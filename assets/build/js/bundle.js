require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var AppsRouter = require('./apps/apps_router');


Application = {

  started: null,

  // Initialize and fire up the application.
  initialize: function () {
    var self = this;
    // Cache user
    // Check if a user is already defined
    if (!_.isUndefined(backendUser)) {
      window.cache.currentUser = backendUser;
    }
    if (!_.isUndefined(systemName)) {
      window.cache.system.name = systemName;
    }

    // Create a user events handler
    _.extend(window.cache.userEvents, Backbone.Events);

    // Mixin backbone events into our pub sub handler
    _.extend(entities.request, Backbone.Events);

    // Mixin backbone events into our rendering event handler
    _.extend(rendering, Backbone.Events);

    if (this.started) {
      self.started = false;
      this.application.initialize();
    } else {
      this.application = AppsRouter.initialize();
      self.started = true;
    }
  }
};

// Backbone Multi-tenant router firing up.
module.exports = Application;

},{"./apps/apps_router":20,"backbone":133,"underscore":159}],2:[function(require,module,exports){
/**
 * This is the main application bootstrap
 * that gets the rest of the apps, routers, etc
 * running.
 */

// Install jQuery plugins
require('blueimp-file-upload/js/vendor/jquery.ui.widget');
i18n = require('i18next-client/i18next.commonjs.withJQuery');
moment = require('moment');

// App
window.Application      = window.Application || {};
window.cache            = { userEvents: {}, currentUser: null, system: {} };

// Events
window.entities = { request: {} };
rendering       = {}

// Set up Backbone to use jQuery
_ = require('underscore');
Backbone = require('backbone');
Backbone.$ = jQuery;

// Load the application
var appr = require('./app-run');
appr.initialize();

},{"./app-run":1,"backbone":133,"blueimp-file-upload/js/vendor/jquery.ui.widget":136,"i18next-client/i18next.commonjs.withJQuery":152,"moment":156,"underscore":159}],3:[function(require,module,exports){

var _ = require('underscore');
var async = require('async');
var Backbone = require('backbone');
var utils = require('../../../mixins/utilities');
var BaseController = require('../../../base/base_controller');
var AdminMainView = require('../views/admin_main_view');


Admin = {};

Admin.ShowController = BaseController.extend({

  events: {
  },

  // Initialize the admin view
  initialize: function (options) {
    this.options = options;
    this.adminMainView = new AdminMainView({
      action: options.action,
      el: this.el
    }).render();
  },

  // Cleanup controller and views
  cleanup: function() {
    this.adminMainView.cleanup();
    removeView(this);
  }

});

module.exports = Admin.ShowController;

},{"../../../base/base_controller":101,"../../../mixins/utilities":128,"../views/admin_main_view":15,"async":131,"backbone":133,"underscore":159}],4:[function(require,module,exports){
module.exports = "<div class=\"row\">\n  <div class=\"col-md-12\">\n    <h2><i class=\"fa fa-newspaper-o\"></i><span class=\"box-icon-text\">Recent Activity</span></h2>\n    <ul class=\"activity-feed list-unstyled\"></ul>\n  </div>\n</div>\n\n<script type=\"text/template\" id=\"newComment\">\n  <li class=\"box-pad-t box-pad-b\">\n    &ldquo;{{comment.value}}&rdquo; said <a href=\"/profile/{{user.id}}\">{{user.name || user.username}}</a> on <a href=\"/{{itemType}}s/{{item.id}}\">{{item.title}}</a>\n    <div class=\"comment-metadata\"><time title=\"{{createdAt}}\">{{createdAtFormatted}}</time></div>\n  </li>\n</script>\n\n<script type=\"text/template\" id=\"newVolunteer\">\n  <li class=\"box-pad-t box-pad-b\">\n    <a href=\"/profile/{{user.id}}\">{{user.name || user.username}}</a> signed up for <a href=\"/tasks/{{task.id}}\">{{task.title}}</a>\n    <div class=\"comment-metadata\"><time title=\"{{createdAt}}\">{{createdAtFormatted}}</time></div>\n  </li>\n</script>\n\n<script type=\"text/template\" id=\"newUser\">\n  <li class=\"box-pad-t box-pad-b\">\n    <a href=\"/profile/{{user.id}}\">{{user.name || user.username}}</a> joined!\n    <div class=\"comment-metadata\"><time title=\"{{createdAt}}\">{{createdAtFormatted}}</time></div>\n  </li>\n</script>\n\n<script type=\"text/template\" id=\"updatedUser\">\n  <li class=\"box-pad-t box-pad-b\">\n    <a href=\"/profile/{{user.id}}\">{{user.name || user.username}}</a> updated their profile\n    <div class=\"comment-metadata\"><time title=\"{{createdAt}}\">{{createdAtFormatted}}</time></div>\n  </li>\n</script>\n\n<script type=\"text/template\" id=\"newTask\">\n  <li class=\"box-pad-t box-pad-b\">\n    <a href=\"/profile/{{user.id}}\">{{user.name || user.username}}</a> posted a new opportunity: <a href=\"/tasks/{{task.id}}\">{{task.title}}</a>\n    <div class=\"comment-metadata\"><time title=\"{{createdAt}}\">{{createdAtFormatted}}</time></div>\n  </li>\n</script>\n";

},{}],5:[function(require,module,exports){
module.exports = "<div class=\"row\">\n  <div class=\"col-sm-6 box-pad-t box-pad-b\">\n    <h2><i class=\"fa fa-line-chart\"></i><span class=\"box-icon-text\" data-i18n=\"InteractionPlural\">Interactions</span></h2>\n    <ul class=\"metrics\">\n      <li>Total Interactions: <%- interactions.count %></li>\n      <ul>\n        <li><span data-i18n=\"Task\">Task</span> Signups: <%- interactions.signups %></li>\n        <li>Assignments: <%- interactions.assignments %></li>\n        <li>Discussion Posts: <%- interactions.posts %></li>\n        <li>Completed Tasks: <%- interactions.completions %></li>\n        <li>Draft Tasks: <%- interactions.drafts %></li>\n        <li>Published Tasks: <%- interactions.publishes %></li>\n      </ul>\n    </ul>\n  </div>\n  <div class=\"col-sm-6 box-pad-t box-pad-b\">\n    <h2><i class=\"fa fa-tags\"></i><span class=\"box-icon-text\" data-i18n=\"TaskPlural\">Tasks</span></h2>\n    <ul class=\"metrics\">\n      <li>Total Created: <%- tasks.count %></li>\n      <ul>\n        <li>Draft: <%- tasks.draft %></li>\n        <li>Open: <%- tasks.open %></li>\n        <li>Assigned: <%- tasks.assigned %></li>\n        <li>Completed: <%- tasks.completed %></li>\n        <li>Archived: <%- tasks.archived %></li>\n      </ul>\n    </ul>\n  </div>\n</div>\n<div class=\"row\">\n  <div class=\"col-sm-6 box-pad-t box-pad-b\">\n    <h2><i class=\"fa fa-user\"></i><span class=\"box-icon-text\">Users</span></h2>\n    <ul class=\"metrics\">\n      <li>Quantity: <%- users.count %></li>\n      <ul><li>Who have created tasks: <%- users.withTasks %></li></ul>\n    </ul>\n  </div>\n  <div class=\"col-sm-6 box-pad-t box-pad-b\">\n    <h2><i class=\"fa fa-rocket\"></i><span class=\"box-icon-text\" data-i18n=\"ProjectPlural\">Projects</span></h2>\n    <ul class=\"metrics\">\n      <li>Total Created: <%- projects.count %></li>\n    </ul>\n  </div>\n</div>\n";

},{}],6:[function(require,module,exports){
module.exports = "<div class=\"alert alert-danger\" style=\"display:none;\">\n</div>\n<div class=\"col-md-12 box box-pad-lr\">\n  <div class=\"row\">\n    <div class=\"col-md-12 sm-nopadding md-nopadding\">\n      <div class=\"fullwidth text-center spinner\">\n        Loading... <i class=\"fa fa-spinner fa-spin\"></i>\n      </div>\n    </div>\n  </div>\n  <div class=\"metric-block\"></div>\n  <div class=\"activity-block\"></div>\n</div>\n";

},{}],7:[function(require,module,exports){
module.exports = "<div class=\"row\">\n  <div class=\"col-sm-3 col-md-3\">\n\n    <nav class=\"navbar admin navbar-default\" role=\"navigation\">\n      <!-- Brand and toggle get grouped for better mobile display -->\n      <div class=\"navbar-header\">\n        <button type=\"button\" class=\"navbar-toggle\" data-toggle=\"collapse\" data-target=\".navbar-ex1-collapse\">\n          <span class=\"sr-only\">Toggle navigation</span>\n          <span class=\"icon-bar\"></span>\n          <span class=\"icon-bar\"></span>\n          <span class=\"icon-bar\"></span>\n        </button>\n        <h2 class=\"box-pad-lr box-pad-t\">Administration</h2>\n      </div>\n\n      <!-- Collect the nav links, forms, and other content for toggling -->\n      <div class=\"collapse navbar-collapse navbar-ex1-collapse\">\n        <ul class=\"nav navbar-nav\">\n          <li><a href=\"/admin/dashboard\" class=\"link-admin\" data-target=\"dashboard\">Dashboard</a></li>\n          <li><a href=\"/admin/users\" class=\"link-admin\" data-target=\"user\">User Management</a></li>\n          <li><a href=\"/admin/tags\" class=\"link-admin\" data-target=\"tag\">Tag Configuration</a></li>\n          <li><a href=\"/admin/tasks\" class=\"link-admin\" data-target=\"tasks\">Tasks</a></li>\n        </ul>\n      </div><!-- /.navbar-collapse -->\n    </nav>\n\n  </div>\n  <div class=\"col-sm-9 col-md-9 sm-nopadding\">\n    <div class=\"admin-container\" id=\"admin-user\">\n    </div>\n    <div class=\"admin-container\" id=\"admin-tag\">\n    </div>\n    <div class=\"admin-container\" id=\"admin-task\">\n    </div>\n    <div class=\"admin-container\" id=\"admin-dashboard\">\n    </div>\n  </div>\n</div>\n";

},{}],8:[function(require,module,exports){
module.exports = "<ul class=\"pagination\" data-filter=\"<% q %>\">\n  <% if (page > 3) { %>\n  <li><a href=\"#\">&laquo;</a></li>\n  <% } %>\n  <%\n  var start = Math.max(1, page-2);\n  var ceil = Math.ceil(count/trueLimit);\n  if (ceil < page + 2) {\n    start = Math.max(1, ceil - 4);\n  }\n  var max = Math.min(page + 2, ceil);\n  if ((ceil > 5) && ((page + 2) < 5)) {\n    max = 5;\n  }\n  %>\n  <% for (var i = start; i <= max; i++) { %>\n  <li <% if (i == page) { %>class=\"active\"<% } %>><a class=\"page\" data-page=\"<%- i %>\" href=\"<%- urlbase %>?p=<%- i %>&q=<%- q %>\"><%- i %> <% if (i == page) { %><span class=\"sr-only\">(current)</span><% } %></a></li>\n  <% } %>\n  <% if (ceil > (page + 2)) { %>\n  <li><a href=\"#\">&raquo;</a></li>\n  <% } %>\n</ul>\n";

},{}],9:[function(require,module,exports){
module.exports = "<div class=\"alert alert-danger\" style=\"display:none;\">\n</div>\n<div class=\"row\">\n  <div class=\"col-md-12 box box-pad-lr\">\n    <div class=\"row\">\n      <div class=\"col-md-12 box-pad-b\">\n        <h2>Find and add tags</h2>\n        <p>Search in the fields below to see existing tags. Type a new tag value to create it.</p>\n        <% _(types).forEach(function(tag) { %>\n          <div class=\"row box-pad-b box-pad-t\">\n            <label for=\"<%= tag %>\" class=\"col-md-2 control-label\"><%= tag %>:</label>\n            <div class=\"col-md-10\">\n              <input type=\"hidden\" id=\"<%= tag %>\" name=\"<%= tag %>\" style=\"width: 100%\"/>\n              <div class=\"form-status text-success\"></div>\n            </div>\n          </div>\n        <% }); %>\n      </div>\n    </div>\n  </div>\n</div>\n";

},{}],10:[function(require,module,exports){
module.exports = "<div class=\"alert alert-danger\" style=\"display:none;\">\n</div>\n<div class=\"row\">\n  <div class=\"col-md-12 box box-pad-lr\">\n    <div class=\"row\">\n      <div class=\"col-md-12\">\n\n        <div role=\"tabpanel\">\n\n          <!-- Nav tabs -->\n          <ul class=\"nav nav-tabs box-pad-t\" role=\"tablist\">\n            <li role=\"presentation\">\n              <a href=\"#drafts\" aria-controls=\"open\" role=\"tab\" data-toggle=\"tab\">\n                Drafts: <%- drafts.length %>\n              </a>\n            </li>\n            <li role=\"presentation\" class=\"active\">\n              <a href=\"#open\" aria-controls=\"open\" role=\"tab\" data-toggle=\"tab\">\n                Open: <%- open.length %>\n              </a>\n            </li>\n            <li role=\"presentation\">\n              <a href=\"#signups\" aria-controls=\"signups\" role=\"tab\" data-toggle=\"tab\">\n                Sign-ups: <%- withSignups.length %>\n              </a>\n            </li>\n            <li role=\"presentation\">\n              <a href=\"#assigned\" aria-controls=\"assigned\" role=\"tab\" data-toggle=\"tab\">\n                Assigned: <%- assigned.length %>\n              </a>\n            </li>\n            <li role=\"presentation\">\n              <a href=\"#completed\" aria-controls=\"completed\" role=\"tab\" data-toggle=\"tab\">\n                Completed: <%- completed.length %>\n              </a>\n            </li>\n          </ul>\n\n          <!-- Tab panes -->\n          <div class=\"tab-content box-pad-t\">\n            <div role=\"tabpanel\" class=\"tab-pane\" id=\"drafts\">\n              <ul class=\"metrics\">\n                <% _(drafts).forEach(function(task) { %>\n                  <li>\n                    <a href=\"/tasks/<%- task.id %>\"><%- task.title %></a>,\n                    <a href=\"/profile/<%- task.user.id %>\"><%- task.user.name || task.user.username %></a>\n                    <% if (task.volunteers.length) { %>\n                    <p>Sign-ups:\n                      <% _(task.volunteers).forEach(function(vol) { %>\n                        <a href=\"/profile/<%- task.user.id %>\"><%- vol.user.name || vol.user.username %></a>\n                      <% }); %>\n                    </p>\n                    <% } %>\n                  </li>\n                <% }); %>\n              </ul>\n            </div>\n            <div role=\"tabpanel\" class=\"tab-pane active\" id=\"open\">\n              <ul class=\"metrics\">\n                <% _(open).forEach(function(task) { %>\n                  <li>\n                    <a href=\"/tasks/<%- task.id %>\"><%- task.title %></a>,\n                    <a href=\"/profile/<%- task.user.id %>\"><%- task.user.name || task.user.username %></a>\n                    <% if (task.volunteers.length) { %>\n                    <p>Sign-ups:\n                      <% _(task.volunteers).forEach(function(vol) { %>\n                        <a href=\"/profile/<%- task.user.id %>\"><%- vol.user.name || vol.user.username %></a>\n                      <% }); %>\n                    </p>\n                    <% } %>\n                  </li>\n                <% }); %>\n              </ul>\n            </div>\n            <div role=\"tabpanel\" class=\"tab-pane\" id=\"signups\">\n              <ul class=\"metrics\">\n                <% _(withSignups).forEach(function(task) { %>\n                  <li>\n                    <a href=\"/tasks/<%- task.id %>\"><%- task.title %></a>,\n                    <a href=\"/profile/<%- task.user.id %>\"><%- task.user.name || task.user.username %></a>\n                    <% if (task.volunteers.length) { %>\n                      <p>Sign-ups:\n                        <% _(task.volunteers).forEach(function(vol) { %>\n                          <a href=\"/profile/<%- task.user.id %>\"><%- vol.user.name || vol.user.username %></a>\n                        <% }); %>\n                      </p>\n                    <% } %>\n                  </li>\n                <% }); %>\n              </ul>\n            </div>\n            <div role=\"tabpanel\" class=\"tab-pane\" id=\"assigned\">\n              <ul class=\"metrics\">\n                <% _(assigned).forEach(function(task) { %>\n                  <li>\n                    <a href=\"/tasks/<%- task.id %>\"><%- task.title %></a>,\n                    <a href=\"/profile/<%- task.user.id %>\"><%- task.user.name || task.user.username %></a>\n                    <% if (task.volunteers.length) { %>\n                      <p>Sign-ups:\n                        <% _(task.volunteers).forEach(function(vol) { %>\n                          <a href=\"/profile/<%- task.user.id %>\"><%- vol.user.name || vol.user.username %></a>\n                        <% }); %>\n                      </p>\n                    <% } %>\n                  </li>\n                <% }); %>\n              </ul>\n            </div>\n            <div role=\"tabpanel\" class=\"tab-pane\" id=\"completed\">\n              <ul class=\"metrics\">\n                <% _(completed).forEach(function(task) { %>\n                  <li>\n                    <a href=\"/tasks/<%- task.id %>\"><%- task.title %></a>,\n                    <a href=\"/profile/<%- task.user.id %>\"><%- task.user.name || task.user.username %></a>\n                    <% if (task.volunteers.length) { %>\n                      <p>Sign-ups:\n                        <% _(task.volunteers).forEach(function(vol) { %>\n                          <a href=\"/profile/<%- task.user.id %>\"><%- vol.user.name || vol.user.username %></a>\n                        <% }); %>\n                      </p>\n                    <% } %>\n                  </li>\n                <% }); %>\n              </ul>\n            </div>\n          </div>\n\n        </div>\n\n      </div>\n    </div>\n  </div>\n</div>\n";

},{}],11:[function(require,module,exports){
module.exports = "<form action=\"\" id=\"reset-password\">\n  <div class=\"modal-body\">\n    <div class=\"alert alert-danger\" style=\"display:none;\">\n    </div>\n    <fieldset>\n      <div class=\"form-group\">\n        <label for=\"newPassword\">New Password for <%- u.name %></label>\n        <input type=\"password\" class=\"form-control\" id=\"newPassword\" name=\"password\" placeholder=\"New Password\" data-validate=\"empty\">\n        <span class=\"help-block error-empty\" style=\"display:none;\">You must enter a password.</span>\n      </div>\n    </fieldset>\n  </div>\n  <div class=\"modal-footer\">\n    <button type=\"button\" class=\"btn btn-c0\" data-dismiss=\"modal\">Cancel</button>\n    <input type=\"submit\" class=\"btn btn-c2\" id=\"submit\" value=\"Change Password\"/>\n  </div>\n</form>\n";

},{}],12:[function(require,module,exports){
module.exports = "<table class=\"table table-hover table-condensed\">\n  <thead>\n    <tr>\n      <th class=\"admin-user-id\">#</th>\n      <th>Name</th>\n      <th>Email</th>\n      <th>Created At</th>\n      <th><span data-i18n=\"ProjectPlural\">Projects</span> (open / closed)</th>\n      <th><span data-i18n=\"TaskPlural\">Tasks</span> (open / assigned / completed / archived)</th>\n      <th>Volunteer (open / assigned / completed / archived)</th>\n      <th class=\"admin-user-checkbox\">Enabled</th>\n      <% if (login.local.enabled === true) { %>\n      <th class=\"admin-user-checkbox\">Password</th>\n      <% } %>\n      <th class=\"admin-user-checkbox\">Admin</th>\n    </tr>\n  </thead>\n  <tbody>\n    <% if (users.length === 0) { %>\n    <tr class=\"empty-row\">\n      <td colspan=\"5\">\n        No users found.\n      </td>\n    </tr>\n    <% } %>\n    <% _.each(users, function (u) { %>\n    <tr data-id=\"<%- u.id %>\">\n      <td>\n        <%- u.id %>\n      </td>\n      <td class=\"admin-table-name\">\n        <%- u.name %>\n      </td>\n      <td class=\"admin-table-username\">\n        <a class=\"link-backbone\" href=\"/profile/<%- u.id %>\"><%- u.username %></a>\n      </td>\n      <td class=\"admin-table-createdat\">\n        <!-- day -->\n        <% var created = new Date(u.createdAt); %>\n        <%= created.toLocaleDateString() %>\n        <!-- time -->\n        <%= created.toLocaleTimeString() %>\n      </td>\n      <td class=\"admin-table-projects\">\n      <% if (u.projectsCreatedOpen !== 0 || u.projectsCreatedClosed !== 0) { %>\n        <a class=\"link-backbone\" href=\"/profile/<%- u.id %>\"><%- u.projectsCreatedOpen %> / <%- u.projectsCreatedClosed %></a>\n      <% } %>\n      </td>\n      <td class=\"admin-table-tasks\">\n      <% if (u.tasksCreatedOpen !== 0 || u.tasksCreatedAssigned !== 0 || u.tasksCreatedCompleted !== 0 || u.tasksCreatedArchived !== 0) { %>\n        <a class=\"link-backbone\" href=\"/profile/<%- u.id %>\"><%- u.tasksCreatedOpen %> / <%- u.tasksCreatedAssigned %> / <%- u.tasksCreatedCompleted %> / <%- u.tasksCreatedArchived %></a>\n      <% } %>\n      </td>\n      <td class=\"admin-table-volunteer\">\n      <% if (u.volCountOpen !== 0 || u.volCountAssigned !== 0 || u.volCountCompleted !== 0 || u.volCountArchived !== 0) { %>\n        <a class=\"link-backbone\" href=\"/profile/<%- u.id %>\"><%- u.volCountOpen %> / <%- u.volCountAssigned %> / <%- u.volCountCompleted %> / <%- u.volCountArchived %></a>\n      <% } %>\n      </td>\n      <td>\n        <button type=\"button\" class=\"btn btn-default btn-xs admin-user-enable\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"Enable\" <% if (u.disabled !== true) { %>style=\"display:none;\"<% } %>><i class=\"fa fa-remove-sign icon-red icon-center\"></i></button>\n        <button type=\"button\" class=\"btn btn-default btn-xs admin-user-disable\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"Disable\" <% if (u.disabled === true) { %>style=\"display:none;\"<% } %>><i class=\"fa fa-check icon-green icon-center\"></i></button>\n        <button type=\"button\" class=\"btn btn-default btn-xs btn-spin\" style=\"display:none;\"><i class=\"fa-spin fa fa-spinner icon-center\"></i></button>\n      </td>\n      <% if (login.local.enabled === true) { %>\n      <td>\n        <button type=\"button\" class=\"btn btn-default btn-xs admin-user-resetpw\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"Reset Password\"><i class=\"fa fa-check fa-cog\"></i></button>\n        <button type=\"button\" class=\"btn btn-default btn-xs admin-user-unlock\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"Unlock User (clear password attempts)\" <% if (u.locked !== true) { %>style=\"display:none;\"<% } %>><i class=\"fa fa-check icon-red fa-lock\"></i></button>\n        <button type=\"button\" class=\"btn btn-default btn-xs btn-spin\" style=\"display:none;\"><i class=\"fa fa-spin fa-spinner icon-center\"></i></button>\n      </td>\n      <% } %>\n      <td>\n        <button type=\"button\" class=\"btn btn-default btn-xs admin-user-rmadmin\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"Remove Admin Priviledges\" <% if (u.isAdmin !== true) { %>style=\"display:none;\"<% } %>><i class=\"fa fa-check icon-green icon-center\"></i></button>\n        <button type=\"button\" class=\"btn btn-default btn-xs admin-user-mkadmin\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"Make Admin\" <% if (u.isAdmin === true) { %>style=\"display:none;\"<% } %>><i class=\"fa fa-times-circle icon-red icon-center\"></i></button>\n        <button type=\"button\" class=\"btn btn-default btn-xs btn-spin\" style=\"display:none;\"><i class=\"fa fa-spin fa-spinner icon-center\"></i></button>\n      </td>\n    </tr>\n    <% }); %>\n  </tbody>\n</table>\n";

},{}],13:[function(require,module,exports){
module.exports = "<div class=\"alert alert-danger\" style=\"display:none;\">\n</div>\n<div id=\"reset-password-container\"></div>\n<div class=\"row\">\n  <div class=\"col-md-12 box box-pad-lr\">\n    <div class=\"row\">\n      <div class=\"col-lg-8 col-md-7 col-sm-5 sm-nopadding md-nopadding\">\n\n      <form class=\"form-inline fullwidth\" role=\"form\">\n        <div class=\"form-group fullwidth\">\n          <label class=\"sr-only\" for=\"user-filter\">Filter</label>\n          <input type=\"text\" class=\"form-control fullwidth\" id=\"user-filter\" placeholder=\"Filter\">\n        </div>\n      </form>\n\n      </div>\n      <div class=\"col-lg-4 col-md-5 col-sm-7 sm-nopadding md-nopadding-right\">\n        <div class=\"pull-right\" id=\"user-page\">\n        </div>\n      </div>\n    </div>\n    <div class=\"row\">\n      <div class=\"col-md-12 sm-nopadding md-nopadding\">\n        <div class=\"fullwidth text-center spinner\">\n          Loading... <i class=\"fa fa-spinner fa-spin\"></i>\n        </div>\n      </div>\n    </div>\n    <div class=\"row\">\n      <div class=\"col-md-12 sm-nopadding md-nopadding\">\n        <div class=\"table-responsive\">\n\n        </div>\n      </div>\n    </div>\n  </div>\n</div>";

},{}],14:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../mixins/utilities');
var ModalComponent = require('../../../components/modal');
var AdminDashboardTemplate = require('../templates/admin_dashboard_template.html');
var AdminDashboardTable = require('../templates/admin_dashboard_table.html');
var AdminDashboardActivities = require('../templates/admin_dashboard_activities.html');
var LoginConfig = require('../../../config/login.json');


var AdminDashboardView = Backbone.View.extend({

  events: {
  },

  initialize: function (options) {
    this.options = options;
    this.data = {
      page: 1
    };
  },

  render: function () {
    var self = this;
    Backbone.history.navigate('/admin/dashboard');
    this.$el.show();
    if (this.rendered === true) {
      return this;
    }
    var data = {
      user: window.cache.currentUser,
      login: LoginConfig
    };
    var template = _.template(AdminDashboardTemplate)(data);
    this.$el.html(template);
    this.rendered = true;
    // fetch data
    this.fetchData(self, this.data);
    return this;
  },

  renderMetrics: function (self, data) {
    var template = _.template(AdminDashboardTable)(data);
    self.$(".metric-block").html(template);
    this.$el.i18n();
    // hide spinner and show results
    self.$(".spinner").hide();
    self.$(".metric-block").show();
  },

  renderActivities: function (self, data) {
    var template = _.template(AdminDashboardActivities);
    self.$(".activity-block").html(template);
    _(data).forEach(function(activity) {
      if (!activity) return;
      // Strip HTML from comments
      if (activity.comment) {
        var value = activity.comment.value.replace(/<(?:.|\n)*?>/gm, '');
        activity.comment.value = value;
      }
      // Format timestamp
      activity.createdAtFormatted = $.timeago(activity.createdAt);
      var template = self.$('#' + activity.type).text(),
          content = _.template(template, { escape: /\{\{(.+?)\}\}/g })(activity);
      self.$('.activity-block .activity-feed').append(content);
    });

    this.$el.i18n();
    // hide spinner and show results
    self.$(".spinner").hide();
    self.$(".activity-block").show();
  },

  fetchData: function (self, data) {
    $.ajax({
      url: '/api/admin/metrics',
      dataType: 'json',
      data: data,
      success: function (data) {
        self.data = data;
        $.ajax({
          url: '/api/admin/interactions',
          dataType: 'json',
          data: data,
          success: function(interactions) {
            data.interactions = interactions;
            interactions.count = _(interactions).reduce(function(sum, value, key) {
              return sum + value;
            }, 0);
            self.renderMetrics(self, data);
          },
          error: function (xhr, status, error) {
            self.handleError(self, xhr, status, error);
          }
        });
      },
      error: function (xhr, status, error) {
        self.handleError(self, xhr, status, error);
      }
    });
    $.ajax({
      url: '/api/admin/activities',
      dataType: 'json',
      data: data,
      success: function (data) {
        self.data = data;
        self.renderActivities(self, data);
      },
      error: function (xhr, status, error) {
        self.handleError(self, xhr, status, error);
      }
    });
  },

  handleError: function (self, xhr, status, error) {
    // show the alert message and hide the spinner
    self.$('.alert').html(error.message || error);
    self.$('.alert').show();
    self.$('.spinner').hide();
  }
});

module.exports = AdminDashboardView;

},{"../../../components/modal":106,"../../../config/login.json":114,"../../../mixins/utilities":128,"../templates/admin_dashboard_activities.html":4,"../templates/admin_dashboard_table.html":5,"../templates/admin_dashboard_template.html":6,"backbone":133,"underscore":159}],15:[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../mixins/utilities');
var AdminUserView = require('./admin_user_view');
var AdminTagView = require('./admin_tag_view');
var AdminTaskView = require('./admin_task_view');
var AdminDashboardView = require('./admin_dashboard_view');
var AdminMainTemplate = require('../templates/admin_main_template.html');


var AdminMainView = Backbone.View.extend({

  events: {
    'click .link-admin'             : 'link'
  },

  initialize: function (options) {
    this.options = options;
  },

  render: function () {
    var data = {

    };
    var template = _.template(AdminMainTemplate)(data);
    this.$el.html(template);
    this.routeTarget(this.options.action || '');
    return this;
  },

  routeTarget: function (target) {
    if (!target) {
      target = 'dashboard';
    }
    var t = $((this.$("[data-target=" + target + "]"))[0]);
    // remove active classes
    $($(t.parents('ul')[0]).find('li')).removeClass('active');
    // make the current link active
    $(t.parent('li')[0]).addClass('active');
    if (target == 'user') {
      if (!this.adminUserView) {
        this.initializeAdminUserView();
      }
      this.hideOthers();
      this.adminUserView.render();
    } else if (target == 'tag') {
      if (!this.adminTagView) {
        this.initializeAdminTagView();
      }
      this.hideOthers();
      this.adminTagView.render();
    } else if (target == 'tasks') {
      if (!this.adminTaskView) {
        this.initializeAdminTaskView();
      }
      this.hideOthers();
      this.adminTaskView.render();
    } else if (target == 'dashboard') {
      if (!this.adminDashboardView) {
        this.initializeAdminDashboardView();
      }
      this.hideOthers();
      this.adminDashboardView.render();
    }
  },

  link: function (e) {
    if (e.preventDefault) e.preventDefault();
    var t = $(e.currentTarget);
    this.routeTarget(t.data('target'));
  },

  hideOthers: function () {
    this.$(".admin-container").hide();
  },

  initializeAdminUserView: function () {
    if (this.adminUserView) {
      this.adminUserView.cleanup();
    }
    this.adminUserView = new AdminUserView({
      el: "#admin-user"
    });
  },

  initializeAdminTagView: function () {
    if (this.adminTagView) {
      this.adminTagView.cleanup();
    }
    this.adminTagView = new AdminTagView({
      el: "#admin-tag"
    });
  },

  initializeAdminTaskView: function () {
    if (this.adminTaskView) {
      this.adminTaskView.cleanup();
    }
    this.adminTaskView = new AdminTaskView({
      el: "#admin-task"
    });
  },

  initializeAdminDashboardView: function () {
    if (this.adminDashboardView) {
      this.adminDashboardView.cleanup();
    }
    this.adminDashboardView = new AdminDashboardView({
      el: "#admin-dashboard"
    });
  },

  cleanup: function () {
    if (this.adminUserView) this.adminUserView.cleanup();
    if (this.adminTagView) this.adminTagView.cleanup();
    if (this.adminTaskView) this.adminTaskView.cleanup();
    if (this.adminDashboardView) this.adminDashboardView.cleanup();
    removeView(this);
  },
});

module.exports = AdminMainView;

},{"../../../mixins/utilities":128,"../templates/admin_main_template.html":7,"./admin_dashboard_view":14,"./admin_tag_view":16,"./admin_task_view":17,"./admin_user_view":19,"backbone":133,"underscore":159}],16:[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../mixins/utilities');
var AdminTagTemplate = require('../templates/admin_tag_template.html');
var TagFactory = require('../../../components/tag_factory');


var AdminTagView = Backbone.View.extend({

  events: {
  },

  initialize: function (options) {
    this.options = options;
    this.tagFactory = new TagFactory();
  },

  render: function () {
    var types = [
      'agency',
      'skill',
      'topic'
    ];
    var data = {
      types: types
    };
    var template = _.template(AdminTagTemplate)(data);
    var self = this;
    this.$el.html(template);
    this.$el.show();

    _(types).forEach(this.tagSelector, this);

    Backbone.history.navigate('/admin/tag');
    return this;
  },

  tagSelector: function(type) {
    var self = this;
    $('#' + type).select2({
      placeholder: 'Search for a tag',
      minimumInputLength: 2,
      formatResult: function (obj, container, query) {
        return obj.name;
      },
      formatSelection: function (obj, container, query) {
        return obj.name;
      },
      createSearchChoice: function (term, values) {
        var vals = values.map(function(value) {
          return value.value.toLowerCase();
        });
        return (vals.indexOf(term.toLowerCase()) >=0) ? false : {
          unmatched: true,
          tagType: type,
          id: term,
          value: term,
          name: "<b>"+term+"</b> <i>click to create a new tag with this value</i>"
        };
      },
      ajax: {
        url: '/api/ac/tag',
        dataType: 'json',
        data: function (term) {
          return {
            type: type,
            q: term
          };
        },
        results: function (data) {
          return { results: data };
        }
      }
    }).on('change', function(e) {
      var $el = self.$(e.currentTarget);
      self.tagFactory.addTagEntities(e.added, self, function() {
        $('#' + type).select2('data', null);
        if (e.added && e.added.value === e.added.id) {
          $el.next('.form-status').text('Added tag: ' + e.added.value);
        } else {
          $el.next('.form-status').text('');
        }
      });
    });
  },

  cleanup: function () {
    removeView(this);
  },
});

module.exports = AdminTagView;

},{"../../../components/tag_factory":112,"../../../mixins/utilities":128,"../templates/admin_tag_template.html":9,"backbone":133,"underscore":159}],17:[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../mixins/utilities');
var AdminTaskTemplate = require('../templates/admin_task_template.html');


var AdminTaskView = Backbone.View.extend({

  events: {
  },

  initialize: function (options) {
    this.options = options;
    this.data = {
      page: 1
    };
  },

  render: function () {
    var self = this;
    $.ajax({
      url: '/api/admin/tasks',
      data: this.data,
      dataType: 'json',
      success: function (data) {
        var template = _.template(AdminTaskTemplate)(data);
        self.$el.html(template);
        self.$el.show();
      },
      error: function (xhr, status, error) {
        self.handleError(self, xhr, status, error);
      }
    });

    Backbone.history.navigate('/admin/tasks');
    return this;
  },

  cleanup: function () {
    removeView(this);
  },

  handleError: function (self, xhr, status, error) {
    // show the alert message and hide the spinner
    self.$('.alert').html(error.message || error);
    self.$('.alert').show();
    self.$('.spinner').hide();
  }

});

module.exports = AdminTaskView;

},{"../../../mixins/utilities":128,"../templates/admin_task_template.html":10,"backbone":133,"underscore":159}],18:[function(require,module,exports){

var Bootstrap = require('bootstrap');
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../mixins/utilities');
var AdminUserPassword = require('../templates/admin_user_password.html');


var AdminUserPasswordView = Backbone.View.extend({

  events: {
    "blur #newPassword"             : "v",
    "submit #reset-password"        : "post"
  },

  initialize: function (options) {
    this.options = options;
  },

  render: function () {
    var data = {
      admin: this.options.admin,
      u: this.options.user
    }
    var template = _.template(AdminUserPassword)(data);
    this.$el.html(template);
    return this;
  },

  v: function (e) {
    return validate(e);
  },

  post: function (e) {
    var self = this;
    if (e.preventDefault) e.preventDefault();

    // validate input fields
    var validateIds = ['#newPassword'];
    var abort = false;
    for (i in validateIds) {
      var iAbort = validate({ currentTarget: validateIds[i] });
      abort = abort || iAbort;
    }
    if (abort === true) {
      return;
    }

    // execute password reset
    var data;
    data = {
      id: this.options.user.id,
      password: this.$("#newPassword").val()
    };

    $.ajax({
      url: '/api/user/resetPassword',
      type: 'POST',
      data: JSON.stringify(data),
      dataType: 'json',
      contentType: 'application/json',
      success: function (data) {
        if (data === true) {
          // collapse modal
          $("#reset-password-modal").modal('hide');
          return;
        }
        self.processError({ message: 'An error occurred while trying to save the password: the server provided an unexpected response.'})
      },
      error: function (xhr, status, error) {
        self.processError(xhr.responseJSON);
      }
    });

  },

  processError: function (e) {
    this.$(".alert").html(e.message || e);
    this.$(".alert").show();
  },

  cleanup: function () {
    removeView(this);
  }

});

module.exports = AdminUserPasswordView;

},{"../../../mixins/utilities":128,"../templates/admin_user_password.html":11,"backbone":133,"bootstrap":138,"underscore":159}],19:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../mixins/utilities');
var ModalComponent = require('../../../components/modal');
var AdminUserPasswordView = require('./admin_user_password_view');
var AdminUserTemplate = require('../templates/admin_user_template.html');
var AdminUserTable = require('../templates/admin_user_table.html');
var Paginate = require('../templates/admin_paginate.html');
var LoginConfig = require('../../../config/login.json');


var AdminUserView = Backbone.View.extend({

  events: {
    "click a.page"              : "clickPage",
    "click .link-backbone"      : linkBackbone,
    "click .admin-user-mkadmin" : "adminCreate",
    "click .admin-user-rmadmin" : "adminRemove",
    "click .admin-user-enable"  : "adminEnable",
    "click .admin-user-disable" : "adminDisable",
    "click .admin-user-unlock"  : "adminUnlock",
    "click .admin-user-resetpw" : "resetPassword",
    "keyup #user-filter"        : "filter"
  },

  initialize: function (options) {
    this.options = options;
    this.data = {
      page: 1
    };
  },

  render: function () {
    var self = this;
    Backbone.history.navigate('/admin/user');
    this.$el.show();
    if (this.rendered === true) {
      return this;
    }
    var data = {
      user: window.cache.currentUser,
      login: LoginConfig
    };
    var template = _.template(AdminUserTemplate)(data);
    this.$el.html(template);
    this.rendered = true;
    // fetch user data
    this.fetchData(self, this.data);
    return this;
  },

  renderUsers: function (self, data) {
    data.urlbase = '/admin/users';
    data.q = data.q || '';
    // if the limit of results coming back hasn't been set yet
    // use the server's default
    if (!self.limit) {
      self.limit = data.limit;
    }
    data.trueLimit = self.limit;
    data.login = LoginConfig;
    data.user = window.cache.currentUser;
    // render the table
    var template = _.template(AdminUserTable)(data);
    // render the pagination
    var paginate = _.template(Paginate)(data);
    self.$("#user-page").html(paginate);
    self.$(".table-responsive").html(template);
    self.$(".btn").tooltip();
    // hide spinner and show results
    self.$(".spinner").hide();
    self.$(".table-responsive").show();
    self.$el.i18n();
  },

  clickPage: function (e) {
    var self = this;
    // if meta or control is held, or if the middle mouse button is pressed,
    // let the link process normally.
    // eg: open a new tab or window based on the browser prefs
    if ((e.metaKey === true) || (e.ctrlKey === true) || (e.which == 2)) {
      return;
    }
    if (e.preventDefault) e.preventDefault();
    // load this page of data
    this.fetchData(self, {
      page: $(e.currentTarget).data('page'),
      q: $($(e.currentTarget).parent('ul')[0]).data('filter'),
      limit: this.limit
    });
  },

  filter: function (e) {
    // get the input box value
    var val = $(e.currentTarget).val().trim();
    // if the filter is the same, don't do anything
    if (val == this.q) {
      return;
    }
    this.q = val;
    // hide the table and show the spinner
    this.$(".table-responsive").hide();
    this.$(".spinner").show();
    // fetch this query, starting from the beginning page
    this.fetchData(this, {
      q: val
    });
  },

  fetchData: function (self, data) {
    // perform the ajax request to fetch the user list
    $.ajax({
      url: '/api/admin/users',
      dataType: 'json',
      data: data,
      success: function (data) {
        self.data = data;
        self.renderUsers(self, data);
      },
      error: function (xhr, status, error) {
        self.handleError(self, xhr, status, error);
      }
    });
  },

  handleError: function (self, xhr, status, error) {
    // show the alert message and hide the spinner
    self.$('.alert').html(error.message || error);
    self.$('.alert').show();
    self.$('.spinner').hide();
  },

  adminCreate: function (e) {
    if (e.preventDefault) e.preventDefault();
    var t = $(e.currentTarget);
    var id = $(t.parents('tr')[0]).data('id');
    this.updateUser(t, {
      id: id,
      isAdmin: true,
      url: '/api/admin/admin/' + id + '?action=true'
    });
  },

  adminRemove: function (e) {
    if (e.preventDefault) e.preventDefault();
    var t = $(e.currentTarget);
    var id = $(t.parents('tr')[0]).data('id');
    this.updateUser(t, {
      id: id,
      isAdmin: false,
      url: '/api/admin/admin/' + id + '?action=false'
    });
  },

  adminEnable: function (e) {
    if (e.preventDefault) e.preventDefault();
    var t = $(e.currentTarget);
    var id = $(t.parents('tr')[0]).data('id');
    this.updateUser(t, {
      id: id,
      disabled: false,
      url: '/api/user/enable/' + id
    });
  },

  adminDisable: function (e) {
    if (e.preventDefault) e.preventDefault();
    var t = $(e.currentTarget);
    var id = $(t.parents('tr')[0]).data('id');
    this.updateUser(t, {
      id: id,
      disabled: true,
      url: '/api/user/disable/' + id
    });
  },

  adminUnlock: function (e) {
    if (e.preventDefault) e.preventDefault();
    var t = $(e.currentTarget);
    var id = $(t.parents('tr')[0]).data('id');
    this.updateUser(t, {
      id: id,
      passwordAttempts: 0,
      url: '/api/admin/unlock/' + id
    });

  },

  updateUser: function (t, data) {
    var self = this;
    var spinner = $($(t.parent()[0]).children('.btn-spin')[0])
    spinner.show();
    t.hide();
    if (data.url) {
      $.ajax({
        url: data.url,
        dataType: 'json',
        success: function (d) {
          // hide the spinner
          spinner.hide();
          // show the opposite button
          if (data.disabled === true) {
            $(t.siblings(".admin-user-enable")[0]).show();
          }
          if (data.disabled === false) {
            $(t.siblings(".admin-user-disable")[0]).show();
          }
          if (data.isAdmin === true) {
            $(t.siblings(".admin-user-rmadmin")[0]).show();
          }
          if (data.isAdmin === false) {
            $(t.siblings(".admin-user-mkadmin")[0]).show();
          }
        },
        error: function (xhr, status, error) {
          self.handleError(self, xhr, status, error);
        }
      });
    }
  },

  resetPassword: function (e) {
    if (e.preventDefault) e.preventDefault();
    if (this.passwordView) { this.passwordView.cleanup(); }
    if (this.modalComponent) this.modalComponent.cleanup();

    var tr = $($(e.currentTarget).parents('tr')[0]);
    var user = {
      id: tr.data('id'),
      name: $(tr.find('td.admin-table-name')[0]).text().trim()
    };

    // set up the modal
    this.modalComponent = new ModalComponent({
      el: "#reset-password-container",
      id: "reset-password-modal",
      modalTitle: "Reset Password"
    }).render();

    // initialize the view inside the modal
    this.passwordView = new AdminUserPasswordView({
      el: ".modal-template",
      user: user
    }).render();

    // render the modal
    this.$("#reset-password-modal").modal('show');
  },

  cleanup: function () {
    removeView(this);
  },
});

module.exports = AdminUserView;

},{"../../../components/modal":106,"../../../config/login.json":114,"../../../mixins/utilities":128,"../templates/admin_paginate.html":8,"../templates/admin_user_table.html":12,"../templates/admin_user_template.html":13,"./admin_user_password_view":18,"backbone":133,"underscore":159}],20:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var i18nOption = require('../config/i18n.json');
var BrowseApp = require('./browse/browse_app');


var initialize = function () {
  var router, browse;

  // Initialize the internationalization library and start Backbone when it's done initializing.
  $.i18n.init(i18nOption, function(t) {
    // Here we are going to fire up all the routers for our app to listen
    // in on their respective applications.  We are -testing- this functionality
    // by using the profile application as a starting point (very simple, 1 route).
    browse = BrowseApp.initialize();

    return Backbone.history.start({ pushState: true });
  });
}

module.exports = {
  initialize: initialize
};

},{"../config/i18n.json":113,"./browse/browse_app":24,"backbone":133,"underscore":159}],21:[function(require,module,exports){
module.exports = "<tr>\n  <td>\n    <span class=\"file-tag c3-bg white\">file</span>\n  </td>\n  <td class=\"attachment-name\">\n    <a href=\"/api/file/get/<%= a.file.id %>\" class=\"file-link\" data-id=\"<%= a.file.id %>\">\n      <%= a.file.name %>\n      <% if (user && ((a.userId == a.userId) || owner)) { %>\n      <a href=\"#\" class=\"file-delete\" data-id=\"<%= a.id %>\"><i class=\"fa fa-remove\"></i></a>\n      <% } %>\n      <br/>\n      <time class=\"timeago\" datetime=\"<%- a.createdAt %>\"><%- a.createdAt %></time>\n    </a>\n  </td>\n  <td class=\"file-person\">\n    <div class=\"project-people-div\" data-userid=\"<%- a.userId %>\">\n      <img src=\"/api/user/photo/<%= a.userId %>\" class=\"project-people\" />\n    </div>\n  </td>\n</tr>\n";

},{}],22:[function(require,module,exports){
module.exports = "<div class=\"box-pad-lr border-bottom\">\n  <h2>\n    Attachments\n    <div class=\"btn btn-c0 btn-sm file-add attachment-filebtn fileinput-button\" style=\"<% if (!user) { %>display:none;<% } %>\">\n      Add File\n      <input id=\"attachment-fileupload\" type=\"file\" name=\"files[]\" title=\"Attach Files\">\n    </div>\n  </h2>\n</div>\n<div class=\"attachment-fileupload box-pad-lr box-pad-t\">\n  <div style=\"display: none;\" class=\"progress progress-striped active\">\n    <div class=\"progress-bar\" style=\"width: 0\"></div>\n  </div>\n</div>\n<div class=\"box-pad-lr\">\n  <div class=\"file-upload-alert alert alert-warning\" style=\"display:none;\">\n    <span></span>\n    <button type=\"button\" class=\"close\" data-dismiss=\"alert\" aria-hidden=\"true\">&times;</button>\n  </div>\n</div>\n<div class=\"box-pad-lr box-pad-t file-list\">\n  <table class=\"table table-hover table-condensed\">\n    <tbody class=\"attachment-tbody\">\n      <tr class=\"attachment-none\"><td>No Attachments</td></tr>\n    </tbody>\n  </table>\n</div>\n";

},{}],23:[function(require,module,exports){

var Bootstrap = require('bootstrap');
var _ = require('underscore');
var jqIframe = require('blueimp-file-upload/js/jquery.iframe-transport');
var jqFU = require('blueimp-file-upload/js/jquery.fileupload.js');
var TimeAgo = require('../../../../vendor/jquery.timeago');
var Backbone = require('backbone');
var utils = require('../../../mixins/utilities');
var async = require('async');
var Popovers = require('../../../mixins/popovers');
var AITemplate = require('../templates/attachment_item_template.html');
var ASTemplate = require('../templates/attachment_show_template.html');


var popovers = new Popovers();

var AttachmentShowView = Backbone.View.extend({

  events: {
    'click .file-delete'                : 'deleteAttachment',
    "mouseenter .project-people-div"    : popovers.popoverPeopleOn,
    "click .project-people-div"         : popovers.popoverClick,
  },

  initialize: function (options) {
    this.options = options;
    this.data = options.data;
    this.action = options.action;
    this.edit = false;
    if (this.options.action) {
      if (this.options.action == 'edit') {
        this.edit = true;
      }
    }
  },

  initializeFiles: function () {
    var self = this;
    $.ajax({
      url: '/api/attachment/findAllBy' + this.options.target + 'Id/' + this.options.id
    }).done(function (data) {
      if (data && (data.length > 0)) {
        $(".attachment-none").hide();
      }
      _.each(data, function (f) {
        var template = self.renderAttachment(f);
        $(".attachment-tbody").append(template);
      });
      $("time.timeago").timeago();
      popovers.popoverPeopleInit(".project-people-div");
    });
  },

  initializeFileUpload: function () {
    var self = this;


    $('#attachment-fileupload').fileupload({
      url: "/api/file/create",
      dataType: 'text',
      acceptFileTypes: /(\.|\/)(gif|jpe?g|png)$/i,
      add: function (e, data) {
        self.$('.attachment-fileupload > .progress').show();
        data.submit();
      },
      progressall: function (e, data) {
        var progress = parseInt(data.loaded / data.total * 100, 10);
        self.$('.attachment-fileupload .progress-bar').css(
          'width',
          progress + '%'
        );
      },
      done: function (e, data) {
        // for IE8/9 that use iframe
        if (data.dataType == 'iframe text') {
          var result = JSON.parse(data.result);
        }
        // for modern XHR browsers
        else {
          var result = JSON.parse($(data.result).text());
        }

        // store id in the database with the file
        var aData = {
          fileId: result[0].id
        };
        aData[self.options.target + 'Id'] = self.options.id;
        $.ajax({
          url: '/api/attachment',
          type: 'POST',
          data: JSON.stringify(aData),
          dataType: 'json',
          contentType: 'application/json'
        }).done(function (attachment) {
          self.$('.attachment-fileupload > .progress').hide();
          self.renderNewAttachment(result[0], attachment);
        });
      },
      fail: function (e, data) {
        // notify the user that the upload failed
        var message = data.errorThrown;
        self.$('.attachment-fileupload > .progress').hide();
        if (data.jqXHR.status == 413) {
          message = "The uploaded file exceeds the maximum file size.";
        }
        self.$(".file-upload-alert > span").html(message)
        self.$(".file-upload-alert").show();
      }
    });

  },

  render: function () {
    data = {
      user: window.cache.currentUser
    };
    var template = _.template(ASTemplate)(data);
    this.$el.html(template);
    this.initializeFileUpload();
    this.initializeFiles();
    return this;
  },

  renderAttachment: function (attachment) {
    var data = {
      a: attachment,
      user: window.cache.currentUser,
      owner: this.options.owner
    };
    var templ = _.template(AITemplate)(data);
    return templ;
  },

  renderNewAttachment: function (file, attachment) {
    attachment.file = file;
    var templ = this.renderAttachment(attachment);
    $(".attachment-none").hide();
    // put new at the top of the list rather than the bottom
    $(".attachment-tbody").prepend(templ);
    $("time.timeago").timeago();
    popovers.popoverPeopleInit(".project-people-div");
  },

  deleteAttachment: function (e) {
    if (e.preventDefault) { e.preventDefault(); }
    $.ajax({
      url: '/api/attachment/' + $(e.currentTarget).data('id'),
      type: 'DELETE',
      success: function (d) {
        // remove from the DOM
        var len = $($(e.currentTarget).parents('tbody')[0]).children().length;
        $(e.currentTarget).parents('tr')[0].remove();
        if (len == 2) {
          $(".attachment-none").show();
        }
      }
    });
  },

  cleanup: function () {
    removeView(this);
  }

});

module.exports = AttachmentShowView;

},{"../../../../vendor/jquery.timeago":130,"../../../mixins/popovers":126,"../../../mixins/utilities":128,"../templates/attachment_item_template.html":21,"../templates/attachment_show_template.html":22,"async":131,"backbone":133,"blueimp-file-upload/js/jquery.fileupload.js":134,"blueimp-file-upload/js/jquery.iframe-transport":135,"bootstrap":138,"underscore":159}],24:[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../mixins/utilities');
var NavView = require('../nav/views/nav_view');
var FooterView = require('../footer/views/footer_view');
var BrowseListController = require('./controllers/browse_list_controller');
var ProjectModel = require('../../entities/projects/project_model');
var ProjectShowController = require('../project/show/controllers/project_show_controller');
var ProfileShowController = require('../profiles/show/controllers/profile_show_controller');
var TaskModel = require('../../entities/tasks/task_model');
var TaskShowController = require('../tasks/show/controllers/task_show_controller');
var TaskEditFormView = require('../tasks/edit/views/task_edit_form_view');
var AdminMainController = require('../admin/controllers/admin_main_controller');
var HomeController = require('../home/controllers/home_controller');


var BrowseRouter = Backbone.Router.extend({

  routes: {
    ''                   : 'showHome',
    'projects(/)'               : 'listProjects',
    'projects/:id(/)'           : 'showProject',
    'projects/:id/:action(/)'   : 'showProject',
    'tasks(/)'                  : 'listTasks',
    'tasks/:id(/)'              : 'showTask',
    'tasks/:id/:action(/)'      : 'showTask',
    'profile(/)'                : 'showProfile',
    'profile/:id(/)'            : 'showProfile',
    'profile/:id(/)/:action'    : 'showProfile',
    'admin(/)'                  : 'showAdmin',
    'admin(/):action(/)'        : 'showAdmin'
  },

  data: { saved: false },

  initialize: function () {
    this.navView = new NavView({
      el: '.navigation'
    }).render();
    this.footerView = new FooterView({
      el: '#footer'
    }).render();
  },

  cleanupChildren: function () {
    if (this.browseListController) { this.browseListController.cleanup(); }
    if (this.projectShowController) { this.projectShowController.cleanup(); }
    if (this.profileShowController) { this.profileShowController.cleanup(); }
    if (this.taskShowController) { this.taskShowController.cleanup(); }
    if (this.homeController) { this.homeController.cleanup(); }
    this.data = { saved: false };
  },

  showHome: function () {
    this.cleanupChildren();
    this.homeController = new HomeController({target: 'home', el: '#container', router: this, data: this.data });
  },

  listProjects: function () {
    this.cleanupChildren();
    this.browseListController = new BrowseListController({
      target: 'projects',
      el: '#container',
      data: this.data
    });
  },

  listTasks: function () {
    this.cleanupChildren();
    this.browseListController = new BrowseListController({
      target: 'tasks',
      el: '#container',
      data: this.data
    });
  },

  showProject: function (id, action) {
    this.cleanupChildren();
    var model = new ProjectModel();
    model.set({ id: id });
    this.projectShowController = new ProjectShowController({ model: model, router: this, id: id, action: action, data: this.data });
  },

  showTask: function (id, action) {
    this.cleanupChildren();
    var model = new TaskModel();
    model.set({ id: id });
    this.taskShowController = new TaskShowController({ model: model, router: this, id: id, action: action, data: this.data });
  },

  showProfile: function (id, action) {
    this.cleanupChildren();
    // normalize input
    if (id) {
      id = id.toLowerCase();
    }
    if (action) {
      action = action.toLowerCase();
    }
    // normalize actions that don't have ids
    if (!action && id) {
      if (id == 'edit') {
        action = id;
        id = window.cache.currentUser.id;
      }
      else if (id == 'settings') {
        action = id;
        id = window.cache.currentUser.id;
      }
    }
    this.profileShowController = new ProfileShowController({ id: id, action: action, data: this.data });
  },

  showAdmin: function (action) {
    this.cleanupChildren();
    this.adminMainController = new AdminMainController({
      el: "#container",
      action: action
    });
  }

});

var initialize = function () {
  var router = new BrowseRouter();
  return router;
}

module.exports = {
  initialize: initialize
};


},{"../../entities/projects/project_model":122,"../../entities/tasks/task_model":124,"../../mixins/utilities":128,"../admin/controllers/admin_main_controller":3,"../footer/views/footer_view":47,"../home/controllers/home_controller":48,"../nav/views/nav_view":57,"../profiles/show/controllers/profile_show_controller":60,"../project/show/controllers/project_show_controller":72,"../tasks/edit/views/task_edit_form_view":87,"../tasks/show/controllers/task_show_controller":93,"./controllers/browse_list_controller":25,"backbone":133,"underscore":159}],25:[function(require,module,exports){

var Bootstrap = require('bootstrap');
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../mixins/utilities');
var BaseController = require('../../../base/base_controller');
var BrowseMainView = require('../views/browse_main_view');
var ProjectsCollection = require('../../../entities/projects/projects_collection');
var TasksCollection = require('../../../entities/tasks/tasks_collection');
var TaskModel = require('../../../entities/tasks/task_model');
var ProjectFormView = require('../../project/new/views/project_new_form_view');
var TaskFormView = require('../../tasks/new/views/task_form_view');
var ModalWizardComponent = require('../../../components/modal_wizard');
var ModalComponent = require('../../../components/modal');


Browse = {};

Browse.ListController = BaseController.extend({

  events: {
    "click .link-backbone"  : linkBackbone,
    "click .project-background-image" : "showProject",
    "click .task-box"       : "showTask",
    "click .add-project"    : "addProject",
    "click .add-opportunity": "addTask"
  },

  initialize: function ( options ) {
    var self = this;
    // this.options = options;
    this.target = options.target;
    this.fireUpCollection();
    this.initializeView();

    this.collection.trigger('browse:' + this.target + ":fetch");

    this.listenTo(this.projectsCollection, "project:save:success", function (data) {
      // hide the modal
      $('#addProject').bind('hidden.bs.modal', function() {
        Backbone.history.navigate('projects/' + data.attributes.id, { trigger: true });
      }).modal('hide');
    });

    this.listenTo(this.tasksCollection, "task:save:success", function (data) {
      // hide the modal
      $('#addTask').bind('hidden.bs.modal', function() {
        Backbone.history.navigate('tasks/' + data, { trigger: true });
      }).modal('hide');
    });

  },

  initializeView: function () {
    if (this.browseMainView) {
      this.browseMainView.cleanup();
    }
    this.browseMainView = new BrowseMainView({
      el: "#container",
      target: this.target,
      collection: this.collection
    }).render();
  },

  fireUpCollection: function () {
    var self = this;
    this.projectsCollection = new ProjectsCollection();
    this.tasksCollection = new TasksCollection();
    if (this.target == 'projects') {
      this.collection = this.projectsCollection;
    }
    else if (this.target == 'tasks') {
      this.collection = this.tasksCollection;
    }
    else {
      this.collection = new ProfilesCollection();
    }
    this.listenToOnce(this.collection, 'browse:' + this.target + ":fetch", function () {
      self.collection.fetch({
        success: function (collection) {
          self.collection = collection;
          self.browseMainView.renderList(self.collection.toJSON());
        }
      })
    })
  },

  // -----------------------
  //= BEGIN CLASS METHODS
  // -----------------------
  showProject: function (e) {
    if (e.preventDefault) e.preventDefault();
    var id = $($(e.currentTarget).parents('li.project-box')[0]).data('id');
    Backbone.history.navigate('projects/' + id, { trigger: true });
  },

  showTask: function (e) {
    if (e.preventDefault) e.preventDefault();
    var id = $(e.currentTarget).data('id') || $($(e.currentTarget).parents('li.task-box')[0]).data('id');
    Backbone.history.navigate('tasks/' + id, { trigger: true });
  },

  addProject: function (e) {
    if (e.preventDefault) e.preventDefault();

    if (this.projectFormView) this.projectFormView.cleanup();
    if (this.modalComponent) this.modalComponent.cleanup();

    this.modalComponent = new ModalComponent({
      el: ".wrapper-addProject",
      id: "addProject",
      modalTitle: "Add " + i18n.t("Project")
    }).render();

    this.projectFormView = new ProjectFormView({
      el: ".modal-template",
      collection: this.projectsCollection
    }).render();

  },

  addTask: function (e) {
    if (e.preventDefault) e.preventDefault();

    if (this.taskFormView) this.taskFormView.cleanup();
    if (this.modalWizardComponent) this.modalWizardComponent.cleanup();

    this.taskModel = new TaskModel();
    this.modalWizardComponent = new ModalWizardComponent({
      el: ".wrapper-addTask",
      id: "addTask",
      draft: true,
      modalTitle: 'New ' + i18n.t('Opportunity'),
      model: this.taskModel,
      collection: this.tasksCollection,
      modelName: 'task',
      data: function (parent) { return {
        title: parent.$("#task-title").val(),
        description: parent.$("#task-description").val(),
        // these tasks are orphaned
        projectId: null
      } }
    }).render();

    this.taskFormView = new TaskFormView({
      el: "#addTask .modal-body",
      projectId: null,
      model: this.taskModel,
      tasks: this.tasksCollection
    }).render();
    this.modalWizardComponent.setChildView(this.taskFormView);
    this.modalWizardComponent.setNext(this.taskFormView.childNext);
    this.modalWizardComponent.setSubmit(this.taskFormView.childNext);
  },

  // ---------------------
  //= UTILITY METHODS
  // ---------------------
  cleanup: function() {
    if (this.taskFormView) { this.taskFormView.cleanup(); }
    if (this.modalWizardComponent) { this.modalWizardComponent.cleanup(); }
    if (this.projectFormView) { this.projectFormView.cleanup(); }
    if (this.modalComponent) { this.modalComponent.cleanup(); }
    if (this.browseMainView) { this.browseMainView.cleanup(); }
    removeView(this);
  }

});

module.exports = Browse.ListController;

},{"../../../base/base_controller":101,"../../../components/modal":106,"../../../components/modal_wizard":110,"../../../entities/projects/projects_collection":123,"../../../entities/tasks/task_model":124,"../../../entities/tasks/tasks_collection":125,"../../../mixins/utilities":128,"../../project/new/views/project_new_form_view":71,"../../tasks/new/views/task_form_view":92,"../views/browse_main_view":32,"backbone":133,"bootstrap":138,"underscore":159}],26:[function(require,module,exports){
module.exports = "<div class=\"wrapper-addProject\"></div>\n<div class=\"wrapper-addTask\"></div>\n\n<div class=\"row search-row\">\n  <div class=\"col-md-3 col-md-push-9 browse-buttons\">\n    <% if (ui.project.show) { %>\n    <a href=\"#addProject\" class=\"btn btn-c2 add-project\" data-toggle=\"modal\" data-backdrop=\"static\" style=\"<% if (!user) { %>display: none;<% } %>\"><i class=\"fa fa-plus\"></i> <span data-i18n=\"Project\">Project</span></a>\n    <% } %>\n    <a href=\"#addTask\" class=\"btn btn-c2 add-opportunity\" data-toggle=\"modal\" data-backdrop=\"static\" style=\"<% if (!user) { %>display: none;<% } %>\"><i class=\"fa fa-plus\"></i> <span data-i18n=\"Task\">Opportunity</span></a>\n  </div>\n  <div class=\"col-md-9 col-md-pull-3\">\n    <form class=\"form-horizontal\" role=\"form\" id=\"search-form\">\n\n      <div class=\"form-group row\">\n        <div class=\"col-sm-10 col-md-10 col-lg-9 input-search\">\n          <input type=\"hidden\" id=\"search\" title=\"Search\" style=\"width: 100%\"/>\n        </div>\n        <div class=\"col-sm-2 col-md-2 col-lg-3 btn-search\">\n          <input type=\"submit\" class=\"btn btn-c1\" title=\"Search\" value=\"Search\"/>\n        </div>\n      </div>\n\n    </form>\n  </div>\n</div>\n<div class=\"row\">\n\n  <div class=\"col-md-3 col-md-push-9 box\">\n    <div class=\"border-bottom box-pad-lr\">\n      <h2>Filters</h2>\n    </div>\n    <div class=\"box-pad-t\">\n      <% if ( target == \"tasks\" ) {%>\n      <div class=\"box-pad-lr\" id=\"stateFilters\">\n        <% _.each(ui.states, function (t) { %>\n          <label class=\"<% if ( t.value == \"draft\" ) { %>hidden draft-filter<% } %>\">\n            <input type='checkbox' name='state<%- t.label %>' class='stateFilter' value='<%- t.value %>'\n            <% if ( t.value == \"open\" ) {%>\n              <%- checked=\"checked\" %>\n            <% } %>\n            > <%- t.label %>\n          </label>\n        <% }); %>\n      </div>\n      <% } %>\n      <div id=\"search-projs-wrapper\" class=\"box-pad-lr\">\n        <ul id=\"search-projs\" class=\"nav nav-pills nav-stacked nav-search\">\n        </ul>\n      </div>\n      <div class=\"box-pad-lr\">\n        <ul id=\"search-tags\" class=\"nav nav-pills nav-stacked nav-search\">\n        </ul>\n      </div>\n      <div class=\"box-pad-lr search-clear\" style=\"display: none;\">\n        <div class=\"align-right\">\n          <a href=\"#\" id=\"search-clear\" class=\"btn btn-sm btn-c0\"><i class=\"fa fa-remove\"></i> Clear Search Criteria</a>\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"col-md-9 col-md-pull-3\">\n    <div id=\"browse-search-spinner\" class=\"fullwidth text-center\">\n      Loading... <i class=\"fa fa-spinner fa-spin\"></i>\n    </div>\n    <ul id=\"browse-list\">\n    </ul>\n  </div>\n\n</div>\n";

},{}],27:[function(require,module,exports){
module.exports = "<li data-id=\"<%= data.id %>\">\n  <%= format %>\n  <div class=\"pull-right\">\n    <a href=\"#\" class=\"search-tag-remove\"><i class=\"fa fa-remove\"></i></a>\n  </div>\n</li>\n";

},{}],28:[function(require,module,exports){
module.exports = "<span data-i18n='[html]noSearchResults.text'>\n<h2>Oops we didn't find any results</h2>\n<p>Maybe your search was too specific. You could try including more filters like <b>Completed</b> or <b>Archived</b>. Maybe there are too many search terms, try removing some or using more general terms.</p>\n<p>Still not finding what you wanted?</p>\n<p>Did you mean to:</p>\n</span>\n\t<ul>\n\t\t<% if (ui.project.show) { %>\n\t\t<li>Look for <span data-i18n=\"ProjectIndefinite\">a Project</span>? Try going to Browse <span data-i18n=\"ProjectPlural\">Projects</span> or clicking <a href='/projects'>here</a> .</li>\n\t\t<% } %>\n\t\t<li>Look for <span data-i18n=\"TaskIndefinite\">a Task</span>? Try going to Browse <span data-i18n=\"TaskPlural\">Tasks</span> or clicking <a href='/tasks'>here</a> . </li>\n\t\t<% if (ui.faq.show) { %>\n\t\t<li>Get an answer to a general question? Try reading the FAQ by clicking <a href='<%- ui.faq.url %>'>here</a> .</li>\n\t\t<% } %>\n\t\t<li>Get an answer to a specific question you can't find elsewhere? Trying <a href='mailto:<%- ui.systemEmail %>'>sending an email to the team .</a></li>\n\t</ul>";

},{}],29:[function(require,module,exports){
module.exports = "<li data-id=\"<%- item.id %>\" class=\"box project-box\">\n  <% if (item.coverId) { %>\n  <div class=\"project-background-image border-bottom\" style=\"background-image: url(/api/file/get/<%= item.coverId %>)\">\n  <% } else { %>\n  <div class=\"project-background-image border-bottom project-background-image-default\">\n  <% } %>\n  </div>\n  <div class=\"project-title\">\n    <a href=\"/projects/<%- item.id %>\" class=\"link-backbone c1\">\n      <%- item.title %>\n    </a>\n  </div>\n  <div class=\"project-list-description\">\n    <%= item.descriptionHtml %>\n  </div>\n\n  <div class=\"project-list-bottom-wrapper border-top\">\n    <div class=\"project-list-counts\">\n      <div class=\"project-list-counts-col\">\n        <div class=\"project-list-count c2\">\n          <%- item.taskCount %>\n        </div>\n        <div class=\"project-list-count-text c2\">\n          opp<% if (item.taskCount != 1) { %>s<% } %>\n        </div>\n      </div>\n      <div class=\"project-list-counts-col\">\n        <div class=\"project-list-count c2\">\n          <%- item.commentCount %>\n        </div>\n        <div class=\"project-list-count-text c2\">\n          comment<% if (item.commentCount != 1) { %>s<% } %>\n        </div>\n      </div>\n      <div class=\"project-list-counts-col\">\n        <div class=\"project-list-count c2\">\n          <%- item.ownerCount %>\n        </div>\n        <div class=\"project-list-count-text c2  \">\n          <% if (item.ownerCount != 1) { %>people<% } else { %>person<% } %>\n        </div>\n      </div>\n    </div>\n  </div>\n</li>";

},{}],30:[function(require,module,exports){
module.exports = "<li data-id=\"<%- item.id %>\" class=\"box task-box\">\n\n    <div class=\"task-list-title task-title-overflow-multi\">\n      <a href=\"/tasks/<%- item.id %>\" class=\"link-backbone c1\">\n        <%- item.title %>\n      </a>\n    </div>\n\n  <div class=\"task-list-description task-desc-overflow-multi\">\n    <%= item.descriptionHtml %>\n  </div>\n\n  <div class=\"task-list-bottom border-top\">\n\n    <% _.each(tagShow, function (tagType) { %>\n\n      <% if (tags[tagType]) { %>\n      <div class=\"task-list-tags c0 task-single-overflow\">\n        <i class=\"task-list-icon-center <%= tagConfig.tags[tagType].icon %>\"></i>\n        <% _.each(tags[tagType], function (t, i) { %>\n          <%= t.name %><% if (i + 1 < tags[tagType].length) { %>,<% } %>\n        <% }); %>\n      </div>\n      <% } %>\n\n    <% }); %>\n\n  </div>\n  <div class=\"task-list-bottom-person border-top\">\n    <div class=\"task-list-person\">\n      <div class=\"project-people-div float-left\" data-userid=\"<%= item.userId %>\" style=\"text-align: right;\">\n        <img src=\"/api/user/photo/<%= item.userId %>\" class=\"project-people\"/>\n      </div>\n      <div class=\"task-list-requestbox\">\n        <div class=\"task-list-requested\">requested by</div>\n        <div class=\"task-list-name\"><%- item.user.name %></div>\n        <% if (item.user.agency) { %>\n        <div class=\"task-list-agency task-single-overflow\"><%= item.user.agency.tag.name %></div>\n        <% } %>\n      </div>\n    </div>\n\n  </div>\n\n</li>";

},{}],31:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var async = require('async');
var utils = require('../../../mixins/utilities');
var UIConfig = require('../../../config/ui.json');
var marked = require('marked');
var TagConfig = require('../../../config/tag');
var ProjectListItem = require('../templates/project_list_item.html');
var TaskListItem = require('../templates/task_list_item.html');
var NoListItem = require('../templates/no_search_results.html');


var BrowseListView = Backbone.View.extend({

  initialize: function (options) {
    var self = this;

    var pageSize = 27;
    if (UIConfig.browse && UIConfig.browse.pageSize)
      pageSize = UIConfig.browse.pageSize;

    this.options = options;
    this.data = {
      pageSize: pageSize,
      page: 1
    }
    $(window).on('scroll',function(e){
      self.scrollCheck(e);
    });
  },

  organizeTags: function (tags) {
    // put the tags into their types
    var outTags = {};
    for (t in tags) {
      if (!(_.has(outTags, tags[t].tag.type))) {
        outTags[tags[t].tag.type] = [];
      }
      outTags[tags[t].tag.type].push(tags[t].tag);
    }
    return outTags;
  },

  scrollCheck: function(e) {
    var currentScrollPos = $(window).scrollTop();
    var currentMaxHeight = $('#container').height();
    var buffer           = 600;

    if ( (this.options.collection.length / this.data.page) > 1 && Math.ceil(this.options.collection.length / this.data.pageSize) >= this.data.page && currentScrollPos + buffer > currentMaxHeight ){
      this.data.page += 1;
      this.render();
    }
  },

  render: function () {

    //settings for infinite scroll
    if ( UIConfig.browse && UIConfig.browse.useInfiniteScroll ) {
      if ( this.data.page == 1 ){
        var start = 0;
      } else {
        var start = (this.data.page-1) * this.data.pageSize;
      }
      var limit    = start + this.data.pageSize;
    } else {
      //reset page to 1 and return
      if ( this.data.page > 1 ) {
        this.data.page = 1;
        return this;
      }
      var limit = this.options.collection.length;
      var start = 0;
    }

    if ( this.options.collection.length == 0 ){
      var settings = {
        ui: UIConfig
      }
      compiledTemplate = _.template(NoListItem)(settings);
      this.$el.append(compiledTemplate);
    } else {

      for ( i = start; i < limit; i++ ){

      if ( typeof this.options.collection[i] == 'undefined' ){ break; }
        var item = {
          item: this.options.collection[i],
          user: window.cache.currentUser,
          tagConfig: TagConfig,
          tagShow: ['location', 'skill', 'topic', 'task-time-estimate', 'task-time-required']
        }
        if (this.options.collection[i].tags) {
          item.tags = this.organizeTags(this.options.collection[i].tags);
        } else {
          item.tags =[];
        }
        if (this.options.collection[i].description) {
          item.item.descriptionHtml = marked(this.options.collection[i].description);
        }
        var compiledTemplate = '';
        if (this.options.target == 'projects') {
          compiledTemplate = _.template(ProjectListItem)(item);
        } else {
          compiledTemplate = _.template(TaskListItem)(item);
        }
        this.$el.append(compiledTemplate);
      }
    }
    this.$el.i18n();
    return this;
  },

  cleanup: function () {
    removeView(this);
  }

});

module.exports = BrowseListView;

},{"../../../config/tag":115,"../../../config/ui.json":116,"../../../mixins/utilities":128,"../templates/no_search_results.html":28,"../templates/project_list_item.html":29,"../templates/task_list_item.html":30,"async":131,"backbone":133,"marked":155,"underscore":159}],32:[function(require,module,exports){
var select2 = require('select2');
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../mixins/utilities');
var UIConfig = require('../../../config/ui.json');
var Popovers = require('../../../mixins/popovers');
var TagConfig = require('../../../config/tag');
var BrowseListView = require('./browse_list_view');
var BrowseMainTemplate = require('../templates/browse_main_view_template.html');
var BrowseSearchTag = require('../templates/browse_search_tag.html');


var popovers = new Popovers();

var BrowseMainView = Backbone.View.extend({

  events: {
    "submit #search-form"             : "search",
    "click .search-tag-remove"        : "searchTagRemove",
    "click .search-clear"             : "searchClear",
    "change .stateFilter"             : "searchTagRemove",
    "mouseenter .project-people-div"  : popovers.popoverPeopleOn,
    "click      .project-people-div"  : popovers.popoverClick,
    "keyup .select2-container"        : "submitOnEnter"
  },

  initialize: function (options) {
    this.options = options;
  },

  render: function () {
    var options = {
      target: this.options.target,
      user: window.cache.currentUser,
      ui: UIConfig
    };
    this.compiledTemplate = _.template(BrowseMainTemplate)(options)
    this.$el.html(this.compiledTemplate);
    this.$el.i18n();

    this.initializeSearch();

    // Allow chaining.
    return this;
  },

  format: function (self, object, container, query) {
    var name = object.name || object.title;
    var icon = this.tagIcon[object.type];
    if (object.target == 'project') {
      icon = 'fa fa-folder-o';
    } else if (object.target == 'task') {
      icon = 'fa fa-tag';
    }
    return '<i class="' + icon + '"></i> <span class="box-icon-text">' + name + '</span>';
  },

  initializeSearch: function() {
    var self = this;
    this.searchTerms = [];
    this.tags = [];

    // figure out which tags apply
    for (var i = 0; i < TagConfig[this.options.target].length; i++) {
      this.tags.push(TagConfig.tags[TagConfig[this.options.target][i]]);
    }

    // extract tag icons and classes
    this.tagIcon = {};
    this.tagClass = {};
    for (var i = 0; i < this.tags.length; i++) {
      this.tagIcon[this.tags[i].type] = this.tags[i].icon;
      this.tagClass[this.tags[i].type] = this.tags[i]['class'];
    }

    var formatResult = function (object, container, query) {
      return self.format(self, object, container, query);
    };

    // Initialize Select2
    $("#search").select2({
      placeholder: 'I\'m looking for...',
      multiple: true,
      formatResult: formatResult,
      formatSelection: function(object,container,query) {
          //null object.target to remove the task / project icons that get readded when terms go
          //     to the search box on the right
          object.target = null;
          object.type   = object.name || object.title;
          object.id     = object.name || object.title;
          object.value  = object.name || object.title;
          object.unmatched = true;
          return object.name || object.title;
      },
      createSearchChoice: function (term) {
          return { unmatched: true,id: term, value: term, name: "<b>"+term+"</b> <i>click to text search for this value.</i>" };
      },
      ajax: {
        url: '/api/ac/search/' + self.options.target,
        dataType: 'json',
        data: function (term) {
          return {
            type: TagConfig[self.options.target].join(),
            q: term
          };
        },
        results: function (data) {
          return { results: data };
        }
      }
    }).on("select2-selecting", function (e){
        if ( e.choice.hasOwnProperty("unmatched") && e.choice.unmatched ){
          //remove the hint before adding it to the list
          e.choice.name = e.val;
        }
      });
  },

  submitOnEnter: function (e) {
    if(e.keyCode === 13) {
      this.search(e);
    }
  },

  search: function (e) {
    var self = this;
    if (e.preventDefault) e.preventDefault();
    // get values from select2
    var data = $("#search").select2("data");
    if (data.length > 0) {
      $("#search-none").hide();
      $(".search-clear").show();
    }
    _.each(data, function (d) {
      var found = false;
      // check if this search term already is chosen
      for (var i in self.searchTerms) {
        if (self.searchTerms[i].id == d.id) {
          if (self.searchTerms[i].title && (self.searchTerms[i].title == d.title)) {
            found = true;
          }
          else if (self.searchTerms[i].name && (self.searchTerms[i].name == d.name)) {
            found = true;
          }
        }
      }
      // return if the search term is found
      if (found) return;
      // add it to our list of search terms
      self.searchTerms.push(d);
      // render the search term in the list
      var templData = {
        data: d,
        format: self.format(self, d)
      };
      var templ = _.template(BrowseSearchTag)(templData);
      if (d.target == 'tagentity') {
        $("#search-tags").append(templ);
      } else {
        $("#search-projs").append(templ);
      }
    });
    $("#search").select2("data","");
    self.searchExec(self.searchTerms);
  },

  renderList: function (collection) {
    // create a new view for the returned data
    if (this.browseListView) { this.browseListView.cleanup(); }

    var filteredCollection = this.applyStateFilters(collection);

    this.browseListView = new BrowseListView({
      el: '#browse-list',
      target: this.options.target,
      collection: filteredCollection,
    });
    // Show draft filter
    var draft = _(collection).chain()
          .pluck('state')
          .indexOf('draft').value() >= 0;
    $(".draft-filter").toggleClass('hidden', !draft);
    $("#browse-search-spinner").hide();
    $("#browse-list").show();
    this.browseListView.render();
    popovers.popoverPeopleInit(".project-people-div");
  },

  searchExec: function (terms) {
    var self = this;

    if (!terms || (terms.length == 0)) {
      // re-render the collection
      self.renderList(this.options.collection.toJSON());
      return;
    }

    // create a search object
    var data = {
      items: [],
      tags: [],
      freeText: [],
      target: self.options.target
    };
    _.each(terms, function (t) {
      if ( t.unmatched ) {
        data.freeText.push(t.value);
      } else {
        data.items.push(t.id);
      }
    });
    $.ajax({
      url: '/api/search',
      type: 'POST',
      data: JSON.stringify(data),
      dataType: 'json',
      contentType: 'application/json'
    }).done(function (data) {
      // render the search results
      self.renderList(data);
    });
  },

  applyStateFilters: function (data) {

    if ( !_.isObject(data) || !$("#stateFilters").length ){ return data; }
    var keepers = [];
    //get check stateFilter inputs
    var inputs = $(".stateFilter:checked");

    _.each(data,function(item){
      _.each(inputs,function(test){
         if ( item.state == test.value ){
           keepers.push(item);
         }
      });
    });

    return keepers;
  },

  searchTagRemove: function (e) {
    if (e.preventDefault) e.preventDefault();

    var self = this;

    if ( $(e.currentTarget).hasClass("stateFilter") ){
      if ( $("#search-tags").length > 0 ) {
        var parent = $("#search-tags");
        var id = "search-tags";
        var project = false;
      }
    } else {
      var parent = $(e.currentTarget).parents('li')[0];
      var id = $(parent).data('id');
      var type = $($(e.currentTarget).parents('ul')[0]).attr('id');
      var project = false;

      if (type == 'search-projs') {
        project = true;
      }
    }

    for (i in self.searchTerms) {
      if (self.searchTerms[i].id == id) {
        if (project && self.searchTerms[i].title) {
          self.searchTerms.splice(i, 1);
          break;
        } else if (self.searchTerms[i].name) {
          self.searchTerms.splice(i, 1);
          break;
        }
      }
    }

    if ( !$(e.currentTarget).hasClass("stateFilter") ){
      parent.remove();
    }
    if (self.searchTerms.length == 0) {
      $("#search-none").show();
      $(".search-clear").hide();
    }
    self.searchExec(self.searchTerms);
  },

  searchClear: function (e) {
    if (e.preventDefault) e.preventDefault();
    this.searchTerms = [];
    $("#search-projs").children().remove();
    $("#search-tags").children().remove();
    $("#search-none").show();
    $(".search-clear").hide();
    this.searchExec(self.searchTerms);
  },

  cleanup: function() {
    if (this.browseListView) { this.browseListView.cleanup(); }
    removeView(this);
  }

});

module.exports = BrowseMainView;

},{"../../../config/tag":115,"../../../config/ui.json":116,"../../../mixins/popovers":126,"../../../mixins/utilities":128,"../templates/browse_main_view_template.html":26,"../templates/browse_search_tag.html":27,"./browse_list_view":31,"backbone":133,"select2":157,"underscore":159}],33:[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var TimeAgo = require('../../../../../vendor/jquery.timeago');
var Popovers = require('../../../../mixins/popovers');
var CommentCollection = require('../../../../entities/comments/comment_collection');
var CommentFormView = require('../../new/views/comment_form_view');
var CommentItemView = require('../views/comment_item_view');
var CommentWrapper = require('../templates/comment_wrapper_template.html');


var popovers = new Popovers();

Comment = Backbone.View.extend({

  el: ".comment-list-wrapper",

  events: {
    "click .new-topic"                  : "newTopic",
    "click .comment-expand"             : "topicExpand",
    "click .comment-contract"           : "topicContract",
    "mouseenter .comment-user-link"     : popovers.popoverPeopleOn,
    "click .comment-user-link"          : popovers.popoverClick,
    "click .link-backbone"              : linkBackbone,
    "click a[href='#reply-to-comment']" : "reply"
  },

  initialize: function (options) {
    var self = this;
    this.options = options;

    this.initializeRender();
    this.initializeCommentCollection();
    this.initializeListeners();

    // Populating the DOM after a comment was created.
    this.listenTo(this.commentCollection, "comment:save:success", function (model, modelJson, currentTarget) {
      if (modelJson.topic) {
        // cleanup the topic form
        if (this.topicForm) this.topicForm.cleanup();
      }
      self.addNewCommentToDom(modelJson, currentTarget);
    });

  },

  initializeRender: function() {
    var template = _.template(CommentWrapper)({ user: window.cache.currentUser });
    this.$el.html(template);
  },

  initializeCommentCollection: function () {
    var self = this;

    if (this.commentCollection) { this.renderView() }
    else { this.commentCollection = new CommentCollection(); }

    this.commentCollection.fetch({
      url: '/api/comment/findAllBy' + this.options.target + 'Id/' + this.options.id,
      success: function (collection) {
        self.collection = collection;
        self.renderView(collection);
      }
    });
  },

  initializeListeners: function() {
    var self = this;

    this.listenTo(this.commentCollection, "comment:topic:new", function (value) {
      var data = {
        value: value,
        topic: true
      };
      data[self.options.target + 'Id'] = self.options.id;

      // TODO: DM: Fix this to add to the collection appropriately,
      // and fetch/re-render as needed.  This is a hack to get it to work
      $.ajax({
        url: '/api/comment',
        type: 'POST',
        contentType: 'application/json',
        processData: false,
        data: JSON.stringify(data)
      }).done(function (result) {
        self.commentCollection.fetch({
          url: '/api/comment/findAllBy' + self.options.target + 'Id/' + self.options.id,
          success: function (collection) {
          }
        });
      });
    });
  },

  renderView: function (collection) {
    var self = this;
    this.parentMap = {};
    this.topics = [];
    var data = {
      comments: collection.toJSON()[0].comments
    };

    // compute the depth of each comment to use as metadata when rendering
    // in the process, create a map of the ids of each comment's children
    var depth = {};
    if (!data.comments) {
      data.comments = [];
    }
    for (var i = 0; i < data.comments.length; i += 1) {
      if (data.comments[i].topic === true) {
        depth[data.comments[i].id] = 0;
        data.comments[i]['depth'] = depth[data.comments[i].id];
        this.topics.push(data);
      } else {
        depth[data.comments[i].id] = depth[data.comments[i].parentId] + 1;
        data.comments[i]['depth'] = depth[data.comments[i].id];
        // augment the parentMap with this comment
        if (_.isUndefined(this.parentMap[data.comments[i].parentId])) {
          this.parentMap[data.comments[i].parentId] = [];
        }
        this.parentMap[data.comments[i].parentId].push(data.comments[i].id);
      }
    }

    // hide the loading spinner
    this.$('.comment-spinner').hide();

    this.commentViews = [];
    this.commentForms = [];
    if (data.comments.length == 0) {
      this.$('#comment-empty').show();
    }
    _.each(data.comments, function (comment, i) {
      self.renderComment(self, comment, collection, self.parentMap);
    });

    this.initializeCommentUIAdditions();
  },

  renderComment: function (self, comment, collection, map) {
    var self = this;
    // count the number of replies in a topic, recursively
    var countChildren = function (map, comment) {
      if (_.isUndefined(map[comment])) {
        return 0;
      }
      var count = map[comment].length;
      _.each(map[comment], function (c) {
        count += countChildren(map, c);
      });
      return count;
    };
    // if this is a topic, count the children for rendering
    if (comment.topic === true) {
      comment.numChildren = countChildren(map, comment.id);
    }
    // Render the topic view and then in that view spew out all of its children.
    var commentIV = new CommentItemView({
      el: "#comment-list-" + (comment.topic ? 'null' : comment.parentId),
      model: comment,
      target: this.options.target,
      projectId: comment.projectId,
      taskId: comment.taskId,
      collection: collection
    }).render();
    self.commentViews.push(commentIV);
    if (comment.depth <= 1) {
      // Place the commentForm at the bottom of the list of comments for that topic.
      var commentFV = new CommentFormView({
        el: '#comment-form-' + comment.id,
        target: this.options.target,
        projectId: comment.projectId,
        taskId: comment.taskId,
        parentId: comment.id,
        collection: collection,
        depth: comment['depth']
      });
      self.commentForms.push(commentFV);
    }
    return $("#comment-list-" + (comment.topic ? 'null' : comment.parentId));
  },

  initializeCommentUIAdditions: function ($comment) {
    if (_.isUndefined($comment)) {
      this.$("time.timeago").timeago();
    } else {
      $comment.find("time.timeago").timeago();
    }
    popovers.popoverPeopleInit(".comment-user-link");
    popovers.popoverPeopleInit(".project-people-div");
  },

  topicExpand: function (e) {
    if (e.preventDefault) e.preventDefault();
    // toggle all the sublists
    var target = $($(e.currentTarget).parents('li')[0])
    $(e.currentTarget).hide();
    $(target.find('.comment-contract')[0]).show();
    $(target.children('.comment-sublist-wrapper')[0]).slideToggle();
  },

  topicContract: function (e) {
    if (e.preventDefault) e.preventDefault();
    // toggle all the sublists
    var target = $($(e.currentTarget).parents('li')[0])
    $(e.currentTarget).hide();
    $(target.find('.comment-expand')[0]).show();
    $(target.children('.comment-sublist-wrapper')[0]).slideToggle();
  },

  reply: function (e) {
    if (e.preventDefault) e.preventDefault();
    // The comment form is adjacent, not a child of the current target.
    // so find the li container, and then the form inside
    var target = $($($(e.currentTarget).parents('li.comment-item')[0]).children('.comment-form')[0]);
    if (target.data('clicked') == 'true') {
      target.hide();
      target.data('clicked', 'false');
    } else {
      target.show();
      target.data('clicked', 'true');
    }
  },

  newTopic: function (e) {
    if (e.preventDefault) e.preventDefault();

    if (this.topicForm) this.topicForm.cleanup();
    var options = {
      el: '.topic-form-wrapper',
      target: this.options.target,
      collection: this.collection,
      topic: true,
      depth: -1
    }
    options[this.options.target + 'Id'] = this.options.id;
    this.topicForm = new CommentFormView(options);
  },

  addNewCommentToDom: function (modelJson, currentTarget) {
    var self = this;
    modelJson['user'] = window.cache.currentUser;
    // increment the comment counter
    if ($(currentTarget).data('depth') >= 0) {
      var itemContainer = $(currentTarget).parents('.comment-item.border-left')[0];
      var countSpan = $(itemContainer).find('.comment-count-num')[0];
      $(countSpan).html(parseInt($(countSpan).text()) + 1);
    }
    // set the depth based on the position in the tree
    modelJson['depth'] = $(currentTarget).data('depth') + 1;
    // update the parentMap for sorting
    if (!_.isNull(modelJson.parentId)) {
      if (_.isUndefined(this.parentMap[modelJson.parentId])) {
        this.parentMap[modelJson.parentId] = [];
      }
      this.parentMap[modelJson.parentId].push(modelJson.id);
    } else {
      this.topics.push(modelJson);
    }
    // hide the empty placeholder, just in case it is still showing
    $("#comment-empty").hide();
    // render comment and UI addons
    var $comment = self.renderComment(self, modelJson, self.collection, self.parentMap);
    self.initializeCommentUIAdditions($comment);

    // Clear out the current div
    $(currentTarget).find("div[contentEditable=true]").text("");
  },

  cleanup: function () {
    for (var i in this.commentForms.reverse()) {
      if (this.commentForms[i]) { this.commentForms[i].cleanup(); }
    }
    for (var i in this.commentViews.reverse()) {
      if (this.commentViews[i]) { this.commentViews[i].cleanup(); }
    }
    if (this.topicForm) {
      this.topicForm.cleanup();
    }
    removeView(this);
  }

});

module.exports = Comment;


},{"../../../../../vendor/jquery.timeago":130,"../../../../entities/comments/comment_collection":117,"../../../../mixins/popovers":126,"../../../../mixins/utilities":128,"../../new/views/comment_form_view":40,"../templates/comment_wrapper_template.html":35,"../views/comment_item_view":36,"backbone":133,"underscore":159}],34:[function(require,module,exports){
module.exports = "<li class=\"comment-item clearfix <% if (topic) { %>border-left box-pad-lr<% } else { %>border-top<% } %>\">\n\n  <div class=\"comment-content\">\n    <% if (topic) { %>\n    <div class=\"comment-expand\">\n      <span class=\"content\">expand</span> <i class=\"fa fa-angle-double-down\"></i>\n    </div>\n    <div class=\"comment-contract\">\n      <span class=\"content\">contract</span> <i class=\"fa fa-angle-double-up\"></i>\n    </div>\n    <% } %>\n    <div class=\"comment-image\">\n      <div class=\"project-people-div\" data-userid=\"<%- userId %>\">\n        <img src=\"/api/user/photo/<%= userId %>\" alt=\"<%- user.name %>\" class=\"project-people\" />\n      </div>\n    </div>\n\n    <div class=\"comment-inner <% if (topic) { %>topic<% }%>\">\n      <span class=\"user-username\" data-userid=\"<%- userId %>\">\n        <a href=\"#\" class=\"comment-user-link\" data-userid=\"<%- userId %>\">\n          <% if (user.name) { %>\n            <%- user.name %>\n          <% } else { %>\n            <%- user.username %>\n          <% } %>\n        </a>\n      </span>\n\n      <%= valueHtml %>\n\n      <div class=\"comment-metadata\">\n        <time class=\"timeago comment-created-at\" datetime=\"<%- createdAt %>\"><%- createdAt %></time>\n        <% if (topic) { %>\n        &bull;&nbsp;\n        <span class=\"comment-count\"><i class=\"fa fa-comments\"></i> <span class=\"comment-count-num\"><%- numChildren %></span> comments</span>\n        <% } %>\n        <% if (depth == 1)  { %>\n        <% if (currentUser) { %>\n        &bull;\n        <a href=\"#reply-to-comment\" class=\"reply-to-<%= id %>\" data-depth=\"<%= depth %>\">Reply</a>\n        <% } %>\n        <% } %>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"comment-sublist-wrapper\">\n\n    <ul id=\"comment-list-<%= id %>\"></ul>\n  </div>\n\n  <div class=\"comment-form\" <% if ((depth >= 1) || (!currentUser)) { %>style=\"display: none;\"<% } %> id=\"comment-form-<%= id %>\"></div>\n\n</li>\n";

},{}],35:[function(require,module,exports){
module.exports = "<div class=\"box-pad-lr border-bottom\">\n  <h2>Discussion\n  <% if (user) { %>\n  <button class=\"btn btn-c0 btn-sm file-add new-topic\" id=\"project-topic-new\">New Topic</button>\n  <% } %>\n  </h2>\n</div>\n<div class=\"box-pad-lr box-pad-t topic-form-wrapper\"></div>\n<div class=\"comment-spinner fullwidth text-center\">\n  Loading discussion... <i class=\"fa fa-spinner fa-spin\"></i>\n</div>\n<ul id=\"comment-list-null\">\n  <li class=\"comment-item clearfix border-left box-pad-lr\" id=\"comment-empty\" style=\"display:none;\">\n    No discussion yet.  Start a topic!\n  </li>\n</ul>\n";

},{}],36:[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');
var utilities = require('../../../../mixins/utilities');
var Autolinker = require('autolinker');
var CommentItemTemplate = require('../templates/comment_item_template.html');


var CommentItemView = Backbone.View.extend({

  render: function () {
    this.model.currentUser = window.cache.currentUser;
    this.model.valueHtml = Autolinker.link(this.model.value);
    if (this.model.topic) {
      var compiledTemplate = _.template(CommentItemTemplate)(this.model);
      this.$el.append(compiledTemplate);
    } else {
      var self = this;
      if (this.model.parentId === parseInt($("#comment-list-" + this.model.parentId).attr("id").split("-")[$("#comment-list-"+this.model.parentId).attr("id").split("-").length - 1])) {
        var newTemplate = _.template(CommentItemTemplate)(this.model);
        $("#comment-list-" + this.model.parentId).append(newTemplate);
      }
    }
  },

  cleanup: function () {
    removeView(this);
  }

});

module.exports = CommentItemView;

},{"../../../../mixins/utilities":128,"../templates/comment_item_template.html":34,"autolinker":132,"backbone":133,"underscore":159}],37:[function(require,module,exports){
module.exports = "<li data-value='<%- value %>'>\n  <div class=\"ac-container\">\n    <% if (image !== null) { %>\n    <img src=\"<%- image %>\" alt=\"<%- value %>\" class=\"ac-image\"/>\n    <% } else if (target == 'project') { %>\n    <img src=\"/images/project_default.png\" alt=\"<%- value %>\" class=\"ac-image\"/>\n    <% } else { %>\n    <div class=\"ac-image\"></div>\n    <% } %>\n    <div class=\"ac-content\">\n      <div class=\"ac-title\">\n        <%- value %>\n      </div>\n      <div class=\"ac-description\">\n        <% if ((target == 'project') || (target == 'user')) { %>\n        <%= description %>\n        <% } %>\n      </div>\n    </div>\n  </div>\n</li>";

},{}],38:[function(require,module,exports){
module.exports = "<div class=\"row\">\n  <div class=\"col-lg-12 \">\n    <div class=\"alert alert-danger comment-alert-empty\">\n      You must enter text before submitting a comment.\n    </div>\n  </div>\n</div>\n<div class=\"row\">\n  <div class=\"col-lg-12 \">\n    <form action=\"\" class=\"form-inline comment-submit <% if (form.topic) { %>comment-form-topic<% } %>\" role=\"form\" data-depth=\"<%= form.depth %>\">\n      <div class=\"input-group\">\n        <div class=\"comment-input form-control input-sm\" contentEditable=\"true\"></div>\n        <span class=\"input-group-btn\">\n          <input class=\"btn btn-c2 btn-sm\" type=\"submit\" value=\"<% if (form.topic) { %> Start Topic <% } else if (form.depth == 1) { %> Reply <% } else { %>Add Comment<% } %>\" title=\"<% if (form.topic) { %> Start Topic <% } else if (form.depth == 1) { %> Reply <% } else { %>Add Comment<% } %>\">\n        </span>\n      </div>\n    </form>\n  </div>\n</div>\n";

},{}],39:[function(require,module,exports){
module.exports = "<% if (target == 'user') {\n  %><a href=\"<%- link %>\" class=\"comment-user-link\" data-userid=<%- id %>>@<%- value %></a><% }\n  else if (target == 'project') {\n  %><a href=\"<%- link %>\" class=\"link-backbone\"><%- value %></a><% }\n  else {\n  %><a href=\"<%- link %>\"><%- value %></a><% } %>";

},{}],40:[function(require,module,exports){
// This is the comment, and topic form.
// We know what to do based on a flag being passed into this view
// via the controller.  That flag is:
// this.options.topic = true


var _ = require('underscore');
var Backbone = require('backbone');
var jqCaret = require('jquery.caret/dist/jquery.caret.min');
var jqAt = require('jquery.atwho/dist/js/jquery.atwho');
var utils = require('../../../../mixins/utilities');
var marked = require('marked');
var CommentCollection = require('../../../../entities/comments/comment_collection');
var CommentFormTemplate = require('../templates/comment_form_template.html');
var CommentAcTemplate = require('../templates/comment_ac_template.html');
var CommentInlineTemplate = require('../templates/comment_inline_template.html');


var CommentFormView = Backbone.View.extend({

  events: {
    "submit .comment-submit": "post"
  },

  initialize: function (options) {
    this.options = options;
    this.render();
  },

  render: function () {
    var self = this;
    var data = { form: this.options };
    var template = _.template(CommentFormTemplate)(data);

    if (this.options.topic) {
      this.$el.prepend(template).append("<div class='clearfix'></div>");
    } else {
      this.$el.append(template);
    }

    var genTemplate = function (template, data) {
      if (!data) {
        return '';
      }
      // use the agency/office name as the description
      // if none exists, use the job title.
      // otherwise leave blank.
      if (data.target == 'user') {
        if (data.agency) {
          data.description = data.agency;
        }
        else if (data.title) {
          data.description = data.title;
        }
        else {
          data.description = '';
        }
      }
      // convert descriptions to markdown/html
      if (data.target == 'project') {
        if (data.description) {
          data.description = marked(data.description);
        }
        if (!data.coverId) {
          data.coverId = null;
        }
      }
      if (!data.image) {
        data.image = null;
      }
      // render template
      return _.template(template)(data);
    };

    this.$(".comment-input").atwho({
      at: '@',
      search_key: 'value',
      tpl: CommentAcTemplate,
      insert_tpl: CommentInlineTemplate,
      limit: 10,
      callbacks: {
        tpl_eval: genTemplate,
        sorter: function (query, items, search_key) {
          // don't sort, use the order from the server
          return items;
        },
        highlighter: function (li, query) {
          return li;
        },
        // highlighter: function (li, query) {
        //   var regexp;
        //   if (!query) {
        //     return li;
        //   }
        //   // just want to find all case insensitive matches and replace with <strong>
        //   // set up the query as a regular expression
        //   var re = new RegExp('(' + query.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1") + ')', 'ig');
        //   // parse the li string into a DOM node
        //   var liDom = $.parseHTML(li);
        //   var text = $(liDom[0]).text().replace(re, "<strong>$1</strong>");
        //   $(liDom[0]).html(text);
        //   return liDom[0];
        // },
        remote_filter: function (query, callback) {
          // get data from the server
          $.getJSON("/api/ac/inline", { q: query }, function (data) {
            _.each(data, function (d) {
              // At.js expects the name to be set for the matcher fn
              if (_.isUndefined(d.name)) {
                d.name = d.value;
              }
            });
            callback(data);
          });
        }
      }
    }).on("inserted.atwho", function(event, $li) {
      // This is a hack to hide the space after inserting an element.
      var ids = self.$("span.atwho-view-flag > span:visible");
      // insert a non-breaking space after the inserted element, but not within it
      // this allows the user to delete that space if they want to, without deleting
      // the referenced element
      ids.parent().after('&nbsp;');
      ids.hide();
    });

    return this;
  },

  post: function (e) {
    if (e.preventDefault) e.preventDefault();

    var commentHtml = this.$(".comment-input").html();
    var commentText = this.$(".comment-input").text().trim();

    // abort if the comment is empty
    if (!commentText) {
      this.$('.comment-alert-empty').show();
      return;
    }

    var parentId;

    if (this.options.parentId) {
      parentId = parseInt(this.options.parentId);
    }

    var data = {
      comment   : commentHtml,
      topic     : false
    };
    data[this.options.target + 'Id'] = this.options[this.options.target + 'Id'];

    if (this.options.topic) {
      data.topic = true;
    } else {
      data.parentId = parentId;
    }
    this.$('.comment-alert-empty').hide();

    var currentTarget = e.currentTarget;
    this.collection.trigger("comment:save", data, currentTarget);
  },

  cleanup: function () {
    removeView(this);
  }

});

module.exports = CommentFormView;

},{"../../../../entities/comments/comment_collection":117,"../../../../mixins/utilities":128,"../templates/comment_ac_template.html":37,"../templates/comment_form_template.html":38,"../templates/comment_inline_template.html":39,"backbone":133,"jquery.atwho/dist/js/jquery.atwho":153,"jquery.caret/dist/jquery.caret.min":154,"marked":155,"underscore":159}],41:[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var Popovers = require('../../../../mixins/popovers');
var EventsCollection = require('../../../../entities/events/events_collection');
var EventCollectionView = require('../views/event_collection_view');
var ModalComponent = require('../../../../components/modal');
var EventFormView = require('../../new/views/event_form_view');


var popovers = new Popovers();

EventList = Backbone.View.extend({

  el: "#event-list-wrapper",

  events: {
    'click .add-event'                : 'add',
    'click .rsvp'                     : 'toggleRSVP',
    'mouseenter .data-event-flag-true': 'buttonRSVPOn',
    'mouseleave .data-event-flag-true': 'buttonRSVPOff',
    "mouseenter .project-people-div"  : popovers.popoverPeopleOn,
    "click .project-people-div"       : popovers.popoverClick
  },

  initialize: function (settings) {
    var self = this;
    this.options = _.extend(settings, this.defaults);
    this.requestEventsCollectionData();
  },

  requestEventsCollectionData: function () {
    var self = this;
    this.collection = new EventsCollection();
    this.collection.fetch({
      url: '/api/event/findAllByProjectId/' + parseInt(this.options.projectId),
      success: function (collection) {
        self.collection = collection;
        self.renderEventCollectionView(collection);
      }
    })
  },

  renderEventCollectionView: function (collection) {
    var self = this;
    this.listenTo(this.collection, "event:save:success", function (model) {
      $('#addEvent').bind('hidden.bs.modal', function() {
        self.requestEventsCollectionData();
        if (this.eventFormView) this.eventFormView.cleanup();
        if (this.modalComponent) this.modalComponent.cleanup();
      }).modal('hide');
    });

    if (this.eventCollectionView) {
      this.eventCollectionView.cleanup();
    }

    this.eventCollectionView = new EventCollectionView({
      el: "#event-list-wrapper",
      onRender: true,
      collection: collection,
      projectId: this.options.projectId
    });

    popovers.popoverPeopleInit(".project-people-div");
  },

  add: function (e) {
    if (e.preventDefault) e.preventDefault();

    // cleanup existing views
    if (this.eventFormView) this.eventFormView.cleanup();
    if (this.modalComponent) this.modalComponent.cleanup();

    // instantiate the modal with the event form view
    this.modalComponent = new ModalComponent({
      el: "#event-modal-add",
      id: "addEvent",
      modalTitle: 'Add Event'
    }).render();

    this.eventFormView = new EventFormView({
      el: "#event-modal-add .modal-template",
      projectId: this.options.projectId,
      collection: this.collection
    }).render();
  },

  updatePeople: function (e, inc) {
    var peopleDiv = $($(e.currentTarget).parents('.event')[0]).find('.event-people')[0];
    var numDiv = $(peopleDiv).children('.event-people-number');
    var newNum = parseInt($(numDiv).html());
    if (inc) {
      newNum++
    } else {
      newNum--;
    }
    // Don't allow race conditions to set the number of people below zero
    if (newNum < 0) {
      newNum = 0;
    }
    $(numDiv).html(newNum);
    var textDiv = $(peopleDiv).children('.event-people-text')[0];
    if (newNum == 1) {
      $(textDiv).html($(textDiv).data('singular'));
    } else {
      $(textDiv).html($(textDiv).data('plural'));
    }
  },

  buttonRSVPOn: function (e) {
    $(e.currentTarget).button('hover');
  },

  buttonRSVPOff: function (e) {
    $(e.currentTarget).button('going');
  },

  toggleRSVP: function (e) {
    var self = this;
    if (e.preventDefault) e.preventDefault();
    // get the id from the parent event div
    var id = $($(e.currentTarget).parents('div.event')[0]).data('id');
    if ($(".rsvp").hasClass("data-event-flag-true") === false) {
      $(".rsvp").removeClass("data-event-flag-false");
      $(".rsvp").addClass("data-event-flag-true");
      $(e.currentTarget).button('going');
      self.updatePeople(e, true);
      $.ajax({
        url: '/api/event/attend/' + id,
        success: function (data) {
        }
      });
    } else {
      $(".rsvp").removeClass("data-event-flag-true");
      $(".rsvp").addClass("data-event-flag-false");
      $(e.currentTarget).button('rsvp');
      self.updatePeople(e, false);
      $.ajax({
        url: '/api/event/cancel/' + id,
        success: function (data) {
        }
      })
    }
  },

  cleanup: function () {
    if (this.eventCollectionView) this.eventCollectionView.cleanup();
    if (this.eventFormView) this.eventFormView.cleanup();
    if (this.modalComponent) this.modalComponent.cleanup();
    removeView(this);
  }

});

module.exports = EventList

},{"../../../../components/modal":106,"../../../../entities/events/events_collection":120,"../../../../mixins/popovers":126,"../../../../mixins/utilities":128,"../../new/views/event_form_view":45,"../views/event_collection_view":43,"backbone":133,"underscore":159}],42:[function(require,module,exports){
module.exports = "<div class=\"box-pad-lr border-bottom\">\n  <h2>\n    Upcoming Events\n    <% if (user) { %>\n    <a href=\"#addEvent\" class=\"btn btn-c0 btn-sm file-add add-event\" data-toggle=\"modal\" data-backdrop=\"static\">Add Event</a>\n    <% } %>\n  </h2>\n</div>\n\n<div id=\"event-modal-add\"></div>\n\n<div class=\"task-scroll\">\n\n  <% if (events.length == 0) { %>\n\n  <div class=\"event border-left\" data-id=\"null\">\n    <div class=\"event-title\">\n      No events scheduled.\n    </div>\n  </div>\n\n  <% } else { %>\n\n  <% _.each(events, function (event, iterator) { %>\n  <div class=\"event border-left\" data-id=\"<%= event.id %>\">\n    <% if (user) { %>\n    <div class=\"event-button pull-right\">\n      <button class=\"btn btn-c2 btn-sm rsvp data-event-flag-<%= event.rsvp %>\" data-going-text=\"<i class='fa fa-check'></i> I'm going\" data-rsvp-text=\"RSVP\" data-hover-text=\"Cancel RSVP\"><% if (event.rsvp) { %><i class='fa fa-check'></i> I'm going<% } else { %>RSVP<% } %></button>\n    </div>\n    <% } %>\n    <div class=\"event-title\">\n      <%- event.title %>\n    </div>\n    <div class=\"event-description\">\n      <%- event.description %>\n    </div>\n    <div class=\"event-tag\">\n      <i class=\"fa fa-calendar\"></i>\n      <span class=\"box-icon-text\">\n      <!-- day -->\n      <% var st = new Date(event.start); var et = new Date(event.end); %>\n      <%= st.toLocaleDateString() %>\n      <% if (st.toLocaleDateString() != et.toLocaleDateString()) { %>\n      - <%= et.toLocaleDateString() %>\n      <% } %>\n      <!-- time -->\n      <%= st.toLocaleTimeString() %>\n      <% if (st.toLocaleDateString() == et.toLocaleDateString()) { %>\n      - <%= et.toLocaleTimeString() %>\n      <% } %>\n      </span>\n    </div>\n    <div class=\"event-tag\">\n      <span class=\"fa fa-map-marker\"></span>\n      <span class=\"box-icon-text\">\n      <%= event.location %>\n      </span>\n    </div>\n    <div class=\"event-tag\">\n      <span class=\"event-icon-center\"><i class=\"fa fa-male\"></i></span>\n      <span class=\"box-icon-text event-people\">\n        <span class=\"event-people-number\"><%= event.rsvps.length %></span>\n        <span class=\"event-people-text\" data-plural=\"people\" data-singular=\"person\">\n        <% if (event.rsvps.length == 1) { %>\n          person\n        <% } else { %>\n          people\n        <% } %>\n        </span>\n        going\n      </span>\n    </div>\n  </div>\n  <% }); %>\n\n  <% } %>\n</div>\n";

},{}],43:[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var EventListTemplate = require('../templates/event_collection_view_template.html');


var EventCollectionView = Backbone.View.extend({

  el: "#event-list-wrapper",

  initialize: function (options) {
    this.options = options;
    this.render();
  },

  render: function () {
    var eventsJSON = {
      events: this.options.collection.toJSON(),
      projectId: this.options.projectId,
      user: window.cache.currentUser
    }

    this.compiledTemplate = _.template(EventListTemplate)(eventsJSON);
    this.$el.html(this.compiledTemplate);

    return this;
  },

  cleanup: function () {
    removeView(this);
  }

});

module.exports = EventCollectionView;

},{"../../../../mixins/utilities":128,"../templates/event_collection_view_template.html":42,"backbone":133,"underscore":159}],44:[function(require,module,exports){
module.exports = "<form id=\"event-form\" class=\"form-horizontal\" style=\"display: block;\">\n\n  <div class=\"modal-body\">\n\n    <fieldset>\n\n      <div class=\"form-group\">\n        <label for=\"event-title\" class=\"col-lg-2 control-label\">Title</label>\n        <div class=\"col-lg-10\">\n          <input id=\"event-title\" class=\"form-control\" type=\"text\" data-validate=\"empty,count100\">\n          <span class=\"help-block error-empty\" style=\"display:none;\">You must enter an event title.</span>\n          <span class=\"help-block error-count100\" style=\"display:none;\">The event title must be less than 100 characters.</span>\n        </div>\n      </div>\n\n      <div class=\"form-group\">\n        <label for=\"event-description\" class=\"col-lg-2 control-label\">Description</label>\n        <div class=\"col-lg-10\">\n          <textarea id=\"event-description\" class=\"form-control\" type=\"text\" data-validate=\"empty,count250\" rows=\"3\"></textarea>\n          <span class=\"help-block error-empty\" style=\"display:none;\">You must enter an event description.</span>\n          <span class=\"help-block error-count100\" style=\"display:none;\">The event description must be less than 250 characters.</span>\n        </div>\n      </div>\n\n      <div class=\"form-group\">\n        <label for=\"event-start\" class=\"col-md-2 control-label\">Time</label>\n        <div class=\"col-md-2 padding-right-none\">\n          <input id=\"event-start\" class=\"form-control fullwidth\" type=\"text\">\n        </div>\n        <div class=\"col-md-2 padding-none\" id=\"div-event-start-time\">\n          <input id=\"event-start-time\" class=\"form-control fullwidth timepicker\" type=\"text\">\n        </div>\n        <div class=\"col-md-1 control-label\">\n          to\n        </div>\n        <div class=\"col-md-2 padding-none\" id=\"div-event-end-time\">\n          <input id=\"event-end-time\" class=\"form-control fullwidth timepicker\" type=\"text\">\n        </div>\n        <div class=\"col-md-2 padding-none\">\n          <input id=\"event-end\" class=\"form-control fullwidth\" type=\"text\">\n        </div>\n      </div>\n\n      <div class=\"form-group\" style=\"margin-top: -10px;\">\n        <div class=\"col-md-10 col-md-offset-2 event-timezone\">\n          Your time zone is set to <span class=\"timezone\">None</span>.\n        </div>\n      </div>\n\n      <div class=\"form-group\">\n        <label for=\"event-location\" class=\"col-lg-2 control-label\">Location</label>\n        <div class=\"col-lg-10\">\n          <input id=\"event-location\" class=\"form-control\" type=\"text\" data-validate=\"empty\">\n          <span class=\"help-block error-empty\" style=\"display:none;\">You must enter an event location.</span>\n        </div>\n      </div>\n\n    </fieldset>\n  </div>\n  <div class=\"modal-footer\">\n    <button type=\"button\" class=\"btn btn-c0 wizard-cancel\" data-dismiss=\"modal\">Cancel</button>\n    <button class=\"btn btn-c2\" type=\"submit\">Add Event</button>\n  </div>\n\n</form>\n";

},{}],45:[function(require,module,exports){

var Bootstrap = require('bootstrap');
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var DatePicker = require('bootstrap-datetimepicker/src/js/bootstrap-datetimepicker');
var TimePicker = require('timepicker/jquery.timepicker');
var EventsCollection = require('../../../../entities/events/events_collection');
var EventFormTemplate = require('../templates/event_form_template.html');


var EventFormView = Backbone.View.extend({

  el: "#event-list-wrapper",

  events: {
    // field validation
    "blur #event-title"       : "v",
    "blur #event-description" : "v",
    "blur #event-location"    : "v",
    // form submission
    "submit #event-form"      : "post"
  },

  initialize: function (options) {
    this.options = options;
  },

  initializeTimeZone: function () {
    var offset = (new Date()).getTimezoneOffset();
    var timezones = {
        '-12': 'Pacific/Kwajalein',
        '-11': 'Pacific/Samoa',
        '-10': 'Pacific/Honolulu',
        '-9': 'America/Juneau',
        '-8': 'America/Los Angeles',
        '-7': 'America/Denver',
        '-6': 'America/Mexico City',
        '-5': 'America/New York',
        '-4': 'America/Caracas',
        '-3.5': 'America/St Johns',
        '-3': 'America/Argentina/Buenos Aires',
        '-2': 'Atlantic/Azores',
        '-1': 'Atlantic/Azores',
        '0': 'Europe/London',
        '1': 'Europe/Paris',
        '2': 'Europe/Helsinki',
        '3': 'Europe/Moscow',
        '3.5': 'Asia/Tehran',
        '4': 'Asia/Baku',
        '4.5': 'Asia/Kabul',
        '5': 'Asia/Karachi',
        '5.5': 'Asia/Calcutta',
        '6': 'Asia/Colombo',
        '7': 'Asia/Bangkok',
        '8': 'Asia/Singapore',
        '9': 'Asia/Tokyo',
        '9.5': 'Australia/Darwin',
        '10': 'Pacific/Guam',
        '11': 'Asia/Magadan',
        '12': 'Asia/Kamchatka'
    };
    // create a timezone string for display
    var tz = timezones[-offset / 60];
    tz += ' (';
    if (offset <= 0) {
      tz += '+';
    }
    tz += (-offset/60) + ':00)';
    $('.timezone').html(tz);

    // set input pickers for time
    $('#event-start-time').timepicker({
      selectOnBlur: true,
      appendTo: '#div-event-start-time'
    });
    $('#event-end-time').timepicker({
      selectOnBlur: true,
      showDuration: true,
      durationTime: function() {
        return ($('#event-start-time').val());
      },
      appendTo: '#div-event-end-time'
    });
    // get the start time by rounding the current time to the nearest 30 minutes
    var coeff = 1000 * 60 * 30;
    var startTime = new Date();  //or use any other date
    startTime = new Date(Math.ceil(startTime.getTime() / coeff) * coeff)
    // the initial end time should be 1 hour after the initial start time
    var endTime = new Date(startTime.getTime() + 1000*60*60);
    $('#event-start-time').timepicker('setTime', startTime);
    $('#event-end-time').timepicker('setTime', endTime);

    // Initialize the date pickers
    var startDate = new Date();
    $('#event-start').datetimepicker({
      pickDate: true,
      pickTime: false,
      startDate: startDate
    });
    $('#event-end').datetimepicker({
      pickDate: true,
      pickTime: false,
      startDate: startDate
    });
    // Set the initial date to now (today)
    $('#event-start').data("DateTimePicker").setDate(startDate);
    $('#event-end').data("DateTimePicker").setDate(startDate);

    // When the start date changes,
    // set the end date to be at least the start date
    $('#event-start').on("change.dp",function (e) {
      $('#event-end').data("DateTimePicker").setStartDate(e.date);
      var diff = $('#event-end').data("DateTimePicker").getDate().unix() - e.date.unix();
      if (diff < 0) {
        $('#event-end').data("DateTimePicker").setDate(e.date);
      }
      $(e.currentTarget).blur();
    });
    // When the end date changes,
    // Enable/disable duration in the timepicker based on whether the
    // start and end dates match
    $('#event-end').on("change.dp",function (e) {
      var diff = e.date.unix() - $('#event-start').data("DateTimePicker").getDate().unix();
      if (diff === 0) {
        $('#event-end-time').timepicker('option', 'showDuration', true);
      } else {
        $('#event-end-time').timepicker('option', 'showDuration', false);
      }
      $(e.currentTarget).blur();
    });
  },

  render: function () {
    var template = _.template(EventFormTemplate);
    this.$el.html(template);
    this.initializeTimeZone();
  },

  v: function (e) {
    return validate(e);
  },

  post: function (e) {
    if (e.preventDefault) e.preventDefault();

    // validate the fields; if any is not validated, abort form submission
    var validateIds = ['#event-title', '#event-description', '#event-location'];
    var abort = false;
    for (i in validateIds) {
      var iAbort = validate({ currentTarget: validateIds[i] });
      abort = abort || iAbort;
    }
    if (abort) {
      return;
    }

    // process the form; create time objects
    var start = $('#event-start').data("DateTimePicker").getDate().clone().toDate();
    var end = $('#event-start').data("DateTimePicker").getDate().clone().toDate();
    start = $('#event-start-time').timepicker('getTime', start);
    end = $('#event-end-time').timepicker('getTime', end);

    var data = {
      title       : $("#event-title").val(),
      description : $("#event-description").val(),
      start       : start.toISOString(),
      end         : end.toISOString(),
      location    : $("#event-location").val(),
      projectId   : this.options.projectId
    };

    this.collection.trigger("event:save", data);
  },

  cleanup: function () {
    removeView(this);
  }

});

module.exports = EventFormView;

},{"../../../../entities/events/events_collection":120,"../../../../mixins/utilities":128,"../templates/event_form_template.html":44,"backbone":133,"bootstrap":138,"bootstrap-datetimepicker/src/js/bootstrap-datetimepicker":137,"timepicker/jquery.timepicker":158,"underscore":159}],46:[function(require,module,exports){
module.exports = "<footer class=\"container\">\n  <div class=\"row\">\n    <div class=\"col-md-12\">\n      <a href=\"https://github.com/18F/midas\"><i class=\"fa fa-github\"></i> powered by midas</a>\n      <% if (login.terms.enabled === true) { %>\n      |\n      <a href=\"<%= login.terms.link %>\"><%= login.terms.name %></a>\n      <% } %>\n      |\n      Locations provided by <a href=\"http://www.geonames.org/\">GeoNames</a>.\n    </div>\n  </div>\n</footer>\n";

},{}],47:[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../mixins/utilities');
var Login = require('../../../config/login.json');
var FooterTemplate = require('../templates/footer_template.html');


var FooterView = Backbone.View.extend({

  events: {
  },

  render: function () {
    var self = this;
    var data = {
      version: version,
      login: Login
    };
    var compiledTemplate = _.template(FooterTemplate)(data);
    this.$el.html(compiledTemplate);

    function resizeElements() {
      headerHeight = $('.navbar').height();
      footerHeight = $('footer').height();
      if (($(document.body).height() + footerHeight) < $(window).height()) {
        self.$el.addClass('navbar-fixed-bottom');
      } else {
        self.$el.removeClass('navbar-fixed-bottom');
      }
    }
    resizeElements();
    $(".container").bind("DOMSubtreeModified", resizeElements);
  },

  cleanup: function () {
    removeView(this);
  }

});

module.exports = FooterView;


},{"../../../config/login.json":114,"../../../mixins/utilities":128,"../templates/footer_template.html":46,"backbone":133,"underscore":159}],48:[function(require,module,exports){

var _ = require('underscore');
var async = require('async');
var Backbone = require('backbone');
var utils = require('../../../mixins/utilities');
var BaseController = require('../../../base/base_controller');
var HomeView = require('../views/home_view');


Home = {};

Home.Controller = BaseController.extend({

  events: {
  },

  // The initialize method is mainly used for event bindings (for efficiency)
  initialize: function (options) {
    var self = this;
    this.homeView = new HomeView().render();
  },

  // ---------------------
  //= Utility Methods
  // ---------------------
  cleanup: function() {
    if (this.homeView) this.homeView.cleanup();
    removeView(this);
  }

});

module.exports = Home.Controller;


},{"../../../base/base_controller":101,"../../../mixins/utilities":128,"../views/home_view":50,"async":131,"backbone":133,"underscore":159}],49:[function(require,module,exports){
module.exports = "  <div class=\"container-fluid padding-left-none padding-right-none\" id=\"home\">\n    <div class=\"splash-wrap\" id=\"splash1\">\n      <div class=\"splash-center\">\n      <h1 class=\"text-center\" data-i18n=\"home.headline\">Hassle Free Collaboration</h1>\n      <p class=\"lead text-center\" data-i18n=\"home.subhead\">Work with other federal employees on projects you are passionate about.</p>\n      <div class=\"text-center\"><a class=\"login\" href=\"/auth\"><button class=\"btn btn-midas\" id=\"center\" data-i18n=\"home.callToAction\">Get Started Today</button></a></div>\n      <!--div class=\"text-center text-on-dark text-muted\"><a href=\"#\">Learn More</a></div-->\n    </div><!-- /#splash -->\n    </div><!-- /.splash-wrap -->\n\n  <div class=\"inline-block-center\">\n    <div class=\"value-prop\">\n        <div class=\"icon\"><i class=\"fa fa-comments\"></i></div> <!-- icon -->\n        <div class=\"text\">Make Connections</div>\n    </div>\n    <div class=\"value-prop\">\n        <div class=\"icon\"><i class=\"fa fa-cogs\"></i></div> <!-- icon -->\n        <div class=\"text\">Build Skills</div>\n    </div>\n    <div class=\"value-prop\">\n        <div class=\"icon\"><i class=\"fa fa-line-chart\"></i></div> <!-- icon -->\n        <div class=\"text\">Make a Difference</div>\n    </div>\n  </div>\n  <div class=\"text-center\"><a class=\"login\" href=\"/auth\"><button class=\"btn btn-midas\" id=\"center\" data-i18n=\"home.callToAction\">Get Started Today</button></a></div>\n\n\n  </div><!-- /.container-fluid-->\n";

},{}],50:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var async = require('async');
var utils = require('../../../mixins/utilities');
var UIConfig = require('../../../config/ui.json');
var Login = require('../../../config/login.json');
var LoginController = require('../../login/controllers/login_controller');
var HomeTemplate = require('../templates/home_view_template.html');


var HomeView = Backbone.View.extend({

  el: "#container",

  events: {
    'click .login'          : 'loginClick'
  },

  initialize: function (options) {
    this.options = options;
    this.listenTo(window.cache.userEvents, "user:login:success", function (user) {
      Backbone.history.navigate(UIConfig.home.logged_in_path, { trigger: true });
    });
  },

  render: function () {
    var compiledTemplate;
    var data = {
      hostname: window.location.hostname,
      user: window.cache.currentUser || {},
    };

    this.$el.addClass('home');
    compiledTemplate = _.template(HomeTemplate)(data);
    this.$el.html(compiledTemplate);
    this.$el.i18n();

    return this;
  },

  loginClick: function (e) {
    if (e.preventDefault) e.preventDefault();
    if (window.cache.currentUser) {
      // we're already logged in
      Backbone.history.navigate(UIConfig.home.logged_in_path, { trigger: true });
    } else {
      this.login();
    }
  },

  login: function (message) {
    if (this.loginController) {
      this.loginController.cleanup();
    }
    this.loginController = new LoginController({
      el: '#login-wrapper',
      message: message
    });
  },

  cleanup: function () {
    this.$el.removeClass('home');
    removeView(this);
  },
});

module.exports = HomeView;

},{"../../../config/login.json":114,"../../../config/ui.json":116,"../../../mixins/utilities":128,"../../login/controllers/login_controller":51,"../templates/home_view_template.html":49,"async":131,"backbone":133,"underscore":159}],51:[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');
var Bootstrap = require('bootstrap');
var utils = require('../../../mixins/utilities');
var BaseController = require('../../../base/base_controller');
var LoginView = require('../views/login_view');
var login = require('../../../config/login.json');
var ModalComponent = require('../../../components/modal');


Login = BaseController.extend({

  events: {
    "click #register-cancel"   : "showLogin",
    "click #login-register"    : "showRegister",
    "click #forgot-done-cancel": "showLogin",
    "click #forgot-cancel"     : "showLogin",
    "click #forgot-password"   : "showForgot"
  },

  initialize: function ( options ) {
    var self = this;
    this.options = options;
    this.initializeView();
  },

  initializeView: function () {
    var self = this;
    if (this.loginView) {
      this.loginView.cleanup();
      this.modalComponent.cleanup();
    }

    // initialize the modal
    if (!_.isUndefined(this.options.message)) {
      var disableClose = this.options.message.disableClose || false;
    }
    this.modalComponent = new ModalComponent({
      el: this.el,
      id: "login",
      modalTitle: "Login or Register",
      disableClose: disableClose
    }).render();

    // put the login view inside the modal
    this.loginView = new LoginView({
      el: ".modal-template",
      login: login,
      message: this.options.message
    }).render();
    this.$("#registration-view").hide();
    this.$("#forgot-view").hide();
    this.$("#forgot-done-view").hide();
    $("#login").modal('show');

    self.listenTo(window.cache.userEvents, "user:login", function (user) {
      // hide the modal
      self.stopListening(window.cache.userEvents);
      // window.cache.userEvents.stopListening();
      $('#login').bind('hidden.bs.modal', function() {
        // reload the page after login
        Backbone.history.loadUrl();
        window.cache.userEvents.trigger("user:login:success", user);
        self.cleanup();
      }).modal('hide');
    });
  },

  showRegister: function (e) {
    if (e.preventDefault) e.preventDefault();
    this.$("#login-view").hide();
    this.$("#login-footer").hide();
    this.$("#registration-view").show();
    this.$("#registration-footer").show();
    this.$("#forgot-view").hide();
    this.$("#forgot-footer").hide();
    this.$("#forgot-done-view").hide();
    this.$("#forgot-done-footer").hide();
  },

  showLogin: function (e) {
    if (e.preventDefault) e.preventDefault();
    this.$("#login-view").show();
    this.$("#login-footer").show();
    this.$("#registration-view").hide();
    this.$("#registration-footer").hide();
    this.$("#forgot-view").hide();
    this.$("#forgot-footer").hide();
    this.$("#forgot-done-view").hide();
    this.$("#forgot-done-footer").hide();
  },

  showForgot: function (e) {
    if (e.preventDefault) e.preventDefault();
    this.$("#forgot-view").show();
    this.$("#forgot-footer").show();
    this.$("#registration-view").hide();
    this.$("#registration-footer").hide();
    this.$("#login-view").hide();
    this.$("#login-footer").hide();
    this.$("#forgot-done-view").hide();
    this.$("#forgot-done-footer").hide();
  },

  // ---------------------
  //= UTILITY METHODS
  // ---------------------
  cleanup: function() {
    // don't do anything
    if (this.loginView) { this.loginView.cleanup(); }
    if (this.modalComponent) { this.modalComponent.cleanup(); }
    removeView(this);
  }

});

module.exports = Login;

},{"../../../base/base_controller":101,"../../../components/modal":106,"../../../config/login.json":114,"../../../mixins/utilities":128,"../views/login_view":55,"backbone":133,"bootstrap":138,"underscore":159}],52:[function(require,module,exports){
module.exports = "<div class=\"row\">\n  <div class=\"col-sm-9 sm-nopadding\">\n    <div class=\"form-group\">\n      <label for=\"rpassword\" class=\"control-label\">Password</label>\n      <input type=\"password\" class=\"form-control validate\" id=\"rpassword\" name=\"password\" placeholder=\"Password\" data-validate=\"empty,password,confirm\"/>\n      <span class=\"help-block error-empty\" style=\"display:none;\">You must enter a password.</span>\n      <span class=\"help-block error-password\" style=\"display:none;\">Your password does not meet password rules.</span>\n    </div>\n    <div class=\"form-group\">\n      <label for=\"rpassword-confirm\" class=\"control-label\">Confirm Password</label>\n      <input type=\"password\" class=\"form-control\" id=\"rpassword-confirm\" placeholder=\"Confirm Password\"/>\n      <span class=\"help-block error-confirm\" style=\"display:none;\">Your password does not match the password entered above.</span>\n    </div>\n  </div>\n  <div class=\"col-sm-3 nopadding\">\n    <div class=\"password-rules-title\">\n      Must Contain:\n    </div>\n    <ul class=\"password-rules\">\n      <li class=\"success rule-username\"><i class=\"fa fa-check\"></i> Not your email</li>\n      <li class=\"error rule-username\"><i class=\"fa fa-remove\"></i> Not your email</li>\n      <li class=\"success rule-length\"><i class=\"fa fa-check\"></i> 8 characters or more</li>\n      <li class=\"error rule-length\"><i class=\"fa fa-remove\"></i> 8 characters or more</li>\n      <li class=\"success rule-upper\"><i class=\"fa fa-check\"></i> Uppercase</li>\n      <li class=\"error rule-upper\"><i class=\"fa fa-remove\"></i> Uppercase</li>\n      <li class=\"success rule-lower\"><i class=\"fa fa-check\"></i> Lowercase</li>\n      <li class=\"error rule-lower\"><i class=\"fa fa-remove\"></i> Lowercase</li>\n      <li class=\"success rule-number\"><i class=\"fa fa-check\"></i> A Number</li>\n      <li class=\"error rule-number\"><i class=\"fa fa-remove\"></i> A Number</li>\n      <li class=\"success rule-symbol\"><i class=\"fa fa-check\"></i> A Symbol</li>\n      <li class=\"error rule-symbol\"><i class=\"fa fa-remove\"></i> A Symbol</li>\n    </ul>\n  </div>\n</div>\n";

},{}],53:[function(require,module,exports){
module.exports = "<form role=\"form\" id=\"login-password-form\">\n<div class=\"modal-body padding-bottom-none\" id=\"login-view\">\n\n  <% if (message && !_.isUndefined(message.message)) { %>\n  <div class=\"alert alert-warning\">\n    <%= message.message %>\n  </div>\n  <% } %>\n\n  <% if (login.oauth.length > 0) { %>\n  <div class=\"login-oauth\">Login with\n  <% _.each(login.oauth, function (e) { %>\n  <div class=\"row\">\n    <div class=\"col-sm-offset-3 col-sm-6\">\n      <div class=\"login-option\">\n        <a href=\"<%= login.config[e].endpoint %>\" class=\"btn btn-c0 btn-login\">\n          <img src=\"<%= login.config[e].image %>\" alt=\"<%= login.config[e].name %>\" class=\"btn-login-responsive\"/>\n        </a>\n      </div>\n    </div>\n  </div>\n  <% }); %>\n  </div>\n  <% } %>\n\n  <% if (login.local.enabled === true) { %>\n    <% if (login.oauth.length > 0) { %>\n    <hr/>\n    <% } %>\n    <div class=\"alert alert-danger\" id=\"login-error\" style=\"display:none;\"></div>\n      <div class=\"form-group\">\n        <label for=\"username\" class=\"control-label\" data-i18n=\"loginModal.emailAddress\">Email Address</label>\n        <input type=\"email\" class=\"form-control\" id=\"username\" name=\"username\" placeholder=\"Email Address\"/>\n      </div>\n      <div class=\"form-group margin-bottom-none\">\n        <label for=\"password\" class=\"control-label\">Password</label>\n        <input type=\"password\" class=\"form-control\" id=\"password\" name=\"password\" placeholder=\"Password\"/>\n        <a href=\"#forgot-password\" class=\"forgot-password\" id=\"forgot-password\">Forgot your password?</a>\n      </div>\n    </div>\n    <div class=\"modal-footer modal-footer-grey\" id=\"login-footer\">\n      <div class=\"row\">\n        <div class=\"col-md-12\">\n          <button type=\"submit\" class=\"btn btn-c2 pull-right\">Sign in</button>\n          <p class=\"pull-left login-register-label\" id=\"login-register-label\">\n            Need an account? \n            <a href=\"#login-register\" id=\"login-register\">\n              <strong>Sign up now</strong>\n            </a>\n          </p>\n        </div>\n      </div>\n    </div>\n  <% } else { %>\n  </div>\n  <% } %>\n</form>\n\n<form role=\"form\" id=\"registration-form\">\n<div class=\"modal-body padding-bottom-none\" id=\"registration-view\">\n    <h2>Create a New Account</h2>\n\n    <div class=\"row\">\n      <div class=\"col-sm-12\">\n        <div class=\"form-group\">\n          <label for=\"rname\" class=\"control-label\" data-i18n=\"loginModal.name\">Name</label>\n          <input type=\"text\" class=\"form-control validate\" id=\"rname\" name=\"rname\" placeholder=\"Full Name\" data-validate=\"empty\">\n          <span class=\"help-block error-empty\" style=\"display:none;\">Please enter your full name.</span>\n        </div>\n      </div>\n      <div class=\"col-sm-12\">\n        <div class=\"form-group\">\n          <label for=\"rusername\" class=\"control-label\" data-i18n=\"loginModal.emailAddress\">Email Address</label>\n          <div class=\"input-group\">\n            <input type=\"text\" class=\"form-control validate\" id=\"rusername\" name=\"username\" placeholder=\"Email Address\" data-validate=\"button\"/>\n            <span class=\"input-group-btn\">\n              <a href=\"#\" class=\"btn btn-danger\" id=\"rusername-button\" tabindex=\"-1\">\n                <i id=\"rusername-check\" class=\"fa fa-times\"></i>\n              </a>\n            </span>\n          </div>\n          <span class=\"help-block error-button\" style=\"display:none;\">The email address is not valid or is already in use.</span>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"password-view\">\n    </div>\n\n    <div class=\"checkbox\">\n      <label>\n        <% if (login.terms.enabled === true) { %>\n        <input type=\"checkbox\" id=\"rterms\" class=\"validate\" data-validate=\"checked\"> <span data-i18n=\"loginModal.tosCheckbox\">Yes, I agree to the </span><a href=\"<%= login.terms.link %>\"><%= login.terms.name %></a>.\n        <span class=\"help-block error-checked\" style=\"display:none;\">You must accept the <%= login.terms.name %> to register.</span>\n        <% } %>\n      </label>\n    </div>\n\n    <div class=\"form-group margin-bottom-none\">\n      <div class=\"row\">\n        <div class=\"col-sm-12\">\n          <div class=\"alert alert-danger\" id=\"registration-error\" style=\"display:none;\"></div>\n        </div>\n      </div>\n    </div>\n</div>\n<div class=\"modal-footer modal-footer-grey\" id=\"registration-footer\" style=\"display:none;\">\n  <div class=\"row\">\n    <div class=\"col-sm-12\">\n      <div class=\"pull-right\">\n        <button type=\"button\" id=\"register-cancel\" class=\"btn btn-c0\">Cancel</button>\n        <button type=\"submit\" class=\"btn btn-c2\">Register</button>\n      </div>\n    </div>\n  </div>\n</div>\n</form>\n\n<form role=\"form\" id=\"forgot-form\">\n<div class=\"modal-body padding-bottom-none\" id=\"forgot-view\">\n    <h2>Reset Your Password</h2>\n\n    <p>Please enter your email address and we'll send you a link to reset your password</p>\n\n    <div class=\"form-group\">\n      <label for=\"fusername\" class=\"control-label\">Email Address</label>\n      <input type=\"text\" class=\"form-control validate\" id=\"fusername\" name=\"username\" placeholder=\"Email Address\" data-validate=\"button\"/>\n    </div>\n    <div class=\"form-group margin-bottom-none\">\n      <div class=\"row\">\n        <div class=\"col-sm-12\">\n          <div class=\"alert alert-danger\" id=\"forgot-error\" style=\"display:none;\"></div>\n        </div>\n      </div>\n    </div>\n</div>\n<div class=\"modal-footer modal-footer-grey\" id=\"forgot-footer\" style=\"display:none;\">\n  <div class=\"row\">\n    <div class=\"col-sm-12\">\n      <div class=\"pull-right\">\n        <button type=\"button\" id=\"forgot-cancel\" class=\"btn btn-c0\">Cancel</button>\n        <button type=\"submit\" class=\"btn btn-c2\">Reset Password</button>\n      </div>\n    </div>\n  </div>\n</div>\n</form>\n\n<div class=\"modal-body padding-bottom-none\" id=\"forgot-done-view\">\n    <h2>Reset Your Password</h2>\n\n    <p>\n      Thank you! An email will arrive shortly with a link to reset your password.\n    </p>\n    <p>\n      If you don't receive an email shortly, check your spam folder.\n    </p>\n</div>\n<div class=\"modal-footer modal-footer-grey\" id=\"forgot-done-footer\" style=\"display:none;\">\n  <div class=\"row\">\n    <div class=\"col-sm-12\">\n      <div class=\"pull-right\">\n        <button type=\"button\" id=\"forgot-done-cancel\" class=\"btn btn-c2\">Return to Login</button>\n      </div>\n    </div>\n  </div>\n</div>";

},{}],54:[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../mixins/utilities');
var LoginPasswordTemplate = require('../templates/login_password_template.html');


var LoginPasswordView = Backbone.View.extend({

  initialize: function (options) {
    this.options = options;
  },

  render: function () {
    var template = _.template(LoginPasswordTemplate);
    this.$el.html(template);
    return this;
  },

  cleanup: function () {
    removeView(this);
  },
});

module.exports = LoginPasswordView;


},{"../../../mixins/utilities":128,"../templates/login_password_template.html":52,"backbone":133,"underscore":159}],55:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../mixins/utilities');
var LoginPasswordView = require('./login_password_view');
var LoginTemplate = require('../templates/login_template.html');
var ModalComponent = require('../../../components/modal');


var LoginView = Backbone.View.extend({

  events: {
    'click .oauth-link'              : 'link',
    'keyup #rname'                   : 'checkName',
    'change #rname'                  : 'checkName',
    'blur #rname'                    : 'checkName',
    'keyup #rusername'               : 'checkUsername',
    'change #rusername'              : 'checkUsername',
    'click #rusername-button'        : 'clickUsername',
    'keyup #rpassword'               : 'checkPassword',
    'blur #rpassword'                : 'checkPassword',
    'keyup #rpassword-confirm'       : 'checkPasswordConfirm',
    'blur #rpassword-confirm'        : 'checkPasswordConfirm',
    'submit #login-password-form'    : 'submitLogin',
    'submit #registration-form'      : 'submitRegister',
    'submit #forgot-form'            : 'submitForgot'
  },

  initialize: function (options) {
    this.options = options;
  },

  render: function () {
    var self = this;
    var data = {
      login: this.options.login,
      message: this.options.message
    };
    var template = _.template(LoginTemplate)(data);
    this.$el.html(template);
    this.$el.i18n();
    this.loginPasswordView = new LoginPasswordView({
      el: this.$(".password-view")
    }).render();
    setTimeout(function () {
      self.$("#username").focus();
    }, 500);
    return this;
  },

  link: function (e) {
    if (e.preventDefault) e.preventDefault();
    var link = $(e.currentTarget).attr('href');
    window.location.href = link;
  },

  v: function (e) {
    return validate(e);
  },

  submitLogin: function (e) {
    var self = this;
    if (e.preventDefault) e.preventDefault();
    var data = {
      username: this.$("#username").val(),
      password: this.$("#password").val(),
      json: true
    };
    $.ajax({
      url: '/api/auth/local',
      type: 'POST',
      data: data
    }).done(function (success) {
      // Set the user object and trigger the user login event
      window.cache.currentUser = success;
      window.cache.userEvents.trigger("user:login", success);
    }).fail(function (error) {
      var d = JSON.parse(error.responseText);
      self.$("#login-error").html(d.message);
      self.$("#login-error").show();
    });
  },

  submitRegister: function (e) {
    var self = this,
        $submitButton = self.$('#registration-form [type="submit"]');
    if (e.preventDefault) e.preventDefault();

    $submitButton.prop('disabled', true);
    // validate input fields
    var validateIds = ['#rname', '#rusername', '#rpassword'];
    // Only validate terms & conditions if it is enabled
    if (this.options.login.terms.enabled === true) {
      validateIds.push('#rterms');
    }
    var abort = false;
    for (i in validateIds) {
      var iAbort = validate({ currentTarget: validateIds[i] });
      abort = abort || iAbort;
    }
    var passwordSuccess = this.checkPassword();
    var parent = $(this.$("#rpassword").parents('.form-group')[0]);
    if (passwordSuccess !== true) {
      parent.addClass('has-error');
      $(parent.find('.error-password')[0]).show();
    } else {
      $(parent.find('.error-password')[0]).hide();
    }
    var passwordConfirmSuccess = this.checkPasswordConfirm();
    var passwordConfirmParent = $(this.$("#rpassword-confirm").parents('.form-group')[0]);
    if (passwordConfirmSuccess !== true) {
      passwordConfirmParent.addClass('has-error');
      $(passwordConfirmParent.find('.error-password')[0]).show();
    } else {
      $(passwordConfirmParent.find('.error-password')[0]).hide();
    }
    if (abort === true || passwordSuccess !== true || passwordConfirmSuccess !== true) {
      $submitButton.prop('disabled', false);
      return;
    }

    // Create a data object with the required fields
    var data = {
      name: this.$("#rname").val(),
      username: this.$("#rusername").val(),
      password: this.$("#rpassword").val(),
      json: true
    };
    // Add in additional, optional fields
    if (this.options.login.terms.enabled === true) {
      data['terms'] = (this.$("#rterms").val() == "on");
    }
    // Post the registration request to the server
    $.ajax({
      url: '/api/auth/register',
      type: 'POST',
      data: data
    }).done(function (success) {
      // Set the user object and trigger the user login event
      window.cache.currentUser = success;
      window.cache.userEvents.trigger("user:login", success);
    }).fail(function (error) {
      var d = JSON.parse(error.responseText);
      self.$("#registration-error").html(d.message);
      self.$("#registration-error").show();
      $submitButton.prop('disabled', false);
    });
  },

  submitForgot: function (e) {
    var self = this;
    if (e.preventDefault) e.preventDefault();
    var data = {
      username: this.$("#fusername").val()
    };
    // Post the registration request to the server
    $.ajax({
      url: '/api/auth/forgot',
      type: 'POST',
      data: data
    }).done(function (success) {
      // Set the user object and trigger the user login event
      self.$("#forgot-view").hide();
      self.$("#forgot-footer").hide();
      self.$("#forgot-done-view").show();
      self.$("#forgot-done-footer").show();
    }).fail(function (error) {
      var d = JSON.parse(error.responseText);
      self.$("#forgot-error").html(d.message);
      self.$("#forgot-error").show();
    });
  },

  checkName: function (e) {
    var name = this.$("#rname").val();
    if (name && name !== '') {
      $("#rname").closest(".form-group").find(".help-block").hide();
    } else {
      $("#rname").closest(".form-group").find(".help-block").show();
    }
  },

  checkUsername: function (e) {
    var username = $("#rusername").val();
    $.ajax({
      url: '/api/user/username/' + username,
    }).done(function (data) {
      $("#rusername-button").removeClass('btn-success');
      $("#rusername-button").removeClass('btn-danger');
      $("#rusername-check").removeClass('fa fa-check');
      $("#rusername-check").removeClass('fa fa-times');
      if (data) {
        // username is taken
        $("#rusername-button").addClass('btn-danger');
        $("#rusername-check").addClass('fa fa-times');
      } else {
        // username is available
        $("#rusername-button").addClass('btn-success');
        $("#rusername-check").addClass('fa fa-check');
        $("#rusername").closest(".form-group").removeClass('has-error');
        $("#rusername").closest(".form-group").find(".help-block").hide();
      }
    });
  },

  checkPassword: function (e) {
    var rules = validatePassword(this.$("#rusername").val(), this.$("#rpassword").val());
    var valuesArray = _.values(rules);
    var validRules = _.every(valuesArray);
    var success = true;
    if (validRules === true) {
      $("#rpassword").closest(".form-group").removeClass('has-error');
      $("#rpassword").closest(".form-group").find(".help-block").hide();
    }
    _.each(rules, function (value, key) {
      if (value === true) {
        this.$(".password-rules .success.rule-" + key).show();
        this.$(".password-rules .error.rule-" + key).hide();
      } else {
        this.$(".password-rules .success.rule-" + key).hide();
        this.$(".password-rules .error.rule-" + key).show();
      }
      success = success && value;
    });
    return success;
  },

  checkPasswordConfirm: function (e) {
    var success = true;
    var password = this.$("#rpassword").val();
    var confirm = this.$("#rpassword-confirm").val()
    if (password === confirm) {
      $("#rpassword-confirm").closest(".form-group").find(".help-block").hide();
    } else {
      $("#rpassword-confirm").closest(".form-group").find(".help-block").show();
      success = false;
    }
    return success;
  },

  clickUsername: function (e) {
    e.preventDefault();
  },

  cleanup: function () {
    if (this.loginPasswordView) { this.loginPasswordView.cleanup(); }
    removeView(this);
  },
});

module.exports = LoginView;

},{"../../../components/modal":106,"../../../mixins/utilities":128,"../templates/login_template.html":53,"./login_password_view":54,"backbone":133,"underscore":159}],56:[function(require,module,exports){
module.exports = "<div id=\"login-wrapper\"></div>\n<div class=\"navbar navbar-default navbar-static-top\">\n  <div class=\"container\">\n    <div class=\"navbar-header\">\n      <button type=\"button\" class=\"navbar-toggle\" data-toggle=\"collapse\" data-target=\".navbar-collapse\">\n        <span class=\"icon-bar\"></span>\n        <span class=\"icon-bar\"></span>\n        <span class=\"icon-bar\"></span>\n      </button>\n      <a class=\"navbar-brand\" href=\"/\" title=\"<%- systemName %> Home\">\n      </a>\n    </div>\n    <div class=\"navbar-collapse collapse pull-right\">\n      <ul class=\"nav navbar-nav\">\n\n        <% if (ui.project.show) { %>\n        <li class=\"projects\">\n          <a href=\"/projects\" class=\"nav-link\">\n            <i class=\"fa fa-rocket\"></i>\n            <span class=\"navbar-title-small\" data-i18n=\"Browse\">Browse</span><br/>\n            <span class=\"navbar-title-big\" data-i18n=\"ProjectPlural\">Projects</span>\n          </a>\n        </li>\n        <% } %>\n        <li class=\"tasks\">\n          <a href=\"/tasks\" class=\"nav-link\">\n            <i class=\"fa fa-tags\"></i>\n            <span class=\"navbar-title-small\" data-i18n=\"Browse\">Browse</span><br/>\n            <span class=\"navbar-title-big\" data-i18n=\"TaskPlural\">Tasks</span>\n          </a>\n        </li>\n\n        <li class=\"divider-vertical navbar-text\"></li>\n        <% if (user) { %>\n          <li class=\"profile dropdown\"><a href=\"/profile\" id=\"navbar-profile\" role=\"button\" class=\"dropdown-toggle\" data-toggle=\"dropdown\">\n            <img src=\"/api/user/photo/<%- user.id %>\" class=\"navbar-people\"/> &nbsp;\n              <% if (user.name) { %><%- user.name %>\n              <% } else { %><%- user.username %>\n              <% } %>\n            </a>\n            <ul class=\"dropdown-menu\" role=\"menu\" aria-labelledby=\"navbar-profile\">\n              <li role=\"presentation\"><a role=\"menuitem\" class=\"nav-link\" tabindex=\"-1\" href=\"/profile\">Profile</a></li>\n              <% if (user.isAdmin === true) { %>\n              <li role=\"presentation\" class=\"divider\"></li>\n              <li role=\"presentation\"><a role=\"menuitem\"\n                 tabindex=\"-1\" href=\"/admin\" class=\"nav-link\">Administration</a></li>\n              <% } %>\n              <% if (login.local.logout) { %>\n              <li role=\"presentation\" class=\"divider\"></li>\n              <li role=\"presentation\"><a role=\"menuitem\"\n                 tabindex=\"-1\" href=\"/auth/logout\" class=\"logout\">Logout</a></li>\n              <% } %>\n            </ul>\n          </li>\n        <% } else { %>\n          <% if (login.signin !== false) { %>\n          <li class=\"navbar-1line\"><a href=\"/auth\" class=\"login\"><i class=\"fa fa-plus-circle\"></i> Sign In</a></li>\n          <% } %>\n        <% }; %>\n      </ul>\n    </div>\n  </div>\n</div>\n";

},{}],57:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../mixins/utilities');
var UIConfig = require('../../../config/ui.json');
var Login = require('../../../config/login.json');
var LoginController = require('../../login/controllers/login_controller');
var NavTemplate = require('../templates/nav_template.html');


var NavView = Backbone.View.extend({

  events: {
    'click .navbar-brand'   : linkBackbone,
    'click .nav-link'       : linkBackbone,
    'click .login'          : 'loginClick',
    'click .logout'         : 'logout'
  },

  initialize: function (options) {
    var self = this;
    this.options = options;

    this.listenTo(window.cache.userEvents, "user:login:success", function (userData) {
      self.doRender({ user: userData });
    });

    this.listenTo(window.cache.userEvents, "user:logout", function () {
      self.doRender({ user: null });
      Backbone.history.loadUrl();
      window.cache.userEvents.trigger("user:logout:success");
    });

    // request that the user log in to see the page
    this.listenTo(window.cache.userEvents, "user:request:login", function (message) {
      // trigger the login modal
      self.login(message);
    });

    // update the navbar when the profile changes
    this.listenTo(window.cache.userEvents, "user:profile:save", function (data) {
      // reset the currentUser object
      window.cache.currentUser = data;
      // re-render the view
      self.render();
    });

    // update the user's photo when they change it
    this.listenTo(window.cache.userEvents, "user:profile:photo:save", function (url) {
      $(".navbar-people").attr('src', url);
    });
  },

  render: function () {
    var self = this;
    this.doRender({ user: window.cache.currentUser, systemName: window.cache.system.name });
    return this;
  },

  doRender: function (data) {
    data.login = Login;
    data.ui = UIConfig;
    var template = _.template(NavTemplate)(data);
    this.$el.html(template);
    this.$el.i18n();
    $(".nav li").on("click", function () {
      $(".nav li").removeClass("active");
      $(this).addClass("active");
    });
  },

  loginClick: function (e) {
    if (e.preventDefault) e.preventDefault();
    this.login();
  },

  login: function (message) {
    if (this.loginController) {
      this.loginController.cleanup();
    }
    this.loginController = new LoginController({
      el: '#login-wrapper',
      message: message
    });
  },

  logout: function (e) {
    if (e.preventDefault) e.preventDefault();
    $.ajax({
      url: '/api/auth/logout?json=true',
    }).done(function (success) {
      window.cache.currentUser = null;
      window.cache.userEvents.trigger("user:logout");
    }).fail(function (error) {
      // do nothing
    });
  },

  cleanup: function () {
    if (this.loginController) { this.loginController.cleanup(); }
    removeView(this);
  },
});

module.exports = NavView;

},{"../../../config/login.json":114,"../../../config/ui.json":116,"../../../mixins/utilities":128,"../../login/controllers/login_controller":51,"../templates/nav_template.html":56,"backbone":133,"underscore":159}],58:[function(require,module,exports){
module.exports = "<form role=\"form\" action=\"\" id=\"email-form\">\n  <div class=\"modal-body\">\n    <div class=\"alert alert-warning\" style=\"display:none;\"></div>\n    <fieldset>\n      <div class=\"form-group\">\n        <label for=\"email\">Email Address</label>\n        <input type=\"email\" class=\"form-control\" id=\"email\" name=\"email\" placeholder=\"name@domain.com\"/>\n      </div>\n    </fieldset>\n  </div>\n  <div class=\"modal-footer\">\n    <button type=\"button\" class=\"btn btn-c0\" data-dismiss=\"modal\">Cancel</button>\n    <input type=\"submit\" class=\"btn btn-c2\" id=\"submit\" value=\"Add Email Address\"/>\n  </div>\n</form>\n";

},{}],59:[function(require,module,exports){

var Bootstrap = require('bootstrap');
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var EmailFormTemplate = require('../templates/profile_email_form.html');


var EmailFormView = Backbone.View.extend({

  events: {
    "submit #email-form" : "post"
  },

  initialize: function (options) {
    this.target = options.target;
    this.options = options;
  },

  render: function () {
    var template = _.template(EmailFormTemplate)({});
    this.$el.html(template);
    return this;
  },

  post: function (e) {
    if (e.preventDefault) e.preventDefault();
    var data;
    var self = this;

    this.$(".alert").hide();
    data = {
      email: $(e.currentTarget).find("#email").val(),
    }

    $.ajax({
      url: '/api/useremail',
      type: 'POST',
      data: data,
      success: function (result) {
        // Pass the tag back
        self.options.model.trigger(self.target + ":email:new", result);
      },
      error: function (req, status, error) {
        self.$(".alert").html(req.responseJSON.message);
        self.$(".alert").show();
        self.options.model.trigger(self.target + ":email:error", req.responseJSON);
      }
    });

  },

  cleanup: function () {
    removeView(this);
  }

});

module.exports = EmailFormView;

},{"../../../../mixins/utilities":128,"../templates/profile_email_form.html":58,"backbone":133,"bootstrap":138,"underscore":159}],60:[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');
var BaseController = require('../../../../base/base_controller');
var ProfileModel = require('../../../../entities/profiles/profile_model');
var ProfileView = require('../views/profile_show_view');
var ProfileSettingsView = require('../views/profile_settings_view');
var ProfileResetView = require('../views/profile_reset_view');
var Login = require('../../../../config/login.json');
var AlertTemplate = require('../../../../components/alert_template.html');

Profile = BaseController.extend({

  // Here we are defining wether or not this is a full-region object
  // or a sub-region of another region.
  region: true,
  subRegion: false,

  el: "#container",

  events: {
  },

  initialize: function (options) {
    this.options = options;
    this.routeId = options.id;
    this.action = options.action;
    this.data = options.data;
    this.initializeController();
  },

  initializeController: function () {
    // Clean up previous views
    if (this.profileView) { this.profileView.cleanup(); }
    if (this.settingsView) { this.settingsView.cleanup(); }
    if (this.profileResetView) { this.profileResetView.cleanup(); }
    // If the action does not require the profile model, display that action
    if (this.routeId == 'reset') {
      this.profileResetView = new ProfileResetView({
        el: this.$el,
        routeId: this.routeId,
        action: this.action,
        data: this.data
      }).render();
    }
    // otherwise load the profile model and display the appropriate view
    else {
      this.initializeProfileModelInstance();
    }
  },

  initializeProfileModelInstance: function () {
    var self = this;

    if (this.model) this.model.remove();
    this.model = new ProfileModel();

    // prevent directly editing profiles when disabled
    if ((Login.profile.edit === false) && (this.action == 'edit')) {
      var data = {
        alert: {
          message: "<strong>Direct editing of profiles is disabled.</strong>  <a href=\"" + Login.profile.editUrl + "\" title=\"Edit Profile\">Click here to edit your profile</a>"
        }
      };
      var template = _.template(AlertTemplate)(data)
      this.$el.html(template);
      return;
    }
    // var fetchId = null;
    // if (this.id && this.id != 'edit') { fetchId = this.id; }
    this.model.trigger("profile:fetch", this.routeId);
    // process a successful model fetch, and display the model
    this.listenTo(this.model, "profile:fetch:success", function (model) {
      // @instance
      self.model = model;
      var modelJson = model.toJSON();
      for (i in modelJson.tags) {
        if (modelJson.tags[i].tag.type == 'agency') {
          self.model.agency = modelJson.tags[i].tag;
          self.model.agency['tagId'] = modelJson.tags[i].id;
        }
        else if (modelJson.tags[i].tag.type == 'location') {
          self.model.location = modelJson.tags[i].tag;
          self.model.location['tagId'] = modelJson.tags[i].id;
        }
      }
      self.initializeProfileViewInstance();
    });
    // if the profile fetch fails, check if it is due to the user
    // not being logged in
    this.listenTo(this.model, "profile:fetch:error", function (model, response) {
      // if the user isn't logged in, trigger the login window
      if (response.status === 403) {
        window.cache.userEvents.trigger("user:request:login", {
          message: "You must be logged in to view profiles",
          disableClose: false
        });
      }
      var data = {
        alert: {
          message: "<strong>Unable to load profile.  Please reload this page to try again.</strong><br/>Error: "
        }
      };
      // check if the response provided an error
      if (response.responseText) {
        var err = JSON.parse(response.responseText);
        if (err.message) {
          data.alert.message += err.message;
        }
      }
      var template = _.template(AlertTemplate)(data)
      self.$el.html(template);
    });
  },

  initializeProfileViewInstance: function () {
    if (this.action == 'settings') {
      this.settingsView = new ProfileSettingsView({
        el: this.$el,
        model: this.model,
        routeId: this.routeId,
        action: this.action,
        data: this.data
      }).render();
    } else {
      this.profileView = new ProfileView({
        el: this.$el,
        model: this.model,
        routeId: this.routeId,
        action: this.action,
        data: this.data
      }).render();
    }
  },

  cleanup: function() {
    if (this.profileView) { this.profileView.cleanup(); }
    if (this.settingsView) { this.settingsView.cleanup(); }
    removeView(this);
  }

});

module.exports = Profile;

},{"../../../../base/base_controller":101,"../../../../components/alert_template.html":103,"../../../../config/login.json":114,"../../../../entities/profiles/profile_model":121,"../views/profile_reset_view":67,"../views/profile_settings_view":68,"../views/profile_show_view":69,"backbone":133,"underscore":159}],61:[function(require,module,exports){
module.exports = "<ul class=\"nav nav-tabs\">\n  <li class=\"active\"><a href=\"#<%= handle %>-tab-open\" data-toggle=\"tab\">Open</a></li>\n  <li><a href=\"#<%= handle %>-tab-closed\" data-toggle=\"tab\">Closed</a></li>\n</ul>\n\n<div class=\"tab-content\">\n  <div class=\"tab-pane active\" id=\"<%= handle %>-tab-open\">\n    <table class=\"table table-condensed table-hover\">\n      <% if ( count.open > 0 || count.assigned > 0 || count.draft > 0) { %>\n        <thead>\n          <tr>\n            <th data-i18n=\"<%= targetCapitalized %>\">Project</th>\n            <th>Created</th>\n            <th>Likes</th>\n          </tr>\n        </thead>\n        <tbody>\n        <% for (var i in data) { %>\n          <% if (data[i].state == 'completed' || data[i].state == 'archived') { continue; } %>\n          <tr>\n            <td>\n              <% if (data[i].state == 'draft') { %>\n              <span class=\"label label-warning\">draft</span>\n              <% } %>\n              <a href=\"<%= target %>s/<%= data[i].id %>\" class=\"activity-link\" data-id=\"<%= data[i].id %>\"><%= data[i].title %></a>\n            </td>\n            <td>\n              <% var created = new Date(data[i].createdAt); %>\n              <%= created.toLocaleDateString() %> <%= created.toLocaleTimeString() %></td>\n            <td><%= data[i].likeCount %></td>\n          </tr>\n        <% } %>\n        </tbody>\n      <% } else { %>\n        <tbody>\n          <tr>\n            <td>No <%= targetsFriendly %></td>\n          </tr>\n        </tbody>\n      <% } %>\n    </table>\n  </div>\n  <div class=\"tab-pane\" id=\"<%= handle %>-tab-closed\">\n    <table class=\"table table-condensed table-hover\">\n      <% if (count.completed > 0 || count.archived > 0) { %>\n        <thead>\n          <tr>\n            <th data-i18n=\"<%= targetCapitalized %>\">Project</th>\n            <th>Created</th>\n            <th>Likes</th>\n          </tr>\n        </thead>\n        <tbody>\n        <% for (var i in data) { %>\n          <% if (data[i].state !== 'completed' && data[i].state !== 'archived') { continue; } %>\n          <tr>\n            <td>\n              <a href=\"<%= target %>s/<%= data[i].id %>\" class=\"activity-link\" data-id=\"<%= data[i].id %>\"><%= data[i].title %></a>\n            </td>\n            <td><%= data[i].createdAt %></td>\n            <td><%= data[i].likeCount %></td>\n          </tr>\n        <% } %>\n        </tbody>\n      <% } else { %>\n        <tbody>\n          <tr>\n            <td>No <%= targetsFriendly %></td>\n          </tr>\n        </tbody>\n      <% } %>\n    </table>\n  </div>\n</div>\n";

},{}],62:[function(require,module,exports){
module.exports = "<div class=\"radio\">\n  <label>\n    <input type=\"radio\" name=\"primaryEmail\" id=\"email-<%- email.id %>\" value=\"<%- email.email %>\" <% if (email.isPrimary) { %>checked<% } %>>\n    <a href=\"#\" class=\"email-remove\" id=\"email-remove-<%- email.id %>\" data-id=\"<%- email.id %>\"><span class=\"fa fa-trash\"></span></a> <%- email.email %>\n  </label>\n</div>\n";

},{}],63:[function(require,module,exports){
module.exports = "<div class=\"row\">\n\n  <div class=\"row\">\n    <div class=\"col-md-6 col-md-offset-3 box\">\n      <div class=\"box-main\">\n\n        <div class=\"profile-reset center\" id=\"profile-reset-check\">\n          <i class=\"fa fa-spin fa-spinner\"></i> Looking up password reset code...\n        </div>\n\n        <div class=\"profile-reset error\" id=\"profile-reset-check-error\" style=\"display: none;\">\n          This is not a valid password reset code.  Please try resetting your password again and clicking on the link in the email.\n        </div>\n        <div class=\"profile-reset error\" id=\"profile-reset-submit-error\" style=\"display: none;\">\n          An error occurred resetting your password.  Please reload this page and try again.\n        </div>\n\n        <div class=\"profile-reset\" id=\"profile-reset-dialog\" style=\"display: none;\">\n          <form id=\"form-password-reset\" title=\"Password Reset\">\n            <h1>\n              Please set a new password for your account.\n            </h1>\n            <div class=\"password-view\">\n            </div>\n            <div>\n              <input type=\"submit\" class=\"btn btn-c1\" value=\"Reset Password\"/>\n            </div>\n          </form>\n        </div>\n        <div class=\"profile-reset center\" id=\"profile-reset-submit\" style=\"display: none;\">\n          <i class=\"fa fa-spin fa-spinner\"></i> Performing password reset.  Please stand by...\n        </div>\n\n      </div>\n    </div>\n  </div>\n\n</div>\n";

},{}],64:[function(require,module,exports){
module.exports = "<div class=\"row\">\n\n  <div class=\"alert alert-info\">\n    Profile settings are not yet implemented.  Please contact the administrator of this system to update your email settings.  Our apologies, stay tuned!\n  </div>\n\n</div>\n";

},{}],65:[function(require,module,exports){
module.exports = "<div class=\"row\">\n\n  <% if (user.isAdmin) { %>\n  <div class=\"alert alert-info\">\n    You are an administrator.\n    <% if (user.id !== data.id) { %>\n      <% if (edit === true) { %>\n        <strong>You are editing another user's profile.</strong>\n      <% } else { %>\n        You are viewing another user's profile.\n      <% } %>\n    <% } %>\n  </div>\n  <% } %>\n\n  <% if (saved) { %>\n  <div class=\"alert alert-success\">Your profile has been successfully updated.</div>\n  <% } %>\n\n  <div class=\"col-sm-3 col-md-4 project-sidebar\">\n    <!-- LEFT SIDEBAR -->\n\n    <div class=\"row\">\n      <div class=\"col-md-12 box project-header-wrapper\">\n        <div id=\"project-header\" style=\"background-image:url('/api/user/photo/<%- data.id %>');\">\n          <div class=\"btn btn-c2 fileinput-button\" <% if (!((data.isOwner || user.isAdmin) && edit)) { %>style=\"display:none;\"<% } %>>\n            <i class=\"fa fa-camera fa-lg\" title=\"Change Cover Photo\" id=\"fileupload-icon\"></i>\n            <input id=\"fileupload\" type=\"file\" name=\"files[]\" title=\"Upload Photo\">\n          </div>\n        </div>\n        <div id=\"file-upload-progress-container\" style=\"display: none;\" class=\"progress progress-striped active\">\n          <div id=\"file-upload-progress\" class=\"progress-bar\" style=\"width: 0\"></div>\n        </div>\n        <div id=\"file-upload-alert\" class=\"alert alert-warning\" style=\"display:none;\">\n        </div>\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"col-md-12 box\">\n        <div class=\"box-main tag-wrapper\">\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"col-sm-9 col-md-8\">\n    <!-- RIGHT MAIN BAR -->\n    <% if (edit) { %> <!-- in edit mode -->\n    <div class=\"box box-main\">\n      <div id=\"emailModal\"></div>\n\n      <form class=\"form-horizontal\" role=\"form\" id=\"profile-form\">\n        <h1>\n          <div class=\"form-group\">\n            <input type=\"text\" class=\"form-control input-lg\" id=\"name\" name=\"name\" placeholder=\"Your Full Name\" value=\"<% if (data.name) { %><%- data.name %><% } %>\" title=\"Your Full Name\"/>\n          </div>\n        </h1>\n\n        <h2> Bio </h2>\n\n        <div class=\"form-group\">\n          <label for=\"title\" class=\"col-md-3 control-label\">Title</label>\n          <div class=\"col-md-9\">\n            <input type=\"text\" class=\"form-control\" id=\"title\" name=\"title\" placeholder=\"Title\" value=\"<% if (data.title) { %><%- data.title %><% } %>\"/>\n          </div>\n        </div>\n\n        <div class=\"form-group\">\n          <label for=\"company\" class=\"col-md-3 control-label\">Agency</label>\n          <div class=\"col-md-9\">\n            <input type=\"hidden\" id=\"company\" name=\"company\" style=\"width: 100%\"/>\n          </div>\n        </div>\n\n        <div class=\"form-group\">\n          <label for=\"location\" class=\"col-md-3 control-label\">Location</label>\n          <div class=\"col-md-9\">\n            <input type=\"hidden\" id=\"location\" name=\"location\" style=\"width: 100%\"/>\n          </div>\n        </div>\n\n        <div class=\"form-group\">\n          <label for=\"bio\" class=\"col-md-3 control-label\">A brief public biography</label>\n          <div class=\"col-md-9\">\n            <div class=\"markdown-edit\"></div>\n          </div>\n        </div>\n\n        <h2> Account Information </h2>\n\n        <div class=\"form-group\">\n          <label for=\"profile-email\" class=\"col-md-3 control-label\">Email</label>\n          <div class=\"col-md-9\">\n            <input type=\"text\" class=\"form-control\" id=\"profile-email\" name=\"email\"\n              placeholder=\"Email\" value=\"<% if (email) { %><%- email.email %><% } %>\">\n            <div id=\"email-update-alert\" class=\"alert alert-warning\" style=\"display:none;\"></div>\n          </div>\n        </div>\n\n        <div class=\"form-group\">\n          <% if (login.oauth.length > 0) { %>\n          <label for=\"services\" class=\"col-md-3 control-label\">Connected Accounts</label>\n          <div class=\"col-md-9\" id=\"services\">\n            <form class=\"form-horizontal\" role=\"form\">\n            <% _.each(login.oauth, function (a) { %>\n              <div class=\"form-group\">\n                <div class=\"col-xs-8 col-sm-9 col-md-9\">\n                  <img src=\"<%= login.config[a].image %>\" alt=\"<%= login.config[a].name %>\" style=\"height: 30px\"/>\n                </div>\n                <div class=\"col-xs-4 col-sm-3 col-md-3\">\n                  <% if (_.contains(data.auths, a)) { %>\n                  <a href=\"#\" class=\"btn btn-danger btn-sm removeAuth pull-right\" data-service=\"<%= a %>\"><span class=\"fa fa-remove\"></span> Disconnect</a>\n                  <% } else { %>\n                  <a href=\"<%= login.config[a].endpoint %>\" class=\"btn btn-success btn-sm pull-right\"><span class=\"fa fa-plus\"></span> Connect</a>\n                  <% } %>\n                  <!-- <%= login.config[a].name %> -->\n                </div>\n              </div>\n            <% }); %>\n          </div>\n          <% } %>\n        </div>\n        <div class=\"form-group\">\n          <div class=\"col-md-offset-3 col-md-9\">\n            <div class=\"pull-right\">\n              <a href=\"#\" class=\"btn btn-c0\" id=\"profile-cancel\">Discard Changes</a>\n\n              <button id=\"submit\" type=\"submit\" class=\"btn btn-c2\" disabled=\"disabled\" data-loading-text=\"<i class='fa fa-spinner fa-spin'></i> Saving...\" data-success-text=\"Saved!\" data-fail-text=\"Save Failed.\">Save Profile</button>\n            </div>\n          </div>\n        </div>\n\n      </form>\n    </div>\n    <% } else { %> <!-- not in edit mode -->\n    <div class=\"row\">\n      <div class=\"col-md-9 sm-nopadding md-nopadding\">\n        <div class=\"box box-main\">\n          <h1><% if (data.name) { %><%- data.name %><% } else { %><%- data.username %><% } %></h1>\n\n          <div class=\"profile-jobtitle\"><% if (data.title) { %><i class=\"fa fa-briefcase\"></i> <span class=\"box-icon-text\"><%- data.title %></span><% } %></div>\n          <div class=\"profile-company\"><% if (data.agency) { %><i class=\"icon-library\"></i> <span class=\"box-icon-text\"><%- data.agency.tag.name %></span><% } %></div>\n          <div class=\"profile-location\"><% if (data.location) { %><span class=\"fa fa-map-marker\"></span> <span class=\"box-icon-text\"><%- data.location.tag.name %></span><% } %></div>\n\n          <div class=\"profile-bio box-pad-t\">\n            <% if (data.bioHtml) { %><%= data.bioHtml %><% } else { %>This person doesn't have a bio yet.<% } %>\n          </div>\n        </div>\n      </div>\n      <div class=\"col-md-3 sm-nopadding md-nopadding padding-left-none\">\n        <div class=\"box padding-none\">\n<!--\n          <div class=\"navbar-side like-row border-bottom\">\n            <a href=\"#\" id=\"like-button\" class=\"like-button\">\n              <i id=\"like-button-icon\" class=\"fa fa-star-o fa-lg gold\"></i>\n            </a>\n            <span class=\"like-number\" id=\"like-number\"><%- data.likeCount %></span>\n            <span class=\"like-plural\" id=\"like-text\" data-plural=\"followers\" data-singular=\"follower\">followers</span>\n          </div>\n-->\n          <div class=\"navbar-side <% if (data.isOwner || user.isAdmin) { %>border-bottom<% } %>\">\n            <ul class=\"nav nav-pills nav-stacked\">\n              <li>\n                <a href=\"#\" id=\"email\"><i class=\"fa fa-envelope-o\"></i> <span class=\"box-icon-text\">Share</span></a>\n              </li>\n              <% if (data.isOwner || user.isAdmin) { %>\n              <li>\n                <a href=\"/api/event/ical/\"><span class=\"fa fa-calendar\"></span> <span class=\"box-icon-text\">Calendar</span></a>\n              </li>\n            </ul>\n          </div>\n          <div class=\"navbar-side\">\n              <ul class=\"nav nav-pills nav-stacked\">\n              <li>\n                <% if (login.profile.edit === true) { %>\n                <a href=\"/profile/<%- data.id %>/edit\" class=\"link-backbone\"><i class=\"fa fa-pencil\"></i> <span class=\"box-icon-text\">Edit Profile</span></a>\n                <% } else if (login.profile.editUrl) { %>\n                <a href=\"<%= login.profile.editUrl %>\" target=\"_blank\"><i class=\"fa fa-pencil\"></i> <span class=\"box-icon-text\">Edit Profile</span></a>\n                <% } %>\n              </li>\n              <% } %>\n            </ul>\n          </div>\n        </div>\n\n      </div>\n    </div>\n\n    <% if (data.isOwner) { %>\n    <div class=\"box\">\n      <div class=\"box-pad-lr border-bottom\">\n        <h2>Account Information</h2>\n      </div>\n\n      <div class=\"box-pad-lr box-pad-t\">\n        <div class=\"row\">\n          <div class=\"col-xs-3 col-sm-3 col-md-3\">\n            Email<% if (data.emails.length > 1) { %>s<% }%>:\n          </div>\n          <div class=\"col-xs-9 col-sm-9 col-md-9\">\n            <% for (var e = 0; e < data.emails.length; e++) { %>\n              <% if (data.emails[e].isPrimary) { %>x<% } %>\n              <%- data.emails[e].email %><br/>\n            <% } %>\n            <% if (data.emails.length == 0) { %>\n            No email addresses\n            <% } %>\n          </div>\n        </div>\n\n        <% if (login.oauth.length > 0) { %>\n        <div class=\"row\">\n          <div class=\"col-xs-3 col-sm-3 col-md-3\">\n            Connected Accounts:\n          </div>\n          <div class=\"col-xs-9 col-sm-9 col-md-9\">\n            <% if (data.auths.length === 0) { %>\n              No connected accounts.\n            <% } %>\n            <% _.each(login.oauth, function (a) { %>\n              <% if (_.contains(data.auths, a)) { %>\n              <div>\n                <%= login.config[a].name %>\n                <span class=\"label label-success\">Connected</span>\n              </div>\n              <% } %>\n            <% }); %>\n          </div>\n        </div>\n        <% } %>\n      </div>\n    </div>\n    <% } %>\n\n    <% if (ui.project.show) { %>\n    <div class=\"box\">\n      <div class=\"box-pad-lr border-bottom\">\n        <h2><span data-i18n=\"ProjectPlural\">Projects</span></h2>\n      </div>\n      <div class=\"box-pad-lr box-pad-t\">\n        <div class=\"project-activity-wrapper\"></div>\n      </div>\n    </div>\n    <% } %>\n\n    <div class=\"box\">\n      <div class=\"box-pad-lr border-bottom\">\n        <h2><span data-i18n=\"TaskPlural\">Opportunities</span> Volunteered For</h2>\n      </div>\n      <div class=\"box-pad-lr box-pad-t\">\n        <div class=\"task-activity-wrapper\"></div>\n      </div>\n    </div>\n\n    <div class=\"box\">\n      <div class=\"box-pad-lr border-bottom\">\n        <h2><span data-i18n=\"TaskPlural\">Opportunities</span> Created</h2>\n      </div>\n      <div class=\"box-pad-lr box-pad-t\">\n        <div class=\"task-createdactivity-wrapper\"></div>\n      </div>\n    </div>\n\n    <% } %> <!-- /edit check -->\n\n  </div>\n</div>\n";

},{}],66:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var UIConfig = require('../../../../config/ui.json');
var async = require('async');
var ActTemplate = require('../templates/profile_activity_template.html');


var ProfileActivityView = Backbone.View.extend({

  events: {
    'click .activity-link'    : 'link'
  },

  initialize: function (options) {
    this.options = options;
  },

  render: function () {
    // sort initially by date, descending.
    var results = this.options.data.sort(function (a, b) {
      return new Date(b.createdAt) - new Date(a.createdAt);
    });
    var data = {
      ui: UIConfig,
      target: this.options.target,
      targetFriendly: i18n.t(this.options.target),
      targetsFriendly: i18n.t(this.options.target + 'Plural'),
      targetCapitalized: this.options.target.charAt(0).toUpperCase() + this.options.target.slice(1),
      handle: this.options.handle,
      data: results,
      count: {}
    };

    for (var i in this.options.data) {
      if (_.isUndefined(data.count[this.options.data[i].state])) {
        data.count[this.options.data[i].state] = 1;
      } else {
        data.count[this.options.data[i].state]++
      }
    }
    var template = _.template(ActTemplate)(data);
    this.$el.html(template);
    this.$el.i18n();

    return this;
  },

  link: function (e) {
    if (e.preventDefault) e.preventDefault();
    Backbone.history.navigate(this.options.target + 's/' + $(e.currentTarget).data('id'), { trigger: true });
  },

  cleanup: function () {
    removeView(this);
  },

});

module.exports = ProfileActivityView;

},{"../../../../config/ui.json":116,"../../../../mixins/utilities":128,"../templates/profile_activity_template.html":61,"async":131,"backbone":133,"underscore":159}],67:[function(require,module,exports){

var async = require('async');
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var LoginPasswordView = require('../../../login/views/login_password_view');
var ProfileResetTemplate = require('../templates/profile_reset_template.html');


var ProfileResetView = Backbone.View.extend({

  events: {
    'keyup #rpassword'               : 'checkPassword',
    'blur #rpassword'                : 'checkPassword',
    'submit #form-password-reset'    : 'submitReset'
  },

  initialize: function (options) {
    this.options = options;
    this.data = options.data;
  },

  render: function () {
    var data = {
      user: window.cache.currentUser || {}
    };
    var template = _.template(ProfileResetTemplate)(data);
    this.$el.html(template);
    this.loginPasswordView = new LoginPasswordView({
      el: this.$(".password-view")
    }).render();
    this.checkValidCode(this.options.action);
    return this;
  },

  checkPassword: function (e) {
    var rules = validatePassword(this.token.email, this.$("#rpassword").val());
    var success = true;
    _.each(rules, function (value, key) {
      if (value === true) {
        this.$(".password-rules .success.rule-" + key).show();
        this.$(".password-rules .error.rule-" + key).hide();
      } else {
        this.$(".password-rules .success.rule-" + key).hide();
        this.$(".password-rules .error.rule-" + key).show();
      }
      success = success && value;
    });
    return success;
  },

  checkValidCode: function (code) {
    var self = this;
    // check if the code is valid and update the DOM accordingly
    $.ajax({
      url: '/api/auth/checkToken/' + code,
      success: function (data) {
        self.$("#profile-reset-check").hide();
        // true means the token is a valid reset token
        if (data === false) {
          self.$("#profile-reset-check-error").show();
        }
        else {
          self.token = data;
          self.$("#profile-reset-dialog").show();
        }
      },
      error: function (data) {
        self.$("#profile-reset-check").hide();
        self.$("#profile-reset-check-error").show();
      }
    });
  },

  submitReset: function (e) {
    var self = this;
    if (e.preventDefault) e.preventDefault();

    var passwordSuccess = this.checkPassword();
    var parent = $(this.$("#rpassword").parents('.form-group')[0]);
    if (passwordSuccess !== true) {
      parent.addClass('has-error');
      $(parent.find('.error-password')[0]).show();
      return;
    } else {
      $(parent.find('.error-password')[0]).hide();
    }

    // Create a data object with the required fields
    var data = {
      token: this.options.action,
      password: this.$("#rpassword").val(),
      json: true
    };
    self.$("#profile-reset-submit").show();
    self.$("#profile-reset-submit-error").hide();
    $.ajax({
      url: '/api/auth/reset/',
      type: 'POST',
      data: data,
      success: function (data) {
        self.$("#profile-reset-submit").hide();
        // true means the token is a valid reset token
        if (data === false) {
          self.$("#profile-reset-submit-error").show();
        }
        else {
          // navigate to the projects main page
          Backbone.history.navigate('/', { trigger: true });
          // show log in screen with notice to log in.
          window.cache.userEvents.trigger("user:request:login", {
            message: "Your password has been reset.  Please log in to continue."
          });
        }
      },
      error: function (data) {
        self.$("#profile-reset-submit").hide();
        self.$("#profile-reset-submit-error").show();
      }
    });

  },

  cleanup: function () {
    removeView(this);
  },

});

module.exports = ProfileResetView;


},{"../../../../mixins/utilities":128,"../../../login/views/login_password_view":54,"../templates/profile_reset_template.html":63,"async":131,"backbone":133,"underscore":159}],68:[function(require,module,exports){

var async = require('async');
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var ProfileSettingsTemplate = require('../templates/profile_settings_template.html');


var ProfileSettingsView = Backbone.View.extend({

  events: {
  },

  initialize: function (options) {
    this.options = options;
    this.data = options.data;
  },

  render: function () {
    var data = {
      user: window.cache.currentUser || {}
    }
    var template = _.template(ProfileSettingsTemplate)(data);
    this.$el.html(template);
    return this;
  },

  cleanup: function () {
    removeView(this);
  },

});

module.exports = ProfileSettingsView;


},{"../../../../mixins/utilities":128,"../templates/profile_settings_template.html":64,"async":131,"backbone":133,"underscore":159}],69:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var UIConfig = require('../../../../config/ui.json');
var async = require('async');
var jqIframe = require('blueimp-file-upload/js/jquery.iframe-transport');
var jqFU = require('blueimp-file-upload/js/jquery.fileupload.js');
var MarkdownEditor = require('../../../../components/markdown_editor');
var marked = require('marked');
var TagShowView = require('../../../tag/show/views/tag_show_view');
var ProfileTemplate = require('../templates/profile_show_template.html');
var EmailTemplate = require('../templates/profile_email_template.html');
var Login = require('../../../../config/login.json');
var ModalComponent = require('../../../../components/modal');
var PAView = require('./profile_activity_view');
var EmailFormView = require('../../email/views/profile_email_view');
var TagFactory = require('../../../../components/tag_factory');


var ProfileShowView = Backbone.View.extend({

  events: {
    "submit #profile-form"       : "profileSubmit",
    "click #profile-save"        : "profileSave",
    "click .link-backbone"       : linkBackbone,
    "click #profile-cancel"      : "profileCancel",
    "click #like-button"         : "like",
    "keyup #name, #title, #bio"  : "fieldModified",
    "click .removeAuth"          : "removeAuth"
  },

  initialize: function (options) {
    this.options = options;
    this.data = options.data;
    this.tagFactory = new TagFactory();
    this.data.newItemTags = [];
    this.edit = false;
    if (this.options.action == 'edit') {
      this.edit = true;
    }
    if (this.data.saved) {
      this.saved = true;
      this.data.saved = false;
    }
  },

  render: function () {
    var data = {
      login: Login,
      data: this.model.toJSON(),
      user: window.cache.currentUser || {},
      edit: this.edit,
      saved: this.saved,
      ui: UIConfig
    }

    data.email = (data.data.emails && data.data.emails.length) ? data.data.emails[0] : '';

    if (data.data.bio) {
      data.data.bioHtml = marked(data.data.bio);
    }
    var template = _.template(ProfileTemplate)(data);
    this.$el.html(template);
    this.$el.i18n();

    // initialize sub components
    this.initializeFileUpload();
    this.initializeForm();
    this.initializeSelect2();
    this.initializeLikes();
    this.initializeTags();
    this.initializePAView();
    this.initializeTextArea();
    this.updatePhoto();
    this.updateProfileEmail();
    return this;
  },

  initializeFileUpload: function () {
    var self = this;

    $('#fileupload').fileupload({
        url: "/api/file/create",
        dataType: 'text',
        acceptFileTypes: /(\.|\/)(gif|jpe?g|png)$/i,
        formData: { 'type': 'image_square' },
        add: function (e, data) {
          self.$('#file-upload-progress-container').show();
          data.submit();
        },
        progressall: function (e, data) {
          var progress = parseInt(data.loaded / data.total * 100, 10);
          self.$('#file-upload-progress').css(
            'width',
            progress + '%'
          );
        },
        done: function (e, data) {
          // for IE8/9 that use iframe
          if (data.dataType == 'iframe text') {
            var result = JSON.parse(data.result);
          }
          // for modern XHR browsers
          else {
            var result = JSON.parse($(data.result).text());
          }
          self.model.trigger("profile:updateWithPhotoId", result[0]);
        },
        fail: function (e, data) {
          // notify the user that the upload failed
          var message = data.errorThrown;
          self.$('#file-upload-progress-container').hide();
          if (data.jqXHR.status == 413) {
            message = "The uploaded file exceeds the maximum file size.";
          }
          self.$("#file-upload-alert").html(message)
          self.$("#file-upload-alert").show();
        }
    });

  },

  updateProfileEmail: function(){
    var self = this;
    $.ajax({
      url: encodeURI('/api/email/makeURL?email=contactUserAboutProfile&subject=Check Out "'+ self.model.attributes.name + '"' +
      '&profileTitle=' + (self.model.attributes.title || '') +
      '&profileLink=' + window.location.protocol + "//" + window.location.host + "" + window.location.pathname +
      '&profileName=' + (self.model.attributes.name || '') +
      '&profileLocation=' + (self.model.attributes.location ? self.model.attributes.location.tag.name : '') +
      '&profileAgency=' + (self.model.agency ? self.model.agency.name : '')),
      type: 'GET'
    }).done( function (data) {
      self.$('#email').attr('href', data);
    });
  },

  initializeTags: function() {
    if (this.tagView) { this.tagView.cleanup(); }
    this.tagView = new TagShowView({
      model: this.model,
      el: '.tag-wrapper',
      target: 'profile',
      targetId: 'userId',
      edit: this.edit,
      url: '/api/tag/findAllByUserId/'
    });
    this.tagView.render();
  },

  initializePAView: function () {
    if (this.projectView) { this.projectView.cleanup(); }
    if (this.taskView) { this.taskView.cleanup(); }
    if (this.volView) { this.volView.cleanup(); }
    $.ajax('/api/user/activities/' + this.model.attributes.id).done(function (data) {
      this.projectView = new PAView({
        model: this.model,
        el: '.project-activity-wrapper',
        target: 'project',
        handle: 'project',
        data: data.projects
      });
      this.projectView.render();
      this.taskView = new PAView({
        model: this.model,
        el: '.task-createdactivity-wrapper',
        target: 'task',
        handle: 'task',
        data: data.tasks
      });
      this.taskView.render();
      this.volView = new PAView({
        model: this.model,
        el: '.task-activity-wrapper',
        target: 'task',
        handle: 'volTask',
        data: data.volTasks
      });
      this.volView.render();

    });
  },

  updatePhoto: function () {
    var self = this;
    this.model.on("profile:updatedPhoto", function (data) {
      var url = '/api/user/photo/' + data.attributes.id;
      // force the new image to be loaded
      $.get(url, function (data) {
        $("#project-header").css('background-image', "url('" + url + "')");
        $('#file-upload-progress-container').hide();
        // notify listeners of the new user image, but only for the current user
        if (self.model.toJSON().id == window.cache.currentUser.id) {
          window.cache.userEvents.trigger("user:profile:photo:save", url);
        }
      });
    });
  },

  initializeForm: function() {
    var self = this;

    $("#topics").on('change', function (e) {
      self.model.trigger("profile:input:changed", e);
    });

    $("#skills").on('change', function (e) {
      self.model.trigger("profile:input:changed", e);
    });

    this.listenTo(self.model, "profile:save:success", function (data) {
      // Bootstrap .button() has execution order issue since it
      // uses setTimeout to change the text of buttons.
      // make sure attr() runs last
      $("#submit").button('success');
      // notify listeners if the current user has been updated
      if (self.model.toJSON().id == window.cache.currentUser.id) {
        window.cache.userEvents.trigger("user:profile:save", data.toJSON());
      }

      var tags = [
        $("#company").select2('data'),
        $("#location").select2('data')
      ];
      self.model.trigger("profile:tags:save", tags);
    });

    self.on('newTagSaveDone',function (){

      tags         = [];
      var tempTags = [];

      //get newly created tags from big three types
      _.each(self.data.newItemTags, function(newItemTag){
        tags.push(newItemTag);
      });

      tempTags.push.apply(tempTags,self.$("#tag_topic").select2('data'));
      tempTags.push.apply(tempTags,self.$("#tag_skill").select2('data'));
      tempTags.push.apply(tempTags,self.$("#tag_location").select2('data'));
      tempTags.push.apply(tempTags,self.$("#tag_agency").select2('data'));

      //see if there are any previously created big three tags and add them to the tag array
      _.each(tempTags,function(tempTag){
          if ( tempTag.id !== tempTag.name ){
          tags.push(tempTag);
        }
      });

      var tagMap = {};

        // if a different profile is being edited, add its userId
        if (self.model.toJSON().id !== window.cache.currentUser.id) {
          tagMap.userId = self.model.toJSON().id;
        }

      async.forEach(tags, function(tag, callback){
        //diffAdd,self.model.attributes.id,"taskId",callback
        return self.tagFactory.addTag(tag,tagMap.userId,"userId",callback);
      }, function(err) {
        self.model.trigger("profile:tags:save:success", err);
      });
    });

    this.listenTo(self.model, "profile:tags:save", function (tags) {

      var newTags = [];

      newTags = newTags.concat(
        self.$("#tag_topic").select2('data'),
        self.$("#tag_skill").select2('data'),
        self.$("#tag_location").select2('data'),
        self.$("#location").select2('data'),
        self.$("#tag_agency").select2('data')
      );

      var removeTag = function(type, done) {
        if (self.model[type]) {
          // delete the existing tag
          $.ajax({
            url: '/api/tag/' + self.model[type].tagId,
            type: 'DELETE',
          }).done(function (data) {
            return done();
          });
          return;
        }
        return done();
      }

      var addTag = function (tag, done) {
        // the tag is invalid or hasn't been selected
        if (!tag || !tag.id) {
          return done();
        }
        // the tag already is stored in the db
        if (tag.tagId) {
          return done();
        }
        var tagMap = {
          tagId: tag.id
        };
        // if a different profile is being edited, add its userId
        if (self.model.toJSON().id !== window.cache.currentUser.id) {
          tagMap.userId = self.model.toJSON().id;
        }
        $.ajax({
          url: '/api/tag',
          type: 'POST',
          data: tagMap
        }).done(function (data) {
          done();
        });
      }

      async.forEach(
        newTags,
        function(newTag, callback) {
          return self.tagFactory.addTagEntities(newTag,self,callback);
        },
        function(err) {
          if (err) return next(err);

          tags = _.filter(tags, function(tag) {
            return (tag && tag.id !== tag.name);
          });
          async.each(['agency','location'], removeTag, function (err) {
            async.each(tags, addTag, function (err) {
              self.trigger("newTagSaveDone");
            });
          });
        }
      );

    });

    this.listenTo(self.model, "profile:tags:save:success", function (err) {
      setTimeout(function() { $("#profile-save, #submit").attr("disabled", "disabled") },0);
      $("#profile-save, #submit").removeClass("btn-primary");
      $("#profile-save, #submit").addClass("btn-success");
      self.data.saved = true;
      Backbone.history.navigate('profile/' + self.model.toJSON().id, { trigger: true });
    });

    this.listenTo(self.model, "profile:save:fail", function (data) {
      $("#submit").button('fail');
    });
    this.listenTo(self.model, "profile:removeAuth:success", function (data, id) {
      self.render();
    });
    this.listenTo(self.model, "profile:input:changed", function (e) {
      $("#profile-save, #submit").button('reset');
      $("#profile-save, #submit").removeAttr("disabled");
      $("#profile-save, #submit").removeClass("btn-success");
      $("#profile-save, #submit").addClass("btn-c2");
    });
  },

  initializeLikes: function() {
    $("#like-number").text(this.model.attributes.likeCount);
    if (parseInt(this.model.attributes.likeCount) === 1) {
      $("#like-text").text($("#like-text").data('singular'));
    } else {
      $("#like-text").text($("#like-text").data('plural'));
    }
    if (this.model.attributes.like) {
      $("#like-button-icon").removeClass('fa fa-star-o');
      $("#like-button-icon").addClass('fa fa-star');
    }
  },

  initializeSelect2: function () {
    var self = this;

    var formatResult = function (object, container, query) {
      return object.name;
    };

    var modelJson = this.model.toJSON();

    var locationSettings = {
      placeholder: 'Select a Location',
      formatResult: formatResult,
      formatSelection: formatResult,
      minimumInputLength: 1,
      data: [ location ],
      createSearchChoice: function (term, values) {
        var vals = values.map(function(value) {
          return value.value.toLowerCase();
        });

        //unmatched = true is the flag for saving these "new" tags to tagEntity when the opp is saved
        return (vals.indexOf(term.toLowerCase()) >=0) ? false : {
          tagType: 'location',
          id: term,
          value: term,
          temp: true,
          name: "<b>"+term+"</b> <i>search for this location</i>"
        };
      },
      ajax: {
        url: '/api/ac/tag',
        dataType: 'json',
        data: function (term) {
          return {
            type: 'location',
            q: term
          };
        },
        results: function (data) {
          return { results: data };
        }
      }
    };

    $("#company").select2({
      placeholder: 'Select an Agency',
      formatResult: formatResult,
      formatSelection: formatResult,
      minimumInputLength: 2,
      ajax: {
        url: '/api/ac/tag',
        dataType: 'json',
        data: function (term) {
          return {
            type: 'agency',
            q: term
          };
        },
        results: function (data) {
          return { results: data };
        }
      }
    });
    if (modelJson.agency) {
      $("#company").select2('data', modelJson.agency.tag);
    }

    $("#topics").on('change', function (e) {
      self.model.trigger("profile:input:changed", e);
    });

    $("#skills").on('change', function (e) {
      self.model.trigger("profile:input:changed", e);
    });

    $("#company").on('change', function (e) {
      self.model.trigger("profile:input:changed", e);
    });
    $('#location').select2(locationSettings).on('select2-selecting', function(e) {
      var $el = self.$(e.currentTarget),
          el = this;
      if (e.choice.temp) {
        this.temp = true;
        $('#location').select2('data', e.choice.name);
        $.get('/api/location/suggest?q=' + e.choice.value, function(d) {
          d = _(d).map(function(item) {
            return {
              id: item.name,
              text: item.name,
              name: item.name,
              unmatched: true,
              tagType: 'location',
              data: _(item).omit('name')
            };
          });
          el.reload = true;
          el.open = true;
          $('#location').select2({ data: d }).select2('open');
        });
      } else {
        delete this.temp;
      }
    }).on('select2-open', function(e) {
      if (!this.reload && this.open) {
        delete this.open;
        delete this.temp;
        var cache = $("#location").select2('data');
        setTimeout(function() {
          $("#location").select2(locationSettings)
            .select2('data', cache)
            .select2('open');
        }, 0);
      } else if (this.reload && this.open) {
        delete this.reload;
      }
    });
    if (modelJson.location) {
      $("#location").select2('data', modelJson.location.tag);
    }
    $("#location").on('change', function (e) {
      self.model.trigger("profile:input:changed", e);
    });
  },

  initializeTextArea: function () {
    if (this.md) { this.md.cleanup(); }
    this.md = new MarkdownEditor({
      data: this.model.toJSON().bio,
      el: ".markdown-edit",
      id: 'bio',
      placeholder: 'A short biography.',
      title: 'Biography',
      rows: 6
    }).render();
  },

  fieldModified: function (e) {
    this.model.trigger("profile:input:changed", e);
  },

  profileCancel: function (e) {
    e.preventDefault();
    Backbone.history.navigate('profile/' + this.model.toJSON().id, { trigger: true });
  },

  profileSave: function (e) {
    e.preventDefault();
    $("#profile-form").submit();
  },

  profileSubmit: function (e) {
    e.preventDefault();
    $("#profile-save, #submit").button('loading');
    setTimeout(function() { $("#profile-save, #submit").attr("disabled", "disabled") }, 0);
    var data = {
          name: $("#name").val(),
          title: $("#title").val(),
          bio: $("#bio").val()
        },
        email = this.model.get('emails')[0],
        self = this;

    if ($("#profile-email").val() !== email.email) {
      $.ajax({
        url: '/api/useremail/' + email.id,
        dataType: 'json',
        method: 'put',
        data: { email: $("#profile-email").val() },
        success: function() { self.model.trigger("profile:save", data); },
        error: function() {
          var msg = 'Failed to update your email address. Please verify it \
                     is a valid email address and try again.';
          $("#email-update-alert").html(msg);
          $("#email-update-alert").show();
        }
      });
    } else {
      this.model.trigger("profile:save", data);
    }
  },

  removeAuth: function (e) {
    if (e.preventDefault) e.preventDefault();
    var node = $(e.target);
    // walk up the tree until we get to the marked node
    while (!(node.hasClass("removeAuth"))) {
      node = node.parent();
    }
    this.model.trigger("profile:removeAuth", node.attr("id"));
  },

  like: function (e) {
    e.preventDefault();
    var self = this;
    var child = $(e.currentTarget).children("#like-button-icon");
    var likenumber = $("#like-number");
    // Not yet liked, initiate like
    if (child.hasClass('fa-star-o')) {
      child.removeClass('fa-star-o');
      child.addClass('fa fa-star');
      likenumber.text(parseInt(likenumber.text()) + 1);
      if (parseInt(likenumber.text()) === 1) {
        $("#like-text").text($("#like-text").data('singular'));
      } else {
        $("#like-text").text($("#like-text").data('plural'));
      }
      $.ajax({
        url: '/api/like/likeu/' + self.model.attributes.id
      }).done( function (data) {
        // liked!
        // response should be the like object
        // console.log(data.id);
      });
    }
    // Liked, initiate unlike
    else {
      child.removeClass('fa-star');
      child.addClass('fa-star-o');
      likenumber.text(parseInt(likenumber.text()) - 1);
      if (parseInt(likenumber.text()) === 1) {
        $("#like-text").text($("#like-text").data('singular'));
      } else {
        $("#like-text").text($("#like-text").data('plural'));
      }
      $.ajax({
        url: '/api/like/unlikeu/' + self.model.attributes.id
      }).done( function (data) {
        // un-liked!
        // response should be null (empty)
      });
    }
  },
  cleanup: function () {
    if (this.md) { this.md.cleanup(); }
    if (this.tagView) { this.tagView.cleanup(); }
    if (this.projectView) { this.projectView.cleanup(); }
    if (this.taskView) { this.taskView.cleanup(); }
    if (this.volView) { this.volView.cleanup(); }
    removeView(this);
  },

});

module.exports = ProfileShowView;

},{"../../../../components/markdown_editor":104,"../../../../components/modal":106,"../../../../components/tag_factory":112,"../../../../config/login.json":114,"../../../../config/ui.json":116,"../../../../mixins/utilities":128,"../../../tag/show/views/tag_show_view":84,"../../email/views/profile_email_view":59,"../templates/profile_email_template.html":62,"../templates/profile_show_template.html":65,"./profile_activity_view":66,"async":131,"backbone":133,"blueimp-file-upload/js/jquery.fileupload.js":134,"blueimp-file-upload/js/jquery.iframe-transport":135,"marked":155,"underscore":159}],70:[function(require,module,exports){
module.exports = "<form action=\"\" id=\"project-form\">\n  <div class=\"modal-body\">\n    <fieldset>\n      <div class=\"form-group\">\n        <label for=\"project-form-title\"><span data-i18n=\"Project\">Project</span> Title</label>\n        <input type=\"text\" class=\"project-title-form form-control\" id=\"project-form-title\" name=\"project-form-title\" placeholder=\"Title\" data-validate=\"empty,count100\">\n        <span class=\"help-block error-empty\" style=\"display:none;\">You must enter a title.</span>\n        <span class=\"help-block error-count100\" style=\"display:none;\">The title must be less than 100 characters.</span>\n      </div>\n      <div class=\"form-group\">\n        <label for=\"project-form-description\"><span data-i18n=\"Project\">Project</span> Description</label>\n        <div class=\"markdown-edit\"></div>\n        <span class=\"help-block error-empty\" style=\"display:none;\">You must enter a description.</span>\n      </div>\n    </fieldset>\n  </div>\n  <div class=\"modal-footer\">\n    <button type=\"button\" class=\"btn btn-c0\" data-dismiss=\"modal\">Cancel</button>\n    <input type=\"submit\" class=\"btn btn-c2 btn-add-project\" id=\"submit\" value=\"Add Project\"/>\n  </div>\n</form>\n";

},{}],71:[function(require,module,exports){
var Bootstrap = require('bootstrap');
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var MarkdownEditor = require('../../../../components/markdown_editor');
var ProjectsCollection = require('../../../../entities/projects/projects_collection');
var ProjectFormTemplate = require('../templates/project_new_form_template.html');


var ProjectFormView = Backbone.View.extend({

  events: {
    "blur #project-form-title"      : "v",
    "blur #project-form-description": "v",
    "submit #project-form"          : "post"
  },

  render: function () {
    var template = _.template(ProjectFormTemplate);
    this.$el.html(template);

    this.$el.i18n();
    this.initializeTextArea();
    this.$(".btn-add-project").val('Add ' + i18n.t('Project'));
    return this;
  },

  v: function (e) {
    return validate(e);
  },

  initializeTextArea: function () {
    if (this.md) { this.md.cleanup(); }
    this.md = new MarkdownEditor({
      data: '',
      el: ".markdown-edit",
      id: 'project-form-description',
      placeholder: 'A description of your ' + i18n.t('project') + ' that explains the focus, objectives, and deliverables.',
      title: i18n.t('Project') + ' Description',
      rows: 6,
      validate: ['empty']
    }).render();
  },

  post: function (e) {
    if (e.preventDefault) e.preventDefault();

    // validate input fields
    var validateIds = ['#project-form-title', '#project-form-description'];
    var abort = false;
    for (i in validateIds) {
      var iAbort = validate({ currentTarget: validateIds[i] });
      abort = abort || iAbort;
    }
    if (abort === true) {
      return;
    }

    // process project form
    var data;
    data = {
      title       : this.$(".project-title-form").val(),
      description : this.$("#project-form-description").val()
    };

    this.collection.trigger("project:save", data);
  },

  cleanup: function () {
    if (this.md) { this.md.cleanup(); }
    removeView(this);
  }

});

module.exports = ProjectFormView;

},{"../../../../components/markdown_editor":104,"../../../../entities/projects/projects_collection":123,"../../../../mixins/utilities":128,"../templates/project_new_form_template.html":70,"backbone":133,"bootstrap":138,"underscore":159}],72:[function(require,module,exports){
var _ = require('underscore');
var async = require('async');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var Popovers = require('../../../../mixins/popovers');
var BaseController = require('../../../../base/base_controller');
var ProjectItemView = require('../views/project_item_view');
var ProjectItemCoreMetaView = require('../views/project_item_coremeta_view');
var ProjectownerShowView = require('../../../projectowner/show/views/projectowner_show_view');
var AttachmentView = require('../../../attachment/views/attachment_show_view');
var TaskListController = require('../../../tasks/list/controllers/task_list_controller');
var EventListController = require('../../../events/list/controllers/event_list_controller');
var CommentListController = require('../../../comments/list/controllers/comment_list_controller');
var CommentFormView = require('../../../comments/new/views/comment_form_view');
var ModalComponent = require('../../../../components/modal');
var ModalAlert = require('../../../../components/modal_alert');
var TaskModel = require('../../../../entities/tasks/task_model');
var ProjectOpenTasksWarningTemplate = require('../templates/project_open_tasks_warning_template.html');


var popovers = new Popovers();

Project = {};

Project.ShowController = BaseController.extend({

  el: "#container",

  // Set the model to null, before it is fetched from the server.
  // This allows us to clear out the previous data from the list_view,
  // and get ready for the new data for the project show view.
  model: null,

  events: {
    "click #like-button"              : "like",
    "keyup .comment-content"          : "search",
    "click #tag-save"                 : "tagSave",
    "click #tag-create"               : "tagCreate",
    "click .tag-delete"               : "tagDelete",
    "click #project-close"            : "stateClose",
    "click #project-reopen"           : "stateReopen",
    'click #editProject'              : 'toggleEditMode',
    "mouseenter .project-people-div"  : popovers.popoverPeopleOn,
    "click .project-people-div"       : popovers.popoverClick
  },

  // The initialize method is mainly used for event bindings (for effeciency)
  initialize: function (options) {
    var self = this;

    this.router = options.router;
    this.id = options.id;
    this.data = options.data;
    this.action = options.action;

    this.model.trigger("project:model:fetch", this.model.id);
    this.listenTo(this.model, "project:model:fetch:success", function (projectModel) {
      self.model = projectModel;
      if (self.action == 'edit') {
        var model = this.model.toJSON();
        // check if the user owns the task
        var owner = model.isOwner;
        if (owner !== true) {
          // if none of these apply, are they an admin?
          if (window.cache.currentUser) {
            if (window.cache.currentUser.isAdmin === true) {
              owner = true;
            }
          }
        }
        // if not the owner, trigger the login dialog.
        if (owner !== true) {
          window.cache.userEvents.trigger("user:request:login", {
            message: "You are not the owner of this project. <a class='link-backbone' href='/projects/" + model.id + "'>View the project instead.</a>",
            disableClose: true
          });
          return;
        }
      }
      self.initializeItemView();
    });

    this.model.on("project:show:rendered", function () {
      self.initializeItemCoreMetaView();
      self.initializeOwners();
      self.initializeItemViewControllers();
      self.initializeHandlers();
      self.initializeLikes();
      self.initializeUI();
    });
  },

  initializeItemView: function () {
    if (this.projectShowItemView) this.projectShowItemView.cleanup();
    this.projectShowItemView  = new ProjectItemView({
                              model: this.model,
                              action: this.action,
                              data: this.data
                            }).render();
  },

  initializeItemCoreMetaView: function () {
    if (this.projectShowItemCoreMetaView) this.projectShowItemCoreMetaView.cleanup();
    this.projectShowItemCoreMetaView  = new ProjectItemCoreMetaView({
                              model: this.model,
                              action: this.action,
                              data: this.data
                             }).render();
  },


  initializeOwners : function(){
    if (this.projectownerShowView) this.projectownerShowView.cleanup();
    this.projectownerShowView = new ProjectownerShowView({
                              model: this.model,
                              action: this.action,
                              data: this.data
                             }).render();
  },

  initializeItemViewControllers: function () {
    if (this.action != 'edit') {
      // Tasks
      if (this.taskListController) this.taskListController.cleanup();
      this.taskListController = new TaskListController({
        projectId: this.model.id
      });

      // Events
      if (this.eventListController) this.eventListController.cleanup();
      this.eventListController = new EventListController({
        projectId: this.model.id
      });
      // Comments
      if (this.commentListController) this.commentListController.cleanup();
      this.commentListController = new CommentListController({
        target: 'project',
        id: this.model.id
      });
      // Attachments
      if (this.attachmentView) this.attachmentView.cleanup();
      this.attachmentView = new AttachmentView({
        target: 'project',
        id: this.model.attributes.id,
        action: this.action,
        data: this.data,
        owner: this.model.attributes.isOwner,
        el: '.attachment-wrapper'
      }).render();
    }
  },

  initializeLikes: function() {
    $("#like-number").text(this.model.attributes.likeCount);
    if (parseInt(this.model.attributes.likeCount) === 1) {
      $("#like-text").text($("#like-text").data('singular'));
    } else {
      $("#like-text").text($("#like-text").data('plural'));
    }
    if (this.model.attributes.like) {
      $("#like-button-icon").removeClass('fa-star-o');
      $("#like-button-icon").addClass('fa fa-star');
    }
  },

  initializeHandlers: function() {
    this.listenTo(this.model, "project:update:state:success", function (data) {
      if (data.attributes.state == 'closed') {
        $("#li-project-close").hide();
        $("#li-project-reopen").show();
        $("#alert-closed").show();
      } else {
        $("#li-project-close").show();
        $("#li-project-reopen").hide();
        $("#alert-closed").hide();
      }
    });
  },

  initializeUI: function() {
    popovers.popoverPeopleInit(".project-people-div");
  },

  toggleEditMode: function(e){
    if (e.preventDefault) e.preventDefault();
    var action = '';
    if (!(this.action && this.action == 'edit')) {
      action = '/edit';
    }
    Backbone.history.navigate('projects/' + this.id + action, { trigger: true });
  },

  stateClose: function (e) {
    if (e.preventDefault) e.preventDefault();
    var self = this;

    var projectTasks = self.model.hasOpenTasks(self.taskListController.collection);
    if (this.modalAlert) { this.modalAlert.cleanup(); }
    if (this.modalComponent) { this.modalComponent.cleanup(); }
    this.modalComponent = new ModalComponent({
      el: "#modal-close",
      id: "check-close",
      modalTitle: "Close "+i18n.t("Project")
    }).render();

    var count = 0;
    if ( projectTasks.hasOpenTasks ){
      var modalContent = _.template(ProjectOpenTasksWarningTemplate)({count: projectTasks.count});
      var submitLabel = "I Understand and Want to Close This "+i18n.t("Project");
    } else {
      var modalContent = '<p>Are you sure you want to close this '+i18n.t("project")+'?  Once the '+i18n.t("project")+' is closed, participants will no longer be able to contribute.</p>';
      var submitLabel = "Close "+i18n.t("Project");
    }

    this.modalAlert = new ModalAlert({
      el: "#check-close .modal-template",
      modalDiv: '#check-close',
      content: modalContent,
      cancel: 'Cancel',
      submit: submitLabel,
      callback: function (e) {
        // user clicked the submit button
        if ( projectTasks.hasOpenTasks ) { self.model.trigger("project:update:tasks:orphan",self.taskListController.collection); }
        self.model.trigger("project:update:state", 'closed');
        self.initializeItemView();
      }
    }).render();
  },

  stateReopen: function (e) {
    if (e.preventDefault) e.preventDefault();
    this.model.trigger("project:update:state", 'open');
  },

  like: function (e) {
    if (e.preventDefault) e.preventDefault();
    var self = this;
    var child = $(e.currentTarget).children("#like-button-icon");
    var likenumber = $("#like-number");
    // Not yet liked, initiate like
    if (child.hasClass('fa-star-o')) {
      child.removeClass('fa-star-o');
      child.addClass('fa fa-star');
      likenumber.text(parseInt(likenumber.text()) + 1);
      if (parseInt(likenumber.text()) === 1) {
        $("#like-text").text($("#like-text").data('singular'));
      } else {
        $("#like-text").text($("#like-text").data('plural'));
      }
      $.ajax({
        url: '/api/like/like/' + this.model.attributes.id
      }).done( function (data) {
        // liked!
        // response should be the like object
        // console.log(data.id);
      });
    }
    // Liked, initiate unlike
    else {
      child.removeClass('fa-star');
      child.addClass('fa-star-o');
      likenumber.text(parseInt(likenumber.text()) - 1);
      if (parseInt(likenumber.text()) === 1) {
        $("#like-text").text($("#like-text").data('singular'));
      } else {
        $("#like-text").text($("#like-text").data('plural'));
      }
      $.ajax({
        url: '/api/like/unlike/' + this.model.attributes.id
      }).done( function (data) {
        // un-liked!
        // response should be null (empty)
      });
    }
  },

  // ---------------------
  //= Utility Methods
  // ---------------------
  cleanup: function() {
    if (this.projectShowItemCoreMetaView) this.projectShowItemCoreMetaView.cleanup();
    if (this.taskListController) this.taskListController.cleanup();
    if (this.eventListController) this.eventListController.cleanup();
    if (this.commentListController) this.commentListController.cleanup();
    if (this.projectShowItemView) this.projectShowItemView.cleanup();
    if (this.projectownerShowView) this.projectownerShowView.cleanup();
    if (this.attachmentView) this.attachmentView.cleanup();
    removeView(this);
  }

});

module.exports = Project.ShowController;

},{"../../../../base/base_controller":101,"../../../../components/modal":106,"../../../../components/modal_alert":107,"../../../../entities/tasks/task_model":124,"../../../../mixins/popovers":126,"../../../../mixins/utilities":128,"../../../attachment/views/attachment_show_view":23,"../../../comments/list/controllers/comment_list_controller":33,"../../../comments/new/views/comment_form_view":40,"../../../events/list/controllers/event_list_controller":41,"../../../projectowner/show/views/projectowner_show_view":79,"../../../tasks/list/controllers/task_list_controller":88,"../templates/project_open_tasks_warning_template.html":75,"../views/project_item_coremeta_view":76,"../views/project_item_view":77,"async":131,"backbone":133,"underscore":159}],73:[function(require,module,exports){
module.exports = "<div id=\"project-coremeta-show\" class=\"coremeta-form-toggle\">\n\n    <h1><%= data.title %></h1>\n\n    <div class=\"project-description\">\n      <%= data.descriptionHtml %>\n    </div>\n\n\n</div> <!-- /main-section -->\n<div id=\"project-coremeta-form\" class=\"coremeta-form-toggle coremeta-admin\">\n  <div class=\"row\">\n    <div class=\"col-md-12\">\n      <form role=\"form\">\n\n        <div class=\"alert alert-success\" id=\"project-coremeta-success\" style=\"display: none;\">\n          Your <span data-i18n=\"project\">project</span> has been successfully updated!\n          <a class=\"close\" data-dismiss=\"alert\" href=\"#\" aria-hidden=\"true\">&times;</a>\n        </div>\n\n        <!-- RIGHT MAIN BAR -->\n        <div class=\"form-group\">\n          <h2 class=\"box-pad-t\"><span data-i18n=\"Project\">Project</span> Title</h2>\n          <input id=\"project-edit-form-title\" class=\"form-control input-lg\" value=\"<%= data.title %>\" type=\"text\" data-validate=\"empty,count100\" title=\"Title\"/>\n          <span class=\"help-block error-empty\" style=\"display:none;\">You must enter a <span data-i18n=\"project\">project</span> title.</span>\n          <span class=\"help-block error-count100\" style=\"display:none;\">Your title must be less than 100 characters.</span>\n        </div>\n        <div class=\"form-group\">\n          <h2 class=\"box-pad-t\"><span data-i18n=\"Project\">Project</span> Description</h2>\n          <div class=\"markdown-edit\">\n          </div>\n          <span class=\"help-block error-empty\" style=\"display:none;\">You must enter a <span data-i18n=\"project\">project</span> description.</span>\n        </div>\n      </form>\n    </div>\n  </div>\n  <div class=\"row\">\n    <div class=\"col-md-12 form-group\">\n\n      <div class=\"pull-right coremeta-admin\" id=\"project-coremeta-buttons\">\n          <button class=\"btn btn-c0\" id=\"coremeta-view\">Discard Changes</button>\n          <button class=\"btn btn-c2\" id=\"coremeta-save\">Save <span data-i18n=\"Project\">Project</span></button>\n      </div>\n\n    </div>\n  </div>\n</div>\n";

},{}],74:[function(require,module,exports){
module.exports = "<!-- ALERTS -->\n<div class=\"alert alert-danger\" id=\"alert-closed\" style=\"<% if (data.state != 'closed') { %>display: none;<% } %>\">This <span data-i18n=\"project\">project</span> is <strong>closed</strong>.  It is no longer active, and no more modifications may be made.</div>\n\n<div class=\"row\">\n  <div class=\"col-sm-4 col-md-4 col-lg-4 project-sidebar md-nopadding-right sm-nopadding\">\n    <!-- LEFT SIDEBAR -->\n\n    <div class=\"row\">\n      <div class=\"col-md-12 box project-header-wrapper\">\n        <% if (data.coverId) { %>\n        <div id=\"project-header\" style=\"background-image:url('/api/file/get/<%= data.coverId %>');\">\n        <% } else { %>\n        <div id=\"project-header\" style=\"background-image:url('/images/project_default.png');\">\n        <% } %>\n          <div class=\"btn btn-c2 fileinput-button\" <% if (!(data.isOwner || user.isAdmin) || !edit) { %>style=\"display:none;\"<% } %>>\n            <i class=\"fa fa-camera fa-lg\" title=\"Change Cover Photo\" id=\"fileupload-icon\"></i>\n            <input id=\"fileupload\" type=\"file\" name=\"files[]\" title=\"Change Cover Photo\">\n          </div>\n        </div>\n        <div id=\"file-upload-progress-container\" style=\"display: none;\" class=\"progress progress-striped active\">\n          <div id=\"file-upload-progress\" class=\"progress-bar\" style=\"width: 0\"></div>\n        </div>\n        <div class=\"file-upload-alert alert alert-warning\" style=\"display:none;\">\n        </div>\n      </div>\n    </div>\n\n  </div>\n\n  <div class=\"col-sm-8 col-md-8 col-lg-8 md-nopadding sm-nopadding\">\n\n    <!-- RIGHT MAIN BAR -->\n    <div class=\"row\">\n      <div class=\"col-sm-8 col-md-9 sm-nopadding\">\n        <div class=\"main-section\">\n          <div class=\"box box-main\" id=\"project-coremeta-wrapper\">\n          </div>\n        </div>\n      </div>\n      <div class=\"col-sm-4 col-md-3 padding-left-none sm-nopadding\">\n        <div class=\"box padding-none\">\n\n          <div class=\"navbar-side like-row border-bottom\">\n            <% if (user) { %>\n            <button id=\"like-button\" class=\"btn btn-link like-button\" title=\"Click to Like or Unlike\">\n            <% } else { %>\n            <span class=\"like-button\">\n            <% } %>\n              <i id=\"like-button-icon\" class=\"fa fa-star-o fa-lg gold\"></i>\n            <% if (user) { %>\n            </button>\n            <% } else { %>\n            </span>\n            <% } %>\n            <span class=\"like-number\" id=\"like-number\"><%- data.likeCount %></span>\n            <span class=\"like-plural\" id=\"like-text\" data-plural=\"likes\" data-singular=\"like\">likes</span>\n          </div>\n          <div class=\"navbar-side <% if (data.isOwner || user.isAdmin) { %>border-bottom<% } %>\">\n            <ul class=\"nav nav-pills nav-stacked\">\n              <li>\n                <a href=\"#\" id=\"email\"><i class=\"fa fa-envelope-o\"></i> <span class=\"box-icon-text\">Share</span></a>\n              </li>\n              <li>\n                <a href=\"webcal://<%- hostname %>/api/event/ical/<%- data.id %>\"><span class=\"fa fa-calendar\"></span> <span class=\"box-icon-text\">Calendar</span></a>\n              </li>\n            </ul>\n          </div>\n          <% if (data.isOwner || user.isAdmin) { %>\n          <div class=\"navbar-side\">\n            <div id=\"modal-close\"></div>\n            <ul class=\"nav nav-pills nav-stacked\">\n              <li>\n                <a href=\"#\" id=\"editProject\"><i class=\"fa fa-pencil\"></i> <span class=\"box-icon-text\">Edit <span data-i18n=\"Project\">Project</span></span></a>\n              </li>\n              <% if ( !edit ) { %>\n              <li id=\"li-project-close\" style=\"<% if (data.state == 'closed') { %>display: none;<% } %>\">\n                <a href=\"#\" id=\"project-close\"><i class=\"fa fa-times-circle\"></i> <span class=\"box-icon-text\">Close <span data-i18n=\"Project\">Project</span></span></a>\n              </li>\n              <li id=\"li-project-reopen\" style=\"<% if (data.state != 'closed') { %>display: none;<% } %>\">\n                <a href=\"#\" id=\"project-reopen\"><i class=\"fa fa-share\"></i> <span class=\"box-icon-text\">Reopen <span data-i18n=\"Project\">Project</span></span></a>\n              </li>\n              <% } %>\n              <!--\n              <li>\n                <a href=\"#\" id=\"project-delete\"><i class=\"fa fa-trash-o\"></i> <span class=\"box-icon-text\">Delete <span data-i18n=\"Project\">Project</span></span></a>\n              </li>\n              -->\n            </ul>\n          </div>\n          <% } %>\n        </div>\n      </div>\n    </div>\n\n  </div>\n</div>\n<div class=\"row\">\n\n  <div class=\"col-sm-5 col-md-4 md-nopadding-right sm-nopadding\">\n\n    <div class=\"row\">\n      <div class=\"col-md-12 box\">\n        <div class=\"box-main tag-wrapper\">\n        </div>\n      </div>\n    </div>\n\n    <% if (!(data.isOwner || user.isAdmin) || !edit) { %>\n    <div class=\"row\">\n      <div class=\"col-md-12 box\">\n        <div class=\"attachment-wrapper\">\n        </div>\n      </div>\n    </div>\n    <% } %>\n\n  </div>\n  <div class=\"col-sm-7 col-md-8 md-nopadding-right sm-nopadding\">\n\n    <div class=\"row\">\n      <div class=\"col-md-12 sm-nopadding md-nopadding\">\n        <div class=\"box\" id=\"projectowner-wrapper\">\n        </div>\n      </div>\n    </div>\n\n    <% if (!(data.isOwner || user.isAdmin) || !edit) { %>\n    <div class=\"row\">\n      <div class=\"col-md-12 sm-nopadding md-nopadding\">\n        <!-- BEGIN EVENTS -->\n        <div class=\"box\" id=\"event-list-wrapper\">\n        </div>\n        <!-- END EVENTS -->\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"col-md-12 sm-nopadding md-nopadding\">\n        <!-- BEGIN TASKS -->\n        <div class=\"wrapper-addTask\"></div>\n        <div class=\"box\" id=\"task-list-wrapper\" data-project-id=\"<%= data.id %>\">\n        </div>\n        <!-- END TASKS -->\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"col-md-12 sm-nopadding md-nopadding\">\n\n        <div class=\"box comment-list-wrapper\" style=\"clear: both;\">\n        </div>\n      </div>\n    </div>\n\n    <% } %> <!-- end of check for edit mode -->\n\n    <!-- add a space at the bottom of the page until we figure out what goes here -->\n    <div style=\"height: 50px;\">\n    </div>\n\n  </div>\n</div>\n";

},{}],75:[function(require,module,exports){
module.exports = "<div>\n  <p>This <span data-i18n=\"project\">project</span> has <strong><%- count %></strong> open, or in progress, opportunities. Closing this <span data-i18n=\"project\">project</span> will cause any such opportunities to be orphaned (no longer associated with any <span data-i18n=\"project\">project</span>).</p>\n\n  <p>Are you sure you wish to proceed?</p>\n\n</div>\n";

},{}],76:[function(require,module,exports){
var _ = require('underscore');
var async = require('async');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var marked = require('marked');
var MarkdownEditor = require('../../../../components/markdown_editor');
var Popovers = require('../../../../mixins/popovers');
var ModalComponent = require('../../../../components/modal');
var ProjectItemCoreMetaTemplate = require('../templates/project_item_coremeta_template.html');


//if(_.isUndefined(popovers)){var popovers = new Popovers();}

var ProjectItemCoreMetaView = Backbone.View.extend({

  el: "#project-coremeta-wrapper",
  model : null,

  // Set the model to null, before it is fetched from the server.
  // This allows us to clear out the previous data from the list_view,
  // and get ready for the new data for the project show view.
  // model: null,

  events: {
    "blur #project-edit-form-title"            : "v",
    "blur #project-edit-form-description"      : "v",
    "click #coremeta-save"                     : "saveCoreMeta",
    "click #coremeta-view"                     : "viewProject"
  },

  // The initialize method is mainly used for event bindings (for effeciency)
  initialize: function (options) {
    var self = this;
    this.options = options;
    this.data = options.data;
    this.action = options.action;
    this.user = window.cache.currentUser || {};
    this.edit = false;
    if (this.options.action) {
      if (this.options.action == 'edit') {
        this.edit = true;
      }
    }

    this.model.on("project:coremeta:show:rendered", function () {
      self.initializeTextArea();
      self.initializeToggledElements();
    });

    this.model.on("project:save:success", function (data) {
      self.render();
      $('#project-coremeta-success').show();
      self.viewProject({});
    });

    this.model.on("project:tags:save:success", function (data) {
      self.render();
      $('#project-coremeta-success').show();
      self.viewProject({});
    });

  },

  render: function () {
    var data = {
      data: this.model.toJSON()
    };
    // convert description to html using markdown syntax
    data.data.descriptionHtml = marked(data.data.description || '');
    var compiledTemplate = _.template(ProjectItemCoreMetaTemplate)(data);
    this.$el.html(compiledTemplate);
    this.$el.i18n();
    this.model.trigger("project:coremeta:show:rendered", data);

    return this;
  },

  initializeTextArea: function () {
    if (this.md) { this.md.cleanup(); }
    this.md = new MarkdownEditor({
      data: this.model.toJSON().description,
      el: ".markdown-edit",
      id: 'project-edit-form-description',
      title: 'Project Description',
      rows: 6,
      validate: ['empty']
    }).render();
  },

  initializeToggledElements: function() {
    var self = this;
    if ((this.model.attributes.isOwner || this.user.isAdmin) && this.edit){
      self.$('#project-coremeta-form').show();
      self.$('#project-coremeta-show').hide();
    }
    else{
      self.$('.coremeta-admin').hide();
    }
  },

  v: function(e) {
    return validate(e);
  },

  saveCoreMeta: function (e){
    if (e.preventDefault) e.preventDefault();
    if (!(this.model.attributes.isOwner || this.user.isAdmin) && this.edit) return false;

    // validate the form fields
    var validateIds = ['#project-edit-form-title', '#project-edit-form-description'];
    var abort = false;
    for (var i in validateIds) {
      var iAbort = validate({ currentTarget: validateIds[i] });
      abort = abort || iAbort;
    }
    if (abort) {
      return;
    }

    // process and update the data model for the project
    var self = this;
    var pId = self.model.attributes.id;
    var title = self.$('#project-edit-form-title').val();
    var description = self.$('#project-edit-form-description').val();
    var params = { title :title, description: description };

    self.model.trigger("project:tag:update:start");
    self.model.trigger("project:model:update", params);
  },

  viewProject: function (e) {
    if (e.preventDefault) e.preventDefault();
    Backbone.history.navigate('projects/' + this.model.attributes.id, { trigger: true });
  },

  // ---------------------
  //= Utility Methods
  // ---------------------
  cleanup: function() {
    if (this.md) { this.md.cleanup(); }
    removeView(this);
  }

});

module.exports = ProjectItemCoreMetaView;

},{"../../../../components/markdown_editor":104,"../../../../components/modal":106,"../../../../mixins/popovers":126,"../../../../mixins/utilities":128,"../templates/project_item_coremeta_template.html":73,"async":131,"backbone":133,"marked":155,"underscore":159}],77:[function(require,module,exports){
var jqIframe = require('blueimp-file-upload/js/jquery.iframe-transport');
var jqFU = require('blueimp-file-upload/js/jquery.fileupload.js');
var select2 = require('select2');
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var async = require('async');
var ProjectShowTemplate = require('../templates/project_item_view_template.html');
var TagShowView = require('../../../tag/show/views/tag_show_view');
var TagFactory = require('../../../../components/tag_factory');


var ProjectShowView = Backbone.View.extend({

  el: "#container",

  events: {
  },

  initialize: function (options) {
    this.options = options;
    this.data = options.data;
    this.action = options.action;
    this.edit = false;
    if (this.options.action) {
      if (this.options.action == 'edit') {
        this.edit = true;
      }
    }
    this.tagFactory = new TagFactory();
    this.data.newItemTags = [];
  },

  render: function () {
    var compiledTemplate;
    var data = {
      hostname: window.location.hostname,
      data: this.model.toJSON(),
      user: window.cache.currentUser || {},
      edit: this.edit
    };

    compiledTemplate = _.template(ProjectShowTemplate)(data);
    this.$el.html(compiledTemplate);
    this.$el.i18n();

    this.initializeToggle();
    this.initializeTagFactory();
    this.initializeFileUpload();
    this.initializeTags();
    this.updatePhoto();
    this.updateProjectEmail();
    this.model.trigger("project:show:rendered");

    return this;
  },

  updatePhoto: function () {
    this.listenTo(this.model, "project:updated:photo:success", function (data) {
      var model = data.toJSON(), url;
      if (model.coverId) {
        url = '/api/file/get/' + model.coverId;
        $("#project-header").css('background-image', "url(" + url + ")");
      }
      $('#file-upload-progress-container').hide();
    });
  },

  updateProjectEmail: function() {
    var self = this;
    $.ajax({
      url: encodeURI('/api/email/makeURL?email=contactUserAboutProject&subject=Check Out "'+ self.model.attributes.title + '"' +
      '&projectTitle=' + self.model.attributes.title +
      '&projectLink=' + window.location.protocol + "//" + window.location.host + "" + window.location.pathname +
      '&projectDescription=' + (self.model.attributes.description || '')),
      type: 'GET'
    }).done( function (data) {
      self.$('#email').attr('href', data);
    });

  },

  initializeTagFactory: function() {
    var self = this;

    this.listenTo(self.model, "project:tag:update:start", function (tags) {

      var newTags = [];
      newTags = newTags.concat(self.$("#tag_topic").select2('data'),self.$("#tag_skill").select2('data'),self.$("#tag_location").select2('data'),self.$("#tag_agency").select2('data'));

      async.forEach(
        newTags,
        function(newTag, callback) {
          return self.tagFactory.addTagEntities(newTag,self,callback);
        },
        function(err) {
          if (err) return next(err);
          self.trigger("newTagSaveDone");
        }
      );
    });

    self.on('newTagSaveDone',function (){

      tags         = [];
      var tempTags = [];

      //get newly created tags from big three types
      _.each(self.data.newItemTags, function(newItemTag){
        tags.push(newItemTag);
      });

      tempTags.push.apply(tempTags,self.$("#tag_topic").select2('data'));
      tempTags.push.apply(tempTags,self.$("#tag_skill").select2('data'));
      tempTags.push.apply(tempTags,self.$("#tag_location").select2('data'));
      tempTags.push.apply(tempTags,self.$("#tag_agency").select2('data'));

      //see if there are any previously created big three tags and add them to the tag array
      _.each(tempTags,function(tempTag){
          if ( tempTag.id !== tempTag.name ){
          tags.push(tempTag);
        }
      });

      var tagMap = {};
      var projectId = self.model.attributes.id;

      async.forEach(
        tags,
        function(tag, callback){
          return self.tagFactory.addTag(tag,projectId,"projectId",callback);
        },
        function(err){
          self.model.trigger("project:tags:save:success", err);
        }
      );
    });
  },

  initializeToggle: function () {
    if(this.edit){
      this.$('#editProject').find('.box-icon-text').html('View ' + i18n.t('Project'));
    }
    else{
      this.$('#editProject').find('.box-icon-text').html('Edit ' + i18n.t('Project'));
    }
  },

  initializeTags: function () {
    this.tagView = new TagShowView({
      model: this.model,
      el: '.tag-wrapper',
      target: 'project',
      targetId: 'projectId',
      edit: this.edit,
      url: '/api/tag/findAllByProjectId/'
    });
    this.tagView.render();
  },

  initializeFileUpload: function () {
    var self = this;

    $('#fileupload').fileupload({
        url: "/api/file/create",
        dataType: 'text',
        acceptFileTypes: /(\.|\/)(gif|jpe?g|png)$/i,
        formData: { 'type': 'image' },
        add: function (e, data) {
          self.$('#file-upload-progress-container').show();
          data.submit();
        },
        progressall: function (e, data) {
          var progress = parseInt(data.loaded / data.total * 100, 10);
          self.$('#file-upload-progress').css(
            'width',
            progress + '%'
          );
        },
        done: function (e, data) {
          // for IE8/9 that use iframe
          if (data.dataType == 'iframe text') {
            var result = JSON.parse(data.result);
          }
          // for modern XHR browsers
          else {
            var result = JSON.parse($(data.result).text());
          }
          self.model.trigger("project:update:photoId", result[0]);
        },
        fail: function (e, data) {
          // notify the user that the upload failed
          var message = data.errorThrown;
          self.$('#file-upload-progress-container').hide();
          if (data.jqXHR.status == 413) {
            message = "The uploaded file exceeds the maximum file size.";
          }
          self.$(".file-upload-alert").html(message)
          self.$(".file-upload-alert").show();
        }
    });

  },

  cleanup: function () {
    if (this.tagView) { this.tagView.cleanup(); }
    removeView(this);
  },
});

module.exports = ProjectShowView;

},{"../../../../components/tag_factory":112,"../../../../mixins/utilities":128,"../../../tag/show/views/tag_show_view":84,"../templates/project_item_view_template.html":74,"async":131,"backbone":133,"blueimp-file-upload/js/jquery.fileupload.js":134,"blueimp-file-upload/js/jquery.iframe-transport":135,"select2":157,"underscore":159}],78:[function(require,module,exports){
module.exports = "<div class=\"box-pad-lr border-bottom\">\n  <h2><span data-i18n=\"ProjectOwnerPlural\">Project Owners</span>\n    <button id=\"owner-edit\" name=\"owner-edit\" class=\"btn btn-c0 btn-sm file-add owner-form-toggle\">Add Owners</button>\n    <button id=\"owner-cancel\" name=\"owner-cancel\" class=\"btn btn-c0 btn-sm file-add owner-form-toggle\">Cancel</button>\n    <button id=\"owner-save\" name=\"owner-save\" class=\"btn btn-c2 btn-sm file-add owner-form-toggle\">Submit</button>\n  </h2>\n</div>\n\n<div id=\"project-owners-form\" class=\"box-pad-lr box-pad-t owner-form-toggle\">\n  <form class=\"\" role=\"form\">\n    <div class=\"form-group\">\n      <input style=\"width: 100%\" id=\"owners\" name=\"owners\" type=\"hidden\" value=\"Add Owner\"/>\n    </div>\n  </form>\n</div>\n\n<div id=\"project-owners-show\" class=\"box-pad-lr box-pad-t owner-form-toggle\">\n  <% if (data.owners) { %>\n    <% for (var i = 0; i < data.owners.length; i++) { %>\n    <div class=\"project-people-div\" data-userid=\"<%= data.owners[i].userId %>\">\n      <img src=\"/api/user/photo/<%= data.owners[i].userId %>\" class=\"project-people\" alt=\"<%= data.owners[i].name %>\"/>\n      <% if ((data.isOwner || user.isAdmin) && (data.owners[i].userId != cache.currentUser.id) && data.edit) { %>\n      <a href=\"#\" class=\"delete-projectowner project-owner-delete fa fa-times\"  id=\"delete-projectowner-<%= data.owners[i].id %>\" data-uid=\"<%= data.owners[i].userId %>\" data-poid=\"<%= data.owners[i].id %>\">\n      </a>\n      <% } %>\n    </div>\n    <% } %>\n  <% } %>\n</div>\n";

},{}],79:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var async = require('async');
var Popovers = require('../../../../mixins/popovers');
var ModalComponent = require('../../../../components/modal');
var ProjectownerShowTemplate = require('../templates/projectowner_show_template.html');


var ProjectownerShowView = Backbone.View.extend({

  el: "#projectowner-wrapper",
  model : null,

  // Set the model to null, before it is fetched from the server.
  // This allows us to clear out the previous data from the list_view,
  // and get ready for the new data for the project show view.
  // model: null,

  events: {
    "click button.owner-form-toggle"      : "toggleOwners",
    "click #owner-save"                   : "saveOwners",
    "click #owner-cancel"                 : "initializeOwnerSelect2",
    "click .delete-projectowner"          : "removeOwner"
  },

  // The initialize method is mainly used for event bindings (for effeciency)
  initialize: function (options) {
    var self = this;
    this.options = options;
    this.data = options.data;
    this.action = options.action;
    this.user = window.cache.currentUser || {};
    if (this.options.action) {
      if (this.options.action == 'edit') {
        this.edit = true;
      }
    }

    this.model.on("projectowner:show:rendered", function () {
      self.initializeOwnerSelect2();
    });
    //when owner set is updated, re-render and re-init popovers
    this.model.on("project:update:owners:success", function (data) {
      self.render();
      if (_.isUndefined(popovers)) {
        var popovers = new Popovers();
        popovers.popoverPeopleInit(".project-people-div");
      }
    });

  },

  render: function () {
    var compiledTemplate;
    var data = {
      data: this.model.toJSON(),
      user: this.user
    };
    data.data.edit = this.edit;
    compiledTemplate = _.template(ProjectownerShowTemplate)(data);
    this.$el.html(compiledTemplate);
    this.$el.i18n();

    this.model.trigger("projectowner:show:rendered", data);
    return this;
  },

  initializeOwnerSelect2: function () {
    var self = this;
    if ((this.model.attributes.isOwner || this.user.isAdmin) && this.edit){
      var formatResult = function (object, container, query) {
        return object.name;
      };
      var oldOwners = this.model.attributes.owners || [];
      var oldOwnerIds = _.map(oldOwners, function(owner){ return owner.userId }) || [];

      self.$("#owners").select2({
        placeholder: 'Add ' + i18n.t('Project') + ' Owners',
        multiple: true,
        formatResult: formatResult,
        formatSelection: formatResult,
        minimumInputLength: 1,
        ajax: {
            url: '/api/ac/user',
            dataType: 'json',
            data: function (term) {
              return {
                q: term
              };
            },
            results: function (data) {
              return { results: _.filter(data, function(user){  return _.indexOf( oldOwnerIds, user.id) >= 0 ? false : true; }, self ) };
          }
        }
      });

      self.$('#owner-edit').show();

    }
    else
    {
      self.$('#owner-edit').hide();
    }

    self.$('#project-owners-form').hide();
    self.$('#project-owners-show').show();
    self.$('#owner-save').hide();
    self.$('#owner-cancel').hide();

  },

  toggleOwners : function(e){
    if (!(this.model.attributes.isOwner || this.user.isAdmin) && this.edit) return false;
    $('.owner-form-toggle').toggle(400);
  },

  saveOwners : function(e){
    if (e.preventDefault) e.preventDefault();
    if (!(this.model.attributes.isOwner || this.user.isAdmin) && this.edit) return false;
    var self = this;

    var pId = self.model.attributes.id;

    var oldOwners = this.model.attributes.owners || [];
    var s2data = $("#owners").select2("data")  || [];
    var s2OwnerIds = _.map(s2data, function(owner){ return owner.id }) || [];

    async.each(s2OwnerIds, createOwner, function(){ self.model.trigger("projectowner:show:changed", oldOwners); });

    $("#owners").select2("data", []);

    function createOwner(ownerID, done){
      var self = this;
      $.ajax({
          url: '/api/projectowner/',
          type: 'POST',
          data: {
            projectId: pId,
            userId: ownerID
          },
          success : function(data){
            var POId = data.id;
            oldOwners.push({ id:POId, userId: ownerID});
          }

        }).done(function (data) {
          done();
        });
    };

  },

  removeOwner: function(e) {
    if (e.stopPropagation()) e.stopPropagation();
    if (e.preventDefault) e.preventDefault();
    $(e.currentTarget).off("mouseenter");
    $('.popover').remove();

    var pOId = $(e.currentTarget).data('poid');
    var uId = $(e.currentTarget).data('uid');
    var self = this;

    if (typeof cache !== "undefined" && uId !== cache.currentUser.id)
    {
      $.ajax({
        url: '/api/projectowner/' + pOId,
        type: 'DELETE',
      }).done(function (data) {
          // done();
      });
    }

    var oldOwners = this.model.attributes.owners || [];
    var unchangedOwners = _.filter(oldOwners, function(owner){ return ( owner.id !== pOId ); } , this)  || [];
    self.model.trigger("projectowner:show:changed", unchangedOwners);
  },




  // ---------------------
  //= Utility Methods
  // ---------------------
  cleanup: function() {
    removeView(this);
  }

});

module.exports = ProjectownerShowView;

},{"../../../../components/modal":106,"../../../../mixins/popovers":126,"../../../../mixins/utilities":128,"../templates/projectowner_show_template.html":78,"async":131,"backbone":133,"underscore":159}],80:[function(require,module,exports){
module.exports = "<form role=\"form\" action=\"\" id=\"tag-form\">\n  <div class=\"modal-body\">\n    <fieldset>\n      <div class=\"form-group\">\n        <label for=\"tag-form-type\">Tag Type</label>\n        <select id=\"tag-form-type\" name=\"tag-form-type\" class=\"form-control\">\n          <% for (var i = 0; i < tags.length; i++) { %>\n          <option value=\"<%- tags[i].type %>\"><%- tags[i].name %></option>\n          <% } %>\n        </select>\n      </div>\n      <div class=\"form-group\">\n        <label for=\"tag-form-name\">\n          Tag Name\n        </label>\n        <input type=\"text\" class=\"form-control\" id=\"tag-form-name\" name=\"tag-form-name\" placeholder=\"Tag Name\" data-validate=\"empty,count100\"/>\n        <span class=\"help-block error-empty\" style=\"display:none;\">You must enter a tag name.</span>\n        <span class=\"help-block error-count100\" style=\"display:none;\">Tags must be less than 100 characters in length.</span>\n      </div>\n    </fieldset>\n  </div>\n  <div class=\"modal-footer\">\n    <button type=\"button\" class=\"btn btn-c0\" data-dismiss=\"modal\">Cancel</button>\n    <input type=\"submit\" class=\"btn btn-c2\" id=\"submit\" value=\"Create Tag\"/>\n  </div>\n</form>\n";

},{}],81:[function(require,module,exports){

var Bootstrap = require('bootstrap');
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var TagFormTemplate = require('../templates/tag_new_form_template.html');


var TagFormView = Backbone.View.extend({

  events: {
    "blur #tag-form-name" : "v",
    "submit #tag-form"    : "post"
  },

  initialize: function (options) {
    this.tags = options.tags;
    this.target = options.target;
    this.options = options;
  },

  render: function () {
    var data = {
      tags: this.tags
    };
    var template = _.template(TagFormTemplate)(data);
    this.$el.html(template);
    return this;
  },

  v: function (e) {
    return validate(e);
  },

  post: function (e) {
    if (e.preventDefault) e.preventDefault();

    // perform field validation
    var validateIds = ['#tag-form-name'];
    var abort = false;
    for (var i in validateIds) {
      var iAbort = validate({ currentTarget: validateIds[i] });
      abort = abort || iAbort;
    }
    if (abort) {
      return;
    }

    // assemble form and submit
    var data;
    var self = this;

    data = {
      type: $(e.currentTarget).find("#tag-form-type").val(),
      name: $(e.currentTarget).find("#tag-form-name").val()
    }

    $.ajax({
      url: '/api/tag/add',
      type: 'POST',
      data: data
    }).done(function (result) {
      // Pass the tag back
      self.options.model.trigger(self.target + ":tag:new", result);
    });

  },

  cleanup: function () {
    removeView(this);
  }

});

module.exports = TagFormView;

},{"../../../../mixins/utilities":128,"../templates/tag_new_form_template.html":80,"backbone":133,"bootstrap":138,"underscore":159}],82:[function(require,module,exports){
module.exports = "<li><%- tag.tag.name %>\n<% if ((data.isOwner || user.isAdmin) && edit) { %>\n<span class=\"tag-delete fa fa-times\" data-id=\"<%- tag.id %>\"></span>\n<% } %>\n</li>\n";

},{}],83:[function(require,module,exports){
module.exports = "<% for (var i = 0; i < tags.length; i++) { %>\n<div class=\"tag-title <%- tags[i]['class'] %>\" id=\"<%- tags[i].id %>\">\n  <h2><i class=\"<%- tags[i].icon %>\"></i> <span class=\"box-icon-text\"><%- tags[i].plural %></span></h2>\n  <% if ((data.isOwner || user.isAdmin) && edit) { %>\n  <div style='margin-bottom: 5px'>\n    <input type=\"text\" id=\"tag_<%- tags[i].id.toLowerCase() %>\" class=\"fullwidth\" name=\"tag_<%- tags[i].name.toLowerCase() %>\"/>\n  </div>\n  <% } %>\n  <ul class=\"tags\">\n    <li class=\"tag-empty\" id=\"<%- tags[i]['class'] %>-empty\">\n      <% if (tags[i]['class'] === 'location') { %>Anywhere<% } else { %>None<% } %>\n    </li>\n  </ul>\n</div>\n<% } %>\n<% if (data.userId) {\n%>\n<div class=\"tag-title\">\n  <h2><i class=\"fa fa-child \"></i> <span class=\"box-icon-text\">Progress</span></h2>\n  <ul class=\"tags\">\n    <li class=\"tag-empty\" id=\"task-length-empty\" style=\"display: none;\">None</li>\n    <li>Published: <%- data.publishedAt ? moment(data.publishedAt).format('ddd, MMM D, YYYY') : '--' %></li><br>\n    <li>Assigned: <%- data.assignedAt ? moment(data.assignedAt).format('ddd, MMM D, YYYY') : '--' %></li><br>\n    <li>Completed: <%- data.completedAt ? moment(data.completedAt).format('ddd, MMM D, YYYY') : '--' %></li>\n  </ul>\n</div>\n<% } %>\n";

},{}],84:[function(require,module,exports){

var Bootstrap = require('bootstrap');
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var async = require('async');
var ModalComponent = require('../../../../components/modal');
var TagConfig = require('../../../../config/tag');
var TagFormView = require('../../new/views/tag_new_form_view');
var TagTemplate = require('../templates/tag_item_template.html');
var TagShowTemplate = require('../templates/tag_show_template.html');
var TagFactory = require('../../../../components/tag_factory');


var TagShowView = Backbone.View.extend({

  events: {
    "click #tag-create"     : "createTag",
    "click #tag-save"       : "saveTag",
    "click .tag-delete"     : "deleteTag"
  },

  initialize: function (options) {
    this.options = options;
    this.model = options.model;
    this.target = options.target;
    this.targetId = options.targetId;
    this.edit = options.edit;
    this.tagFactory = new TagFactory();
    this.tags = [];
    // Figure out which tags apply
    for (var i = 0; i < TagConfig[this.target].length; i++) {
      this.tags.push(TagConfig.tags[TagConfig[this.target][i]]);
    }
  },

  render: function () {
    var data = {
      data: this.model.toJSON(),
      tags: this.tags,
      edit: this.edit,
      user: window.cache.currentUser || {}
    };
    var template = _.template(TagShowTemplate)(data);
    this.$el.html(template);
    this.initializeSelect2();
    this.initializeTags();
    return this;
  },

  initializeSelect2: function () {
    var self = this;

    self.tagFactory.createTagDropDown({
      type:"skill",selector:"#tag_skill",width: "100%",tokenSeparators: [","]
    });

    self.tagFactory.createTagDropDown({
      type:"topic",selector:"#tag_topic",width: "100%",tokenSeparators: [","]
    });

    self.tagFactory.createTagDropDown({type:"location",selector:"#tag_location",width: "100%"});
    self.tagFactory.createTagDropDown({type:"agency",selector:"#tag_agency",width: "100%"});
    self.model.trigger("profile:input:changed");
  },

  initializeTags: function() {
    // Load tags for the view
    var self = this;

    var tagIcon = {};
    var tagClass = {};
    for (var i = 0; i < this.tags.length; i++) {
      tagIcon[this.tags[i].type] = this.tags[i].icon;
      tagClass[this.tags[i].type] = this.tags[i]['class'];
    }

    var renderTag = function (tag) {
      var templData = {
        data: self.model.toJSON(),
        tags: self.tags,
        tag: tag,
        edit: self.edit,
        user: window.cache.currentUser || {}
      };
      var compiledTemplate = _.template(TagTemplate)(templData);
      var tagDom = $("." + tag.tag.type).children(".tags");
      tagDom.append(compiledTemplate);
      $('#' + tagClass[tag.tag.type] + '-empty').hide();
    };

    $.ajax({
      url: this.options.url + this.model.id
    }).done(function (data) {
      for (var i = 0; i < data.length; i++) {
        // Render tags onto page
        renderTag(data[i]);
      }
    });

    // Initialize Select2 for Administrative Functions
    var formatResult = function (object, container, query) {
      return '<i class="' + tagIcon[object.type] + '"></i> ' + object.name;
    };

    $("#input-tags").select2({
      placeholder: 'Add tags',
      multiple: true,
      formatResult: formatResult,
      formatSelection: formatResult,
      ajax: {
        url: '/api/ac/tag',
        dataType: 'json',
        data: function (term) {
          return {
            type: TagConfig[self.target].join(),
            q: term
          };
        },
        results: function (data) {
          return { results: data };
        }
      }
    });

    // New tags added in to the DB via the modal
    this.listenTo(this.model, this.target + ":tag:new", function (data) {
      // Destory modal
      $(".modal").modal('hide');
      // Add tag into the data list
      var s2data = $("#input-tags").select2("data");
      s2data.push(data);
      $("#input-tags").select2("data", s2data);
    });

    // Tags saved using the select2 dialog
    this.listenTo(this.model, this.target + ":tag:save", function (data) {
      for (var i = 0; i < data.length; i++) {
        if (!data[i].existing) {
          renderTag(data[i]);
        }
      }
      $("#input-tags").select2("val", "");
    });

    this.listenTo(this.model, this.target + ":tag:delete", function (e) {
      if ($(e.currentTarget).parent('li').siblings().length == 1) {
        $(e.currentTarget).parent('li').siblings('.tag-empty').show();
      }
      $(e.currentTarget).parent('li').remove();
    });
  },

  createTag: function (e) {
    if (e.preventDefault) e.preventDefault();
    var self = this;

    // Pop up dialog box to create tag,
    // then put tag into the select box
    if (_.isUndefined(this.modalComponent)) {
      this.modalComponent = new ModalComponent({
        el: "#container",
        id: "createTag",
        modalTitle: "Create Tag"
      }).render();
    }

    if (!_.isUndefined(this.modalComponent)) {
      if (this.tagFormView) {
        this.tagFormView.cleanup();
      }
      this.tagFormView = new TagFormView({
        el: "#createTag .modal-template",
        model: self.model,
        tags: self.tags,
        target: self.target
      });
      this.tagFormView.render();
    }
  },

  saveTag: function (e) {
    if (e.preventDefault) e.preventDefault();
    var self = this;
    // Cycle through tags in select box
    // and call create on each one, then
    // render
    $("#tag-save").addClass('disabled');
    var data = $("#input-tags").select2('data');
    var result = [];

    var processTag = function(tag, done) {
      var tagMap = {
        tagId: tag.id
      };
      if (self.targetId) {
        tagMap[self.targetId] = self.model.id;
      }
      $.ajax({
        url: '/api/tag',
        type: 'POST',
        data: tagMap
      }).done(function (data) {
        result.push(data);
        done();
      });
    };

    async.each(data, processTag, function (err) {
      for (var i = 0; i < result.length; i++) {
        for (var j = 0; j < data.length; j++) {
          if (result[i].tagId == data[j].id) {
            result[i].tag = data[j];
            break;
          }
        }
      }
      $("#tag-save").removeClass('disabled');
      self.model.trigger(self.options.target + ":tag:save", result);
    });

  },

  deleteTag: function (e) {
    if (e.preventDefault) e.preventDefault();
    var self = this;
    // Get the data-id of the currentTarget
    // and then call HTTP DELETE on that tag id
    $.ajax({
      url: '/api/tag/' + $(e.currentTarget).data('id'),
      type: 'DELETE',
    }).done(function (data) {
      self.model.trigger(self.options.target + ":tag:delete", e);
    });
  },

  cleanup: function () {
    if (this.tagFormView) { this.tagFormView.cleanup(); }
    removeView(this);
  }

});

module.exports = TagShowView;

},{"../../../../components/modal":106,"../../../../components/tag_factory":112,"../../../../config/tag":115,"../../../../mixins/utilities":128,"../../new/views/tag_new_form_view":81,"../templates/tag_item_template.html":82,"../templates/tag_show_template.html":83,"async":131,"backbone":133,"bootstrap":138,"underscore":159}],85:[function(require,module,exports){
module.exports = "<form action=\"\" id=\"task-edit-form\">\n  <div class=\"form-group\">\n    <h2 class=\"box-pad-t\">\n      <span data-i18n=\"Task\">Opportunity</span> Title\n    </h2>\n    <input id=\"task-title\" type=\"text\" placeholder=\"A short description of the problem.\" value=\"<%- data.title %>\" class=\"form-control input-lg validate\" data-validate=\"empty,count100\"/>\n    <span class=\"help-block error-empty\" style=\"display:none;\">You must enter a title for this <span data-i18n=\"task\">opportunity</span></span>\n    <span class=\"help-block error-count100\" style=\"display:none;\">The short description of the problem must be less than 100 characters.</span>\n  </div>\n  <div class=\"form-group\">\n    <h2 class=\"box-pad-t\">\n      <span data-i18n=\"Task\">Opportunity</span> Description\n    </h2>\n    <div class=\"markdown-edit\"></div>\n    <span class=\"help-block error-empty\" style=\"display:none;\">You must enter a description for this <span data-i18n=\"task\">opportunity</span></span>\n  </div>\n  <hr />\n\n  <% if (ui.project.show) { %>\n  This <span data-i18n=\"task\">opportunity</span> belongs to the <span data-i18n=\"project\">project</span>:\n  <div class=\"row\">\n    <div class=\"col-md-12\">\n      <input type=\"hidden\" id=\"projectId\" class=\"task-skills fullwidth\" />\n    </div>\n  </div>\n  <% } %>\n\n  <hr/>\n\n  <div class=\"row\">\n    <div class=\"col-md-12\">\n        <span data-i18n=\"TaskOwner\">Task Owner</span>\n        <input style=\"width: 100%\" id=\"owner\" name=\"owner\" type=\"hidden\" value=\"Edit Owner\"/>\n    </div>\n  </div>\n\n  <hr/>\n\n  <div class=\"task-edit-description\">\n    We need\n    <select id=\"people\" class=\"dropdown\">\n      <% _.each(tagTypes['task-people'], function (t) { %>\n      <option value=<%= t.id %> <% if (madlibTags['task-people'] && (madlibTags['task-people'][0].id == t.id)) { %>selected<% } %>><%= t.name %></option>\n      <% }); %>\n    </select>\n\n    to work on an <span data-i18n=\"task\">opportunity</span> about:\n    <div class=\"row\">\n      <div class=\"col-md-12\">\n        <input type=\"hidden\" id=\"task_tag_topics\" class=\"task-skills fullwidth\" />\n      </div>\n    </div>\n\n    <hr />\n\n    The following skills are useful and\n    <select id=\"skills-required\" class=\"dropdown\">\n      <% _.each(tagTypes['task-skills-required'], function (t) { %>\n      <option value=<%= t.id %> <% if (madlibTags['task-skills-required'] && (madlibTags['task-skills-required'][0].id == t.id)) { %>selected<% } %>><%= t.name %></option>\n      <% }); %>\n    </select>\n\n    to complete this <span data-i18n=\"task\">opportunity</span> you should\n    <div class=\"row\">\n      <div class=\"col-md-12\">\n        <input type=\"hidden\" id=\"task_tag_skills\" class=\"task-skills fullwidth\"/>\n      </div>\n    </div>\n\n    <hr />\n\n    The <span data-i18n=\"task\">opportunity</span> will require\n    <select id=\"time-estimate\" class=\"dropdown\">\n      <% _.each(tagTypes['task-time-estimate'], function (t) { %>\n      <option value=<%= t.id %> <% if (madlibTags['task-time-estimate'] && (madlibTags['task-time-estimate'][0].id == t.id)) { %>selected<% } %>><%= t.name %></option>\n      <% }); %>\n    </select>\n\n    of\n    <select id=\"time-required\" class=\"dropdown\">\n      <% _.each(tagTypes['task-time-required'], function (t) { %>\n      <option value=<%= t.id %> <% if (madlibTags['task-time-required'] && (madlibTags['task-time-required'][0].id == t.id)) { %>selected<% } %>><%= t.name %></option>\n      <% }); %>\n    </select>\n\n    work, and must be completed within\n    <select id=\"length\" class=\"dropdown\">\n      <% _.each(tagTypes['task-length'], function (t) { %>\n      <option value=<%= t.id %> <% if (madlibTags['task-length'] && (madlibTags['task-length'][0].id == t.id)) { %>selected<% } %>><%= t.name %></option>\n      <% }); %>\n    </select>\n\n    <hr />\n\n    Participants must be located at:<br/>\n\n    <div class=\"row\">\n      <div class=\"col-md-12\">\n        <input type=\"hidden\" id=\"task_tag_location\" class=\"task-skills fullwidth\"/>\n      </div>\n    </div>\n    <small>Leave empty if people can participate from anywhere</small>\n\n    <hr/>\n\n    Pubished date:<br>\n    <div class=\"col-md-12 padding-none\" id=\"div-publishedAt\">\n      <input id=\"publishedAt\" name=\"publishedAt\" class=\"form-control timepicker\" type=\"text\">\n    </div>\n    Assigned date:<br>\n    <div class=\"col-md-12 padding-none\" id=\"div-assignedAt\">\n      <input id=\"assignedAt\" name=\"assignedAt\" class=\"form-control timepicker\" type=\"text\">\n    </div>\n    Completed date:<br>\n    <div class=\"col-md-12 padding-none\" id=\"div-completedAt\">\n      <input id=\"completedAt\" name=\"completedAt\" class=\"form-control timepicker\" type=\"text\">\n    </div>\n    <div class=\"clearfix\">\n      <hr>\n    </div>\n\n  </div>\n  <div class=\"row\">\n    <div class=\"col-lg-12\">\n      <div class=\"pull-right box-pad-b\">\n        <button class=\"btn btn-c0\" id=\"task-view\">Discard Changes</button>\n        <input type=\"submit\" class=\"btn btn-c2\" data-i18n=\"[value]SaveTask\" value=\"Save Opportunity\"/>\n      </div>\n    </div>\n  </div>\n</form>\n";

},{}],86:[function(require,module,exports){
module.exports = "<div class=\"project-people-div\" data-userid=\"<%= data.userId %>\">\n  <img src=\"/api/user/photo/<%= data.userId %>\" class=\"project-people\" alt=\"<%= data.owner.name %>\"/>\n</div>\n<div class=\"project-people-space\">\n  <div class=\"bar\"></div>\n</div>\n<% _.each(data.volunteers, function (v) { %>\n  <div class=\"project-people-div\" data-userid=\"<%= v.userId %>\" data-voluserid=\"<%= v.userId %>\">\n    <img src=\"/api/user/photo/<%= v.userId %>\" class=\"project-people\" alt=\"<%= v.name %>\"/>\n    <a href=\"#\" class=\"delete-volunteer volunteer-delete fa fa-times\"  id=\"delete-volunteer-<%= v.id %>\" data-uid=\"<%= v.userId %>\" data-vid=\"<%= v.id %>\"></a>\n  </div>\n<% }); %>\n";

},{}],87:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var utilities = require('../../../../mixins/utilities');
var UIConfig = require('../../../../config/ui.json');
var async = require('async');
var marked = require('marked');
var MarkdownEditor = require('../../../../components/markdown_editor');
var TaskEditFormTemplate = require('../templates/task_edit_form_template.html');
var VolunteerEditFormTemplate = require('../templates/volunteer_edit_form_template.html');
var TagFactory = require('../../../../components/tag_factory');


var TaskEditFormView = Backbone.View.extend({

  events: {
    'blur .validate'         : 'v',
    'click #task-view'       : 'view',
    'submit #task-edit-form' : 'submit'
  },

  initialize: function (options) {
    this.options = options;
    this.tagFactory = new TagFactory();
    this.data = {};
    this.data.newTag = {};
    this.initializeListeners();
    // Register listener to task update, the last step of saving
    this.listenTo(this.options.model, "task:update:success", function (data) {
      Backbone.history.navigate('tasks/' + data.attributes.id, { trigger: true });
    });
  },

  view: function (e) {
    if (e.preventDefault) e.preventDefault();
    Backbone.history.navigate('tasks/' + this.model.attributes.id, { trigger: true });
  },

  v: function (e) {
    return validate(e);
  },

  render: function () {
    var compiledTemplate, volunteerTemplate;

    this.data = {
      data: this.model.toJSON(),
      tagTypes: this.options.tagTypes,
      newTags: [],
      newItemTags: [],
      tags: this.options.tags,
      madlibTags: this.options.madlibTags,
      ui: UIConfig
    };

    volunteerTemplate = _.template(VolunteerEditFormTemplate)(this.data);
    //$(this.options.elVolunteer).remove();
    $(this.options.elVolunteer).html(volunteerTemplate);
    $(this.options.elVolunteer).i18n();

    compiledTemplate = _.template(TaskEditFormTemplate)(this.data);
    this.$el.html(compiledTemplate);
    this.$el.i18n();

    // DOM now exists, begin select2 init
    this.initializeSelect2();
    this.initializeTextArea();

    // Set up time pickers
    $('#publishedAt').datetimepicker({
      defaultDate: this.data.data.publishedAt
    });
    $('#assignedAt').datetimepicker({
      defaultDate: this.data.data.assignedAt
    });
    $('#completedAt').datetimepicker({
      defaultDate: this.data.data.completedAt
    });

  },

  initializeSelect2: function () {

    var formatResult = function (object, container, query) {
      var formatted = '<div class="select2-result-title">';
      formatted += object.name || object.title;
      formatted += '</div>';
      if (!_.isUndefined(object.description)) {
        formatted += '<div class="select2-result-description">' + marked(object.description) + '</div>';
      }
      return formatted;
    };

    this.$("#projectId").select2({
      placeholder: "Select a project to associate",
      multiple: false,
      formatResult: formatResult,
      formatSelection: formatResult,
      allowClear: true,
      ajax: {
        url: '/api/ac/project',
        dataType: 'json',
        data: function (term) {
          return {
            q: term
          };
        },
        results: function (data) {
          return { results: data };
        }
      }
    });
    if (this.data.data.project) {
      this.$("#projectId").select2('data', this.data.data.project);
    }

    this.$("#owner").select2({
      placeholder: "task owner",
      multiple: false,
      formatResult: formatResult,
      formatSelection: formatResult,
      allowClear: false,
      ajax: {
        url: '/api/ac/user',
        dataType: 'json',
        data: function (term) {
          return {
            q: term
          };
        },
        results: function (data) {
          return { results: data };
        }
      }
    });
    if (this.data.data.owner) {
      this.$("#owner").select2('data', this.data.data.owner);
    }

    this.tagFactory.createTagDropDown({
      type:"skill",selector:"#task_tag_skills",width: "100%", tokenSeparators: [","]
    });
    if (this.data['madlibTags'].skill) {
      this.$("#task_tag_skills").select2('data', this.data['madlibTags'].skill);
    }

    this.tagFactory.createTagDropDown({
      type:"topic", selector: "#task_tag_topics", width: "100%", tokenSeparators: [","]
    });
    if (this.data['madlibTags'].topic) {
      this.$("#task_tag_topics").select2('data', this.data['madlibTags'].topic);
    }

    this.tagFactory.createTagDropDown({type:"location",selector:"#task_tag_location",width: "100%"});
    if (this.data['madlibTags'].location) {
      this.$("#task_tag_location").select2('data', this.data['madlibTags'].location);
    }

    $("#skills-required").select2({
      placeholder: "required/not-required",
      width: '200px'
    });

    $("#time-required").select2({
      placeholder: 'time-required',
      width: '130px'
    });

    $("#people").select2({
      placeholder: 'people',
      width: '150px'
    });

    $("#length").select2({
      placeholder: 'length',
      width: '130px'
    });

    $("#time-estimate").select2({
      placeholder: 'time-estimate',
      width: '200px'
    });

    $("#task-location").select2({
      placeholder: 'location',
      width: '130px'
    });

  },

  initializeTextArea: function () {
    if (this.md) { this.md.cleanup(); }
    this.md = new MarkdownEditor({
      data: this.model.toJSON().description,
      el: ".markdown-edit",
      id: 'task-description',
      placeholder: 'Description of opportunity including goals, expected outcomes and deliverables.',
      title: 'Opportunity Description',
      rows: 6,
      validate: ['empty']
    }).render();
  },

  initializeListeners: function() {
    var self = this;

    self.on("task:tags:save:done", function (){

      var modelData = {
        title: this.$("#task-title").val(),
        description: this.$("#task-description").val(),
        publishedAt: this.$("#publishedAt").val() || undefined,
        assignedAt: this.$("#assignedAt").val() || undefined,
        completedAt: this.$("#completedAt").val() || undefined
      };

      var project = this.$("#projectId").select2('data');
      if (project) {
        modelData.projectId = project.id;
      } else {
        modelData.projectId = null;
      }

      var owner = this.$("#owner").select2('data');
      if (owner) {
        modelData.userId = owner.id;
      }

      oldTags = this.getOldTags();
      tags    = this.getTagsFromPage();
      diff    = this.tagFactory.createDiff(oldTags, tags);

      _.each(self.data.newItemTags, function(newItemTag){
        diff.add.push(newItemTag.id);
      });

      async.forEach(
        diff.add,
        function(diffAdd, callback){
          if ( !_.isFinite(diffAdd) && diffAdd.name == diffAdd.id ) { return callback(); }
          self.tagFactory.addTag(diffAdd,self.model.attributes.id,"taskId",callback);
        },
        function(err){
          self.options.model.trigger("task:update", modelData);
        }
      );

    });
  },

  submit: function (e) {
    var self = this;
    if (e.preventDefault) e.preventDefault();
    //var self = this;

    var tags = [];
    var oldTags = [];
    var diff = [];

    _.extend(this, Backbone.Events);

    // check all of the field validation before submitting
    var children = this.$el.find('.validate');
    var abort = false;
    _.each(children, function (child) {
      var iAbort = validate({ currentTarget: child });
      abort = abort || iAbort;
    });
    if (abort === true) {
      return;
    }

    //var types = ["task-skills-required", "task-time-required", "task-people", "task-length", "task-time-estimate", "skill", "topic", "location"];
    tags = this.getTagsFromPage();
    oldTags = this.getOldTags();

    newTags = [];
    newTags = newTags.concat(self.$("#task_tag_topics").select2('data'),self.$("#task_tag_skills").select2('data'),self.$("#task_tag_location").select2('data'));

      async.forEach(
        newTags,
        function(newTag, callback) {
          self.tagFactory.addTagEntities(newTag,self,callback);
        },
        function(err, data) {
          if (err) return next(err);
          self.trigger("task:tags:save:done");
        }
      );
    diff = this.tagFactory.createDiff(oldTags, tags);

    if ( diff.remove.length > 0 ) {
      async.each(diff.remove, self.tagFactory.removeTag, function (err) {
        // do nothing for now
      });
    }
  },

  getTagsFromPage: function () {

    // Gather tags for submission after the task is created
    var tags = [];
    tags.push.apply(tags,this.$("#task_tag_topics").select2('data'));
    tags.push.apply(tags,this.$("#task_tag_skills").select2('data'));
    tags.push.apply(tags,this.$("#task_tag_location").select2('data'));
    tags.push.apply(tags,[this.$("#skills-required").select2('data')]);
    tags.push.apply(tags,[this.$("#people").select2('data')]);
    tags.push.apply(tags,[this.$("#time-required").select2('data')]);
    tags.push.apply(tags,[this.$("#time-estimate").select2('data')]);
    tags.push.apply(tags,[this.$("#length").select2('data')]);

    return tags;
  },

  getOldTags: function () {

    var oldTags = [];
      for (var i in this.options.tags) {
        oldTags.push({
          id: parseInt(this.options.tags[i].id),
          tagId: parseInt(this.options.tags[i].tag.id),
          type: this.options.tags[i].tag.type
        });
      }

    return oldTags;
  },

  cleanup: function () {
    if (this.md) { this.md.cleanup(); }
    removeView(this);
  }

});

module.exports = TaskEditFormView;

},{"../../../../components/markdown_editor":104,"../../../../components/tag_factory":112,"../../../../config/ui.json":116,"../../../../mixins/utilities":128,"../templates/task_edit_form_template.html":85,"../templates/volunteer_edit_form_template.html":86,"async":131,"backbone":133,"marked":155,"underscore":159}],88:[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');
var Utilities = require('../../../../mixins/utilities');
var Bootstrap = require('bootstrap');
var TasksCollection = require('../../../../entities/tasks/tasks_collection');
var TaskCollectionView = require('../views/task_collection_view');
var TaskFormView = require('../../new/views/task_form_view');
var ModalWizardComponent = require('../../../../components/modal_wizard');
var TaskModel = require('../../../../entities/tasks/task_model');

TaskList = Backbone.View.extend({

  el: "#task-list-wrapper",

  events: {
    'click .add-task' : 'add',
    'click .show-task': 'show',
    'click .task'     : 'show',
    'click .wizard'   : 'wizard'
  },

  initialize: function (settings) {
    this.options = _.extend(settings, this.defaults);
    var self = this;

    this.initializeTaskCollectionInstance();
    this.initializeTaskModelInstance();
    this.initializeListeners();
    this.requestTasksCollectionData();

    this.collection.on("tasks:render", function () {
      self.requestTasksCollectionData()
    })
  },

  initializeListeners: function() {
    var self = this;
    this.listenTo(this.taskModel, 'task:tags:save:success', function () {
      self.initializeTaskModelInstance();
      self.requestTasksCollectionData();
    });
  },

  initializeTaskModelInstance: function () {
    this.taskModel = new TaskModel();
  },

  initializeTaskCollectionInstance: function () {
    if (this.collection) {
      this.collection.initialize();
    } else {
      this.collection = new TasksCollection();
    }
  },

  requestTasksCollectionData: function () {
    var self = this;

    this.collection.fetch({
      url: '/api/task/findAllByProjectId/' + parseInt(this.options.projectId),
      success: function (collection) {
        self.tasks = collection;
        self.renderTaskCollectionView()
      }
    });
  },

  renderTaskCollectionView: function () {
    var self = this;

    if (this.taskCollectionView) this.taskCollectionView.cleanup();
    this.taskCollectionView = new TaskCollectionView({
      el: "#task-list-wrapper",
      onRender: true,
      collection: self.tasks
    });
  },

  add: function (e) {
    if (e.preventDefault) e.preventDefault();
    var self = this;

    if (this.taskFormView) this.taskFormView.cleanup();
    if (this.modalWizardComponent) this.modalWizardComponent.cleanup();
    this.modalWizardComponent = new ModalWizardComponent({
      el: ".wrapper-addTask",
      id: "addTask",
      modalTitle: 'New Opportunity',
      model: self.taskModel,
      collection: self.tasks,
      modelName: 'task',
      data: function (parent) { return {
        title: parent.$("#task-title").val(),
        description: parent.$("#task-description").val(),
        projectId: self.options.projectId
      } }
    }).render();

    this.taskFormView = new TaskFormView({
      el: ".modal-body",
      projectId: this.options.projectId,
      model: self.taskModel,
      tasks: self.tasks
    }).render();
    this.modalWizardComponent.setChildView(this.taskFormView);
    this.modalWizardComponent.setNext(this.taskFormView.childNext);
    this.modalWizardComponent.setSubmit(this.taskFormView.childNext);
  },

  show: function (e) {
    if (e.preventDefault) e.preventDefault();
    var projectId = $(e.currentTarget).data('projectid'),
        taskId    = $(e.currentTarget).data('id');

    if (taskId == 'null') { return; }

    Backbone.history.navigate('tasks/' + taskId, { trigger: true }, taskId);
  },

  cleanup: function () {
    if (this.taskFormView) this.taskFormView.cleanup();
    if (this.modalWizardComponent) this.modalWizardComponent.cleanup();
    if (this.taskCollectionView) this.taskCollectionView.cleanup();
    removeView(this);
  }

});

module.exports = TaskList;


},{"../../../../components/modal_wizard":110,"../../../../entities/tasks/task_model":124,"../../../../entities/tasks/tasks_collection":125,"../../../../mixins/utilities":128,"../../new/views/task_form_view":92,"../views/task_collection_view":90,"backbone":133,"bootstrap":138,"underscore":159}],89:[function(require,module,exports){
module.exports = "<div class=\"box-pad-lr border-bottom\">\n  <h2>\n    Available Opportunities\n    <% if (user) { %>\n    <a href=\"#addTask\" class=\"btn btn-c0 btn-sm file-add add-task\" data-toggle=\"modal\" data-backdrop=\"static\">Add Opportunity</a>\n    <% } %>\n  </h2>\n</div>\n\n<div class=\"task-scroll\">\n  <% if (tasks.length == 0) { %>\n  <div class=\"task border-left\" data-id=\"null\">\n    <div class=\"task-title\">\n      No current opportunities.\n    </div>\n  </div>\n  <% } %>\n  <% _.each(tasks, function(task) { %>\n  <div class=\"task border-left\" data-projectid=\"<%= task.projectId %>\" data-id=\"<%= task.id %>\">\n    <div class=\"pull-right\">\n      <strong><%= task.state %></strong>\n    </div>\n    <div class=\"task-title\">\n      <a href=\"/tasks/<%- task.id %>\" class=\"show-task\" data-projectid=\"<%= task.projectId %>\" data-id=\"<%= task.id %>\"><%- task.title %></a>\n    </div>\n    <div class=\"task-description\">\n      <%= task.description %>\n    </div>\n    <div class=\"task-tags-row\">\n      <ul class=\"tags task-tags\">\n        <% _.each(task.tags, function (tag) { %>\n          <li><%= tag.tag.name %></li>\n        <% }); %>\n      </ul>\n    </div>\n  </div>\n  <% }) %>\n</div>\n";

},{}],90:[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var async = require('async');
var marked = require('marked');
var TaskListTemplate = require('../templates/task_collection_view_template.html');


	var TasksCollectionView = Backbone.View.extend({

		el: "#task-list-wrapper",

		initialize: function (options) {
			this.options = options;
			this.requestTagData();
		},

		requestTagData: function () {
			var self = this;

			this.tasksJson = {
				tasks: this.options.collection.toJSON(),
				user: window.cache.currentUser
			};

			var requestTagData = function (task, done) {
				$.ajax({
					url: '/api/tag/findAllByTaskId/' + task.id,
					async: false,
					success: function (tags) {
						task['tags'] = tags;
						done();
					},
					error: function () {
						task['tags'] = [];
						done();
					}
				});
			}

			async.each(this.tasksJson.tasks, requestTagData, function () {
				self.render();
			});

		},

		render: function () {
			_.each(this.tasksJson.tasks, function(task) {
				task.description = marked(task.description);
			});
			this.compiledTemplate = _.template(TaskListTemplate)(this.tasksJson);
			this.$el.html(this.compiledTemplate);

			return this;
		},

		cleanup: function () {
			removeView(this);
		}

	});

	module.exports = TasksCollectionView;

},{"../../../../mixins/utilities":128,"../templates/task_collection_view_template.html":89,"async":131,"backbone":133,"marked":155,"underscore":159}],91:[function(require,module,exports){
module.exports = "<form id=\"task-form\" class=\"form-inline\" action=\"/api/task\">\n\n  <section id=\"section-1\" class=\"current\">\n    <div class=\"form-group fullwidth\">\n      <label for=\"task-title\">\n        What problem are you trying to solve?\n      </label>\n      <div class=\"row\">\n        <div class=\"col-md-12\">\n          <input type=\"text\" id=\"task-title\" class=\"fullwidth form-control validate\" placeholder=\"A short description of the problem.\" data-validate=\"empty,count100\"/>\n          <span class=\"help-block error-empty\" style=\"display:none;\">You must enter a title for this <span data-i18n=\"task\">opportunity</span></span>\n          <span class=\"help-block error-count100\" style=\"display:none;\">The short description of the problem must be less than 100 characters.</span>\n        </div>\n      </div>\n    </div>\n  </section>\n\n  <section id=\"section-2\">\n    <div class=\"form-group fullwidth\">\n      <label for=\"people\">\n        We need\n      </label>\n      <select id=\"people\" class=\"dropdown\">\n        <% _.each(tags['task-people'], function (person) { %>\n          <option value=\"<%= person.id %>\"><%= person.name %></option>\n        <% }); %>\n      </select>\n\n      <label for=\"topics\">\n        to work on an <span data-i18n=\"task\">opportunity</span> about these topics:\n      </label>\n      <div class=\"row\">\n        <div class=\"col-md-12\">\n          <input type=\"hidden\" id=\"task_tag_topics\" class=\"fullwidth\" name=\"topic\" />\n        </div>\n      </div>\n    </div>\n\n    <hr/>\n\n    <div class=\"form-group fullwidth\">\n      <label for=\"skills-required\">\n        The following skills are useful and\n      </label>\n      <select id=\"skills-required\" name=\"skills-required\" class=\"dropdown\">\n        <% _.each(tags['task-skills-required'], function(requirement) { %>\n          <option value=\"<%= requirement.id %>\"><%= requirement.name %></option>\n        <% }); %>\n      </select>\n      <label for=\"skills\">\n        to complete this <span data-i18n=\"task\">opportunity</span>:\n      </label>\n      <div class=\"row\">\n        <div class=\"col-md-12\">\n          <input type=\"hidden\" id=\"task_tag_skills\" name=\"skills\" class=\"fullwidth\" />\n        </div>\n      </div>\n    </div>\n\n  </section>\n\n  <section id=\"section-3\">\n    <div class=\"form-group fullwidth\">\n      <label for=\"time-estimate\">\n        The <span data-i18n=\"task\">opportunity</span> will require\n      </label>\n      <select id=\"time-estimate\" class=\"dropdown\">\n        <% _.each(tags['task-time-estimate'], function (timeEstimate) { %>\n          <option value=\"<%= timeEstimate.id %>\"><%= timeEstimate.name %></option>\n        <% }); %>\n      </select>\n\n      <label for=\"time-required\">\n        of\n      </label>\n      <select id=\"time-required\" class=\"dropdown\">\n        <% _.each(tags['task-time-required'], function (time) { %>\n          <option value=\"<%= time.id %>\"><%= time.name %></option>\n        <% }); %>\n      </select>\n\n      <label for=\"length\">\n        work, and must be completed within\n      </label>\n      <select id=\"length\" class=\"dropdown\">\n        <% _.each(tags['task-length'], function (item) { %>\n          <option value=\"<%= item.id %>\"><%= item.name %></option>\n        <% }) %>\n      </select>\n    </div>\n\n    <hr/>\n\n    <div class=\"form-group fullwidth\">\n      <label for=\"task-location\">\n        The volunteer(s) must be located\n      </label>\n      <select id=\"task-location\" class=\"dropdown\">\n        <option value=\"false\">anywhere</option>\n        <option value=\"true\">at specific location(s)</option>\n      </select> to complete this task.\n\n      <div class=\"row el-specific-location\">\n        <div class=\"col-md-12\">\n          <div class=\"form-group task-skills fullwidth\">\n            <label for=\"location\">\n              The specific location(s) are:\n            </label>\n            <input type=\"hidden\" id=\"task_tag_location\" name=\"location\" class=\"fullwidth\"/>\n          </div>\n        </div>\n      </div>\n    </div>\n  </section>\n\n  <section id=\"section-4\">\n    <div class=\"form-group fullwidth\">\n      <label for=\"task-description\">\n        Describe the <span data-i18n=\"task\">opportunity</span> details, including goals, expected outcomes and deliverables.\n      </label>\n      <div class=\"row\">\n        <div class=\"col-md-12\">\n          <div class=\"markdown-edit\"></div>\n          <span class=\"help-block error-empty\" style=\"display:none;\">You must enter a description for this <span data-i18n=\"task\">opportunity</span></span>\n        </div>\n      </div>\n    </div>\n  </section>\n\n</form>\n";

},{}],92:[function(require,module,exports){
var Bootstrap = require('bootstrap');
var _ = require('underscore');
var Backbone = require('backbone');
var async = require('async');
var utilities = require('../../../../mixins/utilities');
var MarkdownEditor = require('../../../../components/markdown_editor');
var TasksCollection = require('../../../../entities/tasks/tasks_collection');
var TaskFormTemplate = require('../templates/task_form_template.html');
var TagFactory = require('../../../../components/tag_factory');


var TaskFormView = Backbone.View.extend({

  el: "#task-list-wrapper",

  events: {
    "change .validate"        : "v",
    "change #task-location" : "locationChange"
  },

  initialize: function (options) {
    this.options = _.extend(options, this.defaults);
    this.tasks = this.options.tasks;
    this.tagFactory = new TagFactory();
    this.data = {};
    this.data.newTag = {};
    this.data.newItemTags = [];
    this.data.existingTags = [];
    this.initializeSelect2Data();
    this.initializeListeners();
  },

  initializeSelect2Data: function () {
    var self = this;
    var types = ["task-skills-required", "task-time-required", "task-people", "task-length", "task-time-estimate"];

    this.tagSources = {};

    var requestAllTagsByType = function (type) {
      $.ajax({
        url: '/api/ac/tag?type=' + type + '&list',
        type: 'GET',
        async: false,
        success: function (data) {
          self.tagSources[type] = data;
        }
      });
    }

    async.each(types, requestAllTagsByType, function (err) {
      self.render();
    });
  },

  initializeListeners: function() {
    var self = this;

    _.extend(this, Backbone.Events);

    self.on('newTagSaveDone',function (){

      tags         = [];
      var tempTags = [];

      //get newly created tags from big three types
      _.each(self.data.newItemTags, function(newItemTag){
        tags.push(newItemTag);
      });

      tempTags.push.apply(tempTags,self.$("#task_tag_topics").select2('data'));
      tempTags.push.apply(tempTags,self.$("#task_tag_skills").select2('data'));
      if (self.$("#task-location").select2('data').id == 'true') {
        tempTags.push.apply(tempTags,self.$("#task_tag_location").select2('data'));
      }

      //see if there are any previously created big three tags and add them to the tag array
      _.each(tempTags,function(tempTag){
          if ( tempTag.id !== tempTag.name ){
          tags.push(tempTag);
        }
      });

      _.each(this.data.existingTags, function(tempTag) {
          tags.push(tempTag);
      });

      async.forEach(
        tags,
        function(tag, callback){
          //diffAdd,self.model.attributes.id,"taskId",callback
          return self.tagFactory.addTag(tag,self.tempTaskId,"taskId",callback);
        },
        function(err){
          self.model.trigger("task:modal:hide");
          self.model.trigger("task:tags:save:success", err);
        }
      );
    });

    this.listenTo(this.tasks,"task:save:success", function (taskId){
      //the only concern here is to add newly created tags which is only available in the three items below
      //

      self.tempTaskId = taskId;

      // save the tags from the drop downs
      this.data.existingTags.push(self.$("#skills-required").select2('data'));
      this.data.existingTags.push(self.$("#people").select2('data'));
      this.data.existingTags.push(self.$("#time-required").select2('data'));
      this.data.existingTags.push(self.$("#time-estimate").select2('data'));
      this.data.existingTags.push(self.$("#length").select2('data'));

      var newTags = [];

      newTags = newTags.concat(self.$("#task_tag_topics").select2('data'),self.$("#task_tag_skills").select2('data'),self.$("#task_tag_location").select2('data'));

      async.forEach(
        newTags,
        function(newTag, callback) {
          return self.tagFactory.addTagEntities(newTag,self,callback);
        },
        function(err) {
          if (err) return next(err);
          self.trigger("newTagSaveDone");
        }
      );

    });
  },

  getTagsFromPage: function () {

    // Gather tags for submission after the task is created
    tags = {
      topic: this.$("#task_tag_topics").select2('data'),
      skill: this.$("#task_tagskills").select2('data'),
      location: this.$("#task_tag_location").select2('data'),
      'task-skills-required': [ this.$("#skills-required").select2('data') ],
      'task-people': [ this.$("#people").select2('data') ],
      'task-time-required': [ this.$("#time-required").select2('data') ],
      'task-time-estimate': [ this.$("#time-estimate").select2('data') ],
      'task-length': [ this.$("#length").select2('data') ]
    };

    return tags;
  },

  render: function () {
    var template = _.template(TaskFormTemplate)({ tags: this.tagSources })
    this.$el.html(template);
    this.initializeSelect2();
    this.initializeTextArea();

    // Important: Hide all non-currently opened sections of wizard.
    this.$("section:not(.current)").hide();
    this.$el.i18n();

    // Return this for chaining.
    return this;
  },

  v: function (e) {
    return validate(e);
  },

  childNext: function (e, current) {
    // find all the validation elements
    var children = current.find('.validate');
    var abort = false;
    _.each(children, function (child) {
      var iAbort = validate({ currentTarget: child });
      abort = abort || iAbort;
    });
    return abort;
  },

  initializeSelect2: function () {
    var self = this;

    self.tagFactory.createTagDropDown({type:"skill",selector:"#task_tag_skills",width: "100%",tokenSeparators: [","]});
    self.tagFactory.createTagDropDown({type:"topic",selector:"#task_tag_topics",width: "100%",tokenSeparators: [","]});
    self.tagFactory.createTagDropDown({type:"location",selector:"#task_tag_location",width: "100%",tokenSeparators: [","]});

    self.$(".el-specific-location").hide();

    // ------------------------------ //
    // PRE-DEFINED SELECT MENUS BELOW //
    // ------------------------------ //
    self.$("#skills-required").select2({
      placeholder: "Required/Not Required",
      width: 'resolve'
    });

    self.$("#time-required").select2({
      placeholder: 'Time Commitment',
      width: 'resolve'
    });

    self.$("#people").select2({
      placeholder: 'Personnel Needed',
      width: 'resolve'
    });

    self.$("#length").select2({
      placeholder: 'Deadline',
      width: 'resolve'
    });

    self.$("#time-estimate").select2({
      placeholder: 'Estimated Time Required',
      width: 'resolve'
    });

    self.$("#task-location").select2({
      placeholder: 'Work Location',
      width: 'resolve'
    });

  },

  initializeTextArea: function () {
    if (this.md) { this.md.cleanup(); }
    this.md = new MarkdownEditor({
      data: '',
      el: ".markdown-edit",
      id: 'task-description',
      placeholder: 'Description of ' + i18n.t('task') + ' including goals, expected outcomes and deliverables.',
      title: i18n.t('Task') + ' Description',
      rows: 6,
      validate: ['empty']
    }).render();
  },

  locationChange: function (e) {
    if (_.isEqual(e.currentTarget.value, "true")) {
      this.$(".el-specific-location").show();
    } else {
      this.$(".el-specific-location").hide();
    }
  },

  cleanup: function () {
    if (this.md) { this.md.cleanup(); }
    removeView(this);
  }

});

module.exports = TaskFormView;

},{"../../../../components/markdown_editor":104,"../../../../components/tag_factory":112,"../../../../entities/tasks/tasks_collection":125,"../../../../mixins/utilities":128,"../templates/task_form_template.html":91,"async":131,"backbone":133,"bootstrap":138,"underscore":159}],93:[function(require,module,exports){
var Bootstrap = require('bootstrap');
var _ = require('underscore');
var Backbone = require('backbone');
var Popovers = require('../../../../mixins/popovers');
var utils = require('../../../../mixins/utilities');
var BaseView = require('../../../../base/base_view');
var CommentListController = require('../../../comments/list/controllers/comment_list_controller');
var AttachmentView = require('../../../attachment/views/attachment_show_view');
var TaskItemView = require('../views/task_item_view');
var TagShowView = require('../../../tag/show/views/tag_show_view');
var ModalComponent = require('../../../../components/modal');
var ModalAlert = require('../../../../components/modal_alert');
var TaskEditFormView = require('../../edit/views/task_edit_form_view');
var UIConfig = require('../../../../config/ui.json');
var VolunteerSupervisorNotifyTemplate = require('../templates/volunteer_supervisor_notify_template.html');
var VolunteerTextTemplate = require('../templates/volunteer_text_template.html');
var ChangeStateTemplate = require('../templates/change_state_template.html');
var UpdateNameTemplate = require('../templates/update_name_template.html');


var popovers = new Popovers();

var TaskShowController = BaseView.extend({

  el: "#container",

  events: {
    'change .validate'                : 'v',
    'keyup .validate'                 : 'v',
    'click #task-edit'                : 'edit',
    'click #task-view'                : 'view',
    "click #like-button"              : 'like',
    'click #volunteer'                : 'volunteer',
    'click #volunteered'              : 'volunteered',
    "click #task-close"               : "stateChange",
    "click #task-reopen"              : "stateReopen",
    "click .link-backbone"            : linkBackbone,
    "click .delete-volunteer"         : 'removeVolunteer',
    "mouseenter .project-people-div"  : popovers.popoverPeopleOn,
    "click .project-people-div"       : popovers.popoverClick
  },

  initialize: function (options) {
    this.options = options;

    this.initializeTaskItemView();
    this.initializeChildren();

    //load user settings so they are available as needed
    this.getUserSettings(window.cache.currentUser);

  },

  initializeEdit: function () {
    var model = this.model.toJSON();
    // check if the user owns the task
    var owner = model.isOwner;
    if (owner !== true) {
      // if they don't own the task, do they own the project?
      if (!_.isUndefined(model.project)) {
        if (model.project.isOwner === true) {
          owner = true;
        }
      }
      // if none of these apply, are they an admin?
      if (window.cache.currentUser) {
        if (window.cache.currentUser.isAdmin === true) {
          owner = true;
        }
      }
    }
    // if not the owner, trigger the login dialog.
    if (owner !== true) {
      window.cache.userEvents.trigger("user:request:login", {
        message: "You are not the owner of this opportunity. <a class='link-backbone' href='/tasks/" + model.id + "'>View the opportunity instead.</a>",
        disableClose: true
      });
      return;
    }

    if (this.taskEditFormView) this.taskEditFormView.cleanup();
    this.taskEditFormView = new TaskEditFormView({
      el: '.edit-task-section',
      elVolunteer: '#task-volunteers',
      edit: true,
      taskId: this.model.attributes.id,
      model: this.model,
      tags: this.tags,
      madlibTags: this.madlibTags,
      tagTypes: this.tagTypes
    }).render();
    this.$(".task-show-madlib").hide();
    this.$(".li-task-view").show();
    this.$(".li-task-edit").hide();
    this.$(".task-view").hide();
  },

  initializeChildren: function () {
    var self = this;

    this.listenTo(this.model, 'task:show:render:done', function () {
      self.initializeHandlers();
      self.initializeLikes();

      if (window.cache.currentUser) {
        self.initializeVolunteers();
      }

      if (self.options.action == 'edit') {
        self.initializeEdit();
        popovers.popoverPeopleInit(".project-people-div");
      } else {
        popovers.popoverPeopleInit(".project-people-div");
        if (self.commentListController) self.commentListController.cleanup();
        self.commentListController = new CommentListController({
          target: 'task',
          id: self.model.attributes.id
        });
        if (self.attachmentView) self.attachmentView.cleanup();
        self.attachmentView = new AttachmentView({
          target: 'task',
          id: this.model.attributes.id,
          owner: this.model.attributes.isOwner,
          el: '.attachment-wrapper'
        }).render();
      }

      if (self.tagView) self.tagView.cleanup();
      self.tagView = new TagShowView({
        model: self.model,
        el: '.tag-wrapper',
        target: 'task',
        targetId: 'taskId',
        edit: false,
        url: '/api/tag/findAllByTaskId/'
      }).render();

    });
  },

  initializeLikes: function () {
    $("#like-number").text(this.model.attributes.likeCount);
    if (parseInt(this.model.attributes.likeCount) === 1) {
      $("#like-text").text($("#like-text").data('singular'));
    } else {
      $("#like-text").text($("#like-text").data('plural'));
    }
    if (this.model.attributes.like) {
      $("#like-button-icon").removeClass('fa fa-star-o');
      $("#like-button-icon").addClass('fa fa-star');
    }
  },

  initializeVolunteers: function () {
    if (this.model.attributes.volunteer) {
      $('.volunteer-true').show();
      $('.volunteer-false').hide();
    } else {
      $('.volunteer-true').hide();
      $('.volunteer-false').show();
    }
  },

  initializeHandlers: function() {
    this.listenTo(this.model, "task:update:state:success", function (data) {
      if (data.attributes.state == 'closed') {
        $("#li-task-close").hide();
        $("#li-task-reopen").show();
        $("#alert-closed").show();
      } else {
        $("#li-task-close").show();
        $("#li-task-reopen").hide();
        $("#alert-closed").hide();
      }
    });
  },
  initializeTaskItemView: function () {
    var self = this;
    // Get the tag type info from the view so we don't have to refetch
    this.listenTo(this.model, 'task:tag:types', function (data) {
      self.tagTypes = data;
    });
    this.listenTo(this.model, 'task:tag:data', function (tags, madlibTags) {
      self.tags = tags;
      self.madlibTags = madlibTags;
    });
    if (this.taskItemView) this.taskItemView.cleanup();
    this.taskItemView = new TaskItemView({
      model: this.options.model,
      router: this.options.router,
      id: this.options.id,
      el: this.el
    });
  },

  v: function (e) {
    return validate(e);
  },

  edit: function (e) {
    if (e.preventDefault) e.preventDefault();
    this.initializeEdit();
    popovers.popoverPeopleInit(".project-people-div");
    Backbone.history.navigate('tasks/' + this.model.id + '/edit');
  },

  view: function (e) {
    if (e.preventDefault) e.preventDefault();
    Backbone.history.navigate('tasks/' + this.model.id, { trigger: true });
  },

  like: function (e) {
    if (e.preventDefault) e.preventDefault();
    var self = this;
    var child = $(e.currentTarget).children("#like-button-icon");
    var likenumber = $("#like-number");
    // Not yet liked, initiate like
    if (child.hasClass('fa-star-o')) {
      child.removeClass('fa-star-o');
      child.addClass('fa-star');
      likenumber.text(parseInt(likenumber.text()) + 1);
      if (parseInt(likenumber.text()) === 1) {
        $("#like-text").text($("#like-text").data('singular'));
      } else {
        $("#like-text").text($("#like-text").data('plural'));
      }
      $.ajax({
        url: '/api/like/liket/' + this.model.attributes.id
      }).done( function (data) {
        // liked!
        // response should be the like object
        // console.log(data.id);
      });
    }
    // Liked, initiate unlike
    else {
      child.removeClass('fa-star');
      child.addClass('fa-star-empty');
      likenumber.text(parseInt(likenumber.text()) - 1);
      if (parseInt(likenumber.text()) === 1) {
        $("#like-text").text($("#like-text").data('singular'));
      } else {
        $("#like-text").text($("#like-text").data('plural'));
      }
      $.ajax({
        url: '/api/like/unliket/' + this.model.attributes.id
      }).done( function (data) {
        // un-liked!
        // response should be null (empty)
      });
    }
  },
  getUserSettings: function (userId) {
    //does this belong somewhere else?
    if ( _.isNull(userId) ){ return null; }
    $.ajax({
      url: '/api/usersetting/'+userId.id,
      type: 'GET',
      dataType: 'json'
    })
    .success(function(data){
      _.each(data,function(setting){
        //save active settings to the current user object
        if ( setting.isActive ){
          window.cache.currentUser[setting.key]=setting;
        }
      });
    });
  },

  deleteUserSettingByKey: function(settingKey) {
    //this function expects the entire row from usersetting in the form
    //     window.cache.currentUser[settingKey] = {}
    var self = this;

    //if not set skip
    var targetId =  ( window.cache.currentUser[settingKey] ) ? window.cache.currentUser[settingKey].id : null ;

    if ( targetId ){
      $.ajax({
        url: '/api/usersetting/'+targetId,
        type: 'DELETE',
        dataType: 'json'
      })
    }

  },

  saveUserSettingByKey: function(userId, options) {
    //this function expects the entire row from usersetting in the form
    //     window.cache.currentUser[settingKey] = {}
    var self = this;

    //are values the same, stop
    if ( options.newValue == options.oldValue ) { return true; }

    //if delete old is set, delete exisitng value
    //   default is delete
    if ( !options.deleteOld ){
      self.deleteUserSettingByKey(options.settingKey);
    }

    $.ajax({
        url: '/api/usersetting/',
        type: 'POST',
        dataType: 'json',
        data: {
          userId: userId,
          key: options.settingKey,
          value: options.newValue
        }
      });
  },

  volunteer: function (e) {
    if (e.preventDefault) e.preventDefault();
    if (!window.cache.currentUser) {
      window.cache.userEvents.trigger("user:request:login");
    } else {
      var self = this;
      var child = $(e.currentTarget).children("#like-button-icon");
      var originalEvent = e;

      if (this.modalAlert) { this.modalAlert.cleanup(); }
      if (this.modalComponent) { this.modalComponent.cleanup(); }

      // If user's profile has no name, ask them to enter one
      if (!window.cache.currentUser.name) {
        var modalContent = _.template(UpdateNameTemplate)({});
        this.modalComponent = new ModalComponent({
          el: "#modal-volunteer",
          id: "update-name",
          modalTitle: "What's your name?"
        }).render();
        this.modalAlert = new ModalAlert({
          el: "#update-name .modal-template",
          modalDiv: '#update-name',
          content: modalContent,
          validateBeforeSubmit: true,
          cancel: i18n.t('volunteerModal.cancel'),
          submit: i18n.t('volunteerModal.ok'),
          callback: function(e) {
            var name = $('#update-name-field').val();
            $.ajax({
              url: '/api/user/' + window.cache.currentUser.id,
              method: 'PUT',
              data: { name: name }
            }).done(function(user) {
              window.cache.currentUser.name = user.name;
              self.volunteer(originalEvent);
            });
          }
        }).render();
        return;
      }

      this.modalComponent = new ModalComponent({
        el: "#modal-volunteer",
        id: "check-volunteer",
        modalTitle: i18n.t("volunteerModal.title")
      }).render();

      if ( UIConfig.supervisorEmail.useSupervisorEmail ) {
        //not assigning as null because null injected into the modalContent var shows as a literal value
        //    when what we want is nothing if value is null
        var supervisorEmail = ( window.cache.currentUser.supervisorEmail ) ? window.cache.currentUser.supervisorEmail.value  : "";
        var supervisorName = ( window.cache.currentUser.supervisorName ) ? window.cache.currentUser.supervisorName.value : "";
        var validateBeforeSubmit = true;
        var modalContent = _.template(VolunteerSupervisorNotifyTemplate)({supervisorEmail: supervisorEmail,supervisorName: supervisorName});
      } else {
        validateBeforeSubmit = false;
        var modalContent = _.template(VolunteerTextTemplate)({});
      }

      this.modalAlert = new ModalAlert({
        el: "#check-volunteer .modal-template",
        modalDiv: '#check-volunteer',
        content: modalContent,
        cancel: i18n.t('volunteerModal.cancel'),
        submit: i18n.t('volunteerModal.ok'),
        validateBeforeSubmit: validateBeforeSubmit,
        callback: function (e) {
          if ( UIConfig.supervisorEmail.useSupervisorEmail ) {
            self.saveUserSettingByKey(window.cache.currentUser.id,{settingKey:"supervisorEmail",newValue: $('#userSuperVisorEmail').val(),oldValue: supervisorEmail});
            self.saveUserSettingByKey(window.cache.currentUser.id,{settingKey:"supervisorName",newValue: $('#userSuperVisorName').val(),oldValue: supervisorName});
          }
          // user clicked the submit button
          $.ajax({
            url: '/api/volunteer/',
            type: 'POST',
            data: {
              taskId: self.model.attributes.id
            }
          }).done( function (data) {
            $('.volunteer-true').show();
            $('.volunteer-false').hide();
            var html = '<div class="project-people-div" data-userid="' + data.userId + '" data-voluserid="' + data.userId + '"><img src="/api/user/photo/' + data.userId + '" class="project-people"/>';
            if (self.options.action === "edit") {
              html += '<a href="#" class="delete-volunteer volunteer-delete fa fa-times"  id="delete-volunteer-' + data.id + '" data-uid="' + data.userId + '" data-vid="' +  data.id + '"></a>';
            }
            html += '</div>';
            $('#task-volunteers').append(html);
            popovers.popoverPeopleInit(".project-people-div");
          });
        }
      }).render();
    }
  },

  volunteered: function (e) {
    if (e.preventDefault) e.preventDefault();
    // Not able to un-volunteer, so do nothing
  },

  removeVolunteer: function(e) {
    if (e.stopPropagation()) e.stopPropagation();
    if (e.preventDefault) e.preventDefault();
    $(e.currentTarget).off("mouseenter");
    $('.popover').remove();

    var vId = $(e.currentTarget).data('vid');
    var uId = $(e.currentTarget).data('uid');
    var self = this;

    if (typeof cache !== "undefined")
    {
      $.ajax({
        url: '/api/volunteer/' + vId,
        type: 'DELETE',
      }).done(function (data) {
          // done();
      });
    }

    var oldVols = this.model.attributes.volunteers || [];
    var unchangedVols = _.filter(oldVols, function(vol){ return ( vol.id !== vId ); } , this)  || [];
    this.model.attributes.volunteers = unchangedVols;
    $('[data-voluserid="' + uId + '"]').remove();
    if (window.cache.currentUser.id === uId) {
      $('.volunteer-false').show();
      $('.volunteer-true').hide();
    }
  },

  stateChange: function (e) {
    if (e.preventDefault) e.preventDefault();
    var self = this;

    if (this.modalAlert) { this.modalAlert.cleanup(); }
    if (this.modalComponent) { this.modalComponent.cleanup(); }
    var states = UIConfig.states;
    if (draftAdminOnly && !window.cache.currentUser.isAdmin) {
      states = _(states).reject(function(state) {
        return state.value === 'draft';
      });
    }

    var modalContent = _.template(ChangeStateTemplate)({model:self.model,states: states});
    this.modalComponent = new ModalComponent({
      el: "#modal-close",
      id: "check-close",
      modalTitle: "Change "+i18n.t("Task")+" State"
    }).render();

    this.modalAlert = new ModalAlert({
      el: "#check-close .modal-template",
      modalDiv: '#check-close',
      content: modalContent,
      cancel: 'Cancel',
      submit: 'Change '+i18n.t("Task")+' State',
      callback: function (e) {
        // user clicked the submit button
        self.model.trigger("task:update:state", $('input[name=opportunityState]:checked').val());
      }
    }).render();
  },

  stateReopen: function (e) {
    if (e.preventDefault) e.preventDefault();
    this.model.trigger("task:update:state", 'open');
  },

  cleanup: function () {
    if (this.taskEditFormView) this.taskEditFormView.cleanup();
    if (this.tagView) { this.tagView.cleanup(); }
    if (this.attachmentView) { this.attachmentView.cleanup(); }
    if (this.commentListController) { this.commentListController.cleanup(); }
    if (this.taskItemView) { this.taskItemView.cleanup(); }
    removeView(this);
  }

});

module.exports = TaskShowController;

},{"../../../../base/base_view":102,"../../../../components/modal":106,"../../../../components/modal_alert":107,"../../../../config/ui.json":116,"../../../../mixins/popovers":126,"../../../../mixins/utilities":128,"../../../attachment/views/attachment_show_view":23,"../../../comments/list/controllers/comment_list_controller":33,"../../../tag/show/views/tag_show_view":84,"../../edit/views/task_edit_form_view":87,"../templates/change_state_template.html":94,"../templates/update_name_template.html":96,"../templates/volunteer_supervisor_notify_template.html":97,"../templates/volunteer_text_template.html":98,"../views/task_item_view":99,"backbone":133,"bootstrap":138,"underscore":159}],94:[function(require,module,exports){
module.exports = "<div class=\"form-group\">\n\t<p>Please select the new state for the opportunity. The current state is checked and the available states are:\n\t\t<ul style='list-style-type:none'>\n\t\t\t<% _.each(states, function (t) { %>\n\t\t\t\t<li><input type='radio' name='opportunityState' value='<%- t.value %>'\n\t\t\t\t\t<% if ( t.value == model.attributes.state ) {%>\n\t\t\t\t\t\t<%- checked=\"checked\" %>\n\t\t\t\t\t<% } %>\n\t\t\t\t\t\t> <%- t.label %> </li>\n\t\t\t\t\t<% }); %>\n\t\t</ul>\n\t</p>\n</div>\n";

},{}],95:[function(require,module,exports){
module.exports = "<!-- ALERTS -->\n<div class=\"alert alert-danger\" id=\"alert-closed\" style=\"<% if (model.state != 'closed') { %>display: none;<% } %>\">This <span data-i18n=\"task\">opportunity</span> is <strong>closed</strong>.  It is no longer active, and no more modifications may be made.</div>\n\n<div class=\"row\">\n\n  <div class=\"col-md-push-4 col-sm-push-4 col-sm-8 col-md-8 md-nopadding-right\">\n    <div class=\"row\">\n      <div class=\"col-md-9 sm-nopadding md-nopadding\">\n        <div class=\"box box-main\">\n\n          <div class=\"main-section\">\n            <div class=\"edit-task-section\">\n\n              <h1><%- model.title %></h1>\n              <% if (!_.isUndefined(model.project) && ui.project.show) { %>\n              <div class=\"task-project\">\n                <a href=\"/projects/<%- model.projectId %>\" class=\"link-backbone\">\n                  <i class=\"fa fa-folder-o\"></i>\n                  <%- model.project.title %>\n                </a>\n              </div>\n              <% } %>\n\n              <div class=\"task-show-description\">\n                <%= model.descriptionHtml %>\n              </div>\n\n              <div class=\"task-show-creation\">\n                <span data-i18n=\"Task\">Opportunity</span> created <time class=\"timeago\" datetime=\"<%- model.createdAt %>\"><%- model.createdAt %></time>\n                <% if (model.createdAt != model.updatedAt) { %>\n                and updated <time class=\"timeago\" datetime=\"<%- model.updatedAt %>\"><%- model.updatedAt %></time>\n                <% } %>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n      <div class=\"col-md-3 padding-left-none sm-nopadding md-nopadding\">\n        <div class=\"box padding-none\">\n\n          <div class=\"navbar-side like-row border-bottom\">\n            <% if (user) { %>\n            <a href=\"#\" id=\"like-button\" class=\"like-button\">\n            <% } else { %>\n            <span class=\"like-button\">\n            <% } %>\n              <i id=\"like-button-icon\" class=\"fa fa-star-o fa-lg gold\"></i>\n            <% if (user) { %>\n            </a>\n            <% } else { %>\n            </span>\n            <% } %>\n            <span class=\"like-number\" id=\"like-number\"><%- model.likeCount %></span>\n            <span class=\"like-plural\" id=\"like-text\" data-plural=\"likes\" data-singular=\"like\">likes</span>\n          </div>\n          <div class=\"navbar-side border-bottom\">\n            <ul class=\"nav nav-pills nav-stacked\">\n              <li>\n                <a href=\"#\" id=\"email\"><i class=\"fa fa-envelope-o\"></i> <span class=\"box-icon-text\">Share</span></a>\n              </li>\n            </ul>\n          </div>\n          <% if (model.isOwner || (user && user.isAdmin)) { %>\n          <div class=\"navbar-side <% if (user) { %>border-bottom<% } %>\">\n            <div id=\"modal-close\"></div>\n            <ul class=\"nav nav-pills nav-stacked\">\n              <li class=\"li-task-edit\">\n                <a href=\"#\" id=\"task-edit\"><i class=\"fa fa-pencil\"></i> <span class=\"box-icon-text\">Edit <span data-i18n=\"Task\">Opportunity</span></span></a>\n              </li>\n              <li class=\"li-task-view\" style=\"display: none;\">\n                <a href=\"#\" id=\"task-view\"><i class=\"fa fa-pencil\"></i> <span class=\"box-icon-text\">View <span data-i18n=\"Task\">Opportunity</span></span></a>\n              </li>\n              <% if (!draftAdminOnly || model.state !== 'draft' || (user && user.isAdmin)) { %>\n              <li id=\"li-task-close\" style=\"<% if (model.state == 'closed') { %>display: none;<% } %>\">\n                <a href=\"#\" id=\"task-close\"><i class=\"fa fa-times-circle\"></i> <span class=\"box-icon-text\">Change <span data-i18n=\"Task\">Opportunity</span> State</span></a>\n              </li>\n              <% } else {%>\n                <li><span class=\"no-link\">This draft <span data-i18n=\"task\">opportunity</span> is awaiting approval from an administrator.</span></li>\n              <% } %>\n              <li id=\"li-task-reopen\" style=\"<% if (model.state != 'closed') { %>display: none;<% } %>\">\n                <a href=\"#\" id=\"task-reopen\"><i class=\"fa fa-share\"></i> <span class=\"box-icon-text\">Reopen</span></a>\n              </li>\n              <!--\n              <li>\n                <a href=\"#\" id=\"task-delete\"><i class=\"fa fa-trash-o\"></i> <span class=\"box-icon-text\">Delete <span data-i18n=\"Task\">Opportunity</span></span></a>\n              </li>\n              -->\n            </ul>\n          </div>\n          <% } %>\n          <div class=\"navbar-side border-bottom\" <% if (!vol) {%>style=\"display: none;\"<%}%>>\n            <div id=\"modal-volunteer\"></div>\n            <ul class=\"nav nav-pills nav-stacked\">\n              <li class=\"volunteer-true\" style=\"display: none;\">\n                <a href=\"#\" id=\"volunteered\" class=\"btn btn-c1\"><i class=\"fa fa-thumbs-up\"></i> <span class=\"box-icon-text\" data-i18n=\"taskPage.volunteeredButton\">Volunteered!</span></a>\n\n              </li>\n              <li class=\"volunteer-false\">\n                <a href=\"#\" id=\"volunteer\" class=\"btn btn-c2\"><i class=\"fa fa-thumbs-o-up\"></i> <span class=\"box-icon-text\" data-i18n=\"taskPage.volunteerButton\">Volunteer</span></a>\n              </li>\n            </ul>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"col-md-12 sm-nopadding md-nopadding\">\n        <div class=\"box box-main task-view\">\n          <div id=\"task-show-madlib-description\" class=\"task-show-description\">\n            We need\n              <strong>\n                <% if (madlibTags['task-people']) { %>\n                  <%= madlibTags['task-people'][0].name %>\n                <% } else { %>\n                  'no people yet assigned'\n                <% } %>\n              </strong>\n\n            <% if (madlibTags.topic) { %>\n            to work on an <span data-i18n=\"task\">opportunity</span> about:\n              <strong>\n                    <% _.each(madlibTags.topic, function (t, i) { %>\n                    <% if (i > 0) { %>\n                    ,\n                    <% } %>\n                    <%= t.name %>\n                    <% }) %>\n              </strong>.\n            <% } %>\n\n            <br />\n\n            The following skills are useful and\n              <strong>\n                <% if (madlibTags['task-skills-required']) { %>\n                  <%= madlibTags['task-skills-required'][0].name %>\n                <% } else { %>\n                  not required\n                <% } %>\n              </strong>\n\n            to complete this <span data-i18n=\"task\">opportunity</span>:\n              <strong>\n                <% if (madlibTags.skill) { %>\n                  <% _.each(madlibTags.skill, function (s, i) { %>\n                  <% if (i > 0) { %>\n                  ,\n                  <% } %>\n                  <%= s.name %>\n                  <% }) %>\n                <% } else { %>\n                  no special skills required\n                <% } %>\n              </strong>.\n\n\n            The <span data-i18n=\"task\">opportunity</span> will require\n              <strong>\n                <% if (madlibTags['task-time-estimate']) { %>\n                  <%= madlibTags['task-time-estimate'][0].name %>\n                <% } else { %>\n                  an unspecified amount of time\n                <% } %>\n              </strong>\n\n            of\n              <strong>\n                <% if (madlibTags['task-time-required']) { %>\n                  <%= madlibTags['task-time-required'][0].name %>\n                <% } else { %>\n                  unstructured\n                <% } %>\n              </strong>\n\n            work, and\n            <% if (madlibTags['task-length']) { %>\n            must be completed within\n              <strong>\n                <%= madlibTags['task-length'][0].name %></strong>.\n            <% } else { %>\n              <strong>\n                has no deadline.\n              </strong>\n            <% } %>\n\n            <% if (madlibTags.location) { %>\n            The participant(s) must be located at\n            <strong>\n              <% _.each(madlibTags.location, function (s, i) { %>\n              <% if (i > 0) { %>\n              ,\n              <% } %>\n              <%= s.name %>\n              <% }) %>\n            </strong>\n            to complete this <span data-i18n=\"task\">opportunity</span>.\n            <% } else { %>\n            The participant(s) can be located anywhere.\n            <% } %>\n            </strong>\n\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"col-md-12 sm-nopadding md-nopadding\">\n        <div class=\"box task-both\">\n          <div class=\"box-pad-lr border-bottom\">\n            <h2>Requestor and Participants\n            </h2>\n          </div>\n          <div class=\"box-main\" id=\"task-volunteers\">\n            <div class=\"project-people-div\" data-userid=\"<%= model.userId %>\">\n              <img src=\"/api/user/photo/<%= model.userId %>\" class=\"project-people\" alt=\"<%= model.owner.name %>\"/>\n            </div>\n            <div class=\"project-people-space\">\n              <div class=\"bar\">\n              </div>\n            </div>\n            <% _.each(model.volunteers, function (v) { %>\n            <div class=\"project-people-div\" data-userid=\"<%= v.userId %>\" data-voluserid=\"<%= v.userId %>\">\n              <img src=\"/api/user/photo/<%= v.userId %>\" class=\"project-people\" alt=\"<%= v.name %>\"/>\n            </div>\n            <% }); %>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"col-md-12 task-view sm-nopadding md-nopadding\">\n\n        <div class=\"box comment-list-wrapper\" style=\"clear: both;\">\n          <div class=\"box-pad-lr border-bottom\">\n            <h2>Discussion\n            <% if (user) { %>\n            <button class=\"btn btn-c0 btn-sm file-add new-topic\" id=\"project-topic-new\">New Topic</button>\n            <% } %>\n            </h2>\n          </div>\n          <div class=\"\">\n            <div class=\"box-pad-lr box-pad-t topic-form-wrapper\"></div>\n            <ul id=\"comment-list-null\">\n            </ul>\n          </div>\n        </div>\n      </div>\n    </div>\n\n  </div>\n\n  <div class=\"col-md-pull-8 col-sm-pull-8 col-sm-4 col-md-4 project-sidebar md-nopadding-right\">\n    <!-- LEFT SIDEBAR -->\n    <div class=\"row\">\n      <div class=\"col-md-12 box sm-nopadding\">\n        <div class=\"box-main tag-wrapper\">\n        </div>\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"col-md-12 box task-view sm-nopadding\">\n        <div class=\"attachment-wrapper\">\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n";

},{}],96:[function(require,module,exports){
module.exports = "<p>In order to introduce you as part of the sign up process, we would like to fill in your profile. Please enter your name:</p>\n<div class=\"form-group\">\n  <input type=\"text\" class=\"form-control validate\" id=\"update-name-field\" name=\"update-name-field\" placeholder=\"Full Name\" data-validate=\"empty\">\n  <span class=\"help-block error-empty\" style=\"display:none;\">Please enter your full name.</span>\n</div>\n";

},{}],97:[function(require,module,exports){
module.exports = "<div class=\"form-group\">\n\t<p>Thank you for volunteering. Please be sure you have the availability and expertise to support this opportunity to completion. We will notify your supervisor of your interest in this project so that he or she is aware that you plan to include this work during your regularly scheduled work week to support Department colleagues and projects. Kudos to you!</p>\n\t<p>Please enter  the name and email address of your supervisor below. If you’ve previously volunteered, the last supervisor email you provided is shown. Please update it if necessary.</p>\n\t<span class=\"form-group\">\n\t\t<input type=\"text\" id=\"userSuperVisorName\" placeholder=\"Supervisor Name\" class=\"validate\" data-validate=\"empty\" value=\"<%= supervisorName %>\"/>\n\t\t<input type=\"text\" id=\"userSuperVisorEmail\" placeholder=\"Supervisor email address\" class=\"validate\" data-validate=\"empty,email,emaildomain\" data-emaildomain=\"state.gov\" value=\"<%= supervisorEmail %>\"/>\n\t\t<span class=\"help-block error-email error-empty error-emaildomain\" style=\"display:none;\">You must enter a name and a valid State Department email address to proceed.</span>\n\t</span>\n</div>\n";

},{}],98:[function(require,module,exports){
module.exports = "<p data-i18n=\"volunteerModal.notifySupervisor\">I understand it is my responsibility to confirm supervisor approval prior to committing to an opportunity.</p>\n<p data-i18n=\"volunteerModal.cantCancel\">Once you volunteer for an opportunity, you will not be able to cancel your commitment to volunteer.</p>\n";

},{}],99:[function(require,module,exports){
var Bootstrap = require('bootstrap');
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var UIConfig = require('../../../../config/ui.json');
var async = require('async');
var marked = require('marked');
var TimeAgo = require('../../../../../vendor/jquery.timeago');
var BaseView = require('../../../../base/base_view');
var TaskShowTemplate = require('../templates/task_show_item_template.html');


var TaskItemView = BaseView.extend({

  initialize: function (options) {
    var self = this;
    this.options = options;
    this.model.trigger("task:model:fetch", options.id);
    this.listenTo(this.model, "task:model:fetch:success", function (model) {
      self.model = model;
      self.initializeTags(self);
    });
  },

  getTagData: function (self, cb) {
    $.ajax({
      url: '/api/tag/findAllByTaskId/' + self.options.id,
      async: false,
      success: function (data) {
        self.tags = [];
        for (var i = 0; i < data.length; i += 1) {
          self.tags.push(data[i]);
        }
        // Build object for render
        self.data = {
          user: window.cache.currentUser,
          model: self.model.toJSON(),
          tags: self.tags
        };
        self.data['madlibTags'] = organizeTags(self.tags);
        // convert description from markdown to html
        self.data.model.descriptionHtml = marked(self.data.model.description);
        self.model.trigger('task:tag:data', self.tags, self.data['madlibTags']);
        return cb();
      }
    });

  },

  render: function (self) {
    self.getTagData(self, function () {
      var d = self.data,
          vol = ((!d.user || d.user.id !== d.model.userId) && d.model.state !== 'draft');
      self.data.ui = UIConfig;
      self.data.vol = vol;
      var compiledTemplate = _.template(TaskShowTemplate)(self.data);
      self.$el.html(compiledTemplate);
      self.$el.i18n();
      $("time.timeago").timeago();
      self.updateTaskEmail();
      self.model.trigger('task:show:render:done');
    });
  },

  updateTaskEmail: function() {
    var self = this;
    $.ajax({
      url: encodeURI('/api/email/makeURL?email=contactUserAboutTask&subject=Check Out "'+ self.model.attributes.title + '"' +
      '&opportunityTitle=' + self.model.attributes.title +
      '&opportunityLink=' + window.location.protocol + "//" + window.location.host + "" + window.location.pathname +
      '&opportunityDescription=' + (self.model.attributes.description || '') +
      '&opportunityMadlibs=' + $('<div />', { html: self.$('#task-show-madlib-description').html() }).text().replace(/\s+/g, " ")),
      type: 'GET'
    }).done( function (data) {
      self.$('#email').attr('href', data);
    });

  },

  initializeTags: function (self) {
    var types = ["task-skills-required", "task-time-required", "task-people", "task-length", "task-time-estimate"];

    self.tagSources = {};

    var requestAllTagsByType = function (type, cb) {
      $.ajax({
        url: '/api/ac/tag?type=' + type + '&list',
        type: 'GET',
        async: false,
        success: function (data) {
          // Dynamically create an associative
          // array based on that for the pointer to the list itself to be iterated through
          // on the front-end.
          self.tagSources[type] = data;
          return cb();
        }
      });
    }

    async.each(types, requestAllTagsByType, function (err) {
      self.model.trigger('task:tag:types', self.tagSources);
      self.render(self);
    });
  },

  cleanup: function() {
    removeView(this);
  }
});

module.exports = TaskItemView;

},{"../../../../../vendor/jquery.timeago":130,"../../../../base/base_view":102,"../../../../config/ui.json":116,"../../../../mixins/utilities":128,"../templates/task_show_item_template.html":95,"async":131,"backbone":133,"bootstrap":138,"marked":155,"underscore":159}],100:[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');


	BaseComponent = Backbone.View.extend({

		initialize: function () {}

	});

	module.exports = BaseComponent;

},{"backbone":133,"underscore":159}],101:[function(require,module,exports){
// Base Controller


var _ = require('underscore');
var Backbone = require('backbone');


	BaseController = Backbone.View.extend({
		
		initialize: function () {},

		// ------------
		//= Class Methods available for other views 
		// ------------

		initializeViewSafely: function (viewName) {
			if (this.view) {
				this.view.initialize();
			} else {
				this.view = new viewName();
			}
		},

		cleanup: function () {
			$(this).remove();
		}

	});

	module.exports = BaseController;


},{"backbone":133,"underscore":159}],102:[function(require,module,exports){
// This class implements a paradigm wherein it renders its own child class.
// Doing this allows us to perform logic against it.

// NOTES:
// 'this' refers to the prototype class, not the constructor (logical this).
// This is very useful for smaller el regions, such as a task list
// or anything that requires a small spinner.  Currently to add a bigger spinner
// I'd have to exchange the gif currently provided by font-awesome.


var _ = require('underscore');
var Backbone = require('backbone');
var utilities = require('../mixins/utilities');


var BaseView = Backbone.View.extend({

  initialize: function () {
  },

  cleanup: function () {
    removeView(this);
  }

});

module.exports = BaseView;

},{"../mixins/utilities":128,"backbone":133,"underscore":159}],103:[function(require,module,exports){
module.exports = "<div class=\"alert <% if (alert.type) { %><%= alert.type %><% } else { %>alert-danger<% } %>\" id=\"alert-main\">\n  <% if (alert.dismiss) { %>\n  <button type=\"button\" class=\"close\" data-dismiss=\"alert\" aria-hidden=\"true\">&times;</button>\n  <% } %>\n  <%= alert.message %>\n</div>\n";

},{}],104:[function(require,module,exports){
/**
 * This component implements a Markdown TextEditor that can be
 * dropped into anywhere on an existing form.
 * Initialize the MarkdownEditor with an element `el`,
 * and the `id` of the textarea (so you can retreive its
 * value when the user submits the form.)
 *
 * Options:
 *   el: HTML element to fill - required
 *   id: HTML ID for the <textarea> element - required
 *   data: Default data for the textarea - required
 *   placeholder: Textarea placeholder value - optional
 *   maxlength: Maximum characters for the text area - optional
 *   rows: Number of rows in the textarea - optional
 *   validate: List of strings for the data-validate attribute - optional
 *     example: ['empty', 'count400']
 */

var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../mixins/utilities');
var marked = require('marked');
var BaseComponent = require('../base/base_component');
var jqSelection = require('../../vendor/jquery.selection');
var EditorTemplate = require('./markdown_editor_template.html');


MarkdownEditor = BaseComponent.extend({

  events: {
    "click .btn"                 : "clickButton"
  },

  initialize: function (options) {
    this.options = options;
    this.actions = {
      'bold': {
        before: '**',
        text: 'text',
        after: '**'
      },
      'italic': {
        before: '_',
        text: 'text',
        after: '_'
      },
      'strikethrough': {
        before: '~~',
        text: 'text',
        after: '~~'
      },
      'code': {
        before: '`',
        text: 'code',
        after: '`'
      },
      'link': {
        before: '[Link Title](',
        text: 'http://',
        after: ')'
      }
    }
    return this;
  },

  render: function () {
    var data = {
      id: this.options.id,
      validate: this.options.validate,
      rows: this.options.rows,
      maxlength: this.options.maxlength,
      placeholder: this.options.placeholder,
      title: this.options.title,
      data: this.options.data
    };
    var template = _.template(EditorTemplate)(data);
    this.$el.html(template);
    return this;
  },

  clickButton: function (e) {
    var self = this;
    if (e.preventDefault) e.preventDefault();
    var t = $(e.currentTarget);
    var selText = this.$("#" + this.options.id).selection();
    var editData = t.data('edit');
    if ((editData != 'preview') &&
        (editData != 'edit') &&
        (editData != 'help')) {
      // get the current selected positions
      var pos = this.$("#" + this.options.id).selection('getPos');
      var text = this.$("#" + this.options.id).val();
      // check if this modifier has already been inserted
      var origBefore = text.substring(pos.start-this.actions[editData].before.length,pos.start);
      var origAfter = text.substring(pos.end,pos.end+this.actions[editData].after.length);
      var before = this.actions[editData].before;
      var after = this.actions[editData].after;
      // If the selected text already has the markdown syntax before and after
      // don't insert it again.  Eg, if text is selected in **text**, don't add ** again
      if ((origBefore == before) && (origAfter == after)) {
        before = '';
        after = '';
      }
      // set placeholder text if no text is selected by the user
      if (selText == '') {
        selText = this.actions[editData].text;
      }
      // insert markdown syntax
      this.$("#" + this.options.id).selection('insert', {
        text: before,
        mode: 'before'
      })
      .selection('replace', {
        text: selText
      })
      .selection('insert', {
        text: after,
        mode: 'after'
      });
    } else if (editData == 'help') {
      // show help text and links to markdown syntax
      if (this.$('.help').is(':visible')) {
        this.$('.help').hide();
        t.removeClass('active');
      } else {
        this.$('.help').show();
        t.addClass('active');
      }
    } else {
      if (this.$('.preview').is(':visible')) {
        // if we're in preview mode, switch back to edit mode
        this.$('.btn-edit').hide();
        this.$('.btn-preview').show();
        this.$('.preview').hide();
        this.$("#" + this.options.id).show();
      } else {
        // render the preview using marked
        var html = marked(this.$("#" + this.options.id).val());
        this.$('.btn-preview').hide();
        this.$('.btn-edit').show();
        this.$('.preview').html(html);
        this.$("#" + this.options.id).hide();
        this.$('.preview').show();
      }
    }
  },

  cleanup: function () {
    removeView(this);
  }

});

module.exports = MarkdownEditor;

},{"../../vendor/jquery.selection":129,"../base/base_component":100,"../mixins/utilities":128,"./markdown_editor_template.html":105,"backbone":133,"marked":155,"underscore":159}],105:[function(require,module,exports){
module.exports = "<div class=\"btn-toolbar\" role=\"toolbar\">\n  <div class=\"btn-group btn-group-sm\">\n    <button type=\"button\" class=\"btn btn-c0\" data-edit=\"bold\" title=\"Bold\"><i class=\"fa fa-bold\" alt=\"Bold\"></i></button>\n    <button type=\"button\" class=\"btn btn-c0\" data-edit=\"italic\" title=\"Italic\"><i class=\"fa fa-italic\" alt=\"Italic\"></i></button>\n    <button type=\"button\" class=\"btn btn-c0\" data-edit=\"strikethrough\" title=\"Strikethrough\"><i class=\"fa fa-strikethrough\" alt=\"Strikethrough\"></i></button>\n    <button type=\"button\" class=\"btn btn-c0\" data-edit=\"code\" title=\"Code\"><i class=\"fa fa-code\" alt=\"Code\"></i></button>\n  </div>\n  <div class=\"btn-group btn-group-sm\">\n    <button type=\"button\" class=\"btn btn-c0\" data-edit=\"link\" title=\"Link\"><i class=\"fa fa-link\" alt=\"Link\"></i></button>\n  </div>\n  <div class=\"btn-group btn-group-sm\">\n    <button type=\"button\" class=\"btn btn-c0\" data-edit=\"help\"><i class=\"fa fa-question-circle\" alt=\"Help\"></i> Help</button>\n  </div>\n\n  <div class=\"btn-group btn-group-sm\">\n    <button type=\"button\" class=\"btn btn-c1 btn-preview\" data-edit=\"preview\"><i class=\"fa fa-eye\" alt=\"Open\"></i> Preview</button>\n  </div>\n  <div class=\"btn-group btn-group-sm\">\n    <button type=\"button\" class=\"btn btn-c1 btn-edit\" data-edit=\"edit\" style=\"display: none;\"><i class=\"fa fa-pencil\" alt=\"Edit\"></i> Edit</button>\n  </div>\n</div>\n<div class=\"help\">\n  You can use any <a href=\"http://daringfireball.net/projects/markdown/syntax\" target=\"_blank\">Markdown</a> or <a href=\"https://help.github.com/articles/github-flavored-markdown\" target=\"_blank\">GitHub Flavored Markdown</a> syntax in this text box.\n</div>\n<textarea\n  <%if (!_.isUndefined(maxlength)) { %>maxlength=\"<%= maxlength %>\"<% } %>\n  <% if (!_.isUndefined(rows)) { %>rows=\"<%= rows %>\"<% } %>\n  class=\"form-control validate\"\n  id=\"<%= id %>\"\n  data-validate=\"<% if (!_.isUndefined(validate)) { %><%= validate.join(',') %><% } %>\"\n  <% if (!_.isUndefined(placeholder)) { %>placeholder=\"<%= placeholder %>\"<% } %>\n  <% if (!_.isUndefined(title)) { %>title=\"<%= title %>\"<% } %>\n  ><%= data %></textarea>\n<div class=\"preview\" style=\"display: none;\"></div>\n";

},{}],106:[function(require,module,exports){
/**
 * The Modal component needs to be set to the el: of the parent view
 * you are trying to init it within, then you will be appending the modal-template to that
 * view (this).  Then the form view has an el of $(".modal-body") so that the form will render
 * within that body area.
 * Then all you have to do is set the ID of the modal to the ID of the link you are trying
 * to trigger from as per bootstrap BP.
 */

var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../mixins/utilities');
var BaseComponent = require('../base/base_component');
var ModalTemplate = require('./modal_template.html');


Modal = BaseComponent.extend({

  events: {
    "click .link-backbone"  : "link"
  },

  initialize: function (options) {
    this.options = options;
  },

  render: function () {
    var data = {
      id: this.options.id,
      modalTitle: this.options.modalTitle,
      disableClose: this.options.disableClose
    };

    var compiledTemplate = _.template(ModalTemplate)(data);
    this.$el.append(compiledTemplate);

    return this;
  },

  link: function (e) {
    if (e.preventDefault) e.preventDefault();
    // hide the modal, wait for it to close, then navigate
    $('#' + this.options.id).bind('hidden.bs.modal', function() {
      linkBackbone(e);
    }).modal('hide');
  },

  cleanup: function () {
    removeView(this);
  }

});

module.exports = Modal;

},{"../base/base_component":100,"../mixins/utilities":128,"./modal_template.html":109,"backbone":133,"underscore":159}],107:[function(require,module,exports){
var Bootstrap = require('bootstrap');
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../mixins/utilities');
var ModalTemplate = require('./modal_alert_template.html');


var ModalAlert = Backbone.View.extend({

  events: {
    "submit #modal-form"    : "post"
  },

  initialize: function (options) {
    this.options = options;
  },

  render: function () {
    var template = _.template(ModalTemplate)(this.options);
    this.$el.html(template);
    this.$el.i18n();
    $(this.options.modalDiv).modal('show');
    return this;
  },

  post: function (e) {
    var self = this;
    var hasError = false;

    if (e.preventDefault) e.preventDefault();

    //check any .validate elements and don't submit if they fail
    if ( self.options.validateBeforeSubmit ){
      $(".validate").each(function(index){
        hasError = validate({currentTarget: this});
        if ( hasError ){ return false; }
      });
    }

    if ( !hasError ) {
      $(this.options.modalDiv).bind('hidden.bs.modal', function() {
        self.options.callback(e);
      }).modal('hide');
    }
  },

  cleanup: function () {
    removeView(this);
  }

});

module.exports = ModalAlert;

},{"../mixins/utilities":128,"./modal_alert_template.html":108,"backbone":133,"bootstrap":138,"underscore":159}],108:[function(require,module,exports){
module.exports = "<form role=\"form\" action=\"\" id=\"modal-form\">\n  <div class=\"modal-body\">\n    <%= content %>\n  </div>\n  <div class=\"modal-footer\">\n    <button type=\"button\" class=\"btn btn-c0\" data-dismiss=\"modal\"><%= cancel %></button>\n    <input type=\"submit\" class=\"btn btn-c2\" id=\"submit\" value=\"<%= submit %>\"/>\n  </div>\n</form>\n";

},{}],109:[function(require,module,exports){
module.exports = "<div class=\"modal fade\"\n  id=\"<%- id %>\"\n  role=\"dialog\"\n  aria-hidden=\"true\"\n  tabindex=\"-1\"\n  <% if (disableClose === true) { %>\n  data-backdrop=\"static\"\n  data-keyboard=\"false\"\n  <% } %>\n  >\n  <div class=\"modal-dialog\">\n    <div class=\"modal-content\">\n      <div class=\"modal-header\">\n        <% if (disableClose !== true) { %>\n        <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-hidden=\"true\">&times;</button>\n        <% } %>\n        <h4 class=\"modal-title\"><%- modalTitle %></h4>\n      </div>\n\n      <div class=\"modal-template\">\n\n      </div>\n    </div><!-- /.modal-content -->\n  </div><!-- /.modal-dialog -->\n</div><!-- /.modal -->\n";

},{}],110:[function(require,module,exports){
// Similar to Modal component in every way in all ways but two:
// 1) This modal has a next button instead of save button.
// 2) This modal has some expectations inside the modal-body form.
//    ^ More on this below
//
// This is all the component expects for it to work:
// <div class='modal-body'>
//  <section class="current">First content section</section>
//  <section>Second content section</section>
//  <section>Third content section</section>
//  <!-- and so on -->
// </div>
//
// REMEMBER: This goes inside your formTemplate.  This
// is the ModalWizardComponent, which is scoped to list controller,
// then the Form itself for the addition to the list is scoped to the
// modal-body within this modal-component template.

var _ = require('underscore');
var Backbone = require('backbone');
var utilities = require('../mixins/utilities');
var BaseView = require('../base/base_view');
var ModalWizardTemplate = require('./modal_wizard_template.html');


ModalWizard = BaseView.extend({

  events: {
    "click .wizard-forward" : "moveWizardForward",
    "click .wizard-backward": "moveWizardBackward",
    "click .wizard-submit"  : "submit",
    "click .wizard-cancel"  : "cancel"
  },

  initialize: function (options) {
    this.options = options;
    this.initializeListeners();
  },

  initializeListeners: function () {
    var self = this;
    if (this.model) {
      this.listenTo(this.model, this.options.modelName + ':modal:hide', function () {
        $('.modal.in').modal('hide');
      });
    }
  },

  render: function () {
    var data = {
      id: this.options.id,
      modalTitle: this.options.modalTitle,
      draft: this.options.draft
    };
    var compiledTemplate = _.template(ModalWizardTemplate)(data);
    this.$el.html(compiledTemplate);
    return this;
  },

  /**
   * Set the child of this view, so we can remove it
   * when the view is destroyed
   * @return this for chaining
   */
  setChildView: function (view) {
    this.childView = view;
    return this;
  },

  /**
   * Set the callback on the next button of the modal.
   * Useful for callbacks
   * @return this for chaining
   */
  setNext: function (fn) {
    this.childNext = fn;
    return this;
  },

  /**
   * Set the callback on the submit button of the modal.
   * Useful for callbacks
   * @return this for chaining
   */
  setSubmit: function (fn) {
    this.childSubmit = fn;
    return this;
  },

  // In order for the ModalWizard to work it expects a section
  // by section layout inside the modal, with a 'current' class on
  // the first you want to always start on (re)render.
  moveWizardForward: function (e) {
    if (e.preventDefault) e.preventDefault();
    var self = this;

    // Store $(".current") in cache to reduce query times for DOM lookup
    // on future children and adjacent element to the current el.
    var current   = $(".current"),
        next      = current.next(),
        nextHtml  = next.html();

    // Notify the sub-view to see if it is safe to proceed
    // if not, return and stop processing.
    var abort = false;
    if (this.childNext) {
      abort = this.childNext(e, current);
    }
    if (abort === true) {
      return;
    }

    var nextWizardStep = {
      exists: function () {
        return !_.isUndefined(next.next().html());
      },
      doesNotExist: function () {
        return _.isUndefined(next.next().html());
      }
    };

    hideCurrentAndInitializeNextWizardStep();
    if (nextWizardStep.doesNotExist()) {
      $("button.wizard-forward").hide();
      $("button.wizard-submit").show();
    }

    function hideCurrentAndInitializeNextWizardStep () {
      current.hide();
      current.removeClass("current");
      next.addClass("current");
      next.show();
    };
  },

  moveWizardBackward: function (e) {
    if (e.preventDefault) e.preventDefault();

    var current   = $(".current"),
        prev      = current.prev(),
        prevHtml  = prev.html();

    if (!_.isUndefined(prevHtml)) {
      current.hide();
      current.removeClass("current");
      prev.addClass("current");
      prev.show();
      $("button.wizard-forward").show();
      $("button.wizard-submit").hide();
    } else {
      return;
    }
  },

  // Dumb submit.  Everything is expected via a promise from
  // from the instantiation of this modal wizard.
  submit: function (e) {
    if (e.preventDefault) e.preventDefault();

    var d = this.options.data(this);
    var abort = false;
    var state = $(e.currentTarget).data('state');

    // pass the data to the view
    if (this.childSubmit) {
      // if submit returns true, abort modal processing
      abort = this.childSubmit(e, this.$(".current"));
    }

    if (abort === true) {
      return;
    }

    $('.modal.in').modal('hide');
    if (state) d.state = state;
    this.collection.trigger(this.options.modelName + ":save", d);
  },

  cancel: function (e) {
    if (e.preventDefault) e.preventDefault();
    $('.modal.in').modal('hide');
  },

  cleanup: function () {
    if (this.childView) { this.childView.cleanup(); }
    removeView(this);
  }
});

module.exports = ModalWizard;

},{"../base/base_view":102,"../mixins/utilities":128,"./modal_wizard_template.html":111,"backbone":133,"underscore":159}],111:[function(require,module,exports){
module.exports = "<div class=\"modal fade\" id=\"<%- id %>\" role=\"dialog\" aria-hidden=\"true\" tabindex=\"-1\">\n  <div class=\"modal-dialog\">\n    <div class=\"modal-content\">\n      <div class=\"modal-header\">\n        <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-hidden=\"true\">&times;</button>\n        <h4 class=\"modal-title\"><%- modalTitle %></h4>\n      </div>\n\n      <div class=\"modal-body\">\n\n      </div>\n\n      <div class=\"modal-footer\">\n        <button type=\"button\" class=\"btn btn-c0 wizard-cancel\" data-dismiss=\"modal\">Cancel</button>\n        <% if (draft) { %><button type=\"button\" class=\"btn btn-c0 wizard-submit\" data-state=\"draft\">Save Draft</button><% } %>\n        <button type=\"button\" class=\"btn btn-c2 wizard-backward\"><i class=\"fa fa-chevron-left\"></i> Back</button>\n        <button type=\"button\" class=\"btn btn-c2 wizard-forward\">Next <i class=\"fa fa-chevron-right\"></i></button>\n        <button type=\"button\" class=\"btn btn-c2 wizard-submit\" style=\"display: none;\">Create</button>\n      </div>\n\n    </div><!-- /.modal-content -->\n  </div><!-- /.modal-dialog -->\n</div>\n";

},{}],112:[function(require,module,exports){
/**
 * This component implements a tag widget, allowing creation lookup and deletion of tags from a common ui element
 *
 * Options:
 *
 */

var _ = require('underscore');
var Backbone = require('backbone');
var async = require('async');
var utils = require('../mixins/utilities');
var marked = require('marked');
var BaseComponent = require('../base/base_component');
var jqSelection = require('../../vendor/jquery.selection');


TagFactory = BaseComponent.extend({

	initialize: function (options) {
    this.options = options;

    return this;
  },

  addTagEntities: function (tag, context, done) {
  	//assumes
  	//  tag -- array of tag objects to add
  	//  tagType -- string specifying type for tagEntity table
    var self = this;

  	//this is current solution to mark a tag object as on the fly added
      if ( !tag || typeof tag.unmatched == 'undefined' || !tag.unmatched ){
        return done();
      }
    //remove the flag that marks them as new
    delete tag.unmatched;

    $.ajax({
      url: '/api/tagEntity',
      type: 'POST',
      data: {
        type: tag.tagType,
        name: tag.id,
        data: tag.data
      },
      success: function (data){
        if (context.data) {
          context.data.newTag = data;
          context.data.newItemTags.push(data);
        }
        return done(null, data);
      }
    });
  },

  removeTag: function (id, done) {
    $.ajax({
      url: '/api/tag/' + id,
      type: 'DELETE',
      success: function (data) {
        return done();
      }
    });
  },

  addTag: function (tag, modelId, modelType, done) {
  	//assumes
  	//  tag -- array of tag objects to add
  	//  --- NYI ---
  	//  project or task id - string
    // TODO: abstract the below if-else to a different function so this funciton just takes an array tag ids

    var tagMap = {};
    tagMap[modelType] = modelId;

    if ( _.isFinite(tag) ){
        // --- NYI ---
        // or project id

        tagMap.tagId = tag;
    } else {
        // --- NYI ---
        // or project id

        tagMap.tagId = tag.id;
    }

    $.ajax({
      url: '/api/tag',
      type: 'POST',
      data: tagMap,
      success: function (data) {
        return done();
      },
      error: function (err) {
        return done(err);
      }
    });

  },

  createTagDropDown: function(options) {
    var settings = {
          placeholder: "Start typing to select a "+options.type,
          minimumInputLength: 2,
          multiple: true,
          width: options.width || "500px",
          tokenSeparators: options.tokenSeparators || [],
          formatResult: function (obj, container, query) {
            return obj.name;
          },
          formatSelection: function (obj, container, query) {
            return obj.name;
          },
          createSearchChoice: function (term) {
            //unmatched = true is the flag for saving these "new" tags to tagEntity when the opp is saved
            return {
              unmatched: true,
              tagType: options.type,
              id: term,
              value: term,
              temp: true,
              name: "<b>"+term+"</b> <i>" + ((options.type !== 'location') ?
                "click to create a new tag with this value" :
                "search for this location") + "</i>"
            };
          },
          ajax: {
            url: '/api/ac/tag',
            dataType: 'json',
            data: function (term) {
              return {
                type: options.type,
                q: term
              };
            },
            results: function (data) {
              return { results: data }
            }
          }
        },
      $sel = self.$(options.selector);
    $sel.remote = true;
    $sel.select2(settings).on("select2-selecting", function (e) {
      if (e.choice.tagType === 'location') {
        var $el = self.$(e.currentTarget);
        if (e.choice.temp) {
          e.choice.name = '<em>Searching for <strong>' +
            e.choice.value + '</strong></em>';
          this.temp = true;
          $.get('/api/location/suggest?q=' + e.choice.value, function(d) {
            d = _(d).map(function(item) {
              return {
                id: item.name,
                name: item.name,
                unmatched: true,
                tagType: 'location',
                data: _(item).omit('name')
              };
            });
            var items = $sel.select2('data');
            this.cache = _.reject(items, function(item) {
              return (item.name.indexOf('<em>Searching for <strong>') >= 0);
            });
            $sel.select2({
              multiple: true,
              data: { results: d, text: 'name' }
            }).select2('data', this.cache).select2('open');
            $sel.remote = false;
          });
        } else {
          this.reload = true;
          delete this.temp;
        }
      } else {
        if ( e.choice.hasOwnProperty("unmatched") && e.choice.unmatched ){
          //remove the hint before adding it to the list
          e.choice.name = e.val;
        }
      }
    }).on('select2-blur', function(e) {
      if (!this.reload && this.temp) {
        this.reload = true;
        delete this.temp;
      }
    }).on('select2-open', function(e) {
      var el = this;
      if (this.reload) {
        this.cache = $sel.select2('data');
        setTimeout(function(){
          $sel.select2(settings).select2('data', el.cache).select2('open');
        }, 0);
        delete this.reload;
      }
    });
  },

  createDiff: function ( oldTags, currentTags){
    //sort tags into their needed actions
    //

    var out = {
      remove: [],
      add: [],
      none: []
    };

    var none = null;

    _.each(oldTags, function (oTag,oi){

      none = null;

      _.each(currentTags, function (cTag, ci){
          if (cTag && parseInt(cTag.id) == oTag.tagId ){
            currentTags.splice(ci,1);
            none = oi;
          }
        });

      if( _.isFinite(none) ){
        out.none.push(parseInt(oldTags[none].tagId));
      } else {
        out.remove.push(parseInt(oTag.id));
      }
    });

    out.add = currentTags;

    return out;
  }

});

module.exports = TagFactory;

},{"../../vendor/jquery.selection":129,"../base/base_component":100,"../mixins/utilities":128,"async":131,"backbone":133,"marked":155,"underscore":159}],113:[function(require,module,exports){
module.exports={
  "resGetPath"      : "/locales/__lng__/__ns__.json",

  "lng"             : "en-US",

  "fallbackLng"     : "en",

  "useLocalStorage" : false,

  "sendMissing"     : false,
  "sendMissingTo"   : "current"
}

},{}],114:[function(require,module,exports){
module.exports={
  "signin": true,
  "oauth": [
    "linkedin",
    "myusa"
  ],
  "config": {
    "linkedin": {
      "name": "LinkedIn",
      "image": "/images/login/linkedin.png",
      "endpoint": "/api/auth/oauth/linkedin",
      "params": {"scope": ["r_basicprofile", "r_fullprofile", "r_emailaddress", "r_network"]}
    },
    "myusa": {
      "name": "MyUSA",
      "image": "/images/login/myusa.png",
      "endpoint": "/api/auth/oauth/myusa",
      "params": { "scope": ["profile.email", "profile.first_name", "profile.last_name"] }
    }
  },
  "local": {
    "enabled": true,
    "expand": true,
    "logout": true
  },
  "terms": {
    "enabled": false,
    "name": "Terms and Conditions",
    "link": "https://18f.gsa.gov/"
  },
  "profile": {
    "edit": true,
    "editUrl": null
  }
}

},{}],115:[function(require,module,exports){
/**
 * This is a configuration file that defines the standard
 * tags for this installation.  The tags will be displayed
 * in the order of the array.
 */
module.exports = {
  // This defines all of the tag elements for use in the app
  tags: {
    'skill': {
      'icon': 'icon-atom',
      'class': 'skill',
      'id': 'skill',
      'type': 'skill',
      'name': 'Skill',
      'plural': 'Skills'
    },

    'topic': {
      'icon': 'fa fa-briefcase',
      'class': 'topic',
      'id': 'topic',
      'type': 'topic',
      'name': 'Topic',
      'plural': 'Topics'
    },

    'agency': {
      'icon': 'icon-library',
      'class': 'agency',
      'id': 'agency',
      'type': 'agency',
      'name': 'Agency',
      'plural': 'Agencies'
    },

    'location': {
      'icon': 'fa fa-map-marker',
      'class': 'location',
      'id': 'location',
      'type': 'location',
      'name': 'Work Location',
      'plural': 'Work Locations'
    },

    // ---
    // Task-specific tags
    // ---
    'task-skills-required': {
      'icon': 'fa fa-map-marker',
      'class': 'task-skills-required',
      'id': 'task-skills-required',
      'type': 'task-skills-required',
      'name': 'Skill Required',
      'plural': 'Skills Required'
    },

    'task-time-required': {
      'icon': 'fa fa-calendar-o',
      'class': 'task-time-required',
      'id': 'task-time-required',
      'type': 'task-time-required',
      'name': 'Time Commitment',
      'plural': 'Time Commitment'
    },

    'task-people': {
      'icon': 'fa fa-group',
      'class': 'task-people',
      'id': 'task-people',
      'type': 'task-people',
      'name': 'Personnel Needed',
      'plural': 'Personnel Needed'
    },

    'task-length': {
      'icon': 'fa fa-bullseye',
      'class': 'task-length',
      'id': 'task-length',
      'type': 'task-length',
      'name': 'Deadline',
      'plural': 'Deadline'
    },

    'task-time-estimate': {
      'icon': 'fa fa-cogs',
      'class': 'task-time-estimate',
      'id': 'task-time-estimate',
      'type': 'task-time-estimate',
      'name': 'Estimated Time Required',
      'plural': 'Estimated Time Required'
    }

  },

  // This defines the part of the app and which tags apply
  // plural names are for searching the collection
  // singular names are for the individual show views.
  project   : ['skill', 'topic', 'agency', 'location'],
  projects  : ['skill', 'topic', 'agency', 'location'],

  profile   : ['skill', 'topic'],
  profiles  : ['skill', 'topic', 'agency', 'location'],

  task      : ['skill', 'topic', 'location', 'task-people', 'task-time-estimate', 'task-time-required', 'task-length'],
  tasks     : ['skill', 'topic', 'agency', 'location', 'task-skills-required', 'task-time-required', 'task-people', 'task-length', 'task-time-estimate']
};

},{}],116:[function(require,module,exports){
module.exports={
  "project": {
    "show": true
  },
  "supervisorEmail": {
	  "useSupervisorEmail": false
  },
  "home": {
    "logged_in_path": "/projects"
  },
  "faq" : {
    "show" : false,
    "url"  : "/faq"
  },
  "systemEmail" : "test@midas.com",
  "browse": {
    "pageSize" : 27,
    "useInfiniteScroll" : false
  },
  "states" : [{"value": "draft","label":"Draft"},{"value": "open","label":"Open"},{"value":"assigned","label":"Assigned"},{"value": "completed","label":"Completed"},{"value":"archived","label":"Archived"}]
}

},{}],117:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var CommentModel = require('./comment_model');
var CommentListController = require('../../apps/comments/list/controllers/comment_list_controller');

'use strict';

var CommentCollection = Backbone.Collection.extend({

  urlRoot: '/api/comment',

  model: CommentModel,

  initialize: function () {
    var self = this;

    this.listenTo(this, "comment:save", function (data, currentTarget) {
      self.addAndSave(data, currentTarget);
    });

  },

  addAndSave: function (data, currentTarget) {
    var self = this, comment;

    comment = new CommentModel({
      parentId  : data['parentId'],
      value     : data['comment'],
      taskId    : data['taskId'],
      projectId : data['projectId'],
      topic     : data['topic']
    })

    self.add(comment);

    self.models.forEach(function (model) {
      if (model.attributes.value === data['comment']) {
        model.save(null, {
          success: function (modelInstance, response) {
            self.trigger("comment:save:success", modelInstance, response, currentTarget);
          }
        });
      }
    });

  }
});

module.exports = CommentCollection;

},{"../../apps/comments/list/controllers/comment_list_controller":33,"./comment_model":118,"backbone":133,"underscore":159}],118:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');


var CommentModel = Backbone.Model.extend({

  urlRoot: '/api/comment',

  initialize: function () {
    this.saveComment();
  },

  saveComment: function () {
    var self = this;

    this.listenTo(this, 'comment:save', function (parentId, comment, projectId) {
      self.save({
        parentId  : parentId,
        value     : comment,
        projectId : projectId
      }, {
        success: function (data) {
          self.trigger("comment:save:success");
        }
      })
    })
  }

});

module.exports = CommentModel;

},{"backbone":133,"underscore":159}],119:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');


var EventModel = Backbone.Model.extend({

  urlRoot: '/api/event'

});

module.exports = EventModel;

},{"backbone":133,"underscore":159}],120:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var EventModel = require('./event_model');


var EventCollection = Backbone.Collection.extend({
  
  model: EventModel,
  
  parse: function (response) {
    if (response) {
      return response.events;
    }
  },

  url: '/api/event',

  initialize: function () {
    this.addAndSave();
  },

  addAndSave: function () {
    var self = this;

    this.listenTo(this, "event:save", function (data) {

      self.ev = new EventModel({
        title       : data['title'], 
        description : data['description'], 
        start       : data['start'],
        end         : data['end'],
        location    : data['location'],
        projectId   : data['projectId'] 
      });

      self.add(self.event);

      self.ev.save({}, {
        success: function (modelInstance, response) {
          self.trigger("event:save:success", modelInstance, response);
        }
      });
    });
  }

});

module.exports = EventCollection;

},{"./event_model":119,"backbone":133,"underscore":159}],121:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');


	var ProfileModel = Backbone.Model.extend({

		urlRoot: '/api/user',

		initialize: function () {
			this.initializeProfileSave();
			this.initializeProfileGet();
		},

		parse: function(res, options) {
			// Remove falsy values (db returns null instead of undefined)
			_(res).each(function(v, k, o) { if (!v) delete o[k]; });
			return res;
		},

		initializeProfileGet: function () {
			var self = this;

			this.listenTo(this, "profile:fetch", function (id) {
				self.remoteGet(id);
			});
		},

  remoteGet: function (id) {
    var self = this;
    if (id) {
	      this.set({ id: id });
    }
    this.fetch({
      success: function (model, response, options) {
        self.trigger("profile:fetch:success", model);
      },
      error: function (model, response, options) {
        self.trigger("profile:fetch:error", model, response);
      }
    });
  },

		initializeProfileSave: function () {
			var _this = this;

			this.listenTo(this, "profile:updateWithPhotoId", function(file) {
				var _self = this;
				_this.save({
					photoId: file['id']
				}, {
				success: function (data) {
					_this.trigger("profile:updatedPhoto", data);
				},
				error: function (data) {
					// an error occurred
				}
				});
			});

			this.listenTo(this, "profile:save", function (form) {
				_this.save({
					name: form['name'],
					username: form['username'],
					title: form['title'],
					bio: form['bio']
				}, {
				success: function (data) {
					_this.trigger("profile:save:success", data);
				},
				error: function (data) {
					_this.trigger("profile:save:fail", data);
				}
				});
			});

			this.listenTo(this, "profile:removeAuth", function(id) {
				var auths = this.get("auths");
				auths.splice(auths.indexOf(id), 1);
				_this.save({
					auths: auths
				}, {
				success: function (data) {
					_this.trigger("profile:removeAuth:success", data, id);
				},
				error: function (data) {
					_this.trigger("profile:removeAuth:fail", data, id);
				}
				});
			});

		}

	});

	module.exports = ProfileModel;


},{"backbone":133,"underscore":159}],122:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');


var ProjectModel = Backbone.Model.extend({

  defaults: {
    title       : null,
    description : null,
    archived    : false
  },

  // Initialize contains only event bindings and if/then response
  // functions (class methods).
  initialize: function () {
    var self = this;

    this.listenTo(this, "project:model:fetch", function (id) {
      self.remoteGet(id);
    });

    this.listenTo(this, "project:model:update", function (data) {
      self.update(data);
    });

    this.listenTo(this, "project:update:photoId", function (file) {
      self.updatePhoto(file);
    });

    this.listenTo(this, "project:update:state", function (state) {
      self.updateState(state);
    });

    this.listenTo(this, "projectowner:show:changed", function (data) {
      self.updateOwners(data);
    });

    this.listenTo(this, "project:update:tasks:orphan", function (data) {
      self.orphan(data);
    });

  },

  urlRoot: '/api/project',

  remoteGet: function (id) {
    var self = this;
    this.set({ id: id });
    this.fetch({
      success: function (data) {
        self.trigger("project:model:fetch:success", data);
      }
    });
  },

  update: function (data) {
    var self = this;

    this.save({
      title: data['title'],
      description: data['description']
    }, { success: function (data) {
        self.trigger("project:save:success", data);
      }
    });
  },

  // TODO: Update this method and move it into the global update method.
  updatePhoto: function (file) {
    var self = this;

    this.save({
      coverId: file['id']
    }, {
      success: function (data) {
        self.trigger("project:updated:photo:success", data);
      }
    });
  },

  updateState: function (state) {
    var self = this;

    this.save({
      state: state
    }, {
      success: function(data) {
        self.trigger("project:update:state:success", data);
      }
    });
  },

  updateOwners: function (data) {
    var self = this;
    // console.log(data);
    this.save({
      owners: data
    }, {
      success: function(data) {
        self.trigger("project:update:owners:success", data);
      }
    });
  },

  hasOpenTasks: function(tasks){
    //takes a task collection object
    var hasOpenTasks = false;
    var self = this;
    var count = 0;

    _.each(tasks.models,function(task){
      if ( _.indexOf(['open','assigned'],task.attributes.state) != -1 ){
        hasOpenTasks = true;
        count++;
      }
    });

    return {hasOpenTasks:hasOpenTasks,count:count};
  },

  orphan: function(tasks) {
    //orphans associated tasks for a state change
    tasks.each(function(model){
      model.trigger("task:update:orphan",{});
    });
  }

});

module.exports = ProjectModel;

},{"backbone":133,"underscore":159}],123:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var ProjectModel = require('./project_model');


var ProjectsCollection = Backbone.Collection.extend({

  model: ProjectModel,

  url: '/api/project/findAll',

  parse: function (response) {
    return response.projects;
  },

  initialize: function () {
    var self = this;

    this.listenTo(this, "project:save", function (data) {
      self.addAndSave(data);
    });
  },

  addAndSave: function (data) {
    var project, self = this;

    project = new ProjectModel({
      title: data['title'],
      description: data['description']
    });

    project.save({}, {
      success: function (data) {
        self.add(project);
        self.trigger("project:save:success", data);
      }
    });
  }

});

module.exports = ProjectsCollection;

},{"./project_model":122,"backbone":133,"underscore":159}],124:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');

'use strict';

var TaskModel = Backbone.Model.extend({

  defaults: {
    name        : null,
    description : null
  },

  urlRoot: '/api/task',

  initialize: function () {
    this.listenTo(this, "task:save", function (data) {
      this.save(data);
    });

    this.listenTo(this, "task:model:fetch", function (data) {
      this.remoteGet(data);
    });

    this.listenTo(this, "task:update", function (data) {
      this.update(data);
    });

    this.listenTo(this, "task:update:state", function (state) {
      this.updateState(state);
    });

    this.listenTo(this, "task:update:orphan", function (data) {
      this.orphan(data);
    });
  },

  update: function (data) {
    var self = this;

    this.save(data, {
      success: function (data) {
        self.trigger("task:update:success", data);
      }
    });
  },

  updateState: function (state) {
    var self = this;

    this.save({
      state: state
    }, {
      success: function(data) {
        self.trigger("task:update:state:success", data);
      }
    });
  },

  orphan: function(data) {
    var self = this;

    this.save({
      projectId: null
    }, {
      success: function(data) {
        self.trigger("task:update:orphan:success", data);
      }
    });

  },

  remoteGet: function (id) {
    var self = this;
    this.set({ id: id });
    this.fetch({
      success: function (data) {
        self.trigger("task:model:fetch:success", data);
      }
    });
  },

});

  module.exports = TaskModel;


},{"backbone":133,"underscore":159}],125:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var TaskModel = require('./task_model');

'use strict';

var TasksCollection = Backbone.Collection.extend({

  model: TaskModel,

  parse: function (response) {
    if (response) {
      if (response.tasks) {
        return response.tasks;
      }
      return response;
    }
    return [];
  },

  url: '/api/task',

  initialize: function () {
    var self = this;

    this.listenTo(this, "task:save", function (data) {
      self.addAndSave(data);
    })
  },

  addAndSave: function (data) {
    var self = this;

    self.task = new TaskModel(data);

    self.task.save(null,{
      success: function (model) {
        self.trigger("task:save:success", self.task.id);
      }
    });
  }

});

module.exports = TasksCollection;


},{"./task_model":124,"backbone":133,"underscore":159}],126:[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');
var BaseComponent = require('../base/base_component');
var Bootstrap = require('bootstrap');
var utils = require('./utilities');
var PopoverProfile = require('./templates/popover_profile.html');


Popovers = BaseComponent.extend({

  popoverPeopleInit: function (target) {
    $(target).popover(
      {
        placement: 'auto top',
        trigger: 'manual',
        html: 'true',
        title: 'load',
        container: 'body',
        content: '<div class="popover-spinner"><div class="loading">Fetching Information</div><i class="fa fa-spinner fa-spin"></i></div>',
        template: '<div class="popover"><div class="arrow"></div><h3 class="popover-title" style="display:none; visibility:hidden"></h3><div class="popover-content"></div></div>'
      }).on("mouseleave", function () {
        var _this = this;
        var timeoutFn = function () {
          if (!$(".popover:hover").length) {
            $(_this).popover("hide");
          } else {
            setTimeout(timeoutFn, 100);
          }
        };
        setTimeout(timeoutFn, 100);
      });
  },

  popoverPeopleOn: function (e) {
    if (e.preventDefault) e.preventDefault();
    var target = $(e.currentTarget);
    var popover = target.data('bs.popover');
    // if the data element isn't set or popovers not init'd, abort
    if ((_.isUndefined(target.data('userid'))) || (_.isUndefined(popover))) {
      return;
    }
    target.popover('show');
    // Only load data if the popover hasn't previously been loaded
    if (popover.options.title == 'load') {
      $.ajax({ url: '/api/user/info/' + target.data('userid') }).done(function(data) {
        var template = _.template(PopoverProfile)({data: data});
        popover.options.title = 'done';
        popover.options.content = template;
        popover.setContent();
        popover.$tip.addClass(popover.options.placement);
        // handle links in the popovers
        $(".popover").on('click', ".link-backbone", function (e) {
          target.popover('hide');
          linkBackbone(e);
        });
      });
    }
  },

  popoverClick: function (e) {
    if (e.preventDefault) e.preventDefault();
    var id = $(e.currentTarget).data('userid');
    $(e.currentTarget).popover('hide');
    Backbone.history.navigate('profile/' + id, { trigger: true });
  }
});

module.exports = Popovers;

},{"../base/base_component":100,"./templates/popover_profile.html":127,"./utilities":128,"backbone":133,"bootstrap":138,"underscore":159}],127:[function(require,module,exports){
module.exports = "<div class=\"popover-table\">\n  <div class=\"popover-row\">\n    <div class=\"popover-cell-left\">\n      <img align=\"left\" src=\"/api/user/photo/<%- data.id %>\" class=\"popover-image\"/>\n    </div>\n    <div class=\"popover-cell-right popover-person\">\n      <div class=\"title\"><a class=\"link-backbone\" href=\"/profile/<%- data.id %>\"><%- data.name %></a></div>\n      <% if (data.title) { %><div class=\"text-line\"><i class=\"fa fa-briefcase\"></i> <%- data.title %></div><% } %>\n      <% if (data.agency) { %><div class=\"text-line\"><i class=\"fa fa-library\"></i> <%- data.agency.tag.name %></div><% } %>\n      <% if (data.location) { %><div class=\"text-line\"><span class=\"fa fa-map-marker\"></span> <%- data.location.tag.name %></div><% } %>\n    </div>\n  </div>\n</div>";

},{}],128:[function(require,module,exports){
(function (global){
// Input:
// @collection [ARRAY] Backbone collection.
// @modelId [INTEGER] Backbone Model.cid

// Return: [OBJECT] Model instance looked up from modelId within collection.
global.getCurrentModelFromId = function (collection, modelId) {
	var i = 0;
			id = parseInt(modelId)
			models = collection.models;

	for ( ; i < models.length; i += 1) {
		if (models[i].id === id) {
			return models[i];
		} else {
			continue;
		}
	}
}

// Input:
// @collection [ARRAY] Backbone collection.
// @attr [STRING] Value, to be found.

// Return: [OBJECT] Model instance that is corollary to the found @attr value.
global.getCurrentModelFromFormAttributes = function (collection, attr) {
	var	j,
			i = 0,
			attr = $.trim(attr),
			models = collection.models;

	// Loop through all the models
	for ( ; i < models.length; i += 1) {

		// Loop through all the attributes within the model
		for (j in models[i].attributes) {

			// If we find the model.attr[value] on the current models
			// attribute that we are looping over, then stop and return that
			// model back out to the front-end.
			if (models[i].attributes[j] === attr) {
				return models[i]
			} else {
				// Otherwise continue on.
				continue;
			}
		}
	}
}

/**
 * Completely remove a backbone view and all of its
 * references.  This is needed to destroy the view
 * and all of its listeners, in order to start
 * fresh again and render a new view with a new
 * model.
 *
 * Input:
 * @view the view to be removed, typically called with removeView(this);
 *
 * Return:
 * nothing
 */
global.removeView = function (view) {
  view.undelegateEvents();
  view.$el.html("");
}

/**
 * Clear out any el.
 * @params {[The non-jquery mapped el for the view instance]}
 * Return: Nothing.
 */
global.clearEl = function (el) {
  $(el).children().remove();
}

/**
 * Clear out our global container for full page transitions.
 * @params None
 * @return Nothing
 */
global.clearContainer = function () {
  $("#container").children().remove();
}

/**
 * This helps alleviate a common bug with ajax based
 * page transitions. That is sometimes when the page pushes itself off the screen
 * and allows a browser default background to show, after which scrolling
 * up is required.  It is a somewhat rare bug, but useful to have this function
 * if you need it.
 *
 * Return:
 * nothing
 */
global.scrollTop = function () {
  $(window).scrollTop($(window).scrollTop());
}

/**
 * Organize the tags output into an associative array key'd by their type.
 * If the tag has more than one value for said key, make it an array otherwise
 * keep it as a top level object.
 * @param  {[array]} tags           [array of tags]
 * @return {[object]}               [bindingObject returned out]
 */
global.organizeTags = function (tags) {
  var outTags = {};
  for (t in tags) {
    if (!(_.has(outTags, tags[t].tag.type))) {
      outTags[tags[t].tag.type] = [];
    }
    outTags[tags[t].tag.type].push(tags[t].tag);
  }
  return outTags;
}

/**
 * Validate an input field.  Assumes that there is a data
 * variable in the HTML tag called `data-validate` with the
 * validation options that you want to enforce.
 *
 * email is only meant to allow the value is generally email shaped
 *    it is not bullet proof
 *
 * emaildomain requires a data-emaildomain variable in the HTML tag
 *    it will validate against the value there
 *
 * The input should be in a `form-group` component,
 * and the component should have a .help-text element
 * with a class `.error-[code]` where [code] is the
 * validation rule (eg, `empty`);
 *
 * Expects an object with currentTarget, eg { currentTarget: '#foo' }
 */
global.validate = function (e) {
  var opts = String($(e.currentTarget).data('validate')).split(',');
  var val = $(e.currentTarget).val();
  var parent = $(e.currentTarget).parents('.form-group, .checkbox')[0];
  var result = false;
  _.each(opts, function (o) {
    if (o == 'empty') {
      if (!val) {
        $(parent).find('.error-empty').show();
        result = true;
      } else {
        $(parent).find('.error-empty').hide();
      }
      return;
    }
    if (o == 'checked') {
      if ($(e.currentTarget).prop('checked') !== true) {
        $(parent).find('.error-checked').show();
        result = true;
      } else {
        $(parent).find('.error-checked').hide();
      }
      return;
    }
    if (o.substring(0,5) == 'count') {
      var len = parseInt(o.substring(5));
      if (val.length > len) {
        $(parent).find('.error-' + o).show();
        result = true;
      } else {
        $(parent).find('.error-' + o).hide();
      }
      return;
    }
    if (o == 'confirm') {
      var id = $(e.currentTarget).attr('id');
      var newVal = $('#' + id + '-confirm').val();
      if (val != newVal) {
        $(parent).find('.error-' + o).show();
        result = true;
      } else {
        $(parent).find('.error-' + o).hide();
      }
      return;
    }
    if (o == 'button') {
      if (!($($(parent).find("#" + $(e.currentTarget).attr('id') + "-button")[0]).hasClass('btn-success'))) {
        $(parent).find('.error-' + o).show();
        result = true;
      } else {
        $(parent).find('.error-' + o).hide();
      }
    }
    if (o == 'email'){
      var correctLength = false;
      if ( val != "" && val.indexOf("@") >= 2 ){
        var bits = val.split("@");
        var addrBits = bits[1].split(".");
        if ( addrBits.length >=2 ) {
          for (i=0; i<addrBits.length; i++ ){
            if ( addrBits[i].length < 2 ){
              correctLength = false;
              break;
            } else {
              correctLength = true;
            }
          }
        }
      }
      if ( !correctLength || bits[0].length < 2 ) {
        $(parent).find('.error-email').show();
        result = true;
      } else {
        $(parent).find('.error-email').hide();
      }
      return;
    }
    if ( o== 'emaildomain'){
      var domain = $(e.currentTarget).data('emaildomain');
      if ( val != "" && val.indexOf("@") >= 2 ){
        var bits = val.split("@");
        if ( bits[1] != domain ){
          $(parent).find('.error-emaildomain').show();
          result = true;
        } else {
          $(parent).find('.error-emaildomain').hide();
        }
      }
      return;
    }
  });
  if (result === true) {
    $(parent).addClass('has-error');
  } else {
    $(parent).removeClass('has-error');
  }
  return result;
};

global.validatePassword = function (username, password) {
  var rules = {
    username: false,
    length: false,
    upper: false,
    lower: false,
    number: false,
    symbol: false
  };
  var _username = username.toLowerCase().trim();
  var _password = password.toLowerCase().trim();
  // check username is not the same as the password, in any case
  if (_username != _password && _username.split('@',1)[0] != _password) {
    rules['username'] = true;
  }
  // length > 8 characters
  if (password && password.length >= 8) {
    rules['length'] = true;
  }
  // Uppercase, Lowercase, and Numbers
  for (var i = 0; i < password.length; i++) {
    var test = password.charAt(i);
    // from http://stackoverflow.com/questions/3816905/checking-if-a-string-starts-with-a-lowercase-letter
    if (test === test.toLowerCase() && test !== test.toUpperCase()) {
      // lowercase found
      rules['lower'] = true;
    }
    else if (test === test.toUpperCase() && test !== test.toLowerCase()) {
      rules['upper'] = true;
    }
    // from http://stackoverflow.com/questions/18082/validate-numbers-in-javascript-isnumeric
    else if (!isNaN(parseFloat(test)) && isFinite(test)) {
      rules['number'] = true;
    }
  }
  // check for symbols
  if (/.*[^\w\s].*/.test(password)) {
    rules['symbol'] = true;
  }
  return rules;
};

/**
 * Helper function to navigate links within backbone
 * instead of reloading the whole page through a hard link.
 * Typically used with the `events: {}` handler of backbone
 * such as 'click .link-backbone' : linkBackbone
 * @param e the event fired by jquery/backbone
 */
global.linkBackbone = function (e) {
  // if meta or control is held, or if the middle mouse button is pressed,
  // let the link process normally.
  // eg: open a new tab or window based on the browser prefs
  if ((e.metaKey === true) || (e.ctrlKey === true) || (e.which == 2)) {
    return;
  }
  // otherwise contain the link within backbone
  if (e.preventDefault) e.preventDefault();
  var href = $(e.currentTarget).attr('href');
  Backbone.history.navigate(href, { trigger: true });
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],129:[function(require,module,exports){
/*!
 * jQuery.selection - jQuery Plugin
 *
 * Copyright (c) 2010-2014 IWASAKI Koji (@madapaja).
 * http://blog.madapaja.net/
 * Under The MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
(function($, win, doc) {
    /**
     * get caret status of the selection of the element
     *
     * @param   {Element}   element         target DOM element
     * @return  {Object}    return
     * @return  {String}    return.text     selected text
     * @return  {Number}    return.start    start position of the selection
     * @return  {Number}    return.end      end position of the selection
     */
    var _getCaretInfo = function(element){
        var res = {
            text: '',
            start: 0,
            end: 0
        };

        if (!element.value) {
            /* no value or empty string */
            return res;
        }

        try {
            if (win.getSelection) {
                /* except IE */
                res.start = element.selectionStart;
                res.end = element.selectionEnd;
                res.text = element.value.slice(res.start, res.end);
            } else if (doc.selection) {
                /* for IE */
                element.focus();

                var range = doc.selection.createRange(),
                    range2 = doc.body.createTextRange(),
                    tmpLength;

                res.text = range.text;

                try {
                    range2.moveToElementText(element);
                    range2.setEndPoint('StartToStart', range);
                } catch (e) {
                    range2 = element.createTextRange();
                    range2.setEndPoint('StartToStart', range);
                }

                res.start = element.value.length - range2.text.length;
                res.end = res.start + range.text.length;
            }
        } catch (e) {
            /* give up */
        }

        return res;
    };

    /**
     * caret operation for the element
     * @type {Object}
     */
    var _CaretOperation = {
        /**
         * get caret position
         *
         * @param   {Element}   element         target element
         * @return  {Object}    return
         * @return  {Number}    return.start    start position for the selection
         * @return  {Number}    return.end      end position for the selection
         */
        getPos: function(element) {
            var tmp = _getCaretInfo(element);
            return {start: tmp.start, end: tmp.end};
        },

        /**
         * set caret position
         *
         * @param   {Element}   element         target element
         * @param   {Object}    toRange         caret position
         * @param   {Number}    toRange.start   start position for the selection
         * @param   {Number}    toRange.end     end position for the selection
         * @param   {String}    caret           caret mode: any of the following: "keep" | "start" | "end"
         */
        setPos: function(element, toRange, caret) {
            caret = this._caretMode(caret);

            if (caret == 'start') {
                toRange.end = toRange.start;
            } else if (caret == 'end') {
                toRange.start = toRange.end;
            }

            element.focus();
            try {
                if (element.createTextRange) {
                    var range = element.createTextRange();

                    if (win.navigator.userAgent.toLowerCase().indexOf("msie") >= 0) {
                        toRange.start = element.value.substr(0, toRange.start).replace(/\r/g, '').length;
                        toRange.end = element.value.substr(0, toRange.end).replace(/\r/g, '').length;
                    }

                    range.collapse(true);
                    range.moveStart('character', toRange.start);
                    range.moveEnd('character', toRange.end - toRange.start);

                    range.select();
                } else if (element.setSelectionRange) {
                    element.setSelectionRange(toRange.start, toRange.end);
                }
            } catch (e) {
                /* give up */
            }
        },

        /**
         * get selected text
         *
         * @param   {Element}   element         target element
         * @return  {String}    return          selected text
         */
        getText: function(element) {
            return _getCaretInfo(element).text;
        },

        /**
         * get caret mode
         *
         * @param   {String}    caret           caret mode
         * @return  {String}    return          any of the following: "keep" | "start" | "end"
         */
        _caretMode: function(caret) {
            caret = caret || "keep";
            if (caret === false) {
                caret = 'end';
            }

            switch (caret) {
                case 'keep':
                case 'start':
                case 'end':
                    break;

                default:
                    caret = 'keep';
            }

            return caret;
        },

        /**
         * replace selected text
         *
         * @param   {Element}   element         target element
         * @param   {String}    text            replacement text
         * @param   {String}    caret           caret mode: any of the following: "keep" | "start" | "end"
         */
        replace: function(element, text, caret) {
            var tmp = _getCaretInfo(element),
                orig = element.value,
                pos = $(element).scrollTop(),
                range = {start: tmp.start, end: tmp.start + text.length};

            element.value = orig.substr(0, tmp.start) + text + orig.substr(tmp.end);

            $(element).scrollTop(pos);
            this.setPos(element, range, caret);
        },

        /**
         * insert before the selected text
         *
         * @param   {Element}   element         target element
         * @param   {String}    text            insertion text
         * @param   {String}    caret           caret mode: any of the following: "keep" | "start" | "end"
         */
        insertBefore: function(element, text, caret) {
            var tmp = _getCaretInfo(element),
                orig = element.value,
                pos = $(element).scrollTop(),
                range = {start: tmp.start + text.length, end: tmp.end + text.length};

            element.value = orig.substr(0, tmp.start) + text + orig.substr(tmp.start);

            $(element).scrollTop(pos);
            this.setPos(element, range, caret);
        },

        /**
         * insert after the selected text
         *
         * @param   {Element}   element         target element
         * @param   {String}    text            insertion text
         * @param   {String}    caret           caret mode: any of the following: "keep" | "start" | "end"
         */
        insertAfter: function(element, text, caret) {
            var tmp = _getCaretInfo(element),
                orig = element.value,
                pos = $(element).scrollTop(),
                range = {start: tmp.start, end: tmp.end};

            element.value = orig.substr(0, tmp.end) + text + orig.substr(tmp.end);

            $(element).scrollTop(pos);
            this.setPos(element, range, caret);
        }
    };

    /* add jQuery.selection */
    $.extend({
        /**
         * get selected text on the window
         *
         * @param   {String}    mode            selection mode: any of the following: "text" | "html"
         * @return  {String}    return
         */
        selection: function(mode) {
            var getText = ((mode || 'text').toLowerCase() == 'text');

            try {
                if (win.getSelection) {
                    if (getText) {
                        // get text
                        return win.getSelection().toString();
                    } else {
                        // get html
                        var sel = win.getSelection(), range;

                        if (sel.getRangeAt) {
                            range = sel.getRangeAt(0);
                        } else {
                            range = doc.createRange();
                            range.setStart(sel.anchorNode, sel.anchorOffset);
                            range.setEnd(sel.focusNode, sel.focusOffset);
                        }

                        return $('<div></div>').append(range.cloneContents()).html();
                    }
                } else if (doc.selection) {
                    if (getText) {
                        // get text
                        return doc.selection.createRange().text;
                    } else {
                        // get html
                        return doc.selection.createRange().htmlText;
                    }
                }
            } catch (e) {
                /* give up */
            }

            return '';
        }
    });

    /* add selection */
    $.fn.extend({
        selection: function(mode, opts) {
            opts = opts || {};

            switch (mode) {
                /**
                 * selection('getPos')
                 * get caret position
                 *
                 * @return  {Object}    return
                 * @return  {Number}    return.start    start position for the selection
                 * @return  {Number}    return.end      end position for the selection
                 */
                case 'getPos':
                    return _CaretOperation.getPos(this[0]);

                /**
                 * selection('setPos', opts)
                 * set caret position
                 *
                 * @param   {Number}    opts.start      start position for the selection
                 * @param   {Number}    opts.end        end position for the selection
                 */
                case 'setPos':
                    return this.each(function() {
                        _CaretOperation.setPos(this, opts);
                    });

                /**
                 * selection('replace', opts)
                 * replace the selected text
                 *
                 * @param   {String}    opts.text            replacement text
                 * @param   {String}    opts.caret           caret mode: any of the following: "keep" | "start" | "end"
                 */
                case 'replace':
                    return this.each(function() {
                        _CaretOperation.replace(this, opts.text, opts.caret);
                    });

                /**
                 * selection('insert', opts)
                 * insert before/after the selected text
                 *
                 * @param   {String}    opts.text            insertion text
                 * @param   {String}    opts.caret           caret mode: any of the following: "keep" | "start" | "end"
                 * @param   {String}    opts.mode            insertion mode: any of the following: "before" | "after"
                 */
                case 'insert':
                    return this.each(function() {
                        if (opts.mode == 'before') {
                            _CaretOperation.insertBefore(this, opts.text, opts.caret);
                        } else {
                            _CaretOperation.insertAfter(this, opts.text, opts.caret);
                        }
                    });

                /**
                 * selection('get')
                 * get selected text
                 *
                 * @return  {String}    return
                 */
                case 'get':
                    /* falls through */
                default:
                    return _CaretOperation.getText(this[0]);
            }

            return this;
        }
    });
})(jQuery, window, window.document);

},{}],130:[function(require,module,exports){
/**
 * Timeago is a jQuery plugin that makes it easy to support automatically
 * updating fuzzy timestamps (e.g. "4 minutes ago" or "about 1 day ago").
 *
 * @name timeago
 * @version 1.3.0
 * @requires jQuery v1.2.3+
 * @author Ryan McGeary
 * @license MIT License - http://www.opensource.org/licenses/mit-license.php
 *
 * For usage and examples, visit:
 * http://timeago.yarp.com/
 *
 * Copyright (c) 2008-2013, Ryan McGeary (ryan -[at]- mcgeary [*dot*] org)
 */

(function (factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(['jquery'], factory);
  } else {
    // Browser globals
    factory(jQuery);
  }
}(function ($) {
  $.timeago = function(timestamp) {
    if (timestamp instanceof Date) {
      return inWords(timestamp);
    } else if (typeof timestamp === "string") {
      return inWords($.timeago.parse(timestamp));
    } else if (typeof timestamp === "number") {
      return inWords(new Date(timestamp));
    } else {
      return inWords($.timeago.datetime(timestamp));
    }
  };
  var $t = $.timeago;

  $.extend($.timeago, {
    settings: {
      refreshMillis: 60000,
      allowFuture: false,
      localeTitle: false,
      cutoff: 0,
      strings: {
        prefixAgo: null,
        prefixFromNow: null,
        suffixAgo: "ago",
        suffixFromNow: "from now",
        seconds: "less than a minute",
        minute: "about a minute",
        minutes: "%d minutes",
        hour: "about an hour",
        hours: "about %d hours",
        day: "a day",
        days: "%d days",
        month: "about a month",
        months: "%d months",
        year: "about a year",
        years: "%d years",
        wordSeparator: " ",
        numbers: []
      }
    },
    inWords: function(distanceMillis) {
      var $l = this.settings.strings;
      var prefix = $l.prefixAgo;
      var suffix = $l.suffixAgo;
      if (this.settings.allowFuture) {
        if (distanceMillis < 0) {
          prefix = $l.prefixFromNow;
          suffix = $l.suffixFromNow;
        }
      }

      var seconds = Math.abs(distanceMillis) / 1000;
      var minutes = seconds / 60;
      var hours = minutes / 60;
      var days = hours / 24;
      var years = days / 365;

      function substitute(stringOrFunction, number) {
        var string = $.isFunction(stringOrFunction) ? stringOrFunction(number, distanceMillis) : stringOrFunction;
        var value = ($l.numbers && $l.numbers[number]) || number;
        return string.replace(/%d/i, value);
      }

      var words = seconds < 45 && substitute($l.seconds, Math.round(seconds)) ||
        seconds < 90 && substitute($l.minute, 1) ||
        minutes < 45 && substitute($l.minutes, Math.round(minutes)) ||
        minutes < 90 && substitute($l.hour, 1) ||
        hours < 24 && substitute($l.hours, Math.round(hours)) ||
        hours < 42 && substitute($l.day, 1) ||
        days < 30 && substitute($l.days, Math.round(days)) ||
        days < 45 && substitute($l.month, 1) ||
        days < 365 && substitute($l.months, Math.round(days / 30)) ||
        years < 1.5 && substitute($l.year, 1) ||
        substitute($l.years, Math.round(years));

      var separator = $l.wordSeparator || "";
      if ($l.wordSeparator === undefined) { separator = " "; }
      return $.trim([prefix, words, suffix].join(separator));
    },
    parse: function(iso8601) {
      var s = $.trim(iso8601);
      s = s.replace(/\.\d+/,""); // remove milliseconds
      s = s.replace(/-/,"/").replace(/-/,"/");
      s = s.replace(/T/," ").replace(/Z/," UTC");
      s = s.replace(/([\+\-]\d\d)\:?(\d\d)/," $1$2"); // -04:00 -> -0400
      return new Date(s);
    },
    datetime: function(elem) {
      var iso8601 = $t.isTime(elem) ? $(elem).attr("datetime") : $(elem).attr("title");
      return $t.parse(iso8601);
    },
    isTime: function(elem) {
      // jQuery's `is()` doesn't play well with HTML5 in IE
      return $(elem).get(0).tagName.toLowerCase() === "time"; // $(elem).is("time");
    }
  });

  // functions that can be called via $(el).timeago('action')
  // init is default when no action is given
  // functions are called with context of a single element
  var functions = {
    init: function(){
      var refresh_el = $.proxy(refresh, this);
      refresh_el();
      var $s = $t.settings;
      if ($s.refreshMillis > 0) {
        setInterval(refresh_el, $s.refreshMillis);
      }
    },
    update: function(time){
      $(this).data('timeago', { datetime: $t.parse(time) });
      refresh.apply(this);
    },
    updateFromDOM: function(){
      $(this).data('timeago', { datetime: $t.parse( $t.isTime(this) ? $(this).attr("datetime") : $(this).attr("title") ) });
      refresh.apply(this);
    }
  };

  $.fn.timeago = function(action, options) {
    var fn = action ? functions[action] : functions.init;
    if(!fn){
      throw new Error("Unknown function name '"+ action +"' for timeago");
    }
    // each over objects here and call the requested function
    this.each(function(){
      fn.call(this, options);
    });
    return this;
  };

  function refresh() {
    var data = prepareData(this);
    var $s = $t.settings;

    if (!isNaN(data.datetime)) {
      if ( $s.cutoff == 0 || distance(data.datetime) < $s.cutoff) {
        $(this).text(inWords(data.datetime));
      }
    }
    return this;
  }

  function prepareData(element) {
    element = $(element);
    if (!element.data("timeago")) {
      element.data("timeago", { datetime: $t.datetime(element) });
      var text = $.trim(element.text());
      if ($t.settings.localeTitle) {
        element.attr("title", element.data('timeago').datetime.toLocaleString());
      } else if (text.length > 0 && !($t.isTime(element) && element.attr("title"))) {
        element.attr("title", text);
      }
    }
    return element.data("timeago");
  }

  function inWords(date) {
    return $t.inWords(distance(date));
  }

  function distance(date) {
    return (new Date().getTime() - date.getTime());
  }

  // fix for IE6 suckage
  document.createElement("abbr");
  document.createElement("time");
}));

},{}],131:[function(require,module,exports){
(function (process){
/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _each = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = function (fn) {
              // not a direct alias for IE10 compatibility
              setImmediate(fn);
            };
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                }
            }));
        });
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (err, v) {
                results[x.index] = v;
                callback(err);
            });
        }, function (err) {
            callback(err, results);
        });
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        if (!keys.length) {
            return callback(null);
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (_keys(results).length === keys.length) {
                callback(null, results);
                callback = function () {};
            }
        });

        _each(keys, function (k) {
            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor !== Array) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (test()) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (!test()) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if(data.constructor !== Array) {
              data = [data];
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            }
        };
        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
                if(data.constructor !== Array) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain) cargo.drain();
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                callback.apply(null, memo[key]);
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.compose = function (/* functions... */) {
        var fns = Array.prototype.reverse.call(arguments);
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // AMD / RequireJS
    if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // Node.js
    else if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

}).call(this,require('_process'))

},{"_process":151}],132:[function(require,module,exports){
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define([], function () {
      return (root.returnExportsGlobal = factory());
    });
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like enviroments that support module.exports,
    // like Node.
    module.exports = factory();
  } else {
    root['Autolinker'] = factory();
  }
}(this, function () {

	/*!
	 * Autolinker.js
	 * 0.15.2
	 *
	 * Copyright(c) 2015 Gregory Jacobs <greg@greg-jacobs.com>
	 * MIT Licensed. http://www.opensource.org/licenses/mit-license.php
	 *
	 * https://github.com/gregjacobs/Autolinker.js
	 */
	/**
	 * @class Autolinker
	 * @extends Object
	 * 
	 * Utility class used to process a given string of text, and wrap the URLs, email addresses, and Twitter handles in 
	 * the appropriate anchor (&lt;a&gt;) tags to turn them into links.
	 * 
	 * Any of the configuration options may be provided in an Object (map) provided to the Autolinker constructor, which
	 * will configure how the {@link #link link()} method will process the links.
	 * 
	 * For example:
	 * 
	 *     var autolinker = new Autolinker( {
	 *         newWindow : false,
	 *         truncate  : 30
	 *     } );
	 *     
	 *     var html = autolinker.link( "Joe went to www.yahoo.com" );
	 *     // produces: 'Joe went to <a href="http://www.yahoo.com">yahoo.com</a>'
	 * 
	 * 
	 * The {@link #static-link static link()} method may also be used to inline options into a single call, which may
	 * be more convenient for one-off uses. For example:
	 * 
	 *     var html = Autolinker.link( "Joe went to www.yahoo.com", {
	 *         newWindow : false,
	 *         truncate  : 30
	 *     } );
	 *     // produces: 'Joe went to <a href="http://www.yahoo.com">yahoo.com</a>'
	 * 
	 * 
	 * ## Custom Replacements of Links
	 * 
	 * If the configuration options do not provide enough flexibility, a {@link #replaceFn} may be provided to fully customize
	 * the output of Autolinker. This function is called once for each URL/Email/Twitter handle match that is encountered.
	 * 
	 * For example:
	 * 
	 *     var input = "...";  // string with URLs, Email Addresses, and Twitter Handles
	 *     
	 *     var linkedText = Autolinker.link( input, {
	 *         replaceFn : function( autolinker, match ) {
	 *             console.log( "href = ", match.getAnchorHref() );
	 *             console.log( "text = ", match.getAnchorText() );
	 *         
	 *             switch( match.getType() ) {
	 *                 case 'url' : 
	 *                     console.log( "url: ", match.getUrl() );
	 *                     
	 *                     if( match.getUrl().indexOf( 'mysite.com' ) === -1 ) {
	 *                         var tag = autolinker.getTagBuilder().build( match );  // returns an `Autolinker.HtmlTag` instance, which provides mutator methods for easy changes
	 *                         tag.setAttr( 'rel', 'nofollow' );
	 *                         tag.addClass( 'external-link' );
	 *                         
	 *                         return tag;
	 *                         
	 *                     } else {
	 *                         return true;  // let Autolinker perform its normal anchor tag replacement
	 *                     }
	 *                     
	 *                 case 'email' :
	 *                     var email = match.getEmail();
	 *                     console.log( "email: ", email );
	 *                     
	 *                     if( email === "my@own.address" ) {
	 *                         return false;  // don't auto-link this particular email address; leave as-is
	 *                     } else {
	 *                         return;  // no return value will have Autolinker perform its normal anchor tag replacement (same as returning `true`)
	 *                     }
	 *                 
	 *                 case 'twitter' :
	 *                     var twitterHandle = match.getTwitterHandle();
	 *                     console.log( twitterHandle );
	 *                     
	 *                     return '<a href="http://newplace.to.link.twitter.handles.to/">' + twitterHandle + '</a>';
	 *             }
	 *         }
	 *     } );
	 * 
	 * 
	 * The function may return the following values:
	 * 
	 * - `true` (Boolean): Allow Autolinker to replace the match as it normally would.
	 * - `false` (Boolean): Do not replace the current match at all - leave as-is.
	 * - Any String: If a string is returned from the function, the string will be used directly as the replacement HTML for
	 *   the match.
	 * - An {@link Autolinker.HtmlTag} instance, which can be used to build/modify an HTML tag before writing out its HTML text.
	 * 
	 * @constructor
	 * @param {Object} [config] The configuration options for the Autolinker instance, specified in an Object (map).
	 */
	var Autolinker = function( cfg ) {
		Autolinker.Util.assign( this, cfg );  // assign the properties of `cfg` onto the Autolinker instance. Prototype properties will be used for missing configs.

		this.matchValidator = new Autolinker.MatchValidator();
	};


	Autolinker.prototype = {
		constructor : Autolinker,  // fix constructor property

		/**
		 * @cfg {Boolean} urls
		 * 
		 * `true` if miscellaneous URLs should be automatically linked, `false` if they should not be.
		 */
		urls : true,

		/**
		 * @cfg {Boolean} email
		 * 
		 * `true` if email addresses should be automatically linked, `false` if they should not be.
		 */
		email : true,

		/**
		 * @cfg {Boolean} twitter
		 * 
		 * `true` if Twitter handles ("@example") should be automatically linked, `false` if they should not be.
		 */
		twitter : true,

		/**
		 * @cfg {Boolean} newWindow
		 * 
		 * `true` if the links should open in a new window, `false` otherwise.
		 */
		newWindow : true,

		/**
		 * @cfg {Boolean} stripPrefix
		 * 
		 * `true` if 'http://' or 'https://' and/or the 'www.' should be stripped from the beginning of URL links' text, 
		 * `false` otherwise.
		 */
		stripPrefix : true,

		/**
		 * @cfg {Number} truncate
		 * 
		 * A number for how many characters long URLs/emails/twitter handles should be truncated to inside the text of 
		 * a link. If the URL/email/twitter is over this number of characters, it will be truncated to this length by 
		 * adding a two period ellipsis ('..') to the end of the string.
		 * 
		 * For example: A url like 'http://www.yahoo.com/some/long/path/to/a/file' truncated to 25 characters might look
		 * something like this: 'yahoo.com/some/long/pat..'
		 */

		/**
		 * @cfg {String} className
		 * 
		 * A CSS class name to add to the generated links. This class will be added to all links, as well as this class
		 * plus url/email/twitter suffixes for styling url/email/twitter links differently.
		 * 
		 * For example, if this config is provided as "myLink", then:
		 * 
		 * - URL links will have the CSS classes: "myLink myLink-url"
		 * - Email links will have the CSS classes: "myLink myLink-email", and
		 * - Twitter links will have the CSS classes: "myLink myLink-twitter"
		 */
		className : "",

		/**
		 * @cfg {Function} replaceFn
		 * 
		 * A function to individually process each URL/Email/Twitter match found in the input string.
		 * 
		 * See the class's description for usage.
		 * 
		 * This function is called with the following parameters:
		 * 
		 * @cfg {Autolinker} replaceFn.autolinker The Autolinker instance, which may be used to retrieve child objects from (such
		 *   as the instance's {@link #getTagBuilder tag builder}).
		 * @cfg {Autolinker.match.Match} replaceFn.match The Match instance which can be used to retrieve information about the
		 *   {@link Autolinker.match.Url URL}/{@link Autolinker.match.Email email}/{@link Autolinker.match.Twitter Twitter}
		 *   match that the `replaceFn` is currently processing.
		 */


		/**
		 * @private
		 * @property {RegExp} htmlCharacterEntitiesRegex
		 *
		 * The regular expression that matches common HTML character entities.
		 * 
		 * Ignoring &amp; as it could be part of a query string -- handling it separately.
		 */
		htmlCharacterEntitiesRegex: /(&nbsp;|&#160;|&lt;|&#60;|&gt;|&#62;|&quot;|&#34;|&#39;)/gi,

		/**
		 * @private
		 * @property {RegExp} matcherRegex
		 * 
		 * The regular expression that matches URLs, email addresses, and Twitter handles.
		 * 
		 * This regular expression has the following capturing groups:
		 * 
		 * 1. Group that is used to determine if there is a Twitter handle match (i.e. \@someTwitterUser). Simply check for its 
		 *    existence to determine if there is a Twitter handle match. The next couple of capturing groups give information 
		 *    about the Twitter handle match.
		 * 2. The whitespace character before the \@sign in a Twitter handle. This is needed because there are no lookbehinds in
		 *    JS regular expressions, and can be used to reconstruct the original string in a replace().
		 * 3. The Twitter handle itself in a Twitter match. If the match is '@someTwitterUser', the handle is 'someTwitterUser'.
		 * 4. Group that matches an email address. Used to determine if the match is an email address, as well as holding the full 
		 *    address. Ex: 'me@my.com'
		 * 5. Group that matches a URL in the input text. Ex: 'http://google.com', 'www.google.com', or just 'google.com'.
		 *    This also includes a path, url parameters, or hash anchors. Ex: google.com/path/to/file?q1=1&q2=2#myAnchor
		 * 6. Group that matches a protocol URL (i.e. 'http://google.com'). This is used to match protocol URLs with just a single
		 *    word, like 'http://localhost', where we won't double check that the domain name has at least one '.' in it.
		 * 7. A protocol-relative ('//') match for the case of a 'www.' prefixed URL. Will be an empty string if it is not a 
		 *    protocol-relative match. We need to know the character before the '//' in order to determine if it is a valid match
		 *    or the // was in a string we don't want to auto-link.
		 * 8. A protocol-relative ('//') match for the case of a known TLD prefixed URL. Will be an empty string if it is not a 
		 *    protocol-relative match. See #6 for more info. 
		 */
		matcherRegex : (function() {
			var twitterRegex = /(^|[^\w])@(\w{1,15})/,              // For matching a twitter handle. Ex: @gregory_jacobs

			    emailRegex = /(?:[\-;:&=\+\$,\w\.]+@)/,             // something@ for email addresses (a.k.a. local-part)

			    protocolRegex = /(?:[A-Za-z][-.+A-Za-z0-9]+:(?![A-Za-z][-.+A-Za-z0-9]+:\/\/)(?!\d+\/?)(?:\/\/)?)/,  // match protocol, allow in format "http://" or "mailto:". However, do not match the first part of something like 'link:http://www.google.com' (i.e. don't match "link:"). Also, make sure we don't interpret 'google.com:8000' as if 'google.com' was a protocol here (i.e. ignore a trailing port number in this regex)
			    wwwRegex = /(?:www\.)/,                             // starting with 'www.'
			    domainNameRegex = /[A-Za-z0-9\.\-]*[A-Za-z0-9\-]/,  // anything looking at all like a domain, non-unicode domains, not ending in a period
			    tldRegex = /\.(?:international|construction|contractors|enterprises|photography|productions|foundation|immobilien|industries|management|properties|technology|christmas|community|directory|education|equipment|institute|marketing|solutions|vacations|bargains|boutique|builders|catering|cleaning|clothing|computer|democrat|diamonds|graphics|holdings|lighting|partners|plumbing|supplies|training|ventures|academy|careers|company|cruises|domains|exposed|flights|florist|gallery|guitars|holiday|kitchen|neustar|okinawa|recipes|rentals|reviews|shiksha|singles|support|systems|agency|berlin|camera|center|coffee|condos|dating|estate|events|expert|futbol|kaufen|luxury|maison|monash|museum|nagoya|photos|repair|report|social|supply|tattoo|tienda|travel|viajes|villas|vision|voting|voyage|actor|build|cards|cheap|codes|dance|email|glass|house|mango|ninja|parts|photo|shoes|solar|today|tokyo|tools|watch|works|aero|arpa|asia|best|bike|blue|buzz|camp|club|cool|coop|farm|fish|gift|guru|info|jobs|kiwi|kred|land|limo|link|menu|mobi|moda|name|pics|pink|post|qpon|rich|ruhr|sexy|tips|vote|voto|wang|wien|wiki|zone|bar|bid|biz|cab|cat|ceo|com|edu|gov|int|kim|mil|net|onl|org|pro|pub|red|tel|uno|wed|xxx|xyz|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cw|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sx|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|za|zm|zw)\b/,   // match our known top level domains (TLDs)

			    // Allow optional path, query string, and hash anchor, not ending in the following characters: "?!:,.;"
			    // http://blog.codinghorror.com/the-problem-with-urls/
			    urlSuffixRegex = /[\-A-Za-z0-9+&@#\/%=~_()|'$*\[\]?!:,.;]*[\-A-Za-z0-9+&@#\/%=~_()|'$*\[\]]/;

			return new RegExp( [
				'(',  // *** Capturing group $1, which can be used to check for a twitter handle match. Use group $3 for the actual twitter handle though. $2 may be used to reconstruct the original string in a replace() 
					// *** Capturing group $2, which matches the whitespace character before the '@' sign (needed because of no lookbehinds), and 
					// *** Capturing group $3, which matches the actual twitter handle
					twitterRegex.source,
				')',

				'|',

				'(',  // *** Capturing group $4, which is used to determine an email match
					emailRegex.source,
					domainNameRegex.source,
					tldRegex.source,
				')',

				'|',

				'(',  // *** Capturing group $5, which is used to match a URL
					'(?:', // parens to cover match for protocol (optional), and domain
						'(',  // *** Capturing group $6, for a protocol-prefixed url (ex: http://google.com)
							protocolRegex.source,
							domainNameRegex.source,
						')',

						'|',

						'(?:',  // non-capturing paren for a 'www.' prefixed url (ex: www.google.com)
							'(.?//)?',  // *** Capturing group $7 for an optional protocol-relative URL. Must be at the beginning of the string or start with a non-word character
							wwwRegex.source,
							domainNameRegex.source,
						')',

						'|',

						'(?:',  // non-capturing paren for known a TLD url (ex: google.com)
							'(.?//)?',  // *** Capturing group $8 for an optional protocol-relative URL. Must be at the beginning of the string or start with a non-word character
							domainNameRegex.source,
							tldRegex.source,
						')',
					')',

					'(?:' + urlSuffixRegex.source + ')?',  // match for path, query string, and/or hash anchor - optional
				')'
			].join( "" ), 'gi' );
		} )(),

		/**
		 * @private
		 * @property {RegExp} charBeforeProtocolRelMatchRegex
		 * 
		 * The regular expression used to retrieve the character before a protocol-relative URL match.
		 * 
		 * This is used in conjunction with the {@link #matcherRegex}, which needs to grab the character before a protocol-relative
		 * '//' due to the lack of a negative look-behind in JavaScript regular expressions. The character before the match is stripped
		 * from the URL.
		 */
		charBeforeProtocolRelMatchRegex : /^(.)?\/\//,

		/**
		 * @private
		 * @property {Autolinker.MatchValidator} matchValidator
		 * 
		 * The MatchValidator object, used to filter out any false positives from the {@link #matcherRegex}. See
		 * {@link Autolinker.MatchValidator} for details.
		 */

		/**
		 * @private
		 * @property {Autolinker.HtmlParser} htmlParser
		 * 
		 * The HtmlParser instance used to skip over HTML tags, while finding text nodes to process. This is lazily instantiated
		 * in the {@link #getHtmlParser} method.
		 */

		/**
		 * @private
		 * @property {Autolinker.AnchorTagBuilder} tagBuilder
		 * 
		 * The AnchorTagBuilder instance used to build the URL/email/Twitter replacement anchor tags. This is lazily instantiated
		 * in the {@link #getTagBuilder} method.
		 */


		/**
		 * Automatically links URLs, email addresses, and Twitter handles found in the given chunk of HTML. 
		 * Does not link URLs found within HTML tags.
		 * 
		 * For instance, if given the text: `You should go to http://www.yahoo.com`, then the result
		 * will be `You should go to &lt;a href="http://www.yahoo.com"&gt;http://www.yahoo.com&lt;/a&gt;`
		 * 
		 * This method finds the text around any HTML elements in the input `textOrHtml`, which will be the text that is processed.
		 * Any original HTML elements will be left as-is, as well as the text that is already wrapped in anchor (&lt;a&gt;) tags.
		 * 
		 * @param {String} textOrHtml The HTML or text to link URLs, email addresses, and Twitter handles within (depending on if
		 *   the {@link #urls}, {@link #email}, and {@link #twitter} options are enabled).
		 * @return {String} The HTML, with URLs/emails/Twitter handles automatically linked.
		 */
		link : function( textOrHtml ) {
			var me = this,  // for closure
			    htmlParser = this.getHtmlParser(),
			    htmlCharacterEntitiesRegex = this.htmlCharacterEntitiesRegex,
			    anchorTagStackCount = 0,  // used to only process text around anchor tags, and any inner text/html they may have
			    resultHtml = [];

			htmlParser.parse( textOrHtml, {
				// Process HTML nodes in the input `textOrHtml`
				processHtmlNode : function( tagText, tagName, isClosingTag ) {
					if( tagName === 'a' ) {
						if( !isClosingTag ) {  // it's the start <a> tag
							anchorTagStackCount++;
						} else {   // it's the end </a> tag
							anchorTagStackCount = Math.max( anchorTagStackCount - 1, 0 );  // attempt to handle extraneous </a> tags by making sure the stack count never goes below 0
						}
					}
					resultHtml.push( tagText );  // now add the text of the tag itself verbatim
				},

				// Process text nodes in the input `textOrHtml`
				processTextNode : function( text ) {
					if( anchorTagStackCount === 0 ) {
						// If we're not within an <a> tag, process the text node
						var unescapedText = Autolinker.Util.splitAndCapture( text, htmlCharacterEntitiesRegex );  // split at HTML entities, but include the HTML entities in the results array

						for ( var i = 0, len = unescapedText.length; i < len; i++ ) {
							var textToProcess = unescapedText[ i ],
							    processedTextNode = me.processTextNode( textToProcess );

							resultHtml.push( processedTextNode );
						}

					} else {
						// `text` is within an <a> tag, simply append the text - we do not want to autolink anything 
						// already within an <a>...</a> tag
						resultHtml.push( text );
					}
				}
			} );

			return resultHtml.join( "" );
		},


		/**
		 * Lazily instantiates and returns the {@link #htmlParser} instance for this Autolinker instance.
		 * 
		 * @protected
		 * @return {Autolinker.HtmlParser}
		 */
		getHtmlParser : function() {
			var htmlParser = this.htmlParser;

			if( !htmlParser ) {
				htmlParser = this.htmlParser = new Autolinker.HtmlParser();
			}

			return htmlParser;
		},


		/**
		 * Returns the {@link #tagBuilder} instance for this Autolinker instance, lazily instantiating it
		 * if it does not yet exist.
		 * 
		 * This method may be used in a {@link #replaceFn} to generate the {@link Autolinker.HtmlTag HtmlTag} instance that 
		 * Autolinker would normally generate, and then allow for modifications before returning it. For example:
		 * 
		 *     var html = Autolinker.link( "Test google.com", {
		 *         replaceFn : function( autolinker, match ) {
		 *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance
		 *             tag.setAttr( 'rel', 'nofollow' );
		 *             
		 *             return tag;
		 *         }
		 *     } );
		 *     
		 *     // generated html:
		 *     //   Test <a href="http://google.com" target="_blank" rel="nofollow">google.com</a>
		 * 
		 * @return {Autolinker.AnchorTagBuilder}
		 */
		getTagBuilder : function() {
			var tagBuilder = this.tagBuilder;

			if( !tagBuilder ) {
				tagBuilder = this.tagBuilder = new Autolinker.AnchorTagBuilder( {
					newWindow   : this.newWindow,
					truncate    : this.truncate,
					className   : this.className
				} );
			}

			return tagBuilder;
		},


		/**
		 * Process the text that lies inbetween HTML tags. This method does the actual wrapping of URLs with
		 * anchor tags.
		 * 
		 * @private
		 * @param {String} text The text to auto-link.
		 * @return {String} The text with anchor tags auto-filled.
		 */
		processTextNode : function( text ) {
			var me = this;  // for closure

			return text.replace( this.matcherRegex, function( matchStr, $1, $2, $3, $4, $5, $6, $7, $8 ) {
				var matchDescObj = me.processCandidateMatch( matchStr, $1, $2, $3, $4, $5, $6, $7, $8 );  // match description object

				// Return out with no changes for match types that are disabled (url, email, twitter), or for matches that are 
				// invalid (false positives from the matcherRegex, which can't use look-behinds since they are unavailable in JS).
				if( !matchDescObj ) {
					return matchStr;

				} else {
					// Generate the replacement text for the match
					var matchReturnVal = me.createMatchReturnVal( matchDescObj.match, matchDescObj.matchStr );
					return matchDescObj.prefixStr + matchReturnVal + matchDescObj.suffixStr;
				}
			} );
		},


		/**
		 * Processes a candidate match from the {@link #matcherRegex}. 
		 * 
		 * Not all matches found by the regex are actual URL/email/Twitter matches, as determined by the {@link #matchValidator}. In
		 * this case, the method returns `null`. Otherwise, a valid Object with `prefixStr`, `match`, and `suffixStr` is returned.
		 * 
		 * @private
		 * @param {String} matchStr The full match that was found by the {@link #matcherRegex}.
		 * @param {String} twitterMatch The matched text of a Twitter handle, if the match is a Twitter match.
		 * @param {String} twitterHandlePrefixWhitespaceChar The whitespace char before the @ sign in a Twitter handle match. This 
		 *   is needed because of no lookbehinds in JS regexes, and is need to re-include the character for the anchor tag replacement.
		 * @param {String} twitterHandle The actual Twitter user (i.e the word after the @ sign in a Twitter match).
		 * @param {String} emailAddressMatch The matched email address for an email address match.
		 * @param {String} urlMatch The matched URL string for a URL match.
		 * @param {String} protocolUrlMatch The match URL string for a protocol match. Ex: 'http://yahoo.com'. This is used to match
		 *   something like 'http://localhost', where we won't double check that the domain name has at least one '.' in it.
		 * @param {String} wwwProtocolRelativeMatch The '//' for a protocol-relative match from a 'www' url, with the character that 
		 *   comes before the '//'.
		 * @param {String} tldProtocolRelativeMatch The '//' for a protocol-relative match from a TLD (top level domain) match, with 
		 *   the character that comes before the '//'.
		 *   
		 * @return {Object} A "match description object". This will be `null` if the match was invalid, or if a match type is disabled.
		 *   Otherwise, this will be an Object (map) with the following properties:
		 * @return {String} return.prefixStr The char(s) that should be prepended to the replacement string. These are char(s) that
		 *   were needed to be included from the regex match that were ignored by processing code, and should be re-inserted into 
		 *   the replacement stream.
		 * @return {String} return.suffixStr The char(s) that should be appended to the replacement string. These are char(s) that
		 *   were needed to be included from the regex match that were ignored by processing code, and should be re-inserted into 
		 *   the replacement stream.
		 * @return {String} return.matchStr The `matchStr`, fixed up to remove characters that are no longer needed (which have been
		 *   added to `prefixStr` and `suffixStr`).
		 * @return {Autolinker.match.Match} return.match The Match object that represents the match that was found.
		 */
		processCandidateMatch : function( 
			matchStr, twitterMatch, twitterHandlePrefixWhitespaceChar, twitterHandle, 
			emailAddressMatch, urlMatch, protocolUrlMatch, wwwProtocolRelativeMatch, tldProtocolRelativeMatch
		) {
			var protocolRelativeMatch = wwwProtocolRelativeMatch || tldProtocolRelativeMatch,
			    match,  // Will be an Autolinker.match.Match object

			    prefixStr = "",       // A string to use to prefix the anchor tag that is created. This is needed for the Twitter handle match
			    suffixStr = "";       // A string to suffix the anchor tag that is created. This is used if there is a trailing parenthesis that should not be auto-linked.


			// Return out with `null` for match types that are disabled (url, email, twitter), or for matches that are 
			// invalid (false positives from the matcherRegex, which can't use look-behinds since they are unavailable in JS).
			if(
				( twitterMatch && !this.twitter ) || ( emailAddressMatch && !this.email ) || ( urlMatch && !this.urls ) ||
				!this.matchValidator.isValidMatch( urlMatch, protocolUrlMatch, protocolRelativeMatch ) 
			) {
				return null;
			}

			// Handle a closing parenthesis at the end of the match, and exclude it if there is not a matching open parenthesis
			// in the match itself. 
			if( this.matchHasUnbalancedClosingParen( matchStr ) ) {
				matchStr = matchStr.substr( 0, matchStr.length - 1 );  // remove the trailing ")"
				suffixStr = ")";  // this will be added after the generated <a> tag
			}


			if( emailAddressMatch ) {
				match = new Autolinker.match.Email( { matchedText: matchStr, email: emailAddressMatch } );

			} else if( twitterMatch ) {
				// fix up the `matchStr` if there was a preceding whitespace char, which was needed to determine the match 
				// itself (since there are no look-behinds in JS regexes)
				if( twitterHandlePrefixWhitespaceChar ) {
					prefixStr = twitterHandlePrefixWhitespaceChar;
					matchStr = matchStr.slice( 1 );  // remove the prefixed whitespace char from the match
				}
				match = new Autolinker.match.Twitter( { matchedText: matchStr, twitterHandle: twitterHandle } );

			} else {  // url match
				// If it's a protocol-relative '//' match, remove the character before the '//' (which the matcherRegex needed
				// to match due to the lack of a negative look-behind in JavaScript regular expressions)
				if( protocolRelativeMatch ) {
					var charBeforeMatch = protocolRelativeMatch.match( this.charBeforeProtocolRelMatchRegex )[ 1 ] || "";

					if( charBeforeMatch ) {  // fix up the `matchStr` if there was a preceding char before a protocol-relative match, which was needed to determine the match itself (since there are no look-behinds in JS regexes)
						prefixStr = charBeforeMatch;
						matchStr = matchStr.slice( 1 );  // remove the prefixed char from the match
					}
				}

				match = new Autolinker.match.Url( {
					matchedText : matchStr,
					url : matchStr,
					protocolUrlMatch : !!protocolUrlMatch,
					protocolRelativeMatch : !!protocolRelativeMatch,
					stripPrefix : this.stripPrefix
				} );
			}

			return {
				prefixStr : prefixStr,
				suffixStr : suffixStr,
				matchStr  : matchStr,
				match     : match
			};
		},


		/**
		 * Determines if a match found has an unmatched closing parenthesis. If so, this parenthesis will be removed
		 * from the match itself, and appended after the generated anchor tag in {@link #processTextNode}.
		 * 
		 * A match may have an extra closing parenthesis at the end of the match because the regular expression must include parenthesis
		 * for URLs such as "wikipedia.com/something_(disambiguation)", which should be auto-linked. 
		 * 
		 * However, an extra parenthesis *will* be included when the URL itself is wrapped in parenthesis, such as in the case of
		 * "(wikipedia.com/something_(disambiguation))". In this case, the last closing parenthesis should *not* be part of the URL 
		 * itself, and this method will return `true`.
		 * 
		 * @private
		 * @param {String} matchStr The full match string from the {@link #matcherRegex}.
		 * @return {Boolean} `true` if there is an unbalanced closing parenthesis at the end of the `matchStr`, `false` otherwise.
		 */
		matchHasUnbalancedClosingParen : function( matchStr ) {
			var lastChar = matchStr.charAt( matchStr.length - 1 );

			if( lastChar === ')' ) {
				var openParensMatch = matchStr.match( /\(/g ),
				    closeParensMatch = matchStr.match( /\)/g ),
				    numOpenParens = ( openParensMatch && openParensMatch.length ) || 0,
				    numCloseParens = ( closeParensMatch && closeParensMatch.length ) || 0;

				if( numOpenParens < numCloseParens ) {
					return true;
				}
			}

			return false;
		},


		/**
		 * Creates the return string value for a given match in the input string, for the {@link #processTextNode} method.
		 * 
		 * This method handles the {@link #replaceFn}, if one was provided.
		 * 
		 * @private
		 * @param {Autolinker.match.Match} match The Match object that represents the match.
		 * @param {String} matchStr The original match string, after having been preprocessed to fix match edge cases (see
		 *   the `prefixStr` and `suffixStr` vars in {@link #processTextNode}.
		 * @return {String} The string that the `match` should be replaced with. This is usually the anchor tag string, but
		 *   may be the `matchStr` itself if the match is not to be replaced.
		 */
		createMatchReturnVal : function( match, matchStr ) {
			// Handle a custom `replaceFn` being provided
			var replaceFnResult;
			if( this.replaceFn ) {
				replaceFnResult = this.replaceFn.call( this, this, match );  // Autolinker instance is the context, and the first arg
			}

			if( typeof replaceFnResult === 'string' ) {
				return replaceFnResult;  // `replaceFn` returned a string, use that

			} else if( replaceFnResult === false ) {
				return matchStr;  // no replacement for the match

			} else if( replaceFnResult instanceof Autolinker.HtmlTag ) {
				return replaceFnResult.toString();

			} else {  // replaceFnResult === true, or no/unknown return value from function
				// Perform Autolinker's default anchor tag generation
				var tagBuilder = this.getTagBuilder(),
				    anchorTag = tagBuilder.build( match );  // returns an Autolinker.HtmlTag instance

				return anchorTag.toString();
			}
		}

	};


	/**
	 * Automatically links URLs, email addresses, and Twitter handles found in the given chunk of HTML. 
	 * Does not link URLs found within HTML tags.
	 * 
	 * For instance, if given the text: `You should go to http://www.yahoo.com`, then the result
	 * will be `You should go to &lt;a href="http://www.yahoo.com"&gt;http://www.yahoo.com&lt;/a&gt;`
	 * 
	 * Example:
	 * 
	 *     var linkedText = Autolinker.link( "Go to google.com", { newWindow: false } );
	 *     // Produces: "Go to <a href="http://google.com">google.com</a>"
	 * 
	 * @static
	 * @param {String} textOrHtml The HTML or text to find URLs, email addresses, and Twitter handles within (depending on if
	 *   the {@link #urls}, {@link #email}, and {@link #twitter} options are enabled).
	 * @param {Object} [options] Any of the configuration options for the Autolinker class, specified in an Object (map).
	 *   See the class description for an example call.
	 * @return {String} The HTML text, with URLs automatically linked
	 */
	Autolinker.link = function( textOrHtml, options ) {
		var autolinker = new Autolinker( options );
		return autolinker.link( textOrHtml );
	};


	// Namespace for `match` classes
	Autolinker.match = {};
	/*global Autolinker */
	/*jshint eqnull:true, boss:true */
	/**
	 * @class Autolinker.Util
	 * @singleton
	 * 
	 * A few utility methods for Autolinker.
	 */
	Autolinker.Util = {

		/**
		 * @property {Function} abstractMethod
		 * 
		 * A function object which represents an abstract method.
		 */
		abstractMethod : function() { throw "abstract"; },


		/**
		 * Assigns (shallow copies) the properties of `src` onto `dest`.
		 * 
		 * @param {Object} dest The destination object.
		 * @param {Object} src The source object.
		 * @return {Object} The destination object (`dest`)
		 */
		assign : function( dest, src ) {
			for( var prop in src ) {
				if( src.hasOwnProperty( prop ) ) {
					dest[ prop ] = src[ prop ];
				}
			}

			return dest;
		},


		/**
		 * Extends `superclass` to create a new subclass, adding the `protoProps` to the new subclass's prototype.
		 * 
		 * @param {Function} superclass The constructor function for the superclass.
		 * @param {Object} protoProps The methods/properties to add to the subclass's prototype. This may contain the
		 *   special property `constructor`, which will be used as the new subclass's constructor function.
		 * @return {Function} The new subclass function.
		 */
		extend : function( superclass, protoProps ) {
			var superclassProto = superclass.prototype;

			var F = function() {};
			F.prototype = superclassProto;

			var subclass;
			if( protoProps.hasOwnProperty( 'constructor' ) ) {
				subclass = protoProps.constructor;
			} else {
				subclass = function() { superclassProto.constructor.apply( this, arguments ); };
			}

			var subclassProto = subclass.prototype = new F();  // set up prototype chain
			subclassProto.constructor = subclass;  // fix constructor property
			subclassProto.superclass = superclassProto;

			delete protoProps.constructor;  // don't re-assign constructor property to the prototype, since a new function may have been created (`subclass`), which is now already there
			Autolinker.Util.assign( subclassProto, protoProps );

			return subclass;
		},


		/**
		 * Truncates the `str` at `len - ellipsisChars.length`, and adds the `ellipsisChars` to the
		 * end of the string (by default, two periods: '..'). If the `str` length does not exceed 
		 * `len`, the string will be returned unchanged.
		 * 
		 * @param {String} str The string to truncate and add an ellipsis to.
		 * @param {Number} truncateLen The length to truncate the string at.
		 * @param {String} [ellipsisChars=..] The ellipsis character(s) to add to the end of `str`
		 *   when truncated. Defaults to '..'
		 */
		ellipsis : function( str, truncateLen, ellipsisChars ) {
			if( str.length > truncateLen ) {
				ellipsisChars = ( ellipsisChars == null ) ? '..' : ellipsisChars;
				str = str.substring( 0, truncateLen - ellipsisChars.length ) + ellipsisChars;
			}
			return str;
		},


		/**
		 * Supports `Array.prototype.indexOf()` functionality for old IE (IE8 and below).
		 * 
		 * @param {Array} arr The array to find an element of.
		 * @param {*} element The element to find in the array, and return the index of.
		 * @return {Number} The index of the `element`, or -1 if it was not found.
		 */
		indexOf : function( arr, element ) {
			if( Array.prototype.indexOf ) {
				return arr.indexOf( element );

			} else {
				for( var i = 0, len = arr.length; i < len; i++ ) {
					if( arr[ i ] === element ) return i;
				}
				return -1;
			}
		},



		/**
		 * Performs the functionality of what modern browsers do when `String.prototype.split()` is called
		 * with a regular expression that contains capturing parenthesis.
		 * 
		 * For example:
		 * 
		 *     // Modern browsers: 
		 *     "a,b,c".split( /(,)/ );  // --> [ 'a', ',', 'b', ',', 'c' ]
		 *     
		 *     // Old IE (including IE8):
		 *     "a,b,c".split( /(,)/ );  // --> [ 'a', 'b', 'c' ]
		 *     
		 * This method emulates the functionality of modern browsers for the old IE case.
		 * 
		 * @param {String} str The string to split.
		 * @param {RegExp} splitRegex The regular expression to split the input `str` on. The splitting
		 *   character(s) will be spliced into the array, as in the "modern browsers" example in the 
		 *   description of this method. 
		 *   Note #1: the supplied regular expression **must** have the 'g' flag specified.
		 *   Note #2: for simplicity's sake, the regular expression does not need 
		 *   to contain capturing parenthesis - it will be assumed that any match has them.
		 * @return {String[]} The split array of strings, with the splitting character(s) included.
		 */
		splitAndCapture : function( str, splitRegex ) {
			if( !splitRegex.global ) throw new Error( "`splitRegex` must have the 'g' flag set" );

			var result = [],
			    lastIdx = 0,
			    match;

			while( match = splitRegex.exec( str ) ) {
				result.push( str.substring( lastIdx, match.index ) );
				result.push( match[ 0 ] );  // push the splitting char(s)

				lastIdx = match.index + match[ 0 ].length;
			}
			result.push( str.substring( lastIdx ) );

			return result;
		}

	};
	/*global Autolinker */
	/**
	 * @private
	 * @class Autolinker.HtmlParser
	 * @extends Object
	 * 
	 * An HTML parser implementation which simply walks an HTML string and calls the provided visitor functions to process 
	 * HTML and text nodes.
	 * 
	 * Autolinker uses this to only link URLs/emails/Twitter handles within text nodes, basically ignoring HTML tags.
	 */
	Autolinker.HtmlParser = Autolinker.Util.extend( Object, {

		/**
		 * @private
		 * @property {RegExp} htmlRegex
		 * 
		 * The regular expression used to pull out HTML tags from a string. Handles namespaced HTML tags and
		 * attribute names, as specified by http://www.w3.org/TR/html-markup/syntax.html.
		 * 
		 * Capturing groups:
		 * 
		 * 1. The "!DOCTYPE" tag name, if a tag is a &lt;!DOCTYPE&gt; tag.
		 * 2. If it is an end tag, this group will have the '/'.
		 * 3. The tag name for all tags (other than the &lt;!DOCTYPE&gt; tag)
		 */
		htmlRegex : (function() {
			var tagNameRegex = /[0-9a-zA-Z][0-9a-zA-Z:]*/,
			    attrNameRegex = /[^\s\0"'>\/=\x01-\x1F\x7F]+/,   // the unicode range accounts for excluding control chars, and the delete char
			    attrValueRegex = /(?:"[^"]*?"|'[^']*?'|[^'"=<>`\s]+)/, // double quoted, single quoted, or unquoted attribute values
			    nameEqualsValueRegex = attrNameRegex.source + '(?:\\s*=\\s*' + attrValueRegex.source + ')?';  // optional '=[value]'

			return new RegExp( [
				// for <!DOCTYPE> tag. Ex: <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">) 
				'(?:',
					'<(!DOCTYPE)',  // *** Capturing Group 1 - If it's a doctype tag

						// Zero or more attributes following the tag name
						'(?:',
							'\\s+',  // one or more whitespace chars before an attribute

							// Either:
							// A. attr="value", or 
							// B. "value" alone (To cover example doctype tag: <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">) 
							'(?:', nameEqualsValueRegex, '|', attrValueRegex.source + ')',
						')*',
					'>',
				')',

				'|',

				// All other HTML tags (i.e. tags that are not <!DOCTYPE>)
				'(?:',
					'<(/)?',  // Beginning of a tag. Either '<' for a start tag, or '</' for an end tag. 
					          // *** Capturing Group 2: The slash or an empty string. Slash ('/') for end tag, empty string for start or self-closing tag.

						// *** Capturing Group 3 - The tag name
						'(' + tagNameRegex.source + ')',

						// Zero or more attributes following the tag name
						'(?:',
							'\\s+',                // one or more whitespace chars before an attribute
							nameEqualsValueRegex,  // attr="value" (with optional ="value" part)
						')*',

						'\\s*/?',  // any trailing spaces and optional '/' before the closing '>'
					'>',
				')'
			].join( "" ), 'gi' );
		} )(),


		/**
		 * Walks an HTML string, calling the `options.processHtmlNode` function for each HTML tag that is encountered, and calling
		 * the `options.processTextNode` function when each text around HTML tags is encountered.
		 * 
		 * @param {String} html The HTML to parse.
		 * @param {Object} [options] An Object (map) which may contain the following properties:
		 * 
		 * @param {Function} [options.processHtmlNode] A visitor function which allows processing of an encountered HTML node.
		 *   This function is called with the following arguments:
		 * @param {String} [options.processHtmlNode.tagText] The HTML tag text that was found.
		 * @param {String} [options.processHtmlNode.tagName] The tag name for the HTML tag that was found. Ex: 'a' for an anchor tag.
		 * @param {String} [options.processHtmlNode.isClosingTag] `true` if the tag is a closing tag (ex: &lt;/a&gt;), `false` otherwise.
		 *  
		 * @param {Function} [options.processTextNode] A visitor function which allows processing of an encountered text node.
		 *   This function is called with the following arguments:
		 * @param {String} [options.processTextNode.text] The text node that was matched.
		 */
		parse : function( html, options ) {
			options = options || {};

			var processHtmlNodeVisitor = options.processHtmlNode || function() {},
			    processTextNodeVisitor = options.processTextNode || function() {},
			    htmlRegex = this.htmlRegex,
			    currentResult,
			    lastIndex = 0;

			// Loop over the HTML string, ignoring HTML tags, and processing the text that lies between them,
			// wrapping the URLs in anchor tags
			while( ( currentResult = htmlRegex.exec( html ) ) !== null ) {
				var tagText = currentResult[ 0 ],
				    tagName = currentResult[ 1 ] || currentResult[ 3 ],  // The <!DOCTYPE> tag (ex: "!DOCTYPE"), or another tag (ex: "a") 
				    isClosingTag = !!currentResult[ 2 ],
				    inBetweenTagsText = html.substring( lastIndex, currentResult.index );

				if( inBetweenTagsText ) {
					processTextNodeVisitor( inBetweenTagsText );
				}

				processHtmlNodeVisitor( tagText, tagName.toLowerCase(), isClosingTag );

				lastIndex = currentResult.index + tagText.length;
			}

			// Process any remaining text after the last HTML element. Will process all of the text if there were no HTML elements.
			if( lastIndex < html.length ) {
				var text = html.substring( lastIndex );

				if( text ) {
					processTextNodeVisitor( text );
				}
			}
		}

	} );
	/*global Autolinker */
	/*jshint boss:true */
	/**
	 * @class Autolinker.HtmlTag
	 * @extends Object
	 * 
	 * Represents an HTML tag, which can be used to easily build/modify HTML tags programmatically.
	 * 
	 * Autolinker uses this abstraction to create HTML tags, and then write them out as strings. You may also use
	 * this class in your code, especially within a {@link Autolinker#replaceFn replaceFn}.
	 * 
	 * ## Examples
	 * 
	 * Example instantiation:
	 * 
	 *     var tag = new Autolinker.HtmlTag( {
	 *         tagName : 'a',
	 *         attrs   : { 'href': 'http://google.com', 'class': 'external-link' },
	 *         innerHtml : 'Google'
	 *     } );
	 *     
	 *     tag.toString();  // <a href="http://google.com" class="external-link">Google</a>
	 *     
	 *     // Individual accessor methods
	 *     tag.getTagName();                 // 'a'
	 *     tag.getAttr( 'href' );            // 'http://google.com'
	 *     tag.hasClass( 'external-link' );  // true
	 * 
	 * 
	 * Using mutator methods (which may be used in combination with instantiation config properties):
	 * 
	 *     var tag = new Autolinker.HtmlTag();
	 *     tag.setTagName( 'a' );
	 *     tag.setAttr( 'href', 'http://google.com' );
	 *     tag.addClass( 'external-link' );
	 *     tag.setInnerHtml( 'Google' );
	 *     
	 *     tag.getTagName();                 // 'a'
	 *     tag.getAttr( 'href' );            // 'http://google.com'
	 *     tag.hasClass( 'external-link' );  // true
	 *     
	 *     tag.toString();  // <a href="http://google.com" class="external-link">Google</a>
	 *     
	 * 
	 * ## Example use within a {@link Autolinker#replaceFn replaceFn}
	 * 
	 *     var html = Autolinker.link( "Test google.com", {
	 *         replaceFn : function( autolinker, match ) {
	 *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance, configured with the Match's href and anchor text
	 *             tag.setAttr( 'rel', 'nofollow' );
	 *             
	 *             return tag;
	 *         }
	 *     } );
	 *     
	 *     // generated html:
	 *     //   Test <a href="http://google.com" target="_blank" rel="nofollow">google.com</a>
	 *     
	 *     
	 * ## Example use with a new tag for the replacement
	 * 
	 *     var html = Autolinker.link( "Test google.com", {
	 *         replaceFn : function( autolinker, match ) {
	 *             var tag = new Autolinker.HtmlTag( {
	 *                 tagName : 'button',
	 *                 attrs   : { 'title': 'Load URL: ' + match.getAnchorHref() },
	 *                 innerHtml : 'Load URL: ' + match.getAnchorText()
	 *             } );
	 *             
	 *             return tag;
	 *         }
	 *     } );
	 *     
	 *     // generated html:
	 *     //   Test <button title="Load URL: http://google.com">Load URL: google.com</button>
	 */
	Autolinker.HtmlTag = Autolinker.Util.extend( Object, {

		/**
		 * @cfg {String} tagName
		 * 
		 * The tag name. Ex: 'a', 'button', etc.
		 * 
		 * Not required at instantiation time, but should be set using {@link #setTagName} before {@link #toString}
		 * is executed.
		 */

		/**
		 * @cfg {Object.<String, String>} attrs
		 * 
		 * An key/value Object (map) of attributes to create the tag with. The keys are the attribute names, and the
		 * values are the attribute values.
		 */

		/**
		 * @cfg {String} innerHtml
		 * 
		 * The inner HTML for the tag. 
		 * 
		 * Note the camel case name on `innerHtml`. Acronyms are camelCased in this utility (such as not to run into the acronym 
		 * naming inconsistency that the DOM developers created with `XMLHttpRequest`). You may alternatively use {@link #innerHTML}
		 * if you prefer, but this one is recommended.
		 */

		/**
		 * @cfg {String} innerHTML
		 * 
		 * Alias of {@link #innerHtml}, accepted for consistency with the browser DOM api, but prefer the camelCased version
		 * for acronym names.
		 */


		/**
		 * @protected
		 * @property {RegExp} whitespaceRegex
		 * 
		 * Regular expression used to match whitespace in a string of CSS classes.
		 */
		whitespaceRegex : /\s+/,


		/**
		 * @constructor
		 * @param {Object} [cfg] The configuration properties for this class, in an Object (map)
		 */
		constructor : function( cfg ) {
			Autolinker.Util.assign( this, cfg );

			this.innerHtml = this.innerHtml || this.innerHTML;  // accept either the camelCased form or the fully capitalized acronym
		},


		/**
		 * Sets the tag name that will be used to generate the tag with.
		 * 
		 * @param {String} tagName
		 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
		 */
		setTagName : function( tagName ) {
			this.tagName = tagName;
			return this;
		},


		/**
		 * Retrieves the tag name.
		 * 
		 * @return {String}
		 */
		getTagName : function() {
			return this.tagName || "";
		},


		/**
		 * Sets an attribute on the HtmlTag.
		 * 
		 * @param {String} attrName The attribute name to set.
		 * @param {String} attrValue The attribute value to set.
		 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
		 */
		setAttr : function( attrName, attrValue ) {
			var tagAttrs = this.getAttrs();
			tagAttrs[ attrName ] = attrValue;

			return this;
		},


		/**
		 * Retrieves an attribute from the HtmlTag. If the attribute does not exist, returns `undefined`.
		 * 
		 * @param {String} name The attribute name to retrieve.
		 * @return {String} The attribute's value, or `undefined` if it does not exist on the HtmlTag.
		 */
		getAttr : function( attrName ) {
			return this.getAttrs()[ attrName ];
		},


		/**
		 * Sets one or more attributes on the HtmlTag.
		 * 
		 * @param {Object.<String, String>} attrs A key/value Object (map) of the attributes to set.
		 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
		 */
		setAttrs : function( attrs ) {
			var tagAttrs = this.getAttrs();
			Autolinker.Util.assign( tagAttrs, attrs );

			return this;
		},


		/**
		 * Retrieves the attributes Object (map) for the HtmlTag.
		 * 
		 * @return {Object.<String, String>} A key/value object of the attributes for the HtmlTag.
		 */
		getAttrs : function() {
			return this.attrs || ( this.attrs = {} );
		},


		/**
		 * Sets the provided `cssClass`, overwriting any current CSS classes on the HtmlTag.
		 * 
		 * @param {String} cssClass One or more space-separated CSS classes to set (overwrite).
		 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
		 */
		setClass : function( cssClass ) {
			return this.setAttr( 'class', cssClass );
		},


		/**
		 * Convenience method to add one or more CSS classes to the HtmlTag. Will not add duplicate CSS classes.
		 * 
		 * @param {String} cssClass One or more space-separated CSS classes to add.
		 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
		 */
		addClass : function( cssClass ) {
			var classAttr = this.getClass(),
			    whitespaceRegex = this.whitespaceRegex,
			    indexOf = Autolinker.Util.indexOf,  // to support IE8 and below
			    classes = ( !classAttr ) ? [] : classAttr.split( whitespaceRegex ),
			    newClasses = cssClass.split( whitespaceRegex ),
			    newClass;

			while( newClass = newClasses.shift() ) {
				if( indexOf( classes, newClass ) === -1 ) {
					classes.push( newClass );
				}
			}

			this.getAttrs()[ 'class' ] = classes.join( " " );
			return this;
		},


		/**
		 * Convenience method to remove one or more CSS classes from the HtmlTag.
		 * 
		 * @param {String} cssClass One or more space-separated CSS classes to remove.
		 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
		 */
		removeClass : function( cssClass ) {
			var classAttr = this.getClass(),
			    whitespaceRegex = this.whitespaceRegex,
			    indexOf = Autolinker.Util.indexOf,  // to support IE8 and below
			    classes = ( !classAttr ) ? [] : classAttr.split( whitespaceRegex ),
			    removeClasses = cssClass.split( whitespaceRegex ),
			    removeClass;

			while( classes.length && ( removeClass = removeClasses.shift() ) ) {
				var idx = indexOf( classes, removeClass );
				if( idx !== -1 ) {
					classes.splice( idx, 1 );
				}
			}

			this.getAttrs()[ 'class' ] = classes.join( " " );
			return this;
		},


		/**
		 * Convenience method to retrieve the CSS class(es) for the HtmlTag, which will each be separated by spaces when
		 * there are multiple.
		 * 
		 * @return {String}
		 */
		getClass : function() {
			return this.getAttrs()[ 'class' ] || "";
		},


		/**
		 * Convenience method to check if the tag has a CSS class or not.
		 * 
		 * @param {String} cssClass The CSS class to check for.
		 * @return {Boolean} `true` if the HtmlTag has the CSS class, `false` otherwise.
		 */
		hasClass : function( cssClass ) {
			return ( ' ' + this.getClass() + ' ' ).indexOf( ' ' + cssClass + ' ' ) !== -1;
		},


		/**
		 * Sets the inner HTML for the tag.
		 * 
		 * @param {String} html The inner HTML to set.
		 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
		 */
		setInnerHtml : function( html ) {
			this.innerHtml = html;

			return this;
		},


		/**
		 * Retrieves the inner HTML for the tag.
		 * 
		 * @return {String}
		 */
		getInnerHtml : function() {
			return this.innerHtml || "";
		},


		/**
		 * Override of superclass method used to generate the HTML string for the tag.
		 * 
		 * @return {String}
		 */
		toString : function() {
			var tagName = this.getTagName(),
			    attrsStr = this.buildAttrsStr();

			attrsStr = ( attrsStr ) ? ' ' + attrsStr : '';  // prepend a space if there are actually attributes

			return [ '<', tagName, attrsStr, '>', this.getInnerHtml(), '</', tagName, '>' ].join( "" );
		},


		/**
		 * Support method for {@link #toString}, returns the string space-separated key="value" pairs, used to populate 
		 * the stringified HtmlTag.
		 * 
		 * @protected
		 * @return {String} Example return: `attr1="value1" attr2="value2"`
		 */
		buildAttrsStr : function() {
			if( !this.attrs ) return "";  // no `attrs` Object (map) has been set, return empty string

			var attrs = this.getAttrs(),
			    attrsArr = [];

			for( var prop in attrs ) {
				if( attrs.hasOwnProperty( prop ) ) {
					attrsArr.push( prop + '="' + attrs[ prop ] + '"' );
				}
			}
			return attrsArr.join( " " );
		}

	} );
	/*global Autolinker */
	/*jshint scripturl:true */
	/**
	 * @private
	 * @class Autolinker.MatchValidator
	 * @extends Object
	 * 
	 * Used by Autolinker to filter out false positives from the {@link Autolinker#matcherRegex}.
	 * 
	 * Due to the limitations of regular expressions (including the missing feature of look-behinds in JS regular expressions),
	 * we cannot always determine the validity of a given match. This class applies a bit of additional logic to filter out any
	 * false positives that have been matched by the {@link Autolinker#matcherRegex}.
	 */
	Autolinker.MatchValidator = Autolinker.Util.extend( Object, {

		/**
		 * @private
		 * @property {RegExp} invalidProtocolRelMatchRegex
		 * 
		 * The regular expression used to check a potential protocol-relative URL match, coming from the 
		 * {@link Autolinker#matcherRegex}. A protocol-relative URL is, for example, "//yahoo.com"
		 * 
		 * This regular expression checks to see if there is a word character before the '//' match in order to determine if 
		 * we should actually autolink a protocol-relative URL. This is needed because there is no negative look-behind in 
		 * JavaScript regular expressions. 
		 * 
		 * For instance, we want to autolink something like "Go to: //google.com", but we don't want to autolink something 
		 * like "abc//google.com"
		 */
		invalidProtocolRelMatchRegex : /^[\w]\/\//,

		/**
		 * Regex to test for a full protocol, with the two trailing slashes. Ex: 'http://'
		 * 
		 * @private
		 * @property {RegExp} hasFullProtocolRegex
		 */
		hasFullProtocolRegex : /^[A-Za-z][-.+A-Za-z0-9]+:\/\//,

		/**
		 * Regex to find the URI scheme, such as 'mailto:'.
		 * 
		 * This is used to filter out 'javascript:' and 'vbscript:' schemes.
		 * 
		 * @private
		 * @property {RegExp} uriSchemeRegex
		 */
		uriSchemeRegex : /^[A-Za-z][-.+A-Za-z0-9]+:/,

		/**
		 * Regex to determine if at least one word char exists after the protocol (i.e. after the ':')
		 * 
		 * @private
		 * @property {RegExp} hasWordCharAfterProtocolRegex
		 */
		hasWordCharAfterProtocolRegex : /:[^\s]*?[A-Za-z]/,


		/**
		 * Determines if a given match found by {@link Autolinker#processTextNode} is valid. Will return `false` for:
		 * 
		 * 1) URL matches which do not have at least have one period ('.') in the domain name (effectively skipping over 
		 *    matches like "abc:def"). However, URL matches with a protocol will be allowed (ex: 'http://localhost')
		 * 2) URL matches which do not have at least one word character in the domain name (effectively skipping over
		 *    matches like "git:1.0").
		 * 3) A protocol-relative url match (a URL beginning with '//') whose previous character is a word character 
		 *    (effectively skipping over strings like "abc//google.com")
		 * 
		 * Otherwise, returns `true`.
		 * 
		 * @param {String} urlMatch The matched URL, if there was one. Will be an empty string if the match is not a URL match.
		 * @param {String} protocolUrlMatch The match URL string for a protocol match. Ex: 'http://yahoo.com'. This is used to match
		 *   something like 'http://localhost', where we won't double check that the domain name has at least one '.' in it.
		 * @param {String} protocolRelativeMatch The protocol-relative string for a URL match (i.e. '//'), possibly with a preceding
		 *   character (ex, a space, such as: ' //', or a letter, such as: 'a//'). The match is invalid if there is a word character
		 *   preceding the '//'.
		 * @return {Boolean} `true` if the match given is valid and should be processed, or `false` if the match is invalid and/or 
		 *   should just not be processed.
		 */
		isValidMatch : function( urlMatch, protocolUrlMatch, protocolRelativeMatch ) {
			if(
				( protocolUrlMatch && !this.isValidUriScheme( protocolUrlMatch ) ) ||
				this.urlMatchDoesNotHaveProtocolOrDot( urlMatch, protocolUrlMatch ) ||       // At least one period ('.') must exist in the URL match for us to consider it an actual URL, *unless* it was a full protocol match (like 'http://localhost')
				this.urlMatchDoesNotHaveAtLeastOneWordChar( urlMatch, protocolUrlMatch ) ||  // At least one letter character must exist in the domain name after a protocol match. Ex: skip over something like "git:1.0"
				this.isInvalidProtocolRelativeMatch( protocolRelativeMatch )                 // A protocol-relative match which has a word character in front of it (so we can skip something like "abc//google.com")
			) {
				return false;
			}

			return true;
		},


		/**
		 * Determines if the URI scheme is a valid scheme to be autolinked. Returns `false` if the scheme is 
		 * 'javascript:' or 'vbscript:'
		 * 
		 * @private
		 * @param {String} uriSchemeMatch The match URL string for a full URI scheme match. Ex: 'http://yahoo.com' 
		 *   or 'mailto:a@a.com'.
		 * @return {Boolean} `true` if the scheme is a valid one, `false` otherwise.
		 */
		isValidUriScheme : function( uriSchemeMatch ) {
			var uriScheme = uriSchemeMatch.match( this.uriSchemeRegex )[ 0 ];

			return ( uriScheme !== 'javascript:' && uriScheme !== 'vbscript:' );
		},


		/**
		 * Determines if a URL match does not have either:
		 * 
		 * a) a full protocol (i.e. 'http://'), or
		 * b) at least one dot ('.') in the domain name (for a non-full-protocol match).
		 * 
		 * Either situation is considered an invalid URL (ex: 'git:d' does not have either the '://' part, or at least one dot
		 * in the domain name. If the match was 'git:abc.com', we would consider this valid.)
		 * 
		 * @private
		 * @param {String} urlMatch The matched URL, if there was one. Will be an empty string if the match is not a URL match.
		 * @param {String} protocolUrlMatch The match URL string for a protocol match. Ex: 'http://yahoo.com'. This is used to match
		 *   something like 'http://localhost', where we won't double check that the domain name has at least one '.' in it.
		 * @return {Boolean} `true` if the URL match does not have a full protocol, or at least one dot ('.') in a non-full-protocol
		 *   match.
		 */
		urlMatchDoesNotHaveProtocolOrDot : function( urlMatch, protocolUrlMatch ) {
			return ( !!urlMatch && ( !protocolUrlMatch || !this.hasFullProtocolRegex.test( protocolUrlMatch ) ) && urlMatch.indexOf( '.' ) === -1 );
		},


		/**
		 * Determines if a URL match does not have at least one word character after the protocol (i.e. in the domain name).
		 * 
		 * At least one letter character must exist in the domain name after a protocol match. Ex: skip over something 
		 * like "git:1.0"
		 * 
		 * @private
		 * @param {String} urlMatch The matched URL, if there was one. Will be an empty string if the match is not a URL match.
		 * @param {String} protocolUrlMatch The match URL string for a protocol match. Ex: 'http://yahoo.com'. This is used to
		 *   know whether or not we have a protocol in the URL string, in order to check for a word character after the protocol
		 *   separator (':').
		 * @return {Boolean} `true` if the URL match does not have at least one word character in it after the protocol, `false`
		 *   otherwise.
		 */
		urlMatchDoesNotHaveAtLeastOneWordChar : function( urlMatch, protocolUrlMatch ) {
			if( urlMatch && protocolUrlMatch ) {
				return !this.hasWordCharAfterProtocolRegex.test( urlMatch );
			} else {
				return false;
			}
		},


		/**
		 * Determines if a protocol-relative match is an invalid one. This method returns `true` if there is a `protocolRelativeMatch`,
		 * and that match contains a word character before the '//' (i.e. it must contain whitespace or nothing before the '//' in
		 * order to be considered valid).
		 * 
		 * @private
		 * @param {String} protocolRelativeMatch The protocol-relative string for a URL match (i.e. '//'), possibly with a preceding
		 *   character (ex, a space, such as: ' //', or a letter, such as: 'a//'). The match is invalid if there is a word character
		 *   preceding the '//'.
		 * @return {Boolean} `true` if it is an invalid protocol-relative match, `false` otherwise.
		 */
		isInvalidProtocolRelativeMatch : function( protocolRelativeMatch ) {
			return ( !!protocolRelativeMatch && this.invalidProtocolRelMatchRegex.test( protocolRelativeMatch ) );
		}

	} );
	/*global Autolinker */
	/*jshint sub:true */
	/**
	 * @protected
	 * @class Autolinker.AnchorTagBuilder
	 * @extends Object
	 * 
	 * Builds anchor (&lt;a&gt;) tags for the Autolinker utility when a match is found.
	 * 
	 * Normally this class is instantiated, configured, and used internally by an {@link Autolinker} instance, but may 
	 * actually be retrieved in a {@link Autolinker#replaceFn replaceFn} to create {@link Autolinker.HtmlTag HtmlTag} instances
	 * which may be modified before returning from the {@link Autolinker#replaceFn replaceFn}. For example:
	 * 
	 *     var html = Autolinker.link( "Test google.com", {
	 *         replaceFn : function( autolinker, match ) {
	 *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance
	 *             tag.setAttr( 'rel', 'nofollow' );
	 *             
	 *             return tag;
	 *         }
	 *     } );
	 *     
	 *     // generated html:
	 *     //   Test <a href="http://google.com" target="_blank" rel="nofollow">google.com</a>
	 */
	Autolinker.AnchorTagBuilder = Autolinker.Util.extend( Object, {

		/**
		 * @cfg {Boolean} newWindow
		 * @inheritdoc Autolinker#newWindow
		 */

		/**
		 * @cfg {Number} truncate
		 * @inheritdoc Autolinker#truncate
		 */

		/**
		 * @cfg {String} className
		 * @inheritdoc Autolinker#className
		 */


		/**
		 * @constructor
		 * @param {Object} [cfg] The configuration options for the AnchorTagBuilder instance, specified in an Object (map).
		 */
		constructor : function( cfg ) {
			Autolinker.Util.assign( this, cfg );
		},


		/**
		 * Generates the actual anchor (&lt;a&gt;) tag to use in place of the matched URL/email/Twitter text,
		 * via its `match` object.
		 * 
		 * @param {Autolinker.match.Match} match The Match instance to generate an anchor tag from.
		 * @return {Autolinker.HtmlTag} The HtmlTag instance for the anchor tag.
		 */
		build : function( match ) {
			var tag = new Autolinker.HtmlTag( {
				tagName   : 'a',
				attrs     : this.createAttrs( match.getType(), match.getAnchorHref() ),
				innerHtml : this.processAnchorText( match.getAnchorText() )
			} );

			return tag;
		},


		/**
		 * Creates the Object (map) of the HTML attributes for the anchor (&lt;a&gt;) tag being generated.
		 * 
		 * @protected
		 * @param {"url"/"email"/"twitter"} matchType The type of match that an anchor tag is being generated for.
		 * @param {String} href The href for the anchor tag.
		 * @return {Object} A key/value Object (map) of the anchor tag's attributes. 
		 */
		createAttrs : function( matchType, anchorHref ) {
			var attrs = {
				'href' : anchorHref  // we'll always have the `href` attribute
			};

			var cssClass = this.createCssClass( matchType );
			if( cssClass ) {
				attrs[ 'class' ] = cssClass;
			}
			if( this.newWindow ) {
				attrs[ 'target' ] = "_blank";
			}

			return attrs;
		},


		/**
		 * Creates the CSS class that will be used for a given anchor tag, based on the `matchType` and the {@link #className}
		 * config.
		 * 
		 * @private
		 * @param {"url"/"email"/"twitter"} matchType The type of match that an anchor tag is being generated for.
		 * @return {String} The CSS class string for the link. Example return: "myLink myLink-url". If no {@link #className}
		 *   was configured, returns an empty string.
		 */
		createCssClass : function( matchType ) {
			var className = this.className;

			if( !className ) 
				return "";
			else
				return className + " " + className + "-" + matchType;  // ex: "myLink myLink-url", "myLink myLink-email", or "myLink myLink-twitter"
		},


		/**
		 * Processes the `anchorText` by truncating the text according to the {@link #truncate} config.
		 * 
		 * @private
		 * @param {String} anchorText The anchor tag's text (i.e. what will be displayed).
		 * @return {String} The processed `anchorText`.
		 */
		processAnchorText : function( anchorText ) {
			anchorText = this.doTruncate( anchorText );

			return anchorText;
		},


		/**
		 * Performs the truncation of the `anchorText`, if the `anchorText` is longer than the {@link #truncate} option.
		 * Truncates the text to 2 characters fewer than the {@link #truncate} option, and adds ".." to the end.
		 * 
		 * @private
		 * @param {String} text The anchor tag's text (i.e. what will be displayed).
		 * @return {String} The truncated anchor text.
		 */
		doTruncate : function( anchorText ) {
			return Autolinker.Util.ellipsis( anchorText, this.truncate || Number.POSITIVE_INFINITY );
		}

	} );
	/*global Autolinker */
	/**
	 * @abstract
	 * @class Autolinker.match.Match
	 * 
	 * Represents a match found in an input string which should be Autolinked. A Match object is what is provided in a 
	 * {@link Autolinker#replaceFn replaceFn}, and may be used to query for details about the match.
	 * 
	 * For example:
	 * 
	 *     var input = "...";  // string with URLs, Email Addresses, and Twitter Handles
	 *     
	 *     var linkedText = Autolinker.link( input, {
	 *         replaceFn : function( autolinker, match ) {
	 *             console.log( "href = ", match.getAnchorHref() );
	 *             console.log( "text = ", match.getAnchorText() );
	 *         
	 *             switch( match.getType() ) {
	 *                 case 'url' : 
	 *                     console.log( "url: ", match.getUrl() );
	 *                     
	 *                 case 'email' :
	 *                     console.log( "email: ", match.getEmail() );
	 *                     
	 *                 case 'twitter' :
	 *                     console.log( "twitter: ", match.getTwitterHandle() );
	 *             }
	 *         }
	 *     } );
	 *     
	 * See the {@link Autolinker} class for more details on using the {@link Autolinker#replaceFn replaceFn}.
	 */
	Autolinker.match.Match = Autolinker.Util.extend( Object, {

		/**
		 * @cfg {String} matchedText (required)
		 * 
		 * The original text that was matched.
		 */


		/**
		 * @constructor
		 * @param {Object} cfg The configuration properties for the Match instance, specified in an Object (map).
		 */
		constructor : function( cfg ) {
			Autolinker.Util.assign( this, cfg );
		},


		/**
		 * Returns a string name for the type of match that this class represents.
		 * 
		 * @abstract
		 * @return {String}
		 */
		getType : Autolinker.Util.abstractMethod,


		/**
		 * Returns the original text that was matched.
		 * 
		 * @return {String}
		 */
		getMatchedText : function() {
			return this.matchedText;
		},


		/**
		 * Returns the anchor href that should be generated for the match.
		 * 
		 * @abstract
		 * @return {String}
		 */
		getAnchorHref : Autolinker.Util.abstractMethod,


		/**
		 * Returns the anchor text that should be generated for the match.
		 * 
		 * @abstract
		 * @return {String}
		 */
		getAnchorText : Autolinker.Util.abstractMethod

	} );
	/*global Autolinker */
	/**
	 * @class Autolinker.match.Email
	 * @extends Autolinker.match.Match
	 * 
	 * Represents a Email match found in an input string which should be Autolinked.
	 * 
	 * See this class's superclass ({@link Autolinker.match.Match}) for more details.
	 */
	Autolinker.match.Email = Autolinker.Util.extend( Autolinker.match.Match, {

		/**
		 * @cfg {String} email (required)
		 * 
		 * The email address that was matched.
		 */


		/**
		 * Returns a string name for the type of match that this class represents.
		 * 
		 * @return {String}
		 */
		getType : function() {
			return 'email';
		},


		/**
		 * Returns the email address that was matched.
		 * 
		 * @return {String}
		 */
		getEmail : function() {
			return this.email;
		},


		/**
		 * Returns the anchor href that should be generated for the match.
		 * 
		 * @return {String}
		 */
		getAnchorHref : function() {
			return 'mailto:' + this.email;
		},


		/**
		 * Returns the anchor text that should be generated for the match.
		 * 
		 * @return {String}
		 */
		getAnchorText : function() {
			return this.email;
		}

	} );
	/*global Autolinker */
	/**
	 * @class Autolinker.match.Twitter
	 * @extends Autolinker.match.Match
	 * 
	 * Represents a Twitter match found in an input string which should be Autolinked.
	 * 
	 * See this class's superclass ({@link Autolinker.match.Match}) for more details.
	 */
	Autolinker.match.Twitter = Autolinker.Util.extend( Autolinker.match.Match, {

		/**
		 * @cfg {String} twitterHandle (required)
		 * 
		 * The Twitter handle that was matched.
		 */


		/**
		 * Returns the type of match that this class represents.
		 * 
		 * @return {String}
		 */
		getType : function() {
			return 'twitter';
		},


		/**
		 * Returns a string name for the type of match that this class represents.
		 * 
		 * @return {String}
		 */
		getTwitterHandle : function() {
			return this.twitterHandle;
		},


		/**
		 * Returns the anchor href that should be generated for the match.
		 * 
		 * @return {String}
		 */
		getAnchorHref : function() {
			return 'https://twitter.com/' + this.twitterHandle;
		},


		/**
		 * Returns the anchor text that should be generated for the match.
		 * 
		 * @return {String}
		 */
		getAnchorText : function() {
			return '@' + this.twitterHandle;
		}

	} );
	/*global Autolinker */
	/**
	 * @class Autolinker.match.Url
	 * @extends Autolinker.match.Match
	 * 
	 * Represents a Url match found in an input string which should be Autolinked.
	 * 
	 * See this class's superclass ({@link Autolinker.match.Match}) for more details.
	 */
	Autolinker.match.Url = Autolinker.Util.extend( Autolinker.match.Match, {

		/**
		 * @cfg {String} url (required)
		 * 
		 * The url that was matched.
		 */

		/**
		 * @cfg {Boolean} protocolUrlMatch (required)
		 * 
		 * `true` if the URL is a match which already has a protocol (i.e. 'http://'), `false` if the match was from a 'www' or
		 * known TLD match.
		 */

		/**
		 * @cfg {Boolean} protocolRelativeMatch (required)
		 * 
		 * `true` if the URL is a protocol-relative match. A protocol-relative match is a URL that starts with '//',
		 * and will be either http:// or https:// based on the protocol that the site is loaded under.
		 */

		/**
		 * @cfg {Boolean} stripPrefix (required)
		 * @inheritdoc Autolinker#stripPrefix
		 */


		/**
		 * @private
		 * @property {RegExp} urlPrefixRegex
		 * 
		 * A regular expression used to remove the 'http://' or 'https://' and/or the 'www.' from URLs.
		 */
		urlPrefixRegex: /^(https?:\/\/)?(www\.)?/i,

		/**
		 * @private
		 * @property {RegExp} protocolRelativeRegex
		 * 
		 * The regular expression used to remove the protocol-relative '//' from the {@link #url} string, for purposes
		 * of {@link #getAnchorText}. A protocol-relative URL is, for example, "//yahoo.com"
		 */
		protocolRelativeRegex : /^\/\//,

		/**
		 * @private
		 * @property {Boolean} protocolPrepended
		 * 
		 * Will be set to `true` if the 'http://' protocol has been prepended to the {@link #url} (because the
		 * {@link #url} did not have a protocol)
		 */
		protocolPrepended : false,


		/**
		 * Returns a string name for the type of match that this class represents.
		 * 
		 * @return {String}
		 */
		getType : function() {
			return 'url';
		},


		/**
		 * Returns the url that was matched, assuming the protocol to be 'http://' if the original
		 * match was missing a protocol.
		 * 
		 * @return {String}
		 */
		getUrl : function() {
			var url = this.url;

			// if the url string doesn't begin with a protocol, assume 'http://'
			if( !this.protocolRelativeMatch && !this.protocolUrlMatch && !this.protocolPrepended ) {
				url = this.url = 'http://' + url;

				this.protocolPrepended = true;
			}

			return url;
		},


		/**
		 * Returns the anchor href that should be generated for the match.
		 * 
		 * @return {String}
		 */
		getAnchorHref : function() {
			var url = this.getUrl();

			return url.replace( /&amp;/g, '&' );  // any &amp;'s in the URL should be converted back to '&' if they were displayed as &amp; in the source html 
		},


		/**
		 * Returns the anchor text that should be generated for the match.
		 * 
		 * @return {String}
		 */
		getAnchorText : function() {
			var anchorText = this.getUrl();

			if( this.protocolRelativeMatch ) {
				// Strip off any protocol-relative '//' from the anchor text
				anchorText = this.stripProtocolRelativePrefix( anchorText );
			}
			if( this.stripPrefix ) {
				anchorText = this.stripUrlPrefix( anchorText );
			}
			anchorText = this.removeTrailingSlash( anchorText );  // remove trailing slash, if there is one

			return anchorText;
		},


		// ---------------------------------------

		// Utility Functionality

		/**
		 * Strips the URL prefix (such as "http://" or "https://") from the given text.
		 * 
		 * @private
		 * @param {String} text The text of the anchor that is being generated, for which to strip off the
		 *   url prefix (such as stripping off "http://")
		 * @return {String} The `anchorText`, with the prefix stripped.
		 */
		stripUrlPrefix : function( text ) {
			return text.replace( this.urlPrefixRegex, '' );
		},


		/**
		 * Strips any protocol-relative '//' from the anchor text.
		 * 
		 * @private
		 * @param {String} text The text of the anchor that is being generated, for which to strip off the
		 *   protocol-relative prefix (such as stripping off "//")
		 * @return {String} The `anchorText`, with the protocol-relative prefix stripped.
		 */
		stripProtocolRelativePrefix : function( text ) {
			return text.replace( this.protocolRelativeRegex, '' );
		},


		/**
		 * Removes any trailing slash from the given `anchorText`, in preparation for the text to be displayed.
		 * 
		 * @private
		 * @param {String} anchorText The text of the anchor that is being generated, for which to remove any trailing
		 *   slash ('/') that may exist.
		 * @return {String} The `anchorText`, with the trailing slash removed.
		 */
		removeTrailingSlash : function( anchorText ) {
			if( anchorText.charAt( anchorText.length - 1 ) === '/' ) {
				anchorText = anchorText.slice( 0, -1 );
			}
			return anchorText;
		}

	} );

	return Autolinker;


}));

},{}],133:[function(require,module,exports){
//     Backbone.js 1.1.2

//     (c) 2010-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function(root, factory) {

  // Set up Backbone appropriately for the environment. Start with AMD.
  if (typeof define === 'function' && define.amd) {
    define(['underscore', 'jquery', 'exports'], function(_, $, exports) {
      // Export global even in AMD case in case this script is loaded with
      // others that may still expect a global Backbone.
      root.Backbone = factory(root, exports, _, $);
    });

  // Next for Node.js or CommonJS. jQuery may not be needed as a module.
  } else if (typeof exports !== 'undefined') {
    var _ = require('underscore');
    factory(root, exports, _);

  // Finally, as a browser global.
  } else {
    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));
  }

}(this, function(root, Backbone, _, $) {

  // Initial Setup
  // -------------

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;

  // Create local references to array methods we'll want to use later.
  var array = [];
  var push = array.push;
  var slice = array.slice;
  var splice = array.splice;

  // Current version of the library. Keep in sync with `package.json`.
  Backbone.VERSION = '1.1.2';

  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
  // the `$` variable.
  Backbone.$ = $;

  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.
  Backbone.noConflict = function() {
    root.Backbone = previousBackbone;
    return this;
  };

  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
  // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
  // set a `X-Http-Method-Override` header.
  Backbone.emulateHTTP = false;

  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
  // `application/json` requests ... will encode the body as
  // `application/x-www-form-urlencoded` instead and will send the model in a
  // form param named `model`.
  Backbone.emulateJSON = false;

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback
  // functions to an event; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  var Events = Backbone.Events = {

    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    on: function(name, callback, context) {
      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
      this._events || (this._events = {});
      var events = this._events[name] || (this._events[name] = []);
      events.push({callback: callback, context: context, ctx: context || this});
      return this;
    },

    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed.
    once: function(name, callback, context) {
      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
      var self = this;
      var once = _.once(function() {
        self.off(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
      return this.on(name, once, context);
    },

    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    off: function(name, callback, context) {
      var retain, ev, events, names, i, l, j, k;
      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
      if (!name && !callback && !context) {
        this._events = void 0;
        return this;
      }
      names = name ? [name] : _.keys(this._events);
      for (i = 0, l = names.length; i < l; i++) {
        name = names[i];
        if (events = this._events[name]) {
          this._events[name] = retain = [];
          if (callback || context) {
            for (j = 0, k = events.length; j < k; j++) {
              ev = events[j];
              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                  (context && context !== ev.context)) {
                retain.push(ev);
              }
            }
          }
          if (!retain.length) delete this._events[name];
        }
      }

      return this;
    },

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function(name) {
      if (!this._events) return this;
      var args = slice.call(arguments, 1);
      if (!eventsApi(this, 'trigger', name, args)) return this;
      var events = this._events[name];
      var allEvents = this._events.all;
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, arguments);
      return this;
    },

    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    stopListening: function(obj, name, callback) {
      var listeningTo = this._listeningTo;
      if (!listeningTo) return this;
      var remove = !name && !callback;
      if (!callback && typeof name === 'object') callback = this;
      if (obj) (listeningTo = {})[obj._listenId] = obj;
      for (var id in listeningTo) {
        obj = listeningTo[id];
        obj.off(name, callback, this);
        if (remove || _.isEmpty(obj._events)) delete this._listeningTo[id];
      }
      return this;
    }

  };

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Implement fancy features of the Events API such as multiple event
  // names `"change blur"` and jQuery-style event maps `{change: action}`
  // in terms of the existing API.
  var eventsApi = function(obj, action, name, rest) {
    if (!name) return true;

    // Handle event maps.
    if (typeof name === 'object') {
      for (var key in name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
      return false;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter);
      for (var i = 0, l = names.length; i < l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
      return false;
    }

    return true;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;
    }
  };

  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
  // listen to an event in another object ... keeping track of what it's
  // listening to.
  _.each(listenMethods, function(implementation, method) {
    Events[method] = function(obj, name, callback) {
      var listeningTo = this._listeningTo || (this._listeningTo = {});
      var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
      listeningTo[id] = obj;
      if (!callback && typeof name === 'object') callback = this;
      obj[implementation](name, callback, this);
      return this;
    };
  });

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Allow the `Backbone` object to serve as a global event bus, for folks who
  // want global "pubsub" in a convenient place.
  _.extend(Backbone, Events);

  // Backbone.Model
  // --------------

  // Backbone **Models** are the basic data object in the framework --
  // frequently representing a row in a table in a database on your server.
  // A discrete chunk of data and a bunch of useful, related methods for
  // performing computations and transformations on that data.

  // Create a new model with the specified attributes. A client id (`cid`)
  // is automatically generated and assigned for you.
  var Model = Backbone.Model = function(attributes, options) {
    var attrs = attributes || {};
    options || (options = {});
    this.cid = _.uniqueId('c');
    this.attributes = {};
    if (options.collection) this.collection = options.collection;
    if (options.parse) attrs = this.parse(attrs, options) || {};
    attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
    this.set(attrs, options);
    this.changed = {};
    this.initialize.apply(this, arguments);
  };

  // Attach all inheritable methods to the Model prototype.
  _.extend(Model.prototype, Events, {

    // A hash of attributes whose current and previous value differ.
    changed: null,

    // The value returned during the last failed validation.
    validationError: null,

    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
    // CouchDB users may want to set this to `"_id"`.
    idAttribute: 'id',

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Return a copy of the model's `attributes` object.
    toJSON: function(options) {
      return _.clone(this.attributes);
    },

    // Proxy `Backbone.sync` by default -- but override this if you need
    // custom syncing semantics for *this* particular model.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Get the value of an attribute.
    get: function(attr) {
      return this.attributes[attr];
    },

    // Get the HTML-escaped value of an attribute.
    escape: function(attr) {
      return _.escape(this.get(attr));
    },

    // Returns `true` if the attribute contains a value that is not null
    // or undefined.
    has: function(attr) {
      return this.get(attr) != null;
    },

    // Set a hash of model attributes on the object, firing `"change"`. This is
    // the core primitive operation of a model, updating the data and notifying
    // anyone who needs to know about the change in state. The heart of the beast.
    set: function(key, val, options) {
      var attr, attrs, unset, changes, silent, changing, prev, current;
      if (key == null) return this;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options || (options = {});

      // Run validation.
      if (!this._validate(attrs, options)) return false;

      // Extract attributes and options.
      unset           = options.unset;
      silent          = options.silent;
      changes         = [];
      changing        = this._changing;
      this._changing  = true;

      if (!changing) {
        this._previousAttributes = _.clone(this.attributes);
        this.changed = {};
      }
      current = this.attributes, prev = this._previousAttributes;

      // Check for changes of `id`.
      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

      // For each `set` attribute, update or delete the current value.
      for (attr in attrs) {
        val = attrs[attr];
        if (!_.isEqual(current[attr], val)) changes.push(attr);
        if (!_.isEqual(prev[attr], val)) {
          this.changed[attr] = val;
        } else {
          delete this.changed[attr];
        }
        unset ? delete current[attr] : current[attr] = val;
      }

      // Trigger all relevant attribute changes.
      if (!silent) {
        if (changes.length) this._pending = options;
        for (var i = 0, l = changes.length; i < l; i++) {
          this.trigger('change:' + changes[i], this, current[changes[i]], options);
        }
      }

      // You might be wondering why there's a `while` loop here. Changes can
      // be recursively nested within `"change"` events.
      if (changing) return this;
      if (!silent) {
        while (this._pending) {
          options = this._pending;
          this._pending = false;
          this.trigger('change', this, options);
        }
      }
      this._pending = false;
      this._changing = false;
      return this;
    },

    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
    // if the attribute doesn't exist.
    unset: function(attr, options) {
      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
    },

    // Clear all attributes on the model, firing `"change"`.
    clear: function(options) {
      var attrs = {};
      for (var key in this.attributes) attrs[key] = void 0;
      return this.set(attrs, _.extend({}, options, {unset: true}));
    },

    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
    hasChanged: function(attr) {
      if (attr == null) return !_.isEmpty(this.changed);
      return _.has(this.changed, attr);
    },

    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function(diff) {
      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
      var val, changed = false;
      var old = this._changing ? this._previousAttributes : this.attributes;
      for (var attr in diff) {
        if (_.isEqual(old[attr], (val = diff[attr]))) continue;
        (changed || (changed = {}))[attr] = val;
      }
      return changed;
    },

    // Get the previous value of an attribute, recorded at the time the last
    // `"change"` event was fired.
    previous: function(attr) {
      if (attr == null || !this._previousAttributes) return null;
      return this._previousAttributes[attr];
    },

    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
    previousAttributes: function() {
      return _.clone(this._previousAttributes);
    },

    // Fetch the model from the server. If the server's representation of the
    // model differs from its current attributes, they will be overridden,
    // triggering a `"change"` event.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        if (!model.set(model.parse(resp, options), options)) return false;
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function(key, val, options) {
      var attrs, method, xhr, attributes = this.attributes;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (key == null || typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options = _.extend({validate: true}, options);

      // If we're not waiting and attributes exist, save acts as
      // `set(attr).save(null, opts)` with validation. Otherwise, check if
      // the model will be valid when the attributes, if any, are set.
      if (attrs && !options.wait) {
        if (!this.set(attrs, options)) return false;
      } else {
        if (!this._validate(attrs, options)) return false;
      }

      // Set temporary attributes if `{wait: true}`.
      if (attrs && options.wait) {
        this.attributes = _.extend({}, attributes, attrs);
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        // Ensure attributes are restored during synchronous saves.
        model.attributes = attributes;
        var serverAttrs = model.parse(resp, options);
        if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
        if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
          return false;
        }
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);

      method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
      if (method === 'patch') options.attrs = attrs;
      xhr = this.sync(method, this, options);

      // Restore attributes.
      if (attrs && options.wait) this.attributes = attributes;

      return xhr;
    },

    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;

      var destroy = function() {
        model.trigger('destroy', model, model.collection, options);
      };

      options.success = function(resp) {
        if (options.wait || model.isNew()) destroy();
        if (success) success(model, resp, options);
        if (!model.isNew()) model.trigger('sync', model, resp, options);
      };

      if (this.isNew()) {
        options.success();
        return false;
      }
      wrapError(this, options);

      var xhr = this.sync('delete', this, options);
      if (!options.wait) destroy();
      return xhr;
    },

    // Default URL for the model's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function() {
      var base =
        _.result(this, 'urlRoot') ||
        _.result(this.collection, 'url') ||
        urlError();
      if (this.isNew()) return base;
      return base.replace(/([^\/])$/, '$1/') + encodeURIComponent(this.id);
    },

    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new model with identical attributes to this one.
    clone: function() {
      return new this.constructor(this.attributes);
    },

    // A model is new if it has never been saved to the server, and lacks an id.
    isNew: function() {
      return !this.has(this.idAttribute);
    },

    // Check if the model is currently in a valid state.
    isValid: function(options) {
      return this._validate({}, _.extend(options || {}, { validate: true }));
    },

    // Run validation against the next complete set of model attributes,
    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
    _validate: function(attrs, options) {
      if (!options.validate || !this.validate) return true;
      attrs = _.extend({}, this.attributes, attrs);
      var error = this.validationError = this.validate(attrs, options) || null;
      if (!error) return true;
      this.trigger('invalid', this, error, _.extend(options, {validationError: error}));
      return false;
    }

  });

  // Underscore methods that we want to implement on the Model.
  var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];

  // Mix in each Underscore method as a proxy to `Model#attributes`.
  _.each(modelMethods, function(method) {
    Model.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.attributes);
      return _[method].apply(_, args);
    };
  });

  // Backbone.Collection
  // -------------------

  // If models tend to represent a single row of data, a Backbone Collection is
  // more analagous to a table full of data ... or a small slice or page of that
  // table, or a collection of rows that belong together for a particular reason
  // -- all of the messages in this particular folder, all of the documents
  // belonging to this particular author, and so on. Collections maintain
  // indexes of their models, both in order, and for lookup by `id`.

  // Create a new **Collection**, perhaps to contain a specific type of `model`.
  // If a `comparator` is specified, the Collection will maintain
  // its models in sort order, as they're added and removed.
  var Collection = Backbone.Collection = function(models, options) {
    options || (options = {});
    if (options.model) this.model = options.model;
    if (options.comparator !== void 0) this.comparator = options.comparator;
    this._reset();
    this.initialize.apply(this, arguments);
    if (models) this.reset(models, _.extend({silent: true}, options));
  };

  // Default options for `Collection#set`.
  var setOptions = {add: true, remove: true, merge: true};
  var addOptions = {add: true, remove: false};

  // Define the Collection's inheritable methods.
  _.extend(Collection.prototype, Events, {

    // The default model for a collection is just a **Backbone.Model**.
    // This should be overridden in most cases.
    model: Model,

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // The JSON representation of a Collection is an array of the
    // models' attributes.
    toJSON: function(options) {
      return this.map(function(model){ return model.toJSON(options); });
    },

    // Proxy `Backbone.sync` by default.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Add a model, or list of models to the set.
    add: function(models, options) {
      return this.set(models, _.extend({merge: false}, options, addOptions));
    },

    // Remove a model, or a list of models from the set.
    remove: function(models, options) {
      var singular = !_.isArray(models);
      models = singular ? [models] : _.clone(models);
      options || (options = {});
      var i, l, index, model;
      for (i = 0, l = models.length; i < l; i++) {
        model = models[i] = this.get(models[i]);
        if (!model) continue;
        delete this._byId[model.id];
        delete this._byId[model.cid];
        index = this.indexOf(model);
        this.models.splice(index, 1);
        this.length--;
        if (!options.silent) {
          options.index = index;
          model.trigger('remove', model, this, options);
        }
        this._removeReference(model, options);
      }
      return singular ? models[0] : models;
    },

    // Update a collection by `set`-ing a new list of models, adding new ones,
    // removing models that are no longer present, and merging models that
    // already exist in the collection, as necessary. Similar to **Model#set**,
    // the core operation for updating the data contained by the collection.
    set: function(models, options) {
      options = _.defaults({}, options, setOptions);
      if (options.parse) models = this.parse(models, options);
      var singular = !_.isArray(models);
      models = singular ? (models ? [models] : []) : _.clone(models);
      var i, l, id, model, attrs, existing, sort;
      var at = options.at;
      var targetModel = this.model;
      var sortable = this.comparator && (at == null) && options.sort !== false;
      var sortAttr = _.isString(this.comparator) ? this.comparator : null;
      var toAdd = [], toRemove = [], modelMap = {};
      var add = options.add, merge = options.merge, remove = options.remove;
      var order = !sortable && add && remove ? [] : false;

      // Turn bare objects into model references, and prevent invalid models
      // from being added.
      for (i = 0, l = models.length; i < l; i++) {
        attrs = models[i] || {};
        if (attrs instanceof Model) {
          id = model = attrs;
        } else {
          id = attrs[targetModel.prototype.idAttribute || 'id'];
        }

        // If a duplicate is found, prevent it from being added and
        // optionally merge it into the existing model.
        if (existing = this.get(id)) {
          if (remove) modelMap[existing.cid] = true;
          if (merge) {
            attrs = attrs === model ? model.attributes : attrs;
            if (options.parse) attrs = existing.parse(attrs, options);
            existing.set(attrs, options);
            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
          }
          models[i] = existing;

        // If this is a new, valid model, push it to the `toAdd` list.
        } else if (add) {
          model = models[i] = this._prepareModel(attrs, options);
          if (!model) continue;
          toAdd.push(model);
          this._addReference(model, options);
        }

        // Do not add multiple models with the same `id`.
        model = existing || model;
        if (order && (model.isNew() || !modelMap[model.id])) order.push(model);
        modelMap[model.id] = true;
      }

      // Remove nonexistent models if appropriate.
      if (remove) {
        for (i = 0, l = this.length; i < l; ++i) {
          if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
        }
        if (toRemove.length) this.remove(toRemove, options);
      }

      // See if sorting is needed, update `length` and splice in new models.
      if (toAdd.length || (order && order.length)) {
        if (sortable) sort = true;
        this.length += toAdd.length;
        if (at != null) {
          for (i = 0, l = toAdd.length; i < l; i++) {
            this.models.splice(at + i, 0, toAdd[i]);
          }
        } else {
          if (order) this.models.length = 0;
          var orderedModels = order || toAdd;
          for (i = 0, l = orderedModels.length; i < l; i++) {
            this.models.push(orderedModels[i]);
          }
        }
      }

      // Silently sort the collection if appropriate.
      if (sort) this.sort({silent: true});

      // Unless silenced, it's time to fire all appropriate add/sort events.
      if (!options.silent) {
        for (i = 0, l = toAdd.length; i < l; i++) {
          (model = toAdd[i]).trigger('add', model, this, options);
        }
        if (sort || (order && order.length)) this.trigger('sort', this, options);
      }

      // Return the added (or merged) model (or models).
      return singular ? models[0] : models;
    },

    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any granular `add` or `remove` events. Fires `reset` when finished.
    // Useful for bulk operations and optimizations.
    reset: function(models, options) {
      options || (options = {});
      for (var i = 0, l = this.models.length; i < l; i++) {
        this._removeReference(this.models[i], options);
      }
      options.previousModels = this.models;
      this._reset();
      models = this.add(models, _.extend({silent: true}, options));
      if (!options.silent) this.trigger('reset', this, options);
      return models;
    },

    // Add a model to the end of the collection.
    push: function(model, options) {
      return this.add(model, _.extend({at: this.length}, options));
    },

    // Remove a model from the end of the collection.
    pop: function(options) {
      var model = this.at(this.length - 1);
      this.remove(model, options);
      return model;
    },

    // Add a model to the beginning of the collection.
    unshift: function(model, options) {
      return this.add(model, _.extend({at: 0}, options));
    },

    // Remove a model from the beginning of the collection.
    shift: function(options) {
      var model = this.at(0);
      this.remove(model, options);
      return model;
    },

    // Slice out a sub-array of models from the collection.
    slice: function() {
      return slice.apply(this.models, arguments);
    },

    // Get a model from the set by id.
    get: function(obj) {
      if (obj == null) return void 0;
      return this._byId[obj] || this._byId[obj.id] || this._byId[obj.cid];
    },

    // Get the model at the given index.
    at: function(index) {
      return this.models[index];
    },

    // Return models with matching attributes. Useful for simple cases of
    // `filter`.
    where: function(attrs, first) {
      if (_.isEmpty(attrs)) return first ? void 0 : [];
      return this[first ? 'find' : 'filter'](function(model) {
        for (var key in attrs) {
          if (attrs[key] !== model.get(key)) return false;
        }
        return true;
      });
    },

    // Return the first model with matching attributes. Useful for simple cases
    // of `find`.
    findWhere: function(attrs) {
      return this.where(attrs, true);
    },

    // Force the collection to re-sort itself. You don't need to call this under
    // normal circumstances, as the set will maintain sort order as each item
    // is added.
    sort: function(options) {
      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
      options || (options = {});

      // Run sort based on type of `comparator`.
      if (_.isString(this.comparator) || this.comparator.length === 1) {
        this.models = this.sortBy(this.comparator, this);
      } else {
        this.models.sort(_.bind(this.comparator, this));
      }

      if (!options.silent) this.trigger('sort', this, options);
      return this;
    },

    // Pluck an attribute from each model in the collection.
    pluck: function(attr) {
      return _.invoke(this.models, 'get', attr);
    },

    // Fetch the default set of models for this collection, resetting the
    // collection when they arrive. If `reset: true` is passed, the response
    // data will be passed through the `reset` method instead of `set`.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var success = options.success;
      var collection = this;
      options.success = function(resp) {
        var method = options.reset ? 'reset' : 'set';
        collection[method](resp, options);
        if (success) success(collection, resp, options);
        collection.trigger('sync', collection, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Create a new instance of a model in this collection. Add the model to the
    // collection immediately, unless `wait: true` is passed, in which case we
    // wait for the server to agree.
    create: function(model, options) {
      options = options ? _.clone(options) : {};
      if (!(model = this._prepareModel(model, options))) return false;
      if (!options.wait) this.add(model, options);
      var collection = this;
      var success = options.success;
      options.success = function(model, resp) {
        if (options.wait) collection.add(model, options);
        if (success) success(model, resp, options);
      };
      model.save(null, options);
      return model;
    },

    // **parse** converts a response into a list of models to be added to the
    // collection. The default implementation is just to pass it through.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new collection with an identical list of models as this one.
    clone: function() {
      return new this.constructor(this.models);
    },

    // Private method to reset all internal state. Called when the collection
    // is first initialized or reset.
    _reset: function() {
      this.length = 0;
      this.models = [];
      this._byId  = {};
    },

    // Prepare a hash of attributes (or other model) to be added to this
    // collection.
    _prepareModel: function(attrs, options) {
      if (attrs instanceof Model) return attrs;
      options = options ? _.clone(options) : {};
      options.collection = this;
      var model = new this.model(attrs, options);
      if (!model.validationError) return model;
      this.trigger('invalid', this, model.validationError, options);
      return false;
    },

    // Internal method to create a model's ties to a collection.
    _addReference: function(model, options) {
      this._byId[model.cid] = model;
      if (model.id != null) this._byId[model.id] = model;
      if (!model.collection) model.collection = this;
      model.on('all', this._onModelEvent, this);
    },

    // Internal method to sever a model's ties to a collection.
    _removeReference: function(model, options) {
      if (this === model.collection) delete model.collection;
      model.off('all', this._onModelEvent, this);
    },

    // Internal method called every time a model in the set fires an event.
    // Sets need to update their indexes when models change ids. All other
    // events simply proxy through. "add" and "remove" events that originate
    // in other collections are ignored.
    _onModelEvent: function(event, model, collection, options) {
      if ((event === 'add' || event === 'remove') && collection !== this) return;
      if (event === 'destroy') this.remove(model, options);
      if (model && event === 'change:' + model.idAttribute) {
        delete this._byId[model.previous(model.idAttribute)];
        if (model.id != null) this._byId[model.id] = model;
      }
      this.trigger.apply(this, arguments);
    }

  });

  // Underscore methods that we want to implement on the Collection.
  // 90% of the core usefulness of Backbone Collections is actually implemented
  // right here:
  var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',
    'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',
    'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',
    'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',
    'tail', 'drop', 'last', 'without', 'difference', 'indexOf', 'shuffle',
    'lastIndexOf', 'isEmpty', 'chain', 'sample'];

  // Mix in each Underscore method as a proxy to `Collection#models`.
  _.each(methods, function(method) {
    Collection.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.models);
      return _[method].apply(_, args);
    };
  });

  // Underscore methods that take a property name as an argument.
  var attributeMethods = ['groupBy', 'countBy', 'sortBy', 'indexBy'];

  // Use attributes instead of properties.
  _.each(attributeMethods, function(method) {
    Collection.prototype[method] = function(value, context) {
      var iterator = _.isFunction(value) ? value : function(model) {
        return model.get(value);
      };
      return _[method](this.models, iterator, context);
    };
  });

  // Backbone.View
  // -------------

  // Backbone Views are almost more convention than they are actual code. A View
  // is simply a JavaScript object that represents a logical chunk of UI in the
  // DOM. This might be a single item, an entire list, a sidebar or panel, or
  // even the surrounding frame which wraps your whole app. Defining a chunk of
  // UI as a **View** allows you to define your DOM events declaratively, without
  // having to worry about render order ... and makes it easy for the view to
  // react to specific changes in the state of your models.

  // Creating a Backbone.View creates its initial element outside of the DOM,
  // if an existing element is not provided...
  var View = Backbone.View = function(options) {
    this.cid = _.uniqueId('view');
    options || (options = {});
    _.extend(this, _.pick(options, viewOptions));
    this._ensureElement();
    this.initialize.apply(this, arguments);
    this.delegateEvents();
  };

  // Cached regex to split keys for `delegate`.
  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

  // List of view options to be merged as properties.
  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

  // Set up all inheritable **Backbone.View** properties and methods.
  _.extend(View.prototype, Events, {

    // The default `tagName` of a View's element is `"div"`.
    tagName: 'div',

    // jQuery delegate for element lookup, scoped to DOM elements within the
    // current view. This should be preferred to global lookups where possible.
    $: function(selector) {
      return this.$el.find(selector);
    },

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // **render** is the core function that your view should override, in order
    // to populate its element (`this.el`), with the appropriate HTML. The
    // convention is for **render** to always return `this`.
    render: function() {
      return this;
    },

    // Remove this view by taking the element out of the DOM, and removing any
    // applicable Backbone.Events listeners.
    remove: function() {
      this.$el.remove();
      this.stopListening();
      return this;
    },

    // Change the view's element (`this.el` property), including event
    // re-delegation.
    setElement: function(element, delegate) {
      if (this.$el) this.undelegateEvents();
      this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
      this.el = this.$el[0];
      if (delegate !== false) this.delegateEvents();
      return this;
    },

    // Set callbacks, where `this.events` is a hash of
    //
    // *{"event selector": "callback"}*
    //
    //     {
    //       'mousedown .title':  'edit',
    //       'click .button':     'save',
    //       'click .open':       function(e) { ... }
    //     }
    //
    // pairs. Callbacks will be bound to the view, with `this` set properly.
    // Uses event delegation for efficiency.
    // Omitting the selector binds the event to `this.el`.
    // This only works for delegate-able events: not `focus`, `blur`, and
    // not `change`, `submit`, and `reset` in Internet Explorer.
    delegateEvents: function(events) {
      if (!(events || (events = _.result(this, 'events')))) return this;
      this.undelegateEvents();
      for (var key in events) {
        var method = events[key];
        if (!_.isFunction(method)) method = this[events[key]];
        if (!method) continue;

        var match = key.match(delegateEventSplitter);
        var eventName = match[1], selector = match[2];
        method = _.bind(method, this);
        eventName += '.delegateEvents' + this.cid;
        if (selector === '') {
          this.$el.on(eventName, method);
        } else {
          this.$el.on(eventName, selector, method);
        }
      }
      return this;
    },

    // Clears all callbacks previously bound to the view with `delegateEvents`.
    // You usually don't need to use this, but may wish to if you have multiple
    // Backbone views attached to the same DOM element.
    undelegateEvents: function() {
      this.$el.off('.delegateEvents' + this.cid);
      return this;
    },

    // Ensure that the View has a DOM element to render into.
    // If `this.el` is a string, pass it through `$()`, take the first
    // matching element, and re-assign it to `el`. Otherwise, create
    // an element from the `id`, `className` and `tagName` properties.
    _ensureElement: function() {
      if (!this.el) {
        var attrs = _.extend({}, _.result(this, 'attributes'));
        if (this.id) attrs.id = _.result(this, 'id');
        if (this.className) attrs['class'] = _.result(this, 'className');
        var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);
        this.setElement($el, false);
      } else {
        this.setElement(_.result(this, 'el'), false);
      }
    }

  });

  // Backbone.sync
  // -------------

  // Override this function to change the manner in which Backbone persists
  // models to the server. You will be passed the type of request, and the
  // model in question. By default, makes a RESTful Ajax request
  // to the model's `url()`. Some possible customizations could be:
  //
  // * Use `setTimeout` to batch rapid-fire updates into a single request.
  // * Send up the models as XML instead of JSON.
  // * Persist models via WebSockets instead of Ajax.
  //
  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
  // as `POST`, with a `_method` parameter containing the true HTTP method,
  // as well as all requests with the body as `application/x-www-form-urlencoded`
  // instead of `application/json` with the model in a param named `model`.
  // Useful when interfacing with server-side languages like **PHP** that make
  // it difficult to read the body of `PUT` requests.
  Backbone.sync = function(method, model, options) {
    var type = methodMap[method];

    // Default options, unless specified.
    _.defaults(options || (options = {}), {
      emulateHTTP: Backbone.emulateHTTP,
      emulateJSON: Backbone.emulateJSON
    });

    // Default JSON-request options.
    var params = {type: type, dataType: 'json'};

    // Ensure that we have a URL.
    if (!options.url) {
      params.url = _.result(model, 'url') || urlError();
    }

    // Ensure that we have the appropriate request data.
    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(options.attrs || model.toJSON(options));
    }

    // For older servers, emulate JSON by encoding the request into an HTML-form.
    if (options.emulateJSON) {
      params.contentType = 'application/x-www-form-urlencoded';
      params.data = params.data ? {model: params.data} : {};
    }

    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
    // And an `X-HTTP-Method-Override` header.
    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
      params.type = 'POST';
      if (options.emulateJSON) params.data._method = type;
      var beforeSend = options.beforeSend;
      options.beforeSend = function(xhr) {
        xhr.setRequestHeader('X-HTTP-Method-Override', type);
        if (beforeSend) return beforeSend.apply(this, arguments);
      };
    }

    // Don't process data on a non-GET request.
    if (params.type !== 'GET' && !options.emulateJSON) {
      params.processData = false;
    }

    // If we're sending a `PATCH` request, and we're in an old Internet Explorer
    // that still has ActiveX enabled by default, override jQuery to use that
    // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.
    if (params.type === 'PATCH' && noXhrPatch) {
      params.xhr = function() {
        return new ActiveXObject("Microsoft.XMLHTTP");
      };
    }

    // Make the request, allowing the user to override any Ajax options.
    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
    model.trigger('request', model, xhr, options);
    return xhr;
  };

  var noXhrPatch =
    typeof window !== 'undefined' && !!window.ActiveXObject &&
      !(window.XMLHttpRequest && (new XMLHttpRequest).dispatchEvent);

  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'patch':  'PATCH',
    'delete': 'DELETE',
    'read':   'GET'
  };

  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
  // Override this if you'd like to use a different library.
  Backbone.ajax = function() {
    return Backbone.$.ajax.apply(Backbone.$, arguments);
  };

  // Backbone.Router
  // ---------------

  // Routers map faux-URLs to actions, and fire events when routes are
  // matched. Creating a new one sets its `routes` hash, if not set statically.
  var Router = Backbone.Router = function(options) {
    options || (options = {});
    if (options.routes) this.routes = options.routes;
    this._bindRoutes();
    this.initialize.apply(this, arguments);
  };

  // Cached regular expressions for matching named param parts and splatted
  // parts of route strings.
  var optionalParam = /\((.*?)\)/g;
  var namedParam    = /(\(\?)?:\w+/g;
  var splatParam    = /\*\w+/g;
  var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

  // Set up all inheritable **Backbone.Router** properties and methods.
  _.extend(Router.prototype, Events, {

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Manually bind a single named route to a callback. For example:
    //
    //     this.route('search/:query/p:num', 'search', function(query, num) {
    //       ...
    //     });
    //
    route: function(route, name, callback) {
      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
      if (_.isFunction(name)) {
        callback = name;
        name = '';
      }
      if (!callback) callback = this[name];
      var router = this;
      Backbone.history.route(route, function(fragment) {
        var args = router._extractParameters(route, fragment);
        router.execute(callback, args);
        router.trigger.apply(router, ['route:' + name].concat(args));
        router.trigger('route', name, args);
        Backbone.history.trigger('route', router, name, args);
      });
      return this;
    },

    // Execute a route handler with the provided parameters.  This is an
    // excellent place to do pre-route setup or post-route cleanup.
    execute: function(callback, args) {
      if (callback) callback.apply(this, args);
    },

    // Simple proxy to `Backbone.history` to save a fragment into the history.
    navigate: function(fragment, options) {
      Backbone.history.navigate(fragment, options);
      return this;
    },

    // Bind all defined routes to `Backbone.history`. We have to reverse the
    // order of the routes here to support behavior where the most general
    // routes can be defined at the bottom of the route map.
    _bindRoutes: function() {
      if (!this.routes) return;
      this.routes = _.result(this, 'routes');
      var route, routes = _.keys(this.routes);
      while ((route = routes.pop()) != null) {
        this.route(route, this.routes[route]);
      }
    },

    // Convert a route string into a regular expression, suitable for matching
    // against the current location hash.
    _routeToRegExp: function(route) {
      route = route.replace(escapeRegExp, '\\$&')
                   .replace(optionalParam, '(?:$1)?')
                   .replace(namedParam, function(match, optional) {
                     return optional ? match : '([^/?]+)';
                   })
                   .replace(splatParam, '([^?]*?)');
      return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
    },

    // Given a route, and a URL fragment that it matches, return the array of
    // extracted decoded parameters. Empty or unmatched parameters will be
    // treated as `null` to normalize cross-browser behavior.
    _extractParameters: function(route, fragment) {
      var params = route.exec(fragment).slice(1);
      return _.map(params, function(param, i) {
        // Don't decode the search params.
        if (i === params.length - 1) return param || null;
        return param ? decodeURIComponent(param) : null;
      });
    }

  });

  // Backbone.History
  // ----------------

  // Handles cross-browser history management, based on either
  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
  // and URL fragments. If the browser supports neither (old IE, natch),
  // falls back to polling.
  var History = Backbone.History = function() {
    this.handlers = [];
    _.bindAll(this, 'checkUrl');

    // Ensure that `History` can be used outside of the browser.
    if (typeof window !== 'undefined') {
      this.location = window.location;
      this.history = window.history;
    }
  };

  // Cached regex for stripping a leading hash/slash and trailing space.
  var routeStripper = /^[#\/]|\s+$/g;

  // Cached regex for stripping leading and trailing slashes.
  var rootStripper = /^\/+|\/+$/g;

  // Cached regex for detecting MSIE.
  var isExplorer = /msie [\w.]+/;

  // Cached regex for removing a trailing slash.
  var trailingSlash = /\/$/;

  // Cached regex for stripping urls of hash.
  var pathStripper = /#.*$/;

  // Has the history handling already been started?
  History.started = false;

  // Set up all inheritable **Backbone.History** properties and methods.
  _.extend(History.prototype, Events, {

    // The default interval to poll for hash changes, if necessary, is
    // twenty times a second.
    interval: 50,

    // Are we at the app root?
    atRoot: function() {
      return this.location.pathname.replace(/[^\/]$/, '$&/') === this.root;
    },

    // Gets the true hash value. Cannot use location.hash directly due to bug
    // in Firefox where location.hash will always be decoded.
    getHash: function(window) {
      var match = (window || this).location.href.match(/#(.*)$/);
      return match ? match[1] : '';
    },

    // Get the cross-browser normalized URL fragment, either from the URL,
    // the hash, or the override.
    getFragment: function(fragment, forcePushState) {
      if (fragment == null) {
        if (this._hasPushState || !this._wantsHashChange || forcePushState) {
          fragment = decodeURI(this.location.pathname + this.location.search);
          var root = this.root.replace(trailingSlash, '');
          if (!fragment.indexOf(root)) fragment = fragment.slice(root.length);
        } else {
          fragment = this.getHash();
        }
      }
      return fragment.replace(routeStripper, '');
    },

    // Start the hash change handling, returning `true` if the current URL matches
    // an existing route, and `false` otherwise.
    start: function(options) {
      if (History.started) throw new Error("Backbone.history has already been started");
      History.started = true;

      // Figure out the initial configuration. Do we need an iframe?
      // Is pushState desired ... is it available?
      this.options          = _.extend({root: '/'}, this.options, options);
      this.root             = this.options.root;
      this._wantsHashChange = this.options.hashChange !== false;
      this._wantsPushState  = !!this.options.pushState;
      this._hasPushState    = !!(this.options.pushState && this.history && this.history.pushState);
      var fragment          = this.getFragment();
      var docMode           = document.documentMode;
      var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));

      // Normalize root to always include a leading and trailing slash.
      this.root = ('/' + this.root + '/').replace(rootStripper, '/');

      if (oldIE && this._wantsHashChange) {
        var frame = Backbone.$('<iframe src="javascript:0" tabindex="-1">');
        this.iframe = frame.hide().appendTo('body')[0].contentWindow;
        this.navigate(fragment);
      }

      // Depending on whether we're using pushState or hashes, and whether
      // 'onhashchange' is supported, determine how we check the URL state.
      if (this._hasPushState) {
        Backbone.$(window).on('popstate', this.checkUrl);
      } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {
        Backbone.$(window).on('hashchange', this.checkUrl);
      } else if (this._wantsHashChange) {
        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
      }

      // Determine if we need to change the base url, for a pushState link
      // opened by a non-pushState browser.
      this.fragment = fragment;
      var loc = this.location;

      // Transition from hashChange to pushState or vice versa if both are
      // requested.
      if (this._wantsHashChange && this._wantsPushState) {

        // If we've started off with a route from a `pushState`-enabled
        // browser, but we're currently in a browser that doesn't support it...
        if (!this._hasPushState && !this.atRoot()) {
          this.fragment = this.getFragment(null, true);
          this.location.replace(this.root + '#' + this.fragment);
          // Return immediately as browser will do redirect to new url
          return true;

        // Or if we've started out with a hash-based route, but we're currently
        // in a browser where it could be `pushState`-based instead...
        } else if (this._hasPushState && this.atRoot() && loc.hash) {
          this.fragment = this.getHash().replace(routeStripper, '');
          this.history.replaceState({}, document.title, this.root + this.fragment);
        }

      }

      if (!this.options.silent) return this.loadUrl();
    },

    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
    // but possibly useful for unit testing Routers.
    stop: function() {
      Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);
      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);
      History.started = false;
    },

    // Add a route to be tested when the fragment changes. Routes added later
    // may override previous routes.
    route: function(route, callback) {
      this.handlers.unshift({route: route, callback: callback});
    },

    // Checks the current URL to see if it has changed, and if it has,
    // calls `loadUrl`, normalizing across the hidden iframe.
    checkUrl: function(e) {
      var current = this.getFragment();
      if (current === this.fragment && this.iframe) {
        current = this.getFragment(this.getHash(this.iframe));
      }
      if (current === this.fragment) return false;
      if (this.iframe) this.navigate(current);
      this.loadUrl();
    },

    // Attempt to load the current URL fragment. If a route succeeds with a
    // match, returns `true`. If no defined routes matches the fragment,
    // returns `false`.
    loadUrl: function(fragment) {
      fragment = this.fragment = this.getFragment(fragment);
      return _.any(this.handlers, function(handler) {
        if (handler.route.test(fragment)) {
          handler.callback(fragment);
          return true;
        }
      });
    },

    // Save a fragment into the hash history, or replace the URL state if the
    // 'replace' option is passed. You are responsible for properly URL-encoding
    // the fragment in advance.
    //
    // The options object can contain `trigger: true` if you wish to have the
    // route callback be fired (not usually desirable), or `replace: true`, if
    // you wish to modify the current URL without adding an entry to the history.
    navigate: function(fragment, options) {
      if (!History.started) return false;
      if (!options || options === true) options = {trigger: !!options};

      var url = this.root + (fragment = this.getFragment(fragment || ''));

      // Strip the hash for matching.
      fragment = fragment.replace(pathStripper, '');

      if (this.fragment === fragment) return;
      this.fragment = fragment;

      // Don't include a trailing slash on the root.
      if (fragment === '' && url !== '/') url = url.slice(0, -1);

      // If pushState is available, we use it to set the fragment as a real URL.
      if (this._hasPushState) {
        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

      // If hash changes haven't been explicitly disabled, update the hash
      // fragment to store history.
      } else if (this._wantsHashChange) {
        this._updateHash(this.location, fragment, options.replace);
        if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {
          // Opening and closing the iframe tricks IE7 and earlier to push a
          // history entry on hash-tag change.  When replace is true, we don't
          // want this.
          if(!options.replace) this.iframe.document.open().close();
          this._updateHash(this.iframe.location, fragment, options.replace);
        }

      // If you've told us that you explicitly don't want fallback hashchange-
      // based history, then `navigate` becomes a page refresh.
      } else {
        return this.location.assign(url);
      }
      if (options.trigger) return this.loadUrl(fragment);
    },

    // Update the hash location, either replacing the current entry, or adding
    // a new one to the browser history.
    _updateHash: function(location, fragment, replace) {
      if (replace) {
        var href = location.href.replace(/(javascript:|#).*$/, '');
        location.replace(href + '#' + fragment);
      } else {
        // Some browsers require that `hash` contains a leading #.
        location.hash = '#' + fragment;
      }
    }

  });

  // Create the default Backbone.history.
  Backbone.history = new History;

  // Helpers
  // -------

  // Helper function to correctly set up the prototype chain, for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.
  var extend = function(protoProps, staticProps) {
    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ return parent.apply(this, arguments); };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    var Surrogate = function(){ this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) _.extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  // Set up inheritance for the model, collection, router, view and history.
  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

  // Throw an error when a URL is needed, and none is supplied.
  var urlError = function() {
    throw new Error('A "url" property or function must be specified');
  };

  // Wrap an optional error callback with a fallback error event.
  var wrapError = function(model, options) {
    var error = options.error;
    options.error = function(resp) {
      if (error) error(model, resp, options);
      model.trigger('error', model, resp, options);
    };
  };

  return Backbone;

}));

},{"underscore":159}],134:[function(require,module,exports){
/*
 * jQuery File Upload Plugin 5.40.1
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2010, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/* jshint nomen:false */
/* global define, window, document, location, Blob, FormData */

(function (factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define([
            'jquery',
            'jquery.ui.widget'
        ], factory);
    } else {
        // Browser globals:
        factory(window.jQuery);
    }
}(function ($) {
    'use strict';

    // Detect file input support, based on
    // http://viljamis.com/blog/2012/file-upload-support-on-mobile/
    $.support.fileInput = !(new RegExp(
        // Handle devices which give false positives for the feature detection:
        '(Android (1\\.[0156]|2\\.[01]))' +
            '|(Windows Phone (OS 7|8\\.0))|(XBLWP)|(ZuneWP)|(WPDesktop)' +
            '|(w(eb)?OSBrowser)|(webOS)' +
            '|(Kindle/(1\\.0|2\\.[05]|3\\.0))'
    ).test(window.navigator.userAgent) ||
        // Feature detection for all other devices:
        $('<input type="file">').prop('disabled'));

    // The FileReader API is not actually used, but works as feature detection,
    // as some Safari versions (5?) support XHR file uploads via the FormData API,
    // but not non-multipart XHR file uploads.
    // window.XMLHttpRequestUpload is not available on IE10, so we check for
    // window.ProgressEvent instead to detect XHR2 file upload capability:
    $.support.xhrFileUpload = !!(window.ProgressEvent && window.FileReader);
    $.support.xhrFormDataFileUpload = !!window.FormData;

    // Detect support for Blob slicing (required for chunked uploads):
    $.support.blobSlice = window.Blob && (Blob.prototype.slice ||
        Blob.prototype.webkitSlice || Blob.prototype.mozSlice);

    // The fileupload widget listens for change events on file input fields defined
    // via fileInput setting and paste or drop events of the given dropZone.
    // In addition to the default jQuery Widget methods, the fileupload widget
    // exposes the "add" and "send" methods, to add or directly send files using
    // the fileupload API.
    // By default, files added via file input selection, paste, drag & drop or
    // "add" method are uploaded immediately, but it is possible to override
    // the "add" callback option to queue file uploads.
    $.widget('blueimp.fileupload', {

        options: {
            // The drop target element(s), by the default the complete document.
            // Set to null to disable drag & drop support:
            dropZone: $(document),
            // The paste target element(s), by the default the complete document.
            // Set to null to disable paste support:
            pasteZone: $(document),
            // The file input field(s), that are listened to for change events.
            // If undefined, it is set to the file input fields inside
            // of the widget element on plugin initialization.
            // Set to null to disable the change listener.
            fileInput: undefined,
            // By default, the file input field is replaced with a clone after
            // each input field change event. This is required for iframe transport
            // queues and allows change events to be fired for the same file
            // selection, but can be disabled by setting the following option to false:
            replaceFileInput: true,
            // The parameter name for the file form data (the request argument name).
            // If undefined or empty, the name property of the file input field is
            // used, or "files[]" if the file input name property is also empty,
            // can be a string or an array of strings:
            paramName: undefined,
            // By default, each file of a selection is uploaded using an individual
            // request for XHR type uploads. Set to false to upload file
            // selections in one request each:
            singleFileUploads: true,
            // To limit the number of files uploaded with one XHR request,
            // set the following option to an integer greater than 0:
            limitMultiFileUploads: undefined,
            // The following option limits the number of files uploaded with one
            // XHR request to keep the request size under or equal to the defined
            // limit in bytes:
            limitMultiFileUploadSize: undefined,
            // Multipart file uploads add a number of bytes to each uploaded file,
            // therefore the following option adds an overhead for each file used
            // in the limitMultiFileUploadSize configuration:
            limitMultiFileUploadSizeOverhead: 512,
            // Set the following option to true to issue all file upload requests
            // in a sequential order:
            sequentialUploads: false,
            // To limit the number of concurrent uploads,
            // set the following option to an integer greater than 0:
            limitConcurrentUploads: undefined,
            // Set the following option to true to force iframe transport uploads:
            forceIframeTransport: false,
            // Set the following option to the location of a redirect url on the
            // origin server, for cross-domain iframe transport uploads:
            redirect: undefined,
            // The parameter name for the redirect url, sent as part of the form
            // data and set to 'redirect' if this option is empty:
            redirectParamName: undefined,
            // Set the following option to the location of a postMessage window,
            // to enable postMessage transport uploads:
            postMessage: undefined,
            // By default, XHR file uploads are sent as multipart/form-data.
            // The iframe transport is always using multipart/form-data.
            // Set to false to enable non-multipart XHR uploads:
            multipart: true,
            // To upload large files in smaller chunks, set the following option
            // to a preferred maximum chunk size. If set to 0, null or undefined,
            // or the browser does not support the required Blob API, files will
            // be uploaded as a whole.
            maxChunkSize: undefined,
            // When a non-multipart upload or a chunked multipart upload has been
            // aborted, this option can be used to resume the upload by setting
            // it to the size of the already uploaded bytes. This option is most
            // useful when modifying the options object inside of the "add" or
            // "send" callbacks, as the options are cloned for each file upload.
            uploadedBytes: undefined,
            // By default, failed (abort or error) file uploads are removed from the
            // global progress calculation. Set the following option to false to
            // prevent recalculating the global progress data:
            recalculateProgress: true,
            // Interval in milliseconds to calculate and trigger progress events:
            progressInterval: 100,
            // Interval in milliseconds to calculate progress bitrate:
            bitrateInterval: 500,
            // By default, uploads are started automatically when adding files:
            autoUpload: true,

            // Error and info messages:
            messages: {
                uploadedBytes: 'Uploaded bytes exceed file size'
            },

            // Translation function, gets the message key to be translated
            // and an object with context specific data as arguments:
            i18n: function (message, context) {
                message = this.messages[message] || message.toString();
                if (context) {
                    $.each(context, function (key, value) {
                        message = message.replace('{' + key + '}', value);
                    });
                }
                return message;
            },

            // Additional form data to be sent along with the file uploads can be set
            // using this option, which accepts an array of objects with name and
            // value properties, a function returning such an array, a FormData
            // object (for XHR file uploads), or a simple object.
            // The form of the first fileInput is given as parameter to the function:
            formData: function (form) {
                return form.serializeArray();
            },

            // The add callback is invoked as soon as files are added to the fileupload
            // widget (via file input selection, drag & drop, paste or add API call).
            // If the singleFileUploads option is enabled, this callback will be
            // called once for each file in the selection for XHR file uploads, else
            // once for each file selection.
            //
            // The upload starts when the submit method is invoked on the data parameter.
            // The data object contains a files property holding the added files
            // and allows you to override plugin options as well as define ajax settings.
            //
            // Listeners for this callback can also be bound the following way:
            // .bind('fileuploadadd', func);
            //
            // data.submit() returns a Promise object and allows to attach additional
            // handlers using jQuery's Deferred callbacks:
            // data.submit().done(func).fail(func).always(func);
            add: function (e, data) {
                if (e.isDefaultPrevented()) {
                    return false;
                }
                if (data.autoUpload || (data.autoUpload !== false &&
                        $(this).fileupload('option', 'autoUpload'))) {
                    data.process().done(function () {
                        data.submit();
                    });
                }
            },

            // Other callbacks:

            // Callback for the submit event of each file upload:
            // submit: function (e, data) {}, // .bind('fileuploadsubmit', func);

            // Callback for the start of each file upload request:
            // send: function (e, data) {}, // .bind('fileuploadsend', func);

            // Callback for successful uploads:
            // done: function (e, data) {}, // .bind('fileuploaddone', func);

            // Callback for failed (abort or error) uploads:
            // fail: function (e, data) {}, // .bind('fileuploadfail', func);

            // Callback for completed (success, abort or error) requests:
            // always: function (e, data) {}, // .bind('fileuploadalways', func);

            // Callback for upload progress events:
            // progress: function (e, data) {}, // .bind('fileuploadprogress', func);

            // Callback for global upload progress events:
            // progressall: function (e, data) {}, // .bind('fileuploadprogressall', func);

            // Callback for uploads start, equivalent to the global ajaxStart event:
            // start: function (e) {}, // .bind('fileuploadstart', func);

            // Callback for uploads stop, equivalent to the global ajaxStop event:
            // stop: function (e) {}, // .bind('fileuploadstop', func);

            // Callback for change events of the fileInput(s):
            // change: function (e, data) {}, // .bind('fileuploadchange', func);

            // Callback for paste events to the pasteZone(s):
            // paste: function (e, data) {}, // .bind('fileuploadpaste', func);

            // Callback for drop events of the dropZone(s):
            // drop: function (e, data) {}, // .bind('fileuploaddrop', func);

            // Callback for dragover events of the dropZone(s):
            // dragover: function (e) {}, // .bind('fileuploaddragover', func);

            // Callback for the start of each chunk upload request:
            // chunksend: function (e, data) {}, // .bind('fileuploadchunksend', func);

            // Callback for successful chunk uploads:
            // chunkdone: function (e, data) {}, // .bind('fileuploadchunkdone', func);

            // Callback for failed (abort or error) chunk uploads:
            // chunkfail: function (e, data) {}, // .bind('fileuploadchunkfail', func);

            // Callback for completed (success, abort or error) chunk upload requests:
            // chunkalways: function (e, data) {}, // .bind('fileuploadchunkalways', func);

            // The plugin options are used as settings object for the ajax calls.
            // The following are jQuery ajax settings required for the file uploads:
            processData: false,
            contentType: false,
            cache: false
        },

        // A list of options that require reinitializing event listeners and/or
        // special initialization code:
        _specialOptions: [
            'fileInput',
            'dropZone',
            'pasteZone',
            'multipart',
            'forceIframeTransport'
        ],

        _blobSlice: $.support.blobSlice && function () {
            var slice = this.slice || this.webkitSlice || this.mozSlice;
            return slice.apply(this, arguments);
        },

        _BitrateTimer: function () {
            this.timestamp = ((Date.now) ? Date.now() : (new Date()).getTime());
            this.loaded = 0;
            this.bitrate = 0;
            this.getBitrate = function (now, loaded, interval) {
                var timeDiff = now - this.timestamp;
                if (!this.bitrate || !interval || timeDiff > interval) {
                    this.bitrate = (loaded - this.loaded) * (1000 / timeDiff) * 8;
                    this.loaded = loaded;
                    this.timestamp = now;
                }
                return this.bitrate;
            };
        },

        _isXHRUpload: function (options) {
            return !options.forceIframeTransport &&
                ((!options.multipart && $.support.xhrFileUpload) ||
                $.support.xhrFormDataFileUpload);
        },

        _getFormData: function (options) {
            var formData;
            if ($.type(options.formData) === 'function') {
                return options.formData(options.form);
            }
            if ($.isArray(options.formData)) {
                return options.formData;
            }
            if ($.type(options.formData) === 'object') {
                formData = [];
                $.each(options.formData, function (name, value) {
                    formData.push({name: name, value: value});
                });
                return formData;
            }
            return [];
        },

        _getTotal: function (files) {
            var total = 0;
            $.each(files, function (index, file) {
                total += file.size || 1;
            });
            return total;
        },

        _initProgressObject: function (obj) {
            var progress = {
                loaded: 0,
                total: 0,
                bitrate: 0
            };
            if (obj._progress) {
                $.extend(obj._progress, progress);
            } else {
                obj._progress = progress;
            }
        },

        _initResponseObject: function (obj) {
            var prop;
            if (obj._response) {
                for (prop in obj._response) {
                    if (obj._response.hasOwnProperty(prop)) {
                        delete obj._response[prop];
                    }
                }
            } else {
                obj._response = {};
            }
        },

        _onProgress: function (e, data) {
            if (e.lengthComputable) {
                var now = ((Date.now) ? Date.now() : (new Date()).getTime()),
                    loaded;
                if (data._time && data.progressInterval &&
                        (now - data._time < data.progressInterval) &&
                        e.loaded !== e.total) {
                    return;
                }
                data._time = now;
                loaded = Math.floor(
                    e.loaded / e.total * (data.chunkSize || data._progress.total)
                ) + (data.uploadedBytes || 0);
                // Add the difference from the previously loaded state
                // to the global loaded counter:
                this._progress.loaded += (loaded - data._progress.loaded);
                this._progress.bitrate = this._bitrateTimer.getBitrate(
                    now,
                    this._progress.loaded,
                    data.bitrateInterval
                );
                data._progress.loaded = data.loaded = loaded;
                data._progress.bitrate = data.bitrate = data._bitrateTimer.getBitrate(
                    now,
                    loaded,
                    data.bitrateInterval
                );
                // Trigger a custom progress event with a total data property set
                // to the file size(s) of the current upload and a loaded data
                // property calculated accordingly:
                this._trigger(
                    'progress',
                    $.Event('progress', {delegatedEvent: e}),
                    data
                );
                // Trigger a global progress event for all current file uploads,
                // including ajax calls queued for sequential file uploads:
                this._trigger(
                    'progressall',
                    $.Event('progressall', {delegatedEvent: e}),
                    this._progress
                );
            }
        },

        _initProgressListener: function (options) {
            var that = this,
                xhr = options.xhr ? options.xhr() : $.ajaxSettings.xhr();
            // Accesss to the native XHR object is required to add event listeners
            // for the upload progress event:
            if (xhr.upload) {
                $(xhr.upload).bind('progress', function (e) {
                    var oe = e.originalEvent;
                    // Make sure the progress event properties get copied over:
                    e.lengthComputable = oe.lengthComputable;
                    e.loaded = oe.loaded;
                    e.total = oe.total;
                    that._onProgress(e, options);
                });
                options.xhr = function () {
                    return xhr;
                };
            }
        },

        _isInstanceOf: function (type, obj) {
            // Cross-frame instanceof check
            return Object.prototype.toString.call(obj) === '[object ' + type + ']';
        },

        _initXHRData: function (options) {
            var that = this,
                formData,
                file = options.files[0],
                // Ignore non-multipart setting if not supported:
                multipart = options.multipart || !$.support.xhrFileUpload,
                paramName = $.type(options.paramName) === 'array' ?
                    options.paramName[0] : options.paramName;
            options.headers = $.extend({}, options.headers);
            if (options.contentRange) {
                options.headers['Content-Range'] = options.contentRange;
            }
            if (!multipart || options.blob || !this._isInstanceOf('File', file)) {
                options.headers['Content-Disposition'] = 'attachment; filename="' +
                    encodeURI(file.name) + '"';
            }
            if (!multipart) {
                options.contentType = file.type || 'application/octet-stream';
                options.data = options.blob || file;
            } else if ($.support.xhrFormDataFileUpload) {
                if (options.postMessage) {
                    // window.postMessage does not allow sending FormData
                    // objects, so we just add the File/Blob objects to
                    // the formData array and let the postMessage window
                    // create the FormData object out of this array:
                    formData = this._getFormData(options);
                    if (options.blob) {
                        formData.push({
                            name: paramName,
                            value: options.blob
                        });
                    } else {
                        $.each(options.files, function (index, file) {
                            formData.push({
                                name: ($.type(options.paramName) === 'array' &&
                                    options.paramName[index]) || paramName,
                                value: file
                            });
                        });
                    }
                } else {
                    if (that._isInstanceOf('FormData', options.formData)) {
                        formData = options.formData;
                    } else {
                        formData = new FormData();
                        $.each(this._getFormData(options), function (index, field) {
                            formData.append(field.name, field.value);
                        });
                    }
                    if (options.blob) {
                        formData.append(paramName, options.blob, file.name);
                    } else {
                        $.each(options.files, function (index, file) {
                            // This check allows the tests to run with
                            // dummy objects:
                            if (that._isInstanceOf('File', file) ||
                                    that._isInstanceOf('Blob', file)) {
                                formData.append(
                                    ($.type(options.paramName) === 'array' &&
                                        options.paramName[index]) || paramName,
                                    file,
                                    file.uploadName || file.name
                                );
                            }
                        });
                    }
                }
                options.data = formData;
            }
            // Blob reference is not needed anymore, free memory:
            options.blob = null;
        },

        _initIframeSettings: function (options) {
            var targetHost = $('<a></a>').prop('href', options.url).prop('host');
            // Setting the dataType to iframe enables the iframe transport:
            options.dataType = 'iframe ' + (options.dataType || '');
            // The iframe transport accepts a serialized array as form data:
            options.formData = this._getFormData(options);
            // Add redirect url to form data on cross-domain uploads:
            if (options.redirect && targetHost && targetHost !== location.host) {
                options.formData.push({
                    name: options.redirectParamName || 'redirect',
                    value: options.redirect
                });
            }
        },

        _initDataSettings: function (options) {
            if (this._isXHRUpload(options)) {
                if (!this._chunkedUpload(options, true)) {
                    if (!options.data) {
                        this._initXHRData(options);
                    }
                    this._initProgressListener(options);
                }
                if (options.postMessage) {
                    // Setting the dataType to postmessage enables the
                    // postMessage transport:
                    options.dataType = 'postmessage ' + (options.dataType || '');
                }
            } else {
                this._initIframeSettings(options);
            }
        },

        _getParamName: function (options) {
            var fileInput = $(options.fileInput),
                paramName = options.paramName;
            if (!paramName) {
                paramName = [];
                fileInput.each(function () {
                    var input = $(this),
                        name = input.prop('name') || 'files[]',
                        i = (input.prop('files') || [1]).length;
                    while (i) {
                        paramName.push(name);
                        i -= 1;
                    }
                });
                if (!paramName.length) {
                    paramName = [fileInput.prop('name') || 'files[]'];
                }
            } else if (!$.isArray(paramName)) {
                paramName = [paramName];
            }
            return paramName;
        },

        _initFormSettings: function (options) {
            // Retrieve missing options from the input field and the
            // associated form, if available:
            if (!options.form || !options.form.length) {
                options.form = $(options.fileInput.prop('form'));
                // If the given file input doesn't have an associated form,
                // use the default widget file input's form:
                if (!options.form.length) {
                    options.form = $(this.options.fileInput.prop('form'));
                }
            }
            options.paramName = this._getParamName(options);
            if (!options.url) {
                options.url = options.form.prop('action') || location.href;
            }
            // The HTTP request method must be "POST" or "PUT":
            options.type = (options.type ||
                ($.type(options.form.prop('method')) === 'string' &&
                    options.form.prop('method')) || ''
                ).toUpperCase();
            if (options.type !== 'POST' && options.type !== 'PUT' &&
                    options.type !== 'PATCH') {
                options.type = 'POST';
            }
            if (!options.formAcceptCharset) {
                options.formAcceptCharset = options.form.attr('accept-charset');
            }
        },

        _getAJAXSettings: function (data) {
            var options = $.extend({}, this.options, data);
            this._initFormSettings(options);
            this._initDataSettings(options);
            return options;
        },

        // jQuery 1.6 doesn't provide .state(),
        // while jQuery 1.8+ removed .isRejected() and .isResolved():
        _getDeferredState: function (deferred) {
            if (deferred.state) {
                return deferred.state();
            }
            if (deferred.isResolved()) {
                return 'resolved';
            }
            if (deferred.isRejected()) {
                return 'rejected';
            }
            return 'pending';
        },

        // Maps jqXHR callbacks to the equivalent
        // methods of the given Promise object:
        _enhancePromise: function (promise) {
            promise.success = promise.done;
            promise.error = promise.fail;
            promise.complete = promise.always;
            return promise;
        },

        // Creates and returns a Promise object enhanced with
        // the jqXHR methods abort, success, error and complete:
        _getXHRPromise: function (resolveOrReject, context, args) {
            var dfd = $.Deferred(),
                promise = dfd.promise();
            context = context || this.options.context || promise;
            if (resolveOrReject === true) {
                dfd.resolveWith(context, args);
            } else if (resolveOrReject === false) {
                dfd.rejectWith(context, args);
            }
            promise.abort = dfd.promise;
            return this._enhancePromise(promise);
        },

        // Adds convenience methods to the data callback argument:
        _addConvenienceMethods: function (e, data) {
            var that = this,
                getPromise = function (args) {
                    return $.Deferred().resolveWith(that, args).promise();
                };
            data.process = function (resolveFunc, rejectFunc) {
                if (resolveFunc || rejectFunc) {
                    data._processQueue = this._processQueue =
                        (this._processQueue || getPromise([this])).pipe(
                            function () {
                                if (data.errorThrown) {
                                    return $.Deferred()
                                        .rejectWith(that, [data]).promise();
                                }
                                return getPromise(arguments);
                            }
                        ).pipe(resolveFunc, rejectFunc);
                }
                return this._processQueue || getPromise([this]);
            };
            data.submit = function () {
                if (this.state() !== 'pending') {
                    data.jqXHR = this.jqXHR =
                        (that._trigger(
                            'submit',
                            $.Event('submit', {delegatedEvent: e}),
                            this
                        ) !== false) && that._onSend(e, this);
                }
                return this.jqXHR || that._getXHRPromise();
            };
            data.abort = function () {
                if (this.jqXHR) {
                    return this.jqXHR.abort();
                }
                this.errorThrown = 'abort';
                that._trigger('fail', null, this);
                return that._getXHRPromise(false);
            };
            data.state = function () {
                if (this.jqXHR) {
                    return that._getDeferredState(this.jqXHR);
                }
                if (this._processQueue) {
                    return that._getDeferredState(this._processQueue);
                }
            };
            data.processing = function () {
                return !this.jqXHR && this._processQueue && that
                    ._getDeferredState(this._processQueue) === 'pending';
            };
            data.progress = function () {
                return this._progress;
            };
            data.response = function () {
                return this._response;
            };
        },

        // Parses the Range header from the server response
        // and returns the uploaded bytes:
        _getUploadedBytes: function (jqXHR) {
            var range = jqXHR.getResponseHeader('Range'),
                parts = range && range.split('-'),
                upperBytesPos = parts && parts.length > 1 &&
                    parseInt(parts[1], 10);
            return upperBytesPos && upperBytesPos + 1;
        },

        // Uploads a file in multiple, sequential requests
        // by splitting the file up in multiple blob chunks.
        // If the second parameter is true, only tests if the file
        // should be uploaded in chunks, but does not invoke any
        // upload requests:
        _chunkedUpload: function (options, testOnly) {
            options.uploadedBytes = options.uploadedBytes || 0;
            var that = this,
                file = options.files[0],
                fs = file.size,
                ub = options.uploadedBytes,
                mcs = options.maxChunkSize || fs,
                slice = this._blobSlice,
                dfd = $.Deferred(),
                promise = dfd.promise(),
                jqXHR,
                upload;
            if (!(this._isXHRUpload(options) && slice && (ub || mcs < fs)) ||
                    options.data) {
                return false;
            }
            if (testOnly) {
                return true;
            }
            if (ub >= fs) {
                file.error = options.i18n('uploadedBytes');
                return this._getXHRPromise(
                    false,
                    options.context,
                    [null, 'error', file.error]
                );
            }
            // The chunk upload method:
            upload = function () {
                // Clone the options object for each chunk upload:
                var o = $.extend({}, options),
                    currentLoaded = o._progress.loaded;
                o.blob = slice.call(
                    file,
                    ub,
                    ub + mcs,
                    file.type
                );
                // Store the current chunk size, as the blob itself
                // will be dereferenced after data processing:
                o.chunkSize = o.blob.size;
                // Expose the chunk bytes position range:
                o.contentRange = 'bytes ' + ub + '-' +
                    (ub + o.chunkSize - 1) + '/' + fs;
                // Process the upload data (the blob and potential form data):
                that._initXHRData(o);
                // Add progress listeners for this chunk upload:
                that._initProgressListener(o);
                jqXHR = ((that._trigger('chunksend', null, o) !== false && $.ajax(o)) ||
                        that._getXHRPromise(false, o.context))
                    .done(function (result, textStatus, jqXHR) {
                        ub = that._getUploadedBytes(jqXHR) ||
                            (ub + o.chunkSize);
                        // Create a progress event if no final progress event
                        // with loaded equaling total has been triggered
                        // for this chunk:
                        if (currentLoaded + o.chunkSize - o._progress.loaded) {
                            that._onProgress($.Event('progress', {
                                lengthComputable: true,
                                loaded: ub - o.uploadedBytes,
                                total: ub - o.uploadedBytes
                            }), o);
                        }
                        options.uploadedBytes = o.uploadedBytes = ub;
                        o.result = result;
                        o.textStatus = textStatus;
                        o.jqXHR = jqXHR;
                        that._trigger('chunkdone', null, o);
                        that._trigger('chunkalways', null, o);
                        if (ub < fs) {
                            // File upload not yet complete,
                            // continue with the next chunk:
                            upload();
                        } else {
                            dfd.resolveWith(
                                o.context,
                                [result, textStatus, jqXHR]
                            );
                        }
                    })
                    .fail(function (jqXHR, textStatus, errorThrown) {
                        o.jqXHR = jqXHR;
                        o.textStatus = textStatus;
                        o.errorThrown = errorThrown;
                        that._trigger('chunkfail', null, o);
                        that._trigger('chunkalways', null, o);
                        dfd.rejectWith(
                            o.context,
                            [jqXHR, textStatus, errorThrown]
                        );
                    });
            };
            this._enhancePromise(promise);
            promise.abort = function () {
                return jqXHR.abort();
            };
            upload();
            return promise;
        },

        _beforeSend: function (e, data) {
            if (this._active === 0) {
                // the start callback is triggered when an upload starts
                // and no other uploads are currently running,
                // equivalent to the global ajaxStart event:
                this._trigger('start');
                // Set timer for global bitrate progress calculation:
                this._bitrateTimer = new this._BitrateTimer();
                // Reset the global progress values:
                this._progress.loaded = this._progress.total = 0;
                this._progress.bitrate = 0;
            }
            // Make sure the container objects for the .response() and
            // .progress() methods on the data object are available
            // and reset to their initial state:
            this._initResponseObject(data);
            this._initProgressObject(data);
            data._progress.loaded = data.loaded = data.uploadedBytes || 0;
            data._progress.total = data.total = this._getTotal(data.files) || 1;
            data._progress.bitrate = data.bitrate = 0;
            this._active += 1;
            // Initialize the global progress values:
            this._progress.loaded += data.loaded;
            this._progress.total += data.total;
        },

        _onDone: function (result, textStatus, jqXHR, options) {
            var total = options._progress.total,
                response = options._response;
            if (options._progress.loaded < total) {
                // Create a progress event if no final progress event
                // with loaded equaling total has been triggered:
                this._onProgress($.Event('progress', {
                    lengthComputable: true,
                    loaded: total,
                    total: total
                }), options);
            }
            response.result = options.result = result;
            response.textStatus = options.textStatus = textStatus;
            response.jqXHR = options.jqXHR = jqXHR;
            this._trigger('done', null, options);
        },

        _onFail: function (jqXHR, textStatus, errorThrown, options) {
            var response = options._response;
            if (options.recalculateProgress) {
                // Remove the failed (error or abort) file upload from
                // the global progress calculation:
                this._progress.loaded -= options._progress.loaded;
                this._progress.total -= options._progress.total;
            }
            response.jqXHR = options.jqXHR = jqXHR;
            response.textStatus = options.textStatus = textStatus;
            response.errorThrown = options.errorThrown = errorThrown;
            this._trigger('fail', null, options);
        },

        _onAlways: function (jqXHRorResult, textStatus, jqXHRorError, options) {
            // jqXHRorResult, textStatus and jqXHRorError are added to the
            // options object via done and fail callbacks
            this._trigger('always', null, options);
        },

        _onSend: function (e, data) {
            if (!data.submit) {
                this._addConvenienceMethods(e, data);
            }
            var that = this,
                jqXHR,
                aborted,
                slot,
                pipe,
                options = that._getAJAXSettings(data),
                send = function () {
                    that._sending += 1;
                    // Set timer for bitrate progress calculation:
                    options._bitrateTimer = new that._BitrateTimer();
                    jqXHR = jqXHR || (
                        ((aborted || that._trigger(
                            'send',
                            $.Event('send', {delegatedEvent: e}),
                            options
                        ) === false) &&
                        that._getXHRPromise(false, options.context, aborted)) ||
                        that._chunkedUpload(options) || $.ajax(options)
                    ).done(function (result, textStatus, jqXHR) {
                        that._onDone(result, textStatus, jqXHR, options);
                    }).fail(function (jqXHR, textStatus, errorThrown) {
                        that._onFail(jqXHR, textStatus, errorThrown, options);
                    }).always(function (jqXHRorResult, textStatus, jqXHRorError) {
                        that._onAlways(
                            jqXHRorResult,
                            textStatus,
                            jqXHRorError,
                            options
                        );
                        that._sending -= 1;
                        that._active -= 1;
                        if (options.limitConcurrentUploads &&
                                options.limitConcurrentUploads > that._sending) {
                            // Start the next queued upload,
                            // that has not been aborted:
                            var nextSlot = that._slots.shift();
                            while (nextSlot) {
                                if (that._getDeferredState(nextSlot) === 'pending') {
                                    nextSlot.resolve();
                                    break;
                                }
                                nextSlot = that._slots.shift();
                            }
                        }
                        if (that._active === 0) {
                            // The stop callback is triggered when all uploads have
                            // been completed, equivalent to the global ajaxStop event:
                            that._trigger('stop');
                        }
                    });
                    return jqXHR;
                };
            this._beforeSend(e, options);
            if (this.options.sequentialUploads ||
                    (this.options.limitConcurrentUploads &&
                    this.options.limitConcurrentUploads <= this._sending)) {
                if (this.options.limitConcurrentUploads > 1) {
                    slot = $.Deferred();
                    this._slots.push(slot);
                    pipe = slot.pipe(send);
                } else {
                    this._sequence = this._sequence.pipe(send, send);
                    pipe = this._sequence;
                }
                // Return the piped Promise object, enhanced with an abort method,
                // which is delegated to the jqXHR object of the current upload,
                // and jqXHR callbacks mapped to the equivalent Promise methods:
                pipe.abort = function () {
                    aborted = [undefined, 'abort', 'abort'];
                    if (!jqXHR) {
                        if (slot) {
                            slot.rejectWith(options.context, aborted);
                        }
                        return send();
                    }
                    return jqXHR.abort();
                };
                return this._enhancePromise(pipe);
            }
            return send();
        },

        _onAdd: function (e, data) {
            var that = this,
                result = true,
                options = $.extend({}, this.options, data),
                files = data.files,
                filesLength = files.length,
                limit = options.limitMultiFileUploads,
                limitSize = options.limitMultiFileUploadSize,
                overhead = options.limitMultiFileUploadSizeOverhead,
                batchSize = 0,
                paramName = this._getParamName(options),
                paramNameSet,
                paramNameSlice,
                fileSet,
                i,
                j = 0;
            if (limitSize && (!filesLength || files[0].size === undefined)) {
                limitSize = undefined;
            }
            if (!(options.singleFileUploads || limit || limitSize) ||
                    !this._isXHRUpload(options)) {
                fileSet = [files];
                paramNameSet = [paramName];
            } else if (!(options.singleFileUploads || limitSize) && limit) {
                fileSet = [];
                paramNameSet = [];
                for (i = 0; i < filesLength; i += limit) {
                    fileSet.push(files.slice(i, i + limit));
                    paramNameSlice = paramName.slice(i, i + limit);
                    if (!paramNameSlice.length) {
                        paramNameSlice = paramName;
                    }
                    paramNameSet.push(paramNameSlice);
                }
            } else if (!options.singleFileUploads && limitSize) {
                fileSet = [];
                paramNameSet = [];
                for (i = 0; i < filesLength; i = i + 1) {
                    batchSize += files[i].size + overhead;
                    if (i + 1 === filesLength ||
                            ((batchSize + files[i + 1].size + overhead) > limitSize) ||
                            (limit && i + 1 - j >= limit)) {
                        fileSet.push(files.slice(j, i + 1));
                        paramNameSlice = paramName.slice(j, i + 1);
                        if (!paramNameSlice.length) {
                            paramNameSlice = paramName;
                        }
                        paramNameSet.push(paramNameSlice);
                        j = i + 1;
                        batchSize = 0;
                    }
                }
            } else {
                paramNameSet = paramName;
            }
            data.originalFiles = files;
            $.each(fileSet || files, function (index, element) {
                var newData = $.extend({}, data);
                newData.files = fileSet ? element : [element];
                newData.paramName = paramNameSet[index];
                that._initResponseObject(newData);
                that._initProgressObject(newData);
                that._addConvenienceMethods(e, newData);
                result = that._trigger(
                    'add',
                    $.Event('add', {delegatedEvent: e}),
                    newData
                );
                return result;
            });
            return result;
        },

        _replaceFileInput: function (input) {
            var inputClone = input.clone(true);
            $('<form></form>').append(inputClone)[0].reset();
            // Detaching allows to insert the fileInput on another form
            // without loosing the file input value:
            input.after(inputClone).detach();
            // Avoid memory leaks with the detached file input:
            $.cleanData(input.unbind('remove'));
            // Replace the original file input element in the fileInput
            // elements set with the clone, which has been copied including
            // event handlers:
            this.options.fileInput = this.options.fileInput.map(function (i, el) {
                if (el === input[0]) {
                    return inputClone[0];
                }
                return el;
            });
            // If the widget has been initialized on the file input itself,
            // override this.element with the file input clone:
            if (input[0] === this.element[0]) {
                this.element = inputClone;
            }
        },

        _handleFileTreeEntry: function (entry, path) {
            var that = this,
                dfd = $.Deferred(),
                errorHandler = function (e) {
                    if (e && !e.entry) {
                        e.entry = entry;
                    }
                    // Since $.when returns immediately if one
                    // Deferred is rejected, we use resolve instead.
                    // This allows valid files and invalid items
                    // to be returned together in one set:
                    dfd.resolve([e]);
                },
                dirReader;
            path = path || '';
            if (entry.isFile) {
                if (entry._file) {
                    // Workaround for Chrome bug #149735
                    entry._file.relativePath = path;
                    dfd.resolve(entry._file);
                } else {
                    entry.file(function (file) {
                        file.relativePath = path;
                        dfd.resolve(file);
                    }, errorHandler);
                }
            } else if (entry.isDirectory) {
                dirReader = entry.createReader();
                dirReader.readEntries(function (entries) {
                    that._handleFileTreeEntries(
                        entries,
                        path + entry.name + '/'
                    ).done(function (files) {
                        dfd.resolve(files);
                    }).fail(errorHandler);
                }, errorHandler);
            } else {
                // Return an empy list for file system items
                // other than files or directories:
                dfd.resolve([]);
            }
            return dfd.promise();
        },

        _handleFileTreeEntries: function (entries, path) {
            var that = this;
            return $.when.apply(
                $,
                $.map(entries, function (entry) {
                    return that._handleFileTreeEntry(entry, path);
                })
            ).pipe(function () {
                return Array.prototype.concat.apply(
                    [],
                    arguments
                );
            });
        },

        _getDroppedFiles: function (dataTransfer) {
            dataTransfer = dataTransfer || {};
            var items = dataTransfer.items;
            if (items && items.length && (items[0].webkitGetAsEntry ||
                    items[0].getAsEntry)) {
                return this._handleFileTreeEntries(
                    $.map(items, function (item) {
                        var entry;
                        if (item.webkitGetAsEntry) {
                            entry = item.webkitGetAsEntry();
                            if (entry) {
                                // Workaround for Chrome bug #149735:
                                entry._file = item.getAsFile();
                            }
                            return entry;
                        }
                        return item.getAsEntry();
                    })
                );
            }
            return $.Deferred().resolve(
                $.makeArray(dataTransfer.files)
            ).promise();
        },

        _getSingleFileInputFiles: function (fileInput) {
            fileInput = $(fileInput);
            var entries = fileInput.prop('webkitEntries') ||
                    fileInput.prop('entries'),
                files,
                value;
            if (entries && entries.length) {
                return this._handleFileTreeEntries(entries);
            }
            files = $.makeArray(fileInput.prop('files'));
            if (!files.length) {
                value = fileInput.prop('value');
                if (!value) {
                    return $.Deferred().resolve([]).promise();
                }
                // If the files property is not available, the browser does not
                // support the File API and we add a pseudo File object with
                // the input value as name with path information removed:
                files = [{name: value.replace(/^.*\\/, '')}];
            } else if (files[0].name === undefined && files[0].fileName) {
                // File normalization for Safari 4 and Firefox 3:
                $.each(files, function (index, file) {
                    file.name = file.fileName;
                    file.size = file.fileSize;
                });
            }
            return $.Deferred().resolve(files).promise();
        },

        _getFileInputFiles: function (fileInput) {
            if (!(fileInput instanceof $) || fileInput.length === 1) {
                return this._getSingleFileInputFiles(fileInput);
            }
            return $.when.apply(
                $,
                $.map(fileInput, this._getSingleFileInputFiles)
            ).pipe(function () {
                return Array.prototype.concat.apply(
                    [],
                    arguments
                );
            });
        },

        _onChange: function (e) {
            var that = this,
                data = {
                    fileInput: $(e.target),
                    form: $(e.target.form)
                };
            this._getFileInputFiles(data.fileInput).always(function (files) {
                data.files = files;
                if (that.options.replaceFileInput) {
                    that._replaceFileInput(data.fileInput);
                }
                if (that._trigger(
                        'change',
                        $.Event('change', {delegatedEvent: e}),
                        data
                    ) !== false) {
                    that._onAdd(e, data);
                }
            });
        },

        _onPaste: function (e) {
            var items = e.originalEvent && e.originalEvent.clipboardData &&
                    e.originalEvent.clipboardData.items,
                data = {files: []};
            if (items && items.length) {
                $.each(items, function (index, item) {
                    var file = item.getAsFile && item.getAsFile();
                    if (file) {
                        data.files.push(file);
                    }
                });
                if (this._trigger(
                        'paste',
                        $.Event('paste', {delegatedEvent: e}),
                        data
                    ) !== false) {
                    this._onAdd(e, data);
                }
            }
        },

        _onDrop: function (e) {
            e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;
            var that = this,
                dataTransfer = e.dataTransfer,
                data = {};
            if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {
                e.preventDefault();
                this._getDroppedFiles(dataTransfer).always(function (files) {
                    data.files = files;
                    if (that._trigger(
                            'drop',
                            $.Event('drop', {delegatedEvent: e}),
                            data
                        ) !== false) {
                        that._onAdd(e, data);
                    }
                });
            }
        },

        _onDragOver: function (e) {
            e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;
            var dataTransfer = e.dataTransfer;
            if (dataTransfer && $.inArray('Files', dataTransfer.types) !== -1 &&
                    this._trigger(
                        'dragover',
                        $.Event('dragover', {delegatedEvent: e})
                    ) !== false) {
                e.preventDefault();
                dataTransfer.dropEffect = 'copy';
            }
        },

        _initEventHandlers: function () {
            if (this._isXHRUpload(this.options)) {
                this._on(this.options.dropZone, {
                    dragover: this._onDragOver,
                    drop: this._onDrop
                });
                this._on(this.options.pasteZone, {
                    paste: this._onPaste
                });
            }
            if ($.support.fileInput) {
                this._on(this.options.fileInput, {
                    change: this._onChange
                });
            }
        },

        _destroyEventHandlers: function () {
            this._off(this.options.dropZone, 'dragover drop');
            this._off(this.options.pasteZone, 'paste');
            this._off(this.options.fileInput, 'change');
        },

        _setOption: function (key, value) {
            var reinit = $.inArray(key, this._specialOptions) !== -1;
            if (reinit) {
                this._destroyEventHandlers();
            }
            this._super(key, value);
            if (reinit) {
                this._initSpecialOptions();
                this._initEventHandlers();
            }
        },

        _initSpecialOptions: function () {
            var options = this.options;
            if (options.fileInput === undefined) {
                options.fileInput = this.element.is('input[type="file"]') ?
                        this.element : this.element.find('input[type="file"]');
            } else if (!(options.fileInput instanceof $)) {
                options.fileInput = $(options.fileInput);
            }
            if (!(options.dropZone instanceof $)) {
                options.dropZone = $(options.dropZone);
            }
            if (!(options.pasteZone instanceof $)) {
                options.pasteZone = $(options.pasteZone);
            }
        },

        _getRegExp: function (str) {
            var parts = str.split('/'),
                modifiers = parts.pop();
            parts.shift();
            return new RegExp(parts.join('/'), modifiers);
        },

        _isRegExpOption: function (key, value) {
            return key !== 'url' && $.type(value) === 'string' &&
                /^\/.*\/[igm]{0,3}$/.test(value);
        },

        _initDataAttributes: function () {
            var that = this,
                options = this.options,
                clone = $(this.element[0].cloneNode(false));
            // Initialize options set via HTML5 data-attributes:
            $.each(
                clone.data(),
                function (key, value) {
                    var dataAttributeName = 'data-' +
                        // Convert camelCase to hyphen-ated key:
                        key.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
                    if (clone.attr(dataAttributeName)) {
                        if (that._isRegExpOption(key, value)) {
                            value = that._getRegExp(value);
                        }
                        options[key] = value;
                    }
                }
            );
        },

        _create: function () {
            this._initDataAttributes();
            this._initSpecialOptions();
            this._slots = [];
            this._sequence = this._getXHRPromise(true);
            this._sending = this._active = 0;
            this._initProgressObject(this);
            this._initEventHandlers();
        },

        // This method is exposed to the widget API and allows to query
        // the number of active uploads:
        active: function () {
            return this._active;
        },

        // This method is exposed to the widget API and allows to query
        // the widget upload progress.
        // It returns an object with loaded, total and bitrate properties
        // for the running uploads:
        progress: function () {
            return this._progress;
        },

        // This method is exposed to the widget API and allows adding files
        // using the fileupload API. The data parameter accepts an object which
        // must have a files property and can contain additional options:
        // .fileupload('add', {files: filesList});
        add: function (data) {
            var that = this;
            if (!data || this.options.disabled) {
                return;
            }
            if (data.fileInput && !data.files) {
                this._getFileInputFiles(data.fileInput).always(function (files) {
                    data.files = files;
                    that._onAdd(null, data);
                });
            } else {
                data.files = $.makeArray(data.files);
                this._onAdd(null, data);
            }
        },

        // This method is exposed to the widget API and allows sending files
        // using the fileupload API. The data parameter accepts an object which
        // must have a files or fileInput property and can contain additional options:
        // .fileupload('send', {files: filesList});
        // The method returns a Promise object for the file upload call.
        send: function (data) {
            if (data && !this.options.disabled) {
                if (data.fileInput && !data.files) {
                    var that = this,
                        dfd = $.Deferred(),
                        promise = dfd.promise(),
                        jqXHR,
                        aborted;
                    promise.abort = function () {
                        aborted = true;
                        if (jqXHR) {
                            return jqXHR.abort();
                        }
                        dfd.reject(null, 'abort', 'abort');
                        return promise;
                    };
                    this._getFileInputFiles(data.fileInput).always(
                        function (files) {
                            if (aborted) {
                                return;
                            }
                            if (!files.length) {
                                dfd.reject();
                                return;
                            }
                            data.files = files;
                            jqXHR = that._onSend(null, data).then(
                                function (result, textStatus, jqXHR) {
                                    dfd.resolve(result, textStatus, jqXHR);
                                },
                                function (jqXHR, textStatus, errorThrown) {
                                    dfd.reject(jqXHR, textStatus, errorThrown);
                                }
                            );
                        }
                    );
                    return this._enhancePromise(promise);
                }
                data.files = $.makeArray(data.files);
                if (data.files.length) {
                    return this._onSend(null, data);
                }
            }
            return this._getXHRPromise(false, data && data.context);
        }

    });

}));

},{}],135:[function(require,module,exports){
/*
 * jQuery Iframe Transport Plugin 1.8.2
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/* global define, window, document */

(function (factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define(['jquery'], factory);
    } else {
        // Browser globals:
        factory(window.jQuery);
    }
}(function ($) {
    'use strict';

    // Helper variable to create unique names for the transport iframes:
    var counter = 0;

    // The iframe transport accepts four additional options:
    // options.fileInput: a jQuery collection of file input fields
    // options.paramName: the parameter name for the file form data,
    //  overrides the name property of the file input field(s),
    //  can be a string or an array of strings.
    // options.formData: an array of objects with name and value properties,
    //  equivalent to the return data of .serializeArray(), e.g.:
    //  [{name: 'a', value: 1}, {name: 'b', value: 2}]
    // options.initialIframeSrc: the URL of the initial iframe src,
    //  by default set to "javascript:false;"
    $.ajaxTransport('iframe', function (options) {
        if (options.async) {
            // javascript:false as initial iframe src
            // prevents warning popups on HTTPS in IE6:
            /*jshint scripturl: true */
            var initialIframeSrc = options.initialIframeSrc || 'javascript:false;',
            /*jshint scripturl: false */
                form,
                iframe,
                addParamChar;
            return {
                send: function (_, completeCallback) {
                    form = $('<form style="display:none;"></form>');
                    form.attr('accept-charset', options.formAcceptCharset);
                    addParamChar = /\?/.test(options.url) ? '&' : '?';
                    // XDomainRequest only supports GET and POST:
                    if (options.type === 'DELETE') {
                        options.url = options.url + addParamChar + '_method=DELETE';
                        options.type = 'POST';
                    } else if (options.type === 'PUT') {
                        options.url = options.url + addParamChar + '_method=PUT';
                        options.type = 'POST';
                    } else if (options.type === 'PATCH') {
                        options.url = options.url + addParamChar + '_method=PATCH';
                        options.type = 'POST';
                    }
                    // IE versions below IE8 cannot set the name property of
                    // elements that have already been added to the DOM,
                    // so we set the name along with the iframe HTML markup:
                    counter += 1;
                    iframe = $(
                        '<iframe src="' + initialIframeSrc +
                            '" name="iframe-transport-' + counter + '"></iframe>'
                    ).bind('load', function () {
                        var fileInputClones,
                            paramNames = $.isArray(options.paramName) ?
                                    options.paramName : [options.paramName];
                        iframe
                            .unbind('load')
                            .bind('load', function () {
                                var response;
                                // Wrap in a try/catch block to catch exceptions thrown
                                // when trying to access cross-domain iframe contents:
                                try {
                                    response = iframe.contents();
                                    // Google Chrome and Firefox do not throw an
                                    // exception when calling iframe.contents() on
                                    // cross-domain requests, so we unify the response:
                                    if (!response.length || !response[0].firstChild) {
                                        throw new Error();
                                    }
                                } catch (e) {
                                    response = undefined;
                                }
                                // The complete callback returns the
                                // iframe content document as response object:
                                completeCallback(
                                    200,
                                    'success',
                                    {'iframe': response}
                                );
                                // Fix for IE endless progress bar activity bug
                                // (happens on form submits to iframe targets):
                                $('<iframe src="' + initialIframeSrc + '"></iframe>')
                                    .appendTo(form);
                                window.setTimeout(function () {
                                    // Removing the form in a setTimeout call
                                    // allows Chrome's developer tools to display
                                    // the response result
                                    form.remove();
                                }, 0);
                            });
                        form
                            .prop('target', iframe.prop('name'))
                            .prop('action', options.url)
                            .prop('method', options.type);
                        if (options.formData) {
                            $.each(options.formData, function (index, field) {
                                $('<input type="hidden"/>')
                                    .prop('name', field.name)
                                    .val(field.value)
                                    .appendTo(form);
                            });
                        }
                        if (options.fileInput && options.fileInput.length &&
                                options.type === 'POST') {
                            fileInputClones = options.fileInput.clone();
                            // Insert a clone for each file input field:
                            options.fileInput.after(function (index) {
                                return fileInputClones[index];
                            });
                            if (options.paramName) {
                                options.fileInput.each(function (index) {
                                    $(this).prop(
                                        'name',
                                        paramNames[index] || options.paramName
                                    );
                                });
                            }
                            // Appending the file input fields to the hidden form
                            // removes them from their original location:
                            form
                                .append(options.fileInput)
                                .prop('enctype', 'multipart/form-data')
                                // enctype must be set as encoding for IE:
                                .prop('encoding', 'multipart/form-data');
                            // Remove the HTML5 form attribute from the input(s):
                            options.fileInput.removeAttr('form');
                        }
                        form.submit();
                        // Insert the file input fields at their original location
                        // by replacing the clones with the originals:
                        if (fileInputClones && fileInputClones.length) {
                            options.fileInput.each(function (index, input) {
                                var clone = $(fileInputClones[index]);
                                // Restore the original name and form properties:
                                $(input)
                                    .prop('name', clone.prop('name'))
                                    .attr('form', clone.attr('form'));
                                clone.replaceWith(input);
                            });
                        }
                    });
                    form.append(iframe).appendTo(document.body);
                },
                abort: function () {
                    if (iframe) {
                        // javascript:false as iframe src aborts the request
                        // and prevents warning popups on HTTPS in IE6.
                        // concat is used to avoid the "Script URL" JSLint error:
                        iframe
                            .unbind('load')
                            .prop('src', initialIframeSrc);
                    }
                    if (form) {
                        form.remove();
                    }
                }
            };
        }
    });

    // The iframe transport returns the iframe content document as response.
    // The following adds converters from iframe to text, json, html, xml
    // and script.
    // Please note that the Content-Type for JSON responses has to be text/plain
    // or text/html, if the browser doesn't include application/json in the
    // Accept header, else IE will show a download dialog.
    // The Content-Type for XML responses on the other hand has to be always
    // application/xml or text/xml, so IE properly parses the XML response.
    // See also
    // https://github.com/blueimp/jQuery-File-Upload/wiki/Setup#content-type-negotiation
    $.ajaxSetup({
        converters: {
            'iframe text': function (iframe) {
                return iframe && $(iframe[0].body).text();
            },
            'iframe json': function (iframe) {
                return iframe && $.parseJSON($(iframe[0].body).text());
            },
            'iframe html': function (iframe) {
                return iframe && $(iframe[0].body).html();
            },
            'iframe xml': function (iframe) {
                var xmlDoc = iframe && iframe[0];
                return xmlDoc && $.isXMLDoc(xmlDoc) ? xmlDoc :
                        $.parseXML((xmlDoc.XMLDocument && xmlDoc.XMLDocument.xml) ||
                            $(xmlDoc.body).html());
            },
            'iframe script': function (iframe) {
                return iframe && $.globalEval($(iframe[0].body).text());
            }
        }
    });

}));

},{}],136:[function(require,module,exports){
/*!
 * jQuery UI Widget 1.10.4+amd
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/jQuery.widget/
 */

(function (factory) {
    if (typeof define === "function" && define.amd) {
        // Register as an anonymous AMD module:
        define(["jquery"], factory);
    } else {
        // Browser globals:
        factory(jQuery);
    }
}(function( $, undefined ) {

var uuid = 0,
	slice = Array.prototype.slice,
	_cleanData = $.cleanData;
$.cleanData = function( elems ) {
	for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
		try {
			$( elem ).triggerHandler( "remove" );
		// http://bugs.jquery.com/ticket/8235
		} catch( e ) {}
	}
	_cleanData( elems );
};

$.widget = function( name, base, prototype ) {
	var fullName, existingConstructor, constructor, basePrototype,
		// proxiedPrototype allows the provided prototype to remain unmodified
		// so that it can be used as a mixin for multiple widgets (#8876)
		proxiedPrototype = {},
		namespace = name.split( "." )[ 0 ];

	name = name.split( "." )[ 1 ];
	fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};
	// extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,
		// copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),
		// track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	});

	basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = (function() {
			var _super = function() {
					return base.prototype[ prop ].apply( this, arguments );
				},
				_superApply = function( args ) {
					return base.prototype[ prop ].apply( this, args );
				};
			return function() {
				var __super = this._super,
					__superApply = this._superApply,
					returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		})();
	});
	constructor.prototype = $.widget.extend( basePrototype, {
		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	});

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
		});
		// remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );
};

$.widget.extend = function( target ) {
	var input = slice.call( arguments, 1 ),
		inputIndex = 0,
		inputLength = input.length,
		key,
		value;
	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :
						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );
				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string",
			args = slice.call( arguments, 1 ),
			returnValue = this;

		// allow multiple hashes to be passed on init
		options = !isMethodCall && args.length ?
			$.widget.extend.apply( null, [ options ].concat(args) ) :
			options;

		if ( isMethodCall ) {
			this.each(function() {
				var methodValue,
					instance = $.data( this, fullName );
				if ( !instance ) {
					return $.error( "cannot call methods on " + name + " prior to initialization; " +
						"attempted to call method '" + options + "'" );
				}
				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
					return $.error( "no such method '" + options + "' for " + name + " widget instance" );
				}
				methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue && methodValue.jquery ?
						returnValue.pushStack( methodValue.get() ) :
						methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} )._init();
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",
	options: {
		disabled: false,

		// callbacks
		create: null
	},
	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = uuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;
		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			});
			this.document = $( element.style ?
				// element within the document
				element.ownerDocument :
				// element is window or document
				element.document || element );
			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
		}

		this._create();
		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},
	_getCreateOptions: $.noop,
	_getCreateEventData: $.noop,
	_create: $.noop,
	_init: $.noop,

	destroy: function() {
		this._destroy();
		// we can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.unbind( this.eventNamespace )
			// 1.9 BC for #7810
			// TODO remove dual storage
			.removeData( this.widgetName )
			.removeData( this.widgetFullName )
			// support: jquery <1.6.3
			// http://bugs.jquery.com/ticket/9413
			.removeData( $.camelCase( this.widgetFullName ) );
		this.widget()
			.unbind( this.eventNamespace )
			.removeAttr( "aria-disabled" )
			.removeClass(
				this.widgetFullName + "-disabled " +
				"ui-state-disabled" );

		// clean up events and states
		this.bindings.unbind( this.eventNamespace );
		this.hoverable.removeClass( "ui-state-hover" );
		this.focusable.removeClass( "ui-state-focus" );
	},
	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key,
			parts,
			curOption,
			i;

		if ( arguments.length === 0 ) {
			// don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {
			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( arguments.length === 1 ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( arguments.length === 1 ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this.widget()
				.toggleClass( this.widgetFullName + "-disabled ui-state-disabled", !!value )
				.attr( "aria-disabled", value );
			this.hoverable.removeClass( "ui-state-hover" );
			this.focusable.removeClass( "ui-state-focus" );
		}

		return this;
	},

	enable: function() {
		return this._setOption( "disabled", false );
	},
	disable: function() {
		return this._setOption( "disabled", true );
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement,
			instance = this;

		// no suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// no element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			// accept selectors, DOM elements
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {
				// allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
							$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^(\w+)\s*(.*)$/ ),
				eventName = match[1] + instance.eventNamespace,
				selector = match[2];
			if ( selector ) {
				delegateElement.delegate( selector, eventName, handlerProxy );
			} else {
				element.bind( eventName, handlerProxy );
			}
		});
	},

	_off: function( element, eventName ) {
		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;
		element.unbind( eventName ).undelegate( eventName );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-hover" );
			},
			mouseleave: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-hover" );
			}
		});
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-focus" );
			},
			focusout: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-focus" );
			}
		});
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		// the original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}
		var hasOptions,
			effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;
		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}
		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;
		if ( options.delay ) {
			element.delay( options.delay );
		}
		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue(function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			});
		}
	};
});

}));

},{}],137:[function(require,module,exports){
/**
 * version 2.1.30
 * @license
 * =========================================================
 * bootstrap-datetimepicker.js
 * http://www.eyecon.ro/bootstrap-datepicker
 * =========================================================
 * Copyright 2012 Stefan Petre
 *
 * Contributions:
 * - updated for Bootstrap v3 by Jonathan Peterson (@Eonasdan) and (almost)
 *    completely rewritten to use Momentjs
 * - based on tarruda's bootstrap-datepicker
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =========================================================
 */
; (function (factory) {
    if (typeof define === 'function' && define.amd) {
    // AMD is used - Register as an anonymous module.
        define(['jquery', 'moment'], factory);
    } else {
        // AMD is not used - Attempt to fetch dependencies from scope.
        if(!jQuery){
            throw 'bootstrap-datetimepicker requires jQuery to be loaded first';
        }else if(!moment) {
            throw 'bootstrap-datetimepicker requires moment.js to be loaded first';
        }else{
            factory(jQuery, moment);
        }
    }
}

(function ($, moment) {
    if (typeof moment === 'undefined') {
        alert("momentjs is requried");
        throw new Error('momentjs is required');
    };

    var dpgId = 0,

    pMoment = moment,

// ReSharper disable once InconsistentNaming
    DateTimePicker = function (element, options) {
        var defaults = {
            pickDate: true,
            pickTime: true,
            useMinutes: true,
            useSeconds: false,
            minuteStepping: 1,
            startDate: new pMoment({ y: 1970 }),
            endDate: new pMoment().add(50, "y"),
            collapse: true,
            language: pMoment.lang(),
            defaultDate: "",
            disabledDates: [],
            enabledDates: false,
            icons: {},
            useStrict: false,
            direction: "auto"
        },

		icons = {
		    time: 'glyphicon glyphicon-time',
		    date: 'glyphicon glyphicon-calendar',
		    up: 'glyphicon glyphicon-chevron-up',
		    down: 'glyphicon glyphicon-chevron-down'
		},

        picker = this,

        init = function () {

            var icon = false, i, dDate, longDateFormat;
            picker.options = $.extend({}, defaults, options);
            picker.options.icons = $.extend({}, icons, picker.options.icons);

            picker.element = $(element);

            dataToOptions();

            if (!(picker.options.pickTime || picker.options.pickDate))
                throw new Error('Must choose at least one picker');

            picker.id = dpgId++;
            pMoment.lang(picker.options.language);
            picker.date = pMoment();
            picker.unset = false;
            picker.isInput = picker.element.is('input');
            picker.component = false;

            if (picker.element.hasClass('input-group')) {
                if (picker.element.find('.datepickerbutton').size() == 0) {//in case there is more then one 'input-group-addon` #48
                    picker.component = picker.element.find("[class^='input-group-']");
                }
                else {
                    picker.component = picker.element.find('.datepickerbutton');
                }
            }
            picker.format = picker.options.format;

            longDateFormat = pMoment()._lang._longDateFormat;

            if (!picker.format) {
                if (picker.isInput) picker.format = picker.element.data('format');
                else picker.format = picker.element.find('input').data('format');
                if (!picker.format) {
                    picker.format = (picker.options.pickDate ? longDateFormat.L : '');
                    if (picker.options.pickDate && picker.options.pickTime) picker.format += ' ';
                    picker.format += (picker.options.pickTime ? longDateFormat.LT : '');
                    if (picker.options.useSeconds) {
                        if (~longDateFormat.LT.indexOf(' A')) {
                            picker.format = picker.format.split(" A")[0] + ":ss A";
                        }
                        else {
                            picker.format += ':ss';
                        }
                    }
                }
            }

            picker.options.use24hours = picker.format.toLowerCase().indexOf("a") < 1;

            if (picker.component) icon = picker.component.find('span');

            if (picker.options.pickTime) {
                if (icon) icon.addClass(picker.options.icons.time);
            }
            if (picker.options.pickDate) {
                if (icon) {
                    icon.removeClass(picker.options.icons.time);
                    icon.addClass(picker.options.icons.date);
                }
            }

            picker.widget = $(getTemplate(picker.options.pickDate, picker.options.pickTime, picker.options.collapse)).appendTo('body');
            picker.minViewMode = picker.options.minViewMode || picker.element.data('date-minviewmode') || 0;
            if (typeof picker.minViewMode === 'string') {
                switch (picker.minViewMode) {
                    case 'months':
                        picker.minViewMode = 1;
                        break;
                    case 'years':
                        picker.minViewMode = 2;
                        break;
                    default:
                        picker.minViewMode = 0;
                        break;
                }
            }
            picker.viewMode = picker.options.viewMode || picker.element.data('date-viewmode') || 0;
            if (typeof picker.viewMode === 'string') {
                switch (picker.viewMode) {
                    case 'months':
                        picker.viewMode = 1;
                        break;
                    case 'years':
                        picker.viewMode = 2;
                        break;
                    default:
                        picker.viewMode = 0;
                        break;
                }
            }

            for (i = 0; i < picker.options.disabledDates.length; i++) {
                dDate = picker.options.disabledDates[i];
                dDate = pMoment(dDate);
                //if this is not a valid date then set it to the startdate -1 day so it's disabled.
                if (!dDate.isValid()) dDate = pMoment(picker.options.startDate).subtract(1, "day");
                picker.options.disabledDates[i] = dDate.format("L");
            }

            for (i = 0; i < picker.options.enabledDates.length; i++) {
                dDate = picker.options.enabledDates[i];
                dDate = pMoment(dDate);
                //if this is not a valid date then set it to the startdate -1 day so it's disabled.
                if (!dDate.isValid()) dDate = pMoment(picker.options.startDate).subtract(1, "day");
                picker.options.enabledDates[i] = dDate.format("L");
            }
            picker.startViewMode = picker.viewMode;
            picker.setStartDate(picker.options.startDate || picker.element.data('date-startdate'));
            picker.setEndDate(picker.options.endDate || picker.element.data('date-enddate'));
            fillDow();
            fillMonths();
            fillHours();
            fillMinutes();
			fillSeconds();
            update();
            showMode();
            attachDatePickerEvents();
            if (picker.options.defaultDate !== "") picker.setValue(picker.options.defaultDate);
        },

        dataToOptions = function () {
            var eData = picker.element.data();
            if (eData.pickdate !== undefined) picker.options.pickDate = eData.pickdate;
            if (eData.picktime !== undefined) picker.options.pickTime = eData.picktime;
            if (eData.useminutes !== undefined) picker.options.useMinutes = eData.useminutes;
            if (eData.useseconds !== undefined) picker.options.useSeconds = eData.useseconds;
            if (eData.minutestepping !== undefined) picker.options.minuteStepping = eData.minutestepping;
            if (eData.startdate !== undefined) picker.options.startDate = eData.startdate;
            if (eData.enddate !== undefined) picker.options.endDate = eData.enddate;
            if (eData.collapse !== undefined) picker.options.collapse = eData.collapse;
            if (eData.language !== undefined) picker.options.language = eData.language;
            if (eData.defaultdate !== undefined) picker.options.defaultDate = eData.defaultdate;
            if (eData.disableddates !== undefined) picker.options.disabledDates = eData.disableddates;
            if (eData.enableddates !== undefined) picker.options.enabledDates = eData.enableddates;
            if (eData.icons !== undefined) picker.options.icons = eData.icons;
            if (eData.usestrict !== undefined) picker.options.useStrict = eData.usestrict;
        },

        place = function () {
            var position = 'absolute',
            offset = picker.component ? picker.component.offset() : picker.element.offset(), $window = $(window);
            picker.width = picker.component ? picker.component.outerWidth() : picker.element.outerWidth();
            offset.top = offset.top + picker.element.outerHeight();
            
            // if (picker.options.direction === 'up' || picker.options.direction === 'auto' && offset.top + picker.widget.height() > $window.height()) {
        		// offset.top -= picker.widget.height() + picker.element.outerHeight();
            	// picker.widget.addClass('up');
            // } else if (picker.options.direction === 'down' || picker.options.direction === 'auto' && offset.top + picker.widget.height() <= $window.height()) {
            	// offset.top += picker.element.outerHeight();
            	// picker.widget.addClass('down');
            // }

            if (picker.options.width !== undefined) {
                picker.widget.width(picker.options.width);
            }

            if (picker.options.orientation === 'left') {
                picker.widget.addClass('left-oriented');
                offset.left = offset.left - picker.widget.width() + 20;
            }

            if (isInFixed()) {
                position = 'fixed';
                offset.top -= $window.scrollTop();
                offset.left -= $window.scrollLeft();
            }

            if ($window.width() < offset.left + picker.widget.outerWidth()) {
                offset.right = $window.width() - offset.left - picker.width;
                offset.left = 'auto';
                picker.widget.addClass('pull-right');
            } else {
                offset.right = 'auto';
                picker.widget.removeClass('pull-right');
            }

            picker.widget.css({
                position: position,
                top: offset.top,
                left: offset.left,
                right: offset.right
            });
        },

        notifyChange = function (oldDate, eventType) {
            picker.element.trigger({
                type: 'change.dp',
                date: pMoment(picker.date),
                oldDate: pMoment(oldDate)
            });

            if (eventType !== 'change')
                picker.element.change();
        },

		notifyError = function (date) {
		    picker.element.trigger({
		        type: 'error.dp',
		        date: pMoment(date)
		    });
		},

        update = function (newDate) {
            pMoment.lang(picker.options.language);
            var dateStr = newDate;
            if (!dateStr) {
                if (picker.isInput) {
                    dateStr = picker.element.val();
                } else {
                    dateStr = picker.element.find('input').val();
                }
                if (dateStr) picker.date = pMoment(dateStr, picker.format, picker.options.useStrict);
                if (!picker.date) picker.date = pMoment();
            }
            picker.viewDate = pMoment(picker.date).startOf("month");
            fillDate();
            fillTime();
        },

		fillDow = function () {
		    pMoment.lang(picker.options.language);
		    var html = $('<tr>'), weekdaysMin = pMoment.weekdaysMin(), i;
		    if (pMoment()._lang._week.dow == 0) { // starts on Sunday
		        for(i = 0; i < 7; i++) {
		            html.append('<th class="dow">' + weekdaysMin[i] + '</th>');
		        }
		    } else {
		        for (i = 1; i < 8; i++) {
		            if (i == 7) {
		                html.append('<th class="dow">' + weekdaysMin[0] + '</th>');
		            } else {
		                html.append('<th class="dow">' + weekdaysMin[i] + '</th>');
		            }
		        }
		    }
		    picker.widget.find('.datepicker-days thead').append(html);
		},

        fillMonths = function () {
            pMoment.lang(picker.options.language);
            var html = '', i = 0, monthsShort = pMoment.monthsShort();
            while (i < 12) {
                html += '<span class="month">' + monthsShort[i++] + '</span>';
            }
            picker.widget.find('.datepicker-months td').append(html);
        },

        fillDate = function () {
            pMoment.lang(picker.options.language);
            var year = picker.viewDate.year(),
                month = picker.viewDate.month(),
                startYear = picker.options.startDate.year(),
                startMonth = picker.options.startDate.month(),
                endYear = picker.options.endDate.year(),
                endMonth = picker.options.endDate.month(),
                prevMonth, nextMonth, html = [], row, clsName, i, days, yearCont, currentYear, months = pMoment.months();

            picker.widget.find('.datepicker-days').find('.disabled').removeClass('disabled');
            picker.widget.find('.datepicker-months').find('.disabled').removeClass('disabled');
            picker.widget.find('.datepicker-years').find('.disabled').removeClass('disabled');

            picker.widget.find('.datepicker-days th:eq(1)').text(
                months[month] + ' ' + year);

            prevMonth = pMoment(picker.viewDate).subtract("months", 1);
            days = prevMonth.daysInMonth();
            prevMonth.date(days).startOf('week');
            if ((year == startYear && month <= startMonth) || year < startYear) {
                picker.widget.find('.datepicker-days th:eq(0)').addClass('disabled');
            }
            if ((year == endYear && month >= endMonth) || year > endYear) {
                picker.widget.find('.datepicker-days th:eq(2)').addClass('disabled');
            }

            nextMonth = pMoment(prevMonth).add(42, "d");
            while (prevMonth.isBefore(nextMonth)) {
                if (prevMonth.weekday() === pMoment().startOf('week').weekday()) {
                    row = $('<tr>');
                    html.push(row);
                }
                clsName = '';
                if (prevMonth.year() < year || (prevMonth.year() == year && prevMonth.month() < month)) {
                    clsName += ' old';
                } else if (prevMonth.year() > year || (prevMonth.year() == year && prevMonth.month() > month)) {
                    clsName += ' new';
                }
                if (prevMonth.isSame(pMoment({ y: picker.date.year(), M: picker.date.month(), d: picker.date.date() }))) {
                    clsName += ' active';
                }
                if (isInDisableDates(prevMonth) || !isInEnableDates(prevMonth)) {
                    clsName += ' disabled';
                }
                row.append('<td class="day' + clsName + '">' + prevMonth.date() + '</td>');
                prevMonth.add(1, "d");
            }
            picker.widget.find('.datepicker-days tbody').empty().append(html);
            currentYear = pMoment().year(), months = picker.widget.find('.datepicker-months')
				.find('th:eq(1)').text(year).end().find('span').removeClass('active');
            if (currentYear === year) {
                months.eq(pMoment().month()).addClass('active');
            }
            if (currentYear - 1 < startYear) {
                picker.widget.find('.datepicker-months th:eq(0)').addClass('disabled');
            }
            if (currentYear + 1 > endYear) {
                picker.widget.find('.datepicker-months th:eq(2)').addClass('disabled');
            }
            for (i = 0; i < 12; i++) {
                if ((year == startYear && startMonth > i) || (year < startYear)) {
                    $(months[i]).addClass('disabled');
                } else if ((year == endYear && endMonth < i) || (year > endYear)) {
                    $(months[i]).addClass('disabled');
                }
            }

            html = '';
            year = parseInt(year / 10, 10) * 10;
            yearCont = picker.widget.find('.datepicker-years').find(
                'th:eq(1)').text(year + '-' + (year + 9)).end().find('td');
            picker.widget.find('.datepicker-years').find('th').removeClass('disabled');
            if (startYear > year) {
                picker.widget.find('.datepicker-years').find('th:eq(0)').addClass('disabled');
            }
            if (endYear < year + 9) {
                picker.widget.find('.datepicker-years').find('th:eq(2)').addClass('disabled');
            }
            year -= 1;
            for (i = -1; i < 11; i++) {
                html += '<span class="year' + (i === -1 || i === 10 ? ' old' : '') + (currentYear === year ? ' active' : '') + ((year < startYear || year > endYear) ? ' disabled' : '') + '">' + year + '</span>';
                year += 1;
            }
            yearCont.html(html);
        },

        fillHours = function () {
            pMoment.lang(picker.options.language);
            var table = picker.widget.find('.timepicker .timepicker-hours table'), html = '', current, i, j;
            table.parent().hide();
            if (picker.options.use24hours) {
                current = 0;
                for (i = 0; i < 6; i += 1) {
                    html += '<tr>';
                    for (j = 0; j < 4; j += 1) {
                        html += '<td class="hour">' + padLeft(current.toString()) + '</td>';
                        current++;
                    }
                    html += '</tr>';
                }
            }
            else {
                current = 1;
                for (i = 0; i < 3; i += 1) {
                    html += '<tr>';
                    for (j = 0; j < 4; j += 1) {
                        html += '<td class="hour">' + padLeft(current.toString()) + '</td>';
                        current++;
                    }
                    html += '</tr>';
                }
            }
            table.html(html);
        },

        fillMinutes = function () {
            var table = picker.widget.find('.timepicker .timepicker-minutes table'), html = '', current = 0, i, j;
            table.parent().hide();
            for (i = 0; i < 5; i++) {
                html += '<tr>';
                for (j = 0; j < 4; j += 1) {
                    html += '<td class="minute">' + padLeft(current.toString()) + '</td>';
                    current += 3;
                }
                html += '</tr>';
            }
            table.html(html);
        },

        fillSeconds = function () {
            var table = picker.widget.find('.timepicker .timepicker-seconds table'), html = '', current = 0, i, j;
            table.parent().hide();
            for (i = 0; i < 5; i++) {
                html += '<tr>';
                for (j = 0; j < 4; j += 1) {
                  html += '<td class="second">' + padLeft(current.toString()) + '</td>';
                  current += 3;
                }
                html += '</tr>';
            }
            table.html(html);
        },

        fillTime = function () {
            if (!picker.date) return;
            var timeComponents = picker.widget.find('.timepicker span[data-time-component]'),
            hour = picker.date.hours(),
            period = 'AM';
            if (!picker.options.use24hours) {
                if (hour >= 12) period = 'PM';
                if (hour === 0) hour = 12;
                else if (hour != 12) hour = hour % 12;
                picker.widget.find('.timepicker [data-action=togglePeriod]').text(period);
            }
            timeComponents.filter('[data-time-component=hours]').text(padLeft(hour));
            timeComponents.filter('[data-time-component=minutes]').text(padLeft(picker.date.minutes()));
            timeComponents.filter('[data-time-component=seconds]').text(padLeft(picker.date.second()));
        },

        click = function (e) {
            e.stopPropagation();
            e.preventDefault();
            picker.unset = false;
            var target = $(e.target).closest('span, td, th'), month, year, step, day, oldDate = pMoment(picker.date);
            if (target.length === 1) {
                if (!target.is('.disabled')) {
                    switch (target[0].nodeName.toLowerCase()) {
                        case 'th':
                            switch (target[0].className) {
                                case 'switch':
                                    showMode(1);
                                    break;
                                case 'prev':
                                case 'next':
                                    step = dpGlobal.modes[picker.viewMode].navStep;
                                    if (target[0].className === 'prev') step = step * -1;
                                    picker.viewDate.add(step, dpGlobal.modes[picker.viewMode].navFnc);
                                    fillDate();
                                    break;
                            }
                            break;
                        case 'span':
                            if (target.is('.month')) {
                                month = target.parent().find('span').index(target);
                                picker.viewDate.month(month);
                            } else {
                                year = parseInt(target.text(), 10) || 0;
                                picker.viewDate.year(year);
                            }
                            if (picker.viewMode !== 0) {
                                picker.date = pMoment({
                                    y: picker.viewDate.year(),
                                    M: picker.viewDate.month(),
                                    d: picker.viewDate.date(),
                                    h: picker.date.hours(),
                                    m: picker.date.minutes()
                                });
                                notifyChange(oldDate, e.type);
                            }
                            showMode(-1);
                            fillDate();
                            break;
                        case 'td':
                            if (target.is('.day')) {
                                day = parseInt(target.text(), 10) || 1;
                                month = picker.viewDate.month();
                                year = picker.viewDate.year();
                                if (target.is('.old')) {
                                    if (month === 0) {
                                        month = 11;
                                        year -= 1;
                                    } else {
                                        month -= 1;
                                    }
                                } else if (target.is('.new')) {
                                    if (month == 11) {
                                        month = 0;
                                        year += 1;
                                    } else {
                                        month += 1;
                                    }
                                }
                                picker.date = pMoment({
                                    y: year,
                                    M: month,
                                    d: day,
                                    h: picker.date.hours(),
                                    m: picker.date.minutes()
                                }
                                );
                                picker.viewDate = pMoment({
                                    y: year, M: month, d: Math.min(28, day)
                                });
                                fillDate();
                                set();
                                notifyChange(oldDate, e.type);
                            }
                            break;
                    }
                }
            }
        },

		actions = {
		    incrementHours: function () {
		        checkDate("add", "hours", 1);
		    },

		    incrementMinutes: function () {
		        checkDate("add", "minutes", picker.options.minuteStepping);
		    },

		    incrementSeconds: function () {
		        checkDate("add", "seconds", 1);
		    },

		    decrementHours: function () {
		        checkDate("subtract", "hours", 1);
		    },

		    decrementMinutes: function () {
		        checkDate("subtract", "minutes", picker.options.minuteStepping);
		    },

		    decrementSeconds: function () {
		        checkDate("subtract", "seconds", 1);
		    },

		    togglePeriod: function () {
		        var hour = picker.date.hours();
		        if (hour >= 12) hour -= 12;
		        else hour += 12;
		        picker.date.hours(hour);
		    },

		    showPicker: function () {
		        picker.widget.find('.timepicker > div:not(.timepicker-picker)').hide();
		        picker.widget.find('.timepicker .timepicker-picker').show();
		    },

		    showHours: function () {
		        picker.widget.find('.timepicker .timepicker-picker').hide();
		        picker.widget.find('.timepicker .timepicker-hours').show();
		    },

		    showMinutes: function () {
		        picker.widget.find('.timepicker .timepicker-picker').hide();
		        picker.widget.find('.timepicker .timepicker-minutes').show();
		    },

		    showSeconds: function () {
		        picker.widget.find('.timepicker .timepicker-picker').hide();
		        picker.widget.find('.timepicker .timepicker-seconds').show();
		    },

		    selectHour: function (e) {
		        picker.date.hours(parseInt($(e.target).text(), 10));
		        actions.showPicker.call(picker);
		    },

		    selectMinute: function (e) {
		        picker.date.minutes(parseInt($(e.target).text(), 10));
		        actions.showPicker.call(picker);
		    },

		    selectSecond: function (e) {
		        picker.date.seconds(parseInt($(e.target).text(), 10));
		        actions.showPicker.call(picker);
		    }
		},

	    doAction = function (e) {
	        var oldDate = pMoment(picker.date), action = $(e.currentTarget).data('action'), rv = actions[action].apply(picker, arguments);
	        stopEvent(e);
	        if (!picker.date) picker.date = pMoment({ y: 1970 });
	        set();
	        fillTime();
	        notifyChange(oldDate, e.type);
	        return rv;
	    },

        stopEvent = function (e) {
            e.stopPropagation();
            e.preventDefault();
        },

        change = function (e) {
            pMoment.lang(picker.options.language);
            var input = $(e.target), oldDate = pMoment(picker.date), newDate = pMoment(input.val(), picker.format, picker.options.useStrict);
            if (newDate.isValid() && !isInDisableDates(newDate) && isInEnableDates(newDate)) {
                update();
                picker.setValue(newDate);
                notifyChange(oldDate, e.type);
                set();
            }
            else {
                picker.viewDate = oldDate;
                input.val(pMoment(oldDate).format(picker.format));
                //picker.setValue(""); // unset the date when the input is erased
                notifyChange(oldDate, e.type);
                notifyError(newDate);
                picker.unset = true;
            }
        },

        showMode = function (dir) {
            if (dir) {
                picker.viewMode = Math.max(picker.minViewMode, Math.min(2, picker.viewMode + dir));
            }

            picker.widget.find('.datepicker > div').hide().filter('.datepicker-' + dpGlobal.modes[picker.viewMode].clsName).show();
        },

        attachDatePickerEvents = function () {
            var $this, $parent, expanded, closed, collapseData;
            picker.widget.on('click', '.datepicker *', $.proxy(click, this)); // this handles date picker clicks
            picker.widget.on('click', '[data-action]', $.proxy(doAction, this)); // this handles time picker clicks
            picker.widget.on('mousedown', $.proxy(stopEvent, this));
            if (picker.options.pickDate && picker.options.pickTime) {
                picker.widget.on('click.togglePicker', '.accordion-toggle', function (e) {
                    e.stopPropagation();
                    $this = $(this);
                    $parent = $this.closest('ul');
                    expanded = $parent.find('.in');
                    closed = $parent.find('.collapse:not(.in)');

                    if (expanded && expanded.length) {
                        collapseData = expanded.data('collapse');
                        if (collapseData && collapseData.transitioning) return;
                        expanded.collapse('hide');
                        closed.collapse('show');
                        $this.find('span').toggleClass(picker.options.icons.time + ' ' + picker.options.icons.date);
                        picker.element.find('.input-group-addon span').toggleClass(picker.options.icons.time + ' ' + picker.options.icons.date);
                    }
                });
            }
            if (picker.isInput) {
                picker.element.on({
                    'focus': $.proxy(picker.show, this),
                    'change': $.proxy(change, this),
                    'blur': $.proxy(picker.hide, this)
                });
            } else {
                picker.element.on({
                    'change': $.proxy(change, this)
                }, 'input');
                if (picker.component) {
                    picker.component.on('click', $.proxy(picker.show, this));
                } else {
                    picker.element.on('click', $.proxy(picker.show, this));
                }
            }
        },

        attachDatePickerGlobalEvents = function () {
            $(window).on(
                'resize.datetimepicker' + picker.id, $.proxy(place, this));
            if (!picker.isInput) {
                $(document).on(
                    'mousedown.datetimepicker' + picker.id, $.proxy(picker.hide, this));
            }
        },

        detachDatePickerEvents = function () {
            picker.widget.off('click', '.datepicker *', picker.click);
            picker.widget.off('click', '[data-action]');
            picker.widget.off('mousedown', picker.stopEvent);
            if (picker.options.pickDate && picker.options.pickTime) {
                picker.widget.off('click.togglePicker');
            }
            if (picker.isInput) {
                picker.element.off({
                    'focus': picker.show,
                    'change': picker.change
                });
            } else {
                picker.element.off({
                    'change': picker.change
                }, 'input');
                if (picker.component) {
                    picker.component.off('click', picker.show);
                } else {
                    picker.element.off('click', picker.show);
                }
            }
        },

        detachDatePickerGlobalEvents = function () {
            $(window).off('resize.datetimepicker' + picker.id);
            if (!picker.isInput) {
                $(document).off('mousedown.datetimepicker' + picker.id);
            }
        },

        isInFixed = function () {
            if (picker.element) {
                var parents = picker.element.parents(), inFixed = false, i;
                for (i = 0; i < parents.length; i++) {
                    if ($(parents[i]).css('position') == 'fixed') {
                        inFixed = true;
                        break;
                    }
                }
                ;
                return inFixed;
            } else {
                return false;
            }
        },

        set = function () {
            pMoment.lang(picker.options.language);
            var formatted = '', input;
            if (!picker.unset) formatted = pMoment(picker.date).format(picker.format);
            if (!picker.isInput) {
                if (picker.component) {
                    input = picker.element.find('input');
                    input.val(formatted);
                }
                picker.element.data('date', formatted);
            } else {
                picker.element.val(formatted);
            }
            if (!picker.options.pickTime) picker.hide();
        },

		checkDate = function (direction, unit, amount) {
		    pMoment.lang(picker.options.language);
		    var newDate;
		    if (direction == "add") {
		        newDate = pMoment(picker.date);
		        if (newDate.hours() == 23) newDate.add(amount, unit);
		        newDate.add(amount, unit);
		    }
		    else {
		        newDate = pMoment(picker.date).subtract(amount, unit);
		    }
		    if (isInDisableDates(pMoment(newDate.subtract(amount, unit))) || isInDisableDates(newDate)) {
		        notifyError(newDate.format(picker.format));
		        return;
		    }

		    if (direction == "add") {
		        picker.date.add(amount, unit);
		    }
		    else {
		        picker.date.subtract(amount, unit);
		    }
            picker.unset = false;
		},

		isInDisableDates = function (date) {
		    pMoment.lang(picker.options.language);
            if (date.isAfter(picker.options.endDate) || date.isBefore(picker.options.startDate)) return true;
		    var disabled = picker.options.disabledDates, i;
		    for (i in disabled) {
		        if (disabled[i] == pMoment(date).format("L")) {
		            return true;
		        }
		    }
		    return false;
		},

        isInEnableDates = function (date) {
            pMoment.lang(picker.options.language);
            var enabled = picker.options.enabledDates, i;
            if (enabled.length) {
                for (i in enabled) {
                    if (enabled[i] == pMoment(date).format("L")) {
                        return true;
                    }
                }
                return false;
            }
            return enabled === false ? true : false;
        },
        padLeft = function (string) {
            string = string.toString();
            if (string.length >= 2) return string;
            else return '0' + string;
        },

        getTemplate = function (pickDate, pickTime, collapse) {
            if (pickDate && pickTime) {
                return (
                    '<div class="bootstrap-datetimepicker-widget dropdown-menu" style="z-index:9999 !important;">' +
                        '<ul class="list-unstyled">' +
							'<li' + (collapse ? ' class="collapse in"' : '') + '>' +
								'<div class="datepicker">' + dpGlobal.template + '</div>' +
							'</li>' +
							'<li class="picker-switch accordion-toggle"><a class="btn" style="width:100%"><span class="' + picker.options.icons.time + '"></span></a></li>' +
							'<li' + (collapse ? ' class="collapse"' : '') + '>' +
								'<div class="timepicker">' + tpGlobal.getTemplate() + '</div>' +
							'</li>' +
                        '</ul>' +
                    '</div>'
                );
            } else if (pickTime) {
                return (
                    '<div class="bootstrap-datetimepicker-widget dropdown-menu">' +
                        '<div class="timepicker">' + tpGlobal.getTemplate() + '</div>' +
                    '</div>'
                );
            } else {
                return (
                    '<div class="bootstrap-datetimepicker-widget dropdown-menu">' +
                        '<div class="datepicker">' + dpGlobal.template + '</div>' +
                    '</div>'
                );
            }
        },

		dpGlobal = {
		    modes: [
                {
                    clsName: 'days',
                    navFnc: 'month',
                    navStep: 1
                },
                {
                    clsName: 'months',
                    navFnc: 'year',
                    navStep: 1
                },
                {
                    clsName: 'years',
                    navFnc: 'year',
                    navStep: 10
                }],
		    headTemplate:
                    '<thead>' +
						'<tr>' +
							'<th class="prev">&lsaquo;</th><th colspan="5" class="switch"></th><th class="next">&rsaquo;</th>' +
						'</tr>' +
                    '</thead>',
		    contTemplate:
        '<tbody><tr><td colspan="7"></td></tr></tbody>'
		},

        tpGlobal = {
            hourTemplate:   '<span data-action="showHours"   data-time-component="hours"   class="timepicker-hour"></span>',
            minuteTemplate: '<span data-action="showMinutes" data-time-component="minutes" class="timepicker-minute"></span>',
			secondTemplate: '<span data-action="showSeconds"  data-time-component="seconds" class="timepicker-second"></span>'
        };

        dpGlobal.template =
            '<div class="datepicker-days">' +
                '<table class="table-condensed">' + dpGlobal.headTemplate + '<tbody></tbody></table>' +
            '</div>' +
            '<div class="datepicker-months">' +
                '<table class="table-condensed">' + dpGlobal.headTemplate + dpGlobal.contTemplate + '</table>' +
            '</div>' +
            '<div class="datepicker-years">' +
				'<table class="table-condensed">' + dpGlobal.headTemplate + dpGlobal.contTemplate + '</table>' +
            '</div>';

        tpGlobal.getTemplate = function () {
            return (
                '<div class="timepicker-picker">' +
                    '<table class="table-condensed">' +
						'<tr>' +
							'<td><a href="#" class="btn" data-action="incrementHours"><span class="' + picker.options.icons.up + '"></span></a></td>' +
							'<td class="separator"></td>' +
							'<td>' + (picker.options.useMinutes ? '<a href="#" class="btn" data-action="incrementMinutes"><span class="' + picker.options.icons.up + '"></span></a>' : '') + '</td>' +
                            (picker.options.useSeconds ?
                                '<td class="separator"></td><td><a href="#" class="btn" data-action="incrementSeconds"><span class="' + picker.options.icons.up + '"></span></a></td>' : '') +
							(picker.options.use24hours ? '' : '<td class="separator"></td>') +
						'</tr>' +
						'<tr>' +
							'<td>' + tpGlobal.hourTemplate + '</td> ' +
							'<td class="separator">:</td>' +
							'<td>' + (picker.options.useMinutes ? tpGlobal.minuteTemplate : '<span class="timepicker-minute">00</span>') + '</td> ' +
                            (picker.options.useSeconds ?
                                '<td class="separator">:</td><td>' + tpGlobal.secondTemplate + '</td>' : '') +
							(picker.options.use24hours ? '' : '<td class="separator"></td>' +
							'<td><button type="button" class="btn btn-primary" data-action="togglePeriod"></button></td>') +
						'</tr>' +
						'<tr>' +
							'<td><a href="#" class="btn" data-action="decrementHours"><span class="' + picker.options.icons.down + '"></span></a></td>' +
							'<td class="separator"></td>' +
							'<td>' + (picker.options.useMinutes ? '<a href="#" class="btn" data-action="decrementMinutes"><span class="' + picker.options.icons.down + '"></span></a>' : '') + '</td>' +
                            (picker.options.useSeconds ?
                                '<td class="separator"></td><td><a href="#" class="btn" data-action="decrementSeconds"><span class="' + picker.options.icons.down + '"></span></a></td>' : '') +
							(picker.options.use24hours ? '' : '<td class="separator"></td>') +
						'</tr>' +
                    '</table>' +
                '</div>' +
                '<div class="timepicker-hours" data-action="selectHour">' +
                    '<table class="table-condensed"></table>' +
                '</div>' +
                '<div class="timepicker-minutes" data-action="selectMinute">' +
                    '<table class="table-condensed"></table>' +
                '</div>' +
                (picker.options.useSeconds ?
                    '<div class="timepicker-seconds" data-action="selectSecond"><table class="table-condensed"></table></div>' : '')
            );
        };

        picker.destroy = function () {
            detachDatePickerEvents();
            detachDatePickerGlobalEvents();
            picker.widget.remove();
            picker.element.removeData('DateTimePicker');
            if (picker.component)
                picker.component.removeData('DateTimePicker');
        };

        picker.show = function (e) {
            picker.widget.show();
            picker.height = picker.component ? picker.component.outerHeight() : picker.element.outerHeight();
            place();
            picker.element.trigger({
                type: 'show.dp',
                date: pMoment(picker.date)
            });
            attachDatePickerGlobalEvents();
            if (e) {
                stopEvent(e);
            }
        },

        picker.disable = function () {
            var input = picker.element.find('input');
            if(input.prop('disabled')) return;

            input.prop('disabled', true);
            detachDatePickerEvents();
        },

        picker.enable = function () {
            var input = picker.element.find('input');
            if(!input.prop('disabled')) return;

            input.prop('disabled', false);
            attachDatePickerEvents();
        },

        picker.hide = function (event) {
            if (event && $(event.target).is(picker.element.attr("id")))
                return;
            // Ignore event if in the middle of a picker transition
            var collapse = picker.widget.find('.collapse'), i, collapseData;
            for (i = 0; i < collapse.length; i++) {
                collapseData = collapse.eq(i).data('collapse');
                if (collapseData && collapseData.transitioning)
                    return;
            }
            picker.widget.hide();
            picker.viewMode = picker.startViewMode;
            showMode();
            picker.element.trigger({
                type: 'hide.dp',
                date: pMoment(picker.date)
            });
            detachDatePickerGlobalEvents();
        },

        picker.setValue = function (newDate) {
            pMoment.lang(picker.options.language);
            if (!newDate) {
                picker.unset = true;
            } else {
                picker.unset = false;
            }
            if (!pMoment.isMoment(newDate)) newDate = pMoment(newDate);
            if (newDate.isValid()) {
                picker.date = newDate;
                set();
                picker.viewDate = pMoment({ y: picker.date.year(), M: picker.date.month() });
                fillDate();
                fillTime();
            }
            else {
                notifyError(newDate);
            }
        },

        picker.getDate = function () {
            if (picker.unset) return null;
            return picker.date;
        },

        picker.setDate = function (date) {
            date = pMoment(date);
            if (!date) picker.setValue(null);
            else picker.setValue(date);
        },

        picker.setEnabledDates = function (dates) {
            if (!dates) picker.options.enabledDates = false;
            else picker.options.enabledDates = dates;
            if (picker.viewDate) update();
        },

        picker.setEndDate = function (date) {
            if (date == undefined) return;
            picker.options.endDate = pMoment(date);
            if (picker.viewDate) update();
        },

        picker.setStartDate = function (date) {
            if (date == undefined) return;
            picker.options.startDate = pMoment(date);
            if (picker.viewDate) update();
        };

        init();
    };

    $.fn.datetimepicker = function (options) {
        return this.each(function () {
            var $this = $(this), data = $this.data('DateTimePicker');
            if (!data) $this.data('DateTimePicker', new DateTimePicker(this, options));
        });
    };
}));
},{}],138:[function(require,module,exports){
// This file is autogenerated via the `commonjs` Grunt task. You can require() this file in a CommonJS environment.
require('../../js/transition.js')
require('../../js/alert.js')
require('../../js/button.js')
require('../../js/carousel.js')
require('../../js/collapse.js')
require('../../js/dropdown.js')
require('../../js/modal.js')
require('../../js/tooltip.js')
require('../../js/popover.js')
require('../../js/scrollspy.js')
require('../../js/tab.js')
require('../../js/affix.js')
},{"../../js/affix.js":139,"../../js/alert.js":140,"../../js/button.js":141,"../../js/carousel.js":142,"../../js/collapse.js":143,"../../js/dropdown.js":144,"../../js/modal.js":145,"../../js/popover.js":146,"../../js/scrollspy.js":147,"../../js/tab.js":148,"../../js/tooltip.js":149,"../../js/transition.js":150}],139:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: affix.js v3.3.4
 * http://getbootstrap.com/javascript/#affix
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // AFFIX CLASS DEFINITION
  // ======================

  var Affix = function (element, options) {
    this.options = $.extend({}, Affix.DEFAULTS, options)

    this.$target = $(this.options.target)
      .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))
      .on('click.bs.affix.data-api',  $.proxy(this.checkPositionWithEventLoop, this))

    this.$element     = $(element)
    this.affixed      = null
    this.unpin        = null
    this.pinnedOffset = null

    this.checkPosition()
  }

  Affix.VERSION  = '3.3.4'

  Affix.RESET    = 'affix affix-top affix-bottom'

  Affix.DEFAULTS = {
    offset: 0,
    target: window
  }

  Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {
    var scrollTop    = this.$target.scrollTop()
    var position     = this.$element.offset()
    var targetHeight = this.$target.height()

    if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false

    if (this.affixed == 'bottom') {
      if (offsetTop != null) return (scrollTop + this.unpin <= position.top) ? false : 'bottom'
      return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : 'bottom'
    }

    var initializing   = this.affixed == null
    var colliderTop    = initializing ? scrollTop : position.top
    var colliderHeight = initializing ? targetHeight : height

    if (offsetTop != null && scrollTop <= offsetTop) return 'top'
    if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom)) return 'bottom'

    return false
  }

  Affix.prototype.getPinnedOffset = function () {
    if (this.pinnedOffset) return this.pinnedOffset
    this.$element.removeClass(Affix.RESET).addClass('affix')
    var scrollTop = this.$target.scrollTop()
    var position  = this.$element.offset()
    return (this.pinnedOffset = position.top - scrollTop)
  }

  Affix.prototype.checkPositionWithEventLoop = function () {
    setTimeout($.proxy(this.checkPosition, this), 1)
  }

  Affix.prototype.checkPosition = function () {
    if (!this.$element.is(':visible')) return

    var height       = this.$element.height()
    var offset       = this.options.offset
    var offsetTop    = offset.top
    var offsetBottom = offset.bottom
    var scrollHeight = $(document.body).height()

    if (typeof offset != 'object')         offsetBottom = offsetTop = offset
    if (typeof offsetTop == 'function')    offsetTop    = offset.top(this.$element)
    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element)

    var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)

    if (this.affixed != affix) {
      if (this.unpin != null) this.$element.css('top', '')

      var affixType = 'affix' + (affix ? '-' + affix : '')
      var e         = $.Event(affixType + '.bs.affix')

      this.$element.trigger(e)

      if (e.isDefaultPrevented()) return

      this.affixed = affix
      this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null

      this.$element
        .removeClass(Affix.RESET)
        .addClass(affixType)
        .trigger(affixType.replace('affix', 'affixed') + '.bs.affix')
    }

    if (affix == 'bottom') {
      this.$element.offset({
        top: scrollHeight - height - offsetBottom
      })
    }
  }


  // AFFIX PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.affix')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.affix', (data = new Affix(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.affix

  $.fn.affix             = Plugin
  $.fn.affix.Constructor = Affix


  // AFFIX NO CONFLICT
  // =================

  $.fn.affix.noConflict = function () {
    $.fn.affix = old
    return this
  }


  // AFFIX DATA-API
  // ==============

  $(window).on('load', function () {
    $('[data-spy="affix"]').each(function () {
      var $spy = $(this)
      var data = $spy.data()

      data.offset = data.offset || {}

      if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom
      if (data.offsetTop    != null) data.offset.top    = data.offsetTop

      Plugin.call($spy, data)
    })
  })

}(jQuery);

},{}],140:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: alert.js v3.3.4
 * http://getbootstrap.com/javascript/#alerts
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // ALERT CLASS DEFINITION
  // ======================

  var dismiss = '[data-dismiss="alert"]'
  var Alert   = function (el) {
    $(el).on('click', dismiss, this.close)
  }

  Alert.VERSION = '3.3.4'

  Alert.TRANSITION_DURATION = 150

  Alert.prototype.close = function (e) {
    var $this    = $(this)
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = $(selector)

    if (e) e.preventDefault()

    if (!$parent.length) {
      $parent = $this.closest('.alert')
    }

    $parent.trigger(e = $.Event('close.bs.alert'))

    if (e.isDefaultPrevented()) return

    $parent.removeClass('in')

    function removeElement() {
      // detach from parent, fire event then clean up data
      $parent.detach().trigger('closed.bs.alert').remove()
    }

    $.support.transition && $parent.hasClass('fade') ?
      $parent
        .one('bsTransitionEnd', removeElement)
        .emulateTransitionEnd(Alert.TRANSITION_DURATION) :
      removeElement()
  }


  // ALERT PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.alert')

      if (!data) $this.data('bs.alert', (data = new Alert(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  var old = $.fn.alert

  $.fn.alert             = Plugin
  $.fn.alert.Constructor = Alert


  // ALERT NO CONFLICT
  // =================

  $.fn.alert.noConflict = function () {
    $.fn.alert = old
    return this
  }


  // ALERT DATA-API
  // ==============

  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)

}(jQuery);

},{}],141:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: button.js v3.3.4
 * http://getbootstrap.com/javascript/#buttons
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // BUTTON PUBLIC CLASS DEFINITION
  // ==============================

  var Button = function (element, options) {
    this.$element  = $(element)
    this.options   = $.extend({}, Button.DEFAULTS, options)
    this.isLoading = false
  }

  Button.VERSION  = '3.3.4'

  Button.DEFAULTS = {
    loadingText: 'loading...'
  }

  Button.prototype.setState = function (state) {
    var d    = 'disabled'
    var $el  = this.$element
    var val  = $el.is('input') ? 'val' : 'html'
    var data = $el.data()

    state = state + 'Text'

    if (data.resetText == null) $el.data('resetText', $el[val]())

    // push to event loop to allow forms to submit
    setTimeout($.proxy(function () {
      $el[val](data[state] == null ? this.options[state] : data[state])

      if (state == 'loadingText') {
        this.isLoading = true
        $el.addClass(d).attr(d, d)
      } else if (this.isLoading) {
        this.isLoading = false
        $el.removeClass(d).removeAttr(d)
      }
    }, this), 0)
  }

  Button.prototype.toggle = function () {
    var changed = true
    var $parent = this.$element.closest('[data-toggle="buttons"]')

    if ($parent.length) {
      var $input = this.$element.find('input')
      if ($input.prop('type') == 'radio') {
        if ($input.prop('checked') && this.$element.hasClass('active')) changed = false
        else $parent.find('.active').removeClass('active')
      }
      if (changed) $input.prop('checked', !this.$element.hasClass('active')).trigger('change')
    } else {
      this.$element.attr('aria-pressed', !this.$element.hasClass('active'))
    }

    if (changed) this.$element.toggleClass('active')
  }


  // BUTTON PLUGIN DEFINITION
  // ========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.button')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.button', (data = new Button(this, options)))

      if (option == 'toggle') data.toggle()
      else if (option) data.setState(option)
    })
  }

  var old = $.fn.button

  $.fn.button             = Plugin
  $.fn.button.Constructor = Button


  // BUTTON NO CONFLICT
  // ==================

  $.fn.button.noConflict = function () {
    $.fn.button = old
    return this
  }


  // BUTTON DATA-API
  // ===============

  $(document)
    .on('click.bs.button.data-api', '[data-toggle^="button"]', function (e) {
      var $btn = $(e.target)
      if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn')
      Plugin.call($btn, 'toggle')
      e.preventDefault()
    })
    .on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^="button"]', function (e) {
      $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type))
    })

}(jQuery);

},{}],142:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: carousel.js v3.3.4
 * http://getbootstrap.com/javascript/#carousel
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CAROUSEL CLASS DEFINITION
  // =========================

  var Carousel = function (element, options) {
    this.$element    = $(element)
    this.$indicators = this.$element.find('.carousel-indicators')
    this.options     = options
    this.paused      = null
    this.sliding     = null
    this.interval    = null
    this.$active     = null
    this.$items      = null

    this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this))

    this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element
      .on('mouseenter.bs.carousel', $.proxy(this.pause, this))
      .on('mouseleave.bs.carousel', $.proxy(this.cycle, this))
  }

  Carousel.VERSION  = '3.3.4'

  Carousel.TRANSITION_DURATION = 600

  Carousel.DEFAULTS = {
    interval: 5000,
    pause: 'hover',
    wrap: true,
    keyboard: true
  }

  Carousel.prototype.keydown = function (e) {
    if (/input|textarea/i.test(e.target.tagName)) return
    switch (e.which) {
      case 37: this.prev(); break
      case 39: this.next(); break
      default: return
    }

    e.preventDefault()
  }

  Carousel.prototype.cycle = function (e) {
    e || (this.paused = false)

    this.interval && clearInterval(this.interval)

    this.options.interval
      && !this.paused
      && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))

    return this
  }

  Carousel.prototype.getItemIndex = function (item) {
    this.$items = item.parent().children('.item')
    return this.$items.index(item || this.$active)
  }

  Carousel.prototype.getItemForDirection = function (direction, active) {
    var activeIndex = this.getItemIndex(active)
    var willWrap = (direction == 'prev' && activeIndex === 0)
                || (direction == 'next' && activeIndex == (this.$items.length - 1))
    if (willWrap && !this.options.wrap) return active
    var delta = direction == 'prev' ? -1 : 1
    var itemIndex = (activeIndex + delta) % this.$items.length
    return this.$items.eq(itemIndex)
  }

  Carousel.prototype.to = function (pos) {
    var that        = this
    var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'))

    if (pos > (this.$items.length - 1) || pos < 0) return

    if (this.sliding)       return this.$element.one('slid.bs.carousel', function () { that.to(pos) }) // yes, "slid"
    if (activeIndex == pos) return this.pause().cycle()

    return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos))
  }

  Carousel.prototype.pause = function (e) {
    e || (this.paused = true)

    if (this.$element.find('.next, .prev').length && $.support.transition) {
      this.$element.trigger($.support.transition.end)
      this.cycle(true)
    }

    this.interval = clearInterval(this.interval)

    return this
  }

  Carousel.prototype.next = function () {
    if (this.sliding) return
    return this.slide('next')
  }

  Carousel.prototype.prev = function () {
    if (this.sliding) return
    return this.slide('prev')
  }

  Carousel.prototype.slide = function (type, next) {
    var $active   = this.$element.find('.item.active')
    var $next     = next || this.getItemForDirection(type, $active)
    var isCycling = this.interval
    var direction = type == 'next' ? 'left' : 'right'
    var that      = this

    if ($next.hasClass('active')) return (this.sliding = false)

    var relatedTarget = $next[0]
    var slideEvent = $.Event('slide.bs.carousel', {
      relatedTarget: relatedTarget,
      direction: direction
    })
    this.$element.trigger(slideEvent)
    if (slideEvent.isDefaultPrevented()) return

    this.sliding = true

    isCycling && this.pause()

    if (this.$indicators.length) {
      this.$indicators.find('.active').removeClass('active')
      var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])
      $nextIndicator && $nextIndicator.addClass('active')
    }

    var slidEvent = $.Event('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }) // yes, "slid"
    if ($.support.transition && this.$element.hasClass('slide')) {
      $next.addClass(type)
      $next[0].offsetWidth // force reflow
      $active.addClass(direction)
      $next.addClass(direction)
      $active
        .one('bsTransitionEnd', function () {
          $next.removeClass([type, direction].join(' ')).addClass('active')
          $active.removeClass(['active', direction].join(' '))
          that.sliding = false
          setTimeout(function () {
            that.$element.trigger(slidEvent)
          }, 0)
        })
        .emulateTransitionEnd(Carousel.TRANSITION_DURATION)
    } else {
      $active.removeClass('active')
      $next.addClass('active')
      this.sliding = false
      this.$element.trigger(slidEvent)
    }

    isCycling && this.cycle()

    return this
  }


  // CAROUSEL PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.carousel')
      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)
      var action  = typeof option == 'string' ? option : options.slide

      if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))
      if (typeof option == 'number') data.to(option)
      else if (action) data[action]()
      else if (options.interval) data.pause().cycle()
    })
  }

  var old = $.fn.carousel

  $.fn.carousel             = Plugin
  $.fn.carousel.Constructor = Carousel


  // CAROUSEL NO CONFLICT
  // ====================

  $.fn.carousel.noConflict = function () {
    $.fn.carousel = old
    return this
  }


  // CAROUSEL DATA-API
  // =================

  var clickHandler = function (e) {
    var href
    var $this   = $(this)
    var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) // strip for ie7
    if (!$target.hasClass('carousel')) return
    var options = $.extend({}, $target.data(), $this.data())
    var slideIndex = $this.attr('data-slide-to')
    if (slideIndex) options.interval = false

    Plugin.call($target, options)

    if (slideIndex) {
      $target.data('bs.carousel').to(slideIndex)
    }

    e.preventDefault()
  }

  $(document)
    .on('click.bs.carousel.data-api', '[data-slide]', clickHandler)
    .on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler)

  $(window).on('load', function () {
    $('[data-ride="carousel"]').each(function () {
      var $carousel = $(this)
      Plugin.call($carousel, $carousel.data())
    })
  })

}(jQuery);

},{}],143:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: collapse.js v3.3.4
 * http://getbootstrap.com/javascript/#collapse
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // COLLAPSE PUBLIC CLASS DEFINITION
  // ================================

  var Collapse = function (element, options) {
    this.$element      = $(element)
    this.options       = $.extend({}, Collapse.DEFAULTS, options)
    this.$trigger      = $('[data-toggle="collapse"][href="#' + element.id + '"],' +
                           '[data-toggle="collapse"][data-target="#' + element.id + '"]')
    this.transitioning = null

    if (this.options.parent) {
      this.$parent = this.getParent()
    } else {
      this.addAriaAndCollapsedClass(this.$element, this.$trigger)
    }

    if (this.options.toggle) this.toggle()
  }

  Collapse.VERSION  = '3.3.4'

  Collapse.TRANSITION_DURATION = 350

  Collapse.DEFAULTS = {
    toggle: true
  }

  Collapse.prototype.dimension = function () {
    var hasWidth = this.$element.hasClass('width')
    return hasWidth ? 'width' : 'height'
  }

  Collapse.prototype.show = function () {
    if (this.transitioning || this.$element.hasClass('in')) return

    var activesData
    var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing')

    if (actives && actives.length) {
      activesData = actives.data('bs.collapse')
      if (activesData && activesData.transitioning) return
    }

    var startEvent = $.Event('show.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return

    if (actives && actives.length) {
      Plugin.call(actives, 'hide')
      activesData || actives.data('bs.collapse', null)
    }

    var dimension = this.dimension()

    this.$element
      .removeClass('collapse')
      .addClass('collapsing')[dimension](0)
      .attr('aria-expanded', true)

    this.$trigger
      .removeClass('collapsed')
      .attr('aria-expanded', true)

    this.transitioning = 1

    var complete = function () {
      this.$element
        .removeClass('collapsing')
        .addClass('collapse in')[dimension]('')
      this.transitioning = 0
      this.$element
        .trigger('shown.bs.collapse')
    }

    if (!$.support.transition) return complete.call(this)

    var scrollSize = $.camelCase(['scroll', dimension].join('-'))

    this.$element
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])
  }

  Collapse.prototype.hide = function () {
    if (this.transitioning || !this.$element.hasClass('in')) return

    var startEvent = $.Event('hide.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return

    var dimension = this.dimension()

    this.$element[dimension](this.$element[dimension]())[0].offsetHeight

    this.$element
      .addClass('collapsing')
      .removeClass('collapse in')
      .attr('aria-expanded', false)

    this.$trigger
      .addClass('collapsed')
      .attr('aria-expanded', false)

    this.transitioning = 1

    var complete = function () {
      this.transitioning = 0
      this.$element
        .removeClass('collapsing')
        .addClass('collapse')
        .trigger('hidden.bs.collapse')
    }

    if (!$.support.transition) return complete.call(this)

    this.$element
      [dimension](0)
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)
  }

  Collapse.prototype.toggle = function () {
    this[this.$element.hasClass('in') ? 'hide' : 'show']()
  }

  Collapse.prototype.getParent = function () {
    return $(this.options.parent)
      .find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]')
      .each($.proxy(function (i, element) {
        var $element = $(element)
        this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)
      }, this))
      .end()
  }

  Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {
    var isOpen = $element.hasClass('in')

    $element.attr('aria-expanded', isOpen)
    $trigger
      .toggleClass('collapsed', !isOpen)
      .attr('aria-expanded', isOpen)
  }

  function getTargetFromTrigger($trigger) {
    var href
    var target = $trigger.attr('data-target')
      || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') // strip for ie7

    return $(target)
  }


  // COLLAPSE PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.collapse')
      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false
      if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.collapse

  $.fn.collapse             = Plugin
  $.fn.collapse.Constructor = Collapse


  // COLLAPSE NO CONFLICT
  // ====================

  $.fn.collapse.noConflict = function () {
    $.fn.collapse = old
    return this
  }


  // COLLAPSE DATA-API
  // =================

  $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function (e) {
    var $this   = $(this)

    if (!$this.attr('data-target')) e.preventDefault()

    var $target = getTargetFromTrigger($this)
    var data    = $target.data('bs.collapse')
    var option  = data ? 'toggle' : $this.data()

    Plugin.call($target, option)
  })

}(jQuery);

},{}],144:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: dropdown.js v3.3.4
 * http://getbootstrap.com/javascript/#dropdowns
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // DROPDOWN CLASS DEFINITION
  // =========================

  var backdrop = '.dropdown-backdrop'
  var toggle   = '[data-toggle="dropdown"]'
  var Dropdown = function (element) {
    $(element).on('click.bs.dropdown', this.toggle)
  }

  Dropdown.VERSION = '3.3.4'

  Dropdown.prototype.toggle = function (e) {
    var $this = $(this)

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    clearMenus()

    if (!isActive) {
      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
        // if mobile we use a backdrop because click events don't delegate
        $('<div class="dropdown-backdrop"/>').insertAfter($(this)).on('click', clearMenus)
      }

      var relatedTarget = { relatedTarget: this }
      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this
        .trigger('focus')
        .attr('aria-expanded', 'true')

      $parent
        .toggleClass('open')
        .trigger('shown.bs.dropdown', relatedTarget)
    }

    return false
  }

  Dropdown.prototype.keydown = function (e) {
    if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return

    var $this = $(this)

    e.preventDefault()
    e.stopPropagation()

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    if ((!isActive && e.which != 27) || (isActive && e.which == 27)) {
      if (e.which == 27) $parent.find(toggle).trigger('focus')
      return $this.trigger('click')
    }

    var desc = ' li:not(.disabled):visible a'
    var $items = $parent.find('[role="menu"]' + desc + ', [role="listbox"]' + desc)

    if (!$items.length) return

    var index = $items.index(e.target)

    if (e.which == 38 && index > 0)                 index--                        // up
    if (e.which == 40 && index < $items.length - 1) index++                        // down
    if (!~index)                                      index = 0

    $items.eq(index).trigger('focus')
  }

  function clearMenus(e) {
    if (e && e.which === 3) return
    $(backdrop).remove()
    $(toggle).each(function () {
      var $this         = $(this)
      var $parent       = getParent($this)
      var relatedTarget = { relatedTarget: this }

      if (!$parent.hasClass('open')) return

      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this.attr('aria-expanded', 'false')
      $parent.removeClass('open').trigger('hidden.bs.dropdown', relatedTarget)
    })
  }

  function getParent($this) {
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = selector && $(selector)

    return $parent && $parent.length ? $parent : $this.parent()
  }


  // DROPDOWN PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.dropdown')

      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  var old = $.fn.dropdown

  $.fn.dropdown             = Plugin
  $.fn.dropdown.Constructor = Dropdown


  // DROPDOWN NO CONFLICT
  // ====================

  $.fn.dropdown.noConflict = function () {
    $.fn.dropdown = old
    return this
  }


  // APPLY TO STANDARD DROPDOWN ELEMENTS
  // ===================================

  $(document)
    .on('click.bs.dropdown.data-api', clearMenus)
    .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
    .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)
    .on('keydown.bs.dropdown.data-api', '[role="menu"]', Dropdown.prototype.keydown)
    .on('keydown.bs.dropdown.data-api', '[role="listbox"]', Dropdown.prototype.keydown)

}(jQuery);

},{}],145:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: modal.js v3.3.4
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // MODAL CLASS DEFINITION
  // ======================

  var Modal = function (element, options) {
    this.options             = options
    this.$body               = $(document.body)
    this.$element            = $(element)
    this.$dialog             = this.$element.find('.modal-dialog')
    this.$backdrop           = null
    this.isShown             = null
    this.originalBodyPad     = null
    this.scrollbarWidth      = 0
    this.ignoreBackdropClick = false

    if (this.options.remote) {
      this.$element
        .find('.modal-content')
        .load(this.options.remote, $.proxy(function () {
          this.$element.trigger('loaded.bs.modal')
        }, this))
    }
  }

  Modal.VERSION  = '3.3.4'

  Modal.TRANSITION_DURATION = 300
  Modal.BACKDROP_TRANSITION_DURATION = 150

  Modal.DEFAULTS = {
    backdrop: true,
    keyboard: true,
    show: true
  }

  Modal.prototype.toggle = function (_relatedTarget) {
    return this.isShown ? this.hide() : this.show(_relatedTarget)
  }

  Modal.prototype.show = function (_relatedTarget) {
    var that = this
    var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })

    this.$element.trigger(e)

    if (this.isShown || e.isDefaultPrevented()) return

    this.isShown = true

    this.checkScrollbar()
    this.setScrollbar()
    this.$body.addClass('modal-open')

    this.escape()
    this.resize()

    this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this))

    this.$dialog.on('mousedown.dismiss.bs.modal', function () {
      that.$element.one('mouseup.dismiss.bs.modal', function (e) {
        if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true
      })
    })

    this.backdrop(function () {
      var transition = $.support.transition && that.$element.hasClass('fade')

      if (!that.$element.parent().length) {
        that.$element.appendTo(that.$body) // don't move modals dom position
      }

      that.$element
        .show()
        .scrollTop(0)

      that.adjustDialog()

      if (transition) {
        that.$element[0].offsetWidth // force reflow
      }

      that.$element
        .addClass('in')
        .attr('aria-hidden', false)

      that.enforceFocus()

      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })

      transition ?
        that.$dialog // wait for modal to slide in
          .one('bsTransitionEnd', function () {
            that.$element.trigger('focus').trigger(e)
          })
          .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
        that.$element.trigger('focus').trigger(e)
    })
  }

  Modal.prototype.hide = function (e) {
    if (e) e.preventDefault()

    e = $.Event('hide.bs.modal')

    this.$element.trigger(e)

    if (!this.isShown || e.isDefaultPrevented()) return

    this.isShown = false

    this.escape()
    this.resize()

    $(document).off('focusin.bs.modal')

    this.$element
      .removeClass('in')
      .attr('aria-hidden', true)
      .off('click.dismiss.bs.modal')
      .off('mouseup.dismiss.bs.modal')

    this.$dialog.off('mousedown.dismiss.bs.modal')

    $.support.transition && this.$element.hasClass('fade') ?
      this.$element
        .one('bsTransitionEnd', $.proxy(this.hideModal, this))
        .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
      this.hideModal()
  }

  Modal.prototype.enforceFocus = function () {
    $(document)
      .off('focusin.bs.modal') // guard against infinite focus loop
      .on('focusin.bs.modal', $.proxy(function (e) {
        if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
          this.$element.trigger('focus')
        }
      }, this))
  }

  Modal.prototype.escape = function () {
    if (this.isShown && this.options.keyboard) {
      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
        e.which == 27 && this.hide()
      }, this))
    } else if (!this.isShown) {
      this.$element.off('keydown.dismiss.bs.modal')
    }
  }

  Modal.prototype.resize = function () {
    if (this.isShown) {
      $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this))
    } else {
      $(window).off('resize.bs.modal')
    }
  }

  Modal.prototype.hideModal = function () {
    var that = this
    this.$element.hide()
    this.backdrop(function () {
      that.$body.removeClass('modal-open')
      that.resetAdjustments()
      that.resetScrollbar()
      that.$element.trigger('hidden.bs.modal')
    })
  }

  Modal.prototype.removeBackdrop = function () {
    this.$backdrop && this.$backdrop.remove()
    this.$backdrop = null
  }

  Modal.prototype.backdrop = function (callback) {
    var that = this
    var animate = this.$element.hasClass('fade') ? 'fade' : ''

    if (this.isShown && this.options.backdrop) {
      var doAnimate = $.support.transition && animate

      this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />')
        .appendTo(this.$body)

      this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
        if (this.ignoreBackdropClick) {
          this.ignoreBackdropClick = false
          return
        }
        if (e.target !== e.currentTarget) return
        this.options.backdrop == 'static'
          ? this.$element[0].focus()
          : this.hide()
      }, this))

      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

      this.$backdrop.addClass('in')

      if (!callback) return

      doAnimate ?
        this.$backdrop
          .one('bsTransitionEnd', callback)
          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callback()

    } else if (!this.isShown && this.$backdrop) {
      this.$backdrop.removeClass('in')

      var callbackRemove = function () {
        that.removeBackdrop()
        callback && callback()
      }
      $.support.transition && this.$element.hasClass('fade') ?
        this.$backdrop
          .one('bsTransitionEnd', callbackRemove)
          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callbackRemove()

    } else if (callback) {
      callback()
    }
  }

  // these following methods are used to handle overflowing modals

  Modal.prototype.handleUpdate = function () {
    this.adjustDialog()
  }

  Modal.prototype.adjustDialog = function () {
    var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight

    this.$element.css({
      paddingLeft:  !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
      paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
    })
  }

  Modal.prototype.resetAdjustments = function () {
    this.$element.css({
      paddingLeft: '',
      paddingRight: ''
    })
  }

  Modal.prototype.checkScrollbar = function () {
    var fullWindowWidth = window.innerWidth
    if (!fullWindowWidth) { // workaround for missing window.innerWidth in IE8
      var documentElementRect = document.documentElement.getBoundingClientRect()
      fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)
    }
    this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth
    this.scrollbarWidth = this.measureScrollbar()
  }

  Modal.prototype.setScrollbar = function () {
    var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)
    this.originalBodyPad = document.body.style.paddingRight || ''
    if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)
  }

  Modal.prototype.resetScrollbar = function () {
    this.$body.css('padding-right', this.originalBodyPad)
  }

  Modal.prototype.measureScrollbar = function () { // thx walsh
    var scrollDiv = document.createElement('div')
    scrollDiv.className = 'modal-scrollbar-measure'
    this.$body.append(scrollDiv)
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
    this.$body[0].removeChild(scrollDiv)
    return scrollbarWidth
  }


  // MODAL PLUGIN DEFINITION
  // =======================

  function Plugin(option, _relatedTarget) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.modal')
      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
      if (typeof option == 'string') data[option](_relatedTarget)
      else if (options.show) data.show(_relatedTarget)
    })
  }

  var old = $.fn.modal

  $.fn.modal             = Plugin
  $.fn.modal.Constructor = Modal


  // MODAL NO CONFLICT
  // =================

  $.fn.modal.noConflict = function () {
    $.fn.modal = old
    return this
  }


  // MODAL DATA-API
  // ==============

  $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
    var $this   = $(this)
    var href    = $this.attr('href')
    var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) // strip for ie7
    var option  = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())

    if ($this.is('a')) e.preventDefault()

    $target.one('show.bs.modal', function (showEvent) {
      if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown
      $target.one('hidden.bs.modal', function () {
        $this.is(':visible') && $this.trigger('focus')
      })
    })
    Plugin.call($target, option, this)
  })

}(jQuery);

},{}],146:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: popover.js v3.3.4
 * http://getbootstrap.com/javascript/#popovers
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // POPOVER PUBLIC CLASS DEFINITION
  // ===============================

  var Popover = function (element, options) {
    this.init('popover', element, options)
  }

  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')

  Popover.VERSION  = '3.3.4'

  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
    placement: 'right',
    trigger: 'click',
    content: '',
    template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
  })


  // NOTE: POPOVER EXTENDS tooltip.js
  // ================================

  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)

  Popover.prototype.constructor = Popover

  Popover.prototype.getDefaults = function () {
    return Popover.DEFAULTS
  }

  Popover.prototype.setContent = function () {
    var $tip    = this.tip()
    var title   = this.getTitle()
    var content = this.getContent()

    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
    $tip.find('.popover-content').children().detach().end()[ // we use append for html objects to maintain js events
      this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'
    ](content)

    $tip.removeClass('fade top bottom left right in')

    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
    // this manually by checking the contents.
    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
  }

  Popover.prototype.hasContent = function () {
    return this.getTitle() || this.getContent()
  }

  Popover.prototype.getContent = function () {
    var $e = this.$element
    var o  = this.options

    return $e.attr('data-content')
      || (typeof o.content == 'function' ?
            o.content.call($e[0]) :
            o.content)
  }

  Popover.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.arrow'))
  }


  // POPOVER PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.popover')
      var options = typeof option == 'object' && option

      if (!data && /destroy|hide/.test(option)) return
      if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.popover

  $.fn.popover             = Plugin
  $.fn.popover.Constructor = Popover


  // POPOVER NO CONFLICT
  // ===================

  $.fn.popover.noConflict = function () {
    $.fn.popover = old
    return this
  }

}(jQuery);

},{}],147:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: scrollspy.js v3.3.4
 * http://getbootstrap.com/javascript/#scrollspy
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // SCROLLSPY CLASS DEFINITION
  // ==========================

  function ScrollSpy(element, options) {
    this.$body          = $(document.body)
    this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)
    this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)
    this.selector       = (this.options.target || '') + ' .nav li > a'
    this.offsets        = []
    this.targets        = []
    this.activeTarget   = null
    this.scrollHeight   = 0

    this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this))
    this.refresh()
    this.process()
  }

  ScrollSpy.VERSION  = '3.3.4'

  ScrollSpy.DEFAULTS = {
    offset: 10
  }

  ScrollSpy.prototype.getScrollHeight = function () {
    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
  }

  ScrollSpy.prototype.refresh = function () {
    var that          = this
    var offsetMethod  = 'offset'
    var offsetBase    = 0

    this.offsets      = []
    this.targets      = []
    this.scrollHeight = this.getScrollHeight()

    if (!$.isWindow(this.$scrollElement[0])) {
      offsetMethod = 'position'
      offsetBase   = this.$scrollElement.scrollTop()
    }

    this.$body
      .find(this.selector)
      .map(function () {
        var $el   = $(this)
        var href  = $el.data('target') || $el.attr('href')
        var $href = /^#./.test(href) && $(href)

        return ($href
          && $href.length
          && $href.is(':visible')
          && [[$href[offsetMethod]().top + offsetBase, href]]) || null
      })
      .sort(function (a, b) { return a[0] - b[0] })
      .each(function () {
        that.offsets.push(this[0])
        that.targets.push(this[1])
      })
  }

  ScrollSpy.prototype.process = function () {
    var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset
    var scrollHeight = this.getScrollHeight()
    var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()
    var offsets      = this.offsets
    var targets      = this.targets
    var activeTarget = this.activeTarget
    var i

    if (this.scrollHeight != scrollHeight) {
      this.refresh()
    }

    if (scrollTop >= maxScroll) {
      return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)
    }

    if (activeTarget && scrollTop < offsets[0]) {
      this.activeTarget = null
      return this.clear()
    }

    for (i = offsets.length; i--;) {
      activeTarget != targets[i]
        && scrollTop >= offsets[i]
        && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1])
        && this.activate(targets[i])
    }
  }

  ScrollSpy.prototype.activate = function (target) {
    this.activeTarget = target

    this.clear()

    var selector = this.selector +
      '[data-target="' + target + '"],' +
      this.selector + '[href="' + target + '"]'

    var active = $(selector)
      .parents('li')
      .addClass('active')

    if (active.parent('.dropdown-menu').length) {
      active = active
        .closest('li.dropdown')
        .addClass('active')
    }

    active.trigger('activate.bs.scrollspy')
  }

  ScrollSpy.prototype.clear = function () {
    $(this.selector)
      .parentsUntil(this.options.target, '.active')
      .removeClass('active')
  }


  // SCROLLSPY PLUGIN DEFINITION
  // ===========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.scrollspy')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.scrollspy

  $.fn.scrollspy             = Plugin
  $.fn.scrollspy.Constructor = ScrollSpy


  // SCROLLSPY NO CONFLICT
  // =====================

  $.fn.scrollspy.noConflict = function () {
    $.fn.scrollspy = old
    return this
  }


  // SCROLLSPY DATA-API
  // ==================

  $(window).on('load.bs.scrollspy.data-api', function () {
    $('[data-spy="scroll"]').each(function () {
      var $spy = $(this)
      Plugin.call($spy, $spy.data())
    })
  })

}(jQuery);

},{}],148:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: tab.js v3.3.4
 * http://getbootstrap.com/javascript/#tabs
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // TAB CLASS DEFINITION
  // ====================

  var Tab = function (element) {
    this.element = $(element)
  }

  Tab.VERSION = '3.3.4'

  Tab.TRANSITION_DURATION = 150

  Tab.prototype.show = function () {
    var $this    = this.element
    var $ul      = $this.closest('ul:not(.dropdown-menu)')
    var selector = $this.data('target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    if ($this.parent('li').hasClass('active')) return

    var $previous = $ul.find('.active:last a')
    var hideEvent = $.Event('hide.bs.tab', {
      relatedTarget: $this[0]
    })
    var showEvent = $.Event('show.bs.tab', {
      relatedTarget: $previous[0]
    })

    $previous.trigger(hideEvent)
    $this.trigger(showEvent)

    if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return

    var $target = $(selector)

    this.activate($this.closest('li'), $ul)
    this.activate($target, $target.parent(), function () {
      $previous.trigger({
        type: 'hidden.bs.tab',
        relatedTarget: $this[0]
      })
      $this.trigger({
        type: 'shown.bs.tab',
        relatedTarget: $previous[0]
      })
    })
  }

  Tab.prototype.activate = function (element, container, callback) {
    var $active    = container.find('> .active')
    var transition = callback
      && $.support.transition
      && (($active.length && $active.hasClass('fade')) || !!container.find('> .fade').length)

    function next() {
      $active
        .removeClass('active')
        .find('> .dropdown-menu > .active')
          .removeClass('active')
        .end()
        .find('[data-toggle="tab"]')
          .attr('aria-expanded', false)

      element
        .addClass('active')
        .find('[data-toggle="tab"]')
          .attr('aria-expanded', true)

      if (transition) {
        element[0].offsetWidth // reflow for transition
        element.addClass('in')
      } else {
        element.removeClass('fade')
      }

      if (element.parent('.dropdown-menu').length) {
        element
          .closest('li.dropdown')
            .addClass('active')
          .end()
          .find('[data-toggle="tab"]')
            .attr('aria-expanded', true)
      }

      callback && callback()
    }

    $active.length && transition ?
      $active
        .one('bsTransitionEnd', next)
        .emulateTransitionEnd(Tab.TRANSITION_DURATION) :
      next()

    $active.removeClass('in')
  }


  // TAB PLUGIN DEFINITION
  // =====================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.tab')

      if (!data) $this.data('bs.tab', (data = new Tab(this)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.tab

  $.fn.tab             = Plugin
  $.fn.tab.Constructor = Tab


  // TAB NO CONFLICT
  // ===============

  $.fn.tab.noConflict = function () {
    $.fn.tab = old
    return this
  }


  // TAB DATA-API
  // ============

  var clickHandler = function (e) {
    e.preventDefault()
    Plugin.call($(this), 'show')
  }

  $(document)
    .on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler)
    .on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler)

}(jQuery);

},{}],149:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: tooltip.js v3.3.4
 * http://getbootstrap.com/javascript/#tooltip
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // TOOLTIP PUBLIC CLASS DEFINITION
  // ===============================

  var Tooltip = function (element, options) {
    this.type       = null
    this.options    = null
    this.enabled    = null
    this.timeout    = null
    this.hoverState = null
    this.$element   = null

    this.init('tooltip', element, options)
  }

  Tooltip.VERSION  = '3.3.4'

  Tooltip.TRANSITION_DURATION = 150

  Tooltip.DEFAULTS = {
    animation: true,
    placement: 'top',
    selector: false,
    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    trigger: 'hover focus',
    title: '',
    delay: 0,
    html: false,
    container: false,
    viewport: {
      selector: 'body',
      padding: 0
    }
  }

  Tooltip.prototype.init = function (type, element, options) {
    this.enabled   = true
    this.type      = type
    this.$element  = $(element)
    this.options   = this.getOptions(options)
    this.$viewport = this.options.viewport && $(this.options.viewport.selector || this.options.viewport)

    if (this.$element[0] instanceof document.constructor && !this.options.selector) {
      throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!')
    }

    var triggers = this.options.trigger.split(' ')

    for (var i = triggers.length; i--;) {
      var trigger = triggers[i]

      if (trigger == 'click') {
        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
      } else if (trigger != 'manual') {
        var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'
        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'

        this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
      }
    }

    this.options.selector ?
      (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
      this.fixTitle()
  }

  Tooltip.prototype.getDefaults = function () {
    return Tooltip.DEFAULTS
  }

  Tooltip.prototype.getOptions = function (options) {
    options = $.extend({}, this.getDefaults(), this.$element.data(), options)

    if (options.delay && typeof options.delay == 'number') {
      options.delay = {
        show: options.delay,
        hide: options.delay
      }
    }

    return options
  }

  Tooltip.prototype.getDelegateOptions = function () {
    var options  = {}
    var defaults = this.getDefaults()

    this._options && $.each(this._options, function (key, value) {
      if (defaults[key] != value) options[key] = value
    })

    return options
  }

  Tooltip.prototype.enter = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)

    if (self && self.$tip && self.$tip.is(':visible')) {
      self.hoverState = 'in'
      return
    }

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }

    clearTimeout(self.timeout)

    self.hoverState = 'in'

    if (!self.options.delay || !self.options.delay.show) return self.show()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'in') self.show()
    }, self.options.delay.show)
  }

  Tooltip.prototype.leave = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }

    clearTimeout(self.timeout)

    self.hoverState = 'out'

    if (!self.options.delay || !self.options.delay.hide) return self.hide()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'out') self.hide()
    }, self.options.delay.hide)
  }

  Tooltip.prototype.show = function () {
    var e = $.Event('show.bs.' + this.type)

    if (this.hasContent() && this.enabled) {
      this.$element.trigger(e)

      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])
      if (e.isDefaultPrevented() || !inDom) return
      var that = this

      var $tip = this.tip()

      var tipId = this.getUID(this.type)

      this.setContent()
      $tip.attr('id', tipId)
      this.$element.attr('aria-describedby', tipId)

      if (this.options.animation) $tip.addClass('fade')

      var placement = typeof this.options.placement == 'function' ?
        this.options.placement.call(this, $tip[0], this.$element[0]) :
        this.options.placement

      var autoToken = /\s?auto?\s?/i
      var autoPlace = autoToken.test(placement)
      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'

      $tip
        .detach()
        .css({ top: 0, left: 0, display: 'block' })
        .addClass(placement)
        .data('bs.' + this.type, this)

      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)

      var pos          = this.getPosition()
      var actualWidth  = $tip[0].offsetWidth
      var actualHeight = $tip[0].offsetHeight

      if (autoPlace) {
        var orgPlacement = placement
        var $container   = this.options.container ? $(this.options.container) : this.$element.parent()
        var containerDim = this.getPosition($container)

        placement = placement == 'bottom' && pos.bottom + actualHeight > containerDim.bottom ? 'top'    :
                    placement == 'top'    && pos.top    - actualHeight < containerDim.top    ? 'bottom' :
                    placement == 'right'  && pos.right  + actualWidth  > containerDim.width  ? 'left'   :
                    placement == 'left'   && pos.left   - actualWidth  < containerDim.left   ? 'right'  :
                    placement

        $tip
          .removeClass(orgPlacement)
          .addClass(placement)
      }

      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)

      this.applyPlacement(calculatedOffset, placement)

      var complete = function () {
        var prevHoverState = that.hoverState
        that.$element.trigger('shown.bs.' + that.type)
        that.hoverState = null

        if (prevHoverState == 'out') that.leave(that)
      }

      $.support.transition && this.$tip.hasClass('fade') ?
        $tip
          .one('bsTransitionEnd', complete)
          .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
        complete()
    }
  }

  Tooltip.prototype.applyPlacement = function (offset, placement) {
    var $tip   = this.tip()
    var width  = $tip[0].offsetWidth
    var height = $tip[0].offsetHeight

    // manually read margins because getBoundingClientRect includes difference
    var marginTop = parseInt($tip.css('margin-top'), 10)
    var marginLeft = parseInt($tip.css('margin-left'), 10)

    // we must check for NaN for ie 8/9
    if (isNaN(marginTop))  marginTop  = 0
    if (isNaN(marginLeft)) marginLeft = 0

    offset.top  = offset.top  + marginTop
    offset.left = offset.left + marginLeft

    // $.fn.offset doesn't round pixel values
    // so we use setOffset directly with our own function B-0
    $.offset.setOffset($tip[0], $.extend({
      using: function (props) {
        $tip.css({
          top: Math.round(props.top),
          left: Math.round(props.left)
        })
      }
    }, offset), 0)

    $tip.addClass('in')

    // check to see if placing tip in new offset caused the tip to resize itself
    var actualWidth  = $tip[0].offsetWidth
    var actualHeight = $tip[0].offsetHeight

    if (placement == 'top' && actualHeight != height) {
      offset.top = offset.top + height - actualHeight
    }

    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)

    if (delta.left) offset.left += delta.left
    else offset.top += delta.top

    var isVertical          = /top|bottom/.test(placement)
    var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight
    var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'

    $tip.offset(offset)
    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)
  }

  Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {
    this.arrow()
      .css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')
      .css(isVertical ? 'top' : 'left', '')
  }

  Tooltip.prototype.setContent = function () {
    var $tip  = this.tip()
    var title = this.getTitle()

    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
    $tip.removeClass('fade in top bottom left right')
  }

  Tooltip.prototype.hide = function (callback) {
    var that = this
    var $tip = $(this.$tip)
    var e    = $.Event('hide.bs.' + this.type)

    function complete() {
      if (that.hoverState != 'in') $tip.detach()
      that.$element
        .removeAttr('aria-describedby')
        .trigger('hidden.bs.' + that.type)
      callback && callback()
    }

    this.$element.trigger(e)

    if (e.isDefaultPrevented()) return

    $tip.removeClass('in')

    $.support.transition && $tip.hasClass('fade') ?
      $tip
        .one('bsTransitionEnd', complete)
        .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
      complete()

    this.hoverState = null

    return this
  }

  Tooltip.prototype.fixTitle = function () {
    var $e = this.$element
    if ($e.attr('title') || typeof ($e.attr('data-original-title')) != 'string') {
      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
    }
  }

  Tooltip.prototype.hasContent = function () {
    return this.getTitle()
  }

  Tooltip.prototype.getPosition = function ($element) {
    $element   = $element || this.$element

    var el     = $element[0]
    var isBody = el.tagName == 'BODY'

    var elRect    = el.getBoundingClientRect()
    if (elRect.width == null) {
      // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
      elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top })
    }
    var elOffset  = isBody ? { top: 0, left: 0 } : $element.offset()
    var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }
    var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null

    return $.extend({}, elRect, scroll, outerDims, elOffset)
  }

  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
    return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2 } :
           placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 } :
           placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
        /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width }

  }

  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
    var delta = { top: 0, left: 0 }
    if (!this.$viewport) return delta

    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0
    var viewportDimensions = this.getPosition(this.$viewport)

    if (/right|left/.test(placement)) {
      var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll
      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight
      if (topEdgeOffset < viewportDimensions.top) { // top overflow
        delta.top = viewportDimensions.top - topEdgeOffset
      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow
        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset
      }
    } else {
      var leftEdgeOffset  = pos.left - viewportPadding
      var rightEdgeOffset = pos.left + viewportPadding + actualWidth
      if (leftEdgeOffset < viewportDimensions.left) { // left overflow
        delta.left = viewportDimensions.left - leftEdgeOffset
      } else if (rightEdgeOffset > viewportDimensions.width) { // right overflow
        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset
      }
    }

    return delta
  }

  Tooltip.prototype.getTitle = function () {
    var title
    var $e = this.$element
    var o  = this.options

    title = $e.attr('data-original-title')
      || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

    return title
  }

  Tooltip.prototype.getUID = function (prefix) {
    do prefix += ~~(Math.random() * 1000000)
    while (document.getElementById(prefix))
    return prefix
  }

  Tooltip.prototype.tip = function () {
    return (this.$tip = this.$tip || $(this.options.template))
  }

  Tooltip.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))
  }

  Tooltip.prototype.enable = function () {
    this.enabled = true
  }

  Tooltip.prototype.disable = function () {
    this.enabled = false
  }

  Tooltip.prototype.toggleEnabled = function () {
    this.enabled = !this.enabled
  }

  Tooltip.prototype.toggle = function (e) {
    var self = this
    if (e) {
      self = $(e.currentTarget).data('bs.' + this.type)
      if (!self) {
        self = new this.constructor(e.currentTarget, this.getDelegateOptions())
        $(e.currentTarget).data('bs.' + this.type, self)
      }
    }

    self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
  }

  Tooltip.prototype.destroy = function () {
    var that = this
    clearTimeout(this.timeout)
    this.hide(function () {
      that.$element.off('.' + that.type).removeData('bs.' + that.type)
    })
  }


  // TOOLTIP PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.tooltip')
      var options = typeof option == 'object' && option

      if (!data && /destroy|hide/.test(option)) return
      if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.tooltip

  $.fn.tooltip             = Plugin
  $.fn.tooltip.Constructor = Tooltip


  // TOOLTIP NO CONFLICT
  // ===================

  $.fn.tooltip.noConflict = function () {
    $.fn.tooltip = old
    return this
  }

}(jQuery);

},{}],150:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: transition.js v3.3.4
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
  // ============================================================

  function transitionEnd() {
    var el = document.createElement('bootstrap')

    var transEndEventNames = {
      WebkitTransition : 'webkitTransitionEnd',
      MozTransition    : 'transitionend',
      OTransition      : 'oTransitionEnd otransitionend',
      transition       : 'transitionend'
    }

    for (var name in transEndEventNames) {
      if (el.style[name] !== undefined) {
        return { end: transEndEventNames[name] }
      }
    }

    return false // explicit for ie8 (  ._.)
  }

  // http://blog.alexmaccaw.com/css-transitions
  $.fn.emulateTransitionEnd = function (duration) {
    var called = false
    var $el = this
    $(this).one('bsTransitionEnd', function () { called = true })
    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
    setTimeout(callback, duration)
    return this
  }

  $(function () {
    $.support.transition = transitionEnd()

    if (!$.support.transition) return

    $.event.special.bsTransitionEnd = {
      bindType: $.support.transition.end,
      delegateType: $.support.transition.end,
      handle: function (e) {
        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
      }
    }
  })

}(jQuery);

},{}],151:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;

function drainQueue() {
    if (draining) {
        return;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        var i = -1;
        while (++i < len) {
            currentQueue[i]();
        }
        len = queue.length;
    }
    draining = false;
}
process.nextTick = function (fun) {
    queue.push(fun);
    if (!draining) {
        setTimeout(drainQueue, 0);
    }
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],152:[function(require,module,exports){
// i18next, v1.8.1
// Copyright (c)2015 Jan Mühlemann (jamuhl).
// Distributed under MIT license
// http://i18next.com
(function(root) {

    // add indexOf to non ECMA-262 standard compliant browsers
    if (!Array.prototype.indexOf) {
        Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {
            "use strict";
            if (this == null) {
                throw new TypeError();
            }
            var t = Object(this);
            var len = t.length >>> 0;
            if (len === 0) {
                return -1;
            }
            var n = 0;
            if (arguments.length > 0) {
                n = Number(arguments[1]);
                if (n != n) { // shortcut for verifying if it's NaN
                    n = 0;
                } else if (n != 0 && n != Infinity && n != -Infinity) {
                    n = (n > 0 || -1) * Math.floor(Math.abs(n));
                }
            }
            if (n >= len) {
                return -1;
            }
            var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
            for (; k < len; k++) {
                if (k in t && t[k] === searchElement) {
                    return k;
                }
            }
            return -1;
        }
    }

    // add lastIndexOf to non ECMA-262 standard compliant browsers
    if (!Array.prototype.lastIndexOf) {
        Array.prototype.lastIndexOf = function(searchElement /*, fromIndex*/) {
            "use strict";
            if (this == null) {
                throw new TypeError();
            }
            var t = Object(this);
            var len = t.length >>> 0;
            if (len === 0) {
                return -1;
            }
            var n = len;
            if (arguments.length > 1) {
                n = Number(arguments[1]);
                if (n != n) {
                    n = 0;
                } else if (n != 0 && n != (1 / 0) && n != -(1 / 0)) {
                    n = (n > 0 || -1) * Math.floor(Math.abs(n));
                }
            }
            var k = n >= 0 ? Math.min(n, len - 1) : len - Math.abs(n);
            for (; k >= 0; k--) {
                if (k in t && t[k] === searchElement) {
                    return k;
                }
            }
            return -1;
        };
    }

    // Add string trim for IE8.
    if (typeof String.prototype.trim !== 'function') {
        String.prototype.trim = function() {
            return this.replace(/^\s+|\s+$/g, '');
        }
    }

    var $ = root.jQuery || root.Zepto
      , i18n = {}
      , resStore = {}
      , currentLng
      , replacementCounter = 0
      , languages = []
      , initialized = false
      , sync = {};



    // Export the i18next object for **CommonJS**.
    // If we're not in CommonJS, add `i18n` to the
    // global object or to jquery.
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = i18n;
        if (!$) {
            try {
                $ = require('jquery');
            } catch(e) {
                // just ignore
            }
        }

    } else {
        root.i18n = root.i18n || i18n;
    }

    if ($) {
        $.i18n = $.i18n || i18n;
    }
    sync = {

        load: function(lngs, options, cb) {
            if (options.useLocalStorage) {
                sync._loadLocal(lngs, options, function(err, store) {
                    var missingLngs = [];
                    for (var i = 0, len = lngs.length; i < len; i++) {
                        if (!store[lngs[i]]) missingLngs.push(lngs[i]);
                    }

                    if (missingLngs.length > 0) {
                        sync._fetch(missingLngs, options, function(err, fetched) {
                            f.extend(store, fetched);
                            sync._storeLocal(fetched);

                            cb(null, store);
                        });
                    } else {
                        cb(null, store);
                    }
                });
            } else {
                sync._fetch(lngs, options, function(err, store){
                    cb(null, store);
                });
            }
        },

        _loadLocal: function(lngs, options, cb) {
            var store = {}
              , nowMS = new Date().getTime();

            if(window.localStorage) {

                var todo = lngs.length;

                f.each(lngs, function(key, lng) {
                    var local = f.localStorage.getItem('res_' + lng);

                    if (local) {
                        local = JSON.parse(local);

                        if (local.i18nStamp && local.i18nStamp + options.localStorageExpirationTime > nowMS) {
                            store[lng] = local;
                        }
                    }

                    todo--; // wait for all done befor callback
                    if (todo === 0) cb(null, store);
                });
            }
        },

        _storeLocal: function(store) {
            if(window.localStorage) {
                for (var m in store) {
                    store[m].i18nStamp = new Date().getTime();
                    f.localStorage.setItem('res_' + m, JSON.stringify(store[m]));
                }
            }
            return;
        },

        _fetch: function(lngs, options, cb) {
            var ns = options.ns
              , store = {};

            if (!options.dynamicLoad) {
                var todo = ns.namespaces.length * lngs.length
                  , errors;

                // load each file individual
                f.each(ns.namespaces, function(nsIndex, nsValue) {
                    f.each(lngs, function(lngIndex, lngValue) {

                        // Call this once our translation has returned.
                        var loadComplete = function(err, data) {
                            if (err) {
                                errors = errors || [];
                                errors.push(err);
                            }
                            store[lngValue] = store[lngValue] || {};
                            store[lngValue][nsValue] = data;

                            todo--; // wait for all done befor callback
                            if (todo === 0) cb(errors, store);
                        };

                        if(typeof options.customLoad == 'function'){
                            // Use the specified custom callback.
                            options.customLoad(lngValue, nsValue, options, loadComplete);
                        } else {
                            //~ // Use our inbuilt sync.
                            sync._fetchOne(lngValue, nsValue, options, loadComplete);
                        }
                    });
                });
            } else {
                // Call this once our translation has returned.
                var loadComplete = function(err, data) {
                    cb(null, data);
                };

                if(typeof options.customLoad == 'function'){
                    // Use the specified custom callback.
                    options.customLoad(lngs, ns.namespaces, options, loadComplete);
                } else {
                    var url = applyReplacement(options.resGetPath, { lng: lngs.join('+'), ns: ns.namespaces.join('+') });
                    // load all needed stuff once
                    f.ajax({
                        url: url,
                        success: function(data, status, xhr) {
                            f.log('loaded: ' + url);
                            loadComplete(null, data);
                        },
                        error : function(xhr, status, error) {
                            f.log('failed loading: ' + url);
                            loadComplete('failed loading resource.json error: ' + error);
                        },
                        dataType: "json",
                        async : options.getAsync
                    });
                }
            }
        },

        _fetchOne: function(lng, ns, options, done) {
            var url = applyReplacement(options.resGetPath, { lng: lng, ns: ns });
            f.ajax({
                url: url,
                success: function(data, status, xhr) {
                    f.log('loaded: ' + url);
                    done(null, data);
                },
                error : function(xhr, status, error) {
                    if ((status && status == 200) || (xhr && xhr.status && xhr.status == 200)) {
                        // file loaded but invalid json, stop waste time !
                        f.error('There is a typo in: ' + url);
                    } else if ((status && status == 404) || (xhr && xhr.status && xhr.status == 404)) {
                        f.log('Does not exist: ' + url);
                    } else {
                        var theStatus = status ? status : ((xhr && xhr.status) ? xhr.status : null);
                        f.log(theStatus + ' when loading ' + url);
                    }

                    done(error, {});
                },
                dataType: "json",
                async : options.getAsync
            });
        },

        postMissing: function(lng, ns, key, defaultValue, lngs) {
            var payload = {};
            payload[key] = defaultValue;

            var urls = [];

            if (o.sendMissingTo === 'fallback' && o.fallbackLng[0] !== false) {
                for (var i = 0; i < o.fallbackLng.length; i++) {
                    urls.push({lng: o.fallbackLng[i], url: applyReplacement(o.resPostPath, { lng: o.fallbackLng[i], ns: ns })});
                }
            } else if (o.sendMissingTo === 'current' || (o.sendMissingTo === 'fallback' && o.fallbackLng[0] === false) ) {
                urls.push({lng: lng, url: applyReplacement(o.resPostPath, { lng: lng, ns: ns })});
            } else if (o.sendMissingTo === 'all') {
                for (var i = 0, l = lngs.length; i < l; i++) {
                    urls.push({lng: lngs[i], url: applyReplacement(o.resPostPath, { lng: lngs[i], ns: ns })});
                }
            }

            for (var y = 0, len = urls.length; y < len; y++) {
                var item = urls[y];
                f.ajax({
                    url: item.url,
                    type: o.sendType,
                    data: payload,
                    success: function(data, status, xhr) {
                        f.log('posted missing key \'' + key + '\' to: ' + item.url);

                        // add key to resStore
                        var keys = key.split('.');
                        var x = 0;
                        var value = resStore[item.lng][ns];
                        while (keys[x]) {
                            if (x === keys.length - 1) {
                                value = value[keys[x]] = defaultValue;
                            } else {
                                value = value[keys[x]] = value[keys[x]] || {};
                            }
                            x++;
                        }
                    },
                    error : function(xhr, status, error) {
                        f.log('failed posting missing key \'' + key + '\' to: ' + item.url);
                    },
                    dataType: "json",
                    async : o.postAsync
                });
            }
        },

        reload: reload
    };
    // defaults
    var o = {
        lng: undefined,
        load: 'all',
        preload: [],
        lowerCaseLng: false,
        returnObjectTrees: false,
        fallbackLng: ['dev'],
        fallbackNS: [],
        detectLngQS: 'setLng',
        detectLngFromLocalStorage: false,
        ns: 'translation',
        fallbackOnNull: true,
        fallbackOnEmpty: false,
        fallbackToDefaultNS: false,
        nsseparator: ':',
        keyseparator: '.',
        selectorAttr: 'data-i18n',
        debug: false,

        resGetPath: 'locales/__lng__/__ns__.json',
        resPostPath: 'locales/add/__lng__/__ns__',

        getAsync: true,
        postAsync: true,

        resStore: undefined,
        useLocalStorage: false,
        localStorageExpirationTime: 7*24*60*60*1000,

        dynamicLoad: false,
        sendMissing: false,
        sendMissingTo: 'fallback', // current | all
        sendType: 'POST',

        interpolationPrefix: '__',
        interpolationSuffix: '__',
        defaultVariables: false,
        reusePrefix: '$t(',
        reuseSuffix: ')',
        pluralSuffix: '_plural',
        pluralNotFound: ['plural_not_found', Math.random()].join(''),
        contextNotFound: ['context_not_found', Math.random()].join(''),
        escapeInterpolation: false,
        indefiniteSuffix: '_indefinite',
        indefiniteNotFound: ['indefinite_not_found', Math.random()].join(''),

        setJqueryExt: true,
        defaultValueFromContent: true,
        useDataAttrOptions: false,
        cookieExpirationTime: undefined,
        useCookie: true,
        cookieName: 'i18next',
        cookieDomain: undefined,

        objectTreeKeyHandler: undefined,
        postProcess: undefined,
        parseMissingKey: undefined,
        missingKeyHandler: sync.postMissing,

        shortcutFunction: 'sprintf' // or: defaultValue
    };
    function _extend(target, source) {
        if (!source || typeof source === 'function') {
            return target;
        }

        for (var attr in source) { target[attr] = source[attr]; }
        return target;
    }

    function _deepExtend(target, source) {
        for (var prop in source)
            if (prop in target)
                _deepExtend(target[prop], source[prop]);
            else
                target[prop] = source[prop];
        return target;
    }

    function _each(object, callback, args) {
        var name, i = 0,
            length = object.length,
            isObj = length === undefined || Object.prototype.toString.apply(object) !== '[object Array]' || typeof object === "function";

        if (args) {
            if (isObj) {
                for (name in object) {
                    if (callback.apply(object[name], args) === false) {
                        break;
                    }
                }
            } else {
                for ( ; i < length; ) {
                    if (callback.apply(object[i++], args) === false) {
                        break;
                    }
                }
            }

        // A special, fast, case for the most common use of each
        } else {
            if (isObj) {
                for (name in object) {
                    if (callback.call(object[name], name, object[name]) === false) {
                        break;
                    }
                }
            } else {
                for ( ; i < length; ) {
                    if (callback.call(object[i], i, object[i++]) === false) {
                        break;
                    }
                }
            }
        }

        return object;
    }

    var _entityMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': '&quot;',
        "'": '&#39;',
        "/": '&#x2F;'
    };

    function _escape(data) {
        if (typeof data === 'string') {
            return data.replace(/[&<>"'\/]/g, function (s) {
                return _entityMap[s];
            });
        }else{
            return data;
        }
    }

    function _ajax(options) {

        // v0.5.0 of https://github.com/goloroden/http.js
        var getXhr = function (callback) {
            // Use the native XHR object if the browser supports it.
            if (window.XMLHttpRequest) {
                return callback(null, new XMLHttpRequest());
            } else if (window.ActiveXObject) {
                // In Internet Explorer check for ActiveX versions of the XHR object.
                try {
                    return callback(null, new ActiveXObject("Msxml2.XMLHTTP"));
                } catch (e) {
                    return callback(null, new ActiveXObject("Microsoft.XMLHTTP"));
                }
            }

            // If no XHR support was found, throw an error.
            return callback(new Error());
        };

        var encodeUsingUrlEncoding = function (data) {
            if(typeof data === 'string') {
                return data;
            }

            var result = [];
            for(var dataItem in data) {
                if(data.hasOwnProperty(dataItem)) {
                    result.push(encodeURIComponent(dataItem) + '=' + encodeURIComponent(data[dataItem]));
                }
            }

            return result.join('&');
        };

        var utf8 = function (text) {
            text = text.replace(/\r\n/g, '\n');
            var result = '';

            for(var i = 0; i < text.length; i++) {
                var c = text.charCodeAt(i);

                if(c < 128) {
                        result += String.fromCharCode(c);
                } else if((c > 127) && (c < 2048)) {
                        result += String.fromCharCode((c >> 6) | 192);
                        result += String.fromCharCode((c & 63) | 128);
                } else {
                        result += String.fromCharCode((c >> 12) | 224);
                        result += String.fromCharCode(((c >> 6) & 63) | 128);
                        result += String.fromCharCode((c & 63) | 128);
                }
            }

            return result;
        };

        var base64 = function (text) {
            var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

            text = utf8(text);
            var result = '',
                    chr1, chr2, chr3,
                    enc1, enc2, enc3, enc4,
                    i = 0;

            do {
                chr1 = text.charCodeAt(i++);
                chr2 = text.charCodeAt(i++);
                chr3 = text.charCodeAt(i++);

                enc1 = chr1 >> 2;
                enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                enc4 = chr3 & 63;

                if(isNaN(chr2)) {
                    enc3 = enc4 = 64;
                } else if(isNaN(chr3)) {
                    enc4 = 64;
                }

                result +=
                    keyStr.charAt(enc1) +
                    keyStr.charAt(enc2) +
                    keyStr.charAt(enc3) +
                    keyStr.charAt(enc4);
                chr1 = chr2 = chr3 = '';
                enc1 = enc2 = enc3 = enc4 = '';
            } while(i < text.length);

            return result;
        };

        var mergeHeaders = function () {
            // Use the first header object as base.
            var result = arguments[0];

            // Iterate through the remaining header objects and add them.
            for(var i = 1; i < arguments.length; i++) {
                var currentHeaders = arguments[i];
                for(var header in currentHeaders) {
                    if(currentHeaders.hasOwnProperty(header)) {
                        result[header] = currentHeaders[header];
                    }
                }
            }

            // Return the merged headers.
            return result;
        };

        var ajax = function (method, url, options, callback) {
            // Adjust parameters.
            if(typeof options === 'function') {
                callback = options;
                options = {};
            }

            // Set default parameter values.
            options.cache = options.cache || false;
            options.data = options.data || {};
            options.headers = options.headers || {};
            options.jsonp = options.jsonp || false;
            options.async = options.async === undefined ? true : options.async;

            // Merge the various header objects.
            var headers = mergeHeaders({
                'accept': '*/*',
                'content-type': 'application/x-www-form-urlencoded;charset=UTF-8'
            }, ajax.headers, options.headers);

            // Encode the data according to the content-type.
            var payload;
            if (headers['content-type'] === 'application/json') {
                payload = JSON.stringify(options.data);
            } else {
                payload = encodeUsingUrlEncoding(options.data);
            }

            // Specially prepare GET requests: Setup the query string, handle caching and make a JSONP call
            // if neccessary.
            if(method === 'GET') {
                // Setup the query string.
                var queryString = [];
                if(payload) {
                    queryString.push(payload);
                    payload = null;
                }

                // Handle caching.
                if(!options.cache) {
                    queryString.push('_=' + (new Date()).getTime());
                }

                // If neccessary prepare the query string for a JSONP call.
                if(options.jsonp) {
                    queryString.push('callback=' + options.jsonp);
                    queryString.push('jsonp=' + options.jsonp);
                }

                // Merge the query string and attach it to the url.
                queryString = queryString.join('&');
                if (queryString.length > 1) {
                    if (url.indexOf('?') > -1) {
                        url += '&' + queryString;
                    } else {
                        url += '?' + queryString;
                    }
                }

                // Make a JSONP call if neccessary.
                if(options.jsonp) {
                    var head = document.getElementsByTagName('head')[0];
                    var script = document.createElement('script');
                    script.type = 'text/javascript';
                    script.src = url;
                    head.appendChild(script);
                    return;
                }
            }

            // Since we got here, it is no JSONP request, so make a normal XHR request.
            getXhr(function (err, xhr) {
                if(err) return callback(err);

                // Open the request.
                xhr.open(method, url, options.async);

                // Set the request headers.
                for(var header in headers) {
                    if(headers.hasOwnProperty(header)) {
                        xhr.setRequestHeader(header, headers[header]);
                    }
                }

                // Handle the request events.
                xhr.onreadystatechange = function () {
                    if(xhr.readyState === 4) {
                        var data = xhr.responseText || '';

                        // If no callback is given, return.
                        if(!callback) {
                            return;
                        }

                        // Return an object that provides access to the data as text and JSON.
                        callback(xhr.status, {
                            text: function () {
                                return data;
                            },

                            json: function () {
                                try {
                                    return JSON.parse(data)
                                } catch (e) {
                                    f.error('Can not parse JSON. URL: ' + url);
                                    return {};
                                }
                            }
                        });
                    }
                };

                // Actually send the XHR request.
                xhr.send(payload);
            });
        };

        // Define the external interface.
        var http = {
            authBasic: function (username, password) {
                ajax.headers['Authorization'] = 'Basic ' + base64(username + ':' + password);
            },

            connect: function (url, options, callback) {
                return ajax('CONNECT', url, options, callback);
            },

            del: function (url, options, callback) {
                return ajax('DELETE', url, options, callback);
            },

            get: function (url, options, callback) {
                return ajax('GET', url, options, callback);
            },

            head: function (url, options, callback) {
                return ajax('HEAD', url, options, callback);
            },

            headers: function (headers) {
                ajax.headers = headers || {};
            },

            isAllowed: function (url, verb, callback) {
                this.options(url, function (status, data) {
                    callback(data.text().indexOf(verb) !== -1);
                });
            },

            options: function (url, options, callback) {
                return ajax('OPTIONS', url, options, callback);
            },

            patch: function (url, options, callback) {
                return ajax('PATCH', url, options, callback);
            },

            post: function (url, options, callback) {
                return ajax('POST', url, options, callback);
            },

            put: function (url, options, callback) {
                return ajax('PUT', url, options, callback);
            },

            trace: function (url, options, callback) {
                return ajax('TRACE', url, options, callback);
            }
        };


        var methode = options.type ? options.type.toLowerCase() : 'get';

        http[methode](options.url, options, function (status, data) {
            // file: protocol always gives status code 0, so check for data
            if (status === 200 || (status === 0 && data.text())) {
                options.success(data.json(), status, null);
            } else {
                options.error(data.text(), status, null);
            }
        });
    }

    var _cookie = {
        create: function(name,value,minutes,domain) {
            var expires;
            if (minutes) {
                var date = new Date();
                date.setTime(date.getTime()+(minutes*60*1000));
                expires = "; expires="+date.toGMTString();
            }
            else expires = "";
            domain = (domain)? "domain="+domain+";" : "";
            document.cookie = name+"="+value+expires+";"+domain+"path=/";
        },

        read: function(name) {
            var nameEQ = name + "=";
            var ca = document.cookie.split(';');
            for(var i=0;i < ca.length;i++) {
                var c = ca[i];
                while (c.charAt(0)==' ') c = c.substring(1,c.length);
                if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length,c.length);
            }
            return null;
        },

        remove: function(name) {
            this.create(name,"",-1);
        }
    };

    var cookie_noop = {
        create: function(name,value,minutes,domain) {},
        read: function(name) { return null; },
        remove: function(name) {}
    };



    // move dependent functions to a container so that
    // they can be overriden easier in no jquery environment (node.js)
    var f = {
        extend: $ ? $.extend : _extend,
        deepExtend: _deepExtend,
        each: $ ? $.each : _each,
        ajax: $ ? $.ajax : (typeof document !== 'undefined' ? _ajax : function() {}),
        cookie: typeof document !== 'undefined' ? _cookie : cookie_noop,
        detectLanguage: detectLanguage,
        escape: _escape,
        log: function(str) {
            if (o.debug && typeof console !== "undefined") console.log(str);
        },
        error: function(str) {
            if (typeof console !== "undefined") console.error(str);
        },
        getCountyIndexOfLng: function(lng) {
            var lng_index = 0;
            if (lng === 'nb-NO' || lng === 'nn-NO' || lng === 'nb-no' || lng === 'nn-no') lng_index = 1;
            return lng_index;
        },
        toLanguages: function(lng) {
            var log = this.log;

            function applyCase(l) {
                var ret = l;

                if (typeof l === 'string' && l.indexOf('-') > -1) {
                    var parts = l.split('-');

                    ret = o.lowerCaseLng ?
                        parts[0].toLowerCase() +  '-' + parts[1].toLowerCase() :
                        parts[0].toLowerCase() +  '-' + parts[1].toUpperCase();
                } else {
                    ret = o.lowerCaseLng ? l.toLowerCase() : l;
                }

                return ret;
            }

            var languages = [];
            var whitelist = o.lngWhitelist || false;
            var addLanguage = function(language){
              //reject langs not whitelisted
              if(!whitelist || whitelist.indexOf(language) > -1){
                languages.push(language);
              }else{
                log('rejecting non-whitelisted language: ' + language);
              }
            };
            if (typeof lng === 'string' && lng.indexOf('-') > -1) {
                var parts = lng.split('-');

                if (o.load !== 'unspecific') addLanguage(applyCase(lng));
                if (o.load !== 'current') addLanguage(applyCase(parts[this.getCountyIndexOfLng(lng)]));
            } else {
                addLanguage(applyCase(lng));
            }

            for (var i = 0; i < o.fallbackLng.length; i++) {
                if (languages.indexOf(o.fallbackLng[i]) === -1 && o.fallbackLng[i]) languages.push(applyCase(o.fallbackLng[i]));
            }
            return languages;
        },
        regexEscape: function(str) {
            return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
        },
        regexReplacementEscape: function(strOrFn) {
            if (typeof strOrFn === 'string') {
                return strOrFn.replace(/\$/g, "$$$$");
            } else {
                return strOrFn;
            }
        },
        localStorage: {
            setItem: function(key, value) {
                if (window.localStorage) {
                    try {
                        window.localStorage.setItem(key, value);
                    } catch (e) {
                        f.log('failed to set value for key "' + key + '" to localStorage.');
                    }
                }
            },
            getItem: function(key, value) {
                if (window.localStorage) {
                    try {
                        return window.localStorage.getItem(key, value);
                    } catch (e) {
                        f.log('failed to get value for key "' + key + '" from localStorage.');
                        return undefined;
                    }
                }
            }
        }
    };
    function init(options, cb) {

        if (typeof options === 'function') {
            cb = options;
            options = {};
        }
        options = options || {};

        // override defaults with passed in options
        f.extend(o, options);
        delete o.fixLng; /* passed in each time */

        // override functions: .log(), .detectLanguage(), etc
        if (o.functions) {
            delete o.functions;
            f.extend(f, options.functions);
        }

        // create namespace object if namespace is passed in as string
        if (typeof o.ns == 'string') {
            o.ns = { namespaces: [o.ns], defaultNs: o.ns};
        }

        // fallback namespaces
        if (typeof o.fallbackNS == 'string') {
            o.fallbackNS = [o.fallbackNS];
        }

        // fallback languages
        if (typeof o.fallbackLng == 'string' || typeof o.fallbackLng == 'boolean') {
            o.fallbackLng = [o.fallbackLng];
        }

        // escape prefix/suffix
        o.interpolationPrefixEscaped = f.regexEscape(o.interpolationPrefix);
        o.interpolationSuffixEscaped = f.regexEscape(o.interpolationSuffix);

        if (!o.lng) o.lng = f.detectLanguage();

        languages = f.toLanguages(o.lng);
        currentLng = languages[0];
        f.log('currentLng set to: ' + currentLng);

        if (o.useCookie && f.cookie.read(o.cookieName) !== currentLng){ //cookie is unset or invalid
            f.cookie.create(o.cookieName, currentLng, o.cookieExpirationTime, o.cookieDomain);
        }
        if (o.detectLngFromLocalStorage && typeof document !== 'undefined' && window.localStorage) {
            f.localStorage.setItem('i18next_lng', currentLng);
        }

        var lngTranslate = translate;
        if (options.fixLng) {
            lngTranslate = function(key, options) {
                options = options || {};
                options.lng = options.lng || lngTranslate.lng;
                return translate(key, options);
            };
            lngTranslate.lng = currentLng;
        }

        pluralExtensions.setCurrentLng(currentLng);

        // add JQuery extensions
        if ($ && o.setJqueryExt) addJqueryFunct();

        // jQuery deferred
        var deferred;
        if ($ && $.Deferred) {
            deferred = $.Deferred();
        }

        // return immidiatly if res are passed in
        if (o.resStore) {
            resStore = o.resStore;
            initialized = true;
            if (cb) cb(lngTranslate);
            if (deferred) deferred.resolve(lngTranslate);
            if (deferred) return deferred.promise();
            return;
        }

        // languages to load
        var lngsToLoad = f.toLanguages(o.lng);
        if (typeof o.preload === 'string') o.preload = [o.preload];
        for (var i = 0, l = o.preload.length; i < l; i++) {
            var pres = f.toLanguages(o.preload[i]);
            for (var y = 0, len = pres.length; y < len; y++) {
                if (lngsToLoad.indexOf(pres[y]) < 0) {
                    lngsToLoad.push(pres[y]);
                }
            }
        }

        // else load them
        i18n.sync.load(lngsToLoad, o, function(err, store) {
            resStore = store;
            initialized = true;

            if (cb) cb(lngTranslate);
            if (deferred) deferred.resolve(lngTranslate);
        });

        if (deferred) return deferred.promise();
    }
    function preload(lngs, cb) {
        if (typeof lngs === 'string') lngs = [lngs];
        for (var i = 0, l = lngs.length; i < l; i++) {
            if (o.preload.indexOf(lngs[i]) < 0) {
                o.preload.push(lngs[i]);
            }
        }
        return init(cb);
    }

    function addResourceBundle(lng, ns, resources, deep) {
        if (typeof ns !== 'string') {
            resources = ns;
            ns = o.ns.defaultNs;
        } else if (o.ns.namespaces.indexOf(ns) < 0) {
            o.ns.namespaces.push(ns);
        }

        resStore[lng] = resStore[lng] || {};
        resStore[lng][ns] = resStore[lng][ns] || {};

        if (deep) {
            f.deepExtend(resStore[lng][ns], resources);
        } else {
            f.extend(resStore[lng][ns], resources);
        }
        if (o.useLocalStorage) {
            sync._storeLocal(resStore);
        }
    }

    function hasResourceBundle(lng, ns) {
        if (typeof ns !== 'string') {
            ns = o.ns.defaultNs;
        }

        resStore[lng] = resStore[lng] || {};
        var res = resStore[lng][ns] || {};

        var hasValues = false;
        for(var prop in res) {
            if (res.hasOwnProperty(prop)) {
                hasValues = true;
            }
        }

        return hasValues;
    }

    function getResourceBundle(lng, ns) {
        if (typeof ns !== 'string') {
            ns = o.ns.defaultNs;
        }

        resStore[lng] = resStore[lng] || {};
        return f.extend({}, resStore[lng][ns]);
    }

    function removeResourceBundle(lng, ns) {
        if (typeof ns !== 'string') {
            ns = o.ns.defaultNs;
        }

        resStore[lng] = resStore[lng] || {};
        resStore[lng][ns] = {};
        if (o.useLocalStorage) {
            sync._storeLocal(resStore);
        }
    }

    function addResource(lng, ns, key, value) {
        if (typeof ns !== 'string') {
            resource = ns;
            ns = o.ns.defaultNs;
        } else if (o.ns.namespaces.indexOf(ns) < 0) {
            o.ns.namespaces.push(ns);
        }

        resStore[lng] = resStore[lng] || {};
        resStore[lng][ns] = resStore[lng][ns] || {};

        var keys = key.split(o.keyseparator);
        var x = 0;
        var node = resStore[lng][ns];
        var origRef = node;

        while (keys[x]) {
            if (x == keys.length - 1)
                node[keys[x]] = value;
            else {
                if (node[keys[x]] == null)
                    node[keys[x]] = {};

                node = node[keys[x]];
            }
            x++;
        }
        if (o.useLocalStorage) {
            sync._storeLocal(resStore);
        }
    }

    function addResources(lng, ns, resources) {
        if (typeof ns !== 'string') {
            resource = ns;
            ns = o.ns.defaultNs;
        } else if (o.ns.namespaces.indexOf(ns) < 0) {
            o.ns.namespaces.push(ns);
        }

        for (var m in resources) {
            if (typeof resources[m] === 'string') addResource(lng, ns, m, resources[m]);
        }
    }

    function setDefaultNamespace(ns) {
        o.ns.defaultNs = ns;
    }

    function loadNamespace(namespace, cb) {
        loadNamespaces([namespace], cb);
    }

    function loadNamespaces(namespaces, cb) {
        var opts = {
            dynamicLoad: o.dynamicLoad,
            resGetPath: o.resGetPath,
            getAsync: o.getAsync,
            customLoad: o.customLoad,
            ns: { namespaces: namespaces, defaultNs: ''} /* new namespaces to load */
        };

        // languages to load
        var lngsToLoad = f.toLanguages(o.lng);
        if (typeof o.preload === 'string') o.preload = [o.preload];
        for (var i = 0, l = o.preload.length; i < l; i++) {
            var pres = f.toLanguages(o.preload[i]);
            for (var y = 0, len = pres.length; y < len; y++) {
                if (lngsToLoad.indexOf(pres[y]) < 0) {
                    lngsToLoad.push(pres[y]);
                }
            }
        }

        // check if we have to load
        var lngNeedLoad = [];
        for (var a = 0, lenA = lngsToLoad.length; a < lenA; a++) {
            var needLoad = false;
            var resSet = resStore[lngsToLoad[a]];
            if (resSet) {
                for (var b = 0, lenB = namespaces.length; b < lenB; b++) {
                    if (!resSet[namespaces[b]]) needLoad = true;
                }
            } else {
                needLoad = true;
            }

            if (needLoad) lngNeedLoad.push(lngsToLoad[a]);
        }

        if (lngNeedLoad.length) {
            i18n.sync._fetch(lngNeedLoad, opts, function(err, store) {
                var todo = namespaces.length * lngNeedLoad.length;

                // load each file individual
                f.each(namespaces, function(nsIndex, nsValue) {

                    // append namespace to namespace array
                    if (o.ns.namespaces.indexOf(nsValue) < 0) {
                        o.ns.namespaces.push(nsValue);
                    }

                    f.each(lngNeedLoad, function(lngIndex, lngValue) {
                        resStore[lngValue] = resStore[lngValue] || {};
                        resStore[lngValue][nsValue] = store[lngValue][nsValue];

                        todo--; // wait for all done befor callback
                        if (todo === 0 && cb) {
                            if (o.useLocalStorage) i18n.sync._storeLocal(resStore);
                            cb();
                        }
                    });
                });
            });
        } else {
            if (cb) cb();
        }
    }

    function setLng(lng, options, cb) {
        if (typeof options === 'function') {
            cb = options;
            options = {};
        } else if (!options) {
            options = {};
        }

        options.lng = lng;
        return init(options, cb);
    }

    function lng() {
        return currentLng;
    }

    function reload(cb) {
        resStore = {};
        setLng(currentLng, cb);
    }
    function addJqueryFunct() {
        // $.t shortcut
        $.t = $.t || translate;

        function parse(ele, key, options) {
            if (key.length === 0) return;

            var attr = 'text';

            if (key.indexOf('[') === 0) {
                var parts = key.split(']');
                key = parts[1];
                attr = parts[0].substr(1, parts[0].length-1);
            }

            if (key.indexOf(';') === key.length-1) {
                key = key.substr(0, key.length-2);
            }

            var optionsToUse;
            if (attr === 'html') {
                optionsToUse = o.defaultValueFromContent ? $.extend({ defaultValue: ele.html() }, options) : options;
                ele.html($.t(key, optionsToUse));
            } else if (attr === 'text') {
                optionsToUse = o.defaultValueFromContent ? $.extend({ defaultValue: ele.text() }, options) : options;
                ele.text($.t(key, optionsToUse));
            } else if (attr === 'prepend') {
                optionsToUse = o.defaultValueFromContent ? $.extend({ defaultValue: ele.html() }, options) : options;
                ele.prepend($.t(key, optionsToUse));
            } else if (attr === 'append') {
                optionsToUse = o.defaultValueFromContent ? $.extend({ defaultValue: ele.html() }, options) : options;
                ele.append($.t(key, optionsToUse));
            } else if (attr.indexOf("data-") === 0) {
                var dataAttr = attr.substr(("data-").length);
                optionsToUse = o.defaultValueFromContent ? $.extend({ defaultValue: ele.data(dataAttr) }, options) : options;
                var translated = $.t(key, optionsToUse);
                //we change into the data cache
                ele.data(dataAttr, translated);
                //we change into the dom
                ele.attr(attr, translated);
            } else {
                optionsToUse = o.defaultValueFromContent ? $.extend({ defaultValue: ele.attr(attr) }, options) : options;
                ele.attr(attr, $.t(key, optionsToUse));
            }
        }

        function localize(ele, options) {
            var key = ele.attr(o.selectorAttr);
            if (!key && typeof key !== 'undefined' && key !== false) key = ele.text() || ele.val();
            if (!key) return;

            var target = ele
              , targetSelector = ele.data("i18n-target");
            if (targetSelector) {
                target = ele.find(targetSelector) || ele;
            }

            if (!options && o.useDataAttrOptions === true) {
                options = ele.data("i18n-options");
            }
            options = options || {};

            if (key.indexOf(';') >= 0) {
                var keys = key.split(';');

                $.each(keys, function(m, k) {
                    if (k !== '') parse(target, k, options);
                });

            } else {
                parse(target, key, options);
            }

            if (o.useDataAttrOptions === true) ele.data("i18n-options", options);
        }

        // fn
        $.fn.i18n = function (options) {
            return this.each(function() {
                // localize element itself
                localize($(this), options);

                // localize childs
                var elements =  $(this).find('[' + o.selectorAttr + ']');
                elements.each(function() {
                    localize($(this), options);
                });
            });
        };
    }
    function applyReplacement(str, replacementHash, nestedKey, options) {
        if (!str) return str;

        options = options || replacementHash; // first call uses replacement hash combined with options
        if (str.indexOf(options.interpolationPrefix || o.interpolationPrefix) < 0) return str;

        var prefix = options.interpolationPrefix ? f.regexEscape(options.interpolationPrefix) : o.interpolationPrefixEscaped
          , suffix = options.interpolationSuffix ? f.regexEscape(options.interpolationSuffix) : o.interpolationSuffixEscaped
          , unEscapingSuffix = 'HTML'+suffix;

        var hash = replacementHash.replace && typeof replacementHash.replace === 'object' ? replacementHash.replace : replacementHash;
        f.each(hash, function(key, value) {
            var nextKey = nestedKey ? nestedKey + o.keyseparator + key : key;
            if (typeof value === 'object' && value !== null) {
                str = applyReplacement(str, value, nextKey, options);
            } else {
                if (options.escapeInterpolation || o.escapeInterpolation) {
                    str = str.replace(new RegExp([prefix, nextKey, unEscapingSuffix].join(''), 'g'), f.regexReplacementEscape(value));
                    str = str.replace(new RegExp([prefix, nextKey, suffix].join(''), 'g'), f.regexReplacementEscape(f.escape(value)));
                } else {
                    str = str.replace(new RegExp([prefix, nextKey, suffix].join(''), 'g'), f.regexReplacementEscape(value));
                }
                // str = options.escapeInterpolation;
            }
        });
        return str;
    }

    // append it to functions
    f.applyReplacement = applyReplacement;

    function applyReuse(translated, options) {
        var comma = ',';
        var options_open = '{';
        var options_close = '}';

        var opts = f.extend({}, options);
        delete opts.postProcess;

        while (translated.indexOf(o.reusePrefix) != -1) {
            replacementCounter++;
            if (replacementCounter > o.maxRecursion) { break; } // safety net for too much recursion
            var index_of_opening = translated.lastIndexOf(o.reusePrefix);
            var index_of_end_of_closing = translated.indexOf(o.reuseSuffix, index_of_opening) + o.reuseSuffix.length;
            var token = translated.substring(index_of_opening, index_of_end_of_closing);
            var token_without_symbols = token.replace(o.reusePrefix, '').replace(o.reuseSuffix, '');

            if (index_of_end_of_closing <= index_of_opening) {
                f.error('there is an missing closing in following translation value', translated);
                return '';
            }

            if (token_without_symbols.indexOf(comma) != -1) {
                var index_of_token_end_of_closing = token_without_symbols.indexOf(comma);
                if (token_without_symbols.indexOf(options_open, index_of_token_end_of_closing) != -1 && token_without_symbols.indexOf(options_close, index_of_token_end_of_closing) != -1) {
                    var index_of_opts_opening = token_without_symbols.indexOf(options_open, index_of_token_end_of_closing);
                    var index_of_opts_end_of_closing = token_without_symbols.indexOf(options_close, index_of_opts_opening) + options_close.length;
                    try {
                        opts = f.extend(opts, JSON.parse(token_without_symbols.substring(index_of_opts_opening, index_of_opts_end_of_closing)));
                        token_without_symbols = token_without_symbols.substring(0, index_of_token_end_of_closing);
                    } catch (e) {
                    }
                }
            }

            var translated_token = _translate(token_without_symbols, opts);
            translated = translated.replace(token, f.regexReplacementEscape(translated_token));
        }
        return translated;
    }

    function hasContext(options) {
        return (options.context && (typeof options.context == 'string' || typeof options.context == 'number'));
    }

    function needsPlural(options, lng) {
        return (options.count !== undefined && typeof options.count != 'string'/* && pluralExtensions.needsPlural(lng, options.count)*/);
    }

    function needsIndefiniteArticle(options) {
        return (options.indefinite_article !== undefined && typeof options.indefinite_article != 'string' && options.indefinite_article);
    }

    function exists(key, options) {
        options = options || {};

        var notFound = _getDefaultValue(key, options)
            , found = _find(key, options);

        return found !== undefined || found === notFound;
    }

    function translate(key, options) {
        options = options || {};

        if (!initialized) {
            f.log('i18next not finished initialization. you might have called t function before loading resources finished.')
            return options.defaultValue || '';
        };
        replacementCounter = 0;
        return _translate.apply(null, arguments);
    }

    function _getDefaultValue(key, options) {
        return (options.defaultValue !== undefined) ? options.defaultValue : key;
    }

    function _injectSprintfProcessor() {

        var values = [];

        // mh: build array from second argument onwards
        for (var i = 1; i < arguments.length; i++) {
            values.push(arguments[i]);
        }

        return {
            postProcess: 'sprintf',
            sprintf:     values
        };
    }

    function _translate(potentialKeys, options) {
        if (options && typeof options !== 'object') {
            if (o.shortcutFunction === 'sprintf') {
                // mh: gettext like sprintf syntax found, automatically create sprintf processor
                options = _injectSprintfProcessor.apply(null, arguments);
            } else if (o.shortcutFunction === 'defaultValue') {
                options = {
                    defaultValue: options
                }
            }
        } else {
            options = options || {};
        }

        if (typeof o.defaultVariables === 'object') {
            options = f.extend({}, o.defaultVariables, options);
        }

        if (potentialKeys === undefined || potentialKeys === null || potentialKeys === '') return '';

        if (typeof potentialKeys === 'number') {
            potentialKeys = String(potentialKeys);
        }

        if (typeof potentialKeys === 'string') {
            potentialKeys = [potentialKeys];
        }

        var key = potentialKeys[0];

        if (potentialKeys.length > 1) {
            for (var i = 0; i < potentialKeys.length; i++) {
                key = potentialKeys[i];
                if (exists(key, options)) {
                    break;
                }
            }
        }

        var notFound = _getDefaultValue(key, options)
            , found = _find(key, options)
            , lngs = options.lng ? f.toLanguages(options.lng, options.fallbackLng) : languages
            , ns = options.ns || o.ns.defaultNs
            , parts;

        // split ns and key
        if (key.indexOf(o.nsseparator) > -1) {
            parts = key.split(o.nsseparator);
            ns = parts[0];
            key = parts[1];
        }

        if (found === undefined && o.sendMissing && typeof o.missingKeyHandler === 'function') {
            if (options.lng) {
                o.missingKeyHandler(lngs[0], ns, key, notFound, lngs);
            } else {
                o.missingKeyHandler(o.lng, ns, key, notFound, lngs);
            }
        }

        var postProcessorsToApply;
        if (typeof o.postProcess === 'string' && o.postProcess !== '') {
            postProcessorsToApply = [o.postProcess];
        } else if (typeof o.postProcess === 'array' || typeof o.postProcess === 'object') {
            postProcessorsToApply = o.postProcess;
        } else {
            postProcessorsToApply = [];
        }

        if (typeof options.postProcess === 'string' && options.postProcess !== '') {
            postProcessorsToApply = postProcessorsToApply.concat([options.postProcess]);
        } else if (typeof options.postProcess === 'array' || typeof options.postProcess === 'object') {
            postProcessorsToApply = postProcessorsToApply.concat(options.postProcess);
        }

        if (found !== undefined && postProcessorsToApply.length) {
            postProcessorsToApply.forEach(function(postProcessor) {
                if (postProcessors[postProcessor]) {
                    found = postProcessors[postProcessor](found, key, options);
                }
            });
        }

        // process notFound if function exists
        var splitNotFound = notFound;
        if (notFound.indexOf(o.nsseparator) > -1) {
            parts = notFound.split(o.nsseparator);
            splitNotFound = parts[1];
        }
        if (splitNotFound === key && o.parseMissingKey) {
            notFound = o.parseMissingKey(notFound);
        }

        if (found === undefined) {
            notFound = applyReplacement(notFound, options);
            notFound = applyReuse(notFound, options);

            if (postProcessorsToApply.length) {
                var val = _getDefaultValue(key, options);
                postProcessorsToApply.forEach(function(postProcessor) {
                    if (postProcessors[postProcessor]) {
                        found = postProcessors[postProcessor](val, key, options);
                    }
                });
            }
        }

        return (found !== undefined) ? found : notFound;
    }

    function _find(key, options) {
        options = options || {};

        var optionWithoutCount, translated
            , notFound = _getDefaultValue(key, options)
            , lngs = languages;

        if (!resStore) { return notFound; } // no resStore to translate from

        // CI mode
        if (lngs[0].toLowerCase() === 'cimode') return notFound;

        // passed in lng
        if (options.lngs) lngs = options.lngs;
        if (options.lng) {
            lngs = f.toLanguages(options.lng, options.fallbackLng);

            if (!resStore[lngs[0]]) {
                var oldAsync = o.getAsync;
                o.getAsync = false;

                i18n.sync.load(lngs, o, function(err, store) {
                    f.extend(resStore, store);
                    o.getAsync = oldAsync;
                });
            }
        }

        var ns = options.ns || o.ns.defaultNs;
        if (key.indexOf(o.nsseparator) > -1) {
            var parts = key.split(o.nsseparator);
            ns = parts[0];
            key = parts[1];
        }

        if (hasContext(options)) {
            optionWithoutCount = f.extend({}, options);
            delete optionWithoutCount.context;
            optionWithoutCount.defaultValue = o.contextNotFound;

            var contextKey = ns + o.nsseparator + key + '_' + options.context;

            translated = translate(contextKey, optionWithoutCount);
            if (translated != o.contextNotFound) {
                return applyReplacement(translated, { context: options.context }); // apply replacement for context only
            } // else continue translation with original/nonContext key
        }

        if (needsPlural(options, lngs[0])) {
            optionWithoutCount = f.extend({ lngs: [lngs[0]]}, options);
            delete optionWithoutCount.count;
            optionWithoutCount._origLng = optionWithoutCount._origLng || optionWithoutCount.lng || lngs[0];
            delete optionWithoutCount.lng;
            optionWithoutCount.defaultValue = o.pluralNotFound;

            var pluralKey;
            if (!pluralExtensions.needsPlural(lngs[0], options.count)) {
                pluralKey = ns + o.nsseparator + key;
            } else {
                pluralKey = ns + o.nsseparator + key + o.pluralSuffix;
                var pluralExtension = pluralExtensions.get(lngs[0], options.count);
                if (pluralExtension >= 0) {
                    pluralKey = pluralKey + '_' + pluralExtension;
                } else if (pluralExtension === 1) {
                    pluralKey = ns + o.nsseparator + key; // singular
                }
            }

            translated = translate(pluralKey, optionWithoutCount);

            if (translated != o.pluralNotFound) {
                return applyReplacement(translated, {
                    count: options.count,
                    interpolationPrefix: options.interpolationPrefix,
                    interpolationSuffix: options.interpolationSuffix
                }); // apply replacement for count only
            } else if (lngs.length > 1) {
                // remove failed lng
                var clone = lngs.slice();
                clone.shift();
                options = f.extend(options, { lngs: clone });
                options._origLng = optionWithoutCount._origLng;
                delete options.lng;
                // retry with fallbacks
                translated = translate(ns + o.nsseparator + key, options);
                if (translated != o.pluralNotFound) return translated;
            } else {
                optionWithoutCount.lng = optionWithoutCount._origLng;
                delete optionWithoutCount._origLng;
                translated = translate(ns + o.nsseparator + key, optionWithoutCount);

                return applyReplacement(translated, {
                    count: options.count,
                    interpolationPrefix: options.interpolationPrefix,
                    interpolationSuffix: options.interpolationSuffix
                });
            }
        }

        if (needsIndefiniteArticle(options)) {
            var optionsWithoutIndef = f.extend({}, options);
            delete optionsWithoutIndef.indefinite_article;
            optionsWithoutIndef.defaultValue = o.indefiniteNotFound;
            // If we don't have a count, we want the indefinite, if we do have a count, and needsPlural is false
            var indefiniteKey = ns + o.nsseparator + key + (((options.count && !needsPlural(options, lngs[0])) || !options.count) ? o.indefiniteSuffix : "");
            translated = translate(indefiniteKey, optionsWithoutIndef);
            if (translated != o.indefiniteNotFound) {
                return translated;
            }
        }

        var found;
        var keys = key.split(o.keyseparator);
        for (var i = 0, len = lngs.length; i < len; i++ ) {
            if (found !== undefined) break;

            var l = lngs[i];

            var x = 0;
            var value = resStore[l] && resStore[l][ns];
            while (keys[x]) {
                value = value && value[keys[x]];
                x++;
            }
            if (value !== undefined) {
                var valueType = Object.prototype.toString.apply(value);
                if (typeof value === 'string') {
                    value = applyReplacement(value, options);
                    value = applyReuse(value, options);
                } else if (valueType === '[object Array]' && !o.returnObjectTrees && !options.returnObjectTrees) {
                    value = value.join('\n');
                    value = applyReplacement(value, options);
                    value = applyReuse(value, options);
                } else if (value === null && o.fallbackOnNull === true) {
                    value = undefined;
                } else if (value !== null) {
                    if (!o.returnObjectTrees && !options.returnObjectTrees) {
                        if (o.objectTreeKeyHandler && typeof o.objectTreeKeyHandler == 'function') {
                            value = o.objectTreeKeyHandler(key, value, l, ns, options);
                        } else {
                            value = 'key \'' + ns + ':' + key + ' (' + l + ')\' ' +
                                'returned an object instead of string.';
                            f.log(value);
                        }
                    } else if (valueType !== '[object Number]' && valueType !== '[object Function]' && valueType !== '[object RegExp]') {
                        var copy = (valueType === '[object Array]') ? [] : {}; // apply child translation on a copy
                        f.each(value, function(m) {
                            copy[m] = _translate(ns + o.nsseparator + key + o.keyseparator + m, options);
                        });
                        value = copy;
                    }
                }

                if (typeof value === 'string' && value.trim() === '' && o.fallbackOnEmpty === true)
                    value = undefined;

                found = value;
            }
        }

        if (found === undefined && !options.isFallbackLookup && (o.fallbackToDefaultNS === true || (o.fallbackNS && o.fallbackNS.length > 0))) {
            // set flag for fallback lookup - avoid recursion
            options.isFallbackLookup = true;

            if (o.fallbackNS.length) {

                for (var y = 0, lenY = o.fallbackNS.length; y < lenY; y++) {
                    found = _find(o.fallbackNS[y] + o.nsseparator + key, options);

                    if (found || (found==="" && o.fallbackOnEmpty === false)) {
                        /* compare value without namespace */
                        var foundValue = found.indexOf(o.nsseparator) > -1 ? found.split(o.nsseparator)[1] : found
                          , notFoundValue = notFound.indexOf(o.nsseparator) > -1 ? notFound.split(o.nsseparator)[1] : notFound;

                        if (foundValue !== notFoundValue) break;
                    }
                }
            } else {
                found = _find(key, options); // fallback to default NS
            }
            options.isFallbackLookup = false;
        }

        return found;
    }
    function detectLanguage() {
        var detectedLng;
        var whitelist = o.lngWhitelist || [];
        var userLngChoices = [];

        // get from qs
        var qsParm = [];
        if (typeof window !== 'undefined') {
            (function() {
                var query = window.location.search.substring(1);
                var params = query.split('&');
                for (var i=0; i<params.length; i++) {
                    var pos = params[i].indexOf('=');
                    if (pos > 0) {
                        var key = params[i].substring(0,pos);
                        if (key == o.detectLngQS) {
                            userLngChoices.push(params[i].substring(pos+1));
                        }
                    }
                }
            })();
        }

        // get from cookie
        if (o.useCookie && typeof document !== 'undefined') {
            var c = f.cookie.read(o.cookieName);
            if (c) userLngChoices.push(c);
        }

        // get from localStorage
        if (o.detectLngFromLocalStorage && typeof window !== 'undefined' && window.localStorage) {
            userLngChoices.push(f.localStorage.getItem('i18next_lng'));
        }

        // get from navigator
        if (typeof navigator !== 'undefined') {
            if (navigator.languages) { // chrome only; not an array, so can't use .push.apply instead of iterating
                for (var i=0;i<navigator.languages.length;i++) {
                    userLngChoices.push(navigator.languages[i]);
                }
            }
            if (navigator.userLanguage) {
                userLngChoices.push(navigator.userLanguage);
            }
            if (navigator.language) {
                userLngChoices.push(navigator.language);
            }
        }

        (function() {
            for (var i=0;i<userLngChoices.length;i++) {
                var lng = userLngChoices[i];

                if (lng.indexOf('-') > -1) {
                    var parts = lng.split('-');
                    lng = o.lowerCaseLng ?
                        parts[0].toLowerCase() +  '-' + parts[1].toLowerCase() :
                        parts[0].toLowerCase() +  '-' + parts[1].toUpperCase();
                }

                if (whitelist.length === 0 || whitelist.indexOf(lng) > -1) {
                    detectedLng = lng;
                    break;
                }
            }
        })();

        //fallback
        if (!detectedLng){
          detectedLng = o.fallbackLng[0];
        }

        return detectedLng;
    }
    // definition http://translate.sourceforge.net/wiki/l10n/pluralforms

    /* [code, name, numbers, pluralsType] */
    var _rules = [
        ["ach", "Acholi", [1,2], 1],
        ["af", "Afrikaans",[1,2], 2],
        ["ak", "Akan", [1,2], 1],
        ["am", "Amharic", [1,2], 1],
        ["an", "Aragonese",[1,2], 2],
        ["ar", "Arabic", [0,1,2,3,11,100],5],
        ["arn", "Mapudungun",[1,2], 1],
        ["ast", "Asturian", [1,2], 2],
        ["ay", "Aymará", [1], 3],
        ["az", "Azerbaijani",[1,2],2],
        ["be", "Belarusian",[1,2,5],4],
        ["bg", "Bulgarian",[1,2], 2],
        ["bn", "Bengali", [1,2], 2],
        ["bo", "Tibetan", [1], 3],
        ["br", "Breton", [1,2], 1],
        ["bs", "Bosnian", [1,2,5],4],
        ["ca", "Catalan", [1,2], 2],
        ["cgg", "Chiga", [1], 3],
        ["cs", "Czech", [1,2,5],6],
        ["csb", "Kashubian",[1,2,5],7],
        ["cy", "Welsh", [1,2,3,8],8],
        ["da", "Danish", [1,2], 2],
        ["de", "German", [1,2], 2],
        ["dev", "Development Fallback", [1,2], 2],
        ["dz", "Dzongkha", [1], 3],
        ["el", "Greek", [1,2], 2],
        ["en", "English", [1,2], 2],
        ["eo", "Esperanto",[1,2], 2],
        ["es", "Spanish", [1,2], 2],
        ["es_ar","Argentinean Spanish", [1,2], 2],
        ["et", "Estonian", [1,2], 2],
        ["eu", "Basque", [1,2], 2],
        ["fa", "Persian", [1], 3],
        ["fi", "Finnish", [1,2], 2],
        ["fil", "Filipino", [1,2], 1],
        ["fo", "Faroese", [1,2], 2],
        ["fr", "French", [1,2], 9],
        ["fur", "Friulian", [1,2], 2],
        ["fy", "Frisian", [1,2], 2],
        ["ga", "Irish", [1,2,3,7,11],10],
        ["gd", "Scottish Gaelic",[1,2,3,20],11],
        ["gl", "Galician", [1,2], 2],
        ["gu", "Gujarati", [1,2], 2],
        ["gun", "Gun", [1,2], 1],
        ["ha", "Hausa", [1,2], 2],
        ["he", "Hebrew", [1,2], 2],
        ["hi", "Hindi", [1,2], 2],
        ["hr", "Croatian", [1,2,5],4],
        ["hu", "Hungarian",[1,2], 2],
        ["hy", "Armenian", [1,2], 2],
        ["ia", "Interlingua",[1,2],2],
        ["id", "Indonesian",[1], 3],
        ["is", "Icelandic",[1,2], 12],
        ["it", "Italian", [1,2], 2],
        ["ja", "Japanese", [1], 3],
        ["jbo", "Lojban", [1], 3],
        ["jv", "Javanese", [0,1], 13],
        ["ka", "Georgian", [1], 3],
        ["kk", "Kazakh", [1], 3],
        ["km", "Khmer", [1], 3],
        ["kn", "Kannada", [1,2], 2],
        ["ko", "Korean", [1], 3],
        ["ku", "Kurdish", [1,2], 2],
        ["kw", "Cornish", [1,2,3,4],14],
        ["ky", "Kyrgyz", [1], 3],
        ["lb", "Letzeburgesch",[1,2],2],
        ["ln", "Lingala", [1,2], 1],
        ["lo", "Lao", [1], 3],
        ["lt", "Lithuanian",[1,2,10],15],
        ["lv", "Latvian", [1,2,0],16],
        ["mai", "Maithili", [1,2], 2],
        ["mfe", "Mauritian Creole",[1,2],1],
        ["mg", "Malagasy", [1,2], 1],
        ["mi", "Maori", [1,2], 1],
        ["mk", "Macedonian",[1,2],17],
        ["ml", "Malayalam",[1,2], 2],
        ["mn", "Mongolian",[1,2], 2],
        ["mnk", "Mandinka", [0,1,2],18],
        ["mr", "Marathi", [1,2], 2],
        ["ms", "Malay", [1], 3],
        ["mt", "Maltese", [1,2,11,20],19],
        ["nah", "Nahuatl", [1,2], 2],
        ["nap", "Neapolitan",[1,2], 2],
        ["nb", "Norwegian Bokmal",[1,2],2],
        ["ne", "Nepali", [1,2], 2],
        ["nl", "Dutch", [1,2], 2],
        ["nn", "Norwegian Nynorsk",[1,2],2],
        ["no", "Norwegian",[1,2], 2],
        ["nso", "Northern Sotho",[1,2],2],
        ["oc", "Occitan", [1,2], 1],
        ["or", "Oriya", [2,1], 2],
        ["pa", "Punjabi", [1,2], 2],
        ["pap", "Papiamento",[1,2], 2],
        ["pl", "Polish", [1,2,5],7],
        ["pms", "Piemontese",[1,2], 2],
        ["ps", "Pashto", [1,2], 2],
        ["pt", "Portuguese",[1,2], 2],
        ["pt_br","Brazilian Portuguese",[1,2], 2],
        ["rm", "Romansh", [1,2], 2],
        ["ro", "Romanian", [1,2,20],20],
        ["ru", "Russian", [1,2,5],4],
        ["sah", "Yakut", [1], 3],
        ["sco", "Scots", [1,2], 2],
        ["se", "Northern Sami",[1,2], 2],
        ["si", "Sinhala", [1,2], 2],
        ["sk", "Slovak", [1,2,5],6],
        ["sl", "Slovenian",[5,1,2,3],21],
        ["so", "Somali", [1,2], 2],
        ["son", "Songhay", [1,2], 2],
        ["sq", "Albanian", [1,2], 2],
        ["sr", "Serbian", [1,2,5],4],
        ["su", "Sundanese",[1], 3],
        ["sv", "Swedish", [1,2], 2],
        ["sw", "Swahili", [1,2], 2],
        ["ta", "Tamil", [1,2], 2],
        ["te", "Telugu", [1,2], 2],
        ["tg", "Tajik", [1,2], 1],
        ["th", "Thai", [1], 3],
        ["ti", "Tigrinya", [1,2], 1],
        ["tk", "Turkmen", [1,2], 2],
        ["tr", "Turkish", [1,2], 1],
        ["tt", "Tatar", [1], 3],
        ["ug", "Uyghur", [1], 3],
        ["uk", "Ukrainian",[1,2,5],4],
        ["ur", "Urdu", [1,2], 2],
        ["uz", "Uzbek", [1,2], 1],
        ["vi", "Vietnamese",[1], 3],
        ["wa", "Walloon", [1,2], 1],
        ["wo", "Wolof", [1], 3],
        ["yo", "Yoruba", [1,2], 2],
        ["zh", "Chinese", [1], 3]
    ];

    var _rulesPluralsTypes = {
        1: function(n) {return Number(n > 1);},
        2: function(n) {return Number(n != 1);},
        3: function(n) {return 0;},
        4: function(n) {return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);},
        5: function(n) {return Number(n===0 ? 0 : n==1 ? 1 : n==2 ? 2 : n%100>=3 && n%100<=10 ? 3 : n%100>=11 ? 4 : 5);},
        6: function(n) {return Number((n==1) ? 0 : (n>=2 && n<=4) ? 1 : 2);},
        7: function(n) {return Number(n==1 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);},
        8: function(n) {return Number((n==1) ? 0 : (n==2) ? 1 : (n != 8 && n != 11) ? 2 : 3);},
        9: function(n) {return Number(n >= 2);},
        10: function(n) {return Number(n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : 4) ;},
        11: function(n) {return Number((n==1 || n==11) ? 0 : (n==2 || n==12) ? 1 : (n > 2 && n < 20) ? 2 : 3);},
        12: function(n) {return Number(n%10!=1 || n%100==11);},
        13: function(n) {return Number(n !== 0);},
        14: function(n) {return Number((n==1) ? 0 : (n==2) ? 1 : (n == 3) ? 2 : 3);},
        15: function(n) {return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && (n%100<10 || n%100>=20) ? 1 : 2);},
        16: function(n) {return Number(n%10==1 && n%100!=11 ? 0 : n !== 0 ? 1 : 2);},
        17: function(n) {return Number(n==1 || n%10==1 ? 0 : 1);},
        18: function(n) {return Number(0 ? 0 : n==1 ? 1 : 2);},
        19: function(n) {return Number(n==1 ? 0 : n===0 || ( n%100>1 && n%100<11) ? 1 : (n%100>10 && n%100<20 ) ? 2 : 3);},
        20: function(n) {return Number(n==1 ? 0 : (n===0 || (n%100 > 0 && n%100 < 20)) ? 1 : 2);},
        21: function(n) {return Number(n%100==1 ? 1 : n%100==2 ? 2 : n%100==3 || n%100==4 ? 3 : 0); }
    };

    var pluralExtensions = {

        rules: (function () {
            var l, rules = {};
            for (l=_rules.length; l-- ;) {
                rules[_rules[l][0]] = {
                    name: _rules[l][1],
                    numbers: _rules[l][2],
                    plurals: _rulesPluralsTypes[_rules[l][3]]
                }
            }
            return rules;
        }()),

        // you can add your own pluralExtensions
        addRule: function(lng, obj) {
            pluralExtensions.rules[lng] = obj;
        },

        setCurrentLng: function(lng) {
            if (!pluralExtensions.currentRule || pluralExtensions.currentRule.lng !== lng) {
                var parts = lng.split('-');

                pluralExtensions.currentRule = {
                    lng: lng,
                    rule: pluralExtensions.rules[parts[0]]
                };
            }
        },

        needsPlural: function(lng, count) {
            var parts = lng.split('-');

            var ext;
            if (pluralExtensions.currentRule && pluralExtensions.currentRule.lng === lng) {
                ext = pluralExtensions.currentRule.rule;
            } else {
                ext = pluralExtensions.rules[parts[f.getCountyIndexOfLng(lng)]];
            }

            if (ext && ext.numbers.length <= 1) {
                return false;
            } else {
                return this.get(lng, count) !== 1;
            }
        },

        get: function(lng, count) {
            var parts = lng.split('-');

            function getResult(l, c) {
                var ext;
                if (pluralExtensions.currentRule && pluralExtensions.currentRule.lng === lng) {
                    ext = pluralExtensions.currentRule.rule;
                } else {
                    ext = pluralExtensions.rules[l];
                }
                if (ext) {
                    var i;
                    if (ext.noAbs) {
                        i = ext.plurals(c);
                    } else {
                        i = ext.plurals(Math.abs(c));
                    }

                    var number = ext.numbers[i];
                    if (ext.numbers.length === 2 && ext.numbers[0] === 1) {
                        if (number === 2) {
                            number = -1; // regular plural
                        } else if (number === 1) {
                            number = 1; // singular
                        }
                    }//console.log(count + '-' + number);
                    return number;
                } else {
                    return c === 1 ? '1' : '-1';
                }
            }

            return getResult(parts[f.getCountyIndexOfLng(lng)], count);
        }

    };
    var postProcessors = {};
    var addPostProcessor = function(name, fc) {
        postProcessors[name] = fc;
    };
    // sprintf support
    var sprintf = (function() {
        function get_type(variable) {
            return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
        }
        function str_repeat(input, multiplier) {
            for (var output = []; multiplier > 0; output[--multiplier] = input) {/* do nothing */}
            return output.join('');
        }

        var str_format = function() {
            if (!str_format.cache.hasOwnProperty(arguments[0])) {
                str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
            }
            return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
        };

        str_format.format = function(parse_tree, argv) {
            var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;
            for (i = 0; i < tree_length; i++) {
                node_type = get_type(parse_tree[i]);
                if (node_type === 'string') {
                    output.push(parse_tree[i]);
                }
                else if (node_type === 'array') {
                    match = parse_tree[i]; // convenience purposes only
                    if (match[2]) { // keyword argument
                        arg = argv[cursor];
                        for (k = 0; k < match[2].length; k++) {
                            if (!arg.hasOwnProperty(match[2][k])) {
                                throw(sprintf('[sprintf] property "%s" does not exist', match[2][k]));
                            }
                            arg = arg[match[2][k]];
                        }
                    }
                    else if (match[1]) { // positional argument (explicit)
                        arg = argv[match[1]];
                    }
                    else { // positional argument (implicit)
                        arg = argv[cursor++];
                    }

                    if (/[^s]/.test(match[8]) && (get_type(arg) != 'number')) {
                        throw(sprintf('[sprintf] expecting number but found %s', get_type(arg)));
                    }
                    switch (match[8]) {
                        case 'b': arg = arg.toString(2); break;
                        case 'c': arg = String.fromCharCode(arg); break;
                        case 'd': arg = parseInt(arg, 10); break;
                        case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;
                        case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;
                        case 'o': arg = arg.toString(8); break;
                        case 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break;
                        case 'u': arg = Math.abs(arg); break;
                        case 'x': arg = arg.toString(16); break;
                        case 'X': arg = arg.toString(16).toUpperCase(); break;
                    }
                    arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+'+ arg : arg);
                    pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';
                    pad_length = match[6] - String(arg).length;
                    pad = match[6] ? str_repeat(pad_character, pad_length) : '';
                    output.push(match[5] ? arg + pad : pad + arg);
                }
            }
            return output.join('');
        };

        str_format.cache = {};

        str_format.parse = function(fmt) {
            var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
            while (_fmt) {
                if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
                    parse_tree.push(match[0]);
                }
                else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
                    parse_tree.push('%');
                }
                else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
                    if (match[2]) {
                        arg_names |= 1;
                        var field_list = [], replacement_field = match[2], field_match = [];
                        if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                            field_list.push(field_match[1]);
                            while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                                if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                                    field_list.push(field_match[1]);
                                }
                                else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
                                    field_list.push(field_match[1]);
                                }
                                else {
                                    throw('[sprintf] huh?');
                                }
                            }
                        }
                        else {
                            throw('[sprintf] huh?');
                        }
                        match[2] = field_list;
                    }
                    else {
                        arg_names |= 2;
                    }
                    if (arg_names === 3) {
                        throw('[sprintf] mixing positional and named placeholders is not (yet) supported');
                    }
                    parse_tree.push(match);
                }
                else {
                    throw('[sprintf] huh?');
                }
                _fmt = _fmt.substring(match[0].length);
            }
            return parse_tree;
        };

        return str_format;
    })();

    var vsprintf = function(fmt, argv) {
        argv.unshift(fmt);
        return sprintf.apply(null, argv);
    };

    addPostProcessor("sprintf", function(val, key, opts) {
        if (!opts.sprintf) return val;

        if (Object.prototype.toString.apply(opts.sprintf) === '[object Array]') {
            return vsprintf(val, opts.sprintf);
        } else if (typeof opts.sprintf === 'object') {
            return sprintf(val, opts.sprintf);
        }

        return val;
    });
    // public api interface
    i18n.init = init;
    i18n.setLng = setLng;
    i18n.preload = preload;
    i18n.addResourceBundle = addResourceBundle;
    i18n.hasResourceBundle = hasResourceBundle;
    i18n.getResourceBundle = getResourceBundle;
    i18n.addResource = addResource;
    i18n.addResources = addResources;
    i18n.removeResourceBundle = removeResourceBundle;
    i18n.loadNamespace = loadNamespace;
    i18n.loadNamespaces = loadNamespaces;
    i18n.setDefaultNamespace = setDefaultNamespace;
    i18n.t = translate;
    i18n.translate = translate;
    i18n.exists = exists;
    i18n.detectLanguage = f.detectLanguage;
    i18n.pluralExtensions = pluralExtensions;
    i18n.sync = sync;
    i18n.functions = f;
    i18n.lng = lng;
    i18n.addPostProcessor = addPostProcessor;
    i18n.applyReplacement = f.applyReplacement;
    i18n.options = o;

})(typeof exports === 'undefined' ? window : exports);

},{"jquery":"jquery"}],153:[function(require,module,exports){
/*! jquery.atwho - v0.4.7 - 2014-02-22
* Copyright (c) 2014 chord.luo <chord.luo@gmail.com>; 
* homepage: http://ichord.github.com/At.js 
* Licensed MIT
*/

(function() {
  (function(factory) {
    if (typeof define === 'function' && define.amd) {
      return define(['jquery'], factory);
    } else {
      return factory(window.jQuery);
    }
  })(function($) {

var $CONTAINER, Api, App, Atwho, Controller, DEFAULT_CALLBACKS, KEY_CODE, Model, View,
  __slice = [].slice;

App = (function() {
  function App(inputor) {
    this.current_flag = null;
    this.controllers = {};
    this.alias_maps = {};
    this.$inputor = $(inputor);
    this.listen();
  }

  App.prototype.controller = function(at) {
    return this.controllers[this.alias_maps[at] || at || this.current_flag];
  };

  App.prototype.set_context_for = function(at) {
    this.current_flag = at;
    return this;
  };

  App.prototype.reg = function(flag, setting) {
    var controller, _base;
    controller = (_base = this.controllers)[flag] || (_base[flag] = new Controller(this, flag));
    if (setting.alias) {
      this.alias_maps[setting.alias] = flag;
    }
    controller.init(setting);
    return this;
  };

  App.prototype.listen = function() {
    return this.$inputor.on('keyup.atwhoInner', (function(_this) {
      return function(e) {
        return _this.on_keyup(e);
      };
    })(this)).on('keydown.atwhoInner', (function(_this) {
      return function(e) {
        return _this.on_keydown(e);
      };
    })(this)).on('scroll.atwhoInner', (function(_this) {
      return function(e) {
        var _ref;
        return (_ref = _this.controller()) != null ? _ref.view.hide() : void 0;
      };
    })(this)).on('blur.atwhoInner', (function(_this) {
      return function(e) {
        var c;
        if (c = _this.controller()) {
          return c.view.hide(c.get_opt("display_timeout"));
        }
      };
    })(this));
  };

  App.prototype.shutdown = function() {
    var c, _, _ref;
    _ref = this.controllers;
    for (_ in _ref) {
      c = _ref[_];
      c.destroy();
    }
    return this.$inputor.off('.atwhoInner');
  };

  App.prototype.dispatch = function() {
    return $.map(this.controllers, (function(_this) {
      return function(c) {
        if (c.look_up()) {
          return _this.set_context_for(c.at);
        }
      };
    })(this));
  };

  App.prototype.on_keyup = function(e) {
    var _ref;
    switch (e.keyCode) {
      case KEY_CODE.ESC:
        e.preventDefault();
        if ((_ref = this.controller()) != null) {
          _ref.view.hide();
        }
        break;
      case KEY_CODE.DOWN:
      case KEY_CODE.UP:
        $.noop();
        break;
      default:
        this.dispatch();
    }
  };

  App.prototype.on_keydown = function(e) {
    var view, _ref;
    view = (_ref = this.controller()) != null ? _ref.view : void 0;
    if (!(view && view.visible())) {
      return;
    }
    switch (e.keyCode) {
      case KEY_CODE.ESC:
        e.preventDefault();
        view.hide();
        break;
      case KEY_CODE.UP:
        e.preventDefault();
        view.prev();
        break;
      case KEY_CODE.DOWN:
        e.preventDefault();
        view.next();
        break;
      case KEY_CODE.TAB:
      case KEY_CODE.ENTER:
        if (!view.visible()) {
          return;
        }
        e.preventDefault();
        view.choose();
        break;
      default:
        $.noop();
    }
  };

  return App;

})();

Controller = (function() {
  var uuid, _uuid;

  _uuid = 0;

  uuid = function() {
    return _uuid += 1;
  };

  function Controller(app, at) {
    this.app = app;
    this.at = at;
    this.$inputor = this.app.$inputor;
    this.oDocument = this.$inputor[0].ownerDocument;
    this.oWindow = this.oDocument.defaultView || this.oDocument.parentWindow;
    this.id = this.$inputor[0].id || uuid();
    this.setting = null;
    this.query = null;
    this.pos = 0;
    this.cur_rect = null;
    this.range = null;
    $CONTAINER.append(this.$el = $("<div id='atwho-ground-" + this.id + "'></div>"));
    this.model = new Model(this);
    this.view = new View(this);
  }

  Controller.prototype.init = function(setting) {
    this.setting = $.extend({}, this.setting || $.fn.atwho["default"], setting);
    this.view.init();
    return this.model.reload(this.setting.data);
  };

  Controller.prototype.destroy = function() {
    this.trigger('beforeDestroy');
    this.model.destroy();
    return this.view.destroy();
  };

  Controller.prototype.call_default = function() {
    var args, error, func_name;
    func_name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    try {
      return DEFAULT_CALLBACKS[func_name].apply(this, args);
    } catch (_error) {
      error = _error;
      return $.error("" + error + " Or maybe At.js doesn't have function " + func_name);
    }
  };

  Controller.prototype.trigger = function(name, data) {
    var alias, event_name;
    if (data == null) {
      data = [];
    }
    data.push(this);
    alias = this.get_opt('alias');
    event_name = alias ? "" + name + "-" + alias + ".atwho" : "" + name + ".atwho";
    return this.$inputor.trigger(event_name, data);
  };

  Controller.prototype.callbacks = function(func_name) {
    return this.get_opt("callbacks")[func_name] || DEFAULT_CALLBACKS[func_name];
  };

  Controller.prototype.get_opt = function(at, default_value) {
    var e;
    try {
      return this.setting[at];
    } catch (_error) {
      e = _error;
      return null;
    }
  };

  Controller.prototype.content = function() {
    if (this.$inputor.is('textarea, input')) {
      return this.$inputor.val();
    } else {
      return this.$inputor.text();
    }
  };

  Controller.prototype.catch_query = function() {
    var caret_pos, content, end, query, start, subtext;
    content = this.content();
    caret_pos = this.$inputor.caret('pos');
    subtext = content.slice(0, caret_pos);
    query = this.callbacks("matcher").call(this, this.at, subtext, this.get_opt('start_with_space'));
    if (typeof query === "string" && query.length <= this.get_opt('max_len', 20)) {
      start = caret_pos - query.length;
      end = start + query.length;
      this.pos = start;
      query = {
        'text': query.toLowerCase(),
        'head_pos': start,
        'end_pos': end
      };
      this.trigger("matched", [this.at, query.text]);
    } else {
      this.view.hide();
    }
    return this.query = query;
  };

  Controller.prototype.rect = function() {
    var c, scale_bottom;
    if (!(c = this.$inputor.caret('offset', this.pos - 1))) {
      return;
    }
    if (this.$inputor.attr('contentEditable') === 'true') {
      c = (this.cur_rect || (this.cur_rect = c)) || c;
    }
    scale_bottom = document.selection ? 0 : 2;
    return {
      left: c.left,
      top: c.top,
      bottom: c.top + c.height + scale_bottom
    };
  };

  Controller.prototype.reset_rect = function() {
    if (this.$inputor.attr('contentEditable') === 'true') {
      return this.cur_rect = null;
    }
  };

  Controller.prototype.mark_range = function() {
    if (this.$inputor.attr('contentEditable') === 'true') {
      if (this.oWindow.getSelection) {
        this.range = this.oWindow.getSelection().getRangeAt(0);
      }
      if (this.oDocument.selection) {
        return this.ie8_range = this.oDocument.selection.createRange();
      }
    }
  };

  Controller.prototype.insert_content_for = function($li) {
    var data, data_value, tpl;
    data_value = $li.data('value');
    tpl = this.get_opt('insert_tpl');
    if (this.$inputor.is('textarea, input') || !tpl) {
      return data_value;
    }
    data = $.extend({}, $li.data('item-data'), {
      'atwho-data-value': data_value,
      'atwho-at': this.at
    });
    return this.callbacks("tpl_eval").call(this, tpl, data);
  };

  Controller.prototype.insert = function(content, $li) {
    var $inputor, $insert_node, class_name, content_node, insert_node, pos, range, sel, source, start_str, text;
    $inputor = this.$inputor;
    if ($inputor.attr('contentEditable') === 'true') {
      class_name = "atwho-view-flag atwho-view-flag-" + (this.get_opt('alias') || this.at);
      content_node = "" + content + "<span contenteditable='false'>&nbsp;<span>";
      insert_node = "<span contenteditable='false' class='" + class_name + "'>" + content_node + "</span>";
      $insert_node = $(insert_node, this.oDocument).data('atwho-data-item', $li.data('item-data'));
      if (this.oDocument.selection) {
        $insert_node = $("<span contenteditable='true'></span>", this.oDocument).html($insert_node);
      }
    }
    if ($inputor.is('textarea, input')) {
      content = '' + content;
      source = $inputor.val();
      start_str = source.slice(0, Math.max(this.query.head_pos - this.at.length, 0));
      text = "" + start_str + content + " " + (source.slice(this.query['end_pos'] || 0));
      $inputor.val(text);
      $inputor.caret('pos', start_str.length + content.length + 1);
    } else if (range = this.range) {
      pos = range.startOffset - (this.query.end_pos - this.query.head_pos) - this.at.length;
      range.setStart(range.endContainer, Math.max(pos, 0));
      range.setEnd(range.endContainer, range.endOffset);
      range.deleteContents();
      range.insertNode($insert_node[0]);
      range.collapse(false);
      sel = this.oWindow.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
    } else if (range = this.ie8_range) {
      range.moveStart('character', this.query.end_pos - this.query.head_pos - this.at.length);
      range.pasteHTML(content_node);
      range.collapse(false);
      range.select();
    }
    if (!$inputor.is(':focus')) {
      $inputor.focus();
    }
    return $inputor.change();
  };

  Controller.prototype.render_view = function(data) {
    var search_key;
    search_key = this.get_opt("search_key");
    data = this.callbacks("sorter").call(this, this.query.text, data.slice(0, 1001), search_key);
    return this.view.render(data.slice(0, this.get_opt('limit')));
  };

  Controller.prototype.look_up = function() {
    var query, _callback;
    if (!(query = this.catch_query())) {
      return;
    }
    _callback = function(data) {
      if (data && data.length > 0) {
        return this.render_view(data);
      } else {
        return this.view.hide();
      }
    };
    this.model.query(query.text, $.proxy(_callback, this));
    return query;
  };

  return Controller;

})();

Model = (function() {
  function Model(context) {
    this.context = context;
    this.at = this.context.at;
    this.storage = this.context.$inputor;
  }

  Model.prototype.destroy = function() {
    return this.storage.data(this.at, null);
  };

  Model.prototype.saved = function() {
    return this.fetch() > 0;
  };

  Model.prototype.query = function(query, callback) {
    var data, search_key, _remote_filter;
    data = this.fetch();
    search_key = this.context.get_opt("search_key");
    data = this.context.callbacks('filter').call(this.context, query, data, search_key) || [];
    _remote_filter = this.context.callbacks('remote_filter');
    if (data.length > 0 || (!_remote_filter && data.length === 0)) {
      return callback(data);
    } else {
      return _remote_filter.call(this.context, query, callback);
    }
  };

  Model.prototype.fetch = function() {
    return this.storage.data(this.at) || [];
  };

  Model.prototype.save = function(data) {
    return this.storage.data(this.at, this.context.callbacks("before_save").call(this.context, data || []));
  };

  Model.prototype.load = function(data) {
    if (!(this.saved() || !data)) {
      return this._load(data);
    }
  };

  Model.prototype.reload = function(data) {
    return this._load(data);
  };

  Model.prototype._load = function(data) {
    if (typeof data === "string") {
      return $.ajax(data, {
        dataType: "json"
      }).done((function(_this) {
        return function(data) {
          return _this.save(data);
        };
      })(this));
    } else {
      return this.save(data);
    }
  };

  return Model;

})();

View = (function() {
  function View(context) {
    this.context = context;
    this.$el = $("<div class='atwho-view'><ul class='atwho-view-ul'></ul></div>");
    this.timeout_id = null;
    this.context.$el.append(this.$el);
    this.bind_event();
  }

  View.prototype.init = function() {
    var id;
    id = this.context.get_opt("alias") || this.context.at.charCodeAt(0);
    return this.$el.attr({
      'id': "at-view-" + id
    });
  };

  View.prototype.destroy = function() {
    return this.$el.remove();
  };

  View.prototype.bind_event = function() {
    var $menu;
    $menu = this.$el.find('ul');
    return $menu.on('mouseenter.atwho-view', 'li', function(e) {
      $menu.find('.cur').removeClass('cur');
      return $(e.currentTarget).addClass('cur');
    }).on('click', (function(_this) {
      return function(e) {
        _this.choose();
        return e.preventDefault();
      };
    })(this));
  };

  View.prototype.visible = function() {
    return this.$el.is(":visible");
  };

  View.prototype.choose = function() {
    var $li, content;
    $li = this.$el.find(".cur");
    content = this.context.insert_content_for($li);
    this.context.insert(this.context.callbacks("before_insert").call(this.context, content, $li), $li);
    this.context.trigger("inserted", [$li]);
    return this.hide();
  };

  View.prototype.reposition = function(rect) {
    var offset;
    if (rect.bottom + this.$el.height() - $(window).scrollTop() > $(window).height()) {
      rect.bottom = rect.top - this.$el.height();
    }
    offset = {
      left: rect.left,
      top: rect.bottom
    };
    this.$el.offset(offset);
    return this.context.trigger("reposition", [offset]);
  };

  View.prototype.next = function() {
    var cur, next;
    cur = this.$el.find('.cur').removeClass('cur');
    next = cur.next();
    if (!next.length) {
      next = this.$el.find('li:first');
    }
    return next.addClass('cur');
  };

  View.prototype.prev = function() {
    var cur, prev;
    cur = this.$el.find('.cur').removeClass('cur');
    prev = cur.prev();
    if (!prev.length) {
      prev = this.$el.find('li:last');
    }
    return prev.addClass('cur');
  };

  View.prototype.show = function() {
    var rect;
    this.context.mark_range();
    if (!this.visible()) {
      this.$el.show();
    }
    if (rect = this.context.rect()) {
      return this.reposition(rect);
    }
  };

  View.prototype.hide = function(time) {
    var callback;
    if (isNaN(time && this.visible())) {
      this.context.reset_rect();
      return this.$el.hide();
    } else {
      callback = (function(_this) {
        return function() {
          return _this.hide();
        };
      })(this);
      clearTimeout(this.timeout_id);
      return this.timeout_id = setTimeout(callback, time);
    }
  };

  View.prototype.render = function(list) {
    var $li, $ul, item, li, tpl, _i, _len;
    if (!($.isArray(list) && list.length > 0)) {
      this.hide();
      return;
    }
    this.$el.find('ul').empty();
    $ul = this.$el.find('ul');
    tpl = this.context.get_opt('tpl');
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      item = list[_i];
      item = $.extend({}, item, {
        'atwho-at': this.context.at
      });
      li = this.context.callbacks("tpl_eval").call(this.context, tpl, item);
      $li = $(this.context.callbacks("highlighter").call(this.context, li, this.context.query.text));
      $li.data("item-data", item);
      $ul.append($li);
    }
    this.show();
    return $ul.find("li:first").addClass("cur");
  };

  return View;

})();

KEY_CODE = {
  DOWN: 40,
  UP: 38,
  ESC: 27,
  TAB: 9,
  ENTER: 13
};

DEFAULT_CALLBACKS = {
  before_save: function(data) {
    var item, _i, _len, _results;
    if (!$.isArray(data)) {
      return data;
    }
    _results = [];
    for (_i = 0, _len = data.length; _i < _len; _i++) {
      item = data[_i];
      if ($.isPlainObject(item)) {
        _results.push(item);
      } else {
        _results.push({
          name: item
        });
      }
    }
    return _results;
  },
  matcher: function(flag, subtext, should_start_with_space) {
    var match, regexp;
    flag = flag.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
    if (should_start_with_space) {
      flag = '(?:^|\\s)' + flag;
    }
    regexp = new RegExp(flag + '([A-Za-z0-9_\+\-]*)$|' + flag + '([^\\x00-\\xff]*)$', 'gi');
    match = regexp.exec(subtext);
    if (match) {
      return match[2] || match[1];
    } else {
      return null;
    }
  },
  filter: function(query, data, search_key) {
    var item, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = data.length; _i < _len; _i++) {
      item = data[_i];
      if (~item[search_key].toLowerCase().indexOf(query)) {
        _results.push(item);
      }
    }
    return _results;
  },
  remote_filter: null,
  sorter: function(query, items, search_key) {
    var item, _i, _len, _results;
    if (!query) {
      return items;
    }
    _results = [];
    for (_i = 0, _len = items.length; _i < _len; _i++) {
      item = items[_i];
      item.atwho_order = item[search_key].toLowerCase().indexOf(query);
      if (item.atwho_order > -1) {
        _results.push(item);
      }
    }
    return _results.sort(function(a, b) {
      return a.atwho_order - b.atwho_order;
    });
  },
  tpl_eval: function(tpl, map) {
    var error;
    try {
      return tpl.replace(/\$\{([^\}]*)\}/g, function(tag, key, pos) {
        return map[key];
      });
    } catch (_error) {
      error = _error;
      return "";
    }
  },
  highlighter: function(li, query) {
    var regexp;
    if (!query) {
      return li;
    }
    regexp = new RegExp(">\\s*(\\w*)(" + query.replace("+", "\\+") + ")(\\w*)\\s*<", 'ig');
    return li.replace(regexp, function(str, $1, $2, $3) {
      return '> ' + $1 + '<strong>' + $2 + '</strong>' + $3 + ' <';
    });
  },
  before_insert: function(value, $li) {
    return value;
  }
};

Api = {
  load: function(at, data) {
    var c;
    if (c = this.controller(at)) {
      return c.model.load(data);
    }
  },
  getInsertedItemsWithIDs: function(at) {
    var c, ids, items;
    if (!(c = this.controller(at))) {
      return [null, null];
    }
    if (at) {
      at = "-" + (c.get_opt('alias') || c.at);
    }
    ids = [];
    items = $.map(this.$inputor.find("span.atwho-view-flag" + (at || "")), function(item) {
      var data;
      data = $(item).data('atwho-data-item');
      if (ids.indexOf(data.id) > -1) {
        return;
      }
      if (data.id) {
        ids.push = data.id;
      }
      return data;
    });
    return [ids, items];
  },
  getInsertedItems: function(at) {
    return Api.getInsertedItemsWithIDs.apply(this, [at])[1];
  },
  getInsertedIDs: function(at) {
    return Api.getInsertedItemsWithIDs.apply(this, [at])[0];
  },
  run: function() {
    return this.dispatch();
  },
  destroy: function() {
    this.shutdown();
    return this.$inputor.data('atwho', null);
  }
};

Atwho = {
  init: function(options) {
    var $this, app;
    app = ($this = $(this)).data("atwho");
    if (!app) {
      $this.data('atwho', (app = new App(this)));
    }
    app.reg(options.at, options);
    return this;
  }
};

$CONTAINER = $("<div id='atwho-container'></div>");

$.fn.atwho = function(method) {
  var result, _args;
  _args = arguments;
  $('body').append($CONTAINER);
  result = null;
  this.filter('textarea, input, [contenteditable=true]').each(function() {
    var app;
    if (typeof method === 'object' || !method) {
      return Atwho.init.apply(this, _args);
    } else if (Api[method]) {
      if (app = $(this).data('atwho')) {
        return result = Api[method].apply(app, Array.prototype.slice.call(_args, 1));
      }
    } else {
      return $.error("Method " + method + " does not exist on jQuery.caret");
    }
  });
  return result || this;
};

$.fn.atwho["default"] = {
  at: void 0,
  alias: void 0,
  data: null,
  tpl: "<li data-value='${atwho-at}${name}'>${name}</li>",
  insert_tpl: "<span>${atwho-data-value}</span>",
  callbacks: DEFAULT_CALLBACKS,
  search_key: "name",
  start_with_space: true,
  limit: 5,
  max_len: 20,
  display_timeout: 300
};

  });
}).call(this);

},{}],154:[function(require,module,exports){
/*! jquery.caret 2014-03-14 */
(function(){!function(a){return"function"==typeof define&&define.amd?define(["jquery"],a):a(window.jQuery)}(function(a){"use strict";var b,c,d,e,f,g,h,i,j;return j="caret",b=function(){function b(a){this.$inputor=a,this.domInputor=this.$inputor[0]}return b.prototype.setPos=function(){return this.domInputor},b.prototype.getIEPosition=function(){return a.noop()},b.prototype.getPosition=function(){return a.noop()},b.prototype.getOldIEPos=function(){var a,b;return b=g.selection.createRange(),a=g.body.createTextRange(),a.moveToElementText(this.domInputor),a.setEndPoint("EndToEnd",b),a.text.length},b.prototype.getPos=function(){var a,b,c;return(c=this.range())?(a=c.cloneRange(),a.selectNodeContents(this.domInputor),a.setEnd(c.endContainer,c.endOffset),b=a.toString().length,a.detach(),b):g.selection?this.getOldIEPos():void 0},b.prototype.getOldIEOffset=function(){var a,b;return a=g.selection.createRange().duplicate(),a.moveStart("character",-1),b=a.getBoundingClientRect(),{height:b.bottom-b.top,left:b.left,top:b.top}},b.prototype.getOffset=function(){var b,c,d,e;if(i.getSelection&&(d=this.range())){if(d.endOffset-1<0)return null;b=d.cloneRange(),b.setStart(d.endContainer,d.endOffset-1),b.setEnd(d.endContainer,d.endOffset),e=b.getBoundingClientRect(),c={height:e.height,left:e.left+e.width,top:e.top},b.detach()}else g.selection&&(c=this.getOldIEOffset());return c&&!h&&(c.top+=a(i).scrollTop(),c.left+=a(i).scrollLeft()),c},b.prototype.range=function(){var a;if(i.getSelection)return a=i.getSelection(),a.rangeCount>0?a.getRangeAt(0):null},b}(),c=function(){function b(a){this.$inputor=a,this.domInputor=this.$inputor[0]}return b.prototype.getIEPos=function(){var a,b,c,d,e,f,h;return b=this.domInputor,f=g.selection.createRange(),e=0,f&&f.parentElement()===b&&(d=b.value.replace(/\r\n/g,"\n"),c=d.length,h=b.createTextRange(),h.moveToBookmark(f.getBookmark()),a=b.createTextRange(),a.collapse(!1),e=h.compareEndPoints("StartToEnd",a)>-1?c:-h.moveStart("character",-c)),e},b.prototype.getPos=function(){return g.selection?this.getIEPos():this.domInputor.selectionStart},b.prototype.setPos=function(a){var b,c;return b=this.domInputor,g.selection?(c=b.createTextRange(),c.move("character",a),c.select()):b.setSelectionRange&&b.setSelectionRange(a,a),b},b.prototype.getIEOffset=function(a){var b,c,d,e;return c=this.domInputor.createTextRange(),a||(a=this.getPos()),c.move("character",a),d=c.boundingLeft,e=c.boundingTop,b=c.boundingHeight,{left:d,top:e,height:b}},b.prototype.getOffset=function(b){var c,d,e;return c=this.$inputor,g.selection?(d=this.getIEOffset(b),d.top+=a(i).scrollTop()+c.scrollTop(),d.left+=a(i).scrollLeft()+c.scrollLeft(),d):(d=c.offset(),e=this.getPosition(b),d={left:d.left+e.left-c.scrollLeft(),top:d.top+e.top-c.scrollTop(),height:e.height})},b.prototype.getPosition=function(a){var b,c,e,f,g,h;return b=this.$inputor,e=function(a){return a.replace(/</g,"&lt").replace(/>/g,"&gt").replace(/`/g,"&#96").replace(/"/g,"&quot").replace(/\r\n|\r|\n/g,"<br />")},void 0===a&&(a=this.getPos()),h=b.val().slice(0,a),f="<span>"+e(h)+"</span>",f+="<span id='caret'>|</span>",g=new d(b),c=g.create(f).rect()},b.prototype.getIEPosition=function(a){var b,c,d,e,f;return d=this.getIEOffset(a),c=this.$inputor.offset(),e=d.left-c.left,f=d.top-c.top,b=d.height,{left:e,top:f,height:b}},b}(),d=function(){function b(a){this.$inputor=a}return b.prototype.css_attr=["overflowY","height","width","paddingTop","paddingLeft","paddingRight","paddingBottom","marginTop","marginLeft","marginRight","marginBottom","fontFamily","borderStyle","borderWidth","wordWrap","fontSize","lineHeight","overflowX","text-align"],b.prototype.mirrorCss=function(){var b,c=this;return b={position:"absolute",left:-9999,top:0,zIndex:-2e4,"white-space":"pre-wrap"},a.each(this.css_attr,function(a,d){return b[d]=c.$inputor.css(d)}),b},b.prototype.create=function(b){return this.$mirror=a("<div></div>"),this.$mirror.css(this.mirrorCss()),this.$mirror.html(b),this.$inputor.after(this.$mirror),this},b.prototype.rect=function(){var a,b,c;return a=this.$mirror.find("#caret"),b=a.position(),c={left:b.left,top:b.top,height:a.height()},this.$mirror.remove(),c},b}(),e={contentEditable:function(a){return!(!a[0].contentEditable||"true"!==a[0].contentEditable)}},f={pos:function(a){return a||0===a?this.setPos(a):this.getPos()},position:function(a){return g.selection?this.getIEPosition(a):this.getPosition(a)},offset:function(b){var c,d;return d=this.getOffset(b),h&&(c=a(h).offset(),d.top+=c.top,d.left+=c.left),d}},g=null,i=null,h=null,a.fn.caret=function(d){var j,k;g=this[0].ownerDocument,i=g.defaultView||g.parentWindow;try{h=i.frameElement}catch(l){k=l}return j=e.contentEditable(this)?new b(this):new c(this),f[d]?f[d].apply(j,Array.prototype.slice.call(arguments,1)):a.error("Method "+d+" does not exist on jQuery.caret")},a.fn.caret.EditableCaret=b,a.fn.caret.InputCaret=c,a.fn.caret.Utils=e,a.fn.caret.apis=f})}).call(this);
},{}],155:[function(require,module,exports){
(function (global){
/**
 * marked - a markdown parser
 * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/chjj/marked
 */

;(function() {

/**
 * Block-Level Grammar
 */

var block = {
  newline: /^\n+/,
  code: /^( {4}[^\n]+\n*)+/,
  fences: noop,
  hr: /^( *[-*_]){3,} *(?:\n+|$)/,
  heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
  nptable: noop,
  lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
  blockquote: /^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/,
  list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
  html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
  table: noop,
  paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
  text: /^[^\n]+/
};

block.bullet = /(?:[*+-]|\d+\.)/;
block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
block.item = replace(block.item, 'gm')
  (/bull/g, block.bullet)
  ();

block.list = replace(block.list)
  (/bull/g, block.bullet)
  ('hr', '\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))')
  ('def', '\\n+(?=' + block.def.source + ')')
  ();

block.blockquote = replace(block.blockquote)
  ('def', block.def)
  ();

block._tag = '(?!(?:'
  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
  + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b';

block.html = replace(block.html)
  ('comment', /<!--[\s\S]*?-->/)
  ('closed', /<(tag)[\s\S]+?<\/\1>/)
  ('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)
  (/tag/g, block._tag)
  ();

block.paragraph = replace(block.paragraph)
  ('hr', block.hr)
  ('heading', block.heading)
  ('lheading', block.lheading)
  ('blockquote', block.blockquote)
  ('tag', '<' + block._tag)
  ('def', block.def)
  ();

/**
 * Normal Block Grammar
 */

block.normal = merge({}, block);

/**
 * GFM Block Grammar
 */

block.gfm = merge({}, block.normal, {
  fences: /^ *(`{3,}|~{3,}) *(\S+)? *\n([\s\S]+?)\s*\1 *(?:\n+|$)/,
  paragraph: /^/
});

block.gfm.paragraph = replace(block.paragraph)
  ('(?!', '(?!'
    + block.gfm.fences.source.replace('\\1', '\\2') + '|'
    + block.list.source.replace('\\1', '\\3') + '|')
  ();

/**
 * GFM + Tables Block Grammar
 */

block.tables = merge({}, block.gfm, {
  nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
  table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
});

/**
 * Block Lexer
 */

function Lexer(options) {
  this.tokens = [];
  this.tokens.links = {};
  this.options = options || marked.defaults;
  this.rules = block.normal;

  if (this.options.gfm) {
    if (this.options.tables) {
      this.rules = block.tables;
    } else {
      this.rules = block.gfm;
    }
  }
}

/**
 * Expose Block Rules
 */

Lexer.rules = block;

/**
 * Static Lex Method
 */

Lexer.lex = function(src, options) {
  var lexer = new Lexer(options);
  return lexer.lex(src);
};

/**
 * Preprocessing
 */

Lexer.prototype.lex = function(src) {
  src = src
    .replace(/\r\n|\r/g, '\n')
    .replace(/\t/g, '    ')
    .replace(/\u00a0/g, ' ')
    .replace(/\u2424/g, '\n');

  return this.token(src, true);
};

/**
 * Lexing
 */

Lexer.prototype.token = function(src, top, bq) {
  var src = src.replace(/^ +$/gm, '')
    , next
    , loose
    , cap
    , bull
    , b
    , item
    , space
    , i
    , l;

  while (src) {
    // newline
    if (cap = this.rules.newline.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[0].length > 1) {
        this.tokens.push({
          type: 'space'
        });
      }
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      cap = cap[0].replace(/^ {4}/gm, '');
      this.tokens.push({
        type: 'code',
        text: !this.options.pedantic
          ? cap.replace(/\n+$/, '')
          : cap
      });
      continue;
    }

    // fences (gfm)
    if (cap = this.rules.fences.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'code',
        lang: cap[2],
        text: cap[3]
      });
      continue;
    }

    // heading
    if (cap = this.rules.heading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[1].length,
        text: cap[2]
      });
      continue;
    }

    // table no leading pipe (gfm)
    if (top && (cap = this.rules.nptable.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i].split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // lheading
    if (cap = this.rules.lheading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[2] === '=' ? 1 : 2,
        text: cap[1]
      });
      continue;
    }

    // hr
    if (cap = this.rules.hr.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'hr'
      });
      continue;
    }

    // blockquote
    if (cap = this.rules.blockquote.exec(src)) {
      src = src.substring(cap[0].length);

      this.tokens.push({
        type: 'blockquote_start'
      });

      cap = cap[0].replace(/^ *> ?/gm, '');

      // Pass `top` to keep the current
      // "toplevel" state. This is exactly
      // how markdown.pl works.
      this.token(cap, top, true);

      this.tokens.push({
        type: 'blockquote_end'
      });

      continue;
    }

    // list
    if (cap = this.rules.list.exec(src)) {
      src = src.substring(cap[0].length);
      bull = cap[2];

      this.tokens.push({
        type: 'list_start',
        ordered: bull.length > 1
      });

      // Get each top-level item.
      cap = cap[0].match(this.rules.item);

      next = false;
      l = cap.length;
      i = 0;

      for (; i < l; i++) {
        item = cap[i];

        // Remove the list item's bullet
        // so it is seen as the next token.
        space = item.length;
        item = item.replace(/^ *([*+-]|\d+\.) +/, '');

        // Outdent whatever the
        // list item contains. Hacky.
        if (~item.indexOf('\n ')) {
          space -= item.length;
          item = !this.options.pedantic
            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
            : item.replace(/^ {1,4}/gm, '');
        }

        // Determine whether the next list item belongs here.
        // Backpedal if it does not belong in this list.
        if (this.options.smartLists && i !== l - 1) {
          b = block.bullet.exec(cap[i + 1])[0];
          if (bull !== b && !(bull.length > 1 && b.length > 1)) {
            src = cap.slice(i + 1).join('\n') + src;
            i = l - 1;
          }
        }

        // Determine whether item is loose or not.
        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
        // for discount behavior.
        loose = next || /\n\n(?!\s*$)/.test(item);
        if (i !== l - 1) {
          next = item.charAt(item.length - 1) === '\n';
          if (!loose) loose = next;
        }

        this.tokens.push({
          type: loose
            ? 'loose_item_start'
            : 'list_item_start'
        });

        // Recurse.
        this.token(item, false, bq);

        this.tokens.push({
          type: 'list_item_end'
        });
      }

      this.tokens.push({
        type: 'list_end'
      });

      continue;
    }

    // html
    if (cap = this.rules.html.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: this.options.sanitize
          ? 'paragraph'
          : 'html',
        pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',
        text: cap[0]
      });
      continue;
    }

    // def
    if ((!bq && top) && (cap = this.rules.def.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.links[cap[1].toLowerCase()] = {
        href: cap[2],
        title: cap[3]
      };
      continue;
    }

    // table (gfm)
    if (top && (cap = this.rules.table.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i]
          .replace(/^ *\| *| *\| *$/g, '')
          .split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // top-level paragraph
    if (top && (cap = this.rules.paragraph.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'paragraph',
        text: cap[1].charAt(cap[1].length - 1) === '\n'
          ? cap[1].slice(0, -1)
          : cap[1]
      });
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      // Top-level should never reach here.
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'text',
        text: cap[0]
      });
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return this.tokens;
};

/**
 * Inline-Level Grammar
 */

var inline = {
  escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
  autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
  url: noop,
  tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
  link: /^!?\[(inside)\]\(href\)/,
  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
  nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
  strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
  em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
  code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
  br: /^ {2,}\n(?!\s*$)/,
  del: noop,
  text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
};

inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;
inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;

inline.link = replace(inline.link)
  ('inside', inline._inside)
  ('href', inline._href)
  ();

inline.reflink = replace(inline.reflink)
  ('inside', inline._inside)
  ();

/**
 * Normal Inline Grammar
 */

inline.normal = merge({}, inline);

/**
 * Pedantic Inline Grammar
 */

inline.pedantic = merge({}, inline.normal, {
  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
});

/**
 * GFM Inline Grammar
 */

inline.gfm = merge({}, inline.normal, {
  escape: replace(inline.escape)('])', '~|])')(),
  url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
  del: /^~~(?=\S)([\s\S]*?\S)~~/,
  text: replace(inline.text)
    (']|', '~]|')
    ('|', '|https?://|')
    ()
});

/**
 * GFM + Line Breaks Inline Grammar
 */

inline.breaks = merge({}, inline.gfm, {
  br: replace(inline.br)('{2,}', '*')(),
  text: replace(inline.gfm.text)('{2,}', '*')()
});

/**
 * Inline Lexer & Compiler
 */

function InlineLexer(links, options) {
  this.options = options || marked.defaults;
  this.links = links;
  this.rules = inline.normal;
  this.renderer = this.options.renderer || new Renderer;
  this.renderer.options = this.options;

  if (!this.links) {
    throw new
      Error('Tokens array requires a `links` property.');
  }

  if (this.options.gfm) {
    if (this.options.breaks) {
      this.rules = inline.breaks;
    } else {
      this.rules = inline.gfm;
    }
  } else if (this.options.pedantic) {
    this.rules = inline.pedantic;
  }
}

/**
 * Expose Inline Rules
 */

InlineLexer.rules = inline;

/**
 * Static Lexing/Compiling Method
 */

InlineLexer.output = function(src, links, options) {
  var inline = new InlineLexer(links, options);
  return inline.output(src);
};

/**
 * Lexing/Compiling
 */

InlineLexer.prototype.output = function(src) {
  var out = ''
    , link
    , text
    , href
    , cap;

  while (src) {
    // escape
    if (cap = this.rules.escape.exec(src)) {
      src = src.substring(cap[0].length);
      out += cap[1];
      continue;
    }

    // autolink
    if (cap = this.rules.autolink.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[2] === '@') {
        text = cap[1].charAt(6) === ':'
          ? this.mangle(cap[1].substring(7))
          : this.mangle(cap[1]);
        href = this.mangle('mailto:') + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      out += this.renderer.link(href, null, text);
      continue;
    }

    // url (gfm)
    if (!this.inLink && (cap = this.rules.url.exec(src))) {
      src = src.substring(cap[0].length);
      text = escape(cap[1]);
      href = text;
      out += this.renderer.link(href, null, text);
      continue;
    }

    // tag
    if (cap = this.rules.tag.exec(src)) {
      if (!this.inLink && /^<a /i.test(cap[0])) {
        this.inLink = true;
      } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
        this.inLink = false;
      }
      src = src.substring(cap[0].length);
      out += this.options.sanitize
        ? escape(cap[0])
        : cap[0];
      continue;
    }

    // link
    if (cap = this.rules.link.exec(src)) {
      src = src.substring(cap[0].length);
      this.inLink = true;
      out += this.outputLink(cap, {
        href: cap[2],
        title: cap[3]
      });
      this.inLink = false;
      continue;
    }

    // reflink, nolink
    if ((cap = this.rules.reflink.exec(src))
        || (cap = this.rules.nolink.exec(src))) {
      src = src.substring(cap[0].length);
      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = this.links[link.toLowerCase()];
      if (!link || !link.href) {
        out += cap[0].charAt(0);
        src = cap[0].substring(1) + src;
        continue;
      }
      this.inLink = true;
      out += this.outputLink(cap, link);
      this.inLink = false;
      continue;
    }

    // strong
    if (cap = this.rules.strong.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.strong(this.output(cap[2] || cap[1]));
      continue;
    }

    // em
    if (cap = this.rules.em.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.em(this.output(cap[2] || cap[1]));
      continue;
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.codespan(escape(cap[2], true));
      continue;
    }

    // br
    if (cap = this.rules.br.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.br();
      continue;
    }

    // del (gfm)
    if (cap = this.rules.del.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.del(this.output(cap[1]));
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      src = src.substring(cap[0].length);
      out += escape(this.smartypants(cap[0]));
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return out;
};

/**
 * Compile Link
 */

InlineLexer.prototype.outputLink = function(cap, link) {
  var href = escape(link.href)
    , title = link.title ? escape(link.title) : null;

  return cap[0].charAt(0) !== '!'
    ? this.renderer.link(href, title, this.output(cap[1]))
    : this.renderer.image(href, title, escape(cap[1]));
};

/**
 * Smartypants Transformations
 */

InlineLexer.prototype.smartypants = function(text) {
  if (!this.options.smartypants) return text;
  return text
    // em-dashes
    .replace(/--/g, '\u2014')
    // opening singles
    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
    // closing singles & apostrophes
    .replace(/'/g, '\u2019')
    // opening doubles
    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
    // closing doubles
    .replace(/"/g, '\u201d')
    // ellipses
    .replace(/\.{3}/g, '\u2026');
};

/**
 * Mangle Links
 */

InlineLexer.prototype.mangle = function(text) {
  var out = ''
    , l = text.length
    , i = 0
    , ch;

  for (; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = 'x' + ch.toString(16);
    }
    out += '&#' + ch + ';';
  }

  return out;
};

/**
 * Renderer
 */

function Renderer(options) {
  this.options = options || {};
}

Renderer.prototype.code = function(code, lang, escaped) {
  if (this.options.highlight) {
    var out = this.options.highlight(code, lang);
    if (out != null && out !== code) {
      escaped = true;
      code = out;
    }
  }

  if (!lang) {
    return '<pre><code>'
      + (escaped ? code : escape(code, true))
      + '\n</code></pre>';
  }

  return '<pre><code class="'
    + this.options.langPrefix
    + escape(lang, true)
    + '">'
    + (escaped ? code : escape(code, true))
    + '\n</code></pre>\n';
};

Renderer.prototype.blockquote = function(quote) {
  return '<blockquote>\n' + quote + '</blockquote>\n';
};

Renderer.prototype.html = function(html) {
  return html;
};

Renderer.prototype.heading = function(text, level, raw) {
  return '<h'
    + level
    + ' id="'
    + this.options.headerPrefix
    + raw.toLowerCase().replace(/[^\w]+/g, '-')
    + '">'
    + text
    + '</h'
    + level
    + '>\n';
};

Renderer.prototype.hr = function() {
  return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
};

Renderer.prototype.list = function(body, ordered) {
  var type = ordered ? 'ol' : 'ul';
  return '<' + type + '>\n' + body + '</' + type + '>\n';
};

Renderer.prototype.listitem = function(text) {
  return '<li>' + text + '</li>\n';
};

Renderer.prototype.paragraph = function(text) {
  return '<p>' + text + '</p>\n';
};

Renderer.prototype.table = function(header, body) {
  return '<table>\n'
    + '<thead>\n'
    + header
    + '</thead>\n'
    + '<tbody>\n'
    + body
    + '</tbody>\n'
    + '</table>\n';
};

Renderer.prototype.tablerow = function(content) {
  return '<tr>\n' + content + '</tr>\n';
};

Renderer.prototype.tablecell = function(content, flags) {
  var type = flags.header ? 'th' : 'td';
  var tag = flags.align
    ? '<' + type + ' style="text-align:' + flags.align + '">'
    : '<' + type + '>';
  return tag + content + '</' + type + '>\n';
};

// span level renderer
Renderer.prototype.strong = function(text) {
  return '<strong>' + text + '</strong>';
};

Renderer.prototype.em = function(text) {
  return '<em>' + text + '</em>';
};

Renderer.prototype.codespan = function(text) {
  return '<code>' + text + '</code>';
};

Renderer.prototype.br = function() {
  return this.options.xhtml ? '<br/>' : '<br>';
};

Renderer.prototype.del = function(text) {
  return '<del>' + text + '</del>';
};

Renderer.prototype.link = function(href, title, text) {
  if (this.options.sanitize) {
    try {
      var prot = decodeURIComponent(unescape(href))
        .replace(/[^\w:]/g, '')
        .toLowerCase();
    } catch (e) {
      return '';
    }
    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0) {
      return '';
    }
  }
  var out = '<a href="' + href + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += '>' + text + '</a>';
  return out;
};

Renderer.prototype.image = function(href, title, text) {
  var out = '<img src="' + href + '" alt="' + text + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += this.options.xhtml ? '/>' : '>';
  return out;
};

/**
 * Parsing & Compiling
 */

function Parser(options) {
  this.tokens = [];
  this.token = null;
  this.options = options || marked.defaults;
  this.options.renderer = this.options.renderer || new Renderer;
  this.renderer = this.options.renderer;
  this.renderer.options = this.options;
}

/**
 * Static Parse Method
 */

Parser.parse = function(src, options, renderer) {
  var parser = new Parser(options, renderer);
  return parser.parse(src);
};

/**
 * Parse Loop
 */

Parser.prototype.parse = function(src) {
  this.inline = new InlineLexer(src.links, this.options, this.renderer);
  this.tokens = src.reverse();

  var out = '';
  while (this.next()) {
    out += this.tok();
  }

  return out;
};

/**
 * Next Token
 */

Parser.prototype.next = function() {
  return this.token = this.tokens.pop();
};

/**
 * Preview Next Token
 */

Parser.prototype.peek = function() {
  return this.tokens[this.tokens.length - 1] || 0;
};

/**
 * Parse Text Tokens
 */

Parser.prototype.parseText = function() {
  var body = this.token.text;

  while (this.peek().type === 'text') {
    body += '\n' + this.next().text;
  }

  return this.inline.output(body);
};

/**
 * Parse Current Token
 */

Parser.prototype.tok = function() {
  switch (this.token.type) {
    case 'space': {
      return '';
    }
    case 'hr': {
      return this.renderer.hr();
    }
    case 'heading': {
      return this.renderer.heading(
        this.inline.output(this.token.text),
        this.token.depth,
        this.token.text);
    }
    case 'code': {
      return this.renderer.code(this.token.text,
        this.token.lang,
        this.token.escaped);
    }
    case 'table': {
      var header = ''
        , body = ''
        , i
        , row
        , cell
        , flags
        , j;

      // header
      cell = '';
      for (i = 0; i < this.token.header.length; i++) {
        flags = { header: true, align: this.token.align[i] };
        cell += this.renderer.tablecell(
          this.inline.output(this.token.header[i]),
          { header: true, align: this.token.align[i] }
        );
      }
      header += this.renderer.tablerow(cell);

      for (i = 0; i < this.token.cells.length; i++) {
        row = this.token.cells[i];

        cell = '';
        for (j = 0; j < row.length; j++) {
          cell += this.renderer.tablecell(
            this.inline.output(row[j]),
            { header: false, align: this.token.align[j] }
          );
        }

        body += this.renderer.tablerow(cell);
      }
      return this.renderer.table(header, body);
    }
    case 'blockquote_start': {
      var body = '';

      while (this.next().type !== 'blockquote_end') {
        body += this.tok();
      }

      return this.renderer.blockquote(body);
    }
    case 'list_start': {
      var body = ''
        , ordered = this.token.ordered;

      while (this.next().type !== 'list_end') {
        body += this.tok();
      }

      return this.renderer.list(body, ordered);
    }
    case 'list_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.token.type === 'text'
          ? this.parseText()
          : this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'loose_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'html': {
      var html = !this.token.pre && !this.options.pedantic
        ? this.inline.output(this.token.text)
        : this.token.text;
      return this.renderer.html(html);
    }
    case 'paragraph': {
      return this.renderer.paragraph(this.inline.output(this.token.text));
    }
    case 'text': {
      return this.renderer.paragraph(this.parseText());
    }
  }
};

/**
 * Helpers
 */

function escape(html, encode) {
  return html
    .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function unescape(html) {
  return html.replace(/&([#\w]+);/g, function(_, n) {
    n = n.toLowerCase();
    if (n === 'colon') return ':';
    if (n.charAt(0) === '#') {
      return n.charAt(1) === 'x'
        ? String.fromCharCode(parseInt(n.substring(2), 16))
        : String.fromCharCode(+n.substring(1));
    }
    return '';
  });
}

function replace(regex, opt) {
  regex = regex.source;
  opt = opt || '';
  return function self(name, val) {
    if (!name) return new RegExp(regex, opt);
    val = val.source || val;
    val = val.replace(/(^|[^\[])\^/g, '$1');
    regex = regex.replace(name, val);
    return self;
  };
}

function noop() {}
noop.exec = noop;

function merge(obj) {
  var i = 1
    , target
    , key;

  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }

  return obj;
}


/**
 * Marked
 */

function marked(src, opt, callback) {
  if (callback || typeof opt === 'function') {
    if (!callback) {
      callback = opt;
      opt = null;
    }

    opt = merge({}, marked.defaults, opt || {});

    var highlight = opt.highlight
      , tokens
      , pending
      , i = 0;

    try {
      tokens = Lexer.lex(src, opt)
    } catch (e) {
      return callback(e);
    }

    pending = tokens.length;

    var done = function(err) {
      if (err) {
        opt.highlight = highlight;
        return callback(err);
      }

      var out;

      try {
        out = Parser.parse(tokens, opt);
      } catch (e) {
        err = e;
      }

      opt.highlight = highlight;

      return err
        ? callback(err)
        : callback(null, out);
    };

    if (!highlight || highlight.length < 3) {
      return done();
    }

    delete opt.highlight;

    if (!pending) return done();

    for (; i < tokens.length; i++) {
      (function(token) {
        if (token.type !== 'code') {
          return --pending || done();
        }
        return highlight(token.text, token.lang, function(err, code) {
          if (err) return done(err);
          if (code == null || code === token.text) {
            return --pending || done();
          }
          token.text = code;
          token.escaped = true;
          --pending || done();
        });
      })(tokens[i]);
    }

    return;
  }
  try {
    if (opt) opt = merge({}, marked.defaults, opt);
    return Parser.parse(Lexer.lex(src, opt), opt);
  } catch (e) {
    e.message += '\nPlease report this to https://github.com/chjj/marked.';
    if ((opt || marked.defaults).silent) {
      return '<p>An error occured:</p><pre>'
        + escape(e.message + '', true)
        + '</pre>';
    }
    throw e;
  }
}

/**
 * Options
 */

marked.options =
marked.setOptions = function(opt) {
  merge(marked.defaults, opt);
  return marked;
};

marked.defaults = {
  gfm: true,
  tables: true,
  breaks: false,
  pedantic: false,
  sanitize: false,
  smartLists: false,
  silent: false,
  highlight: null,
  langPrefix: 'lang-',
  smartypants: false,
  headerPrefix: '',
  renderer: new Renderer,
  xhtml: false
};

/**
 * Expose
 */

marked.Parser = Parser;
marked.parser = Parser.parse;

marked.Renderer = Renderer;

marked.Lexer = Lexer;
marked.lexer = Lexer.lex;

marked.InlineLexer = InlineLexer;
marked.inlineLexer = InlineLexer.output;

marked.parse = marked;

if (typeof module !== 'undefined' && typeof exports === 'object') {
  module.exports = marked;
} else if (typeof define === 'function' && define.amd) {
  define(function() { return marked; });
} else {
  this.marked = marked;
}

}).call(function() {
  return this || (typeof window !== 'undefined' ? window : global);
}());

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],156:[function(require,module,exports){
//! moment.js
//! version : 2.5.0
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

(function (undefined) {

    /************************************
        Constants
    ************************************/

    var moment,
        VERSION = "2.5.0",
        global = this,
        round = Math.round,
        i,

        YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,

        // internal storage for language config files
        languages = {},

        // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module.exports && typeof require !== 'undefined'),

        // ASP.NET json date format regex
        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,

        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,

        // format tokens
        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,

        // parsing token regexes
        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
        parseTokenOneToFourDigits = /\d{1,4}/, // 0 - 9999
        parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
        parseTokenDigits = /\d+/, // nonzero number of digits
        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
        parseTokenT = /T/i, // T (ISO separator)
        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123

        //strict parsing regexes
        parseTokenOneDigit = /\d/, // 0 - 9
        parseTokenTwoDigits = /\d\d/, // 00 - 99
        parseTokenThreeDigits = /\d{3}/, // 000 - 999
        parseTokenFourDigits = /\d{4}/, // 0000 - 9999
        parseTokenSixDigits = /[+\-]?\d{6}/, // -999,999 - 999,999

        // iso 8601 regex
        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
        isoRegex = /^\s*\d{4}-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,

        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',

        isoDates = [
            'YYYY-MM-DD',
            'GGGG-[W]WW',
            'GGGG-[W]WW-E',
            'YYYY-DDD'
        ],

        // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d{1,3}/],
            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
            ['HH:mm', /(T| )\d\d:\d\d/],
            ['HH', /(T| )\d\d/]
        ],

        // timezone chunker "+10:00" > ["10", "00"] or "-1530" > ["-15", "30"]
        parseTimezoneChunker = /([\+\-]|\d\d)/gi,

        // getter and setter names
        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
        unitMillisecondFactors = {
            'Milliseconds' : 1,
            'Seconds' : 1e3,
            'Minutes' : 6e4,
            'Hours' : 36e5,
            'Days' : 864e5,
            'Months' : 2592e6,
            'Years' : 31536e6
        },

        unitAliases = {
            ms : 'millisecond',
            s : 'second',
            m : 'minute',
            h : 'hour',
            d : 'day',
            D : 'date',
            w : 'week',
            W : 'isoWeek',
            M : 'month',
            y : 'year',
            DDD : 'dayOfYear',
            e : 'weekday',
            E : 'isoWeekday',
            gg: 'weekYear',
            GG: 'isoWeekYear'
        },

        camelFunctions = {
            dayofyear : 'dayOfYear',
            isoweekday : 'isoWeekday',
            isoweek : 'isoWeek',
            weekyear : 'weekYear',
            isoweekyear : 'isoWeekYear'
        },

        // format function strings
        formatFunctions = {},

        // tokens to ordinalize and pad
        ordinalizeTokens = 'DDD w W M D d'.split(' '),
        paddedTokens = 'M D H h m s w W'.split(' '),

        formatTokenFunctions = {
            M    : function () {
                return this.month() + 1;
            },
            MMM  : function (format) {
                return this.lang().monthsShort(this, format);
            },
            MMMM : function (format) {
                return this.lang().months(this, format);
            },
            D    : function () {
                return this.date();
            },
            DDD  : function () {
                return this.dayOfYear();
            },
            d    : function () {
                return this.day();
            },
            dd   : function (format) {
                return this.lang().weekdaysMin(this, format);
            },
            ddd  : function (format) {
                return this.lang().weekdaysShort(this, format);
            },
            dddd : function (format) {
                return this.lang().weekdays(this, format);
            },
            w    : function () {
                return this.week();
            },
            W    : function () {
                return this.isoWeek();
            },
            YY   : function () {
                return leftZeroFill(this.year() % 100, 2);
            },
            YYYY : function () {
                return leftZeroFill(this.year(), 4);
            },
            YYYYY : function () {
                return leftZeroFill(this.year(), 5);
            },
            YYYYYY : function () {
                var y = this.year(), sign = y >= 0 ? '+' : '-';
                return sign + leftZeroFill(Math.abs(y), 6);
            },
            gg   : function () {
                return leftZeroFill(this.weekYear() % 100, 2);
            },
            gggg : function () {
                return this.weekYear();
            },
            ggggg : function () {
                return leftZeroFill(this.weekYear(), 5);
            },
            GG   : function () {
                return leftZeroFill(this.isoWeekYear() % 100, 2);
            },
            GGGG : function () {
                return this.isoWeekYear();
            },
            GGGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 5);
            },
            e : function () {
                return this.weekday();
            },
            E : function () {
                return this.isoWeekday();
            },
            a    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), true);
            },
            A    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), false);
            },
            H    : function () {
                return this.hours();
            },
            h    : function () {
                return this.hours() % 12 || 12;
            },
            m    : function () {
                return this.minutes();
            },
            s    : function () {
                return this.seconds();
            },
            S    : function () {
                return toInt(this.milliseconds() / 100);
            },
            SS   : function () {
                return leftZeroFill(toInt(this.milliseconds() / 10), 2);
            },
            SSS  : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            SSSS : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            Z    : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(toInt(a / 60), 2) + ":" + leftZeroFill(toInt(a) % 60, 2);
            },
            ZZ   : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
            },
            z : function () {
                return this.zoneAbbr();
            },
            zz : function () {
                return this.zoneName();
            },
            X    : function () {
                return this.unix();
            },
            Q : function () {
                return this.quarter();
            }
        },

        lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];

    function padToken(func, count) {
        return function (a) {
            return leftZeroFill(func.call(this, a), count);
        };
    }
    function ordinalizeToken(func, period) {
        return function (a) {
            return this.lang().ordinal(func.call(this, a), period);
        };
    }

    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    }
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);


    /************************************
        Constructors
    ************************************/

    function Language() {

    }

    // Moment prototype object
    function Moment(config) {
        checkOverflow(config);
        extend(this, config);
    }

    // Duration Constructor
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            years * 12;

        this._data = {};

        this._bubble();
    }

    /************************************
        Helpers
    ************************************/


    function extend(a, b) {
        for (var i in b) {
            if (b.hasOwnProperty(i)) {
                a[i] = b[i];
            }
        }

        if (b.hasOwnProperty("toString")) {
            a.toString = b.toString;
        }

        if (b.hasOwnProperty("valueOf")) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    // left zero fill a number
    // see http://jsperf.com/left-zero-filling for performance comparison
    function leftZeroFill(number, targetLength, forceSign) {
        var output = Math.abs(number) + '',
            sign = number >= 0;

        while (output.length < targetLength) {
            output = '0' + output;
        }
        return (sign ? (forceSign ? '+' : '') : '-') + output;
    }

    // helper function for _.addTime and _.subtractTime
    function addOrSubtractDurationFromMoment(mom, duration, isAdding, ignoreUpdateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months,
            minutes,
            hours;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        // store the minutes and hours so we can restore them
        if (days || months) {
            minutes = mom.minute();
            hours = mom.hour();
        }
        if (days) {
            mom.date(mom.date() + days * isAdding);
        }
        if (months) {
            mom.month(mom.month() + months * isAdding);
        }
        if (milliseconds && !ignoreUpdateOffset) {
            moment.updateOffset(mom);
        }
        // restore the minutes and hours after possibly changing dst
        if (days || months) {
            mom.minute(minutes);
            mom.hour(hours);
        }
    }

    // check if is an array
    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return  Object.prototype.toString.call(input) === '[object Date]' ||
                input instanceof Date;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function normalizeUnits(units) {
        if (units) {
            var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
            units = unitAliases[units] || camelFunctions[lowered] || lowered;
        }
        return units;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (inputObject.hasOwnProperty(prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeList(field) {
        var count, setter;

        if (field.indexOf('week') === 0) {
            count = 7;
            setter = 'day';
        }
        else if (field.indexOf('month') === 0) {
            count = 12;
            setter = 'month';
        }
        else {
            return;
        }

        moment[field] = function (format, index) {
            var i, getter,
                method = moment.fn._lang[field],
                results = [];

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            getter = function (i) {
                var m = moment().utc().set(setter, i);
                return method.call(moment.fn._lang, m, format || '');
            };

            if (index != null) {
                return getter(index);
            }
            else {
                for (i = 0; i < count; i++) {
                    results.push(getter(i));
                }
                return results;
            }
        };
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            if (coercedNumber >= 0) {
                value = Math.floor(coercedNumber);
            } else {
                value = Math.ceil(coercedNumber);
            }
        }

        return value;
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    function checkOverflow(m) {
        var overflow;
        if (m._a && m._pf.overflow === -2) {
            overflow =
                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
                m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
                m._a[HOUR] < 0 || m._a[HOUR] > 23 ? HOUR :
                m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
                m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            m._pf.overflow = overflow;
        }
    }

    function initializeParsingFlags(config) {
        config._pf = {
            empty : false,
            unusedTokens : [],
            unusedInput : [],
            overflow : -2,
            charsLeftOver : 0,
            nullInput : false,
            invalidMonth : null,
            invalidFormat : false,
            userInvalidated : false,
            iso: false
        };
    }

    function isValid(m) {
        if (m._isValid == null) {
            m._isValid = !isNaN(m._d.getTime()) &&
                m._pf.overflow < 0 &&
                !m._pf.empty &&
                !m._pf.invalidMonth &&
                !m._pf.nullInput &&
                !m._pf.invalidFormat &&
                !m._pf.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    m._pf.charsLeftOver === 0 &&
                    m._pf.unusedTokens.length === 0;
            }
        }
        return m._isValid;
    }

    function normalizeLanguage(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function makeAs(input, model) {
        return model._isUTC ? moment(input).zone(model._offset || 0) :
            moment(input).local();
    }

    /************************************
        Languages
    ************************************/


    extend(Language.prototype, {

        set : function (config) {
            var prop, i;
            for (i in config) {
                prop = config[i];
                if (typeof prop === 'function') {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
        },

        _months : "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        months : function (m) {
            return this._months[m.month()];
        },

        _monthsShort : "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        monthsShort : function (m) {
            return this._monthsShort[m.month()];
        },

        monthsParse : function (monthName) {
            var i, mom, regex;

            if (!this._monthsParse) {
                this._monthsParse = [];
            }

            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                if (!this._monthsParse[i]) {
                    mom = moment.utc([2000, i]);
                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        },

        _weekdays : "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdays : function (m) {
            return this._weekdays[m.day()];
        },

        _weekdaysShort : "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysShort : function (m) {
            return this._weekdaysShort[m.day()];
        },

        _weekdaysMin : "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        weekdaysMin : function (m) {
            return this._weekdaysMin[m.day()];
        },

        weekdaysParse : function (weekdayName) {
            var i, mom, regex;

            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
            }

            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already
                if (!this._weekdaysParse[i]) {
                    mom = moment([2000, 1]).day(i);
                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        },

        _longDateFormat : {
            LT : "h:mm A",
            L : "MM/DD/YYYY",
            LL : "MMMM D YYYY",
            LLL : "MMMM D YYYY LT",
            LLLL : "dddd, MMMM D YYYY LT"
        },
        longDateFormat : function (key) {
            var output = this._longDateFormat[key];
            if (!output && this._longDateFormat[key.toUpperCase()]) {
                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
                    return val.slice(1);
                });
                this._longDateFormat[key] = output;
            }
            return output;
        },

        isPM : function (input) {
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
            // Using charAt should be more compatible.
            return ((input + '').toLowerCase().charAt(0) === 'p');
        },

        _meridiemParse : /[ap]\.?m?\.?/i,
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        },

        _calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        calendar : function (key, mom) {
            var output = this._calendar[key];
            return typeof output === 'function' ? output.apply(mom) : output;
        },

        _relativeTime : {
            future : "in %s",
            past : "%s ago",
            s : "a few seconds",
            m : "a minute",
            mm : "%d minutes",
            h : "an hour",
            hh : "%d hours",
            d : "a day",
            dd : "%d days",
            M : "a month",
            MM : "%d months",
            y : "a year",
            yy : "%d years"
        },
        relativeTime : function (number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return (typeof output === 'function') ?
                output(number, withoutSuffix, string, isFuture) :
                output.replace(/%d/i, number);
        },
        pastFuture : function (diff, output) {
            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
        },

        ordinal : function (number) {
            return this._ordinal.replace("%d", number);
        },
        _ordinal : "%d",

        preparse : function (string) {
            return string;
        },

        postformat : function (string) {
            return string;
        },

        week : function (mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        },

        _week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        },

        _invalidDate: 'Invalid date',
        invalidDate: function () {
            return this._invalidDate;
        }
    });

    // Loads a language definition into the `languages` cache.  The function
    // takes a key and optionally values.  If not in the browser and no values
    // are provided, it will load the language file module.  As a convenience,
    // this function also returns the language values.
    function loadLang(key, values) {
        values.abbr = key;
        if (!languages[key]) {
            languages[key] = new Language();
        }
        languages[key].set(values);
        return languages[key];
    }

    // Remove a language from the `languages` cache. Mostly useful in tests.
    function unloadLang(key) {
        delete languages[key];
    }

    // Determines which language definition to use and returns it.
    //
    // With no parameters, it will return the global language.  If you
    // pass in a language key, such as 'en', it will return the
    // definition for 'en', so long as 'en' has already been loaded using
    // moment.lang.
    function getLangDefinition(key) {
        var i = 0, j, lang, next, split,
            get = function (k) {
                if (!languages[k] && hasModule) {
                    try {
                        require('./lang/' + k);
                    } catch (e) { }
                }
                return languages[k];
            };

        if (!key) {
            return moment.fn._lang;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            lang = get(key);
            if (lang) {
                return lang;
            }
            key = [key];
        }

        //pick the language from the array
        //try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
        //substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
        while (i < key.length) {
            split = normalizeLanguage(key[i]).split('-');
            j = split.length;
            next = normalizeLanguage(key[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                lang = get(split.slice(0, j).join('-'));
                if (lang) {
                    return lang;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return moment.fn._lang;
    }

    /************************************
        Formatting
    ************************************/


    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = "";
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {

        if (!m.isValid()) {
            return m.lang().invalidDate();
        }

        format = expandFormat(format, m.lang());

        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }

        return formatFunctions[format](m);
    }

    function expandFormat(format, lang) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return lang.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }


    /************************************
        Parsing
    ************************************/


    // get the regex to find the next token
    function getParseRegexForToken(token, config) {
        var a, strict = config._strict;
        switch (token) {
        case 'DDDD':
            return parseTokenThreeDigits;
        case 'YYYY':
        case 'GGGG':
        case 'gggg':
            return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
        case 'YYYYYY':
        case 'YYYYY':
        case 'GGGGG':
        case 'ggggg':
            return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
        case 'S':
            if (strict) { return parseTokenOneDigit; }
            /* falls through */
        case 'SS':
            if (strict) { return parseTokenTwoDigits; }
            /* falls through */
        case 'SSS':
        case 'DDD':
            return strict ? parseTokenThreeDigits : parseTokenOneToThreeDigits;
        case 'MMM':
        case 'MMMM':
        case 'dd':
        case 'ddd':
        case 'dddd':
            return parseTokenWord;
        case 'a':
        case 'A':
            return getLangDefinition(config._l)._meridiemParse;
        case 'X':
            return parseTokenTimestampMs;
        case 'Z':
        case 'ZZ':
            return parseTokenTimezone;
        case 'T':
            return parseTokenT;
        case 'SSSS':
            return parseTokenDigits;
        case 'MM':
        case 'DD':
        case 'YY':
        case 'GG':
        case 'gg':
        case 'HH':
        case 'hh':
        case 'mm':
        case 'ss':
        case 'ww':
        case 'WW':
            return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
        case 'M':
        case 'D':
        case 'd':
        case 'H':
        case 'h':
        case 'm':
        case 's':
        case 'w':
        case 'W':
        case 'e':
        case 'E':
            return strict ? parseTokenOneDigit : parseTokenOneOrTwoDigits;
        default :
            a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), "i"));
            return a;
        }
    }

    function timezoneMinutesFromString(string) {
        string = string || "";
        var possibleTzMatches = (string.match(parseTokenTimezone) || []),
            tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
            parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
            minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? -minutes : minutes;
    }

    // function to convert string input to date
    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;

        switch (token) {
        // MONTH
        case 'M' : // fall through to MM
        case 'MM' :
            if (input != null) {
                datePartArray[MONTH] = toInt(input) - 1;
            }
            break;
        case 'MMM' : // fall through to MMMM
        case 'MMMM' :
            a = getLangDefinition(config._l).monthsParse(input);
            // if we didn't find a month name, mark the date as invalid.
            if (a != null) {
                datePartArray[MONTH] = a;
            } else {
                config._pf.invalidMonth = input;
            }
            break;
        // DAY OF MONTH
        case 'D' : // fall through to DD
        case 'DD' :
            if (input != null) {
                datePartArray[DATE] = toInt(input);
            }
            break;
        // DAY OF YEAR
        case 'DDD' : // fall through to DDDD
        case 'DDDD' :
            if (input != null) {
                config._dayOfYear = toInt(input);
            }

            break;
        // YEAR
        case 'YY' :
            datePartArray[YEAR] = toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
            break;
        case 'YYYY' :
        case 'YYYYY' :
        case 'YYYYYY' :
            datePartArray[YEAR] = toInt(input);
            break;
        // AM / PM
        case 'a' : // fall through to A
        case 'A' :
            config._isPm = getLangDefinition(config._l).isPM(input);
            break;
        // 24 HOUR
        case 'H' : // fall through to hh
        case 'HH' : // fall through to hh
        case 'h' : // fall through to hh
        case 'hh' :
            datePartArray[HOUR] = toInt(input);
            break;
        // MINUTE
        case 'm' : // fall through to mm
        case 'mm' :
            datePartArray[MINUTE] = toInt(input);
            break;
        // SECOND
        case 's' : // fall through to ss
        case 'ss' :
            datePartArray[SECOND] = toInt(input);
            break;
        // MILLISECOND
        case 'S' :
        case 'SS' :
        case 'SSS' :
        case 'SSSS' :
            datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
            break;
        // UNIX TIMESTAMP WITH MS
        case 'X':
            config._d = new Date(parseFloat(input) * 1000);
            break;
        // TIMEZONE
        case 'Z' : // fall through to ZZ
        case 'ZZ' :
            config._useUTC = true;
            config._tzm = timezoneMinutesFromString(input);
            break;
        case 'w':
        case 'ww':
        case 'W':
        case 'WW':
        case 'd':
        case 'dd':
        case 'ddd':
        case 'dddd':
        case 'e':
        case 'E':
            token = token.substr(0, 1);
            /* falls through */
        case 'gg':
        case 'gggg':
        case 'GG':
        case 'GGGG':
        case 'GGGGG':
            token = token.substr(0, 2);
            if (input) {
                config._w = config._w || {};
                config._w[token] = input;
            }
            break;
        }
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function dateFromConfig(config) {
        var i, date, input = [], currentDate,
            yearToUse, fixYear, w, temp, lang, weekday, week;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            fixYear = function (val) {
                var int_val = parseInt(val, 10);
                return val ?
                  (val.length < 3 ? (int_val > 68 ? 1900 + int_val : 2000 + int_val) : int_val) :
                  (config._a[YEAR] == null ? moment().weekYear() : config._a[YEAR]);
            };

            w = config._w;
            if (w.GG != null || w.W != null || w.E != null) {
                temp = dayOfYearFromWeeks(fixYear(w.GG), w.W || 1, w.E, 4, 1);
            }
            else {
                lang = getLangDefinition(config._l);
                weekday = w.d != null ?  parseWeekday(w.d, lang) :
                  (w.e != null ?  parseInt(w.e, 10) + lang._week.dow : 0);

                week = parseInt(w.w, 10) || 1;

                //if we're parsing 'd', then the low day numbers may be next week
                if (w.d != null && weekday < lang._week.dow) {
                    week++;
                }

                temp = dayOfYearFromWeeks(fixYear(w.gg), week, weekday, lang._week.doy, lang._week.dow);
            }

            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = config._a[YEAR] == null ? currentDate[YEAR] : config._a[YEAR];

            if (config._dayOfYear > daysInYear(yearToUse)) {
                config._pf._overflowDayOfYear = true;
            }

            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // add the offsets to the time to be parsed so that we can have a clean array for checking isValid
        input[HOUR] += toInt((config._tzm || 0) / 60);
        input[MINUTE] += toInt((config._tzm || 0) % 60);

        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
    }

    function dateFromObject(config) {
        var normalizedInput;

        if (config._d) {
            return;
        }

        normalizedInput = normalizeObjectUnits(config._i);
        config._a = [
            normalizedInput.year,
            normalizedInput.month,
            normalizedInput.day,
            normalizedInput.hour,
            normalizedInput.minute,
            normalizedInput.second,
            normalizedInput.millisecond
        ];

        dateFromConfig(config);
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [
                now.getUTCFullYear(),
                now.getUTCMonth(),
                now.getUTCDate()
            ];
        } else {
            return [now.getFullYear(), now.getMonth(), now.getDate()];
        }
    }

    // date from string and format string
    function makeDateFromStringAndFormat(config) {

        config._a = [];
        config._pf.empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var lang = getLangDefinition(config._l),
            string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, lang).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    config._pf.unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    config._pf.empty = false;
                }
                else {
                    config._pf.unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                config._pf.unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            config._pf.unusedInput.push(string);
        }

        // handle am pm
        if (config._isPm && config._a[HOUR] < 12) {
            config._a[HOUR] += 12;
        }
        // if is 12 am, change hours to 0
        if (config._isPm === false && config._a[HOUR] === 12) {
            config._a[HOUR] = 0;
        }

        dateFromConfig(config);
        checkOverflow(config);
    }

    function unescapeFormat(s) {
        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        });
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function regexpEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    // date from string and array of format strings
    function makeDateFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            config._pf.invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = extend({}, config);
            initializeParsingFlags(tempConfig);
            tempConfig._f = config._f[i];
            makeDateFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += tempConfig._pf.charsLeftOver;

            //or tokens
            currentScore += tempConfig._pf.unusedTokens.length * 10;

            tempConfig._pf.score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    // date from iso format
    function makeDateFromString(config) {
        var i,
            string = config._i,
            match = isoRegex.exec(string);

        if (match) {
            config._pf.iso = true;
            for (i = 4; i > 0; i--) {
                if (match[i]) {
                    // match[5] should be "T" or undefined
                    config._f = isoDates[i - 1] + (match[6] || " ");
                    break;
                }
            }
            for (i = 0; i < 4; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (string.match(parseTokenTimezone)) {
                config._f += "Z";
            }
            makeDateFromStringAndFormat(config);
        }
        else {
            config._d = new Date(string);
        }
    }

    function makeDateFromInput(config) {
        var input = config._i,
            matched = aspNetJsonRegex.exec(input);

        if (input === undefined) {
            config._d = new Date();
        } else if (matched) {
            config._d = new Date(+matched[1]);
        } else if (typeof input === 'string') {
            makeDateFromString(config);
        } else if (isArray(input)) {
            config._a = input.slice(0);
            dateFromConfig(config);
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if (typeof(input) === 'object') {
            dateFromObject(config);
        } else {
            config._d = new Date(input);
        }
    }

    function makeDate(y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function makeUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    function parseWeekday(input, language) {
        if (typeof input === 'string') {
            if (!isNaN(input)) {
                input = parseInt(input, 10);
            }
            else {
                input = language.weekdaysParse(input);
                if (typeof input !== 'number') {
                    return null;
                }
            }
        }
        return input;
    }

    /************************************
        Relative Time
    ************************************/


    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {
        return lang.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime(milliseconds, withoutSuffix, lang) {
        var seconds = round(Math.abs(milliseconds) / 1000),
            minutes = round(seconds / 60),
            hours = round(minutes / 60),
            days = round(hours / 24),
            years = round(days / 365),
            args = seconds < 45 && ['s', seconds] ||
                minutes === 1 && ['m'] ||
                minutes < 45 && ['mm', minutes] ||
                hours === 1 && ['h'] ||
                hours < 22 && ['hh', hours] ||
                days === 1 && ['d'] ||
                days <= 25 && ['dd', days] ||
                days <= 45 && ['M'] ||
                days < 345 && ['MM', round(days / 30)] ||
                years === 1 && ['y'] || ['yy', years];
        args[2] = withoutSuffix;
        args[3] = milliseconds > 0;
        args[4] = lang;
        return substituteTimeAgo.apply({}, args);
    }


    /************************************
        Week of Year
    ************************************/


    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = moment(mom).add('d', daysToDayOfWeek);
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        // The only solid way to create an iso date from year is to use
        // a string format (Date.UTC handles only years > 1900). Don't ask why
        // it doesn't need Z at the end.
        var d = new Date(leftZeroFill(year, 6, true) + '-01-01').getUTCDay(),
            daysToAdd, dayOfYear;

        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;

        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    /************************************
        Top Level Functions
    ************************************/

    function makeMoment(config) {
        var input = config._i,
            format = config._f;

        if (typeof config._pf === 'undefined') {
            initializeParsingFlags(config);
        }

        if (input === null) {
            return moment.invalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = getLangDefinition().preparse(input);
        }

        if (moment.isMoment(input)) {
            config = extend({}, input);

            config._d = new Date(+input._d);
        } else if (format) {
            if (isArray(format)) {
                makeDateFromStringAndArray(config);
            } else {
                makeDateFromStringAndFormat(config);
            }
        } else {
            makeDateFromInput(config);
        }

        return new Moment(config);
    }

    moment = function (input, format, lang, strict) {
        if (typeof(lang) === "boolean") {
            strict = lang;
            lang = undefined;
        }
        return makeMoment({
            _i : input,
            _f : format,
            _l : lang,
            _strict : strict,
            _isUTC : false
        });
    };

    // creating with utc
    moment.utc = function (input, format, lang, strict) {
        var m;

        if (typeof(lang) === "boolean") {
            strict = lang;
            lang = undefined;
        }
        m = makeMoment({
            _useUTC : true,
            _isUTC : true,
            _l : lang,
            _i : input,
            _f : format,
            _strict : strict
        }).utc();

        return m;
    };

    // creating with unix timestamp (in seconds)
    moment.unix = function (input) {
        return moment(input * 1000);
    };

    // duration
    moment.duration = function (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            parseIso;

        if (moment.isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
            sign = (match[1] === "-") ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoDurationRegex.exec(input))) {
            sign = (match[1] === "-") ? -1 : 1;
            parseIso = function (inp) {
                // We'd normally use ~~inp for this, but unfortunately it also
                // converts floats to ints.
                // inp may be undefined, so careful calling replace on it.
                var res = inp && parseFloat(inp.replace(',', '.'));
                // apply sign while we're at it
                return (isNaN(res) ? 0 : res) * sign;
            };
            duration = {
                y: parseIso(match[2]),
                M: parseIso(match[3]),
                d: parseIso(match[4]),
                h: parseIso(match[5]),
                m: parseIso(match[6]),
                s: parseIso(match[7]),
                w: parseIso(match[8])
            };
        }

        ret = new Duration(duration);

        if (moment.isDuration(input) && input.hasOwnProperty('_lang')) {
            ret._lang = input._lang;
        }

        return ret;
    };

    // version number
    moment.version = VERSION;

    // default format
    moment.defaultFormat = isoFormat;

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    moment.updateOffset = function () {};

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    moment.lang = function (key, values) {
        var r;
        if (!key) {
            return moment.fn._lang._abbr;
        }
        if (values) {
            loadLang(normalizeLanguage(key), values);
        } else if (values === null) {
            unloadLang(key);
            key = 'en';
        } else if (!languages[key]) {
            getLangDefinition(key);
        }
        r = moment.duration.fn._lang = moment.fn._lang = getLangDefinition(key);
        return r._abbr;
    };

    // returns language data
    moment.langData = function (key) {
        if (key && key._lang && key._lang._abbr) {
            key = key._lang._abbr;
        }
        return getLangDefinition(key);
    };

    // compare moment object
    moment.isMoment = function (obj) {
        return obj instanceof Moment;
    };

    // for typechecking Duration objects
    moment.isDuration = function (obj) {
        return obj instanceof Duration;
    };

    for (i = lists.length - 1; i >= 0; --i) {
        makeList(lists[i]);
    }

    moment.normalizeUnits = function (units) {
        return normalizeUnits(units);
    };

    moment.invalid = function (flags) {
        var m = moment.utc(NaN);
        if (flags != null) {
            extend(m._pf, flags);
        }
        else {
            m._pf.userInvalidated = true;
        }

        return m;
    };

    moment.parseZone = function (input) {
        return moment(input).parseZone();
    };

    /************************************
        Moment Prototype
    ************************************/


    extend(moment.fn = Moment.prototype, {

        clone : function () {
            return moment(this);
        },

        valueOf : function () {
            return +this._d + ((this._offset || 0) * 60000);
        },

        unix : function () {
            return Math.floor(+this / 1000);
        },

        toString : function () {
            return this.clone().lang('en').format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        },

        toDate : function () {
            return this._offset ? new Date(+this) : this._d;
        },

        toISOString : function () {
            var m = moment(this).utc();
            if (0 < m.year() && m.year() <= 9999) {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            } else {
                return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        },

        toArray : function () {
            var m = this;
            return [
                m.year(),
                m.month(),
                m.date(),
                m.hours(),
                m.minutes(),
                m.seconds(),
                m.milliseconds()
            ];
        },

        isValid : function () {
            return isValid(this);
        },

        isDSTShifted : function () {

            if (this._a) {
                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
            }

            return false;
        },

        parsingFlags : function () {
            return extend({}, this._pf);
        },

        invalidAt: function () {
            return this._pf.overflow;
        },

        utc : function () {
            return this.zone(0);
        },

        local : function () {
            this.zone(0);
            this._isUTC = false;
            return this;
        },

        format : function (inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat);
            return this.lang().postformat(output);
        },

        add : function (input, val) {
            var dur;
            // switch args to support add('s', 1) and add(1, 's')
            if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, 1);
            return this;
        },

        subtract : function (input, val) {
            var dur;
            // switch args to support subtract('s', 1) and subtract(1, 's')
            if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, -1);
            return this;
        },

        diff : function (input, units, asFloat) {
            var that = makeAs(input, this),
                zoneDiff = (this.zone() - that.zone()) * 6e4,
                diff, output;

            units = normalizeUnits(units);

            if (units === 'year' || units === 'month') {
                // average number of days in the months in the given dates
                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2
                // difference in months
                output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
                // adjust by taking difference in days, average number of days
                // and dst in the given months.
                output += ((this - moment(this).startOf('month')) -
                        (that - moment(that).startOf('month'))) / diff;
                // same as above but with zones, to negate all dst
                output -= ((this.zone() - moment(this).startOf('month').zone()) -
                        (that.zone() - moment(that).startOf('month').zone())) * 6e4 / diff;
                if (units === 'year') {
                    output = output / 12;
                }
            } else {
                diff = (this - that);
                output = units === 'second' ? diff / 1e3 : // 1000
                    units === 'minute' ? diff / 6e4 : // 1000 * 60
                    units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
                    units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                    units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                    diff;
            }
            return asFloat ? output : absRound(output);
        },

        from : function (time, withoutSuffix) {
            return moment.duration(this.diff(time)).lang(this.lang()._abbr).humanize(!withoutSuffix);
        },

        fromNow : function (withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },

        calendar : function () {
            // We want to compare the start of today, vs this.
            // Getting start-of-today depends on whether we're zone'd or not.
            var sod = makeAs(moment(), this).startOf('day'),
                diff = this.diff(sod, 'days', true),
                format = diff < -6 ? 'sameElse' :
                    diff < -1 ? 'lastWeek' :
                    diff < 0 ? 'lastDay' :
                    diff < 1 ? 'sameDay' :
                    diff < 2 ? 'nextDay' :
                    diff < 7 ? 'nextWeek' : 'sameElse';
            return this.format(this.lang().calendar(format, this));
        },

        isLeapYear : function () {
            return isLeapYear(this.year());
        },

        isDST : function () {
            return (this.zone() < this.clone().month(0).zone() ||
                this.zone() < this.clone().month(5).zone());
        },

        day : function (input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.lang());
                return this.add({ d : input - day });
            } else {
                return day;
            }
        },

        month : function (input) {
            var utc = this._isUTC ? 'UTC' : '',
                dayOfMonth;

            if (input != null) {
                if (typeof input === 'string') {
                    input = this.lang().monthsParse(input);
                    if (typeof input !== 'number') {
                        return this;
                    }
                }

                dayOfMonth = this.date();
                this.date(1);
                this._d['set' + utc + 'Month'](input);
                this.date(Math.min(dayOfMonth, this.daysInMonth()));

                moment.updateOffset(this);
                return this;
            } else {
                return this._d['get' + utc + 'Month']();
            }
        },

        startOf: function (units) {
            units = normalizeUnits(units);
            // the following switch intentionally omits break keywords
            // to utilize falling through the cases.
            switch (units) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'month':
                this.date(1);
                /* falls through */
            case 'week':
            case 'isoWeek':
            case 'day':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
                /* falls through */
            }

            // weeks are a special case
            if (units === 'week') {
                this.weekday(0);
            } else if (units === 'isoWeek') {
                this.isoWeekday(1);
            }

            return this;
        },

        endOf: function (units) {
            units = normalizeUnits(units);
            return this.startOf(units).add((units === 'isoWeek' ? 'week' : units), 1).subtract('ms', 1);
        },

        isAfter: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) > +moment(input).startOf(units);
        },

        isBefore: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) < +moment(input).startOf(units);
        },

        isSame: function (input, units) {
            units = units || 'ms';
            return +this.clone().startOf(units) === +makeAs(input, this).startOf(units);
        },

        min: function (other) {
            other = moment.apply(null, arguments);
            return other < this ? this : other;
        },

        max: function (other) {
            other = moment.apply(null, arguments);
            return other > this ? this : other;
        },

        zone : function (input) {
            var offset = this._offset || 0;
            if (input != null) {
                if (typeof input === "string") {
                    input = timezoneMinutesFromString(input);
                }
                if (Math.abs(input) < 16) {
                    input = input * 60;
                }
                this._offset = input;
                this._isUTC = true;
                if (offset !== input) {
                    addOrSubtractDurationFromMoment(this, moment.duration(offset - input, 'm'), 1, true);
                }
            } else {
                return this._isUTC ? offset : this._d.getTimezoneOffset();
            }
            return this;
        },

        zoneAbbr : function () {
            return this._isUTC ? "UTC" : "";
        },

        zoneName : function () {
            return this._isUTC ? "Coordinated Universal Time" : "";
        },

        parseZone : function () {
            if (this._tzm) {
                this.zone(this._tzm);
            } else if (typeof this._i === 'string') {
                this.zone(this._i);
            }
            return this;
        },

        hasAlignedHourOffset : function (input) {
            if (!input) {
                input = 0;
            }
            else {
                input = moment(input).zone();
            }

            return (this.zone() - input) % 60 === 0;
        },

        daysInMonth : function () {
            return daysInMonth(this.year(), this.month());
        },

        dayOfYear : function (input) {
            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
            return input == null ? dayOfYear : this.add("d", (input - dayOfYear));
        },

        quarter : function () {
            return Math.ceil((this.month() + 1.0) / 3.0);
        },

        weekYear : function (input) {
            var year = weekOfYear(this, this.lang()._week.dow, this.lang()._week.doy).year;
            return input == null ? year : this.add("y", (input - year));
        },

        isoWeekYear : function (input) {
            var year = weekOfYear(this, 1, 4).year;
            return input == null ? year : this.add("y", (input - year));
        },

        week : function (input) {
            var week = this.lang().week(this);
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        isoWeek : function (input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        weekday : function (input) {
            var weekday = (this.day() + 7 - this.lang()._week.dow) % 7;
            return input == null ? weekday : this.add("d", input - weekday);
        },

        isoWeekday : function (input) {
            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.
            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units]();
        },

        set : function (units, value) {
            units = normalizeUnits(units);
            if (typeof this[units] === 'function') {
                this[units](value);
            }
            return this;
        },

        // If passed a language key, it will set the language for this
        // instance.  Otherwise, it will return the language configuration
        // variables for this instance.
        lang : function (key) {
            if (key === undefined) {
                return this._lang;
            } else {
                this._lang = getLangDefinition(key);
                return this;
            }
        }
    });

    // helper for adding shortcuts
    function makeGetterAndSetter(name, key) {
        moment.fn[name] = moment.fn[name + 's'] = function (input) {
            var utc = this._isUTC ? 'UTC' : '';
            if (input != null) {
                this._d['set' + utc + key](input);
                moment.updateOffset(this);
                return this;
            } else {
                return this._d['get' + utc + key]();
            }
        };
    }

    // loop through and add shortcuts (Month, Date, Hours, Minutes, Seconds, Milliseconds)
    for (i = 0; i < proxyGettersAndSetters.length; i ++) {
        makeGetterAndSetter(proxyGettersAndSetters[i].toLowerCase().replace(/s$/, ''), proxyGettersAndSetters[i]);
    }

    // add shortcut for year (uses different syntax than the getter/setter 'year' == 'FullYear')
    makeGetterAndSetter('year', 'FullYear');

    // add plural methods
    moment.fn.days = moment.fn.day;
    moment.fn.months = moment.fn.month;
    moment.fn.weeks = moment.fn.week;
    moment.fn.isoWeeks = moment.fn.isoWeek;

    // add aliased format methods
    moment.fn.toJSON = moment.fn.toISOString;

    /************************************
        Duration Prototype
    ************************************/


    extend(moment.duration.fn = Duration.prototype, {

        _bubble : function () {
            var milliseconds = this._milliseconds,
                days = this._days,
                months = this._months,
                data = this._data,
                seconds, minutes, hours, years;

            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1000;

            seconds = absRound(milliseconds / 1000);
            data.seconds = seconds % 60;

            minutes = absRound(seconds / 60);
            data.minutes = minutes % 60;

            hours = absRound(minutes / 60);
            data.hours = hours % 24;

            days += absRound(hours / 24);
            data.days = days % 30;

            months += absRound(days / 30);
            data.months = months % 12;

            years = absRound(months / 12);
            data.years = years;
        },

        weeks : function () {
            return absRound(this.days() / 7);
        },

        valueOf : function () {
            return this._milliseconds +
              this._days * 864e5 +
              (this._months % 12) * 2592e6 +
              toInt(this._months / 12) * 31536e6;
        },

        humanize : function (withSuffix) {
            var difference = +this,
                output = relativeTime(difference, !withSuffix, this.lang());

            if (withSuffix) {
                output = this.lang().pastFuture(difference, output);
            }

            return this.lang().postformat(output);
        },

        add : function (input, val) {
            // supports only 2.0-style add(1, 's') or add(moment)
            var dur = moment.duration(input, val);

            this._milliseconds += dur._milliseconds;
            this._days += dur._days;
            this._months += dur._months;

            this._bubble();

            return this;
        },

        subtract : function (input, val) {
            var dur = moment.duration(input, val);

            this._milliseconds -= dur._milliseconds;
            this._days -= dur._days;
            this._months -= dur._months;

            this._bubble();

            return this;
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units.toLowerCase() + 's']();
        },

        as : function (units) {
            units = normalizeUnits(units);
            return this['as' + units.charAt(0).toUpperCase() + units.slice(1) + 's']();
        },

        lang : moment.fn.lang,

        toIsoString : function () {
            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
            var years = Math.abs(this.years()),
                months = Math.abs(this.months()),
                days = Math.abs(this.days()),
                hours = Math.abs(this.hours()),
                minutes = Math.abs(this.minutes()),
                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);

            if (!this.asSeconds()) {
                // this is the same as C#'s (Noda) and python (isodate)...
                // but not other JS (goog.date)
                return 'P0D';
            }

            return (this.asSeconds() < 0 ? '-' : '') +
                'P' +
                (years ? years + 'Y' : '') +
                (months ? months + 'M' : '') +
                (days ? days + 'D' : '') +
                ((hours || minutes || seconds) ? 'T' : '') +
                (hours ? hours + 'H' : '') +
                (minutes ? minutes + 'M' : '') +
                (seconds ? seconds + 'S' : '');
        }
    });

    function makeDurationGetter(name) {
        moment.duration.fn[name] = function () {
            return this._data[name];
        };
    }

    function makeDurationAsGetter(name, factor) {
        moment.duration.fn['as' + name] = function () {
            return +this / factor;
        };
    }

    for (i in unitMillisecondFactors) {
        if (unitMillisecondFactors.hasOwnProperty(i)) {
            makeDurationAsGetter(i, unitMillisecondFactors[i]);
            makeDurationGetter(i.toLowerCase());
        }
    }

    makeDurationAsGetter('Weeks', 6048e5);
    moment.duration.fn.asMonths = function () {
        return (+this - this.years() * 31536e6) / 2592e6 + this.years() * 12;
    };


    /************************************
        Default Lang
    ************************************/


    // Set default language, other languages will inherit from English.
    moment.lang('en', {
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    /* EMBED_LANGUAGES */

    /************************************
        Exposing Moment
    ************************************/

    function makeGlobal(deprecate) {
        var warned = false, local_moment = moment;
        /*global ender:false */
        if (typeof ender !== 'undefined') {
            return;
        }
        // here, `this` means `window` in the browser, or `global` on the server
        // add `moment` as a global object via a string identifier,
        // for Closure Compiler "advanced" mode
        if (deprecate) {
            global.moment = function () {
                if (!warned && console && console.warn) {
                    warned = true;
                    console.warn(
                            "Accessing Moment through the global scope is " +
                            "deprecated, and will be removed in an upcoming " +
                            "release.");
                }
                return local_moment.apply(null, arguments);
            };
            extend(global.moment, local_moment);
        } else {
            global['moment'] = moment;
        }
    }

    // CommonJS module is defined
    if (hasModule) {
        module.exports = moment;
        makeGlobal(true);
    } else if (typeof define === "function" && define.amd) {
        define("moment", function (require, exports, module) {
            if (module.config && module.config() && module.config().noGlobal !== true) {
                // If user provided noGlobal, he is aware of global
                makeGlobal(module.config().noGlobal === undefined);
            }

            return moment;
        });
    } else {
        makeGlobal();
    }
}).call(this);

},{}],157:[function(require,module,exports){
/*
Copyright 2012 Igor Vaynberg

Version: 3.5.2 Timestamp: Sat Nov  1 14:43:36 EDT 2014

This software is licensed under the Apache License, Version 2.0 (the "Apache License") or the GNU
General Public License version 2 (the "GPL License"). You may choose either license to govern your
use of this software only upon the condition that you accept all of the terms of either the Apache
License or the GPL License.

You may obtain a copy of the Apache License and the GPL License at:

    http://www.apache.org/licenses/LICENSE-2.0
    http://www.gnu.org/licenses/gpl-2.0.html

Unless required by applicable law or agreed to in writing, software distributed under the
Apache License or the GPL License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the Apache License and the GPL License for
the specific language governing permissions and limitations under the Apache License and the GPL License.
*/
(function ($) {
    if(typeof $.fn.each2 == "undefined") {
        $.extend($.fn, {
            /*
            * 4-10 times faster .each replacement
            * use it carefully, as it overrides jQuery context of element on each iteration
            */
            each2 : function (c) {
                var j = $([0]), i = -1, l = this.length;
                while (
                    ++i < l
                    && (j.context = j[0] = this[i])
                    && c.call(j[0], i, j) !== false //"this"=DOM, i=index, j=jQuery object
                );
                return this;
            }
        });
    }
})(jQuery);

(function ($, undefined) {
    "use strict";
    /*global document, window, jQuery, console */

    if (window.Select2 !== undefined) {
        return;
    }

    var AbstractSelect2, SingleSelect2, MultiSelect2, nextUid, sizer,
        lastMousePosition={x:0,y:0}, $document, scrollBarDimensions,

    KEY = {
        TAB: 9,
        ENTER: 13,
        ESC: 27,
        SPACE: 32,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,
        SHIFT: 16,
        CTRL: 17,
        ALT: 18,
        PAGE_UP: 33,
        PAGE_DOWN: 34,
        HOME: 36,
        END: 35,
        BACKSPACE: 8,
        DELETE: 46,
        isArrow: function (k) {
            k = k.which ? k.which : k;
            switch (k) {
            case KEY.LEFT:
            case KEY.RIGHT:
            case KEY.UP:
            case KEY.DOWN:
                return true;
            }
            return false;
        },
        isControl: function (e) {
            var k = e.which;
            switch (k) {
            case KEY.SHIFT:
            case KEY.CTRL:
            case KEY.ALT:
                return true;
            }

            if (e.metaKey) return true;

            return false;
        },
        isFunctionKey: function (k) {
            k = k.which ? k.which : k;
            return k >= 112 && k <= 123;
        }
    },
    MEASURE_SCROLLBAR_TEMPLATE = "<div class='select2-measure-scrollbar'></div>",

    DIACRITICS = {"\u24B6":"A","\uFF21":"A","\u00C0":"A","\u00C1":"A","\u00C2":"A","\u1EA6":"A","\u1EA4":"A","\u1EAA":"A","\u1EA8":"A","\u00C3":"A","\u0100":"A","\u0102":"A","\u1EB0":"A","\u1EAE":"A","\u1EB4":"A","\u1EB2":"A","\u0226":"A","\u01E0":"A","\u00C4":"A","\u01DE":"A","\u1EA2":"A","\u00C5":"A","\u01FA":"A","\u01CD":"A","\u0200":"A","\u0202":"A","\u1EA0":"A","\u1EAC":"A","\u1EB6":"A","\u1E00":"A","\u0104":"A","\u023A":"A","\u2C6F":"A","\uA732":"AA","\u00C6":"AE","\u01FC":"AE","\u01E2":"AE","\uA734":"AO","\uA736":"AU","\uA738":"AV","\uA73A":"AV","\uA73C":"AY","\u24B7":"B","\uFF22":"B","\u1E02":"B","\u1E04":"B","\u1E06":"B","\u0243":"B","\u0182":"B","\u0181":"B","\u24B8":"C","\uFF23":"C","\u0106":"C","\u0108":"C","\u010A":"C","\u010C":"C","\u00C7":"C","\u1E08":"C","\u0187":"C","\u023B":"C","\uA73E":"C","\u24B9":"D","\uFF24":"D","\u1E0A":"D","\u010E":"D","\u1E0C":"D","\u1E10":"D","\u1E12":"D","\u1E0E":"D","\u0110":"D","\u018B":"D","\u018A":"D","\u0189":"D","\uA779":"D","\u01F1":"DZ","\u01C4":"DZ","\u01F2":"Dz","\u01C5":"Dz","\u24BA":"E","\uFF25":"E","\u00C8":"E","\u00C9":"E","\u00CA":"E","\u1EC0":"E","\u1EBE":"E","\u1EC4":"E","\u1EC2":"E","\u1EBC":"E","\u0112":"E","\u1E14":"E","\u1E16":"E","\u0114":"E","\u0116":"E","\u00CB":"E","\u1EBA":"E","\u011A":"E","\u0204":"E","\u0206":"E","\u1EB8":"E","\u1EC6":"E","\u0228":"E","\u1E1C":"E","\u0118":"E","\u1E18":"E","\u1E1A":"E","\u0190":"E","\u018E":"E","\u24BB":"F","\uFF26":"F","\u1E1E":"F","\u0191":"F","\uA77B":"F","\u24BC":"G","\uFF27":"G","\u01F4":"G","\u011C":"G","\u1E20":"G","\u011E":"G","\u0120":"G","\u01E6":"G","\u0122":"G","\u01E4":"G","\u0193":"G","\uA7A0":"G","\uA77D":"G","\uA77E":"G","\u24BD":"H","\uFF28":"H","\u0124":"H","\u1E22":"H","\u1E26":"H","\u021E":"H","\u1E24":"H","\u1E28":"H","\u1E2A":"H","\u0126":"H","\u2C67":"H","\u2C75":"H","\uA78D":"H","\u24BE":"I","\uFF29":"I","\u00CC":"I","\u00CD":"I","\u00CE":"I","\u0128":"I","\u012A":"I","\u012C":"I","\u0130":"I","\u00CF":"I","\u1E2E":"I","\u1EC8":"I","\u01CF":"I","\u0208":"I","\u020A":"I","\u1ECA":"I","\u012E":"I","\u1E2C":"I","\u0197":"I","\u24BF":"J","\uFF2A":"J","\u0134":"J","\u0248":"J","\u24C0":"K","\uFF2B":"K","\u1E30":"K","\u01E8":"K","\u1E32":"K","\u0136":"K","\u1E34":"K","\u0198":"K","\u2C69":"K","\uA740":"K","\uA742":"K","\uA744":"K","\uA7A2":"K","\u24C1":"L","\uFF2C":"L","\u013F":"L","\u0139":"L","\u013D":"L","\u1E36":"L","\u1E38":"L","\u013B":"L","\u1E3C":"L","\u1E3A":"L","\u0141":"L","\u023D":"L","\u2C62":"L","\u2C60":"L","\uA748":"L","\uA746":"L","\uA780":"L","\u01C7":"LJ","\u01C8":"Lj","\u24C2":"M","\uFF2D":"M","\u1E3E":"M","\u1E40":"M","\u1E42":"M","\u2C6E":"M","\u019C":"M","\u24C3":"N","\uFF2E":"N","\u01F8":"N","\u0143":"N","\u00D1":"N","\u1E44":"N","\u0147":"N","\u1E46":"N","\u0145":"N","\u1E4A":"N","\u1E48":"N","\u0220":"N","\u019D":"N","\uA790":"N","\uA7A4":"N","\u01CA":"NJ","\u01CB":"Nj","\u24C4":"O","\uFF2F":"O","\u00D2":"O","\u00D3":"O","\u00D4":"O","\u1ED2":"O","\u1ED0":"O","\u1ED6":"O","\u1ED4":"O","\u00D5":"O","\u1E4C":"O","\u022C":"O","\u1E4E":"O","\u014C":"O","\u1E50":"O","\u1E52":"O","\u014E":"O","\u022E":"O","\u0230":"O","\u00D6":"O","\u022A":"O","\u1ECE":"O","\u0150":"O","\u01D1":"O","\u020C":"O","\u020E":"O","\u01A0":"O","\u1EDC":"O","\u1EDA":"O","\u1EE0":"O","\u1EDE":"O","\u1EE2":"O","\u1ECC":"O","\u1ED8":"O","\u01EA":"O","\u01EC":"O","\u00D8":"O","\u01FE":"O","\u0186":"O","\u019F":"O","\uA74A":"O","\uA74C":"O","\u01A2":"OI","\uA74E":"OO","\u0222":"OU","\u24C5":"P","\uFF30":"P","\u1E54":"P","\u1E56":"P","\u01A4":"P","\u2C63":"P","\uA750":"P","\uA752":"P","\uA754":"P","\u24C6":"Q","\uFF31":"Q","\uA756":"Q","\uA758":"Q","\u024A":"Q","\u24C7":"R","\uFF32":"R","\u0154":"R","\u1E58":"R","\u0158":"R","\u0210":"R","\u0212":"R","\u1E5A":"R","\u1E5C":"R","\u0156":"R","\u1E5E":"R","\u024C":"R","\u2C64":"R","\uA75A":"R","\uA7A6":"R","\uA782":"R","\u24C8":"S","\uFF33":"S","\u1E9E":"S","\u015A":"S","\u1E64":"S","\u015C":"S","\u1E60":"S","\u0160":"S","\u1E66":"S","\u1E62":"S","\u1E68":"S","\u0218":"S","\u015E":"S","\u2C7E":"S","\uA7A8":"S","\uA784":"S","\u24C9":"T","\uFF34":"T","\u1E6A":"T","\u0164":"T","\u1E6C":"T","\u021A":"T","\u0162":"T","\u1E70":"T","\u1E6E":"T","\u0166":"T","\u01AC":"T","\u01AE":"T","\u023E":"T","\uA786":"T","\uA728":"TZ","\u24CA":"U","\uFF35":"U","\u00D9":"U","\u00DA":"U","\u00DB":"U","\u0168":"U","\u1E78":"U","\u016A":"U","\u1E7A":"U","\u016C":"U","\u00DC":"U","\u01DB":"U","\u01D7":"U","\u01D5":"U","\u01D9":"U","\u1EE6":"U","\u016E":"U","\u0170":"U","\u01D3":"U","\u0214":"U","\u0216":"U","\u01AF":"U","\u1EEA":"U","\u1EE8":"U","\u1EEE":"U","\u1EEC":"U","\u1EF0":"U","\u1EE4":"U","\u1E72":"U","\u0172":"U","\u1E76":"U","\u1E74":"U","\u0244":"U","\u24CB":"V","\uFF36":"V","\u1E7C":"V","\u1E7E":"V","\u01B2":"V","\uA75E":"V","\u0245":"V","\uA760":"VY","\u24CC":"W","\uFF37":"W","\u1E80":"W","\u1E82":"W","\u0174":"W","\u1E86":"W","\u1E84":"W","\u1E88":"W","\u2C72":"W","\u24CD":"X","\uFF38":"X","\u1E8A":"X","\u1E8C":"X","\u24CE":"Y","\uFF39":"Y","\u1EF2":"Y","\u00DD":"Y","\u0176":"Y","\u1EF8":"Y","\u0232":"Y","\u1E8E":"Y","\u0178":"Y","\u1EF6":"Y","\u1EF4":"Y","\u01B3":"Y","\u024E":"Y","\u1EFE":"Y","\u24CF":"Z","\uFF3A":"Z","\u0179":"Z","\u1E90":"Z","\u017B":"Z","\u017D":"Z","\u1E92":"Z","\u1E94":"Z","\u01B5":"Z","\u0224":"Z","\u2C7F":"Z","\u2C6B":"Z","\uA762":"Z","\u24D0":"a","\uFF41":"a","\u1E9A":"a","\u00E0":"a","\u00E1":"a","\u00E2":"a","\u1EA7":"a","\u1EA5":"a","\u1EAB":"a","\u1EA9":"a","\u00E3":"a","\u0101":"a","\u0103":"a","\u1EB1":"a","\u1EAF":"a","\u1EB5":"a","\u1EB3":"a","\u0227":"a","\u01E1":"a","\u00E4":"a","\u01DF":"a","\u1EA3":"a","\u00E5":"a","\u01FB":"a","\u01CE":"a","\u0201":"a","\u0203":"a","\u1EA1":"a","\u1EAD":"a","\u1EB7":"a","\u1E01":"a","\u0105":"a","\u2C65":"a","\u0250":"a","\uA733":"aa","\u00E6":"ae","\u01FD":"ae","\u01E3":"ae","\uA735":"ao","\uA737":"au","\uA739":"av","\uA73B":"av","\uA73D":"ay","\u24D1":"b","\uFF42":"b","\u1E03":"b","\u1E05":"b","\u1E07":"b","\u0180":"b","\u0183":"b","\u0253":"b","\u24D2":"c","\uFF43":"c","\u0107":"c","\u0109":"c","\u010B":"c","\u010D":"c","\u00E7":"c","\u1E09":"c","\u0188":"c","\u023C":"c","\uA73F":"c","\u2184":"c","\u24D3":"d","\uFF44":"d","\u1E0B":"d","\u010F":"d","\u1E0D":"d","\u1E11":"d","\u1E13":"d","\u1E0F":"d","\u0111":"d","\u018C":"d","\u0256":"d","\u0257":"d","\uA77A":"d","\u01F3":"dz","\u01C6":"dz","\u24D4":"e","\uFF45":"e","\u00E8":"e","\u00E9":"e","\u00EA":"e","\u1EC1":"e","\u1EBF":"e","\u1EC5":"e","\u1EC3":"e","\u1EBD":"e","\u0113":"e","\u1E15":"e","\u1E17":"e","\u0115":"e","\u0117":"e","\u00EB":"e","\u1EBB":"e","\u011B":"e","\u0205":"e","\u0207":"e","\u1EB9":"e","\u1EC7":"e","\u0229":"e","\u1E1D":"e","\u0119":"e","\u1E19":"e","\u1E1B":"e","\u0247":"e","\u025B":"e","\u01DD":"e","\u24D5":"f","\uFF46":"f","\u1E1F":"f","\u0192":"f","\uA77C":"f","\u24D6":"g","\uFF47":"g","\u01F5":"g","\u011D":"g","\u1E21":"g","\u011F":"g","\u0121":"g","\u01E7":"g","\u0123":"g","\u01E5":"g","\u0260":"g","\uA7A1":"g","\u1D79":"g","\uA77F":"g","\u24D7":"h","\uFF48":"h","\u0125":"h","\u1E23":"h","\u1E27":"h","\u021F":"h","\u1E25":"h","\u1E29":"h","\u1E2B":"h","\u1E96":"h","\u0127":"h","\u2C68":"h","\u2C76":"h","\u0265":"h","\u0195":"hv","\u24D8":"i","\uFF49":"i","\u00EC":"i","\u00ED":"i","\u00EE":"i","\u0129":"i","\u012B":"i","\u012D":"i","\u00EF":"i","\u1E2F":"i","\u1EC9":"i","\u01D0":"i","\u0209":"i","\u020B":"i","\u1ECB":"i","\u012F":"i","\u1E2D":"i","\u0268":"i","\u0131":"i","\u24D9":"j","\uFF4A":"j","\u0135":"j","\u01F0":"j","\u0249":"j","\u24DA":"k","\uFF4B":"k","\u1E31":"k","\u01E9":"k","\u1E33":"k","\u0137":"k","\u1E35":"k","\u0199":"k","\u2C6A":"k","\uA741":"k","\uA743":"k","\uA745":"k","\uA7A3":"k","\u24DB":"l","\uFF4C":"l","\u0140":"l","\u013A":"l","\u013E":"l","\u1E37":"l","\u1E39":"l","\u013C":"l","\u1E3D":"l","\u1E3B":"l","\u017F":"l","\u0142":"l","\u019A":"l","\u026B":"l","\u2C61":"l","\uA749":"l","\uA781":"l","\uA747":"l","\u01C9":"lj","\u24DC":"m","\uFF4D":"m","\u1E3F":"m","\u1E41":"m","\u1E43":"m","\u0271":"m","\u026F":"m","\u24DD":"n","\uFF4E":"n","\u01F9":"n","\u0144":"n","\u00F1":"n","\u1E45":"n","\u0148":"n","\u1E47":"n","\u0146":"n","\u1E4B":"n","\u1E49":"n","\u019E":"n","\u0272":"n","\u0149":"n","\uA791":"n","\uA7A5":"n","\u01CC":"nj","\u24DE":"o","\uFF4F":"o","\u00F2":"o","\u00F3":"o","\u00F4":"o","\u1ED3":"o","\u1ED1":"o","\u1ED7":"o","\u1ED5":"o","\u00F5":"o","\u1E4D":"o","\u022D":"o","\u1E4F":"o","\u014D":"o","\u1E51":"o","\u1E53":"o","\u014F":"o","\u022F":"o","\u0231":"o","\u00F6":"o","\u022B":"o","\u1ECF":"o","\u0151":"o","\u01D2":"o","\u020D":"o","\u020F":"o","\u01A1":"o","\u1EDD":"o","\u1EDB":"o","\u1EE1":"o","\u1EDF":"o","\u1EE3":"o","\u1ECD":"o","\u1ED9":"o","\u01EB":"o","\u01ED":"o","\u00F8":"o","\u01FF":"o","\u0254":"o","\uA74B":"o","\uA74D":"o","\u0275":"o","\u01A3":"oi","\u0223":"ou","\uA74F":"oo","\u24DF":"p","\uFF50":"p","\u1E55":"p","\u1E57":"p","\u01A5":"p","\u1D7D":"p","\uA751":"p","\uA753":"p","\uA755":"p","\u24E0":"q","\uFF51":"q","\u024B":"q","\uA757":"q","\uA759":"q","\u24E1":"r","\uFF52":"r","\u0155":"r","\u1E59":"r","\u0159":"r","\u0211":"r","\u0213":"r","\u1E5B":"r","\u1E5D":"r","\u0157":"r","\u1E5F":"r","\u024D":"r","\u027D":"r","\uA75B":"r","\uA7A7":"r","\uA783":"r","\u24E2":"s","\uFF53":"s","\u00DF":"s","\u015B":"s","\u1E65":"s","\u015D":"s","\u1E61":"s","\u0161":"s","\u1E67":"s","\u1E63":"s","\u1E69":"s","\u0219":"s","\u015F":"s","\u023F":"s","\uA7A9":"s","\uA785":"s","\u1E9B":"s","\u24E3":"t","\uFF54":"t","\u1E6B":"t","\u1E97":"t","\u0165":"t","\u1E6D":"t","\u021B":"t","\u0163":"t","\u1E71":"t","\u1E6F":"t","\u0167":"t","\u01AD":"t","\u0288":"t","\u2C66":"t","\uA787":"t","\uA729":"tz","\u24E4":"u","\uFF55":"u","\u00F9":"u","\u00FA":"u","\u00FB":"u","\u0169":"u","\u1E79":"u","\u016B":"u","\u1E7B":"u","\u016D":"u","\u00FC":"u","\u01DC":"u","\u01D8":"u","\u01D6":"u","\u01DA":"u","\u1EE7":"u","\u016F":"u","\u0171":"u","\u01D4":"u","\u0215":"u","\u0217":"u","\u01B0":"u","\u1EEB":"u","\u1EE9":"u","\u1EEF":"u","\u1EED":"u","\u1EF1":"u","\u1EE5":"u","\u1E73":"u","\u0173":"u","\u1E77":"u","\u1E75":"u","\u0289":"u","\u24E5":"v","\uFF56":"v","\u1E7D":"v","\u1E7F":"v","\u028B":"v","\uA75F":"v","\u028C":"v","\uA761":"vy","\u24E6":"w","\uFF57":"w","\u1E81":"w","\u1E83":"w","\u0175":"w","\u1E87":"w","\u1E85":"w","\u1E98":"w","\u1E89":"w","\u2C73":"w","\u24E7":"x","\uFF58":"x","\u1E8B":"x","\u1E8D":"x","\u24E8":"y","\uFF59":"y","\u1EF3":"y","\u00FD":"y","\u0177":"y","\u1EF9":"y","\u0233":"y","\u1E8F":"y","\u00FF":"y","\u1EF7":"y","\u1E99":"y","\u1EF5":"y","\u01B4":"y","\u024F":"y","\u1EFF":"y","\u24E9":"z","\uFF5A":"z","\u017A":"z","\u1E91":"z","\u017C":"z","\u017E":"z","\u1E93":"z","\u1E95":"z","\u01B6":"z","\u0225":"z","\u0240":"z","\u2C6C":"z","\uA763":"z","\u0386":"\u0391","\u0388":"\u0395","\u0389":"\u0397","\u038A":"\u0399","\u03AA":"\u0399","\u038C":"\u039F","\u038E":"\u03A5","\u03AB":"\u03A5","\u038F":"\u03A9","\u03AC":"\u03B1","\u03AD":"\u03B5","\u03AE":"\u03B7","\u03AF":"\u03B9","\u03CA":"\u03B9","\u0390":"\u03B9","\u03CC":"\u03BF","\u03CD":"\u03C5","\u03CB":"\u03C5","\u03B0":"\u03C5","\u03C9":"\u03C9","\u03C2":"\u03C3"};

    $document = $(document);

    nextUid=(function() { var counter=1; return function() { return counter++; }; }());


    function reinsertElement(element) {
        var placeholder = $(document.createTextNode(''));

        element.before(placeholder);
        placeholder.before(element);
        placeholder.remove();
    }

    function stripDiacritics(str) {
        // Used 'uni range + named function' from http://jsperf.com/diacritics/18
        function match(a) {
            return DIACRITICS[a] || a;
        }

        return str.replace(/[^\u0000-\u007E]/g, match);
    }

    function indexOf(value, array) {
        var i = 0, l = array.length;
        for (; i < l; i = i + 1) {
            if (equal(value, array[i])) return i;
        }
        return -1;
    }

    function measureScrollbar () {
        var $template = $( MEASURE_SCROLLBAR_TEMPLATE );
        $template.appendTo(document.body);

        var dim = {
            width: $template.width() - $template[0].clientWidth,
            height: $template.height() - $template[0].clientHeight
        };
        $template.remove();

        return dim;
    }

    /**
     * Compares equality of a and b
     * @param a
     * @param b
     */
    function equal(a, b) {
        if (a === b) return true;
        if (a === undefined || b === undefined) return false;
        if (a === null || b === null) return false;
        // Check whether 'a' or 'b' is a string (primitive or object).
        // The concatenation of an empty string (+'') converts its argument to a string's primitive.
        if (a.constructor === String) return a+'' === b+''; // a+'' - in case 'a' is a String object
        if (b.constructor === String) return b+'' === a+''; // b+'' - in case 'b' is a String object
        return false;
    }

    /**
     * Splits the string into an array of values, transforming each value. An empty array is returned for nulls or empty
     * strings
     * @param string
     * @param separator
     */
    function splitVal(string, separator, transform) {
        var val, i, l;
        if (string === null || string.length < 1) return [];
        val = string.split(separator);
        for (i = 0, l = val.length; i < l; i = i + 1) val[i] = transform(val[i]);
        return val;
    }

    function getSideBorderPadding(element) {
        return element.outerWidth(false) - element.width();
    }

    function installKeyUpChangeEvent(element) {
        var key="keyup-change-value";
        element.on("keydown", function () {
            if ($.data(element, key) === undefined) {
                $.data(element, key, element.val());
            }
        });
        element.on("keyup", function () {
            var val= $.data(element, key);
            if (val !== undefined && element.val() !== val) {
                $.removeData(element, key);
                element.trigger("keyup-change");
            }
        });
    }


    /**
     * filters mouse events so an event is fired only if the mouse moved.
     *
     * filters out mouse events that occur when mouse is stationary but
     * the elements under the pointer are scrolled.
     */
    function installFilteredMouseMove(element) {
        element.on("mousemove", function (e) {
            var lastpos = lastMousePosition;
            if (lastpos === undefined || lastpos.x !== e.pageX || lastpos.y !== e.pageY) {
                $(e.target).trigger("mousemove-filtered", e);
            }
        });
    }

    /**
     * Debounces a function. Returns a function that calls the original fn function only if no invocations have been made
     * within the last quietMillis milliseconds.
     *
     * @param quietMillis number of milliseconds to wait before invoking fn
     * @param fn function to be debounced
     * @param ctx object to be used as this reference within fn
     * @return debounced version of fn
     */
    function debounce(quietMillis, fn, ctx) {
        ctx = ctx || undefined;
        var timeout;
        return function () {
            var args = arguments;
            window.clearTimeout(timeout);
            timeout = window.setTimeout(function() {
                fn.apply(ctx, args);
            }, quietMillis);
        };
    }

    function installDebouncedScroll(threshold, element) {
        var notify = debounce(threshold, function (e) { element.trigger("scroll-debounced", e);});
        element.on("scroll", function (e) {
            if (indexOf(e.target, element.get()) >= 0) notify(e);
        });
    }

    function focus($el) {
        if ($el[0] === document.activeElement) return;

        /* set the focus in a 0 timeout - that way the focus is set after the processing
            of the current event has finished - which seems like the only reliable way
            to set focus */
        window.setTimeout(function() {
            var el=$el[0], pos=$el.val().length, range;

            $el.focus();

            /* make sure el received focus so we do not error out when trying to manipulate the caret.
                sometimes modals or others listeners may steal it after its set */
            var isVisible = (el.offsetWidth > 0 || el.offsetHeight > 0);
            if (isVisible && el === document.activeElement) {

                /* after the focus is set move the caret to the end, necessary when we val()
                    just before setting focus */
                if(el.setSelectionRange)
                {
                    el.setSelectionRange(pos, pos);
                }
                else if (el.createTextRange) {
                    range = el.createTextRange();
                    range.collapse(false);
                    range.select();
                }
            }
        }, 0);
    }

    function getCursorInfo(el) {
        el = $(el)[0];
        var offset = 0;
        var length = 0;
        if ('selectionStart' in el) {
            offset = el.selectionStart;
            length = el.selectionEnd - offset;
        } else if ('selection' in document) {
            el.focus();
            var sel = document.selection.createRange();
            length = document.selection.createRange().text.length;
            sel.moveStart('character', -el.value.length);
            offset = sel.text.length - length;
        }
        return { offset: offset, length: length };
    }

    function killEvent(event) {
        event.preventDefault();
        event.stopPropagation();
    }
    function killEventImmediately(event) {
        event.preventDefault();
        event.stopImmediatePropagation();
    }

    function measureTextWidth(e) {
        if (!sizer){
            var style = e[0].currentStyle || window.getComputedStyle(e[0], null);
            sizer = $(document.createElement("div")).css({
                position: "absolute",
                left: "-10000px",
                top: "-10000px",
                display: "none",
                fontSize: style.fontSize,
                fontFamily: style.fontFamily,
                fontStyle: style.fontStyle,
                fontWeight: style.fontWeight,
                letterSpacing: style.letterSpacing,
                textTransform: style.textTransform,
                whiteSpace: "nowrap"
            });
            sizer.attr("class","select2-sizer");
            $(document.body).append(sizer);
        }
        sizer.text(e.val());
        return sizer.width();
    }

    function syncCssClasses(dest, src, adapter) {
        var classes, replacements = [], adapted;

        classes = $.trim(dest.attr("class"));

        if (classes) {
            classes = '' + classes; // for IE which returns object

            $(classes.split(/\s+/)).each2(function() {
                if (this.indexOf("select2-") === 0) {
                    replacements.push(this);
                }
            });
        }

        classes = $.trim(src.attr("class"));

        if (classes) {
            classes = '' + classes; // for IE which returns object

            $(classes.split(/\s+/)).each2(function() {
                if (this.indexOf("select2-") !== 0) {
                    adapted = adapter(this);

                    if (adapted) {
                        replacements.push(adapted);
                    }
                }
            });
        }

        dest.attr("class", replacements.join(" "));
    }


    function markMatch(text, term, markup, escapeMarkup) {
        var match=stripDiacritics(text.toUpperCase()).indexOf(stripDiacritics(term.toUpperCase())),
            tl=term.length;

        if (match<0) {
            markup.push(escapeMarkup(text));
            return;
        }

        markup.push(escapeMarkup(text.substring(0, match)));
        markup.push("<span class='select2-match'>");
        markup.push(escapeMarkup(text.substring(match, match + tl)));
        markup.push("</span>");
        markup.push(escapeMarkup(text.substring(match + tl, text.length)));
    }

    function defaultEscapeMarkup(markup) {
        var replace_map = {
            '\\': '&#92;',
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;',
            "/": '&#47;'
        };

        return String(markup).replace(/[&<>"'\/\\]/g, function (match) {
            return replace_map[match];
        });
    }

    /**
     * Produces an ajax-based query function
     *
     * @param options object containing configuration parameters
     * @param options.params parameter map for the transport ajax call, can contain such options as cache, jsonpCallback, etc. see $.ajax
     * @param options.transport function that will be used to execute the ajax request. must be compatible with parameters supported by $.ajax
     * @param options.url url for the data
     * @param options.data a function(searchTerm, pageNumber, context) that should return an object containing query string parameters for the above url.
     * @param options.dataType request data type: ajax, jsonp, other datatypes supported by jQuery's $.ajax function or the transport function if specified
     * @param options.quietMillis (optional) milliseconds to wait before making the ajaxRequest, helps debounce the ajax function if invoked too often
     * @param options.results a function(remoteData, pageNumber, query) that converts data returned form the remote request to the format expected by Select2.
     *      The expected format is an object containing the following keys:
     *      results array of objects that will be used as choices
     *      more (optional) boolean indicating whether there are more results available
     *      Example: {results:[{id:1, text:'Red'},{id:2, text:'Blue'}], more:true}
     */
    function ajax(options) {
        var timeout, // current scheduled but not yet executed request
            handler = null,
            quietMillis = options.quietMillis || 100,
            ajaxUrl = options.url,
            self = this;

        return function (query) {
            window.clearTimeout(timeout);
            timeout = window.setTimeout(function () {
                var data = options.data, // ajax data function
                    url = ajaxUrl, // ajax url string or function
                    transport = options.transport || $.fn.select2.ajaxDefaults.transport,
                    // deprecated - to be removed in 4.0  - use params instead
                    deprecated = {
                        type: options.type || 'GET', // set type of request (GET or POST)
                        cache: options.cache || false,
                        jsonpCallback: options.jsonpCallback||undefined,
                        dataType: options.dataType||"json"
                    },
                    params = $.extend({}, $.fn.select2.ajaxDefaults.params, deprecated);

                data = data ? data.call(self, query.term, query.page, query.context) : null;
                url = (typeof url === 'function') ? url.call(self, query.term, query.page, query.context) : url;

                if (handler && typeof handler.abort === "function") { handler.abort(); }

                if (options.params) {
                    if ($.isFunction(options.params)) {
                        $.extend(params, options.params.call(self));
                    } else {
                        $.extend(params, options.params);
                    }
                }

                $.extend(params, {
                    url: url,
                    dataType: options.dataType,
                    data: data,
                    success: function (data) {
                        // TODO - replace query.page with query so users have access to term, page, etc.
                        // added query as third paramter to keep backwards compatibility
                        var results = options.results(data, query.page, query);
                        query.callback(results);
                    },
                    error: function(jqXHR, textStatus, errorThrown){
                        var results = {
                            hasError: true,
                            jqXHR: jqXHR,
                            textStatus: textStatus,
                            errorThrown: errorThrown
                        };

                        query.callback(results);
                    }
                });
                handler = transport.call(self, params);
            }, quietMillis);
        };
    }

    /**
     * Produces a query function that works with a local array
     *
     * @param options object containing configuration parameters. The options parameter can either be an array or an
     * object.
     *
     * If the array form is used it is assumed that it contains objects with 'id' and 'text' keys.
     *
     * If the object form is used it is assumed that it contains 'data' and 'text' keys. The 'data' key should contain
     * an array of objects that will be used as choices. These objects must contain at least an 'id' key. The 'text'
     * key can either be a String in which case it is expected that each element in the 'data' array has a key with the
     * value of 'text' which will be used to match choices. Alternatively, text can be a function(item) that can extract
     * the text.
     */
    function local(options) {
        var data = options, // data elements
            dataText,
            tmp,
            text = function (item) { return ""+item.text; }; // function used to retrieve the text portion of a data item that is matched against the search

         if ($.isArray(data)) {
            tmp = data;
            data = { results: tmp };
        }

         if ($.isFunction(data) === false) {
            tmp = data;
            data = function() { return tmp; };
        }

        var dataItem = data();
        if (dataItem.text) {
            text = dataItem.text;
            // if text is not a function we assume it to be a key name
            if (!$.isFunction(text)) {
                dataText = dataItem.text; // we need to store this in a separate variable because in the next step data gets reset and data.text is no longer available
                text = function (item) { return item[dataText]; };
            }
        }

        return function (query) {
            var t = query.term, filtered = { results: [] }, process;
            if (t === "") {
                query.callback(data());
                return;
            }

            process = function(datum, collection) {
                var group, attr;
                datum = datum[0];
                if (datum.children) {
                    group = {};
                    for (attr in datum) {
                        if (datum.hasOwnProperty(attr)) group[attr]=datum[attr];
                    }
                    group.children=[];
                    $(datum.children).each2(function(i, childDatum) { process(childDatum, group.children); });
                    if (group.children.length || query.matcher(t, text(group), datum)) {
                        collection.push(group);
                    }
                } else {
                    if (query.matcher(t, text(datum), datum)) {
                        collection.push(datum);
                    }
                }
            };

            $(data().results).each2(function(i, datum) { process(datum, filtered.results); });
            query.callback(filtered);
        };
    }

    // TODO javadoc
    function tags(data) {
        var isFunc = $.isFunction(data);
        return function (query) {
            var t = query.term, filtered = {results: []};
            var result = isFunc ? data(query) : data;
            if ($.isArray(result)) {
                $(result).each(function () {
                    var isObject = this.text !== undefined,
                        text = isObject ? this.text : this;
                    if (t === "" || query.matcher(t, text)) {
                        filtered.results.push(isObject ? this : {id: this, text: this});
                    }
                });
                query.callback(filtered);
            }
        };
    }

    /**
     * Checks if the formatter function should be used.
     *
     * Throws an error if it is not a function. Returns true if it should be used,
     * false if no formatting should be performed.
     *
     * @param formatter
     */
    function checkFormatter(formatter, formatterName) {
        if ($.isFunction(formatter)) return true;
        if (!formatter) return false;
        if (typeof(formatter) === 'string') return true;
        throw new Error(formatterName +" must be a string, function, or falsy value");
    }

  /**
   * Returns a given value
   * If given a function, returns its output
   *
   * @param val string|function
   * @param context value of "this" to be passed to function
   * @returns {*}
   */
    function evaluate(val, context) {
        if ($.isFunction(val)) {
            var args = Array.prototype.slice.call(arguments, 2);
            return val.apply(context, args);
        }
        return val;
    }

    function countResults(results) {
        var count = 0;
        $.each(results, function(i, item) {
            if (item.children) {
                count += countResults(item.children);
            } else {
                count++;
            }
        });
        return count;
    }

    /**
     * Default tokenizer. This function uses breaks the input on substring match of any string from the
     * opts.tokenSeparators array and uses opts.createSearchChoice to create the choice object. Both of those
     * two options have to be defined in order for the tokenizer to work.
     *
     * @param input text user has typed so far or pasted into the search field
     * @param selection currently selected choices
     * @param selectCallback function(choice) callback tho add the choice to selection
     * @param opts select2's opts
     * @return undefined/null to leave the current input unchanged, or a string to change the input to the returned value
     */
    function defaultTokenizer(input, selection, selectCallback, opts) {
        var original = input, // store the original so we can compare and know if we need to tell the search to update its text
            dupe = false, // check for whether a token we extracted represents a duplicate selected choice
            token, // token
            index, // position at which the separator was found
            i, l, // looping variables
            separator; // the matched separator

        if (!opts.createSearchChoice || !opts.tokenSeparators || opts.tokenSeparators.length < 1) return undefined;

        while (true) {
            index = -1;

            for (i = 0, l = opts.tokenSeparators.length; i < l; i++) {
                separator = opts.tokenSeparators[i];
                index = input.indexOf(separator);
                if (index >= 0) break;
            }

            if (index < 0) break; // did not find any token separator in the input string, bail

            token = input.substring(0, index);
            input = input.substring(index + separator.length);

            if (token.length > 0) {
                token = opts.createSearchChoice.call(this, token, selection);
                if (token !== undefined && token !== null && opts.id(token) !== undefined && opts.id(token) !== null) {
                    dupe = false;
                    for (i = 0, l = selection.length; i < l; i++) {
                        if (equal(opts.id(token), opts.id(selection[i]))) {
                            dupe = true; break;
                        }
                    }

                    if (!dupe) selectCallback(token);
                }
            }
        }

        if (original!==input) return input;
    }

    function cleanupJQueryElements() {
        var self = this;

        $.each(arguments, function (i, element) {
            self[element].remove();
            self[element] = null;
        });
    }

    /**
     * Creates a new class
     *
     * @param superClass
     * @param methods
     */
    function clazz(SuperClass, methods) {
        var constructor = function () {};
        constructor.prototype = new SuperClass;
        constructor.prototype.constructor = constructor;
        constructor.prototype.parent = SuperClass.prototype;
        constructor.prototype = $.extend(constructor.prototype, methods);
        return constructor;
    }

    AbstractSelect2 = clazz(Object, {

        // abstract
        bind: function (func) {
            var self = this;
            return function () {
                func.apply(self, arguments);
            };
        },

        // abstract
        init: function (opts) {
            var results, search, resultsSelector = ".select2-results";

            // prepare options
            this.opts = opts = this.prepareOpts(opts);

            this.id=opts.id;

            // destroy if called on an existing component
            if (opts.element.data("select2") !== undefined &&
                opts.element.data("select2") !== null) {
                opts.element.data("select2").destroy();
            }

            this.container = this.createContainer();

            this.liveRegion = $('.select2-hidden-accessible');
            if (this.liveRegion.length == 0) {
                this.liveRegion = $("<span>", {
                        role: "status",
                        "aria-live": "polite"
                    })
                    .addClass("select2-hidden-accessible")
                    .appendTo(document.body);
            }

            this.containerId="s2id_"+(opts.element.attr("id") || "autogen"+nextUid());
            this.containerEventName= this.containerId
                .replace(/([.])/g, '_')
                .replace(/([;&,\-\.\+\*\~':"\!\^#$%@\[\]\(\)=>\|])/g, '\\$1');
            this.container.attr("id", this.containerId);

            this.container.attr("title", opts.element.attr("title"));

            this.body = $(document.body);

            syncCssClasses(this.container, this.opts.element, this.opts.adaptContainerCssClass);

            this.container.attr("style", opts.element.attr("style"));
            this.container.css(evaluate(opts.containerCss, this.opts.element));
            this.container.addClass(evaluate(opts.containerCssClass, this.opts.element));

            this.elementTabIndex = this.opts.element.attr("tabindex");

            // swap container for the element
            this.opts.element
                .data("select2", this)
                .attr("tabindex", "-1")
                .before(this.container)
                .on("click.select2", killEvent); // do not leak click events

            this.container.data("select2", this);

            this.dropdown = this.container.find(".select2-drop");

            syncCssClasses(this.dropdown, this.opts.element, this.opts.adaptDropdownCssClass);

            this.dropdown.addClass(evaluate(opts.dropdownCssClass, this.opts.element));
            this.dropdown.data("select2", this);
            this.dropdown.on("click", killEvent);

            this.results = results = this.container.find(resultsSelector);
            this.search = search = this.container.find("input.select2-input");

            this.queryCount = 0;
            this.resultsPage = 0;
            this.context = null;

            // initialize the container
            this.initContainer();

            this.container.on("click", killEvent);

            installFilteredMouseMove(this.results);

            this.dropdown.on("mousemove-filtered", resultsSelector, this.bind(this.highlightUnderEvent));
            this.dropdown.on("touchstart touchmove touchend", resultsSelector, this.bind(function (event) {
                this._touchEvent = true;
                this.highlightUnderEvent(event);
            }));
            this.dropdown.on("touchmove", resultsSelector, this.bind(this.touchMoved));
            this.dropdown.on("touchstart touchend", resultsSelector, this.bind(this.clearTouchMoved));

            // Waiting for a click event on touch devices to select option and hide dropdown
            // otherwise click will be triggered on an underlying element
            this.dropdown.on('click', this.bind(function (event) {
                if (this._touchEvent) {
                    this._touchEvent = false;
                    this.selectHighlighted();
                }
            }));

            installDebouncedScroll(80, this.results);
            this.dropdown.on("scroll-debounced", resultsSelector, this.bind(this.loadMoreIfNeeded));

            // do not propagate change event from the search field out of the component
            $(this.container).on("change", ".select2-input", function(e) {e.stopPropagation();});
            $(this.dropdown).on("change", ".select2-input", function(e) {e.stopPropagation();});

            // if jquery.mousewheel plugin is installed we can prevent out-of-bounds scrolling of results via mousewheel
            if ($.fn.mousewheel) {
                results.mousewheel(function (e, delta, deltaX, deltaY) {
                    var top = results.scrollTop();
                    if (deltaY > 0 && top - deltaY <= 0) {
                        results.scrollTop(0);
                        killEvent(e);
                    } else if (deltaY < 0 && results.get(0).scrollHeight - results.scrollTop() + deltaY <= results.height()) {
                        results.scrollTop(results.get(0).scrollHeight - results.height());
                        killEvent(e);
                    }
                });
            }

            installKeyUpChangeEvent(search);
            search.on("keyup-change input paste", this.bind(this.updateResults));
            search.on("focus", function () { search.addClass("select2-focused"); });
            search.on("blur", function () { search.removeClass("select2-focused");});

            this.dropdown.on("mouseup", resultsSelector, this.bind(function (e) {
                if ($(e.target).closest(".select2-result-selectable").length > 0) {
                    this.highlightUnderEvent(e);
                    this.selectHighlighted(e);
                }
            }));

            // trap all mouse events from leaving the dropdown. sometimes there may be a modal that is listening
            // for mouse events outside of itself so it can close itself. since the dropdown is now outside the select2's
            // dom it will trigger the popup close, which is not what we want
            // focusin can cause focus wars between modals and select2 since the dropdown is outside the modal.
            this.dropdown.on("click mouseup mousedown touchstart touchend focusin", function (e) { e.stopPropagation(); });

            this.nextSearchTerm = undefined;

            if ($.isFunction(this.opts.initSelection)) {
                // initialize selection based on the current value of the source element
                this.initSelection();

                // if the user has provided a function that can set selection based on the value of the source element
                // we monitor the change event on the element and trigger it, allowing for two way synchronization
                this.monitorSource();
            }

            if (opts.maximumInputLength !== null) {
                this.search.attr("maxlength", opts.maximumInputLength);
            }

            var disabled = opts.element.prop("disabled");
            if (disabled === undefined) disabled = false;
            this.enable(!disabled);

            var readonly = opts.element.prop("readonly");
            if (readonly === undefined) readonly = false;
            this.readonly(readonly);

            // Calculate size of scrollbar
            scrollBarDimensions = scrollBarDimensions || measureScrollbar();

            this.autofocus = opts.element.prop("autofocus");
            opts.element.prop("autofocus", false);
            if (this.autofocus) this.focus();

            this.search.attr("placeholder", opts.searchInputPlaceholder);
        },

        // abstract
        destroy: function () {
            var element=this.opts.element, select2 = element.data("select2"), self = this;

            this.close();

            if (element.length && element[0].detachEvent && self._sync) {
                element.each(function () {
                    if (self._sync) {
                        this.detachEvent("onpropertychange", self._sync);
                    }
                });
            }
            if (this.propertyObserver) {
                this.propertyObserver.disconnect();
                this.propertyObserver = null;
            }
            this._sync = null;

            if (select2 !== undefined) {
                select2.container.remove();
                select2.liveRegion.remove();
                select2.dropdown.remove();
                element
                    .show()
                    .removeData("select2")
                    .off(".select2")
                    .prop("autofocus", this.autofocus || false);
                if (this.elementTabIndex) {
                    element.attr({tabindex: this.elementTabIndex});
                } else {
                    element.removeAttr("tabindex");
                }
                element.show();
            }

            cleanupJQueryElements.call(this,
                "container",
                "liveRegion",
                "dropdown",
                "results",
                "search"
            );
        },

        // abstract
        optionToData: function(element) {
            if (element.is("option")) {
                return {
                    id:element.prop("value"),
                    text:element.text(),
                    element: element.get(),
                    css: element.attr("class"),
                    disabled: element.prop("disabled"),
                    locked: equal(element.attr("locked"), "locked") || equal(element.data("locked"), true)
                };
            } else if (element.is("optgroup")) {
                return {
                    text:element.attr("label"),
                    children:[],
                    element: element.get(),
                    css: element.attr("class")
                };
            }
        },

        // abstract
        prepareOpts: function (opts) {
            var element, select, idKey, ajaxUrl, self = this;

            element = opts.element;

            if (element.get(0).tagName.toLowerCase() === "select") {
                this.select = select = opts.element;
            }

            if (select) {
                // these options are not allowed when attached to a select because they are picked up off the element itself
                $.each(["id", "multiple", "ajax", "query", "createSearchChoice", "initSelection", "data", "tags"], function () {
                    if (this in opts) {
                        throw new Error("Option '" + this + "' is not allowed for Select2 when attached to a <select> element.");
                    }
                });
            }

            opts = $.extend({}, {
                populateResults: function(container, results, query) {
                    var populate, id=this.opts.id, liveRegion=this.liveRegion;

                    populate=function(results, container, depth) {

                        var i, l, result, selectable, disabled, compound, node, label, innerContainer, formatted;

                        results = opts.sortResults(results, container, query);

                        // collect the created nodes for bulk append
                        var nodes = [];
                        for (i = 0, l = results.length; i < l; i = i + 1) {

                            result=results[i];

                            disabled = (result.disabled === true);
                            selectable = (!disabled) && (id(result) !== undefined);

                            compound=result.children && result.children.length > 0;

                            node=$("<li></li>");
                            node.addClass("select2-results-dept-"+depth);
                            node.addClass("select2-result");
                            node.addClass(selectable ? "select2-result-selectable" : "select2-result-unselectable");
                            if (disabled) { node.addClass("select2-disabled"); }
                            if (compound) { node.addClass("select2-result-with-children"); }
                            node.addClass(self.opts.formatResultCssClass(result));
                            node.attr("role", "presentation");

                            label=$(document.createElement("div"));
                            label.addClass("select2-result-label");
                            label.attr("id", "select2-result-label-" + nextUid());
                            label.attr("role", "option");

                            formatted=opts.formatResult(result, label, query, self.opts.escapeMarkup);
                            if (formatted!==undefined) {
                                label.html(formatted);
                                node.append(label);
                            }


                            if (compound) {

                                innerContainer=$("<ul></ul>");
                                innerContainer.addClass("select2-result-sub");
                                populate(result.children, innerContainer, depth+1);
                                node.append(innerContainer);
                            }

                            node.data("select2-data", result);
                            nodes.push(node[0]);
                        }

                        // bulk append the created nodes
                        container.append(nodes);
                        liveRegion.text(opts.formatMatches(results.length));
                    };

                    populate(results, container, 0);
                }
            }, $.fn.select2.defaults, opts);

            if (typeof(opts.id) !== "function") {
                idKey = opts.id;
                opts.id = function (e) { return e[idKey]; };
            }

            if ($.isArray(opts.element.data("select2Tags"))) {
                if ("tags" in opts) {
                    throw "tags specified as both an attribute 'data-select2-tags' and in options of Select2 " + opts.element.attr("id");
                }
                opts.tags=opts.element.data("select2Tags");
            }

            if (select) {
                opts.query = this.bind(function (query) {
                    var data = { results: [], more: false },
                        term = query.term,
                        children, placeholderOption, process;

                    process=function(element, collection) {
                        var group;
                        if (element.is("option")) {
                            if (query.matcher(term, element.text(), element)) {
                                collection.push(self.optionToData(element));
                            }
                        } else if (element.is("optgroup")) {
                            group=self.optionToData(element);
                            element.children().each2(function(i, elm) { process(elm, group.children); });
                            if (group.children.length>0) {
                                collection.push(group);
                            }
                        }
                    };

                    children=element.children();

                    // ignore the placeholder option if there is one
                    if (this.getPlaceholder() !== undefined && children.length > 0) {
                        placeholderOption = this.getPlaceholderOption();
                        if (placeholderOption) {
                            children=children.not(placeholderOption);
                        }
                    }

                    children.each2(function(i, elm) { process(elm, data.results); });

                    query.callback(data);
                });
                // this is needed because inside val() we construct choices from options and their id is hardcoded
                opts.id=function(e) { return e.id; };
            } else {
                if (!("query" in opts)) {

                    if ("ajax" in opts) {
                        ajaxUrl = opts.element.data("ajax-url");
                        if (ajaxUrl && ajaxUrl.length > 0) {
                            opts.ajax.url = ajaxUrl;
                        }
                        opts.query = ajax.call(opts.element, opts.ajax);
                    } else if ("data" in opts) {
                        opts.query = local(opts.data);
                    } else if ("tags" in opts) {
                        opts.query = tags(opts.tags);
                        if (opts.createSearchChoice === undefined) {
                            opts.createSearchChoice = function (term) { return {id: $.trim(term), text: $.trim(term)}; };
                        }
                        if (opts.initSelection === undefined) {
                            opts.initSelection = function (element, callback) {
                                var data = [];
                                $(splitVal(element.val(), opts.separator, opts.transformVal)).each(function () {
                                    var obj = { id: this, text: this },
                                        tags = opts.tags;
                                    if ($.isFunction(tags)) tags=tags();
                                    $(tags).each(function() { if (equal(this.id, obj.id)) { obj = this; return false; } });
                                    data.push(obj);
                                });

                                callback(data);
                            };
                        }
                    }
                }
            }
            if (typeof(opts.query) !== "function") {
                throw "query function not defined for Select2 " + opts.element.attr("id");
            }

            if (opts.createSearchChoicePosition === 'top') {
                opts.createSearchChoicePosition = function(list, item) { list.unshift(item); };
            }
            else if (opts.createSearchChoicePosition === 'bottom') {
                opts.createSearchChoicePosition = function(list, item) { list.push(item); };
            }
            else if (typeof(opts.createSearchChoicePosition) !== "function")  {
                throw "invalid createSearchChoicePosition option must be 'top', 'bottom' or a custom function";
            }

            return opts;
        },

        /**
         * Monitor the original element for changes and update select2 accordingly
         */
        // abstract
        monitorSource: function () {
            var el = this.opts.element, observer, self = this;

            el.on("change.select2", this.bind(function (e) {
                if (this.opts.element.data("select2-change-triggered") !== true) {
                    this.initSelection();
                }
            }));

            this._sync = this.bind(function () {

                // sync enabled state
                var disabled = el.prop("disabled");
                if (disabled === undefined) disabled = false;
                this.enable(!disabled);

                var readonly = el.prop("readonly");
                if (readonly === undefined) readonly = false;
                this.readonly(readonly);

                if (this.container) {
                    syncCssClasses(this.container, this.opts.element, this.opts.adaptContainerCssClass);
                    this.container.addClass(evaluate(this.opts.containerCssClass, this.opts.element));
                }

                if (this.dropdown) {
                    syncCssClasses(this.dropdown, this.opts.element, this.opts.adaptDropdownCssClass);
                    this.dropdown.addClass(evaluate(this.opts.dropdownCssClass, this.opts.element));
                }

            });

            // IE8-10 (IE9/10 won't fire propertyChange via attachEventListener)
            if (el.length && el[0].attachEvent) {
                el.each(function() {
                    this.attachEvent("onpropertychange", self._sync);
                });
            }

            // safari, chrome, firefox, IE11
            observer = window.MutationObserver || window.WebKitMutationObserver|| window.MozMutationObserver;
            if (observer !== undefined) {
                if (this.propertyObserver) { delete this.propertyObserver; this.propertyObserver = null; }
                this.propertyObserver = new observer(function (mutations) {
                    $.each(mutations, self._sync);
                });
                this.propertyObserver.observe(el.get(0), { attributes:true, subtree:false });
            }
        },

        // abstract
        triggerSelect: function(data) {
            var evt = $.Event("select2-selecting", { val: this.id(data), object: data, choice: data });
            this.opts.element.trigger(evt);
            return !evt.isDefaultPrevented();
        },

        /**
         * Triggers the change event on the source element
         */
        // abstract
        triggerChange: function (details) {

            details = details || {};
            details= $.extend({}, details, { type: "change", val: this.val() });
            // prevents recursive triggering
            this.opts.element.data("select2-change-triggered", true);
            this.opts.element.trigger(details);
            this.opts.element.data("select2-change-triggered", false);

            // some validation frameworks ignore the change event and listen instead to keyup, click for selects
            // so here we trigger the click event manually
            this.opts.element.click();

            // ValidationEngine ignores the change event and listens instead to blur
            // so here we trigger the blur event manually if so desired
            if (this.opts.blurOnChange)
                this.opts.element.blur();
        },

        //abstract
        isInterfaceEnabled: function()
        {
            return this.enabledInterface === true;
        },

        // abstract
        enableInterface: function() {
            var enabled = this._enabled && !this._readonly,
                disabled = !enabled;

            if (enabled === this.enabledInterface) return false;

            this.container.toggleClass("select2-container-disabled", disabled);
            this.close();
            this.enabledInterface = enabled;

            return true;
        },

        // abstract
        enable: function(enabled) {
            if (enabled === undefined) enabled = true;
            if (this._enabled === enabled) return;
            this._enabled = enabled;

            this.opts.element.prop("disabled", !enabled);
            this.enableInterface();
        },

        // abstract
        disable: function() {
            this.enable(false);
        },

        // abstract
        readonly: function(enabled) {
            if (enabled === undefined) enabled = false;
            if (this._readonly === enabled) return;
            this._readonly = enabled;

            this.opts.element.prop("readonly", enabled);
            this.enableInterface();
        },

        // abstract
        opened: function () {
            return (this.container) ? this.container.hasClass("select2-dropdown-open") : false;
        },

        // abstract
        positionDropdown: function() {
            var $dropdown = this.dropdown,
                container = this.container,
                offset = container.offset(),
                height = container.outerHeight(false),
                width = container.outerWidth(false),
                dropHeight = $dropdown.outerHeight(false),
                $window = $(window),
                windowWidth = $window.width(),
                windowHeight = $window.height(),
                viewPortRight = $window.scrollLeft() + windowWidth,
                viewportBottom = $window.scrollTop() + windowHeight,
                dropTop = offset.top + height,
                dropLeft = offset.left,
                enoughRoomBelow = dropTop + dropHeight <= viewportBottom,
                enoughRoomAbove = (offset.top - dropHeight) >= $window.scrollTop(),
                dropWidth = $dropdown.outerWidth(false),
                enoughRoomOnRight = function() {
                    return dropLeft + dropWidth <= viewPortRight;
                },
                enoughRoomOnLeft = function() {
                    return offset.left + viewPortRight + container.outerWidth(false)  > dropWidth;
                },
                aboveNow = $dropdown.hasClass("select2-drop-above"),
                bodyOffset,
                above,
                changeDirection,
                css,
                resultsListNode;

            // always prefer the current above/below alignment, unless there is not enough room
            if (aboveNow) {
                above = true;
                if (!enoughRoomAbove && enoughRoomBelow) {
                    changeDirection = true;
                    above = false;
                }
            } else {
                above = false;
                if (!enoughRoomBelow && enoughRoomAbove) {
                    changeDirection = true;
                    above = true;
                }
            }

            //if we are changing direction we need to get positions when dropdown is hidden;
            if (changeDirection) {
                $dropdown.hide();
                offset = this.container.offset();
                height = this.container.outerHeight(false);
                width = this.container.outerWidth(false);
                dropHeight = $dropdown.outerHeight(false);
                viewPortRight = $window.scrollLeft() + windowWidth;
                viewportBottom = $window.scrollTop() + windowHeight;
                dropTop = offset.top + height;
                dropLeft = offset.left;
                dropWidth = $dropdown.outerWidth(false);
                $dropdown.show();

                // fix so the cursor does not move to the left within the search-textbox in IE
                this.focusSearch();
            }

            if (this.opts.dropdownAutoWidth) {
                resultsListNode = $('.select2-results', $dropdown)[0];
                $dropdown.addClass('select2-drop-auto-width');
                $dropdown.css('width', '');
                // Add scrollbar width to dropdown if vertical scrollbar is present
                dropWidth = $dropdown.outerWidth(false) + (resultsListNode.scrollHeight === resultsListNode.clientHeight ? 0 : scrollBarDimensions.width);
                dropWidth > width ? width = dropWidth : dropWidth = width;
                dropHeight = $dropdown.outerHeight(false);
            }
            else {
                this.container.removeClass('select2-drop-auto-width');
            }

            //console.log("below/ droptop:", dropTop, "dropHeight", dropHeight, "sum", (dropTop+dropHeight)+" viewport bottom", viewportBottom, "enough?", enoughRoomBelow);
            //console.log("above/ offset.top", offset.top, "dropHeight", dropHeight, "top", (offset.top-dropHeight), "scrollTop", this.body.scrollTop(), "enough?", enoughRoomAbove);

            // fix positioning when body has an offset and is not position: static
            if (this.body.css('position') !== 'static') {
                bodyOffset = this.body.offset();
                dropTop -= bodyOffset.top;
                dropLeft -= bodyOffset.left;
            }

            if (!enoughRoomOnRight() && enoughRoomOnLeft()) {
                dropLeft = offset.left + this.container.outerWidth(false) - dropWidth;
            }

            css =  {
                left: dropLeft,
                width: width
            };

            if (above) {
                css.top = offset.top - dropHeight;
                css.bottom = 'auto';
                this.container.addClass("select2-drop-above");
                $dropdown.addClass("select2-drop-above");
            }
            else {
                css.top = dropTop;
                css.bottom = 'auto';
                this.container.removeClass("select2-drop-above");
                $dropdown.removeClass("select2-drop-above");
            }
            css = $.extend(css, evaluate(this.opts.dropdownCss, this.opts.element));

            $dropdown.css(css);
        },

        // abstract
        shouldOpen: function() {
            var event;

            if (this.opened()) return false;

            if (this._enabled === false || this._readonly === true) return false;

            event = $.Event("select2-opening");
            this.opts.element.trigger(event);
            return !event.isDefaultPrevented();
        },

        // abstract
        clearDropdownAlignmentPreference: function() {
            // clear the classes used to figure out the preference of where the dropdown should be opened
            this.container.removeClass("select2-drop-above");
            this.dropdown.removeClass("select2-drop-above");
        },

        /**
         * Opens the dropdown
         *
         * @return {Boolean} whether or not dropdown was opened. This method will return false if, for example,
         * the dropdown is already open, or if the 'open' event listener on the element called preventDefault().
         */
        // abstract
        open: function () {

            if (!this.shouldOpen()) return false;

            this.opening();

            // Only bind the document mousemove when the dropdown is visible
            $document.on("mousemove.select2Event", function (e) {
                lastMousePosition.x = e.pageX;
                lastMousePosition.y = e.pageY;
            });

            return true;
        },

        /**
         * Performs the opening of the dropdown
         */
        // abstract
        opening: function() {
            var cid = this.containerEventName,
                scroll = "scroll." + cid,
                resize = "resize."+cid,
                orient = "orientationchange."+cid,
                mask;

            this.container.addClass("select2-dropdown-open").addClass("select2-container-active");

            this.clearDropdownAlignmentPreference();

            if(this.dropdown[0] !== this.body.children().last()[0]) {
                this.dropdown.detach().appendTo(this.body);
            }

            // create the dropdown mask if doesn't already exist
            mask = $("#select2-drop-mask");
            if (mask.length === 0) {
                mask = $(document.createElement("div"));
                mask.attr("id","select2-drop-mask").attr("class","select2-drop-mask");
                mask.hide();
                mask.appendTo(this.body);
                mask.on("mousedown touchstart click", function (e) {
                    // Prevent IE from generating a click event on the body
                    reinsertElement(mask);

                    var dropdown = $("#select2-drop"), self;
                    if (dropdown.length > 0) {
                        self=dropdown.data("select2");
                        if (self.opts.selectOnBlur) {
                            self.selectHighlighted({noFocus: true});
                        }
                        self.close();
                        e.preventDefault();
                        e.stopPropagation();
                    }
                });
            }

            // ensure the mask is always right before the dropdown
            if (this.dropdown.prev()[0] !== mask[0]) {
                this.dropdown.before(mask);
            }

            // move the global id to the correct dropdown
            $("#select2-drop").removeAttr("id");
            this.dropdown.attr("id", "select2-drop");

            // show the elements
            mask.show();

            this.positionDropdown();
            this.dropdown.show();
            this.positionDropdown();

            this.dropdown.addClass("select2-drop-active");

            // attach listeners to events that can change the position of the container and thus require
            // the position of the dropdown to be updated as well so it does not come unglued from the container
            var that = this;
            this.container.parents().add(window).each(function () {
                $(this).on(resize+" "+scroll+" "+orient, function (e) {
                    if (that.opened()) that.positionDropdown();
                });
            });


        },

        // abstract
        close: function () {
            if (!this.opened()) return;

            var cid = this.containerEventName,
                scroll = "scroll." + cid,
                resize = "resize."+cid,
                orient = "orientationchange."+cid;

            // unbind event listeners
            this.container.parents().add(window).each(function () { $(this).off(scroll).off(resize).off(orient); });

            this.clearDropdownAlignmentPreference();

            $("#select2-drop-mask").hide();
            this.dropdown.removeAttr("id"); // only the active dropdown has the select2-drop id
            this.dropdown.hide();
            this.container.removeClass("select2-dropdown-open").removeClass("select2-container-active");
            this.results.empty();

            // Now that the dropdown is closed, unbind the global document mousemove event
            $document.off("mousemove.select2Event");

            this.clearSearch();
            this.search.removeClass("select2-active");
            this.opts.element.trigger($.Event("select2-close"));
        },

        /**
         * Opens control, sets input value, and updates results.
         */
        // abstract
        externalSearch: function (term) {
            this.open();
            this.search.val(term);
            this.updateResults(false);
        },

        // abstract
        clearSearch: function () {

        },

        //abstract
        getMaximumSelectionSize: function() {
            return evaluate(this.opts.maximumSelectionSize, this.opts.element);
        },

        // abstract
        ensureHighlightVisible: function () {
            var results = this.results, children, index, child, hb, rb, y, more, topOffset;

            index = this.highlight();

            if (index < 0) return;

            if (index == 0) {

                // if the first element is highlighted scroll all the way to the top,
                // that way any unselectable headers above it will also be scrolled
                // into view

                results.scrollTop(0);
                return;
            }

            children = this.findHighlightableChoices().find('.select2-result-label');

            child = $(children[index]);

            topOffset = (child.offset() || {}).top || 0;

            hb = topOffset + child.outerHeight(true);

            // if this is the last child lets also make sure select2-more-results is visible
            if (index === children.length - 1) {
                more = results.find("li.select2-more-results");
                if (more.length > 0) {
                    hb = more.offset().top + more.outerHeight(true);
                }
            }

            rb = results.offset().top + results.outerHeight(false);
            if (hb > rb) {
                results.scrollTop(results.scrollTop() + (hb - rb));
            }
            y = topOffset - results.offset().top;

            // make sure the top of the element is visible
            if (y < 0 && child.css('display') != 'none' ) {
                results.scrollTop(results.scrollTop() + y); // y is negative
            }
        },

        // abstract
        findHighlightableChoices: function() {
            return this.results.find(".select2-result-selectable:not(.select2-disabled):not(.select2-selected)");
        },

        // abstract
        moveHighlight: function (delta) {
            var choices = this.findHighlightableChoices(),
                index = this.highlight();

            while (index > -1 && index < choices.length) {
                index += delta;
                var choice = $(choices[index]);
                if (choice.hasClass("select2-result-selectable") && !choice.hasClass("select2-disabled") && !choice.hasClass("select2-selected")) {
                    this.highlight(index);
                    break;
                }
            }
        },

        // abstract
        highlight: function (index) {
            var choices = this.findHighlightableChoices(),
                choice,
                data;

            if (arguments.length === 0) {
                return indexOf(choices.filter(".select2-highlighted")[0], choices.get());
            }

            if (index >= choices.length) index = choices.length - 1;
            if (index < 0) index = 0;

            this.removeHighlight();

            choice = $(choices[index]);
            choice.addClass("select2-highlighted");

            // ensure assistive technology can determine the active choice
            this.search.attr("aria-activedescendant", choice.find(".select2-result-label").attr("id"));

            this.ensureHighlightVisible();

            this.liveRegion.text(choice.text());

            data = choice.data("select2-data");
            if (data) {
                this.opts.element.trigger({ type: "select2-highlight", val: this.id(data), choice: data });
            }
        },

        removeHighlight: function() {
            this.results.find(".select2-highlighted").removeClass("select2-highlighted");
        },

        touchMoved: function() {
            this._touchMoved = true;
        },

        clearTouchMoved: function() {
          this._touchMoved = false;
        },

        // abstract
        countSelectableResults: function() {
            return this.findHighlightableChoices().length;
        },

        // abstract
        highlightUnderEvent: function (event) {
            var el = $(event.target).closest(".select2-result-selectable");
            if (el.length > 0 && !el.is(".select2-highlighted")) {
                var choices = this.findHighlightableChoices();
                this.highlight(choices.index(el));
            } else if (el.length == 0) {
                // if we are over an unselectable item remove all highlights
                this.removeHighlight();
            }
        },

        // abstract
        loadMoreIfNeeded: function () {
            var results = this.results,
                more = results.find("li.select2-more-results"),
                below, // pixels the element is below the scroll fold, below==0 is when the element is starting to be visible
                page = this.resultsPage + 1,
                self=this,
                term=this.search.val(),
                context=this.context;

            if (more.length === 0) return;
            below = more.offset().top - results.offset().top - results.height();

            if (below <= this.opts.loadMorePadding) {
                more.addClass("select2-active");
                this.opts.query({
                        element: this.opts.element,
                        term: term,
                        page: page,
                        context: context,
                        matcher: this.opts.matcher,
                        callback: this.bind(function (data) {

                    // ignore a response if the select2 has been closed before it was received
                    if (!self.opened()) return;


                    self.opts.populateResults.call(this, results, data.results, {term: term, page: page, context:context});
                    self.postprocessResults(data, false, false);

                    if (data.more===true) {
                        more.detach().appendTo(results).html(self.opts.escapeMarkup(evaluate(self.opts.formatLoadMore, self.opts.element, page+1)));
                        window.setTimeout(function() { self.loadMoreIfNeeded(); }, 10);
                    } else {
                        more.remove();
                    }
                    self.positionDropdown();
                    self.resultsPage = page;
                    self.context = data.context;
                    this.opts.element.trigger({ type: "select2-loaded", items: data });
                })});
            }
        },

        /**
         * Default tokenizer function which does nothing
         */
        tokenize: function() {

        },

        /**
         * @param initial whether or not this is the call to this method right after the dropdown has been opened
         */
        // abstract
        updateResults: function (initial) {
            var search = this.search,
                results = this.results,
                opts = this.opts,
                data,
                self = this,
                input,
                term = search.val(),
                lastTerm = $.data(this.container, "select2-last-term"),
                // sequence number used to drop out-of-order responses
                queryNumber;

            // prevent duplicate queries against the same term
            if (initial !== true && lastTerm && equal(term, lastTerm)) return;

            $.data(this.container, "select2-last-term", term);

            // if the search is currently hidden we do not alter the results
            if (initial !== true && (this.showSearchInput === false || !this.opened())) {
                return;
            }

            function postRender() {
                search.removeClass("select2-active");
                self.positionDropdown();
                if (results.find('.select2-no-results,.select2-selection-limit,.select2-searching').length) {
                    self.liveRegion.text(results.text());
                }
                else {
                    self.liveRegion.text(self.opts.formatMatches(results.find('.select2-result-selectable:not(".select2-selected")').length));
                }
            }

            function render(html) {
                results.html(html);
                postRender();
            }

            queryNumber = ++this.queryCount;

            var maxSelSize = this.getMaximumSelectionSize();
            if (maxSelSize >=1) {
                data = this.data();
                if ($.isArray(data) && data.length >= maxSelSize && checkFormatter(opts.formatSelectionTooBig, "formatSelectionTooBig")) {
                    render("<li class='select2-selection-limit'>" + evaluate(opts.formatSelectionTooBig, opts.element, maxSelSize) + "</li>");
                    return;
                }
            }

            if (search.val().length < opts.minimumInputLength) {
                if (checkFormatter(opts.formatInputTooShort, "formatInputTooShort")) {
                    render("<li class='select2-no-results'>" + evaluate(opts.formatInputTooShort, opts.element, search.val(), opts.minimumInputLength) + "</li>");
                } else {
                    render("");
                }
                if (initial && this.showSearch) this.showSearch(true);
                return;
            }

            if (opts.maximumInputLength && search.val().length > opts.maximumInputLength) {
                if (checkFormatter(opts.formatInputTooLong, "formatInputTooLong")) {
                    render("<li class='select2-no-results'>" + evaluate(opts.formatInputTooLong, opts.element, search.val(), opts.maximumInputLength) + "</li>");
                } else {
                    render("");
                }
                return;
            }

            if (opts.formatSearching && this.findHighlightableChoices().length === 0) {
                render("<li class='select2-searching'>" + evaluate(opts.formatSearching, opts.element) + "</li>");
            }

            search.addClass("select2-active");

            this.removeHighlight();

            // give the tokenizer a chance to pre-process the input
            input = this.tokenize();
            if (input != undefined && input != null) {
                search.val(input);
            }

            this.resultsPage = 1;

            opts.query({
                element: opts.element,
                    term: search.val(),
                    page: this.resultsPage,
                    context: null,
                    matcher: opts.matcher,
                    callback: this.bind(function (data) {
                var def; // default choice

                // ignore old responses
                if (queryNumber != this.queryCount) {
                  return;
                }

                // ignore a response if the select2 has been closed before it was received
                if (!this.opened()) {
                    this.search.removeClass("select2-active");
                    return;
                }

                // handle ajax error
                if(data.hasError !== undefined && checkFormatter(opts.formatAjaxError, "formatAjaxError")) {
                    render("<li class='select2-ajax-error'>" + evaluate(opts.formatAjaxError, opts.element, data.jqXHR, data.textStatus, data.errorThrown) + "</li>");
                    return;
                }

                // save context, if any
                this.context = (data.context===undefined) ? null : data.context;
                // create a default choice and prepend it to the list
                if (this.opts.createSearchChoice && search.val() !== "") {
                    def = this.opts.createSearchChoice.call(self, search.val(), data.results);
                    if (def !== undefined && def !== null && self.id(def) !== undefined && self.id(def) !== null) {
                        if ($(data.results).filter(
                            function () {
                                return equal(self.id(this), self.id(def));
                            }).length === 0) {
                            this.opts.createSearchChoicePosition(data.results, def);
                        }
                    }
                }

                if (data.results.length === 0 && checkFormatter(opts.formatNoMatches, "formatNoMatches")) {
                    render("<li class='select2-no-results'>" + evaluate(opts.formatNoMatches, opts.element, search.val()) + "</li>");
                    return;
                }

                results.empty();
                self.opts.populateResults.call(this, results, data.results, {term: search.val(), page: this.resultsPage, context:null});

                if (data.more === true && checkFormatter(opts.formatLoadMore, "formatLoadMore")) {
                    results.append("<li class='select2-more-results'>" + opts.escapeMarkup(evaluate(opts.formatLoadMore, opts.element, this.resultsPage)) + "</li>");
                    window.setTimeout(function() { self.loadMoreIfNeeded(); }, 10);
                }

                this.postprocessResults(data, initial);

                postRender();

                this.opts.element.trigger({ type: "select2-loaded", items: data });
            })});
        },

        // abstract
        cancel: function () {
            this.close();
        },

        // abstract
        blur: function () {
            // if selectOnBlur == true, select the currently highlighted option
            if (this.opts.selectOnBlur)
                this.selectHighlighted({noFocus: true});

            this.close();
            this.container.removeClass("select2-container-active");
            // synonymous to .is(':focus'), which is available in jquery >= 1.6
            if (this.search[0] === document.activeElement) { this.search.blur(); }
            this.clearSearch();
            this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
        },

        // abstract
        focusSearch: function () {
            focus(this.search);
        },

        // abstract
        selectHighlighted: function (options) {
            if (this._touchMoved) {
              this.clearTouchMoved();
              return;
            }
            var index=this.highlight(),
                highlighted=this.results.find(".select2-highlighted"),
                data = highlighted.closest('.select2-result').data("select2-data");

            if (data) {
                this.highlight(index);
                this.onSelect(data, options);
            } else if (options && options.noFocus) {
                this.close();
            }
        },

        // abstract
        getPlaceholder: function () {
            var placeholderOption;
            return this.opts.element.attr("placeholder") ||
                this.opts.element.attr("data-placeholder") || // jquery 1.4 compat
                this.opts.element.data("placeholder") ||
                this.opts.placeholder ||
                ((placeholderOption = this.getPlaceholderOption()) !== undefined ? placeholderOption.text() : undefined);
        },

        // abstract
        getPlaceholderOption: function() {
            if (this.select) {
                var firstOption = this.select.children('option').first();
                if (this.opts.placeholderOption !== undefined ) {
                    //Determine the placeholder option based on the specified placeholderOption setting
                    return (this.opts.placeholderOption === "first" && firstOption) ||
                           (typeof this.opts.placeholderOption === "function" && this.opts.placeholderOption(this.select));
                } else if ($.trim(firstOption.text()) === "" && firstOption.val() === "") {
                    //No explicit placeholder option specified, use the first if it's blank
                    return firstOption;
                }
            }
        },

        /**
         * Get the desired width for the container element.  This is
         * derived first from option `width` passed to select2, then
         * the inline 'style' on the original element, and finally
         * falls back to the jQuery calculated element width.
         */
        // abstract
        initContainerWidth: function () {
            function resolveContainerWidth() {
                var style, attrs, matches, i, l, attr;

                if (this.opts.width === "off") {
                    return null;
                } else if (this.opts.width === "element"){
                    return this.opts.element.outerWidth(false) === 0 ? 'auto' : this.opts.element.outerWidth(false) + 'px';
                } else if (this.opts.width === "copy" || this.opts.width === "resolve") {
                    // check if there is inline style on the element that contains width
                    style = this.opts.element.attr('style');
                    if (style !== undefined) {
                        attrs = style.split(';');
                        for (i = 0, l = attrs.length; i < l; i = i + 1) {
                            attr = attrs[i].replace(/\s/g, '');
                            matches = attr.match(/^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i);
                            if (matches !== null && matches.length >= 1)
                                return matches[1];
                        }
                    }

                    if (this.opts.width === "resolve") {
                        // next check if css('width') can resolve a width that is percent based, this is sometimes possible
                        // when attached to input type=hidden or elements hidden via css
                        style = this.opts.element.css('width');
                        if (style.indexOf("%") > 0) return style;

                        // finally, fallback on the calculated width of the element
                        return (this.opts.element.outerWidth(false) === 0 ? 'auto' : this.opts.element.outerWidth(false) + 'px');
                    }

                    return null;
                } else if ($.isFunction(this.opts.width)) {
                    return this.opts.width();
                } else {
                    return this.opts.width;
               }
            };

            var width = resolveContainerWidth.call(this);
            if (width !== null) {
                this.container.css("width", width);
            }
        }
    });

    SingleSelect2 = clazz(AbstractSelect2, {

        // single

        createContainer: function () {
            var container = $(document.createElement("div")).attr({
                "class": "select2-container"
            }).html([
                "<a href='javascript:void(0)' class='select2-choice' tabindex='-1'>",
                "   <span class='select2-chosen'>&#160;</span><abbr class='select2-search-choice-close'></abbr>",
                "   <span class='select2-arrow' role='presentation'><b role='presentation'></b></span>",
                "</a>",
                "<label for='' class='select2-offscreen'></label>",
                "<input class='select2-focusser select2-offscreen' type='text' aria-haspopup='true' role='button' />",
                "<div class='select2-drop select2-display-none'>",
                "   <div class='select2-search'>",
                "       <label for='' class='select2-offscreen'></label>",
                "       <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='select2-input' role='combobox' aria-expanded='true'",
                "       aria-autocomplete='list' />",
                "   </div>",
                "   <ul class='select2-results' role='listbox'>",
                "   </ul>",
                "</div>"].join(""));
            return container;
        },

        // single
        enableInterface: function() {
            if (this.parent.enableInterface.apply(this, arguments)) {
                this.focusser.prop("disabled", !this.isInterfaceEnabled());
            }
        },

        // single
        opening: function () {
            var el, range, len;

            if (this.opts.minimumResultsForSearch >= 0) {
                this.showSearch(true);
            }

            this.parent.opening.apply(this, arguments);

            if (this.showSearchInput !== false) {
                // IE appends focusser.val() at the end of field :/ so we manually insert it at the beginning using a range
                // all other browsers handle this just fine

                this.search.val(this.focusser.val());
            }
            if (this.opts.shouldFocusInput(this)) {
                this.search.focus();
                // move the cursor to the end after focussing, otherwise it will be at the beginning and
                // new text will appear *before* focusser.val()
                el = this.search.get(0);
                if (el.createTextRange) {
                    range = el.createTextRange();
                    range.collapse(false);
                    range.select();
                } else if (el.setSelectionRange) {
                    len = this.search.val().length;
                    el.setSelectionRange(len, len);
                }
            }

            // initializes search's value with nextSearchTerm (if defined by user)
            // ignore nextSearchTerm if the dropdown is opened by the user pressing a letter
            if(this.search.val() === "") {
                if(this.nextSearchTerm != undefined){
                    this.search.val(this.nextSearchTerm);
                    this.search.select();
                }
            }

            this.focusser.prop("disabled", true).val("");
            this.updateResults(true);
            this.opts.element.trigger($.Event("select2-open"));
        },

        // single
        close: function () {
            if (!this.opened()) return;
            this.parent.close.apply(this, arguments);

            this.focusser.prop("disabled", false);

            if (this.opts.shouldFocusInput(this)) {
                this.focusser.focus();
            }
        },

        // single
        focus: function () {
            if (this.opened()) {
                this.close();
            } else {
                this.focusser.prop("disabled", false);
                if (this.opts.shouldFocusInput(this)) {
                    this.focusser.focus();
                }
            }
        },

        // single
        isFocused: function () {
            return this.container.hasClass("select2-container-active");
        },

        // single
        cancel: function () {
            this.parent.cancel.apply(this, arguments);
            this.focusser.prop("disabled", false);

            if (this.opts.shouldFocusInput(this)) {
                this.focusser.focus();
            }
        },

        // single
        destroy: function() {
            $("label[for='" + this.focusser.attr('id') + "']")
                .attr('for', this.opts.element.attr("id"));
            this.parent.destroy.apply(this, arguments);

            cleanupJQueryElements.call(this,
                "selection",
                "focusser"
            );
        },

        // single
        initContainer: function () {

            var selection,
                container = this.container,
                dropdown = this.dropdown,
                idSuffix = nextUid(),
                elementLabel;

            if (this.opts.minimumResultsForSearch < 0) {
                this.showSearch(false);
            } else {
                this.showSearch(true);
            }

            this.selection = selection = container.find(".select2-choice");

            this.focusser = container.find(".select2-focusser");

            // add aria associations
            selection.find(".select2-chosen").attr("id", "select2-chosen-"+idSuffix);
            this.focusser.attr("aria-labelledby", "select2-chosen-"+idSuffix);
            this.results.attr("id", "select2-results-"+idSuffix);
            this.search.attr("aria-owns", "select2-results-"+idSuffix);

            // rewrite labels from original element to focusser
            this.focusser.attr("id", "s2id_autogen"+idSuffix);

            elementLabel = $("label[for='" + this.opts.element.attr("id") + "']");
            this.opts.element.focus(this.bind(function () { this.focus(); }));

            this.focusser.prev()
                .text(elementLabel.text())
                .attr('for', this.focusser.attr('id'));

            // Ensure the original element retains an accessible name
            var originalTitle = this.opts.element.attr("title");
            this.opts.element.attr("title", (originalTitle || elementLabel.text()));

            this.focusser.attr("tabindex", this.elementTabIndex);

            // write label for search field using the label from the focusser element
            this.search.attr("id", this.focusser.attr('id') + '_search');

            this.search.prev()
                .text($("label[for='" + this.focusser.attr('id') + "']").text())
                .attr('for', this.search.attr('id'));

            this.search.on("keydown", this.bind(function (e) {
                if (!this.isInterfaceEnabled()) return;

                // filter 229 keyCodes (input method editor is processing key input)
                if (229 == e.keyCode) return;

                if (e.which === KEY.PAGE_UP || e.which === KEY.PAGE_DOWN) {
                    // prevent the page from scrolling
                    killEvent(e);
                    return;
                }

                switch (e.which) {
                    case KEY.UP:
                    case KEY.DOWN:
                        this.moveHighlight((e.which === KEY.UP) ? -1 : 1);
                        killEvent(e);
                        return;
                    case KEY.ENTER:
                        this.selectHighlighted();
                        killEvent(e);
                        return;
                    case KEY.TAB:
                        this.selectHighlighted({noFocus: true});
                        return;
                    case KEY.ESC:
                        this.cancel(e);
                        killEvent(e);
                        return;
                }
            }));

            this.search.on("blur", this.bind(function(e) {
                // a workaround for chrome to keep the search field focussed when the scroll bar is used to scroll the dropdown.
                // without this the search field loses focus which is annoying
                if (document.activeElement === this.body.get(0)) {
                    window.setTimeout(this.bind(function() {
                        if (this.opened()) {
                            this.search.focus();
                        }
                    }), 0);
                }
            }));

            this.focusser.on("keydown", this.bind(function (e) {
                if (!this.isInterfaceEnabled()) return;

                if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC) {
                    return;
                }

                if (this.opts.openOnEnter === false && e.which === KEY.ENTER) {
                    killEvent(e);
                    return;
                }

                if (e.which == KEY.DOWN || e.which == KEY.UP
                    || (e.which == KEY.ENTER && this.opts.openOnEnter)) {

                    if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) return;

                    this.open();
                    killEvent(e);
                    return;
                }

                if (e.which == KEY.DELETE || e.which == KEY.BACKSPACE) {
                    if (this.opts.allowClear) {
                        this.clear();
                    }
                    killEvent(e);
                    return;
                }
            }));


            installKeyUpChangeEvent(this.focusser);
            this.focusser.on("keyup-change input", this.bind(function(e) {
                if (this.opts.minimumResultsForSearch >= 0) {
                    e.stopPropagation();
                    if (this.opened()) return;
                    this.open();
                }
            }));

            selection.on("mousedown touchstart", "abbr", this.bind(function (e) {
                if (!this.isInterfaceEnabled()) {
                    return;
                }

                this.clear();
                killEventImmediately(e);
                this.close();

                if (this.selection) {
                    this.selection.focus();
                }
            }));

            selection.on("mousedown touchstart", this.bind(function (e) {
                // Prevent IE from generating a click event on the body
                reinsertElement(selection);

                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }

                if (this.opened()) {
                    this.close();
                } else if (this.isInterfaceEnabled()) {
                    this.open();
                }

                killEvent(e);
            }));

            dropdown.on("mousedown touchstart", this.bind(function() {
                if (this.opts.shouldFocusInput(this)) {
                    this.search.focus();
                }
            }));

            selection.on("focus", this.bind(function(e) {
                killEvent(e);
            }));

            this.focusser.on("focus", this.bind(function(){
                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }
                this.container.addClass("select2-container-active");
            })).on("blur", this.bind(function() {
                if (!this.opened()) {
                    this.container.removeClass("select2-container-active");
                    this.opts.element.trigger($.Event("select2-blur"));
                }
            }));
            this.search.on("focus", this.bind(function(){
                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }
                this.container.addClass("select2-container-active");
            }));

            this.initContainerWidth();
            this.opts.element.hide();
            this.setPlaceholder();

        },

        // single
        clear: function(triggerChange) {
            var data=this.selection.data("select2-data");
            if (data) { // guard against queued quick consecutive clicks
                var evt = $.Event("select2-clearing");
                this.opts.element.trigger(evt);
                if (evt.isDefaultPrevented()) {
                    return;
                }
                var placeholderOption = this.getPlaceholderOption();
                this.opts.element.val(placeholderOption ? placeholderOption.val() : "");
                this.selection.find(".select2-chosen").empty();
                this.selection.removeData("select2-data");
                this.setPlaceholder();

                if (triggerChange !== false){
                    this.opts.element.trigger({ type: "select2-removed", val: this.id(data), choice: data });
                    this.triggerChange({removed:data});
                }
            }
        },

        /**
         * Sets selection based on source element's value
         */
        // single
        initSelection: function () {
            var selected;
            if (this.isPlaceholderOptionSelected()) {
                this.updateSelection(null);
                this.close();
                this.setPlaceholder();
            } else {
                var self = this;
                this.opts.initSelection.call(null, this.opts.element, function(selected){
                    if (selected !== undefined && selected !== null) {
                        self.updateSelection(selected);
                        self.close();
                        self.setPlaceholder();
                        self.nextSearchTerm = self.opts.nextSearchTerm(selected, self.search.val());
                    }
                });
            }
        },

        isPlaceholderOptionSelected: function() {
            var placeholderOption;
            if (this.getPlaceholder() === undefined) return false; // no placeholder specified so no option should be considered
            return ((placeholderOption = this.getPlaceholderOption()) !== undefined && placeholderOption.prop("selected"))
                || (this.opts.element.val() === "")
                || (this.opts.element.val() === undefined)
                || (this.opts.element.val() === null);
        },

        // single
        prepareOpts: function () {
            var opts = this.parent.prepareOpts.apply(this, arguments),
                self=this;

            if (opts.element.get(0).tagName.toLowerCase() === "select") {
                // install the selection initializer
                opts.initSelection = function (element, callback) {
                    var selected = element.find("option").filter(function() { return this.selected && !this.disabled });
                    // a single select box always has a value, no need to null check 'selected'
                    callback(self.optionToData(selected));
                };
            } else if ("data" in opts) {
                // install default initSelection when applied to hidden input and data is local
                opts.initSelection = opts.initSelection || function (element, callback) {
                    var id = element.val();
                    //search in data by id, storing the actual matching item
                    var match = null;
                    opts.query({
                        matcher: function(term, text, el){
                            var is_match = equal(id, opts.id(el));
                            if (is_match) {
                                match = el;
                            }
                            return is_match;
                        },
                        callback: !$.isFunction(callback) ? $.noop : function() {
                            callback(match);
                        }
                    });
                };
            }

            return opts;
        },

        // single
        getPlaceholder: function() {
            // if a placeholder is specified on a single select without a valid placeholder option ignore it
            if (this.select) {
                if (this.getPlaceholderOption() === undefined) {
                    return undefined;
                }
            }

            return this.parent.getPlaceholder.apply(this, arguments);
        },

        // single
        setPlaceholder: function () {
            var placeholder = this.getPlaceholder();

            if (this.isPlaceholderOptionSelected() && placeholder !== undefined) {

                // check for a placeholder option if attached to a select
                if (this.select && this.getPlaceholderOption() === undefined) return;

                this.selection.find(".select2-chosen").html(this.opts.escapeMarkup(placeholder));

                this.selection.addClass("select2-default");

                this.container.removeClass("select2-allowclear");
            }
        },

        // single
        postprocessResults: function (data, initial, noHighlightUpdate) {
            var selected = 0, self = this, showSearchInput = true;

            // find the selected element in the result list

            this.findHighlightableChoices().each2(function (i, elm) {
                if (equal(self.id(elm.data("select2-data")), self.opts.element.val())) {
                    selected = i;
                    return false;
                }
            });

            // and highlight it
            if (noHighlightUpdate !== false) {
                if (initial === true && selected >= 0) {
                    this.highlight(selected);
                } else {
                    this.highlight(0);
                }
            }

            // hide the search box if this is the first we got the results and there are enough of them for search

            if (initial === true) {
                var min = this.opts.minimumResultsForSearch;
                if (min >= 0) {
                    this.showSearch(countResults(data.results) >= min);
                }
            }
        },

        // single
        showSearch: function(showSearchInput) {
            if (this.showSearchInput === showSearchInput) return;

            this.showSearchInput = showSearchInput;

            this.dropdown.find(".select2-search").toggleClass("select2-search-hidden", !showSearchInput);
            this.dropdown.find(".select2-search").toggleClass("select2-offscreen", !showSearchInput);
            //add "select2-with-searchbox" to the container if search box is shown
            $(this.dropdown, this.container).toggleClass("select2-with-searchbox", showSearchInput);
        },

        // single
        onSelect: function (data, options) {

            if (!this.triggerSelect(data)) { return; }

            var old = this.opts.element.val(),
                oldData = this.data();

            this.opts.element.val(this.id(data));
            this.updateSelection(data);

            this.opts.element.trigger({ type: "select2-selected", val: this.id(data), choice: data });

            this.nextSearchTerm = this.opts.nextSearchTerm(data, this.search.val());
            this.close();

            if ((!options || !options.noFocus) && this.opts.shouldFocusInput(this)) {
                this.focusser.focus();
            }

            if (!equal(old, this.id(data))) {
                this.triggerChange({ added: data, removed: oldData });
            }
        },

        // single
        updateSelection: function (data) {

            var container=this.selection.find(".select2-chosen"), formatted, cssClass;

            this.selection.data("select2-data", data);

            container.empty();
            if (data !== null) {
                formatted=this.opts.formatSelection(data, container, this.opts.escapeMarkup);
            }
            if (formatted !== undefined) {
                container.append(formatted);
            }
            cssClass=this.opts.formatSelectionCssClass(data, container);
            if (cssClass !== undefined) {
                container.addClass(cssClass);
            }

            this.selection.removeClass("select2-default");

            if (this.opts.allowClear && this.getPlaceholder() !== undefined) {
                this.container.addClass("select2-allowclear");
            }
        },

        // single
        val: function () {
            var val,
                triggerChange = false,
                data = null,
                self = this,
                oldData = this.data();

            if (arguments.length === 0) {
                return this.opts.element.val();
            }

            val = arguments[0];

            if (arguments.length > 1) {
                triggerChange = arguments[1];
            }

            if (this.select) {
                this.select
                    .val(val)
                    .find("option").filter(function() { return this.selected }).each2(function (i, elm) {
                        data = self.optionToData(elm);
                        return false;
                    });
                this.updateSelection(data);
                this.setPlaceholder();
                if (triggerChange) {
                    this.triggerChange({added: data, removed:oldData});
                }
            } else {
                // val is an id. !val is true for [undefined,null,'',0] - 0 is legal
                if (!val && val !== 0) {
                    this.clear(triggerChange);
                    return;
                }
                if (this.opts.initSelection === undefined) {
                    throw new Error("cannot call val() if initSelection() is not defined");
                }
                this.opts.element.val(val);
                this.opts.initSelection(this.opts.element, function(data){
                    self.opts.element.val(!data ? "" : self.id(data));
                    self.updateSelection(data);
                    self.setPlaceholder();
                    if (triggerChange) {
                        self.triggerChange({added: data, removed:oldData});
                    }
                });
            }
        },

        // single
        clearSearch: function () {
            this.search.val("");
            this.focusser.val("");
        },

        // single
        data: function(value) {
            var data,
                triggerChange = false;

            if (arguments.length === 0) {
                data = this.selection.data("select2-data");
                if (data == undefined) data = null;
                return data;
            } else {
                if (arguments.length > 1) {
                    triggerChange = arguments[1];
                }
                if (!value) {
                    this.clear(triggerChange);
                } else {
                    data = this.data();
                    this.opts.element.val(!value ? "" : this.id(value));
                    this.updateSelection(value);
                    if (triggerChange) {
                        this.triggerChange({added: value, removed:data});
                    }
                }
            }
        }
    });

    MultiSelect2 = clazz(AbstractSelect2, {

        // multi
        createContainer: function () {
            var container = $(document.createElement("div")).attr({
                "class": "select2-container select2-container-multi"
            }).html([
                "<ul class='select2-choices'>",
                "  <li class='select2-search-field'>",
                "    <label for='' class='select2-offscreen'></label>",
                "    <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='select2-input'>",
                "  </li>",
                "</ul>",
                "<div class='select2-drop select2-drop-multi select2-display-none'>",
                "   <ul class='select2-results'>",
                "   </ul>",
                "</div>"].join(""));
            return container;
        },

        // multi
        prepareOpts: function () {
            var opts = this.parent.prepareOpts.apply(this, arguments),
                self=this;

            // TODO validate placeholder is a string if specified
            if (opts.element.get(0).tagName.toLowerCase() === "select") {
                // install the selection initializer
                opts.initSelection = function (element, callback) {

                    var data = [];

                    element.find("option").filter(function() { return this.selected && !this.disabled }).each2(function (i, elm) {
                        data.push(self.optionToData(elm));
                    });
                    callback(data);
                };
            } else if ("data" in opts) {
                // install default initSelection when applied to hidden input and data is local
                opts.initSelection = opts.initSelection || function (element, callback) {
                    var ids = splitVal(element.val(), opts.separator, opts.transformVal);
                    //search in data by array of ids, storing matching items in a list
                    var matches = [];
                    opts.query({
                        matcher: function(term, text, el){
                            var is_match = $.grep(ids, function(id) {
                                return equal(id, opts.id(el));
                            }).length;
                            if (is_match) {
                                matches.push(el);
                            }
                            return is_match;
                        },
                        callback: !$.isFunction(callback) ? $.noop : function() {
                            // reorder matches based on the order they appear in the ids array because right now
                            // they are in the order in which they appear in data array
                            var ordered = [];
                            for (var i = 0; i < ids.length; i++) {
                                var id = ids[i];
                                for (var j = 0; j < matches.length; j++) {
                                    var match = matches[j];
                                    if (equal(id, opts.id(match))) {
                                        ordered.push(match);
                                        matches.splice(j, 1);
                                        break;
                                    }
                                }
                            }
                            callback(ordered);
                        }
                    });
                };
            }

            return opts;
        },

        // multi
        selectChoice: function (choice) {

            var selected = this.container.find(".select2-search-choice-focus");
            if (selected.length && choice && choice[0] == selected[0]) {

            } else {
                if (selected.length) {
                    this.opts.element.trigger("choice-deselected", selected);
                }
                selected.removeClass("select2-search-choice-focus");
                if (choice && choice.length) {
                    this.close();
                    choice.addClass("select2-search-choice-focus");
                    this.opts.element.trigger("choice-selected", choice);
                }
            }
        },

        // multi
        destroy: function() {
            $("label[for='" + this.search.attr('id') + "']")
                .attr('for', this.opts.element.attr("id"));
            this.parent.destroy.apply(this, arguments);

            cleanupJQueryElements.call(this,
                "searchContainer",
                "selection"
            );
        },

        // multi
        initContainer: function () {

            var selector = ".select2-choices", selection;

            this.searchContainer = this.container.find(".select2-search-field");
            this.selection = selection = this.container.find(selector);

            var _this = this;
            this.selection.on("click", ".select2-container:not(.select2-container-disabled) .select2-search-choice:not(.select2-locked)", function (e) {
                _this.search[0].focus();
                _this.selectChoice($(this));
            });

            // rewrite labels from original element to focusser
            this.search.attr("id", "s2id_autogen"+nextUid());

            this.search.prev()
                .text($("label[for='" + this.opts.element.attr("id") + "']").text())
                .attr('for', this.search.attr('id'));
            this.opts.element.focus(this.bind(function () { this.focus(); }));

            this.search.on("input paste", this.bind(function() {
                if (this.search.attr('placeholder') && this.search.val().length == 0) return;
                if (!this.isInterfaceEnabled()) return;
                if (!this.opened()) {
                    this.open();
                }
            }));

            this.search.attr("tabindex", this.elementTabIndex);

            this.keydowns = 0;
            this.search.on("keydown", this.bind(function (e) {
                if (!this.isInterfaceEnabled()) return;

                ++this.keydowns;
                var selected = selection.find(".select2-search-choice-focus");
                var prev = selected.prev(".select2-search-choice:not(.select2-locked)");
                var next = selected.next(".select2-search-choice:not(.select2-locked)");
                var pos = getCursorInfo(this.search);

                if (selected.length &&
                    (e.which == KEY.LEFT || e.which == KEY.RIGHT || e.which == KEY.BACKSPACE || e.which == KEY.DELETE || e.which == KEY.ENTER)) {
                    var selectedChoice = selected;
                    if (e.which == KEY.LEFT && prev.length) {
                        selectedChoice = prev;
                    }
                    else if (e.which == KEY.RIGHT) {
                        selectedChoice = next.length ? next : null;
                    }
                    else if (e.which === KEY.BACKSPACE) {
                        if (this.unselect(selected.first())) {
                            this.search.width(10);
                            selectedChoice = prev.length ? prev : next;
                        }
                    } else if (e.which == KEY.DELETE) {
                        if (this.unselect(selected.first())) {
                            this.search.width(10);
                            selectedChoice = next.length ? next : null;
                        }
                    } else if (e.which == KEY.ENTER) {
                        selectedChoice = null;
                    }

                    this.selectChoice(selectedChoice);
                    killEvent(e);
                    if (!selectedChoice || !selectedChoice.length) {
                        this.open();
                    }
                    return;
                } else if (((e.which === KEY.BACKSPACE && this.keydowns == 1)
                    || e.which == KEY.LEFT) && (pos.offset == 0 && !pos.length)) {

                    this.selectChoice(selection.find(".select2-search-choice:not(.select2-locked)").last());
                    killEvent(e);
                    return;
                } else {
                    this.selectChoice(null);
                }

                if (this.opened()) {
                    switch (e.which) {
                    case KEY.UP:
                    case KEY.DOWN:
                        this.moveHighlight((e.which === KEY.UP) ? -1 : 1);
                        killEvent(e);
                        return;
                    case KEY.ENTER:
                        this.selectHighlighted();
                        killEvent(e);
                        return;
                    case KEY.TAB:
                        this.selectHighlighted({noFocus:true});
                        this.close();
                        return;
                    case KEY.ESC:
                        this.cancel(e);
                        killEvent(e);
                        return;
                    }
                }

                if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e)
                 || e.which === KEY.BACKSPACE || e.which === KEY.ESC) {
                    return;
                }

                if (e.which === KEY.ENTER) {
                    if (this.opts.openOnEnter === false) {
                        return;
                    } else if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) {
                        return;
                    }
                }

                this.open();

                if (e.which === KEY.PAGE_UP || e.which === KEY.PAGE_DOWN) {
                    // prevent the page from scrolling
                    killEvent(e);
                }

                if (e.which === KEY.ENTER) {
                    // prevent form from being submitted
                    killEvent(e);
                }

            }));

            this.search.on("keyup", this.bind(function (e) {
                this.keydowns = 0;
                this.resizeSearch();
            })
            );

            this.search.on("blur", this.bind(function(e) {
                this.container.removeClass("select2-container-active");
                this.search.removeClass("select2-focused");
                this.selectChoice(null);
                if (!this.opened()) this.clearSearch();
                e.stopImmediatePropagation();
                this.opts.element.trigger($.Event("select2-blur"));
            }));

            this.container.on("click", selector, this.bind(function (e) {
                if (!this.isInterfaceEnabled()) return;
                if ($(e.target).closest(".select2-search-choice").length > 0) {
                    // clicked inside a select2 search choice, do not open
                    return;
                }
                this.selectChoice(null);
                this.clearPlaceholder();
                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }
                this.open();
                this.focusSearch();
                e.preventDefault();
            }));

            this.container.on("focus", selector, this.bind(function () {
                if (!this.isInterfaceEnabled()) return;
                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }
                this.container.addClass("select2-container-active");
                this.dropdown.addClass("select2-drop-active");
                this.clearPlaceholder();
            }));

            this.initContainerWidth();
            this.opts.element.hide();

            // set the placeholder if necessary
            this.clearSearch();
        },

        // multi
        enableInterface: function() {
            if (this.parent.enableInterface.apply(this, arguments)) {
                this.search.prop("disabled", !this.isInterfaceEnabled());
            }
        },

        // multi
        initSelection: function () {
            var data;
            if (this.opts.element.val() === "" && this.opts.element.text() === "") {
                this.updateSelection([]);
                this.close();
                // set the placeholder if necessary
                this.clearSearch();
            }
            if (this.select || this.opts.element.val() !== "") {
                var self = this;
                this.opts.initSelection.call(null, this.opts.element, function(data){
                    if (data !== undefined && data !== null) {
                        self.updateSelection(data);
                        self.close();
                        // set the placeholder if necessary
                        self.clearSearch();
                    }
                });
            }
        },

        // multi
        clearSearch: function () {
            var placeholder = this.getPlaceholder(),
                maxWidth = this.getMaxSearchWidth();

            if (placeholder !== undefined  && this.getVal().length === 0 && this.search.hasClass("select2-focused") === false) {
                this.search.val(placeholder).addClass("select2-default");
                // stretch the search box to full width of the container so as much of the placeholder is visible as possible
                // we could call this.resizeSearch(), but we do not because that requires a sizer and we do not want to create one so early because of a firefox bug, see #944
                this.search.width(maxWidth > 0 ? maxWidth : this.container.css("width"));
            } else {
                this.search.val("").width(10);
            }
        },

        // multi
        clearPlaceholder: function () {
            if (this.search.hasClass("select2-default")) {
                this.search.val("").removeClass("select2-default");
            }
        },

        // multi
        opening: function () {
            this.clearPlaceholder(); // should be done before super so placeholder is not used to search
            this.resizeSearch();

            this.parent.opening.apply(this, arguments);

            this.focusSearch();

            // initializes search's value with nextSearchTerm (if defined by user)
            // ignore nextSearchTerm if the dropdown is opened by the user pressing a letter
            if(this.search.val() === "") {
                if(this.nextSearchTerm != undefined){
                    this.search.val(this.nextSearchTerm);
                    this.search.select();
                }
            }

            this.updateResults(true);
            if (this.opts.shouldFocusInput(this)) {
                this.search.focus();
            }
            this.opts.element.trigger($.Event("select2-open"));
        },

        // multi
        close: function () {
            if (!this.opened()) return;
            this.parent.close.apply(this, arguments);
        },

        // multi
        focus: function () {
            this.close();
            this.search.focus();
        },

        // multi
        isFocused: function () {
            return this.search.hasClass("select2-focused");
        },

        // multi
        updateSelection: function (data) {
            var ids = [], filtered = [], self = this;

            // filter out duplicates
            $(data).each(function () {
                if (indexOf(self.id(this), ids) < 0) {
                    ids.push(self.id(this));
                    filtered.push(this);
                }
            });
            data = filtered;

            this.selection.find(".select2-search-choice").remove();
            $(data).each(function () {
                self.addSelectedChoice(this);
            });
            self.postprocessResults();
        },

        // multi
        tokenize: function() {
            var input = this.search.val();
            input = this.opts.tokenizer.call(this, input, this.data(), this.bind(this.onSelect), this.opts);
            if (input != null && input != undefined) {
                this.search.val(input);
                if (input.length > 0) {
                    this.open();
                }
            }

        },

        // multi
        onSelect: function (data, options) {

            if (!this.triggerSelect(data) || data.text === "") { return; }

            this.addSelectedChoice(data);

            this.opts.element.trigger({ type: "selected", val: this.id(data), choice: data });

            // keep track of the search's value before it gets cleared
            this.nextSearchTerm = this.opts.nextSearchTerm(data, this.search.val());

            this.clearSearch();
            this.updateResults();

            if (this.select || !this.opts.closeOnSelect) this.postprocessResults(data, false, this.opts.closeOnSelect===true);

            if (this.opts.closeOnSelect) {
                this.close();
                this.search.width(10);
            } else {
                if (this.countSelectableResults()>0) {
                    this.search.width(10);
                    this.resizeSearch();
                    if (this.getMaximumSelectionSize() > 0 && this.val().length >= this.getMaximumSelectionSize()) {
                        // if we reached max selection size repaint the results so choices
                        // are replaced with the max selection reached message
                        this.updateResults(true);
                    } else {
                        // initializes search's value with nextSearchTerm and update search result
                        if(this.nextSearchTerm != undefined){
                            this.search.val(this.nextSearchTerm);
                            this.updateResults();
                            this.search.select();
                        }
                    }
                    this.positionDropdown();
                } else {
                    // if nothing left to select close
                    this.close();
                    this.search.width(10);
                }
            }

            // since its not possible to select an element that has already been
            // added we do not need to check if this is a new element before firing change
            this.triggerChange({ added: data });

            if (!options || !options.noFocus)
                this.focusSearch();
        },

        // multi
        cancel: function () {
            this.close();
            this.focusSearch();
        },

        addSelectedChoice: function (data) {
            var enableChoice = !data.locked,
                enabledItem = $(
                    "<li class='select2-search-choice'>" +
                    "    <div></div>" +
                    "    <a href='#' class='select2-search-choice-close' tabindex='-1'></a>" +
                    "</li>"),
                disabledItem = $(
                    "<li class='select2-search-choice select2-locked'>" +
                    "<div></div>" +
                    "</li>");
            var choice = enableChoice ? enabledItem : disabledItem,
                id = this.id(data),
                val = this.getVal(),
                formatted,
                cssClass;

            formatted=this.opts.formatSelection(data, choice.find("div"), this.opts.escapeMarkup);
            if (formatted != undefined) {
                choice.find("div").replaceWith($("<div></div>").html(formatted));
            }
            cssClass=this.opts.formatSelectionCssClass(data, choice.find("div"));
            if (cssClass != undefined) {
                choice.addClass(cssClass);
            }

            if(enableChoice){
              choice.find(".select2-search-choice-close")
                  .on("mousedown", killEvent)
                  .on("click dblclick", this.bind(function (e) {
                  if (!this.isInterfaceEnabled()) return;

                  this.unselect($(e.target));
                  this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
                  killEvent(e);
                  this.close();
                  this.focusSearch();
              })).on("focus", this.bind(function () {
                  if (!this.isInterfaceEnabled()) return;
                  this.container.addClass("select2-container-active");
                  this.dropdown.addClass("select2-drop-active");
              }));
            }

            choice.data("select2-data", data);
            choice.insertBefore(this.searchContainer);

            val.push(id);
            this.setVal(val);
        },

        // multi
        unselect: function (selected) {
            var val = this.getVal(),
                data,
                index;
            selected = selected.closest(".select2-search-choice");

            if (selected.length === 0) {
                throw "Invalid argument: " + selected + ". Must be .select2-search-choice";
            }

            data = selected.data("select2-data");

            if (!data) {
                // prevent a race condition when the 'x' is clicked really fast repeatedly the event can be queued
                // and invoked on an element already removed
                return;
            }

            var evt = $.Event("select2-removing");
            evt.val = this.id(data);
            evt.choice = data;
            this.opts.element.trigger(evt);

            if (evt.isDefaultPrevented()) {
                return false;
            }

            while((index = indexOf(this.id(data), val)) >= 0) {
                val.splice(index, 1);
                this.setVal(val);
                if (this.select) this.postprocessResults();
            }

            selected.remove();

            this.opts.element.trigger({ type: "select2-removed", val: this.id(data), choice: data });
            this.triggerChange({ removed: data });

            return true;
        },

        // multi
        postprocessResults: function (data, initial, noHighlightUpdate) {
            var val = this.getVal(),
                choices = this.results.find(".select2-result"),
                compound = this.results.find(".select2-result-with-children"),
                self = this;

            choices.each2(function (i, choice) {
                var id = self.id(choice.data("select2-data"));
                if (indexOf(id, val) >= 0) {
                    choice.addClass("select2-selected");
                    // mark all children of the selected parent as selected
                    choice.find(".select2-result-selectable").addClass("select2-selected");
                }
            });

            compound.each2(function(i, choice) {
                // hide an optgroup if it doesn't have any selectable children
                if (!choice.is('.select2-result-selectable')
                    && choice.find(".select2-result-selectable:not(.select2-selected)").length === 0) {
                    choice.addClass("select2-selected");
                }
            });

            if (this.highlight() == -1 && noHighlightUpdate !== false && this.opts.closeOnSelect === true){
                self.highlight(0);
            }

            //If all results are chosen render formatNoMatches
            if(!this.opts.createSearchChoice && !choices.filter('.select2-result:not(.select2-selected)').length > 0){
                if(!data || data && !data.more && this.results.find(".select2-no-results").length === 0) {
                    if (checkFormatter(self.opts.formatNoMatches, "formatNoMatches")) {
                        this.results.append("<li class='select2-no-results'>" + evaluate(self.opts.formatNoMatches, self.opts.element, self.search.val()) + "</li>");
                    }
                }
            }

        },

        // multi
        getMaxSearchWidth: function() {
            return this.selection.width() - getSideBorderPadding(this.search);
        },

        // multi
        resizeSearch: function () {
            var minimumWidth, left, maxWidth, containerLeft, searchWidth,
                sideBorderPadding = getSideBorderPadding(this.search);

            minimumWidth = measureTextWidth(this.search) + 10;

            left = this.search.offset().left;

            maxWidth = this.selection.width();
            containerLeft = this.selection.offset().left;

            searchWidth = maxWidth - (left - containerLeft) - sideBorderPadding;

            if (searchWidth < minimumWidth) {
                searchWidth = maxWidth - sideBorderPadding;
            }

            if (searchWidth < 40) {
                searchWidth = maxWidth - sideBorderPadding;
            }

            if (searchWidth <= 0) {
              searchWidth = minimumWidth;
            }

            this.search.width(Math.floor(searchWidth));
        },

        // multi
        getVal: function () {
            var val;
            if (this.select) {
                val = this.select.val();
                return val === null ? [] : val;
            } else {
                val = this.opts.element.val();
                return splitVal(val, this.opts.separator, this.opts.transformVal);
            }
        },

        // multi
        setVal: function (val) {
            var unique;
            if (this.select) {
                this.select.val(val);
            } else {
                unique = [];
                // filter out duplicates
                $(val).each(function () {
                    if (indexOf(this, unique) < 0) unique.push(this);
                });
                this.opts.element.val(unique.length === 0 ? "" : unique.join(this.opts.separator));
            }
        },

        // multi
        buildChangeDetails: function (old, current) {
            var current = current.slice(0),
                old = old.slice(0);

            // remove intersection from each array
            for (var i = 0; i < current.length; i++) {
                for (var j = 0; j < old.length; j++) {
                    if (equal(this.opts.id(current[i]), this.opts.id(old[j]))) {
                        current.splice(i, 1);
                        if(i>0){
                            i--;
                        }
                        old.splice(j, 1);
                        j--;
                    }
                }
            }

            return {added: current, removed: old};
        },


        // multi
        val: function (val, triggerChange) {
            var oldData, self=this;

            if (arguments.length === 0) {
                return this.getVal();
            }

            oldData=this.data();
            if (!oldData.length) oldData=[];

            // val is an id. !val is true for [undefined,null,'',0] - 0 is legal
            if (!val && val !== 0) {
                this.opts.element.val("");
                this.updateSelection([]);
                this.clearSearch();
                if (triggerChange) {
                    this.triggerChange({added: this.data(), removed: oldData});
                }
                return;
            }

            // val is a list of ids
            this.setVal(val);

            if (this.select) {
                this.opts.initSelection(this.select, this.bind(this.updateSelection));
                if (triggerChange) {
                    this.triggerChange(this.buildChangeDetails(oldData, this.data()));
                }
            } else {
                if (this.opts.initSelection === undefined) {
                    throw new Error("val() cannot be called if initSelection() is not defined");
                }

                this.opts.initSelection(this.opts.element, function(data){
                    var ids=$.map(data, self.id);
                    self.setVal(ids);
                    self.updateSelection(data);
                    self.clearSearch();
                    if (triggerChange) {
                        self.triggerChange(self.buildChangeDetails(oldData, self.data()));
                    }
                });
            }
            this.clearSearch();
        },

        // multi
        onSortStart: function() {
            if (this.select) {
                throw new Error("Sorting of elements is not supported when attached to <select>. Attach to <input type='hidden'/> instead.");
            }

            // collapse search field into 0 width so its container can be collapsed as well
            this.search.width(0);
            // hide the container
            this.searchContainer.hide();
        },

        // multi
        onSortEnd:function() {

            var val=[], self=this;

            // show search and move it to the end of the list
            this.searchContainer.show();
            // make sure the search container is the last item in the list
            this.searchContainer.appendTo(this.searchContainer.parent());
            // since we collapsed the width in dragStarted, we resize it here
            this.resizeSearch();

            // update selection
            this.selection.find(".select2-search-choice").each(function() {
                val.push(self.opts.id($(this).data("select2-data")));
            });
            this.setVal(val);
            this.triggerChange();
        },

        // multi
        data: function(values, triggerChange) {
            var self=this, ids, old;
            if (arguments.length === 0) {
                 return this.selection
                     .children(".select2-search-choice")
                     .map(function() { return $(this).data("select2-data"); })
                     .get();
            } else {
                old = this.data();
                if (!values) { values = []; }
                ids = $.map(values, function(e) { return self.opts.id(e); });
                this.setVal(ids);
                this.updateSelection(values);
                this.clearSearch();
                if (triggerChange) {
                    this.triggerChange(this.buildChangeDetails(old, this.data()));
                }
            }
        }
    });

    $.fn.select2 = function () {

        var args = Array.prototype.slice.call(arguments, 0),
            opts,
            select2,
            method, value, multiple,
            allowedMethods = ["val", "destroy", "opened", "open", "close", "focus", "isFocused", "container", "dropdown", "onSortStart", "onSortEnd", "enable", "disable", "readonly", "positionDropdown", "data", "search"],
            valueMethods = ["opened", "isFocused", "container", "dropdown"],
            propertyMethods = ["val", "data"],
            methodsMap = { search: "externalSearch" };

        this.each(function () {
            if (args.length === 0 || typeof(args[0]) === "object") {
                opts = args.length === 0 ? {} : $.extend({}, args[0]);
                opts.element = $(this);

                if (opts.element.get(0).tagName.toLowerCase() === "select") {
                    multiple = opts.element.prop("multiple");
                } else {
                    multiple = opts.multiple || false;
                    if ("tags" in opts) {opts.multiple = multiple = true;}
                }

                select2 = multiple ? new window.Select2["class"].multi() : new window.Select2["class"].single();
                select2.init(opts);
            } else if (typeof(args[0]) === "string") {

                if (indexOf(args[0], allowedMethods) < 0) {
                    throw "Unknown method: " + args[0];
                }

                value = undefined;
                select2 = $(this).data("select2");
                if (select2 === undefined) return;

                method=args[0];

                if (method === "container") {
                    value = select2.container;
                } else if (method === "dropdown") {
                    value = select2.dropdown;
                } else {
                    if (methodsMap[method]) method = methodsMap[method];

                    value = select2[method].apply(select2, args.slice(1));
                }
                if (indexOf(args[0], valueMethods) >= 0
                    || (indexOf(args[0], propertyMethods) >= 0 && args.length == 1)) {
                    return false; // abort the iteration, ready to return first matched value
                }
            } else {
                throw "Invalid arguments to select2 plugin: " + args;
            }
        });
        return (value === undefined) ? this : value;
    };

    // plugin defaults, accessible to users
    $.fn.select2.defaults = {
        width: "copy",
        loadMorePadding: 0,
        closeOnSelect: true,
        openOnEnter: true,
        containerCss: {},
        dropdownCss: {},
        containerCssClass: "",
        dropdownCssClass: "",
        formatResult: function(result, container, query, escapeMarkup) {
            var markup=[];
            markMatch(this.text(result), query.term, markup, escapeMarkup);
            return markup.join("");
        },
        transformVal: function(val) {
            return $.trim(val);
        },
        formatSelection: function (data, container, escapeMarkup) {
            return data ? escapeMarkup(this.text(data)) : undefined;
        },
        sortResults: function (results, container, query) {
            return results;
        },
        formatResultCssClass: function(data) {return data.css;},
        formatSelectionCssClass: function(data, container) {return undefined;},
        minimumResultsForSearch: 0,
        minimumInputLength: 0,
        maximumInputLength: null,
        maximumSelectionSize: 0,
        id: function (e) { return e == undefined ? null : e.id; },
        text: function (e) {
          if (e && this.data && this.data.text) {
            if ($.isFunction(this.data.text)) {
              return this.data.text(e);
            } else {
              return e[this.data.text];
            }
          } else {
            return e.text;
          }
        },
        matcher: function(term, text) {
            return stripDiacritics(''+text).toUpperCase().indexOf(stripDiacritics(''+term).toUpperCase()) >= 0;
        },
        separator: ",",
        tokenSeparators: [],
        tokenizer: defaultTokenizer,
        escapeMarkup: defaultEscapeMarkup,
        blurOnChange: false,
        selectOnBlur: false,
        adaptContainerCssClass: function(c) { return c; },
        adaptDropdownCssClass: function(c) { return null; },
        nextSearchTerm: function(selectedObject, currentSearchTerm) { return undefined; },
        searchInputPlaceholder: '',
        createSearchChoicePosition: 'top',
        shouldFocusInput: function (instance) {
            // Attempt to detect touch devices
            var supportsTouchEvents = (('ontouchstart' in window) ||
                                       (navigator.msMaxTouchPoints > 0));

            // Only devices which support touch events should be special cased
            if (!supportsTouchEvents) {
                return true;
            }

            // Never focus the input if search is disabled
            if (instance.opts.minimumResultsForSearch < 0) {
                return false;
            }

            return true;
        }
    };

    $.fn.select2.locales = [];

    $.fn.select2.locales['en'] = {
         formatMatches: function (matches) { if (matches === 1) { return "One result is available, press enter to select it."; } return matches + " results are available, use up and down arrow keys to navigate."; },
         formatNoMatches: function () { return "No matches found"; },
         formatAjaxError: function (jqXHR, textStatus, errorThrown) { return "Loading failed"; },
         formatInputTooShort: function (input, min) { var n = min - input.length; return "Please enter " + n + " or more character" + (n == 1 ? "" : "s"); },
         formatInputTooLong: function (input, max) { var n = input.length - max; return "Please delete " + n + " character" + (n == 1 ? "" : "s"); },
         formatSelectionTooBig: function (limit) { return "You can only select " + limit + " item" + (limit == 1 ? "" : "s"); },
         formatLoadMore: function (pageNumber) { return "Loading more results…"; },
         formatSearching: function () { return "Searching…"; }
    };

    $.extend($.fn.select2.defaults, $.fn.select2.locales['en']);

    $.fn.select2.ajaxDefaults = {
        transport: $.ajax,
        params: {
            type: "GET",
            cache: false,
            dataType: "json"
        }
    };

    // exports
    window.Select2 = {
        query: {
            ajax: ajax,
            local: local,
            tags: tags
        }, util: {
            debounce: debounce,
            markMatch: markMatch,
            escapeMarkup: defaultEscapeMarkup,
            stripDiacritics: stripDiacritics
        }, "class": {
            "abstract": AbstractSelect2,
            "single": SingleSelect2,
            "multi": MultiSelect2
        }
    };

}(jQuery));

},{}],158:[function(require,module,exports){
/************************
jquery-timepicker v1.2.15
http://jonthornton.github.com/jquery-timepicker/

requires jQuery 1.7+
************************/


(function (factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['jquery'], factory);
	} else {
		// Browser globals
		factory(jQuery);
	}
}(function ($) {
	var _baseDate = _generateBaseDate();
	var _ONE_DAY = 86400;
	var _defaults =	{
		className: null,
		minTime: null,
		maxTime: null,
		durationTime: null,
		step: 30,
		showDuration: false,
		timeFormat: 'g:ia',
		scrollDefaultNow: false,
		scrollDefaultTime: false,
		selectOnBlur: false,
		disableTouchKeyboard: false,
		forceRoundTime: false,
		appendTo: 'body',
		disableTimeRanges: [],
		closeOnWindowScroll: false,
		disableTextInput: false,
		typeaheadHighlight: true
	};
	var _lang = {
		decimal: '.',
		mins: 'mins',
		hr: 'hr',
		hrs: 'hrs'
	};

	var methods =
	{
		init: function(options)
		{
			return this.each(function()
			{
				var self = $(this);

				// convert dropdowns to text input
				if (self[0].tagName == 'SELECT') {
					var attrs = { 'type': 'text', 'value': self.val() };
					var raw_attrs = self[0].attributes;

					for (var i=0; i < raw_attrs.length; i++) {
						attrs[raw_attrs[i].nodeName] = raw_attrs[i].nodeValue;
					}

					var input = $('<input />', attrs);
					self.replaceWith(input);
					self = input;
				}

				var settings = $.extend({}, _defaults);

				if (options) {
					settings = $.extend(settings, options);
				}

				if (settings.lang) {
					_lang = $.extend(_lang, settings.lang);
				}

				settings = _parseSettings(settings);

				self.data('timepicker-settings', settings);
				self.prop('autocomplete', 'off');
				self.on('click.timepicker focus.timepicker', methods.show);
				self.on('change.timepicker', _formatValue);
				self.on('keydown.timepicker', _keydownhandler);
				self.on('keyup.timepicker', _keyuphandler);
				self.addClass('ui-timepicker-input');

				_formatValue.call(self.get(0));
			});
		},

		show: function(e)
		{
			e.preventDefault();

			var self = $(this);
			var settings = self.data('timepicker-settings');

			if (_hideKeyboard(self)) {
				// block the keyboard on mobile devices
				self.blur();
			}

			var list = self.data('timepicker-list');

			// check if input is readonly
			if (self.prop('readonly')) {
				return;
			}

			// check if list needs to be rendered
			if (!list || list.length === 0 || typeof settings.durationTime === 'function') {
				_render(self);
				list = self.data('timepicker-list');
			}

			if (list.is(':visible')) {
				return;
			}

			// make sure other pickers are hidden
			methods.hide();

			list.show();

			if ((self.offset().top + self.outerHeight(true) + list.outerHeight()) > $(window).height() + $(window).scrollTop()) {
				// position the dropdown on top
				list.offset({
					'left': self.offset().left + parseInt(list.css('marginLeft').replace('px', ''), 10),
					'top': self.offset().top - list.outerHeight() + parseInt(list.css('marginTop').replace('px', ''), 10)
				});
			} else {
				// put it under the input
				list.offset({
					'left':self.offset().left + parseInt(list.css('marginLeft').replace('px', ''), 10),
					'top': self.offset().top + self.outerHeight() + parseInt(list.css('marginTop').replace('px', ''), 10)
				});
			}

			// position scrolling
			var selected = list.find('.ui-timepicker-selected');

			if (!selected.length) {
				if (_getTimeValue(self)) {
					selected = _findRow(self, list, _time2int(_getTimeValue(self)));
				} else if (settings.scrollDefaultNow) {
					selected = _findRow(self, list, _time2int(new Date()));
				} else if (settings.scrollDefaultTime !== false) {
					selected = _findRow(self, list, _time2int(settings.scrollDefaultTime));
				}
			}

			if (selected && selected.length) {
				var topOffset = list.scrollTop() + selected.position().top - selected.outerHeight();
				list.scrollTop(topOffset);
			} else {
				list.scrollTop(0);
			}

			// attach close handlers
			$('body').on('touchstart.ui-timepicker mousedown.ui-timepicker', _closeHandler);
			if (settings.closeOnWindowScroll) {
				$(window).on('scroll.ui-timepicker', _closeHandler);
			}

			self.trigger('showTimepicker');
		},

		hide: function(e)
		{
			$('.ui-timepicker-wrapper:visible').each(function() {
				var list = $(this);
				var self = list.data('timepicker-input');
				var settings = self.data('timepicker-settings');

				if (settings && settings.selectOnBlur) {
					_selectValue(self);
				}

				list.hide();
				self.trigger('hideTimepicker');
			});
		},

		option: function(key, value)
		{
			var self = this;
			var settings = self.data('timepicker-settings');
			var list = self.data('timepicker-list');

			if (typeof key == 'object') {
				settings = $.extend(settings, key);

			} else if (typeof key == 'string' && typeof value != 'undefined') {
				settings[key] = value;

			} else if (typeof key == 'string') {
				return settings[key];
			}

			settings = _parseSettings(settings);

			self.data('timepicker-settings', settings);

			if (list) {
				list.remove();
				self.data('timepicker-list', false);
			}

			return self;
		},

		getSecondsFromMidnight: function()
		{
			return _time2int(_getTimeValue(this));
		},

		getTime: function(relative_date)
		{
			var self = this;

			var time_string = _getTimeValue(self);
			if (!time_string) {
				return null;
			}

			if (!relative_date) {
				relative_date = new Date();
			}

			relative_date.setHours(0, 0, 0, 0);
			return new Date(relative_date.valueOf() + (_time2int(time_string)*1000));
		},

		setTime: function(value)
		{
			var self = this;
			var prettyTime = _int2time(_time2int(value), self.data('timepicker-settings').timeFormat);

			_setTimeValue(self, prettyTime);
			if (self.data('timepicker-list')) {
				_setSelected(self, self.data('timepicker-list'));
			}
		},

		remove: function()
		{
			var self = this;

			// check if this element is a timepicker
			if (!self.hasClass('ui-timepicker-input')) {
				return;
			}

			self.removeAttr('autocomplete', 'off');
			self.removeClass('ui-timepicker-input');
			self.removeData('timepicker-settings');
			self.off('.timepicker');

			// timepicker-list won't be present unless the user has interacted with this timepicker
			if (self.data('timepicker-list')) {
				self.data('timepicker-list').remove();
			}

			self.removeData('timepicker-list');
		}
	};

	// private methods

	function _parseSettings(settings)
	{
		if (settings.minTime) {
			settings.minTime = _time2int(settings.minTime);
		}

		if (settings.maxTime) {
			settings.maxTime = _time2int(settings.maxTime);
		}

		if (settings.durationTime && typeof settings.durationTime !== 'function') {
			settings.durationTime = _time2int(settings.durationTime);
		}

		if (settings.disableTimeRanges.length > 0) {
			// convert string times to integers
			for (var i in settings.disableTimeRanges) {
				settings.disableTimeRanges[i] = [
					_time2int(settings.disableTimeRanges[i][0]),
					_time2int(settings.disableTimeRanges[i][1])
				];
			}

			// sort by starting time
			settings.disableTimeRanges = settings.disableTimeRanges.sort(function(a, b){
				return a[0] - b[0];
			});

			// merge any overlapping ranges
			for (var i = settings.disableTimeRanges.length-1; i > 0; i--) {
				if (settings.disableTimeRanges[i][0] <= settings.disableTimeRanges[i-1][1]) {
					settings.disableTimeRanges[i-1] = [
						Math.min(settings.disableTimeRanges[i][0], settings.disableTimeRanges[i-1][0]),
						Math.max(settings.disableTimeRanges[i][1], settings.disableTimeRanges[i-1][1])
					];
					settings.disableTimeRanges.splice(i, 1);
				}
			}
		}

		return settings;
	}

	function _render(self)
	{
		var settings = self.data('timepicker-settings');
		var list = self.data('timepicker-list');

		if (list && list.length) {
			list.remove();
			self.data('timepicker-list', false);
		}

		list = $('<ul />', { 'class': 'ui-timepicker-list' });

		var wrapped_list = $('<div />', { 'class': 'ui-timepicker-wrapper', 'tabindex': -1 });
		wrapped_list.css({'display':'none', 'position': 'absolute' }).append(list);


		if (settings.className) {
			wrapped_list.addClass(settings.className);
		}

		if ((settings.minTime !== null || settings.durationTime !== null) && settings.showDuration) {
			wrapped_list.addClass('ui-timepicker-with-duration');
		}

		var durStart = settings.minTime;
		if (typeof settings.durationTime === 'function') {
			durStart = _time2int(settings.durationTime());
		} else if (settings.durationTime !== null) {
			durStart = settings.durationTime;
		}
		var start = (settings.minTime !== null) ? settings.minTime : 0;
		var end = (settings.maxTime !== null) ? settings.maxTime : (start + _ONE_DAY - 1);

		if (end <= start) {
			// make sure the end time is greater than start time, otherwise there will be no list to show
			end += _ONE_DAY;
		}

		if (end === _ONE_DAY-1 && settings.timeFormat.indexOf('H') !== -1) {
			// show a 24:00 option when using military time
			end = _ONE_DAY;
		}

		var dr = settings.disableTimeRanges;
		var drCur = 0;
		var drLen = dr.length;

		for (var i=start; i <= end; i += settings.step*60) {
			var timeInt = i;

			var row = $('<li />');
			row.data('time', (timeInt <= 86400 ? timeInt : timeInt % 86400));
			row.text(_int2time(timeInt, settings.timeFormat));

			if ((settings.minTime !== null || settings.durationTime !== null) && settings.showDuration) {
				var duration = $('<span />');
				duration.addClass('ui-timepicker-duration');
				duration.text(' ('+_int2duration(i - durStart)+')');
				row.append(duration);
			}

			if (drCur < drLen) {
				if (timeInt >= dr[drCur][1]) {
					drCur += 1;
				}

				if (dr[drCur] && timeInt >= dr[drCur][0] && timeInt < dr[drCur][1]) {
					row.addClass('ui-timepicker-disabled');
				}
			}

			list.append(row);
		}

		wrapped_list.data('timepicker-input', self);
		self.data('timepicker-list', wrapped_list);

		var appendTo = settings.appendTo;
		if (typeof appendTo === 'string') {
			appendTo = $(appendTo);
		} else if (typeof appendTo === 'function') {
			appendTo = appendTo(self);
		}
		appendTo.append(wrapped_list);
		_setSelected(self, list);

		list.on('click', 'li', function(e) {

			// hack: temporarily disable the focus handler
			// to deal with the fact that IE fires 'focus'
			// events asynchronously
			self.off('focus.timepicker');
			self.on('focus.timepicker-ie-hack', function(){
				self.off('focus.timepicker-ie-hack');
				self.on('focus.timepicker', methods.show);
			});

			if (!_hideKeyboard(self)) {
				self[0].focus();
			}

			// make sure only the clicked row is selected
			list.find('li').removeClass('ui-timepicker-selected');
			$(this).addClass('ui-timepicker-selected');

			if (_selectValue(self)) {
				self.trigger('hideTimepicker');
				wrapped_list.hide();
			}
		});
	}

	function _generateBaseDate()
	{
		return new Date(1970, 1, 1, 0, 0, 0);
	}

	// event handler to decide whether to close timepicker
	function _closeHandler(e)
	{
		var target = $(e.target);
		var input = target.closest('.ui-timepicker-input');
		if (input.length === 0 && target.closest('.ui-timepicker-wrapper').length === 0) {
			methods.hide();
			$('body').unbind('.ui-timepicker');
			$(window).unbind('.ui-timepicker');
		}
	}

	function _hideKeyboard(self)
	{
		var settings = self.data('timepicker-settings');
		return ((window.navigator.msMaxTouchPoints || 'ontouchstart' in document) && settings.disableTouchKeyboard);
	}

	function _findRow(self, list, value)
	{
		if (!value && value !== 0) {
			return false;
		}

		var settings = self.data('timepicker-settings');
		var out = false;
		var halfStep = settings.step*30;

		// loop through the menu items
		list.find('li').each(function(i, obj) {
			var jObj = $(obj);

			var offset = jObj.data('time') - value;

			// check if the value is less than half a step from each row
			if (Math.abs(offset) < halfStep || offset == halfStep) {
				out = jObj;
				return false;
			}
		});

		return out;
	}

	function _setSelected(self, list)
	{
		list.find('li').removeClass('ui-timepicker-selected');

		var timeValue = _time2int(_getTimeValue(self));
		if (timeValue === null) {
			return;
		}

		var selected = _findRow(self, list, timeValue);
		if (selected) {

			var topDelta = selected.offset().top - list.offset().top;

			if (topDelta + selected.outerHeight() > list.outerHeight() || topDelta < 0) {
				list.scrollTop(list.scrollTop() + selected.position().top - selected.outerHeight());
			}

			selected.addClass('ui-timepicker-selected');
		}
	}


	function _formatValue()
	{
		if (this.value === '') {
			return;
		}

		var self = $(this);
		var list = self.data('timepicker-list');

		if (list && list.is(':visible')) {
			return;
		}

		var seconds = _time2int(this.value);

		if (seconds === null) {
			self.trigger('timeFormatError');
			return;
		}

		var settings = self.data('timepicker-settings');
		var rangeError = false;
		// check that the time in within bounds
		if (settings.minTime !== null && seconds < settings.minTime) {
			rangeError = true;
		} else if (settings.maxTime !== null && seconds > settings.maxTime) {
			rangeError = true;
		}

		// check that time isn't within disabled time ranges
		$.each(settings.disableTimeRanges, function(){
			if (seconds >= this[0] && seconds < this[1]) {
				rangeError = true;
				return false;
			}
		});

		if (settings.forceRoundTime) {
			var offset = seconds % (settings.step*60); // step is in minutes

			if (offset >= settings.step*30) {
				// if offset is larger than a half step, round up
				seconds += (settings.step*60) - offset;
			} else {
				// round down
				seconds -= offset;
			}
		}

		var prettyTime = _int2time(seconds, settings.timeFormat);

		if (rangeError) {
			if (_setTimeValue(self, prettyTime, 'error')) {
				self.trigger('timeRangeError');
			}
		} else {
			_setTimeValue(self, prettyTime);
		}
	}

	function _getTimeValue(self)
	{
		if (self.is('input')) {
			return self.val();
		} else {
			// use the element's data attributes to store values
			return self.data('ui-timepicker-value');
		}
	}

	function _setTimeValue(self, value, source)
	{
		if (self.is('input')) {
			self.val(value);
		}

		if (self.data('ui-timepicker-value') != value) {
			self.data('ui-timepicker-value', value);
			if (source == 'select') {
				self.trigger('selectTime').trigger('changeTime').trigger('change');
			} else if (source != 'error') {
				self.trigger('changeTime');
			}

			return true;
		} else {
			self.trigger('selectTime');
			return false;
		}
	}

	/*
	*  Keyboard navigation via arrow keys
	*/
	function _keydownhandler(e)
	{
		var self = $(this);
		var list = self.data('timepicker-list');

		if (!list || !list.is(':visible')) {
			if (e.keyCode == 40) {
				if (!_hideKeyboard(self)) {
					self.focus();
				}
			} else {
				return _screenInput(e, self);
			}
		}

		switch (e.keyCode) {

			case 13: // return
				if (_selectValue(self)) {
					methods.hide.apply(this);
				}

				e.preventDefault();
				return false;

			case 38: // up
				var selected = list.find('.ui-timepicker-selected');

				if (!selected.length) {
					list.find('li').each(function(i, obj) {
						if ($(obj).position().top > 0) {
							selected = $(obj);
							return false;
						}
					});
					selected.addClass('ui-timepicker-selected');

				} else if (!selected.is(':first-child')) {
					selected.removeClass('ui-timepicker-selected');
					selected.prev().addClass('ui-timepicker-selected');

					if (selected.prev().position().top < selected.outerHeight()) {
						list.scrollTop(list.scrollTop() - selected.outerHeight());
					}
				}

				return false;

			case 40: // down
				selected = list.find('.ui-timepicker-selected');

				if (selected.length === 0) {
					list.find('li').each(function(i, obj) {
						if ($(obj).position().top > 0) {
							selected = $(obj);
							return false;
						}
					});

					selected.addClass('ui-timepicker-selected');
				} else if (!selected.is(':last-child')) {
					selected.removeClass('ui-timepicker-selected');
					selected.next().addClass('ui-timepicker-selected');

					if (selected.next().position().top + 2*selected.outerHeight() > list.outerHeight()) {
						list.scrollTop(list.scrollTop() + selected.outerHeight());
					}
				}

				return false;

			case 27: // escape
				list.find('li').removeClass('ui-timepicker-selected');
				methods.hide();
				break;

			case 9: //tab
				methods.hide();
				break;

			default:
				return _screenInput(e, self);
		}
	}

	function _screenInput(e, self)
	{
		return !self.data('timepicker-settings').disableTextInput || e.ctrlKey || e.altKey || e.metaKey || (e.keyCode != 2 && e.keyCode != 8 && e.keyCode < 46);
	}

	/*
	*	Time typeahead
	*/
	function _keyuphandler(e)
	{
		var self = $(this);
		var list = self.data('timepicker-list');

		if (!list || !list.is(':visible')) {
			return true;
		}

		if (!self.data('timepicker-settings').typeaheadHighlight) {
			list.find('li').removeClass('ui-timepicker-selected');
			return true;
		}

		switch (e.keyCode) {

			case 96: // numpad numerals
			case 97:
			case 98:
			case 99:
			case 100:
			case 101:
			case 102:
			case 103:
			case 104:
			case 105:
			case 48: // numerals
			case 49:
			case 50:
			case 51:
			case 52:
			case 53:
			case 54:
			case 55:
			case 56:
			case 57:
			case 65: // a
			case 77: // m
			case 80: // p
			case 186: // colon
			case 8: // backspace
			case 46: // delete
				_setSelected(self, list);
				break;

			default:
				// list.find('li').removeClass('ui-timepicker-selected');
				return;
		}
	}

	function _selectValue(self)
	{
		var settings = self.data('timepicker-settings');
		var list = self.data('timepicker-list');
		var timeValue = null;

		var cursor = list.find('.ui-timepicker-selected');

		if (cursor.hasClass('ui-timepicker-disabled')) {
			return false;
		}

		if (cursor.length) {
			// selected value found
			timeValue = cursor.data('time');

		} else if (_getTimeValue(self)) {

			// no selected value; fall back on input value
			timeValue = _time2int(_getTimeValue(self));

			_setSelected(self, list);
		}

		if (timeValue !== null) {
			var timeString = _int2time(timeValue, settings.timeFormat);
			_setTimeValue(self, timeString, 'select');
		}

		//self.trigger('change').trigger('selectTime');
		return true;
	}

	function _int2duration(seconds)
	{
		var minutes = Math.round(seconds/60);
		var duration;

		if (Math.abs(minutes) < 60) {
			duration = [minutes, _lang.mins];
		} else if (minutes == 60) {
			duration = ['1', _lang.hr];
		} else {
			var hours = (minutes/60).toFixed(1);
			if (_lang.decimal != '.') hours = hours.replace('.', _lang.decimal);
			duration = [hours, _lang.hrs];
		}

		return duration.join(' ');
	}

	function _int2time(seconds, format)
	{
		if (seconds === null) {
			return;
		}

		var time = new Date(_baseDate.valueOf() + (seconds*1000));
		var output = '';
		var hour, code;

		for (var i=0; i<format.length; i++) {

			code = format.charAt(i);
			switch (code) {

				case 'a':
					output += (time.getHours() > 11) ? 'pm' : 'am';
					break;

				case 'A':
					output += (time.getHours() > 11) ? 'PM' : 'AM';
					break;

				case 'g':
					hour = time.getHours() % 12;
					output += (hour === 0) ? '12' : hour;
					break;

				case 'G':
					output += time.getHours();
					break;

				case 'h':
					hour = time.getHours() % 12;

					if (hour !== 0 && hour < 10) {
						hour = '0'+hour;
					}

					output += (hour === 0) ? '12' : hour;
					break;

				case 'H':
					hour = time.getHours();
					if (seconds === _ONE_DAY) hour = 24;
					output += (hour > 9) ? hour : '0'+hour;
					break;

				case 'i':
					var minutes = time.getMinutes();
					output += (minutes > 9) ? minutes : '0'+minutes;
					break;

				case 's':
					seconds = time.getSeconds();
					output += (seconds > 9) ? seconds : '0'+seconds;
					break;

				default:
					output += code;
			}
		}

		return output;
	}

	function _time2int(timeString)
	{
		if (timeString === '') return null;
		if (!timeString || timeString+0 == timeString) return timeString;

		if (typeof(timeString) == 'object') {
			timeString = timeString.getHours()+':'+_pad2(timeString.getMinutes())+':'+_pad2(timeString.getSeconds());
		}

		timeString = timeString.toLowerCase();

		var d = new Date(0);
		var time;

		// try to parse time input
		if (timeString.indexOf(":") === -1) {
			// no colon present
			time = timeString.match(/^([0-9]):?([0-5][0-9])?:?([0-5][0-9])?\s*([pa]?)m?$/);

			if (!time) {
				time = timeString.match(/^([0-2][0-9]):?([0-5][0-9])?:?([0-5][0-9])?\s*([pa]?)m?$/);
			}
		} else {
			time = timeString.match(/^(\d{1,2})(?::([0-5][0-9]))?(?::([0-5][0-9]))?\s*([pa]?)m?$/);
		}

		if (!time) {
			return null;
		}

		var hour = parseInt(time[1]*1, 10);
		var hours;

		if (time[4]) {
			if (hour == 12) {
				hours = (time[4] == 'p') ? 12 : 0;
			} else {
				hours = (hour + (time[4] == 'p' ? 12 : 0));
			}

		} else {
			hours = hour;
		}

		var minutes = ( time[2]*1 || 0 );
		var seconds = ( time[3]*1 || 0 );
		return hours*3600 + minutes*60 + seconds;
	}

	function _pad2(n) {
		return ("0" + n).slice(-2);
	}

	// Plugin entry
	$.fn.timepicker = function(method)
	{
		if(methods[method]) { return methods[method].apply(this, Array.prototype.slice.call(arguments, 1)); }
		else if(typeof method === "object" || !method) { return methods.init.apply(this, arguments); }
		else { $.error("Method "+ method + " does not exist on jQuery.timepicker"); }
	};
}));

},{}],159:[function(require,module,exports){
//     Underscore.js 1.8.2
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.2';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var isArrayLike = function(collection) {
    var length = collection && collection.length;
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, target, fromIndex) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    return _.indexOf(obj, target, typeof fromIndex == 'number' && fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = input && input.length; i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (array == null) return [];
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = array.length; i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    if (array == null) return [];
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = array.length; i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, 'length').length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = list && list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    var i = 0, length = array && array.length;
    if (typeof isSorted == 'number') {
      i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;
    } else if (isSorted && length) {
      i = _.sortedIndex(array, item);
      return array[i] === item ? i : -1;
    }
    if (item !== item) {
      return _.findIndex(slice.call(array, i), _.isNaN);
    }
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  _.lastIndexOf = function(array, item, from) {
    var idx = array ? array.length : 0;
    if (typeof from == 'number') {
      idx = from < 0 ? idx + from + 1 : Math.min(idx, from + 1);
    }
    if (item !== item) {
      return _.findLastIndex(slice.call(array, 0, idx), _.isNaN);
    }
    while (--idx >= 0) if (array[idx] === item) return idx;
    return -1;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = array != null && array.length;
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createIndexFinder(1);

  _.findLastIndex = createIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    
    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of 
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
  
  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],"jquery":[function(require,module,exports){
module.exports = jQuery;

},{}]},{},[2])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwLXJ1bi5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHAuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9hZG1pbi9jb250cm9sbGVycy9hZG1pbl9tYWluX2NvbnRyb2xsZXIuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9hZG1pbi90ZW1wbGF0ZXMvYWRtaW5fZGFzaGJvYXJkX2FjdGl2aXRpZXMuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2FkbWluL3RlbXBsYXRlcy9hZG1pbl9kYXNoYm9hcmRfdGFibGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2FkbWluL3RlbXBsYXRlcy9hZG1pbl9kYXNoYm9hcmRfdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2FkbWluL3RlbXBsYXRlcy9hZG1pbl9tYWluX3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9hZG1pbi90ZW1wbGF0ZXMvYWRtaW5fcGFnaW5hdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2FkbWluL3RlbXBsYXRlcy9hZG1pbl90YWdfdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2FkbWluL3RlbXBsYXRlcy9hZG1pbl90YXNrX3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9hZG1pbi90ZW1wbGF0ZXMvYWRtaW5fdXNlcl9wYXNzd29yZC5odG1sIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvYWRtaW4vdGVtcGxhdGVzL2FkbWluX3VzZXJfdGFibGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2FkbWluL3RlbXBsYXRlcy9hZG1pbl91c2VyX3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9hZG1pbi92aWV3cy9hZG1pbl9kYXNoYm9hcmRfdmlldy5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2FkbWluL3ZpZXdzL2FkbWluX21haW5fdmlldy5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2FkbWluL3ZpZXdzL2FkbWluX3RhZ192aWV3LmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvYWRtaW4vdmlld3MvYWRtaW5fdGFza192aWV3LmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvYWRtaW4vdmlld3MvYWRtaW5fdXNlcl9wYXNzd29yZF92aWV3LmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvYWRtaW4vdmlld3MvYWRtaW5fdXNlcl92aWV3LmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvYXBwc19yb3V0ZXIuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9hdHRhY2htZW50L3RlbXBsYXRlcy9hdHRhY2htZW50X2l0ZW1fdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2F0dGFjaG1lbnQvdGVtcGxhdGVzL2F0dGFjaG1lbnRfc2hvd190ZW1wbGF0ZS5odG1sIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvYXR0YWNobWVudC92aWV3cy9hdHRhY2htZW50X3Nob3dfdmlldy5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2Jyb3dzZS9icm93c2VfYXBwLmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvYnJvd3NlL2NvbnRyb2xsZXJzL2Jyb3dzZV9saXN0X2NvbnRyb2xsZXIuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9icm93c2UvdGVtcGxhdGVzL2Jyb3dzZV9tYWluX3ZpZXdfdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2Jyb3dzZS90ZW1wbGF0ZXMvYnJvd3NlX3NlYXJjaF90YWcuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2Jyb3dzZS90ZW1wbGF0ZXMvbm9fc2VhcmNoX3Jlc3VsdHMuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2Jyb3dzZS90ZW1wbGF0ZXMvcHJvamVjdF9saXN0X2l0ZW0uaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2Jyb3dzZS90ZW1wbGF0ZXMvdGFza19saXN0X2l0ZW0uaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2Jyb3dzZS92aWV3cy9icm93c2VfbGlzdF92aWV3LmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvYnJvd3NlL3ZpZXdzL2Jyb3dzZV9tYWluX3ZpZXcuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9jb21tZW50cy9saXN0L2NvbnRyb2xsZXJzL2NvbW1lbnRfbGlzdF9jb250cm9sbGVyLmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvY29tbWVudHMvbGlzdC90ZW1wbGF0ZXMvY29tbWVudF9pdGVtX3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9jb21tZW50cy9saXN0L3RlbXBsYXRlcy9jb21tZW50X3dyYXBwZXJfdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2NvbW1lbnRzL2xpc3Qvdmlld3MvY29tbWVudF9pdGVtX3ZpZXcuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9jb21tZW50cy9uZXcvdGVtcGxhdGVzL2NvbW1lbnRfYWNfdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2NvbW1lbnRzL25ldy90ZW1wbGF0ZXMvY29tbWVudF9mb3JtX3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9jb21tZW50cy9uZXcvdGVtcGxhdGVzL2NvbW1lbnRfaW5saW5lX3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9jb21tZW50cy9uZXcvdmlld3MvY29tbWVudF9mb3JtX3ZpZXcuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9ldmVudHMvbGlzdC9jb250cm9sbGVycy9ldmVudF9saXN0X2NvbnRyb2xsZXIuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9ldmVudHMvbGlzdC90ZW1wbGF0ZXMvZXZlbnRfY29sbGVjdGlvbl92aWV3X3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9ldmVudHMvbGlzdC92aWV3cy9ldmVudF9jb2xsZWN0aW9uX3ZpZXcuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9ldmVudHMvbmV3L3RlbXBsYXRlcy9ldmVudF9mb3JtX3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9ldmVudHMvbmV3L3ZpZXdzL2V2ZW50X2Zvcm1fdmlldy5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2Zvb3Rlci90ZW1wbGF0ZXMvZm9vdGVyX3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9mb290ZXIvdmlld3MvZm9vdGVyX3ZpZXcuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9ob21lL2NvbnRyb2xsZXJzL2hvbWVfY29udHJvbGxlci5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2hvbWUvdGVtcGxhdGVzL2hvbWVfdmlld190ZW1wbGF0ZS5odG1sIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvaG9tZS92aWV3cy9ob21lX3ZpZXcuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9sb2dpbi9jb250cm9sbGVycy9sb2dpbl9jb250cm9sbGVyLmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvbG9naW4vdGVtcGxhdGVzL2xvZ2luX3Bhc3N3b3JkX3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9sb2dpbi90ZW1wbGF0ZXMvbG9naW5fdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2xvZ2luL3ZpZXdzL2xvZ2luX3Bhc3N3b3JkX3ZpZXcuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9sb2dpbi92aWV3cy9sb2dpbl92aWV3LmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvbmF2L3RlbXBsYXRlcy9uYXZfdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL25hdi92aWV3cy9uYXZfdmlldy5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3Byb2ZpbGVzL2VtYWlsL3RlbXBsYXRlcy9wcm9maWxlX2VtYWlsX2Zvcm0uaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3Byb2ZpbGVzL2VtYWlsL3ZpZXdzL3Byb2ZpbGVfZW1haWxfdmlldy5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3Byb2ZpbGVzL3Nob3cvY29udHJvbGxlcnMvcHJvZmlsZV9zaG93X2NvbnRyb2xsZXIuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9wcm9maWxlcy9zaG93L3RlbXBsYXRlcy9wcm9maWxlX2FjdGl2aXR5X3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9wcm9maWxlcy9zaG93L3RlbXBsYXRlcy9wcm9maWxlX2VtYWlsX3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9wcm9maWxlcy9zaG93L3RlbXBsYXRlcy9wcm9maWxlX3Jlc2V0X3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9wcm9maWxlcy9zaG93L3RlbXBsYXRlcy9wcm9maWxlX3NldHRpbmdzX3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9wcm9maWxlcy9zaG93L3RlbXBsYXRlcy9wcm9maWxlX3Nob3dfdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3Byb2ZpbGVzL3Nob3cvdmlld3MvcHJvZmlsZV9hY3Rpdml0eV92aWV3LmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvcHJvZmlsZXMvc2hvdy92aWV3cy9wcm9maWxlX3Jlc2V0X3ZpZXcuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9wcm9maWxlcy9zaG93L3ZpZXdzL3Byb2ZpbGVfc2V0dGluZ3Nfdmlldy5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3Byb2ZpbGVzL3Nob3cvdmlld3MvcHJvZmlsZV9zaG93X3ZpZXcuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9wcm9qZWN0L25ldy90ZW1wbGF0ZXMvcHJvamVjdF9uZXdfZm9ybV90ZW1wbGF0ZS5odG1sIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvcHJvamVjdC9uZXcvdmlld3MvcHJvamVjdF9uZXdfZm9ybV92aWV3LmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvcHJvamVjdC9zaG93L2NvbnRyb2xsZXJzL3Byb2plY3Rfc2hvd19jb250cm9sbGVyLmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvcHJvamVjdC9zaG93L3RlbXBsYXRlcy9wcm9qZWN0X2l0ZW1fY29yZW1ldGFfdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3Byb2plY3Qvc2hvdy90ZW1wbGF0ZXMvcHJvamVjdF9pdGVtX3ZpZXdfdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3Byb2plY3Qvc2hvdy90ZW1wbGF0ZXMvcHJvamVjdF9vcGVuX3Rhc2tzX3dhcm5pbmdfdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3Byb2plY3Qvc2hvdy92aWV3cy9wcm9qZWN0X2l0ZW1fY29yZW1ldGFfdmlldy5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3Byb2plY3Qvc2hvdy92aWV3cy9wcm9qZWN0X2l0ZW1fdmlldy5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3Byb2plY3Rvd25lci9zaG93L3RlbXBsYXRlcy9wcm9qZWN0b3duZXJfc2hvd190ZW1wbGF0ZS5odG1sIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvcHJvamVjdG93bmVyL3Nob3cvdmlld3MvcHJvamVjdG93bmVyX3Nob3dfdmlldy5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3RhZy9uZXcvdGVtcGxhdGVzL3RhZ19uZXdfZm9ybV90ZW1wbGF0ZS5odG1sIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvdGFnL25ldy92aWV3cy90YWdfbmV3X2Zvcm1fdmlldy5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3RhZy9zaG93L3RlbXBsYXRlcy90YWdfaXRlbV90ZW1wbGF0ZS5odG1sIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvdGFnL3Nob3cvdGVtcGxhdGVzL3RhZ19zaG93X3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy90YWcvc2hvdy92aWV3cy90YWdfc2hvd192aWV3LmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvdGFza3MvZWRpdC90ZW1wbGF0ZXMvdGFza19lZGl0X2Zvcm1fdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3Rhc2tzL2VkaXQvdGVtcGxhdGVzL3ZvbHVudGVlcl9lZGl0X2Zvcm1fdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3Rhc2tzL2VkaXQvdmlld3MvdGFza19lZGl0X2Zvcm1fdmlldy5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3Rhc2tzL2xpc3QvY29udHJvbGxlcnMvdGFza19saXN0X2NvbnRyb2xsZXIuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy90YXNrcy9saXN0L3RlbXBsYXRlcy90YXNrX2NvbGxlY3Rpb25fdmlld190ZW1wbGF0ZS5odG1sIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvdGFza3MvbGlzdC92aWV3cy90YXNrX2NvbGxlY3Rpb25fdmlldy5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3Rhc2tzL25ldy90ZW1wbGF0ZXMvdGFza19mb3JtX3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy90YXNrcy9uZXcvdmlld3MvdGFza19mb3JtX3ZpZXcuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy90YXNrcy9zaG93L2NvbnRyb2xsZXJzL3Rhc2tfc2hvd19jb250cm9sbGVyLmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvdGFza3Mvc2hvdy90ZW1wbGF0ZXMvY2hhbmdlX3N0YXRlX3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy90YXNrcy9zaG93L3RlbXBsYXRlcy90YXNrX3Nob3dfaXRlbV90ZW1wbGF0ZS5odG1sIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvdGFza3Mvc2hvdy90ZW1wbGF0ZXMvdXBkYXRlX25hbWVfdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3Rhc2tzL3Nob3cvdGVtcGxhdGVzL3ZvbHVudGVlcl9zdXBlcnZpc29yX25vdGlmeV90ZW1wbGF0ZS5odG1sIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvdGFza3Mvc2hvdy90ZW1wbGF0ZXMvdm9sdW50ZWVyX3RleHRfdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3Rhc2tzL3Nob3cvdmlld3MvdGFza19pdGVtX3ZpZXcuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYmFzZS9iYXNlX2NvbXBvbmVudC5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9iYXNlL2Jhc2VfY29udHJvbGxlci5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9iYXNlL2Jhc2Vfdmlldy5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9jb21wb25lbnRzL2FsZXJ0X3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvY29tcG9uZW50cy9tYXJrZG93bl9lZGl0b3IuanMiLCJhc3NldHMvanMvYmFja2JvbmUvY29tcG9uZW50cy9tYXJrZG93bl9lZGl0b3JfdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9jb21wb25lbnRzL21vZGFsLmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2NvbXBvbmVudHMvbW9kYWxfYWxlcnQuanMiLCJhc3NldHMvanMvYmFja2JvbmUvY29tcG9uZW50cy9tb2RhbF9hbGVydF90ZW1wbGF0ZS5odG1sIiwiYXNzZXRzL2pzL2JhY2tib25lL2NvbXBvbmVudHMvbW9kYWxfdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9jb21wb25lbnRzL21vZGFsX3dpemFyZC5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9jb21wb25lbnRzL21vZGFsX3dpemFyZF90ZW1wbGF0ZS5odG1sIiwiYXNzZXRzL2pzL2JhY2tib25lL2NvbXBvbmVudHMvdGFnX2ZhY3RvcnkuanMiLCJhc3NldHMvanMvYmFja2JvbmUvY29uZmlnL2kxOG4uanNvbiIsImFzc2V0cy9qcy9iYWNrYm9uZS9jb25maWcvbG9naW4uanNvbiIsImFzc2V0cy9qcy9iYWNrYm9uZS9jb25maWcvdGFnLmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2NvbmZpZy91aS5qc29uIiwiYXNzZXRzL2pzL2JhY2tib25lL2VudGl0aWVzL2NvbW1lbnRzL2NvbW1lbnRfY29sbGVjdGlvbi5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9lbnRpdGllcy9jb21tZW50cy9jb21tZW50X21vZGVsLmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2VudGl0aWVzL2V2ZW50cy9ldmVudF9tb2RlbC5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9lbnRpdGllcy9ldmVudHMvZXZlbnRzX2NvbGxlY3Rpb24uanMiLCJhc3NldHMvanMvYmFja2JvbmUvZW50aXRpZXMvcHJvZmlsZXMvcHJvZmlsZV9tb2RlbC5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9lbnRpdGllcy9wcm9qZWN0cy9wcm9qZWN0X21vZGVsLmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2VudGl0aWVzL3Byb2plY3RzL3Byb2plY3RzX2NvbGxlY3Rpb24uanMiLCJhc3NldHMvanMvYmFja2JvbmUvZW50aXRpZXMvdGFza3MvdGFza19tb2RlbC5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9lbnRpdGllcy90YXNrcy90YXNrc19jb2xsZWN0aW9uLmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL21peGlucy9wb3BvdmVycy5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9taXhpbnMvdGVtcGxhdGVzL3BvcG92ZXJfcHJvZmlsZS5odG1sIiwiYXNzZXRzL2pzL2JhY2tib25lL21peGlucy91dGlsaXRpZXMuanMiLCJhc3NldHMvanMvdmVuZG9yL2pxdWVyeS5zZWxlY3Rpb24uanMiLCJhc3NldHMvanMvdmVuZG9yL2pxdWVyeS50aW1lYWdvLmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jL2xpYi9hc3luYy5qcyIsIm5vZGVfbW9kdWxlcy9hdXRvbGlua2VyL2Rpc3QvQXV0b2xpbmtlci5qcyIsIm5vZGVfbW9kdWxlcy9iYWNrYm9uZS9iYWNrYm9uZS5qcyIsIm5vZGVfbW9kdWxlcy9ibHVlaW1wLWZpbGUtdXBsb2FkL2pzL2pxdWVyeS5maWxldXBsb2FkLmpzIiwibm9kZV9tb2R1bGVzL2JsdWVpbXAtZmlsZS11cGxvYWQvanMvanF1ZXJ5LmlmcmFtZS10cmFuc3BvcnQuanMiLCJub2RlX21vZHVsZXMvYmx1ZWltcC1maWxlLXVwbG9hZC9qcy92ZW5kb3IvanF1ZXJ5LnVpLndpZGdldC5qcyIsIm5vZGVfbW9kdWxlcy9ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIvc3JjL2pzL2Jvb3RzdHJhcC1kYXRldGltZXBpY2tlci5qcyIsIm5vZGVfbW9kdWxlcy9ib290c3RyYXAvZGlzdC9qcy9ucG0uanMiLCJub2RlX21vZHVsZXMvYm9vdHN0cmFwL2pzL2FmZml4LmpzIiwibm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9qcy9hbGVydC5qcyIsIm5vZGVfbW9kdWxlcy9ib290c3RyYXAvanMvYnV0dG9uLmpzIiwibm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9qcy9jYXJvdXNlbC5qcyIsIm5vZGVfbW9kdWxlcy9ib290c3RyYXAvanMvY29sbGFwc2UuanMiLCJub2RlX21vZHVsZXMvYm9vdHN0cmFwL2pzL2Ryb3Bkb3duLmpzIiwibm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9qcy9tb2RhbC5qcyIsIm5vZGVfbW9kdWxlcy9ib290c3RyYXAvanMvcG9wb3Zlci5qcyIsIm5vZGVfbW9kdWxlcy9ib290c3RyYXAvanMvc2Nyb2xsc3B5LmpzIiwibm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9qcy90YWIuanMiLCJub2RlX21vZHVsZXMvYm9vdHN0cmFwL2pzL3Rvb2x0aXAuanMiLCJub2RlX21vZHVsZXMvYm9vdHN0cmFwL2pzL3RyYW5zaXRpb24uanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2kxOG5leHQtY2xpZW50L2kxOG5leHQuY29tbW9uanMud2l0aEpRdWVyeS5qcyIsIm5vZGVfbW9kdWxlcy9qcXVlcnkuYXR3aG8vZGlzdC9qcy9qcXVlcnkuYXR3aG8uanMiLCJub2RlX21vZHVsZXMvanF1ZXJ5LmNhcmV0L2Rpc3QvanF1ZXJ5LmNhcmV0Lm1pbi5qcyIsIm5vZGVfbW9kdWxlcy9tYXJrZWQvbGliL21hcmtlZC5qcyIsIm5vZGVfbW9kdWxlcy9tb21lbnQvbW9tZW50LmpzIiwibm9kZV9tb2R1bGVzL3NlbGVjdDIvc2VsZWN0Mi5qcyIsIm5vZGVfbW9kdWxlcy90aW1lcGlja2VyL2pxdWVyeS50aW1lcGlja2VyLmpzIiwibm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvdW5kZXJzY29yZS5qcyIsImFzc2V0cy9qcy92ZW5kb3IvanF1ZXJ5LXNoaW0uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFLQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9SQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdExBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RIQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFQQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2bUJBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JTQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbk5BO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9MQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwUEE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25JQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5ZUE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFKQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlMQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25XQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzk3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMzhEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4a0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbDVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ROQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGtDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2h2QkE7QUFDQTs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4dkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcjlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2o1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGdEQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciBBcHBzUm91dGVyID0gcmVxdWlyZSgnLi9hcHBzL2FwcHNfcm91dGVyJyk7XG5cblxuQXBwbGljYXRpb24gPSB7XG5cbiAgc3RhcnRlZDogbnVsbCxcblxuICAvLyBJbml0aWFsaXplIGFuZCBmaXJlIHVwIHRoZSBhcHBsaWNhdGlvbi5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAvLyBDYWNoZSB1c2VyXG4gICAgLy8gQ2hlY2sgaWYgYSB1c2VyIGlzIGFscmVhZHkgZGVmaW5lZFxuICAgIGlmICghXy5pc1VuZGVmaW5lZChiYWNrZW5kVXNlcikpIHtcbiAgICAgIHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlciA9IGJhY2tlbmRVc2VyO1xuICAgIH1cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoc3lzdGVtTmFtZSkpIHtcbiAgICAgIHdpbmRvdy5jYWNoZS5zeXN0ZW0ubmFtZSA9IHN5c3RlbU5hbWU7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgdXNlciBldmVudHMgaGFuZGxlclxuICAgIF8uZXh0ZW5kKHdpbmRvdy5jYWNoZS51c2VyRXZlbnRzLCBCYWNrYm9uZS5FdmVudHMpO1xuXG4gICAgLy8gTWl4aW4gYmFja2JvbmUgZXZlbnRzIGludG8gb3VyIHB1YiBzdWIgaGFuZGxlclxuICAgIF8uZXh0ZW5kKGVudGl0aWVzLnJlcXVlc3QsIEJhY2tib25lLkV2ZW50cyk7XG5cbiAgICAvLyBNaXhpbiBiYWNrYm9uZSBldmVudHMgaW50byBvdXIgcmVuZGVyaW5nIGV2ZW50IGhhbmRsZXJcbiAgICBfLmV4dGVuZChyZW5kZXJpbmcsIEJhY2tib25lLkV2ZW50cyk7XG5cbiAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICBzZWxmLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuYXBwbGljYXRpb24uaW5pdGlhbGl6ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFwcGxpY2F0aW9uID0gQXBwc1JvdXRlci5pbml0aWFsaXplKCk7XG4gICAgICBzZWxmLnN0YXJ0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gQmFja2JvbmUgTXVsdGktdGVuYW50IHJvdXRlciBmaXJpbmcgdXAuXG5tb2R1bGUuZXhwb3J0cyA9IEFwcGxpY2F0aW9uO1xuIiwiLyoqXG4gKiBUaGlzIGlzIHRoZSBtYWluIGFwcGxpY2F0aW9uIGJvb3RzdHJhcFxuICogdGhhdCBnZXRzIHRoZSByZXN0IG9mIHRoZSBhcHBzLCByb3V0ZXJzLCBldGNcbiAqIHJ1bm5pbmcuXG4gKi9cblxuLy8gSW5zdGFsbCBqUXVlcnkgcGx1Z2luc1xucmVxdWlyZSgnYmx1ZWltcC1maWxlLXVwbG9hZC9qcy92ZW5kb3IvanF1ZXJ5LnVpLndpZGdldCcpO1xuaTE4biA9IHJlcXVpcmUoJ2kxOG5leHQtY2xpZW50L2kxOG5leHQuY29tbW9uanMud2l0aEpRdWVyeScpO1xubW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XG5cbi8vIEFwcFxud2luZG93LkFwcGxpY2F0aW9uICAgICAgPSB3aW5kb3cuQXBwbGljYXRpb24gfHwge307XG53aW5kb3cuY2FjaGUgICAgICAgICAgICA9IHsgdXNlckV2ZW50czoge30sIGN1cnJlbnRVc2VyOiBudWxsLCBzeXN0ZW06IHt9IH07XG5cbi8vIEV2ZW50c1xud2luZG93LmVudGl0aWVzID0geyByZXF1ZXN0OiB7fSB9O1xucmVuZGVyaW5nICAgICAgID0ge31cblxuLy8gU2V0IHVwIEJhY2tib25lIHRvIHVzZSBqUXVlcnlcbl8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5CYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG5CYWNrYm9uZS4kID0galF1ZXJ5O1xuXG4vLyBMb2FkIHRoZSBhcHBsaWNhdGlvblxudmFyIGFwcHIgPSByZXF1aXJlKCcuL2FwcC1ydW4nKTtcbmFwcHIuaW5pdGlhbGl6ZSgpO1xuIiwiXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBhc3luYyA9IHJlcXVpcmUoJ2FzeW5jJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vbWl4aW5zL3V0aWxpdGllcycpO1xudmFyIEJhc2VDb250cm9sbGVyID0gcmVxdWlyZSgnLi4vLi4vLi4vYmFzZS9iYXNlX2NvbnRyb2xsZXInKTtcbnZhciBBZG1pbk1haW5WaWV3ID0gcmVxdWlyZSgnLi4vdmlld3MvYWRtaW5fbWFpbl92aWV3Jyk7XG5cblxuQWRtaW4gPSB7fTtcblxuQWRtaW4uU2hvd0NvbnRyb2xsZXIgPSBCYXNlQ29udHJvbGxlci5leHRlbmQoe1xuXG4gIGV2ZW50czoge1xuICB9LFxuXG4gIC8vIEluaXRpYWxpemUgdGhlIGFkbWluIHZpZXdcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuYWRtaW5NYWluVmlldyA9IG5ldyBBZG1pbk1haW5WaWV3KHtcbiAgICAgIGFjdGlvbjogb3B0aW9ucy5hY3Rpb24sXG4gICAgICBlbDogdGhpcy5lbFxuICAgIH0pLnJlbmRlcigpO1xuICB9LFxuXG4gIC8vIENsZWFudXAgY29udHJvbGxlciBhbmQgdmlld3NcbiAgY2xlYW51cDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5hZG1pbk1haW5WaWV3LmNsZWFudXAoKTtcbiAgICByZW1vdmVWaWV3KHRoaXMpO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFkbWluLlNob3dDb250cm9sbGVyO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMTJcXFwiPlxcbiAgICA8aDI+PGkgY2xhc3M9XFxcImZhIGZhLW5ld3NwYXBlci1vXFxcIj48L2k+PHNwYW4gY2xhc3M9XFxcImJveC1pY29uLXRleHRcXFwiPlJlY2VudCBBY3Rpdml0eTwvc3Bhbj48L2gyPlxcbiAgICA8dWwgY2xhc3M9XFxcImFjdGl2aXR5LWZlZWQgbGlzdC11bnN0eWxlZFxcXCI+PC91bD5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcblxcbjxzY3JpcHQgdHlwZT1cXFwidGV4dC90ZW1wbGF0ZVxcXCIgaWQ9XFxcIm5ld0NvbW1lbnRcXFwiPlxcbiAgPGxpIGNsYXNzPVxcXCJib3gtcGFkLXQgYm94LXBhZC1iXFxcIj5cXG4gICAgJmxkcXVvO3t7Y29tbWVudC52YWx1ZX19JnJkcXVvOyBzYWlkIDxhIGhyZWY9XFxcIi9wcm9maWxlL3t7dXNlci5pZH19XFxcIj57e3VzZXIubmFtZSB8fCB1c2VyLnVzZXJuYW1lfX08L2E+IG9uIDxhIGhyZWY9XFxcIi97e2l0ZW1UeXBlfX1zL3t7aXRlbS5pZH19XFxcIj57e2l0ZW0udGl0bGV9fTwvYT5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY29tbWVudC1tZXRhZGF0YVxcXCI+PHRpbWUgdGl0bGU9XFxcInt7Y3JlYXRlZEF0fX1cXFwiPnt7Y3JlYXRlZEF0Rm9ybWF0dGVkfX08L3RpbWU+PC9kaXY+XFxuICA8L2xpPlxcbjwvc2NyaXB0PlxcblxcbjxzY3JpcHQgdHlwZT1cXFwidGV4dC90ZW1wbGF0ZVxcXCIgaWQ9XFxcIm5ld1ZvbHVudGVlclxcXCI+XFxuICA8bGkgY2xhc3M9XFxcImJveC1wYWQtdCBib3gtcGFkLWJcXFwiPlxcbiAgICA8YSBocmVmPVxcXCIvcHJvZmlsZS97e3VzZXIuaWR9fVxcXCI+e3t1c2VyLm5hbWUgfHwgdXNlci51c2VybmFtZX19PC9hPiBzaWduZWQgdXAgZm9yIDxhIGhyZWY9XFxcIi90YXNrcy97e3Rhc2suaWR9fVxcXCI+e3t0YXNrLnRpdGxlfX08L2E+XFxuICAgIDxkaXYgY2xhc3M9XFxcImNvbW1lbnQtbWV0YWRhdGFcXFwiPjx0aW1lIHRpdGxlPVxcXCJ7e2NyZWF0ZWRBdH19XFxcIj57e2NyZWF0ZWRBdEZvcm1hdHRlZH19PC90aW1lPjwvZGl2PlxcbiAgPC9saT5cXG48L3NjcmlwdD5cXG5cXG48c2NyaXB0IHR5cGU9XFxcInRleHQvdGVtcGxhdGVcXFwiIGlkPVxcXCJuZXdVc2VyXFxcIj5cXG4gIDxsaSBjbGFzcz1cXFwiYm94LXBhZC10IGJveC1wYWQtYlxcXCI+XFxuICAgIDxhIGhyZWY9XFxcIi9wcm9maWxlL3t7dXNlci5pZH19XFxcIj57e3VzZXIubmFtZSB8fCB1c2VyLnVzZXJuYW1lfX08L2E+IGpvaW5lZCFcXG4gICAgPGRpdiBjbGFzcz1cXFwiY29tbWVudC1tZXRhZGF0YVxcXCI+PHRpbWUgdGl0bGU9XFxcInt7Y3JlYXRlZEF0fX1cXFwiPnt7Y3JlYXRlZEF0Rm9ybWF0dGVkfX08L3RpbWU+PC9kaXY+XFxuICA8L2xpPlxcbjwvc2NyaXB0PlxcblxcbjxzY3JpcHQgdHlwZT1cXFwidGV4dC90ZW1wbGF0ZVxcXCIgaWQ9XFxcInVwZGF0ZWRVc2VyXFxcIj5cXG4gIDxsaSBjbGFzcz1cXFwiYm94LXBhZC10IGJveC1wYWQtYlxcXCI+XFxuICAgIDxhIGhyZWY9XFxcIi9wcm9maWxlL3t7dXNlci5pZH19XFxcIj57e3VzZXIubmFtZSB8fCB1c2VyLnVzZXJuYW1lfX08L2E+IHVwZGF0ZWQgdGhlaXIgcHJvZmlsZVxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb21tZW50LW1ldGFkYXRhXFxcIj48dGltZSB0aXRsZT1cXFwie3tjcmVhdGVkQXR9fVxcXCI+e3tjcmVhdGVkQXRGb3JtYXR0ZWR9fTwvdGltZT48L2Rpdj5cXG4gIDwvbGk+XFxuPC9zY3JpcHQ+XFxuXFxuPHNjcmlwdCB0eXBlPVxcXCJ0ZXh0L3RlbXBsYXRlXFxcIiBpZD1cXFwibmV3VGFza1xcXCI+XFxuICA8bGkgY2xhc3M9XFxcImJveC1wYWQtdCBib3gtcGFkLWJcXFwiPlxcbiAgICA8YSBocmVmPVxcXCIvcHJvZmlsZS97e3VzZXIuaWR9fVxcXCI+e3t1c2VyLm5hbWUgfHwgdXNlci51c2VybmFtZX19PC9hPiBwb3N0ZWQgYSBuZXcgb3Bwb3J0dW5pdHk6IDxhIGhyZWY9XFxcIi90YXNrcy97e3Rhc2suaWR9fVxcXCI+e3t0YXNrLnRpdGxlfX08L2E+XFxuICAgIDxkaXYgY2xhc3M9XFxcImNvbW1lbnQtbWV0YWRhdGFcXFwiPjx0aW1lIHRpdGxlPVxcXCJ7e2NyZWF0ZWRBdH19XFxcIj57e2NyZWF0ZWRBdEZvcm1hdHRlZH19PC90aW1lPjwvZGl2PlxcbiAgPC9saT5cXG48L3NjcmlwdD5cXG5cIjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiY29sLXNtLTYgYm94LXBhZC10IGJveC1wYWQtYlxcXCI+XFxuICAgIDxoMj48aSBjbGFzcz1cXFwiZmEgZmEtbGluZS1jaGFydFxcXCI+PC9pPjxzcGFuIGNsYXNzPVxcXCJib3gtaWNvbi10ZXh0XFxcIiBkYXRhLWkxOG49XFxcIkludGVyYWN0aW9uUGx1cmFsXFxcIj5JbnRlcmFjdGlvbnM8L3NwYW4+PC9oMj5cXG4gICAgPHVsIGNsYXNzPVxcXCJtZXRyaWNzXFxcIj5cXG4gICAgICA8bGk+VG90YWwgSW50ZXJhY3Rpb25zOiA8JS0gaW50ZXJhY3Rpb25zLmNvdW50ICU+PC9saT5cXG4gICAgICA8dWw+XFxuICAgICAgICA8bGk+PHNwYW4gZGF0YS1pMThuPVxcXCJUYXNrXFxcIj5UYXNrPC9zcGFuPiBTaWdudXBzOiA8JS0gaW50ZXJhY3Rpb25zLnNpZ251cHMgJT48L2xpPlxcbiAgICAgICAgPGxpPkFzc2lnbm1lbnRzOiA8JS0gaW50ZXJhY3Rpb25zLmFzc2lnbm1lbnRzICU+PC9saT5cXG4gICAgICAgIDxsaT5EaXNjdXNzaW9uIFBvc3RzOiA8JS0gaW50ZXJhY3Rpb25zLnBvc3RzICU+PC9saT5cXG4gICAgICAgIDxsaT5Db21wbGV0ZWQgVGFza3M6IDwlLSBpbnRlcmFjdGlvbnMuY29tcGxldGlvbnMgJT48L2xpPlxcbiAgICAgICAgPGxpPkRyYWZ0IFRhc2tzOiA8JS0gaW50ZXJhY3Rpb25zLmRyYWZ0cyAlPjwvbGk+XFxuICAgICAgICA8bGk+UHVibGlzaGVkIFRhc2tzOiA8JS0gaW50ZXJhY3Rpb25zLnB1Ymxpc2hlcyAlPjwvbGk+XFxuICAgICAgPC91bD5cXG4gICAgPC91bD5cXG4gIDwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwiY29sLXNtLTYgYm94LXBhZC10IGJveC1wYWQtYlxcXCI+XFxuICAgIDxoMj48aSBjbGFzcz1cXFwiZmEgZmEtdGFnc1xcXCI+PC9pPjxzcGFuIGNsYXNzPVxcXCJib3gtaWNvbi10ZXh0XFxcIiBkYXRhLWkxOG49XFxcIlRhc2tQbHVyYWxcXFwiPlRhc2tzPC9zcGFuPjwvaDI+XFxuICAgIDx1bCBjbGFzcz1cXFwibWV0cmljc1xcXCI+XFxuICAgICAgPGxpPlRvdGFsIENyZWF0ZWQ6IDwlLSB0YXNrcy5jb3VudCAlPjwvbGk+XFxuICAgICAgPHVsPlxcbiAgICAgICAgPGxpPkRyYWZ0OiA8JS0gdGFza3MuZHJhZnQgJT48L2xpPlxcbiAgICAgICAgPGxpPk9wZW46IDwlLSB0YXNrcy5vcGVuICU+PC9saT5cXG4gICAgICAgIDxsaT5Bc3NpZ25lZDogPCUtIHRhc2tzLmFzc2lnbmVkICU+PC9saT5cXG4gICAgICAgIDxsaT5Db21wbGV0ZWQ6IDwlLSB0YXNrcy5jb21wbGV0ZWQgJT48L2xpPlxcbiAgICAgICAgPGxpPkFyY2hpdmVkOiA8JS0gdGFza3MuYXJjaGl2ZWQgJT48L2xpPlxcbiAgICAgIDwvdWw+XFxuICAgIDwvdWw+XFxuICA8L2Rpdj5cXG48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiY29sLXNtLTYgYm94LXBhZC10IGJveC1wYWQtYlxcXCI+XFxuICAgIDxoMj48aSBjbGFzcz1cXFwiZmEgZmEtdXNlclxcXCI+PC9pPjxzcGFuIGNsYXNzPVxcXCJib3gtaWNvbi10ZXh0XFxcIj5Vc2Vyczwvc3Bhbj48L2gyPlxcbiAgICA8dWwgY2xhc3M9XFxcIm1ldHJpY3NcXFwiPlxcbiAgICAgIDxsaT5RdWFudGl0eTogPCUtIHVzZXJzLmNvdW50ICU+PC9saT5cXG4gICAgICA8dWw+PGxpPldobyBoYXZlIGNyZWF0ZWQgdGFza3M6IDwlLSB1c2Vycy53aXRoVGFza3MgJT48L2xpPjwvdWw+XFxuICAgIDwvdWw+XFxuICA8L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcImNvbC1zbS02IGJveC1wYWQtdCBib3gtcGFkLWJcXFwiPlxcbiAgICA8aDI+PGkgY2xhc3M9XFxcImZhIGZhLXJvY2tldFxcXCI+PC9pPjxzcGFuIGNsYXNzPVxcXCJib3gtaWNvbi10ZXh0XFxcIiBkYXRhLWkxOG49XFxcIlByb2plY3RQbHVyYWxcXFwiPlByb2plY3RzPC9zcGFuPjwvaDI+XFxuICAgIDx1bCBjbGFzcz1cXFwibWV0cmljc1xcXCI+XFxuICAgICAgPGxpPlRvdGFsIENyZWF0ZWQ6IDwlLSBwcm9qZWN0cy5jb3VudCAlPjwvbGk+XFxuICAgIDwvdWw+XFxuICA8L2Rpdj5cXG48L2Rpdj5cXG5cIjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJhbGVydCBhbGVydC1kYW5nZXJcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIj5cXG48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMTIgYm94IGJveC1wYWQtbHJcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTEyIHNtLW5vcGFkZGluZyBtZC1ub3BhZGRpbmdcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImZ1bGx3aWR0aCB0ZXh0LWNlbnRlciBzcGlubmVyXFxcIj5cXG4gICAgICAgIExvYWRpbmcuLi4gPGkgY2xhc3M9XFxcImZhIGZhLXNwaW5uZXIgZmEtc3BpblxcXCI+PC9pPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwibWV0cmljLWJsb2NrXFxcIj48L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcImFjdGl2aXR5LWJsb2NrXFxcIj48L2Rpdj5cXG48L2Rpdj5cXG5cIjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiY29sLXNtLTMgY29sLW1kLTNcXFwiPlxcblxcbiAgICA8bmF2IGNsYXNzPVxcXCJuYXZiYXIgYWRtaW4gbmF2YmFyLWRlZmF1bHRcXFwiIHJvbGU9XFxcIm5hdmlnYXRpb25cXFwiPlxcbiAgICAgIDwhLS0gQnJhbmQgYW5kIHRvZ2dsZSBnZXQgZ3JvdXBlZCBmb3IgYmV0dGVyIG1vYmlsZSBkaXNwbGF5IC0tPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIm5hdmJhci1oZWFkZXJcXFwiPlxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJuYXZiYXItdG9nZ2xlXFxcIiBkYXRhLXRvZ2dsZT1cXFwiY29sbGFwc2VcXFwiIGRhdGEtdGFyZ2V0PVxcXCIubmF2YmFyLWV4MS1jb2xsYXBzZVxcXCI+XFxuICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzci1vbmx5XFxcIj5Ub2dnbGUgbmF2aWdhdGlvbjwvc3Bhbj5cXG4gICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImljb24tYmFyXFxcIj48L3NwYW4+XFxuICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpY29uLWJhclxcXCI+PC9zcGFuPlxcbiAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaWNvbi1iYXJcXFwiPjwvc3Bhbj5cXG4gICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgPGgyIGNsYXNzPVxcXCJib3gtcGFkLWxyIGJveC1wYWQtdFxcXCI+QWRtaW5pc3RyYXRpb248L2gyPlxcbiAgICAgIDwvZGl2PlxcblxcbiAgICAgIDwhLS0gQ29sbGVjdCB0aGUgbmF2IGxpbmtzLCBmb3JtcywgYW5kIG90aGVyIGNvbnRlbnQgZm9yIHRvZ2dsaW5nIC0tPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbGxhcHNlIG5hdmJhci1jb2xsYXBzZSBuYXZiYXItZXgxLWNvbGxhcHNlXFxcIj5cXG4gICAgICAgIDx1bCBjbGFzcz1cXFwibmF2IG5hdmJhci1uYXZcXFwiPlxcbiAgICAgICAgICA8bGk+PGEgaHJlZj1cXFwiL2FkbWluL2Rhc2hib2FyZFxcXCIgY2xhc3M9XFxcImxpbmstYWRtaW5cXFwiIGRhdGEtdGFyZ2V0PVxcXCJkYXNoYm9hcmRcXFwiPkRhc2hib2FyZDwvYT48L2xpPlxcbiAgICAgICAgICA8bGk+PGEgaHJlZj1cXFwiL2FkbWluL3VzZXJzXFxcIiBjbGFzcz1cXFwibGluay1hZG1pblxcXCIgZGF0YS10YXJnZXQ9XFxcInVzZXJcXFwiPlVzZXIgTWFuYWdlbWVudDwvYT48L2xpPlxcbiAgICAgICAgICA8bGk+PGEgaHJlZj1cXFwiL2FkbWluL3RhZ3NcXFwiIGNsYXNzPVxcXCJsaW5rLWFkbWluXFxcIiBkYXRhLXRhcmdldD1cXFwidGFnXFxcIj5UYWcgQ29uZmlndXJhdGlvbjwvYT48L2xpPlxcbiAgICAgICAgICA8bGk+PGEgaHJlZj1cXFwiL2FkbWluL3Rhc2tzXFxcIiBjbGFzcz1cXFwibGluay1hZG1pblxcXCIgZGF0YS10YXJnZXQ9XFxcInRhc2tzXFxcIj5UYXNrczwvYT48L2xpPlxcbiAgICAgICAgPC91bD5cXG4gICAgICA8L2Rpdj48IS0tIC8ubmF2YmFyLWNvbGxhcHNlIC0tPlxcbiAgICA8L25hdj5cXG5cXG4gIDwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwiY29sLXNtLTkgY29sLW1kLTkgc20tbm9wYWRkaW5nXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiYWRtaW4tY29udGFpbmVyXFxcIiBpZD1cXFwiYWRtaW4tdXNlclxcXCI+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJhZG1pbi1jb250YWluZXJcXFwiIGlkPVxcXCJhZG1pbi10YWdcXFwiPlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiYWRtaW4tY29udGFpbmVyXFxcIiBpZD1cXFwiYWRtaW4tdGFza1xcXCI+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJhZG1pbi1jb250YWluZXJcXFwiIGlkPVxcXCJhZG1pbi1kYXNoYm9hcmRcXFwiPlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjx1bCBjbGFzcz1cXFwicGFnaW5hdGlvblxcXCIgZGF0YS1maWx0ZXI9XFxcIjwlIHEgJT5cXFwiPlxcbiAgPCUgaWYgKHBhZ2UgPiAzKSB7ICU+XFxuICA8bGk+PGEgaHJlZj1cXFwiI1xcXCI+JmxhcXVvOzwvYT48L2xpPlxcbiAgPCUgfSAlPlxcbiAgPCVcXG4gIHZhciBzdGFydCA9IE1hdGgubWF4KDEsIHBhZ2UtMik7XFxuICB2YXIgY2VpbCA9IE1hdGguY2VpbChjb3VudC90cnVlTGltaXQpO1xcbiAgaWYgKGNlaWwgPCBwYWdlICsgMikge1xcbiAgICBzdGFydCA9IE1hdGgubWF4KDEsIGNlaWwgLSA0KTtcXG4gIH1cXG4gIHZhciBtYXggPSBNYXRoLm1pbihwYWdlICsgMiwgY2VpbCk7XFxuICBpZiAoKGNlaWwgPiA1KSAmJiAoKHBhZ2UgKyAyKSA8IDUpKSB7XFxuICAgIG1heCA9IDU7XFxuICB9XFxuICAlPlxcbiAgPCUgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDw9IG1heDsgaSsrKSB7ICU+XFxuICA8bGkgPCUgaWYgKGkgPT0gcGFnZSkgeyAlPmNsYXNzPVxcXCJhY3RpdmVcXFwiPCUgfSAlPj48YSBjbGFzcz1cXFwicGFnZVxcXCIgZGF0YS1wYWdlPVxcXCI8JS0gaSAlPlxcXCIgaHJlZj1cXFwiPCUtIHVybGJhc2UgJT4/cD08JS0gaSAlPiZxPTwlLSBxICU+XFxcIj48JS0gaSAlPiA8JSBpZiAoaSA9PSBwYWdlKSB7ICU+PHNwYW4gY2xhc3M9XFxcInNyLW9ubHlcXFwiPihjdXJyZW50KTwvc3Bhbj48JSB9ICU+PC9hPjwvbGk+XFxuICA8JSB9ICU+XFxuICA8JSBpZiAoY2VpbCA+IChwYWdlICsgMikpIHsgJT5cXG4gIDxsaT48YSBocmVmPVxcXCIjXFxcIj4mcmFxdW87PC9hPjwvbGk+XFxuICA8JSB9ICU+XFxuPC91bD5cXG5cIjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJhbGVydCBhbGVydC1kYW5nZXJcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIj5cXG48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTEyIGJveCBib3gtcGFkLWxyXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMTIgYm94LXBhZC1iXFxcIj5cXG4gICAgICAgIDxoMj5GaW5kIGFuZCBhZGQgdGFnczwvaDI+XFxuICAgICAgICA8cD5TZWFyY2ggaW4gdGhlIGZpZWxkcyBiZWxvdyB0byBzZWUgZXhpc3RpbmcgdGFncy4gVHlwZSBhIG5ldyB0YWcgdmFsdWUgdG8gY3JlYXRlIGl0LjwvcD5cXG4gICAgICAgIDwlIF8odHlwZXMpLmZvckVhY2goZnVuY3Rpb24odGFnKSB7ICU+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJvdyBib3gtcGFkLWIgYm94LXBhZC10XFxcIj5cXG4gICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCI8JT0gdGFnICU+XFxcIiBjbGFzcz1cXFwiY29sLW1kLTIgY29udHJvbC1sYWJlbFxcXCI+PCU9IHRhZyAlPjo8L2xhYmVsPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0xMFxcXCI+XFxuICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwiaGlkZGVuXFxcIiBpZD1cXFwiPCU9IHRhZyAlPlxcXCIgbmFtZT1cXFwiPCU9IHRhZyAlPlxcXCIgc3R5bGU9XFxcIndpZHRoOiAxMDAlXFxcIi8+XFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLXN0YXR1cyB0ZXh0LXN1Y2Nlc3NcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwlIH0pOyAlPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImFsZXJ0IGFsZXJ0LWRhbmdlclxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPlxcbjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMTIgYm94IGJveC1wYWQtbHJcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0xMlxcXCI+XFxuXFxuICAgICAgICA8ZGl2IHJvbGU9XFxcInRhYnBhbmVsXFxcIj5cXG5cXG4gICAgICAgICAgPCEtLSBOYXYgdGFicyAtLT5cXG4gICAgICAgICAgPHVsIGNsYXNzPVxcXCJuYXYgbmF2LXRhYnMgYm94LXBhZC10XFxcIiByb2xlPVxcXCJ0YWJsaXN0XFxcIj5cXG4gICAgICAgICAgICA8bGkgcm9sZT1cXFwicHJlc2VudGF0aW9uXFxcIj5cXG4gICAgICAgICAgICAgIDxhIGhyZWY9XFxcIiNkcmFmdHNcXFwiIGFyaWEtY29udHJvbHM9XFxcIm9wZW5cXFwiIHJvbGU9XFxcInRhYlxcXCIgZGF0YS10b2dnbGU9XFxcInRhYlxcXCI+XFxuICAgICAgICAgICAgICAgIERyYWZ0czogPCUtIGRyYWZ0cy5sZW5ndGggJT5cXG4gICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgIDxsaSByb2xlPVxcXCJwcmVzZW50YXRpb25cXFwiIGNsYXNzPVxcXCJhY3RpdmVcXFwiPlxcbiAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiI29wZW5cXFwiIGFyaWEtY29udHJvbHM9XFxcIm9wZW5cXFwiIHJvbGU9XFxcInRhYlxcXCIgZGF0YS10b2dnbGU9XFxcInRhYlxcXCI+XFxuICAgICAgICAgICAgICAgIE9wZW46IDwlLSBvcGVuLmxlbmd0aCAlPlxcbiAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgPGxpIHJvbGU9XFxcInByZXNlbnRhdGlvblxcXCI+XFxuICAgICAgICAgICAgICA8YSBocmVmPVxcXCIjc2lnbnVwc1xcXCIgYXJpYS1jb250cm9scz1cXFwic2lnbnVwc1xcXCIgcm9sZT1cXFwidGFiXFxcIiBkYXRhLXRvZ2dsZT1cXFwidGFiXFxcIj5cXG4gICAgICAgICAgICAgICAgU2lnbi11cHM6IDwlLSB3aXRoU2lnbnVwcy5sZW5ndGggJT5cXG4gICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgIDxsaSByb2xlPVxcXCJwcmVzZW50YXRpb25cXFwiPlxcbiAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiI2Fzc2lnbmVkXFxcIiBhcmlhLWNvbnRyb2xzPVxcXCJhc3NpZ25lZFxcXCIgcm9sZT1cXFwidGFiXFxcIiBkYXRhLXRvZ2dsZT1cXFwidGFiXFxcIj5cXG4gICAgICAgICAgICAgICAgQXNzaWduZWQ6IDwlLSBhc3NpZ25lZC5sZW5ndGggJT5cXG4gICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgIDxsaSByb2xlPVxcXCJwcmVzZW50YXRpb25cXFwiPlxcbiAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiI2NvbXBsZXRlZFxcXCIgYXJpYS1jb250cm9scz1cXFwiY29tcGxldGVkXFxcIiByb2xlPVxcXCJ0YWJcXFwiIGRhdGEtdG9nZ2xlPVxcXCJ0YWJcXFwiPlxcbiAgICAgICAgICAgICAgICBDb21wbGV0ZWQ6IDwlLSBjb21wbGV0ZWQubGVuZ3RoICU+XFxuICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgPC91bD5cXG5cXG4gICAgICAgICAgPCEtLSBUYWIgcGFuZXMgLS0+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInRhYi1jb250ZW50IGJveC1wYWQtdFxcXCI+XFxuICAgICAgICAgICAgPGRpdiByb2xlPVxcXCJ0YWJwYW5lbFxcXCIgY2xhc3M9XFxcInRhYi1wYW5lXFxcIiBpZD1cXFwiZHJhZnRzXFxcIj5cXG4gICAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwibWV0cmljc1xcXCI+XFxuICAgICAgICAgICAgICAgIDwlIF8oZHJhZnRzKS5mb3JFYWNoKGZ1bmN0aW9uKHRhc2spIHsgJT5cXG4gICAgICAgICAgICAgICAgICA8bGk+XFxuICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCIvdGFza3MvPCUtIHRhc2suaWQgJT5cXFwiPjwlLSB0YXNrLnRpdGxlICU+PC9hPixcXG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIi9wcm9maWxlLzwlLSB0YXNrLnVzZXIuaWQgJT5cXFwiPjwlLSB0YXNrLnVzZXIubmFtZSB8fCB0YXNrLnVzZXIudXNlcm5hbWUgJT48L2E+XFxuICAgICAgICAgICAgICAgICAgICA8JSBpZiAodGFzay52b2x1bnRlZXJzLmxlbmd0aCkgeyAlPlxcbiAgICAgICAgICAgICAgICAgICAgPHA+U2lnbi11cHM6XFxuICAgICAgICAgICAgICAgICAgICAgIDwlIF8odGFzay52b2x1bnRlZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKHZvbCkgeyAlPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIi9wcm9maWxlLzwlLSB0YXNrLnVzZXIuaWQgJT5cXFwiPjwlLSB2b2wudXNlci5uYW1lIHx8IHZvbC51c2VyLnVzZXJuYW1lICU+PC9hPlxcbiAgICAgICAgICAgICAgICAgICAgICA8JSB9KTsgJT5cXG4gICAgICAgICAgICAgICAgICAgIDwvcD5cXG4gICAgICAgICAgICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgICA8JSB9KTsgJT5cXG4gICAgICAgICAgICAgIDwvdWw+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiByb2xlPVxcXCJ0YWJwYW5lbFxcXCIgY2xhc3M9XFxcInRhYi1wYW5lIGFjdGl2ZVxcXCIgaWQ9XFxcIm9wZW5cXFwiPlxcbiAgICAgICAgICAgICAgPHVsIGNsYXNzPVxcXCJtZXRyaWNzXFxcIj5cXG4gICAgICAgICAgICAgICAgPCUgXyhvcGVuKS5mb3JFYWNoKGZ1bmN0aW9uKHRhc2spIHsgJT5cXG4gICAgICAgICAgICAgICAgICA8bGk+XFxuICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCIvdGFza3MvPCUtIHRhc2suaWQgJT5cXFwiPjwlLSB0YXNrLnRpdGxlICU+PC9hPixcXG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIi9wcm9maWxlLzwlLSB0YXNrLnVzZXIuaWQgJT5cXFwiPjwlLSB0YXNrLnVzZXIubmFtZSB8fCB0YXNrLnVzZXIudXNlcm5hbWUgJT48L2E+XFxuICAgICAgICAgICAgICAgICAgICA8JSBpZiAodGFzay52b2x1bnRlZXJzLmxlbmd0aCkgeyAlPlxcbiAgICAgICAgICAgICAgICAgICAgPHA+U2lnbi11cHM6XFxuICAgICAgICAgICAgICAgICAgICAgIDwlIF8odGFzay52b2x1bnRlZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKHZvbCkgeyAlPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIi9wcm9maWxlLzwlLSB0YXNrLnVzZXIuaWQgJT5cXFwiPjwlLSB2b2wudXNlci5uYW1lIHx8IHZvbC51c2VyLnVzZXJuYW1lICU+PC9hPlxcbiAgICAgICAgICAgICAgICAgICAgICA8JSB9KTsgJT5cXG4gICAgICAgICAgICAgICAgICAgIDwvcD5cXG4gICAgICAgICAgICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgICA8JSB9KTsgJT5cXG4gICAgICAgICAgICAgIDwvdWw+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiByb2xlPVxcXCJ0YWJwYW5lbFxcXCIgY2xhc3M9XFxcInRhYi1wYW5lXFxcIiBpZD1cXFwic2lnbnVwc1xcXCI+XFxuICAgICAgICAgICAgICA8dWwgY2xhc3M9XFxcIm1ldHJpY3NcXFwiPlxcbiAgICAgICAgICAgICAgICA8JSBfKHdpdGhTaWdudXBzKS5mb3JFYWNoKGZ1bmN0aW9uKHRhc2spIHsgJT5cXG4gICAgICAgICAgICAgICAgICA8bGk+XFxuICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCIvdGFza3MvPCUtIHRhc2suaWQgJT5cXFwiPjwlLSB0YXNrLnRpdGxlICU+PC9hPixcXG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIi9wcm9maWxlLzwlLSB0YXNrLnVzZXIuaWQgJT5cXFwiPjwlLSB0YXNrLnVzZXIubmFtZSB8fCB0YXNrLnVzZXIudXNlcm5hbWUgJT48L2E+XFxuICAgICAgICAgICAgICAgICAgICA8JSBpZiAodGFzay52b2x1bnRlZXJzLmxlbmd0aCkgeyAlPlxcbiAgICAgICAgICAgICAgICAgICAgICA8cD5TaWduLXVwczpcXG4gICAgICAgICAgICAgICAgICAgICAgICA8JSBfKHRhc2sudm9sdW50ZWVycykuZm9yRWFjaChmdW5jdGlvbih2b2wpIHsgJT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIi9wcm9maWxlLzwlLSB0YXNrLnVzZXIuaWQgJT5cXFwiPjwlLSB2b2wudXNlci5uYW1lIHx8IHZvbC51c2VyLnVzZXJuYW1lICU+PC9hPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwlIH0pOyAlPlxcbiAgICAgICAgICAgICAgICAgICAgICA8L3A+XFxuICAgICAgICAgICAgICAgICAgICA8JSB9ICU+XFxuICAgICAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICAgICAgPCUgfSk7ICU+XFxuICAgICAgICAgICAgICA8L3VsPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgcm9sZT1cXFwidGFicGFuZWxcXFwiIGNsYXNzPVxcXCJ0YWItcGFuZVxcXCIgaWQ9XFxcImFzc2lnbmVkXFxcIj5cXG4gICAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwibWV0cmljc1xcXCI+XFxuICAgICAgICAgICAgICAgIDwlIF8oYXNzaWduZWQpLmZvckVhY2goZnVuY3Rpb24odGFzaykgeyAlPlxcbiAgICAgICAgICAgICAgICAgIDxsaT5cXG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIi90YXNrcy88JS0gdGFzay5pZCAlPlxcXCI+PCUtIHRhc2sudGl0bGUgJT48L2E+LFxcbiAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiL3Byb2ZpbGUvPCUtIHRhc2sudXNlci5pZCAlPlxcXCI+PCUtIHRhc2sudXNlci5uYW1lIHx8IHRhc2sudXNlci51c2VybmFtZSAlPjwvYT5cXG4gICAgICAgICAgICAgICAgICAgIDwlIGlmICh0YXNrLnZvbHVudGVlcnMubGVuZ3RoKSB7ICU+XFxuICAgICAgICAgICAgICAgICAgICAgIDxwPlNpZ24tdXBzOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwlIF8odGFzay52b2x1bnRlZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKHZvbCkgeyAlPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiL3Byb2ZpbGUvPCUtIHRhc2sudXNlci5pZCAlPlxcXCI+PCUtIHZvbC51c2VyLm5hbWUgfHwgdm9sLnVzZXIudXNlcm5hbWUgJT48L2E+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPCUgfSk7ICU+XFxuICAgICAgICAgICAgICAgICAgICAgIDwvcD5cXG4gICAgICAgICAgICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgICA8JSB9KTsgJT5cXG4gICAgICAgICAgICAgIDwvdWw+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiByb2xlPVxcXCJ0YWJwYW5lbFxcXCIgY2xhc3M9XFxcInRhYi1wYW5lXFxcIiBpZD1cXFwiY29tcGxldGVkXFxcIj5cXG4gICAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwibWV0cmljc1xcXCI+XFxuICAgICAgICAgICAgICAgIDwlIF8oY29tcGxldGVkKS5mb3JFYWNoKGZ1bmN0aW9uKHRhc2spIHsgJT5cXG4gICAgICAgICAgICAgICAgICA8bGk+XFxuICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCIvdGFza3MvPCUtIHRhc2suaWQgJT5cXFwiPjwlLSB0YXNrLnRpdGxlICU+PC9hPixcXG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIi9wcm9maWxlLzwlLSB0YXNrLnVzZXIuaWQgJT5cXFwiPjwlLSB0YXNrLnVzZXIubmFtZSB8fCB0YXNrLnVzZXIudXNlcm5hbWUgJT48L2E+XFxuICAgICAgICAgICAgICAgICAgICA8JSBpZiAodGFzay52b2x1bnRlZXJzLmxlbmd0aCkgeyAlPlxcbiAgICAgICAgICAgICAgICAgICAgICA8cD5TaWduLXVwczpcXG4gICAgICAgICAgICAgICAgICAgICAgICA8JSBfKHRhc2sudm9sdW50ZWVycykuZm9yRWFjaChmdW5jdGlvbih2b2wpIHsgJT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIi9wcm9maWxlLzwlLSB0YXNrLnVzZXIuaWQgJT5cXFwiPjwlLSB2b2wudXNlci5uYW1lIHx8IHZvbC51c2VyLnVzZXJuYW1lICU+PC9hPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwlIH0pOyAlPlxcbiAgICAgICAgICAgICAgICAgICAgICA8L3A+XFxuICAgICAgICAgICAgICAgICAgICA8JSB9ICU+XFxuICAgICAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICAgICAgPCUgfSk7ICU+XFxuICAgICAgICAgICAgICA8L3VsPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgIDwvZGl2PlxcblxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxmb3JtIGFjdGlvbj1cXFwiXFxcIiBpZD1cXFwicmVzZXQtcGFzc3dvcmRcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwibW9kYWwtYm9keVxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImFsZXJ0IGFsZXJ0LWRhbmdlclxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPlxcbiAgICA8L2Rpdj5cXG4gICAgPGZpZWxkc2V0PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwibmV3UGFzc3dvcmRcXFwiPk5ldyBQYXNzd29yZCBmb3IgPCUtIHUubmFtZSAlPjwvbGFiZWw+XFxuICAgICAgICA8aW5wdXQgdHlwZT1cXFwicGFzc3dvcmRcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIGlkPVxcXCJuZXdQYXNzd29yZFxcXCIgbmFtZT1cXFwicGFzc3dvcmRcXFwiIHBsYWNlaG9sZGVyPVxcXCJOZXcgUGFzc3dvcmRcXFwiIGRhdGEtdmFsaWRhdGU9XFxcImVtcHR5XFxcIj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJoZWxwLWJsb2NrIGVycm9yLWVtcHR5XFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI+WW91IG11c3QgZW50ZXIgYSBwYXNzd29yZC48L3NwYW4+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZmllbGRzZXQ+XFxuICA8L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWZvb3RlclxcXCI+XFxuICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1jMFxcXCIgZGF0YS1kaXNtaXNzPVxcXCJtb2RhbFxcXCI+Q2FuY2VsPC9idXR0b24+XFxuICAgIDxpbnB1dCB0eXBlPVxcXCJzdWJtaXRcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWMyXFxcIiBpZD1cXFwic3VibWl0XFxcIiB2YWx1ZT1cXFwiQ2hhbmdlIFBhc3N3b3JkXFxcIi8+XFxuICA8L2Rpdj5cXG48L2Zvcm0+XFxuXCI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHRhYmxlIGNsYXNzPVxcXCJ0YWJsZSB0YWJsZS1ob3ZlciB0YWJsZS1jb25kZW5zZWRcXFwiPlxcbiAgPHRoZWFkPlxcbiAgICA8dHI+XFxuICAgICAgPHRoIGNsYXNzPVxcXCJhZG1pbi11c2VyLWlkXFxcIj4jPC90aD5cXG4gICAgICA8dGg+TmFtZTwvdGg+XFxuICAgICAgPHRoPkVtYWlsPC90aD5cXG4gICAgICA8dGg+Q3JlYXRlZCBBdDwvdGg+XFxuICAgICAgPHRoPjxzcGFuIGRhdGEtaTE4bj1cXFwiUHJvamVjdFBsdXJhbFxcXCI+UHJvamVjdHM8L3NwYW4+IChvcGVuIC8gY2xvc2VkKTwvdGg+XFxuICAgICAgPHRoPjxzcGFuIGRhdGEtaTE4bj1cXFwiVGFza1BsdXJhbFxcXCI+VGFza3M8L3NwYW4+IChvcGVuIC8gYXNzaWduZWQgLyBjb21wbGV0ZWQgLyBhcmNoaXZlZCk8L3RoPlxcbiAgICAgIDx0aD5Wb2x1bnRlZXIgKG9wZW4gLyBhc3NpZ25lZCAvIGNvbXBsZXRlZCAvIGFyY2hpdmVkKTwvdGg+XFxuICAgICAgPHRoIGNsYXNzPVxcXCJhZG1pbi11c2VyLWNoZWNrYm94XFxcIj5FbmFibGVkPC90aD5cXG4gICAgICA8JSBpZiAobG9naW4ubG9jYWwuZW5hYmxlZCA9PT0gdHJ1ZSkgeyAlPlxcbiAgICAgIDx0aCBjbGFzcz1cXFwiYWRtaW4tdXNlci1jaGVja2JveFxcXCI+UGFzc3dvcmQ8L3RoPlxcbiAgICAgIDwlIH0gJT5cXG4gICAgICA8dGggY2xhc3M9XFxcImFkbWluLXVzZXItY2hlY2tib3hcXFwiPkFkbWluPC90aD5cXG4gICAgPC90cj5cXG4gIDwvdGhlYWQ+XFxuICA8dGJvZHk+XFxuICAgIDwlIGlmICh1c2Vycy5sZW5ndGggPT09IDApIHsgJT5cXG4gICAgPHRyIGNsYXNzPVxcXCJlbXB0eS1yb3dcXFwiPlxcbiAgICAgIDx0ZCBjb2xzcGFuPVxcXCI1XFxcIj5cXG4gICAgICAgIE5vIHVzZXJzIGZvdW5kLlxcbiAgICAgIDwvdGQ+XFxuICAgIDwvdHI+XFxuICAgIDwlIH0gJT5cXG4gICAgPCUgXy5lYWNoKHVzZXJzLCBmdW5jdGlvbiAodSkgeyAlPlxcbiAgICA8dHIgZGF0YS1pZD1cXFwiPCUtIHUuaWQgJT5cXFwiPlxcbiAgICAgIDx0ZD5cXG4gICAgICAgIDwlLSB1LmlkICU+XFxuICAgICAgPC90ZD5cXG4gICAgICA8dGQgY2xhc3M9XFxcImFkbWluLXRhYmxlLW5hbWVcXFwiPlxcbiAgICAgICAgPCUtIHUubmFtZSAlPlxcbiAgICAgIDwvdGQ+XFxuICAgICAgPHRkIGNsYXNzPVxcXCJhZG1pbi10YWJsZS11c2VybmFtZVxcXCI+XFxuICAgICAgICA8YSBjbGFzcz1cXFwibGluay1iYWNrYm9uZVxcXCIgaHJlZj1cXFwiL3Byb2ZpbGUvPCUtIHUuaWQgJT5cXFwiPjwlLSB1LnVzZXJuYW1lICU+PC9hPlxcbiAgICAgIDwvdGQ+XFxuICAgICAgPHRkIGNsYXNzPVxcXCJhZG1pbi10YWJsZS1jcmVhdGVkYXRcXFwiPlxcbiAgICAgICAgPCEtLSBkYXkgLS0+XFxuICAgICAgICA8JSB2YXIgY3JlYXRlZCA9IG5ldyBEYXRlKHUuY3JlYXRlZEF0KTsgJT5cXG4gICAgICAgIDwlPSBjcmVhdGVkLnRvTG9jYWxlRGF0ZVN0cmluZygpICU+XFxuICAgICAgICA8IS0tIHRpbWUgLS0+XFxuICAgICAgICA8JT0gY3JlYXRlZC50b0xvY2FsZVRpbWVTdHJpbmcoKSAlPlxcbiAgICAgIDwvdGQ+XFxuICAgICAgPHRkIGNsYXNzPVxcXCJhZG1pbi10YWJsZS1wcm9qZWN0c1xcXCI+XFxuICAgICAgPCUgaWYgKHUucHJvamVjdHNDcmVhdGVkT3BlbiAhPT0gMCB8fCB1LnByb2plY3RzQ3JlYXRlZENsb3NlZCAhPT0gMCkgeyAlPlxcbiAgICAgICAgPGEgY2xhc3M9XFxcImxpbmstYmFja2JvbmVcXFwiIGhyZWY9XFxcIi9wcm9maWxlLzwlLSB1LmlkICU+XFxcIj48JS0gdS5wcm9qZWN0c0NyZWF0ZWRPcGVuICU+IC8gPCUtIHUucHJvamVjdHNDcmVhdGVkQ2xvc2VkICU+PC9hPlxcbiAgICAgIDwlIH0gJT5cXG4gICAgICA8L3RkPlxcbiAgICAgIDx0ZCBjbGFzcz1cXFwiYWRtaW4tdGFibGUtdGFza3NcXFwiPlxcbiAgICAgIDwlIGlmICh1LnRhc2tzQ3JlYXRlZE9wZW4gIT09IDAgfHwgdS50YXNrc0NyZWF0ZWRBc3NpZ25lZCAhPT0gMCB8fCB1LnRhc2tzQ3JlYXRlZENvbXBsZXRlZCAhPT0gMCB8fCB1LnRhc2tzQ3JlYXRlZEFyY2hpdmVkICE9PSAwKSB7ICU+XFxuICAgICAgICA8YSBjbGFzcz1cXFwibGluay1iYWNrYm9uZVxcXCIgaHJlZj1cXFwiL3Byb2ZpbGUvPCUtIHUuaWQgJT5cXFwiPjwlLSB1LnRhc2tzQ3JlYXRlZE9wZW4gJT4gLyA8JS0gdS50YXNrc0NyZWF0ZWRBc3NpZ25lZCAlPiAvIDwlLSB1LnRhc2tzQ3JlYXRlZENvbXBsZXRlZCAlPiAvIDwlLSB1LnRhc2tzQ3JlYXRlZEFyY2hpdmVkICU+PC9hPlxcbiAgICAgIDwlIH0gJT5cXG4gICAgICA8L3RkPlxcbiAgICAgIDx0ZCBjbGFzcz1cXFwiYWRtaW4tdGFibGUtdm9sdW50ZWVyXFxcIj5cXG4gICAgICA8JSBpZiAodS52b2xDb3VudE9wZW4gIT09IDAgfHwgdS52b2xDb3VudEFzc2lnbmVkICE9PSAwIHx8IHUudm9sQ291bnRDb21wbGV0ZWQgIT09IDAgfHwgdS52b2xDb3VudEFyY2hpdmVkICE9PSAwKSB7ICU+XFxuICAgICAgICA8YSBjbGFzcz1cXFwibGluay1iYWNrYm9uZVxcXCIgaHJlZj1cXFwiL3Byb2ZpbGUvPCUtIHUuaWQgJT5cXFwiPjwlLSB1LnZvbENvdW50T3BlbiAlPiAvIDwlLSB1LnZvbENvdW50QXNzaWduZWQgJT4gLyA8JS0gdS52b2xDb3VudENvbXBsZXRlZCAlPiAvIDwlLSB1LnZvbENvdW50QXJjaGl2ZWQgJT48L2E+XFxuICAgICAgPCUgfSAlPlxcbiAgICAgIDwvdGQ+XFxuICAgICAgPHRkPlxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgYnRuLXhzIGFkbWluLXVzZXItZW5hYmxlXFxcIiBkYXRhLXRvZ2dsZT1cXFwidG9vbHRpcFxcXCIgZGF0YS1wbGFjZW1lbnQ9XFxcInRvcFxcXCIgdGl0bGU9XFxcIkVuYWJsZVxcXCIgPCUgaWYgKHUuZGlzYWJsZWQgIT09IHRydWUpIHsgJT5zdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI8JSB9ICU+PjxpIGNsYXNzPVxcXCJmYSBmYS1yZW1vdmUtc2lnbiBpY29uLXJlZCBpY29uLWNlbnRlclxcXCI+PC9pPjwvYnV0dG9uPlxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgYnRuLXhzIGFkbWluLXVzZXItZGlzYWJsZVxcXCIgZGF0YS10b2dnbGU9XFxcInRvb2x0aXBcXFwiIGRhdGEtcGxhY2VtZW50PVxcXCJ0b3BcXFwiIHRpdGxlPVxcXCJEaXNhYmxlXFxcIiA8JSBpZiAodS5kaXNhYmxlZCA9PT0gdHJ1ZSkgeyAlPnN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIjwlIH0gJT4+PGkgY2xhc3M9XFxcImZhIGZhLWNoZWNrIGljb24tZ3JlZW4gaWNvbi1jZW50ZXJcXFwiPjwvaT48L2J1dHRvbj5cXG4gICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi14cyBidG4tc3BpblxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPjxpIGNsYXNzPVxcXCJmYS1zcGluIGZhIGZhLXNwaW5uZXIgaWNvbi1jZW50ZXJcXFwiPjwvaT48L2J1dHRvbj5cXG4gICAgICA8L3RkPlxcbiAgICAgIDwlIGlmIChsb2dpbi5sb2NhbC5lbmFibGVkID09PSB0cnVlKSB7ICU+XFxuICAgICAgPHRkPlxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgYnRuLXhzIGFkbWluLXVzZXItcmVzZXRwd1xcXCIgZGF0YS10b2dnbGU9XFxcInRvb2x0aXBcXFwiIGRhdGEtcGxhY2VtZW50PVxcXCJ0b3BcXFwiIHRpdGxlPVxcXCJSZXNldCBQYXNzd29yZFxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLWNoZWNrIGZhLWNvZ1xcXCI+PC9pPjwvYnV0dG9uPlxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgYnRuLXhzIGFkbWluLXVzZXItdW5sb2NrXFxcIiBkYXRhLXRvZ2dsZT1cXFwidG9vbHRpcFxcXCIgZGF0YS1wbGFjZW1lbnQ9XFxcInRvcFxcXCIgdGl0bGU9XFxcIlVubG9jayBVc2VyIChjbGVhciBwYXNzd29yZCBhdHRlbXB0cylcXFwiIDwlIGlmICh1LmxvY2tlZCAhPT0gdHJ1ZSkgeyAlPnN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIjwlIH0gJT4+PGkgY2xhc3M9XFxcImZhIGZhLWNoZWNrIGljb24tcmVkIGZhLWxvY2tcXFwiPjwvaT48L2J1dHRvbj5cXG4gICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi14cyBidG4tc3BpblxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1zcGluIGZhLXNwaW5uZXIgaWNvbi1jZW50ZXJcXFwiPjwvaT48L2J1dHRvbj5cXG4gICAgICA8L3RkPlxcbiAgICAgIDwlIH0gJT5cXG4gICAgICA8dGQ+XFxuICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBidG4teHMgYWRtaW4tdXNlci1ybWFkbWluXFxcIiBkYXRhLXRvZ2dsZT1cXFwidG9vbHRpcFxcXCIgZGF0YS1wbGFjZW1lbnQ9XFxcInRvcFxcXCIgdGl0bGU9XFxcIlJlbW92ZSBBZG1pbiBQcml2aWxlZGdlc1xcXCIgPCUgaWYgKHUuaXNBZG1pbiAhPT0gdHJ1ZSkgeyAlPnN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIjwlIH0gJT4+PGkgY2xhc3M9XFxcImZhIGZhLWNoZWNrIGljb24tZ3JlZW4gaWNvbi1jZW50ZXJcXFwiPjwvaT48L2J1dHRvbj5cXG4gICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi14cyBhZG1pbi11c2VyLW1rYWRtaW5cXFwiIGRhdGEtdG9nZ2xlPVxcXCJ0b29sdGlwXFxcIiBkYXRhLXBsYWNlbWVudD1cXFwidG9wXFxcIiB0aXRsZT1cXFwiTWFrZSBBZG1pblxcXCIgPCUgaWYgKHUuaXNBZG1pbiA9PT0gdHJ1ZSkgeyAlPnN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIjwlIH0gJT4+PGkgY2xhc3M9XFxcImZhIGZhLXRpbWVzLWNpcmNsZSBpY29uLXJlZCBpY29uLWNlbnRlclxcXCI+PC9pPjwvYnV0dG9uPlxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgYnRuLXhzIGJ0bi1zcGluXFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXNwaW4gZmEtc3Bpbm5lciBpY29uLWNlbnRlclxcXCI+PC9pPjwvYnV0dG9uPlxcbiAgICAgIDwvdGQ+XFxuICAgIDwvdHI+XFxuICAgIDwlIH0pOyAlPlxcbiAgPC90Ym9keT5cXG48L3RhYmxlPlxcblwiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImFsZXJ0IGFsZXJ0LWRhbmdlclxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPlxcbjwvZGl2PlxcbjxkaXYgaWQ9XFxcInJlc2V0LXBhc3N3b3JkLWNvbnRhaW5lclxcXCI+PC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0xMiBib3ggYm94LXBhZC1sclxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLWxnLTggY29sLW1kLTcgY29sLXNtLTUgc20tbm9wYWRkaW5nIG1kLW5vcGFkZGluZ1xcXCI+XFxuXFxuICAgICAgPGZvcm0gY2xhc3M9XFxcImZvcm0taW5saW5lIGZ1bGx3aWR0aFxcXCIgcm9sZT1cXFwiZm9ybVxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwIGZ1bGx3aWR0aFxcXCI+XFxuICAgICAgICAgIDxsYWJlbCBjbGFzcz1cXFwic3Itb25seVxcXCIgZm9yPVxcXCJ1c2VyLWZpbHRlclxcXCI+RmlsdGVyPC9sYWJlbD5cXG4gICAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2wgZnVsbHdpZHRoXFxcIiBpZD1cXFwidXNlci1maWx0ZXJcXFwiIHBsYWNlaG9sZGVyPVxcXCJGaWx0ZXJcXFwiPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9mb3JtPlxcblxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1sZy00IGNvbC1tZC01IGNvbC1zbS03IHNtLW5vcGFkZGluZyBtZC1ub3BhZGRpbmctcmlnaHRcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwicHVsbC1yaWdodFxcXCIgaWQ9XFxcInVzZXItcGFnZVxcXCI+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTEyIHNtLW5vcGFkZGluZyBtZC1ub3BhZGRpbmdcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiZnVsbHdpZHRoIHRleHQtY2VudGVyIHNwaW5uZXJcXFwiPlxcbiAgICAgICAgICBMb2FkaW5nLi4uIDxpIGNsYXNzPVxcXCJmYSBmYS1zcGlubmVyIGZhLXNwaW5cXFwiPjwvaT5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMTIgc20tbm9wYWRkaW5nIG1kLW5vcGFkZGluZ1xcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0YWJsZS1yZXNwb25zaXZlXFxcIj5cXG5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZGl2PlwiO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vbWl4aW5zL3V0aWxpdGllcycpO1xudmFyIE1vZGFsQ29tcG9uZW50ID0gcmVxdWlyZSgnLi4vLi4vLi4vY29tcG9uZW50cy9tb2RhbCcpO1xudmFyIEFkbWluRGFzaGJvYXJkVGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvYWRtaW5fZGFzaGJvYXJkX3RlbXBsYXRlLmh0bWwnKTtcbnZhciBBZG1pbkRhc2hib2FyZFRhYmxlID0gcmVxdWlyZSgnLi4vdGVtcGxhdGVzL2FkbWluX2Rhc2hib2FyZF90YWJsZS5odG1sJyk7XG52YXIgQWRtaW5EYXNoYm9hcmRBY3Rpdml0aWVzID0gcmVxdWlyZSgnLi4vdGVtcGxhdGVzL2FkbWluX2Rhc2hib2FyZF9hY3Rpdml0aWVzLmh0bWwnKTtcbnZhciBMb2dpbkNvbmZpZyA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbmZpZy9sb2dpbi5qc29uJyk7XG5cblxudmFyIEFkbWluRGFzaGJvYXJkVmlldyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcblxuICBldmVudHM6IHtcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5kYXRhID0ge1xuICAgICAgcGFnZTogMVxuICAgIH07XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIEJhY2tib25lLmhpc3RvcnkubmF2aWdhdGUoJy9hZG1pbi9kYXNoYm9hcmQnKTtcbiAgICB0aGlzLiRlbC5zaG93KCk7XG4gICAgaWYgKHRoaXMucmVuZGVyZWQgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIHVzZXI6IHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlcixcbiAgICAgIGxvZ2luOiBMb2dpbkNvbmZpZ1xuICAgIH07XG4gICAgdmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZShBZG1pbkRhc2hib2FyZFRlbXBsYXRlKShkYXRhKTtcbiAgICB0aGlzLiRlbC5odG1sKHRlbXBsYXRlKTtcbiAgICB0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcbiAgICAvLyBmZXRjaCBkYXRhXG4gICAgdGhpcy5mZXRjaERhdGEoc2VsZiwgdGhpcy5kYXRhKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICByZW5kZXJNZXRyaWNzOiBmdW5jdGlvbiAoc2VsZiwgZGF0YSkge1xuICAgIHZhciB0ZW1wbGF0ZSA9IF8udGVtcGxhdGUoQWRtaW5EYXNoYm9hcmRUYWJsZSkoZGF0YSk7XG4gICAgc2VsZi4kKFwiLm1ldHJpYy1ibG9ja1wiKS5odG1sKHRlbXBsYXRlKTtcbiAgICB0aGlzLiRlbC5pMThuKCk7XG4gICAgLy8gaGlkZSBzcGlubmVyIGFuZCBzaG93IHJlc3VsdHNcbiAgICBzZWxmLiQoXCIuc3Bpbm5lclwiKS5oaWRlKCk7XG4gICAgc2VsZi4kKFwiLm1ldHJpYy1ibG9ja1wiKS5zaG93KCk7XG4gIH0sXG5cbiAgcmVuZGVyQWN0aXZpdGllczogZnVuY3Rpb24gKHNlbGYsIGRhdGEpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBfLnRlbXBsYXRlKEFkbWluRGFzaGJvYXJkQWN0aXZpdGllcyk7XG4gICAgc2VsZi4kKFwiLmFjdGl2aXR5LWJsb2NrXCIpLmh0bWwodGVtcGxhdGUpO1xuICAgIF8oZGF0YSkuZm9yRWFjaChmdW5jdGlvbihhY3Rpdml0eSkge1xuICAgICAgaWYgKCFhY3Rpdml0eSkgcmV0dXJuO1xuICAgICAgLy8gU3RyaXAgSFRNTCBmcm9tIGNvbW1lbnRzXG4gICAgICBpZiAoYWN0aXZpdHkuY29tbWVudCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhY3Rpdml0eS5jb21tZW50LnZhbHVlLnJlcGxhY2UoLzwoPzoufFxcbikqPz4vZ20sICcnKTtcbiAgICAgICAgYWN0aXZpdHkuY29tbWVudC52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgLy8gRm9ybWF0IHRpbWVzdGFtcFxuICAgICAgYWN0aXZpdHkuY3JlYXRlZEF0Rm9ybWF0dGVkID0gJC50aW1lYWdvKGFjdGl2aXR5LmNyZWF0ZWRBdCk7XG4gICAgICB2YXIgdGVtcGxhdGUgPSBzZWxmLiQoJyMnICsgYWN0aXZpdHkudHlwZSkudGV4dCgpLFxuICAgICAgICAgIGNvbnRlbnQgPSBfLnRlbXBsYXRlKHRlbXBsYXRlLCB7IGVzY2FwZTogL1xce1xceyguKz8pXFx9XFx9L2cgfSkoYWN0aXZpdHkpO1xuICAgICAgc2VsZi4kKCcuYWN0aXZpdHktYmxvY2sgLmFjdGl2aXR5LWZlZWQnKS5hcHBlbmQoY29udGVudCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLiRlbC5pMThuKCk7XG4gICAgLy8gaGlkZSBzcGlubmVyIGFuZCBzaG93IHJlc3VsdHNcbiAgICBzZWxmLiQoXCIuc3Bpbm5lclwiKS5oaWRlKCk7XG4gICAgc2VsZi4kKFwiLmFjdGl2aXR5LWJsb2NrXCIpLnNob3coKTtcbiAgfSxcblxuICBmZXRjaERhdGE6IGZ1bmN0aW9uIChzZWxmLCBkYXRhKSB7XG4gICAgJC5hamF4KHtcbiAgICAgIHVybDogJy9hcGkvYWRtaW4vbWV0cmljcycsXG4gICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHNlbGYuZGF0YSA9IGRhdGE7XG4gICAgICAgICQuYWpheCh7XG4gICAgICAgICAgdXJsOiAnL2FwaS9hZG1pbi9pbnRlcmFjdGlvbnMnLFxuICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihpbnRlcmFjdGlvbnMpIHtcbiAgICAgICAgICAgIGRhdGEuaW50ZXJhY3Rpb25zID0gaW50ZXJhY3Rpb25zO1xuICAgICAgICAgICAgaW50ZXJhY3Rpb25zLmNvdW50ID0gXyhpbnRlcmFjdGlvbnMpLnJlZHVjZShmdW5jdGlvbihzdW0sIHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHN1bSArIHZhbHVlO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICBzZWxmLnJlbmRlck1ldHJpY3Moc2VsZiwgZGF0YSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKHhociwgc3RhdHVzLCBlcnJvcikge1xuICAgICAgICAgICAgc2VsZi5oYW5kbGVFcnJvcihzZWxmLCB4aHIsIHN0YXR1cywgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZXJyb3I6IGZ1bmN0aW9uICh4aHIsIHN0YXR1cywgZXJyb3IpIHtcbiAgICAgICAgc2VsZi5oYW5kbGVFcnJvcihzZWxmLCB4aHIsIHN0YXR1cywgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICAgICQuYWpheCh7XG4gICAgICB1cmw6ICcvYXBpL2FkbWluL2FjdGl2aXRpZXMnLFxuICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBzZWxmLmRhdGEgPSBkYXRhO1xuICAgICAgICBzZWxmLnJlbmRlckFjdGl2aXRpZXMoc2VsZiwgZGF0YSk7XG4gICAgICB9LFxuICAgICAgZXJyb3I6IGZ1bmN0aW9uICh4aHIsIHN0YXR1cywgZXJyb3IpIHtcbiAgICAgICAgc2VsZi5oYW5kbGVFcnJvcihzZWxmLCB4aHIsIHN0YXR1cywgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIGhhbmRsZUVycm9yOiBmdW5jdGlvbiAoc2VsZiwgeGhyLCBzdGF0dXMsIGVycm9yKSB7XG4gICAgLy8gc2hvdyB0aGUgYWxlcnQgbWVzc2FnZSBhbmQgaGlkZSB0aGUgc3Bpbm5lclxuICAgIHNlbGYuJCgnLmFsZXJ0JykuaHRtbChlcnJvci5tZXNzYWdlIHx8IGVycm9yKTtcbiAgICBzZWxmLiQoJy5hbGVydCcpLnNob3coKTtcbiAgICBzZWxmLiQoJy5zcGlubmVyJykuaGlkZSgpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZG1pbkRhc2hib2FyZFZpZXc7XG4iLCJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uL21peGlucy91dGlsaXRpZXMnKTtcbnZhciBBZG1pblVzZXJWaWV3ID0gcmVxdWlyZSgnLi9hZG1pbl91c2VyX3ZpZXcnKTtcbnZhciBBZG1pblRhZ1ZpZXcgPSByZXF1aXJlKCcuL2FkbWluX3RhZ192aWV3Jyk7XG52YXIgQWRtaW5UYXNrVmlldyA9IHJlcXVpcmUoJy4vYWRtaW5fdGFza192aWV3Jyk7XG52YXIgQWRtaW5EYXNoYm9hcmRWaWV3ID0gcmVxdWlyZSgnLi9hZG1pbl9kYXNoYm9hcmRfdmlldycpO1xudmFyIEFkbWluTWFpblRlbXBsYXRlID0gcmVxdWlyZSgnLi4vdGVtcGxhdGVzL2FkbWluX21haW5fdGVtcGxhdGUuaHRtbCcpO1xuXG5cbnZhciBBZG1pbk1haW5WaWV3ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuXG4gIGV2ZW50czoge1xuICAgICdjbGljayAubGluay1hZG1pbicgICAgICAgICAgICAgOiAnbGluaydcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGEgPSB7XG5cbiAgICB9O1xuICAgIHZhciB0ZW1wbGF0ZSA9IF8udGVtcGxhdGUoQWRtaW5NYWluVGVtcGxhdGUpKGRhdGEpO1xuICAgIHRoaXMuJGVsLmh0bWwodGVtcGxhdGUpO1xuICAgIHRoaXMucm91dGVUYXJnZXQodGhpcy5vcHRpb25zLmFjdGlvbiB8fCAnJyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcm91dGVUYXJnZXQ6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgdGFyZ2V0ID0gJ2Rhc2hib2FyZCc7XG4gICAgfVxuICAgIHZhciB0ID0gJCgodGhpcy4kKFwiW2RhdGEtdGFyZ2V0PVwiICsgdGFyZ2V0ICsgXCJdXCIpKVswXSk7XG4gICAgLy8gcmVtb3ZlIGFjdGl2ZSBjbGFzc2VzXG4gICAgJCgkKHQucGFyZW50cygndWwnKVswXSkuZmluZCgnbGknKSkucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgIC8vIG1ha2UgdGhlIGN1cnJlbnQgbGluayBhY3RpdmVcbiAgICAkKHQucGFyZW50KCdsaScpWzBdKS5hZGRDbGFzcygnYWN0aXZlJyk7XG4gICAgaWYgKHRhcmdldCA9PSAndXNlcicpIHtcbiAgICAgIGlmICghdGhpcy5hZG1pblVzZXJWaWV3KSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZUFkbWluVXNlclZpZXcoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGlkZU90aGVycygpO1xuICAgICAgdGhpcy5hZG1pblVzZXJWaWV3LnJlbmRlcigpO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0ID09ICd0YWcnKSB7XG4gICAgICBpZiAoIXRoaXMuYWRtaW5UYWdWaWV3KSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZUFkbWluVGFnVmlldygpO1xuICAgICAgfVxuICAgICAgdGhpcy5oaWRlT3RoZXJzKCk7XG4gICAgICB0aGlzLmFkbWluVGFnVmlldy5yZW5kZXIoKTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldCA9PSAndGFza3MnKSB7XG4gICAgICBpZiAoIXRoaXMuYWRtaW5UYXNrVmlldykge1xuICAgICAgICB0aGlzLmluaXRpYWxpemVBZG1pblRhc2tWaWV3KCk7XG4gICAgICB9XG4gICAgICB0aGlzLmhpZGVPdGhlcnMoKTtcbiAgICAgIHRoaXMuYWRtaW5UYXNrVmlldy5yZW5kZXIoKTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldCA9PSAnZGFzaGJvYXJkJykge1xuICAgICAgaWYgKCF0aGlzLmFkbWluRGFzaGJvYXJkVmlldykge1xuICAgICAgICB0aGlzLmluaXRpYWxpemVBZG1pbkRhc2hib2FyZFZpZXcoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGlkZU90aGVycygpO1xuICAgICAgdGhpcy5hZG1pbkRhc2hib2FyZFZpZXcucmVuZGVyKCk7XG4gICAgfVxuICB9LFxuXG4gIGxpbms6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB2YXIgdCA9ICQoZS5jdXJyZW50VGFyZ2V0KTtcbiAgICB0aGlzLnJvdXRlVGFyZ2V0KHQuZGF0YSgndGFyZ2V0JykpO1xuICB9LFxuXG4gIGhpZGVPdGhlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLiQoXCIuYWRtaW4tY29udGFpbmVyXCIpLmhpZGUoKTtcbiAgfSxcblxuICBpbml0aWFsaXplQWRtaW5Vc2VyVmlldzogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmFkbWluVXNlclZpZXcpIHtcbiAgICAgIHRoaXMuYWRtaW5Vc2VyVmlldy5jbGVhbnVwKCk7XG4gICAgfVxuICAgIHRoaXMuYWRtaW5Vc2VyVmlldyA9IG5ldyBBZG1pblVzZXJWaWV3KHtcbiAgICAgIGVsOiBcIiNhZG1pbi11c2VyXCJcbiAgICB9KTtcbiAgfSxcblxuICBpbml0aWFsaXplQWRtaW5UYWdWaWV3OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuYWRtaW5UYWdWaWV3KSB7XG4gICAgICB0aGlzLmFkbWluVGFnVmlldy5jbGVhbnVwKCk7XG4gICAgfVxuICAgIHRoaXMuYWRtaW5UYWdWaWV3ID0gbmV3IEFkbWluVGFnVmlldyh7XG4gICAgICBlbDogXCIjYWRtaW4tdGFnXCJcbiAgICB9KTtcbiAgfSxcblxuICBpbml0aWFsaXplQWRtaW5UYXNrVmlldzogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmFkbWluVGFza1ZpZXcpIHtcbiAgICAgIHRoaXMuYWRtaW5UYXNrVmlldy5jbGVhbnVwKCk7XG4gICAgfVxuICAgIHRoaXMuYWRtaW5UYXNrVmlldyA9IG5ldyBBZG1pblRhc2tWaWV3KHtcbiAgICAgIGVsOiBcIiNhZG1pbi10YXNrXCJcbiAgICB9KTtcbiAgfSxcblxuICBpbml0aWFsaXplQWRtaW5EYXNoYm9hcmRWaWV3OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuYWRtaW5EYXNoYm9hcmRWaWV3KSB7XG4gICAgICB0aGlzLmFkbWluRGFzaGJvYXJkVmlldy5jbGVhbnVwKCk7XG4gICAgfVxuICAgIHRoaXMuYWRtaW5EYXNoYm9hcmRWaWV3ID0gbmV3IEFkbWluRGFzaGJvYXJkVmlldyh7XG4gICAgICBlbDogXCIjYWRtaW4tZGFzaGJvYXJkXCJcbiAgICB9KTtcbiAgfSxcblxuICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuYWRtaW5Vc2VyVmlldykgdGhpcy5hZG1pblVzZXJWaWV3LmNsZWFudXAoKTtcbiAgICBpZiAodGhpcy5hZG1pblRhZ1ZpZXcpIHRoaXMuYWRtaW5UYWdWaWV3LmNsZWFudXAoKTtcbiAgICBpZiAodGhpcy5hZG1pblRhc2tWaWV3KSB0aGlzLmFkbWluVGFza1ZpZXcuY2xlYW51cCgpO1xuICAgIGlmICh0aGlzLmFkbWluRGFzaGJvYXJkVmlldykgdGhpcy5hZG1pbkRhc2hib2FyZFZpZXcuY2xlYW51cCgpO1xuICAgIHJlbW92ZVZpZXcodGhpcyk7XG4gIH0sXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZG1pbk1haW5WaWV3O1xuIiwiXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgQWRtaW5UYWdUZW1wbGF0ZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy9hZG1pbl90YWdfdGVtcGxhdGUuaHRtbCcpO1xudmFyIFRhZ0ZhY3RvcnkgPSByZXF1aXJlKCcuLi8uLi8uLi9jb21wb25lbnRzL3RhZ19mYWN0b3J5Jyk7XG5cblxudmFyIEFkbWluVGFnVmlldyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcblxuICBldmVudHM6IHtcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy50YWdGYWN0b3J5ID0gbmV3IFRhZ0ZhY3RvcnkoKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdHlwZXMgPSBbXG4gICAgICAnYWdlbmN5JyxcbiAgICAgICdza2lsbCcsXG4gICAgICAndG9waWMnXG4gICAgXTtcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIHR5cGVzOiB0eXBlc1xuICAgIH07XG4gICAgdmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZShBZG1pblRhZ1RlbXBsYXRlKShkYXRhKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy4kZWwuaHRtbCh0ZW1wbGF0ZSk7XG4gICAgdGhpcy4kZWwuc2hvdygpO1xuXG4gICAgXyh0eXBlcykuZm9yRWFjaCh0aGlzLnRhZ1NlbGVjdG9yLCB0aGlzKTtcblxuICAgIEJhY2tib25lLmhpc3RvcnkubmF2aWdhdGUoJy9hZG1pbi90YWcnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICB0YWdTZWxlY3RvcjogZnVuY3Rpb24odHlwZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAkKCcjJyArIHR5cGUpLnNlbGVjdDIoe1xuICAgICAgcGxhY2Vob2xkZXI6ICdTZWFyY2ggZm9yIGEgdGFnJyxcbiAgICAgIG1pbmltdW1JbnB1dExlbmd0aDogMixcbiAgICAgIGZvcm1hdFJlc3VsdDogZnVuY3Rpb24gKG9iaiwgY29udGFpbmVyLCBxdWVyeSkge1xuICAgICAgICByZXR1cm4gb2JqLm5hbWU7XG4gICAgICB9LFxuICAgICAgZm9ybWF0U2VsZWN0aW9uOiBmdW5jdGlvbiAob2JqLCBjb250YWluZXIsIHF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiBvYmoubmFtZTtcbiAgICAgIH0sXG4gICAgICBjcmVhdGVTZWFyY2hDaG9pY2U6IGZ1bmN0aW9uICh0ZXJtLCB2YWx1ZXMpIHtcbiAgICAgICAgdmFyIHZhbHMgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlLnZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKHZhbHMuaW5kZXhPZih0ZXJtLnRvTG93ZXJDYXNlKCkpID49MCkgPyBmYWxzZSA6IHtcbiAgICAgICAgICB1bm1hdGNoZWQ6IHRydWUsXG4gICAgICAgICAgdGFnVHlwZTogdHlwZSxcbiAgICAgICAgICBpZDogdGVybSxcbiAgICAgICAgICB2YWx1ZTogdGVybSxcbiAgICAgICAgICBuYW1lOiBcIjxiPlwiK3Rlcm0rXCI8L2I+IDxpPmNsaWNrIHRvIGNyZWF0ZSBhIG5ldyB0YWcgd2l0aCB0aGlzIHZhbHVlPC9pPlwiXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgYWpheDoge1xuICAgICAgICB1cmw6ICcvYXBpL2FjL3RhZycsXG4gICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgIGRhdGE6IGZ1bmN0aW9uICh0ZXJtKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBxOiB0ZXJtXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzdWx0czogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICByZXR1cm4geyByZXN1bHRzOiBkYXRhIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KS5vbignY2hhbmdlJywgZnVuY3Rpb24oZSkge1xuICAgICAgdmFyICRlbCA9IHNlbGYuJChlLmN1cnJlbnRUYXJnZXQpO1xuICAgICAgc2VsZi50YWdGYWN0b3J5LmFkZFRhZ0VudGl0aWVzKGUuYWRkZWQsIHNlbGYsIGZ1bmN0aW9uKCkge1xuICAgICAgICAkKCcjJyArIHR5cGUpLnNlbGVjdDIoJ2RhdGEnLCBudWxsKTtcbiAgICAgICAgaWYgKGUuYWRkZWQgJiYgZS5hZGRlZC52YWx1ZSA9PT0gZS5hZGRlZC5pZCkge1xuICAgICAgICAgICRlbC5uZXh0KCcuZm9ybS1zdGF0dXMnKS50ZXh0KCdBZGRlZCB0YWc6ICcgKyBlLmFkZGVkLnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkZWwubmV4dCgnLmZvcm0tc3RhdHVzJykudGV4dCgnJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIGNsZWFudXA6IGZ1bmN0aW9uICgpIHtcbiAgICByZW1vdmVWaWV3KHRoaXMpO1xuICB9LFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQWRtaW5UYWdWaWV3O1xuIiwiXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgQWRtaW5UYXNrVGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvYWRtaW5fdGFza190ZW1wbGF0ZS5odG1sJyk7XG5cblxudmFyIEFkbWluVGFza1ZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG5cbiAgZXZlbnRzOiB7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuZGF0YSA9IHtcbiAgICAgIHBhZ2U6IDFcbiAgICB9O1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAkLmFqYXgoe1xuICAgICAgdXJsOiAnL2FwaS9hZG1pbi90YXNrcycsXG4gICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgc3VjY2VzczogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZShBZG1pblRhc2tUZW1wbGF0ZSkoZGF0YSk7XG4gICAgICAgIHNlbGYuJGVsLmh0bWwodGVtcGxhdGUpO1xuICAgICAgICBzZWxmLiRlbC5zaG93KCk7XG4gICAgICB9LFxuICAgICAgZXJyb3I6IGZ1bmN0aW9uICh4aHIsIHN0YXR1cywgZXJyb3IpIHtcbiAgICAgICAgc2VsZi5oYW5kbGVFcnJvcihzZWxmLCB4aHIsIHN0YXR1cywgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgQmFja2JvbmUuaGlzdG9yeS5uYXZpZ2F0ZSgnL2FkbWluL3Rhc2tzJyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgY2xlYW51cDogZnVuY3Rpb24gKCkge1xuICAgIHJlbW92ZVZpZXcodGhpcyk7XG4gIH0sXG5cbiAgaGFuZGxlRXJyb3I6IGZ1bmN0aW9uIChzZWxmLCB4aHIsIHN0YXR1cywgZXJyb3IpIHtcbiAgICAvLyBzaG93IHRoZSBhbGVydCBtZXNzYWdlIGFuZCBoaWRlIHRoZSBzcGlubmVyXG4gICAgc2VsZi4kKCcuYWxlcnQnKS5odG1sKGVycm9yLm1lc3NhZ2UgfHwgZXJyb3IpO1xuICAgIHNlbGYuJCgnLmFsZXJ0Jykuc2hvdygpO1xuICAgIHNlbGYuJCgnLnNwaW5uZXInKS5oaWRlKCk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQWRtaW5UYXNrVmlldztcbiIsIlxudmFyIEJvb3RzdHJhcCA9IHJlcXVpcmUoJ2Jvb3RzdHJhcCcpO1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vbWl4aW5zL3V0aWxpdGllcycpO1xudmFyIEFkbWluVXNlclBhc3N3b3JkID0gcmVxdWlyZSgnLi4vdGVtcGxhdGVzL2FkbWluX3VzZXJfcGFzc3dvcmQuaHRtbCcpO1xuXG5cbnZhciBBZG1pblVzZXJQYXNzd29yZFZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG5cbiAgZXZlbnRzOiB7XG4gICAgXCJibHVyICNuZXdQYXNzd29yZFwiICAgICAgICAgICAgIDogXCJ2XCIsXG4gICAgXCJzdWJtaXQgI3Jlc2V0LXBhc3N3b3JkXCIgICAgICAgIDogXCJwb3N0XCJcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBhZG1pbjogdGhpcy5vcHRpb25zLmFkbWluLFxuICAgICAgdTogdGhpcy5vcHRpb25zLnVzZXJcbiAgICB9XG4gICAgdmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZShBZG1pblVzZXJQYXNzd29yZCkoZGF0YSk7XG4gICAgdGhpcy4kZWwuaHRtbCh0ZW1wbGF0ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgdjogZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gdmFsaWRhdGUoZSk7XG4gIH0sXG5cbiAgcG9zdDogZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIC8vIHZhbGlkYXRlIGlucHV0IGZpZWxkc1xuICAgIHZhciB2YWxpZGF0ZUlkcyA9IFsnI25ld1Bhc3N3b3JkJ107XG4gICAgdmFyIGFib3J0ID0gZmFsc2U7XG4gICAgZm9yIChpIGluIHZhbGlkYXRlSWRzKSB7XG4gICAgICB2YXIgaUFib3J0ID0gdmFsaWRhdGUoeyBjdXJyZW50VGFyZ2V0OiB2YWxpZGF0ZUlkc1tpXSB9KTtcbiAgICAgIGFib3J0ID0gYWJvcnQgfHwgaUFib3J0O1xuICAgIH1cbiAgICBpZiAoYWJvcnQgPT09IHRydWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBleGVjdXRlIHBhc3N3b3JkIHJlc2V0XG4gICAgdmFyIGRhdGE7XG4gICAgZGF0YSA9IHtcbiAgICAgIGlkOiB0aGlzLm9wdGlvbnMudXNlci5pZCxcbiAgICAgIHBhc3N3b3JkOiB0aGlzLiQoXCIjbmV3UGFzc3dvcmRcIikudmFsKClcbiAgICB9O1xuXG4gICAgJC5hamF4KHtcbiAgICAgIHVybDogJy9hcGkvdXNlci9yZXNldFBhc3N3b3JkJyxcbiAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIC8vIGNvbGxhcHNlIG1vZGFsXG4gICAgICAgICAgJChcIiNyZXNldC1wYXNzd29yZC1tb2RhbFwiKS5tb2RhbCgnaGlkZScpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLnByb2Nlc3NFcnJvcih7IG1lc3NhZ2U6ICdBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSB0cnlpbmcgdG8gc2F2ZSB0aGUgcGFzc3dvcmQ6IHRoZSBzZXJ2ZXIgcHJvdmlkZWQgYW4gdW5leHBlY3RlZCByZXNwb25zZS4nfSlcbiAgICAgIH0sXG4gICAgICBlcnJvcjogZnVuY3Rpb24gKHhociwgc3RhdHVzLCBlcnJvcikge1xuICAgICAgICBzZWxmLnByb2Nlc3NFcnJvcih4aHIucmVzcG9uc2VKU09OKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICB9LFxuXG4gIHByb2Nlc3NFcnJvcjogZnVuY3Rpb24gKGUpIHtcbiAgICB0aGlzLiQoXCIuYWxlcnRcIikuaHRtbChlLm1lc3NhZ2UgfHwgZSk7XG4gICAgdGhpcy4kKFwiLmFsZXJ0XCIpLnNob3coKTtcbiAgfSxcblxuICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZG1pblVzZXJQYXNzd29yZFZpZXc7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgTW9kYWxDb21wb25lbnQgPSByZXF1aXJlKCcuLi8uLi8uLi9jb21wb25lbnRzL21vZGFsJyk7XG52YXIgQWRtaW5Vc2VyUGFzc3dvcmRWaWV3ID0gcmVxdWlyZSgnLi9hZG1pbl91c2VyX3Bhc3N3b3JkX3ZpZXcnKTtcbnZhciBBZG1pblVzZXJUZW1wbGF0ZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy9hZG1pbl91c2VyX3RlbXBsYXRlLmh0bWwnKTtcbnZhciBBZG1pblVzZXJUYWJsZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy9hZG1pbl91c2VyX3RhYmxlLmh0bWwnKTtcbnZhciBQYWdpbmF0ZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy9hZG1pbl9wYWdpbmF0ZS5odG1sJyk7XG52YXIgTG9naW5Db25maWcgPSByZXF1aXJlKCcuLi8uLi8uLi9jb25maWcvbG9naW4uanNvbicpO1xuXG5cbnZhciBBZG1pblVzZXJWaWV3ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuXG4gIGV2ZW50czoge1xuICAgIFwiY2xpY2sgYS5wYWdlXCIgICAgICAgICAgICAgIDogXCJjbGlja1BhZ2VcIixcbiAgICBcImNsaWNrIC5saW5rLWJhY2tib25lXCIgICAgICA6IGxpbmtCYWNrYm9uZSxcbiAgICBcImNsaWNrIC5hZG1pbi11c2VyLW1rYWRtaW5cIiA6IFwiYWRtaW5DcmVhdGVcIixcbiAgICBcImNsaWNrIC5hZG1pbi11c2VyLXJtYWRtaW5cIiA6IFwiYWRtaW5SZW1vdmVcIixcbiAgICBcImNsaWNrIC5hZG1pbi11c2VyLWVuYWJsZVwiICA6IFwiYWRtaW5FbmFibGVcIixcbiAgICBcImNsaWNrIC5hZG1pbi11c2VyLWRpc2FibGVcIiA6IFwiYWRtaW5EaXNhYmxlXCIsXG4gICAgXCJjbGljayAuYWRtaW4tdXNlci11bmxvY2tcIiAgOiBcImFkbWluVW5sb2NrXCIsXG4gICAgXCJjbGljayAuYWRtaW4tdXNlci1yZXNldHB3XCIgOiBcInJlc2V0UGFzc3dvcmRcIixcbiAgICBcImtleXVwICN1c2VyLWZpbHRlclwiICAgICAgICA6IFwiZmlsdGVyXCJcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5kYXRhID0ge1xuICAgICAgcGFnZTogMVxuICAgIH07XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIEJhY2tib25lLmhpc3RvcnkubmF2aWdhdGUoJy9hZG1pbi91c2VyJyk7XG4gICAgdGhpcy4kZWwuc2hvdygpO1xuICAgIGlmICh0aGlzLnJlbmRlcmVkID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICB1c2VyOiB3aW5kb3cuY2FjaGUuY3VycmVudFVzZXIsXG4gICAgICBsb2dpbjogTG9naW5Db25maWdcbiAgICB9O1xuICAgIHZhciB0ZW1wbGF0ZSA9IF8udGVtcGxhdGUoQWRtaW5Vc2VyVGVtcGxhdGUpKGRhdGEpO1xuICAgIHRoaXMuJGVsLmh0bWwodGVtcGxhdGUpO1xuICAgIHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuICAgIC8vIGZldGNoIHVzZXIgZGF0YVxuICAgIHRoaXMuZmV0Y2hEYXRhKHNlbGYsIHRoaXMuZGF0YSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcmVuZGVyVXNlcnM6IGZ1bmN0aW9uIChzZWxmLCBkYXRhKSB7XG4gICAgZGF0YS51cmxiYXNlID0gJy9hZG1pbi91c2Vycyc7XG4gICAgZGF0YS5xID0gZGF0YS5xIHx8ICcnO1xuICAgIC8vIGlmIHRoZSBsaW1pdCBvZiByZXN1bHRzIGNvbWluZyBiYWNrIGhhc24ndCBiZWVuIHNldCB5ZXRcbiAgICAvLyB1c2UgdGhlIHNlcnZlcidzIGRlZmF1bHRcbiAgICBpZiAoIXNlbGYubGltaXQpIHtcbiAgICAgIHNlbGYubGltaXQgPSBkYXRhLmxpbWl0O1xuICAgIH1cbiAgICBkYXRhLnRydWVMaW1pdCA9IHNlbGYubGltaXQ7XG4gICAgZGF0YS5sb2dpbiA9IExvZ2luQ29uZmlnO1xuICAgIGRhdGEudXNlciA9IHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlcjtcbiAgICAvLyByZW5kZXIgdGhlIHRhYmxlXG4gICAgdmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZShBZG1pblVzZXJUYWJsZSkoZGF0YSk7XG4gICAgLy8gcmVuZGVyIHRoZSBwYWdpbmF0aW9uXG4gICAgdmFyIHBhZ2luYXRlID0gXy50ZW1wbGF0ZShQYWdpbmF0ZSkoZGF0YSk7XG4gICAgc2VsZi4kKFwiI3VzZXItcGFnZVwiKS5odG1sKHBhZ2luYXRlKTtcbiAgICBzZWxmLiQoXCIudGFibGUtcmVzcG9uc2l2ZVwiKS5odG1sKHRlbXBsYXRlKTtcbiAgICBzZWxmLiQoXCIuYnRuXCIpLnRvb2x0aXAoKTtcbiAgICAvLyBoaWRlIHNwaW5uZXIgYW5kIHNob3cgcmVzdWx0c1xuICAgIHNlbGYuJChcIi5zcGlubmVyXCIpLmhpZGUoKTtcbiAgICBzZWxmLiQoXCIudGFibGUtcmVzcG9uc2l2ZVwiKS5zaG93KCk7XG4gICAgc2VsZi4kZWwuaTE4bigpO1xuICB9LFxuXG4gIGNsaWNrUGFnZTogZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgLy8gaWYgbWV0YSBvciBjb250cm9sIGlzIGhlbGQsIG9yIGlmIHRoZSBtaWRkbGUgbW91c2UgYnV0dG9uIGlzIHByZXNzZWQsXG4gICAgLy8gbGV0IHRoZSBsaW5rIHByb2Nlc3Mgbm9ybWFsbHkuXG4gICAgLy8gZWc6IG9wZW4gYSBuZXcgdGFiIG9yIHdpbmRvdyBiYXNlZCBvbiB0aGUgYnJvd3NlciBwcmVmc1xuICAgIGlmICgoZS5tZXRhS2V5ID09PSB0cnVlKSB8fCAoZS5jdHJsS2V5ID09PSB0cnVlKSB8fCAoZS53aGljaCA9PSAyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIC8vIGxvYWQgdGhpcyBwYWdlIG9mIGRhdGFcbiAgICB0aGlzLmZldGNoRGF0YShzZWxmLCB7XG4gICAgICBwYWdlOiAkKGUuY3VycmVudFRhcmdldCkuZGF0YSgncGFnZScpLFxuICAgICAgcTogJCgkKGUuY3VycmVudFRhcmdldCkucGFyZW50KCd1bCcpWzBdKS5kYXRhKCdmaWx0ZXInKSxcbiAgICAgIGxpbWl0OiB0aGlzLmxpbWl0XG4gICAgfSk7XG4gIH0sXG5cbiAgZmlsdGVyOiBmdW5jdGlvbiAoZSkge1xuICAgIC8vIGdldCB0aGUgaW5wdXQgYm94IHZhbHVlXG4gICAgdmFyIHZhbCA9ICQoZS5jdXJyZW50VGFyZ2V0KS52YWwoKS50cmltKCk7XG4gICAgLy8gaWYgdGhlIGZpbHRlciBpcyB0aGUgc2FtZSwgZG9uJ3QgZG8gYW55dGhpbmdcbiAgICBpZiAodmFsID09IHRoaXMucSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnEgPSB2YWw7XG4gICAgLy8gaGlkZSB0aGUgdGFibGUgYW5kIHNob3cgdGhlIHNwaW5uZXJcbiAgICB0aGlzLiQoXCIudGFibGUtcmVzcG9uc2l2ZVwiKS5oaWRlKCk7XG4gICAgdGhpcy4kKFwiLnNwaW5uZXJcIikuc2hvdygpO1xuICAgIC8vIGZldGNoIHRoaXMgcXVlcnksIHN0YXJ0aW5nIGZyb20gdGhlIGJlZ2lubmluZyBwYWdlXG4gICAgdGhpcy5mZXRjaERhdGEodGhpcywge1xuICAgICAgcTogdmFsXG4gICAgfSk7XG4gIH0sXG5cbiAgZmV0Y2hEYXRhOiBmdW5jdGlvbiAoc2VsZiwgZGF0YSkge1xuICAgIC8vIHBlcmZvcm0gdGhlIGFqYXggcmVxdWVzdCB0byBmZXRjaCB0aGUgdXNlciBsaXN0XG4gICAgJC5hamF4KHtcbiAgICAgIHVybDogJy9hcGkvYWRtaW4vdXNlcnMnLFxuICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBzZWxmLmRhdGEgPSBkYXRhO1xuICAgICAgICBzZWxmLnJlbmRlclVzZXJzKHNlbGYsIGRhdGEpO1xuICAgICAgfSxcbiAgICAgIGVycm9yOiBmdW5jdGlvbiAoeGhyLCBzdGF0dXMsIGVycm9yKSB7XG4gICAgICAgIHNlbGYuaGFuZGxlRXJyb3Ioc2VsZiwgeGhyLCBzdGF0dXMsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBoYW5kbGVFcnJvcjogZnVuY3Rpb24gKHNlbGYsIHhociwgc3RhdHVzLCBlcnJvcikge1xuICAgIC8vIHNob3cgdGhlIGFsZXJ0IG1lc3NhZ2UgYW5kIGhpZGUgdGhlIHNwaW5uZXJcbiAgICBzZWxmLiQoJy5hbGVydCcpLmh0bWwoZXJyb3IubWVzc2FnZSB8fCBlcnJvcik7XG4gICAgc2VsZi4kKCcuYWxlcnQnKS5zaG93KCk7XG4gICAgc2VsZi4kKCcuc3Bpbm5lcicpLmhpZGUoKTtcbiAgfSxcblxuICBhZG1pbkNyZWF0ZTogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHZhciB0ID0gJChlLmN1cnJlbnRUYXJnZXQpO1xuICAgIHZhciBpZCA9ICQodC5wYXJlbnRzKCd0cicpWzBdKS5kYXRhKCdpZCcpO1xuICAgIHRoaXMudXBkYXRlVXNlcih0LCB7XG4gICAgICBpZDogaWQsXG4gICAgICBpc0FkbWluOiB0cnVlLFxuICAgICAgdXJsOiAnL2FwaS9hZG1pbi9hZG1pbi8nICsgaWQgKyAnP2FjdGlvbj10cnVlJ1xuICAgIH0pO1xuICB9LFxuXG4gIGFkbWluUmVtb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIHQgPSAkKGUuY3VycmVudFRhcmdldCk7XG4gICAgdmFyIGlkID0gJCh0LnBhcmVudHMoJ3RyJylbMF0pLmRhdGEoJ2lkJyk7XG4gICAgdGhpcy51cGRhdGVVc2VyKHQsIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIGlzQWRtaW46IGZhbHNlLFxuICAgICAgdXJsOiAnL2FwaS9hZG1pbi9hZG1pbi8nICsgaWQgKyAnP2FjdGlvbj1mYWxzZSdcbiAgICB9KTtcbiAgfSxcblxuICBhZG1pbkVuYWJsZTogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHZhciB0ID0gJChlLmN1cnJlbnRUYXJnZXQpO1xuICAgIHZhciBpZCA9ICQodC5wYXJlbnRzKCd0cicpWzBdKS5kYXRhKCdpZCcpO1xuICAgIHRoaXMudXBkYXRlVXNlcih0LCB7XG4gICAgICBpZDogaWQsXG4gICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICB1cmw6ICcvYXBpL3VzZXIvZW5hYmxlLycgKyBpZFxuICAgIH0pO1xuICB9LFxuXG4gIGFkbWluRGlzYWJsZTogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHZhciB0ID0gJChlLmN1cnJlbnRUYXJnZXQpO1xuICAgIHZhciBpZCA9ICQodC5wYXJlbnRzKCd0cicpWzBdKS5kYXRhKCdpZCcpO1xuICAgIHRoaXMudXBkYXRlVXNlcih0LCB7XG4gICAgICBpZDogaWQsXG4gICAgICBkaXNhYmxlZDogdHJ1ZSxcbiAgICAgIHVybDogJy9hcGkvdXNlci9kaXNhYmxlLycgKyBpZFxuICAgIH0pO1xuICB9LFxuXG4gIGFkbWluVW5sb2NrOiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIHQgPSAkKGUuY3VycmVudFRhcmdldCk7XG4gICAgdmFyIGlkID0gJCh0LnBhcmVudHMoJ3RyJylbMF0pLmRhdGEoJ2lkJyk7XG4gICAgdGhpcy51cGRhdGVVc2VyKHQsIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIHBhc3N3b3JkQXR0ZW1wdHM6IDAsXG4gICAgICB1cmw6ICcvYXBpL2FkbWluL3VubG9jay8nICsgaWRcbiAgICB9KTtcblxuICB9LFxuXG4gIHVwZGF0ZVVzZXI6IGZ1bmN0aW9uICh0LCBkYXRhKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzcGlubmVyID0gJCgkKHQucGFyZW50KClbMF0pLmNoaWxkcmVuKCcuYnRuLXNwaW4nKVswXSlcbiAgICBzcGlubmVyLnNob3coKTtcbiAgICB0LmhpZGUoKTtcbiAgICBpZiAoZGF0YS51cmwpIHtcbiAgICAgICQuYWpheCh7XG4gICAgICAgIHVybDogZGF0YS51cmwsXG4gICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgLy8gaGlkZSB0aGUgc3Bpbm5lclxuICAgICAgICAgIHNwaW5uZXIuaGlkZSgpO1xuICAgICAgICAgIC8vIHNob3cgdGhlIG9wcG9zaXRlIGJ1dHRvblxuICAgICAgICAgIGlmIChkYXRhLmRpc2FibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAkKHQuc2libGluZ3MoXCIuYWRtaW4tdXNlci1lbmFibGVcIilbMF0pLnNob3coKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRhdGEuZGlzYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAkKHQuc2libGluZ3MoXCIuYWRtaW4tdXNlci1kaXNhYmxlXCIpWzBdKS5zaG93KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkYXRhLmlzQWRtaW4gPT09IHRydWUpIHtcbiAgICAgICAgICAgICQodC5zaWJsaW5ncyhcIi5hZG1pbi11c2VyLXJtYWRtaW5cIilbMF0pLnNob3coKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRhdGEuaXNBZG1pbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICQodC5zaWJsaW5ncyhcIi5hZG1pbi11c2VyLW1rYWRtaW5cIilbMF0pLnNob3coKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbiAoeGhyLCBzdGF0dXMsIGVycm9yKSB7XG4gICAgICAgICAgc2VsZi5oYW5kbGVFcnJvcihzZWxmLCB4aHIsIHN0YXR1cywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgcmVzZXRQYXNzd29yZDogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICh0aGlzLnBhc3N3b3JkVmlldykgeyB0aGlzLnBhc3N3b3JkVmlldy5jbGVhbnVwKCk7IH1cbiAgICBpZiAodGhpcy5tb2RhbENvbXBvbmVudCkgdGhpcy5tb2RhbENvbXBvbmVudC5jbGVhbnVwKCk7XG5cbiAgICB2YXIgdHIgPSAkKCQoZS5jdXJyZW50VGFyZ2V0KS5wYXJlbnRzKCd0cicpWzBdKTtcbiAgICB2YXIgdXNlciA9IHtcbiAgICAgIGlkOiB0ci5kYXRhKCdpZCcpLFxuICAgICAgbmFtZTogJCh0ci5maW5kKCd0ZC5hZG1pbi10YWJsZS1uYW1lJylbMF0pLnRleHQoKS50cmltKClcbiAgICB9O1xuXG4gICAgLy8gc2V0IHVwIHRoZSBtb2RhbFxuICAgIHRoaXMubW9kYWxDb21wb25lbnQgPSBuZXcgTW9kYWxDb21wb25lbnQoe1xuICAgICAgZWw6IFwiI3Jlc2V0LXBhc3N3b3JkLWNvbnRhaW5lclwiLFxuICAgICAgaWQ6IFwicmVzZXQtcGFzc3dvcmQtbW9kYWxcIixcbiAgICAgIG1vZGFsVGl0bGU6IFwiUmVzZXQgUGFzc3dvcmRcIlxuICAgIH0pLnJlbmRlcigpO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSB0aGUgdmlldyBpbnNpZGUgdGhlIG1vZGFsXG4gICAgdGhpcy5wYXNzd29yZFZpZXcgPSBuZXcgQWRtaW5Vc2VyUGFzc3dvcmRWaWV3KHtcbiAgICAgIGVsOiBcIi5tb2RhbC10ZW1wbGF0ZVwiLFxuICAgICAgdXNlcjogdXNlclxuICAgIH0pLnJlbmRlcigpO1xuXG4gICAgLy8gcmVuZGVyIHRoZSBtb2RhbFxuICAgIHRoaXMuJChcIiNyZXNldC1wYXNzd29yZC1tb2RhbFwiKS5tb2RhbCgnc2hvdycpO1xuICB9LFxuXG4gIGNsZWFudXA6IGZ1bmN0aW9uICgpIHtcbiAgICByZW1vdmVWaWV3KHRoaXMpO1xuICB9LFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQWRtaW5Vc2VyVmlldztcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciBpMThuT3B0aW9uID0gcmVxdWlyZSgnLi4vY29uZmlnL2kxOG4uanNvbicpO1xudmFyIEJyb3dzZUFwcCA9IHJlcXVpcmUoJy4vYnJvd3NlL2Jyb3dzZV9hcHAnKTtcblxuXG52YXIgaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJvdXRlciwgYnJvd3NlO1xuXG4gIC8vIEluaXRpYWxpemUgdGhlIGludGVybmF0aW9uYWxpemF0aW9uIGxpYnJhcnkgYW5kIHN0YXJ0IEJhY2tib25lIHdoZW4gaXQncyBkb25lIGluaXRpYWxpemluZy5cbiAgJC5pMThuLmluaXQoaTE4bk9wdGlvbiwgZnVuY3Rpb24odCkge1xuICAgIC8vIEhlcmUgd2UgYXJlIGdvaW5nIHRvIGZpcmUgdXAgYWxsIHRoZSByb3V0ZXJzIGZvciBvdXIgYXBwIHRvIGxpc3RlblxuICAgIC8vIGluIG9uIHRoZWlyIHJlc3BlY3RpdmUgYXBwbGljYXRpb25zLiAgV2UgYXJlIC10ZXN0aW5nLSB0aGlzIGZ1bmN0aW9uYWxpdHlcbiAgICAvLyBieSB1c2luZyB0aGUgcHJvZmlsZSBhcHBsaWNhdGlvbiBhcyBhIHN0YXJ0aW5nIHBvaW50ICh2ZXJ5IHNpbXBsZSwgMSByb3V0ZSkuXG4gICAgYnJvd3NlID0gQnJvd3NlQXBwLmluaXRpYWxpemUoKTtcblxuICAgIHJldHVybiBCYWNrYm9uZS5oaXN0b3J5LnN0YXJ0KHsgcHVzaFN0YXRlOiB0cnVlIH0pO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGluaXRpYWxpemU6IGluaXRpYWxpemVcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHRyPlxcbiAgPHRkPlxcbiAgICA8c3BhbiBjbGFzcz1cXFwiZmlsZS10YWcgYzMtYmcgd2hpdGVcXFwiPmZpbGU8L3NwYW4+XFxuICA8L3RkPlxcbiAgPHRkIGNsYXNzPVxcXCJhdHRhY2htZW50LW5hbWVcXFwiPlxcbiAgICA8YSBocmVmPVxcXCIvYXBpL2ZpbGUvZ2V0LzwlPSBhLmZpbGUuaWQgJT5cXFwiIGNsYXNzPVxcXCJmaWxlLWxpbmtcXFwiIGRhdGEtaWQ9XFxcIjwlPSBhLmZpbGUuaWQgJT5cXFwiPlxcbiAgICAgIDwlPSBhLmZpbGUubmFtZSAlPlxcbiAgICAgIDwlIGlmICh1c2VyICYmICgoYS51c2VySWQgPT0gYS51c2VySWQpIHx8IG93bmVyKSkgeyAlPlxcbiAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJmaWxlLWRlbGV0ZVxcXCIgZGF0YS1pZD1cXFwiPCU9IGEuaWQgJT5cXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1yZW1vdmVcXFwiPjwvaT48L2E+XFxuICAgICAgPCUgfSAlPlxcbiAgICAgIDxici8+XFxuICAgICAgPHRpbWUgY2xhc3M9XFxcInRpbWVhZ29cXFwiIGRhdGV0aW1lPVxcXCI8JS0gYS5jcmVhdGVkQXQgJT5cXFwiPjwlLSBhLmNyZWF0ZWRBdCAlPjwvdGltZT5cXG4gICAgPC9hPlxcbiAgPC90ZD5cXG4gIDx0ZCBjbGFzcz1cXFwiZmlsZS1wZXJzb25cXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJwcm9qZWN0LXBlb3BsZS1kaXZcXFwiIGRhdGEtdXNlcmlkPVxcXCI8JS0gYS51c2VySWQgJT5cXFwiPlxcbiAgICAgIDxpbWcgc3JjPVxcXCIvYXBpL3VzZXIvcGhvdG8vPCU9IGEudXNlcklkICU+XFxcIiBjbGFzcz1cXFwicHJvamVjdC1wZW9wbGVcXFwiIC8+XFxuICAgIDwvZGl2PlxcbiAgPC90ZD5cXG48L3RyPlxcblwiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImJveC1wYWQtbHIgYm9yZGVyLWJvdHRvbVxcXCI+XFxuICA8aDI+XFxuICAgIEF0dGFjaG1lbnRzXFxuICAgIDxkaXYgY2xhc3M9XFxcImJ0biBidG4tYzAgYnRuLXNtIGZpbGUtYWRkIGF0dGFjaG1lbnQtZmlsZWJ0biBmaWxlaW5wdXQtYnV0dG9uXFxcIiBzdHlsZT1cXFwiPCUgaWYgKCF1c2VyKSB7ICU+ZGlzcGxheTpub25lOzwlIH0gJT5cXFwiPlxcbiAgICAgIEFkZCBGaWxlXFxuICAgICAgPGlucHV0IGlkPVxcXCJhdHRhY2htZW50LWZpbGV1cGxvYWRcXFwiIHR5cGU9XFxcImZpbGVcXFwiIG5hbWU9XFxcImZpbGVzW11cXFwiIHRpdGxlPVxcXCJBdHRhY2ggRmlsZXNcXFwiPlxcbiAgICA8L2Rpdj5cXG4gIDwvaDI+XFxuPC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwiYXR0YWNobWVudC1maWxldXBsb2FkIGJveC1wYWQtbHIgYm94LXBhZC10XFxcIj5cXG4gIDxkaXYgc3R5bGU9XFxcImRpc3BsYXk6IG5vbmU7XFxcIiBjbGFzcz1cXFwicHJvZ3Jlc3MgcHJvZ3Jlc3Mtc3RyaXBlZCBhY3RpdmVcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJwcm9ncmVzcy1iYXJcXFwiIHN0eWxlPVxcXCJ3aWR0aDogMFxcXCI+PC9kaXY+XFxuICA8L2Rpdj5cXG48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJib3gtcGFkLWxyXFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcImZpbGUtdXBsb2FkLWFsZXJ0IGFsZXJ0IGFsZXJ0LXdhcm5pbmdcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIj5cXG4gICAgPHNwYW4+PC9zcGFuPlxcbiAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImNsb3NlXFxcIiBkYXRhLWRpc21pc3M9XFxcImFsZXJ0XFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+JnRpbWVzOzwvYnV0dG9uPlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwiYm94LXBhZC1sciBib3gtcGFkLXQgZmlsZS1saXN0XFxcIj5cXG4gIDx0YWJsZSBjbGFzcz1cXFwidGFibGUgdGFibGUtaG92ZXIgdGFibGUtY29uZGVuc2VkXFxcIj5cXG4gICAgPHRib2R5IGNsYXNzPVxcXCJhdHRhY2htZW50LXRib2R5XFxcIj5cXG4gICAgICA8dHIgY2xhc3M9XFxcImF0dGFjaG1lbnQtbm9uZVxcXCI+PHRkPk5vIEF0dGFjaG1lbnRzPC90ZD48L3RyPlxcbiAgICA8L3Rib2R5PlxcbiAgPC90YWJsZT5cXG48L2Rpdj5cXG5cIjtcbiIsIlxudmFyIEJvb3RzdHJhcCA9IHJlcXVpcmUoJ2Jvb3RzdHJhcCcpO1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIganFJZnJhbWUgPSByZXF1aXJlKCdibHVlaW1wLWZpbGUtdXBsb2FkL2pzL2pxdWVyeS5pZnJhbWUtdHJhbnNwb3J0Jyk7XG52YXIganFGVSA9IHJlcXVpcmUoJ2JsdWVpbXAtZmlsZS11cGxvYWQvanMvanF1ZXJ5LmZpbGV1cGxvYWQuanMnKTtcbnZhciBUaW1lQWdvID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vdmVuZG9yL2pxdWVyeS50aW1lYWdvJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vbWl4aW5zL3V0aWxpdGllcycpO1xudmFyIGFzeW5jID0gcmVxdWlyZSgnYXN5bmMnKTtcbnZhciBQb3BvdmVycyA9IHJlcXVpcmUoJy4uLy4uLy4uL21peGlucy9wb3BvdmVycycpO1xudmFyIEFJVGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvYXR0YWNobWVudF9pdGVtX3RlbXBsYXRlLmh0bWwnKTtcbnZhciBBU1RlbXBsYXRlID0gcmVxdWlyZSgnLi4vdGVtcGxhdGVzL2F0dGFjaG1lbnRfc2hvd190ZW1wbGF0ZS5odG1sJyk7XG5cblxudmFyIHBvcG92ZXJzID0gbmV3IFBvcG92ZXJzKCk7XG5cbnZhciBBdHRhY2htZW50U2hvd1ZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG5cbiAgZXZlbnRzOiB7XG4gICAgJ2NsaWNrIC5maWxlLWRlbGV0ZScgICAgICAgICAgICAgICAgOiAnZGVsZXRlQXR0YWNobWVudCcsXG4gICAgXCJtb3VzZWVudGVyIC5wcm9qZWN0LXBlb3BsZS1kaXZcIiAgICA6IHBvcG92ZXJzLnBvcG92ZXJQZW9wbGVPbixcbiAgICBcImNsaWNrIC5wcm9qZWN0LXBlb3BsZS1kaXZcIiAgICAgICAgIDogcG9wb3ZlcnMucG9wb3ZlckNsaWNrLFxuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmRhdGEgPSBvcHRpb25zLmRhdGE7XG4gICAgdGhpcy5hY3Rpb24gPSBvcHRpb25zLmFjdGlvbjtcbiAgICB0aGlzLmVkaXQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmFjdGlvbikge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hY3Rpb24gPT0gJ2VkaXQnKSB7XG4gICAgICAgIHRoaXMuZWRpdCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGluaXRpYWxpemVGaWxlczogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAkLmFqYXgoe1xuICAgICAgdXJsOiAnL2FwaS9hdHRhY2htZW50L2ZpbmRBbGxCeScgKyB0aGlzLm9wdGlvbnMudGFyZ2V0ICsgJ0lkLycgKyB0aGlzLm9wdGlvbnMuaWRcbiAgICB9KS5kb25lKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBpZiAoZGF0YSAmJiAoZGF0YS5sZW5ndGggPiAwKSkge1xuICAgICAgICAkKFwiLmF0dGFjaG1lbnQtbm9uZVwiKS5oaWRlKCk7XG4gICAgICB9XG4gICAgICBfLmVhY2goZGF0YSwgZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gc2VsZi5yZW5kZXJBdHRhY2htZW50KGYpO1xuICAgICAgICAkKFwiLmF0dGFjaG1lbnQtdGJvZHlcIikuYXBwZW5kKHRlbXBsYXRlKTtcbiAgICAgIH0pO1xuICAgICAgJChcInRpbWUudGltZWFnb1wiKS50aW1lYWdvKCk7XG4gICAgICBwb3BvdmVycy5wb3BvdmVyUGVvcGxlSW5pdChcIi5wcm9qZWN0LXBlb3BsZS1kaXZcIik7XG4gICAgfSk7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZUZpbGVVcGxvYWQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cblxuICAgICQoJyNhdHRhY2htZW50LWZpbGV1cGxvYWQnKS5maWxldXBsb2FkKHtcbiAgICAgIHVybDogXCIvYXBpL2ZpbGUvY3JlYXRlXCIsXG4gICAgICBkYXRhVHlwZTogJ3RleHQnLFxuICAgICAgYWNjZXB0RmlsZVR5cGVzOiAvKFxcLnxcXC8pKGdpZnxqcGU/Z3xwbmcpJC9pLFxuICAgICAgYWRkOiBmdW5jdGlvbiAoZSwgZGF0YSkge1xuICAgICAgICBzZWxmLiQoJy5hdHRhY2htZW50LWZpbGV1cGxvYWQgPiAucHJvZ3Jlc3MnKS5zaG93KCk7XG4gICAgICAgIGRhdGEuc3VibWl0KCk7XG4gICAgICB9LFxuICAgICAgcHJvZ3Jlc3NhbGw6IGZ1bmN0aW9uIChlLCBkYXRhKSB7XG4gICAgICAgIHZhciBwcm9ncmVzcyA9IHBhcnNlSW50KGRhdGEubG9hZGVkIC8gZGF0YS50b3RhbCAqIDEwMCwgMTApO1xuICAgICAgICBzZWxmLiQoJy5hdHRhY2htZW50LWZpbGV1cGxvYWQgLnByb2dyZXNzLWJhcicpLmNzcyhcbiAgICAgICAgICAnd2lkdGgnLFxuICAgICAgICAgIHByb2dyZXNzICsgJyUnXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgZG9uZTogZnVuY3Rpb24gKGUsIGRhdGEpIHtcbiAgICAgICAgLy8gZm9yIElFOC85IHRoYXQgdXNlIGlmcmFtZVxuICAgICAgICBpZiAoZGF0YS5kYXRhVHlwZSA9PSAnaWZyYW1lIHRleHQnKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IEpTT04ucGFyc2UoZGF0YS5yZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZvciBtb2Rlcm4gWEhSIGJyb3dzZXJzXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBKU09OLnBhcnNlKCQoZGF0YS5yZXN1bHQpLnRleHQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzdG9yZSBpZCBpbiB0aGUgZGF0YWJhc2Ugd2l0aCB0aGUgZmlsZVxuICAgICAgICB2YXIgYURhdGEgPSB7XG4gICAgICAgICAgZmlsZUlkOiByZXN1bHRbMF0uaWRcbiAgICAgICAgfTtcbiAgICAgICAgYURhdGFbc2VsZi5vcHRpb25zLnRhcmdldCArICdJZCddID0gc2VsZi5vcHRpb25zLmlkO1xuICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgIHVybDogJy9hcGkvYXR0YWNobWVudCcsXG4gICAgICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KGFEYXRhKSxcbiAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgfSkuZG9uZShmdW5jdGlvbiAoYXR0YWNobWVudCkge1xuICAgICAgICAgIHNlbGYuJCgnLmF0dGFjaG1lbnQtZmlsZXVwbG9hZCA+IC5wcm9ncmVzcycpLmhpZGUoKTtcbiAgICAgICAgICBzZWxmLnJlbmRlck5ld0F0dGFjaG1lbnQocmVzdWx0WzBdLCBhdHRhY2htZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZmFpbDogZnVuY3Rpb24gKGUsIGRhdGEpIHtcbiAgICAgICAgLy8gbm90aWZ5IHRoZSB1c2VyIHRoYXQgdGhlIHVwbG9hZCBmYWlsZWRcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBkYXRhLmVycm9yVGhyb3duO1xuICAgICAgICBzZWxmLiQoJy5hdHRhY2htZW50LWZpbGV1cGxvYWQgPiAucHJvZ3Jlc3MnKS5oaWRlKCk7XG4gICAgICAgIGlmIChkYXRhLmpxWEhSLnN0YXR1cyA9PSA0MTMpIHtcbiAgICAgICAgICBtZXNzYWdlID0gXCJUaGUgdXBsb2FkZWQgZmlsZSBleGNlZWRzIHRoZSBtYXhpbXVtIGZpbGUgc2l6ZS5cIjtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLiQoXCIuZmlsZS11cGxvYWQtYWxlcnQgPiBzcGFuXCIpLmh0bWwobWVzc2FnZSlcbiAgICAgICAgc2VsZi4kKFwiLmZpbGUtdXBsb2FkLWFsZXJ0XCIpLnNob3coKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIGRhdGEgPSB7XG4gICAgICB1c2VyOiB3aW5kb3cuY2FjaGUuY3VycmVudFVzZXJcbiAgICB9O1xuICAgIHZhciB0ZW1wbGF0ZSA9IF8udGVtcGxhdGUoQVNUZW1wbGF0ZSkoZGF0YSk7XG4gICAgdGhpcy4kZWwuaHRtbCh0ZW1wbGF0ZSk7XG4gICAgdGhpcy5pbml0aWFsaXplRmlsZVVwbG9hZCgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZUZpbGVzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcmVuZGVyQXR0YWNobWVudDogZnVuY3Rpb24gKGF0dGFjaG1lbnQpIHtcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIGE6IGF0dGFjaG1lbnQsXG4gICAgICB1c2VyOiB3aW5kb3cuY2FjaGUuY3VycmVudFVzZXIsXG4gICAgICBvd25lcjogdGhpcy5vcHRpb25zLm93bmVyXG4gICAgfTtcbiAgICB2YXIgdGVtcGwgPSBfLnRlbXBsYXRlKEFJVGVtcGxhdGUpKGRhdGEpO1xuICAgIHJldHVybiB0ZW1wbDtcbiAgfSxcblxuICByZW5kZXJOZXdBdHRhY2htZW50OiBmdW5jdGlvbiAoZmlsZSwgYXR0YWNobWVudCkge1xuICAgIGF0dGFjaG1lbnQuZmlsZSA9IGZpbGU7XG4gICAgdmFyIHRlbXBsID0gdGhpcy5yZW5kZXJBdHRhY2htZW50KGF0dGFjaG1lbnQpO1xuICAgICQoXCIuYXR0YWNobWVudC1ub25lXCIpLmhpZGUoKTtcbiAgICAvLyBwdXQgbmV3IGF0IHRoZSB0b3Agb2YgdGhlIGxpc3QgcmF0aGVyIHRoYW4gdGhlIGJvdHRvbVxuICAgICQoXCIuYXR0YWNobWVudC10Ym9keVwiKS5wcmVwZW5kKHRlbXBsKTtcbiAgICAkKFwidGltZS50aW1lYWdvXCIpLnRpbWVhZ28oKTtcbiAgICBwb3BvdmVycy5wb3BvdmVyUGVvcGxlSW5pdChcIi5wcm9qZWN0LXBlb3BsZS1kaXZcIik7XG4gIH0sXG5cbiAgZGVsZXRlQXR0YWNobWVudDogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgeyBlLnByZXZlbnREZWZhdWx0KCk7IH1cbiAgICAkLmFqYXgoe1xuICAgICAgdXJsOiAnL2FwaS9hdHRhY2htZW50LycgKyAkKGUuY3VycmVudFRhcmdldCkuZGF0YSgnaWQnKSxcbiAgICAgIHR5cGU6ICdERUxFVEUnLFxuICAgICAgc3VjY2VzczogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGZyb20gdGhlIERPTVxuICAgICAgICB2YXIgbGVuID0gJCgkKGUuY3VycmVudFRhcmdldCkucGFyZW50cygndGJvZHknKVswXSkuY2hpbGRyZW4oKS5sZW5ndGg7XG4gICAgICAgICQoZS5jdXJyZW50VGFyZ2V0KS5wYXJlbnRzKCd0cicpWzBdLnJlbW92ZSgpO1xuICAgICAgICBpZiAobGVuID09IDIpIHtcbiAgICAgICAgICAkKFwiLmF0dGFjaG1lbnQtbm9uZVwiKS5zaG93KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBdHRhY2htZW50U2hvd1ZpZXc7XG4iLCJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL21peGlucy91dGlsaXRpZXMnKTtcbnZhciBOYXZWaWV3ID0gcmVxdWlyZSgnLi4vbmF2L3ZpZXdzL25hdl92aWV3Jyk7XG52YXIgRm9vdGVyVmlldyA9IHJlcXVpcmUoJy4uL2Zvb3Rlci92aWV3cy9mb290ZXJfdmlldycpO1xudmFyIEJyb3dzZUxpc3RDb250cm9sbGVyID0gcmVxdWlyZSgnLi9jb250cm9sbGVycy9icm93c2VfbGlzdF9jb250cm9sbGVyJyk7XG52YXIgUHJvamVjdE1vZGVsID0gcmVxdWlyZSgnLi4vLi4vZW50aXRpZXMvcHJvamVjdHMvcHJvamVjdF9tb2RlbCcpO1xudmFyIFByb2plY3RTaG93Q29udHJvbGxlciA9IHJlcXVpcmUoJy4uL3Byb2plY3Qvc2hvdy9jb250cm9sbGVycy9wcm9qZWN0X3Nob3dfY29udHJvbGxlcicpO1xudmFyIFByb2ZpbGVTaG93Q29udHJvbGxlciA9IHJlcXVpcmUoJy4uL3Byb2ZpbGVzL3Nob3cvY29udHJvbGxlcnMvcHJvZmlsZV9zaG93X2NvbnRyb2xsZXInKTtcbnZhciBUYXNrTW9kZWwgPSByZXF1aXJlKCcuLi8uLi9lbnRpdGllcy90YXNrcy90YXNrX21vZGVsJyk7XG52YXIgVGFza1Nob3dDb250cm9sbGVyID0gcmVxdWlyZSgnLi4vdGFza3Mvc2hvdy9jb250cm9sbGVycy90YXNrX3Nob3dfY29udHJvbGxlcicpO1xudmFyIFRhc2tFZGl0Rm9ybVZpZXcgPSByZXF1aXJlKCcuLi90YXNrcy9lZGl0L3ZpZXdzL3Rhc2tfZWRpdF9mb3JtX3ZpZXcnKTtcbnZhciBBZG1pbk1haW5Db250cm9sbGVyID0gcmVxdWlyZSgnLi4vYWRtaW4vY29udHJvbGxlcnMvYWRtaW5fbWFpbl9jb250cm9sbGVyJyk7XG52YXIgSG9tZUNvbnRyb2xsZXIgPSByZXF1aXJlKCcuLi9ob21lL2NvbnRyb2xsZXJzL2hvbWVfY29udHJvbGxlcicpO1xuXG5cbnZhciBCcm93c2VSb3V0ZXIgPSBCYWNrYm9uZS5Sb3V0ZXIuZXh0ZW5kKHtcblxuICByb3V0ZXM6IHtcbiAgICAnJyAgICAgICAgICAgICAgICAgICA6ICdzaG93SG9tZScsXG4gICAgJ3Byb2plY3RzKC8pJyAgICAgICAgICAgICAgIDogJ2xpc3RQcm9qZWN0cycsXG4gICAgJ3Byb2plY3RzLzppZCgvKScgICAgICAgICAgIDogJ3Nob3dQcm9qZWN0JyxcbiAgICAncHJvamVjdHMvOmlkLzphY3Rpb24oLyknICAgOiAnc2hvd1Byb2plY3QnLFxuICAgICd0YXNrcygvKScgICAgICAgICAgICAgICAgICA6ICdsaXN0VGFza3MnLFxuICAgICd0YXNrcy86aWQoLyknICAgICAgICAgICAgICA6ICdzaG93VGFzaycsXG4gICAgJ3Rhc2tzLzppZC86YWN0aW9uKC8pJyAgICAgIDogJ3Nob3dUYXNrJyxcbiAgICAncHJvZmlsZSgvKScgICAgICAgICAgICAgICAgOiAnc2hvd1Byb2ZpbGUnLFxuICAgICdwcm9maWxlLzppZCgvKScgICAgICAgICAgICA6ICdzaG93UHJvZmlsZScsXG4gICAgJ3Byb2ZpbGUvOmlkKC8pLzphY3Rpb24nICAgIDogJ3Nob3dQcm9maWxlJyxcbiAgICAnYWRtaW4oLyknICAgICAgICAgICAgICAgICAgOiAnc2hvd0FkbWluJyxcbiAgICAnYWRtaW4oLyk6YWN0aW9uKC8pJyAgICAgICAgOiAnc2hvd0FkbWluJ1xuICB9LFxuXG4gIGRhdGE6IHsgc2F2ZWQ6IGZhbHNlIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubmF2VmlldyA9IG5ldyBOYXZWaWV3KHtcbiAgICAgIGVsOiAnLm5hdmlnYXRpb24nXG4gICAgfSkucmVuZGVyKCk7XG4gICAgdGhpcy5mb290ZXJWaWV3ID0gbmV3IEZvb3RlclZpZXcoe1xuICAgICAgZWw6ICcjZm9vdGVyJ1xuICAgIH0pLnJlbmRlcigpO1xuICB9LFxuXG4gIGNsZWFudXBDaGlsZHJlbjogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmJyb3dzZUxpc3RDb250cm9sbGVyKSB7IHRoaXMuYnJvd3NlTGlzdENvbnRyb2xsZXIuY2xlYW51cCgpOyB9XG4gICAgaWYgKHRoaXMucHJvamVjdFNob3dDb250cm9sbGVyKSB7IHRoaXMucHJvamVjdFNob3dDb250cm9sbGVyLmNsZWFudXAoKTsgfVxuICAgIGlmICh0aGlzLnByb2ZpbGVTaG93Q29udHJvbGxlcikgeyB0aGlzLnByb2ZpbGVTaG93Q29udHJvbGxlci5jbGVhbnVwKCk7IH1cbiAgICBpZiAodGhpcy50YXNrU2hvd0NvbnRyb2xsZXIpIHsgdGhpcy50YXNrU2hvd0NvbnRyb2xsZXIuY2xlYW51cCgpOyB9XG4gICAgaWYgKHRoaXMuaG9tZUNvbnRyb2xsZXIpIHsgdGhpcy5ob21lQ29udHJvbGxlci5jbGVhbnVwKCk7IH1cbiAgICB0aGlzLmRhdGEgPSB7IHNhdmVkOiBmYWxzZSB9O1xuICB9LFxuXG4gIHNob3dIb21lOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jbGVhbnVwQ2hpbGRyZW4oKTtcbiAgICB0aGlzLmhvbWVDb250cm9sbGVyID0gbmV3IEhvbWVDb250cm9sbGVyKHt0YXJnZXQ6ICdob21lJywgZWw6ICcjY29udGFpbmVyJywgcm91dGVyOiB0aGlzLCBkYXRhOiB0aGlzLmRhdGEgfSk7XG4gIH0sXG5cbiAgbGlzdFByb2plY3RzOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jbGVhbnVwQ2hpbGRyZW4oKTtcbiAgICB0aGlzLmJyb3dzZUxpc3RDb250cm9sbGVyID0gbmV3IEJyb3dzZUxpc3RDb250cm9sbGVyKHtcbiAgICAgIHRhcmdldDogJ3Byb2plY3RzJyxcbiAgICAgIGVsOiAnI2NvbnRhaW5lcicsXG4gICAgICBkYXRhOiB0aGlzLmRhdGFcbiAgICB9KTtcbiAgfSxcblxuICBsaXN0VGFza3M6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNsZWFudXBDaGlsZHJlbigpO1xuICAgIHRoaXMuYnJvd3NlTGlzdENvbnRyb2xsZXIgPSBuZXcgQnJvd3NlTGlzdENvbnRyb2xsZXIoe1xuICAgICAgdGFyZ2V0OiAndGFza3MnLFxuICAgICAgZWw6ICcjY29udGFpbmVyJyxcbiAgICAgIGRhdGE6IHRoaXMuZGF0YVxuICAgIH0pO1xuICB9LFxuXG4gIHNob3dQcm9qZWN0OiBmdW5jdGlvbiAoaWQsIGFjdGlvbikge1xuICAgIHRoaXMuY2xlYW51cENoaWxkcmVuKCk7XG4gICAgdmFyIG1vZGVsID0gbmV3IFByb2plY3RNb2RlbCgpO1xuICAgIG1vZGVsLnNldCh7IGlkOiBpZCB9KTtcbiAgICB0aGlzLnByb2plY3RTaG93Q29udHJvbGxlciA9IG5ldyBQcm9qZWN0U2hvd0NvbnRyb2xsZXIoeyBtb2RlbDogbW9kZWwsIHJvdXRlcjogdGhpcywgaWQ6IGlkLCBhY3Rpb246IGFjdGlvbiwgZGF0YTogdGhpcy5kYXRhIH0pO1xuICB9LFxuXG4gIHNob3dUYXNrOiBmdW5jdGlvbiAoaWQsIGFjdGlvbikge1xuICAgIHRoaXMuY2xlYW51cENoaWxkcmVuKCk7XG4gICAgdmFyIG1vZGVsID0gbmV3IFRhc2tNb2RlbCgpO1xuICAgIG1vZGVsLnNldCh7IGlkOiBpZCB9KTtcbiAgICB0aGlzLnRhc2tTaG93Q29udHJvbGxlciA9IG5ldyBUYXNrU2hvd0NvbnRyb2xsZXIoeyBtb2RlbDogbW9kZWwsIHJvdXRlcjogdGhpcywgaWQ6IGlkLCBhY3Rpb246IGFjdGlvbiwgZGF0YTogdGhpcy5kYXRhIH0pO1xuICB9LFxuXG4gIHNob3dQcm9maWxlOiBmdW5jdGlvbiAoaWQsIGFjdGlvbikge1xuICAgIHRoaXMuY2xlYW51cENoaWxkcmVuKCk7XG4gICAgLy8gbm9ybWFsaXplIGlucHV0XG4gICAgaWYgKGlkKSB7XG4gICAgICBpZCA9IGlkLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIGlmIChhY3Rpb24pIHtcbiAgICAgIGFjdGlvbiA9IGFjdGlvbi50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICAvLyBub3JtYWxpemUgYWN0aW9ucyB0aGF0IGRvbid0IGhhdmUgaWRzXG4gICAgaWYgKCFhY3Rpb24gJiYgaWQpIHtcbiAgICAgIGlmIChpZCA9PSAnZWRpdCcpIHtcbiAgICAgICAgYWN0aW9uID0gaWQ7XG4gICAgICAgIGlkID0gd2luZG93LmNhY2hlLmN1cnJlbnRVc2VyLmlkO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaWQgPT0gJ3NldHRpbmdzJykge1xuICAgICAgICBhY3Rpb24gPSBpZDtcbiAgICAgICAgaWQgPSB3aW5kb3cuY2FjaGUuY3VycmVudFVzZXIuaWQ7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucHJvZmlsZVNob3dDb250cm9sbGVyID0gbmV3IFByb2ZpbGVTaG93Q29udHJvbGxlcih7IGlkOiBpZCwgYWN0aW9uOiBhY3Rpb24sIGRhdGE6IHRoaXMuZGF0YSB9KTtcbiAgfSxcblxuICBzaG93QWRtaW46IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICB0aGlzLmNsZWFudXBDaGlsZHJlbigpO1xuICAgIHRoaXMuYWRtaW5NYWluQ29udHJvbGxlciA9IG5ldyBBZG1pbk1haW5Db250cm9sbGVyKHtcbiAgICAgIGVsOiBcIiNjb250YWluZXJcIixcbiAgICAgIGFjdGlvbjogYWN0aW9uXG4gICAgfSk7XG4gIH1cblxufSk7XG5cbnZhciBpbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcm91dGVyID0gbmV3IEJyb3dzZVJvdXRlcigpO1xuICByZXR1cm4gcm91dGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5pdGlhbGl6ZTogaW5pdGlhbGl6ZVxufTtcblxuIiwiXG52YXIgQm9vdHN0cmFwID0gcmVxdWlyZSgnYm9vdHN0cmFwJyk7XG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgQmFzZUNvbnRyb2xsZXIgPSByZXF1aXJlKCcuLi8uLi8uLi9iYXNlL2Jhc2VfY29udHJvbGxlcicpO1xudmFyIEJyb3dzZU1haW5WaWV3ID0gcmVxdWlyZSgnLi4vdmlld3MvYnJvd3NlX21haW5fdmlldycpO1xudmFyIFByb2plY3RzQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uLy4uL2VudGl0aWVzL3Byb2plY3RzL3Byb2plY3RzX2NvbGxlY3Rpb24nKTtcbnZhciBUYXNrc0NvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi8uLi9lbnRpdGllcy90YXNrcy90YXNrc19jb2xsZWN0aW9uJyk7XG52YXIgVGFza01vZGVsID0gcmVxdWlyZSgnLi4vLi4vLi4vZW50aXRpZXMvdGFza3MvdGFza19tb2RlbCcpO1xudmFyIFByb2plY3RGb3JtVmlldyA9IHJlcXVpcmUoJy4uLy4uL3Byb2plY3QvbmV3L3ZpZXdzL3Byb2plY3RfbmV3X2Zvcm1fdmlldycpO1xudmFyIFRhc2tGb3JtVmlldyA9IHJlcXVpcmUoJy4uLy4uL3Rhc2tzL25ldy92aWV3cy90YXNrX2Zvcm1fdmlldycpO1xudmFyIE1vZGFsV2l6YXJkQ29tcG9uZW50ID0gcmVxdWlyZSgnLi4vLi4vLi4vY29tcG9uZW50cy9tb2RhbF93aXphcmQnKTtcbnZhciBNb2RhbENvbXBvbmVudCA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbXBvbmVudHMvbW9kYWwnKTtcblxuXG5Ccm93c2UgPSB7fTtcblxuQnJvd3NlLkxpc3RDb250cm9sbGVyID0gQmFzZUNvbnRyb2xsZXIuZXh0ZW5kKHtcblxuICBldmVudHM6IHtcbiAgICBcImNsaWNrIC5saW5rLWJhY2tib25lXCIgIDogbGlua0JhY2tib25lLFxuICAgIFwiY2xpY2sgLnByb2plY3QtYmFja2dyb3VuZC1pbWFnZVwiIDogXCJzaG93UHJvamVjdFwiLFxuICAgIFwiY2xpY2sgLnRhc2stYm94XCIgICAgICAgOiBcInNob3dUYXNrXCIsXG4gICAgXCJjbGljayAuYWRkLXByb2plY3RcIiAgICA6IFwiYWRkUHJvamVjdFwiLFxuICAgIFwiY2xpY2sgLmFkZC1vcHBvcnR1bml0eVwiOiBcImFkZFRhc2tcIlxuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICggb3B0aW9ucyApIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgLy8gdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnRhcmdldCA9IG9wdGlvbnMudGFyZ2V0O1xuICAgIHRoaXMuZmlyZVVwQ29sbGVjdGlvbigpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZVZpZXcoKTtcblxuICAgIHRoaXMuY29sbGVjdGlvbi50cmlnZ2VyKCdicm93c2U6JyArIHRoaXMudGFyZ2V0ICsgXCI6ZmV0Y2hcIik7XG5cbiAgICB0aGlzLmxpc3RlblRvKHRoaXMucHJvamVjdHNDb2xsZWN0aW9uLCBcInByb2plY3Q6c2F2ZTpzdWNjZXNzXCIsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAvLyBoaWRlIHRoZSBtb2RhbFxuICAgICAgJCgnI2FkZFByb2plY3QnKS5iaW5kKCdoaWRkZW4uYnMubW9kYWwnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgQmFja2JvbmUuaGlzdG9yeS5uYXZpZ2F0ZSgncHJvamVjdHMvJyArIGRhdGEuYXR0cmlidXRlcy5pZCwgeyB0cmlnZ2VyOiB0cnVlIH0pO1xuICAgICAgfSkubW9kYWwoJ2hpZGUnKTtcbiAgICB9KTtcblxuICAgIHRoaXMubGlzdGVuVG8odGhpcy50YXNrc0NvbGxlY3Rpb24sIFwidGFzazpzYXZlOnN1Y2Nlc3NcIiwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIC8vIGhpZGUgdGhlIG1vZGFsXG4gICAgICAkKCcjYWRkVGFzaycpLmJpbmQoJ2hpZGRlbi5icy5tb2RhbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBCYWNrYm9uZS5oaXN0b3J5Lm5hdmlnYXRlKCd0YXNrcy8nICsgZGF0YSwgeyB0cmlnZ2VyOiB0cnVlIH0pO1xuICAgICAgfSkubW9kYWwoJ2hpZGUnKTtcbiAgICB9KTtcblxuICB9LFxuXG4gIGluaXRpYWxpemVWaWV3OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuYnJvd3NlTWFpblZpZXcpIHtcbiAgICAgIHRoaXMuYnJvd3NlTWFpblZpZXcuY2xlYW51cCgpO1xuICAgIH1cbiAgICB0aGlzLmJyb3dzZU1haW5WaWV3ID0gbmV3IEJyb3dzZU1haW5WaWV3KHtcbiAgICAgIGVsOiBcIiNjb250YWluZXJcIixcbiAgICAgIHRhcmdldDogdGhpcy50YXJnZXQsXG4gICAgICBjb2xsZWN0aW9uOiB0aGlzLmNvbGxlY3Rpb25cbiAgICB9KS5yZW5kZXIoKTtcbiAgfSxcblxuICBmaXJlVXBDb2xsZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMucHJvamVjdHNDb2xsZWN0aW9uID0gbmV3IFByb2plY3RzQ29sbGVjdGlvbigpO1xuICAgIHRoaXMudGFza3NDb2xsZWN0aW9uID0gbmV3IFRhc2tzQ29sbGVjdGlvbigpO1xuICAgIGlmICh0aGlzLnRhcmdldCA9PSAncHJvamVjdHMnKSB7XG4gICAgICB0aGlzLmNvbGxlY3Rpb24gPSB0aGlzLnByb2plY3RzQ29sbGVjdGlvbjtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy50YXJnZXQgPT0gJ3Rhc2tzJykge1xuICAgICAgdGhpcy5jb2xsZWN0aW9uID0gdGhpcy50YXNrc0NvbGxlY3Rpb247XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5jb2xsZWN0aW9uID0gbmV3IFByb2ZpbGVzQ29sbGVjdGlvbigpO1xuICAgIH1cbiAgICB0aGlzLmxpc3RlblRvT25jZSh0aGlzLmNvbGxlY3Rpb24sICdicm93c2U6JyArIHRoaXMudGFyZ2V0ICsgXCI6ZmV0Y2hcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5jb2xsZWN0aW9uLmZldGNoKHtcbiAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICBzZWxmLmNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuICAgICAgICAgIHNlbGYuYnJvd3NlTWFpblZpZXcucmVuZGVyTGlzdChzZWxmLmNvbGxlY3Rpb24udG9KU09OKCkpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH0sXG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy89IEJFR0lOIENMQVNTIE1FVEhPRFNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgc2hvd1Byb2plY3Q6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB2YXIgaWQgPSAkKCQoZS5jdXJyZW50VGFyZ2V0KS5wYXJlbnRzKCdsaS5wcm9qZWN0LWJveCcpWzBdKS5kYXRhKCdpZCcpO1xuICAgIEJhY2tib25lLmhpc3RvcnkubmF2aWdhdGUoJ3Byb2plY3RzLycgKyBpZCwgeyB0cmlnZ2VyOiB0cnVlIH0pO1xuICB9LFxuXG4gIHNob3dUYXNrOiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIGlkID0gJChlLmN1cnJlbnRUYXJnZXQpLmRhdGEoJ2lkJykgfHwgJCgkKGUuY3VycmVudFRhcmdldCkucGFyZW50cygnbGkudGFzay1ib3gnKVswXSkuZGF0YSgnaWQnKTtcbiAgICBCYWNrYm9uZS5oaXN0b3J5Lm5hdmlnYXRlKCd0YXNrcy8nICsgaWQsIHsgdHJpZ2dlcjogdHJ1ZSB9KTtcbiAgfSxcblxuICBhZGRQcm9qZWN0OiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBpZiAodGhpcy5wcm9qZWN0Rm9ybVZpZXcpIHRoaXMucHJvamVjdEZvcm1WaWV3LmNsZWFudXAoKTtcbiAgICBpZiAodGhpcy5tb2RhbENvbXBvbmVudCkgdGhpcy5tb2RhbENvbXBvbmVudC5jbGVhbnVwKCk7XG5cbiAgICB0aGlzLm1vZGFsQ29tcG9uZW50ID0gbmV3IE1vZGFsQ29tcG9uZW50KHtcbiAgICAgIGVsOiBcIi53cmFwcGVyLWFkZFByb2plY3RcIixcbiAgICAgIGlkOiBcImFkZFByb2plY3RcIixcbiAgICAgIG1vZGFsVGl0bGU6IFwiQWRkIFwiICsgaTE4bi50KFwiUHJvamVjdFwiKVxuICAgIH0pLnJlbmRlcigpO1xuXG4gICAgdGhpcy5wcm9qZWN0Rm9ybVZpZXcgPSBuZXcgUHJvamVjdEZvcm1WaWV3KHtcbiAgICAgIGVsOiBcIi5tb2RhbC10ZW1wbGF0ZVwiLFxuICAgICAgY29sbGVjdGlvbjogdGhpcy5wcm9qZWN0c0NvbGxlY3Rpb25cbiAgICB9KS5yZW5kZXIoKTtcblxuICB9LFxuXG4gIGFkZFRhc2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIGlmICh0aGlzLnRhc2tGb3JtVmlldykgdGhpcy50YXNrRm9ybVZpZXcuY2xlYW51cCgpO1xuICAgIGlmICh0aGlzLm1vZGFsV2l6YXJkQ29tcG9uZW50KSB0aGlzLm1vZGFsV2l6YXJkQ29tcG9uZW50LmNsZWFudXAoKTtcblxuICAgIHRoaXMudGFza01vZGVsID0gbmV3IFRhc2tNb2RlbCgpO1xuICAgIHRoaXMubW9kYWxXaXphcmRDb21wb25lbnQgPSBuZXcgTW9kYWxXaXphcmRDb21wb25lbnQoe1xuICAgICAgZWw6IFwiLndyYXBwZXItYWRkVGFza1wiLFxuICAgICAgaWQ6IFwiYWRkVGFza1wiLFxuICAgICAgZHJhZnQ6IHRydWUsXG4gICAgICBtb2RhbFRpdGxlOiAnTmV3ICcgKyBpMThuLnQoJ09wcG9ydHVuaXR5JyksXG4gICAgICBtb2RlbDogdGhpcy50YXNrTW9kZWwsXG4gICAgICBjb2xsZWN0aW9uOiB0aGlzLnRhc2tzQ29sbGVjdGlvbixcbiAgICAgIG1vZGVsTmFtZTogJ3Rhc2snLFxuICAgICAgZGF0YTogZnVuY3Rpb24gKHBhcmVudCkgeyByZXR1cm4ge1xuICAgICAgICB0aXRsZTogcGFyZW50LiQoXCIjdGFzay10aXRsZVwiKS52YWwoKSxcbiAgICAgICAgZGVzY3JpcHRpb246IHBhcmVudC4kKFwiI3Rhc2stZGVzY3JpcHRpb25cIikudmFsKCksXG4gICAgICAgIC8vIHRoZXNlIHRhc2tzIGFyZSBvcnBoYW5lZFxuICAgICAgICBwcm9qZWN0SWQ6IG51bGxcbiAgICAgIH0gfVxuICAgIH0pLnJlbmRlcigpO1xuXG4gICAgdGhpcy50YXNrRm9ybVZpZXcgPSBuZXcgVGFza0Zvcm1WaWV3KHtcbiAgICAgIGVsOiBcIiNhZGRUYXNrIC5tb2RhbC1ib2R5XCIsXG4gICAgICBwcm9qZWN0SWQ6IG51bGwsXG4gICAgICBtb2RlbDogdGhpcy50YXNrTW9kZWwsXG4gICAgICB0YXNrczogdGhpcy50YXNrc0NvbGxlY3Rpb25cbiAgICB9KS5yZW5kZXIoKTtcbiAgICB0aGlzLm1vZGFsV2l6YXJkQ29tcG9uZW50LnNldENoaWxkVmlldyh0aGlzLnRhc2tGb3JtVmlldyk7XG4gICAgdGhpcy5tb2RhbFdpemFyZENvbXBvbmVudC5zZXROZXh0KHRoaXMudGFza0Zvcm1WaWV3LmNoaWxkTmV4dCk7XG4gICAgdGhpcy5tb2RhbFdpemFyZENvbXBvbmVudC5zZXRTdWJtaXQodGhpcy50YXNrRm9ybVZpZXcuY2hpbGROZXh0KTtcbiAgfSxcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy89IFVUSUxJVFkgTUVUSE9EU1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgY2xlYW51cDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMudGFza0Zvcm1WaWV3KSB7IHRoaXMudGFza0Zvcm1WaWV3LmNsZWFudXAoKTsgfVxuICAgIGlmICh0aGlzLm1vZGFsV2l6YXJkQ29tcG9uZW50KSB7IHRoaXMubW9kYWxXaXphcmRDb21wb25lbnQuY2xlYW51cCgpOyB9XG4gICAgaWYgKHRoaXMucHJvamVjdEZvcm1WaWV3KSB7IHRoaXMucHJvamVjdEZvcm1WaWV3LmNsZWFudXAoKTsgfVxuICAgIGlmICh0aGlzLm1vZGFsQ29tcG9uZW50KSB7IHRoaXMubW9kYWxDb21wb25lbnQuY2xlYW51cCgpOyB9XG4gICAgaWYgKHRoaXMuYnJvd3NlTWFpblZpZXcpIHsgdGhpcy5icm93c2VNYWluVmlldy5jbGVhbnVwKCk7IH1cbiAgICByZW1vdmVWaWV3KHRoaXMpO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJyb3dzZS5MaXN0Q29udHJvbGxlcjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJ3cmFwcGVyLWFkZFByb2plY3RcXFwiPjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcIndyYXBwZXItYWRkVGFza1xcXCI+PC9kaXY+XFxuXFxuPGRpdiBjbGFzcz1cXFwicm93IHNlYXJjaC1yb3dcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTMgY29sLW1kLXB1c2gtOSBicm93c2UtYnV0dG9uc1xcXCI+XFxuICAgIDwlIGlmICh1aS5wcm9qZWN0LnNob3cpIHsgJT5cXG4gICAgPGEgaHJlZj1cXFwiI2FkZFByb2plY3RcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWMyIGFkZC1wcm9qZWN0XFxcIiBkYXRhLXRvZ2dsZT1cXFwibW9kYWxcXFwiIGRhdGEtYmFja2Ryb3A9XFxcInN0YXRpY1xcXCIgc3R5bGU9XFxcIjwlIGlmICghdXNlcikgeyAlPmRpc3BsYXk6IG5vbmU7PCUgfSAlPlxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXBsdXNcXFwiPjwvaT4gPHNwYW4gZGF0YS1pMThuPVxcXCJQcm9qZWN0XFxcIj5Qcm9qZWN0PC9zcGFuPjwvYT5cXG4gICAgPCUgfSAlPlxcbiAgICA8YSBocmVmPVxcXCIjYWRkVGFza1xcXCIgY2xhc3M9XFxcImJ0biBidG4tYzIgYWRkLW9wcG9ydHVuaXR5XFxcIiBkYXRhLXRvZ2dsZT1cXFwibW9kYWxcXFwiIGRhdGEtYmFja2Ryb3A9XFxcInN0YXRpY1xcXCIgc3R5bGU9XFxcIjwlIGlmICghdXNlcikgeyAlPmRpc3BsYXk6IG5vbmU7PCUgfSAlPlxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXBsdXNcXFwiPjwvaT4gPHNwYW4gZGF0YS1pMThuPVxcXCJUYXNrXFxcIj5PcHBvcnR1bml0eTwvc3Bhbj48L2E+XFxuICA8L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcImNvbC1tZC05IGNvbC1tZC1wdWxsLTNcXFwiPlxcbiAgICA8Zm9ybSBjbGFzcz1cXFwiZm9ybS1ob3Jpem9udGFsXFxcIiByb2xlPVxcXCJmb3JtXFxcIiBpZD1cXFwic2VhcmNoLWZvcm1cXFwiPlxcblxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXAgcm93XFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1zbS0xMCBjb2wtbWQtMTAgY29sLWxnLTkgaW5wdXQtc2VhcmNoXFxcIj5cXG4gICAgICAgICAgPGlucHV0IHR5cGU9XFxcImhpZGRlblxcXCIgaWQ9XFxcInNlYXJjaFxcXCIgdGl0bGU9XFxcIlNlYXJjaFxcXCIgc3R5bGU9XFxcIndpZHRoOiAxMDAlXFxcIi8+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1zbS0yIGNvbC1tZC0yIGNvbC1sZy0zIGJ0bi1zZWFyY2hcXFwiPlxcbiAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwic3VibWl0XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1jMVxcXCIgdGl0bGU9XFxcIlNlYXJjaFxcXCIgdmFsdWU9XFxcIlNlYXJjaFxcXCIvPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuXFxuICAgIDwvZm9ybT5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuXFxuICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMyBjb2wtbWQtcHVzaC05IGJveFxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImJvcmRlci1ib3R0b20gYm94LXBhZC1sclxcXCI+XFxuICAgICAgPGgyPkZpbHRlcnM8L2gyPlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiYm94LXBhZC10XFxcIj5cXG4gICAgICA8JSBpZiAoIHRhcmdldCA9PSBcXFwidGFza3NcXFwiICkgeyU+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiYm94LXBhZC1sclxcXCIgaWQ9XFxcInN0YXRlRmlsdGVyc1xcXCI+XFxuICAgICAgICA8JSBfLmVhY2godWkuc3RhdGVzLCBmdW5jdGlvbiAodCkgeyAlPlxcbiAgICAgICAgICA8bGFiZWwgY2xhc3M9XFxcIjwlIGlmICggdC52YWx1ZSA9PSBcXFwiZHJhZnRcXFwiICkgeyAlPmhpZGRlbiBkcmFmdC1maWx0ZXI8JSB9ICU+XFxcIj5cXG4gICAgICAgICAgICA8aW5wdXQgdHlwZT0nY2hlY2tib3gnIG5hbWU9J3N0YXRlPCUtIHQubGFiZWwgJT4nIGNsYXNzPSdzdGF0ZUZpbHRlcicgdmFsdWU9JzwlLSB0LnZhbHVlICU+J1xcbiAgICAgICAgICAgIDwlIGlmICggdC52YWx1ZSA9PSBcXFwib3BlblxcXCIgKSB7JT5cXG4gICAgICAgICAgICAgIDwlLSBjaGVja2VkPVxcXCJjaGVja2VkXFxcIiAlPlxcbiAgICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgICA+IDwlLSB0LmxhYmVsICU+XFxuICAgICAgICAgIDwvbGFiZWw+XFxuICAgICAgICA8JSB9KTsgJT5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8JSB9ICU+XFxuICAgICAgPGRpdiBpZD1cXFwic2VhcmNoLXByb2pzLXdyYXBwZXJcXFwiIGNsYXNzPVxcXCJib3gtcGFkLWxyXFxcIj5cXG4gICAgICAgIDx1bCBpZD1cXFwic2VhcmNoLXByb2pzXFxcIiBjbGFzcz1cXFwibmF2IG5hdi1waWxscyBuYXYtc3RhY2tlZCBuYXYtc2VhcmNoXFxcIj5cXG4gICAgICAgIDwvdWw+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiYm94LXBhZC1sclxcXCI+XFxuICAgICAgICA8dWwgaWQ9XFxcInNlYXJjaC10YWdzXFxcIiBjbGFzcz1cXFwibmF2IG5hdi1waWxscyBuYXYtc3RhY2tlZCBuYXYtc2VhcmNoXFxcIj5cXG4gICAgICAgIDwvdWw+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiYm94LXBhZC1sciBzZWFyY2gtY2xlYXJcXFwiIHN0eWxlPVxcXCJkaXNwbGF5OiBub25lO1xcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJhbGlnbi1yaWdodFxcXCI+XFxuICAgICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGlkPVxcXCJzZWFyY2gtY2xlYXJcXFwiIGNsYXNzPVxcXCJidG4gYnRuLXNtIGJ0bi1jMFxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXJlbW92ZVxcXCI+PC9pPiBDbGVhciBTZWFyY2ggQ3JpdGVyaWE8L2E+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG5cXG4gIDxkaXYgY2xhc3M9XFxcImNvbC1tZC05IGNvbC1tZC1wdWxsLTNcXFwiPlxcbiAgICA8ZGl2IGlkPVxcXCJicm93c2Utc2VhcmNoLXNwaW5uZXJcXFwiIGNsYXNzPVxcXCJmdWxsd2lkdGggdGV4dC1jZW50ZXJcXFwiPlxcbiAgICAgIExvYWRpbmcuLi4gPGkgY2xhc3M9XFxcImZhIGZhLXNwaW5uZXIgZmEtc3BpblxcXCI+PC9pPlxcbiAgICA8L2Rpdj5cXG4gICAgPHVsIGlkPVxcXCJicm93c2UtbGlzdFxcXCI+XFxuICAgIDwvdWw+XFxuICA8L2Rpdj5cXG5cXG48L2Rpdj5cXG5cIjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8bGkgZGF0YS1pZD1cXFwiPCU9IGRhdGEuaWQgJT5cXFwiPlxcbiAgPCU9IGZvcm1hdCAlPlxcbiAgPGRpdiBjbGFzcz1cXFwicHVsbC1yaWdodFxcXCI+XFxuICAgIDxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJzZWFyY2gtdGFnLXJlbW92ZVxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXJlbW92ZVxcXCI+PC9pPjwvYT5cXG4gIDwvZGl2PlxcbjwvbGk+XFxuXCI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHNwYW4gZGF0YS1pMThuPSdbaHRtbF1ub1NlYXJjaFJlc3VsdHMudGV4dCc+XFxuPGgyPk9vcHMgd2UgZGlkbid0IGZpbmQgYW55IHJlc3VsdHM8L2gyPlxcbjxwPk1heWJlIHlvdXIgc2VhcmNoIHdhcyB0b28gc3BlY2lmaWMuIFlvdSBjb3VsZCB0cnkgaW5jbHVkaW5nIG1vcmUgZmlsdGVycyBsaWtlIDxiPkNvbXBsZXRlZDwvYj4gb3IgPGI+QXJjaGl2ZWQ8L2I+LiBNYXliZSB0aGVyZSBhcmUgdG9vIG1hbnkgc2VhcmNoIHRlcm1zLCB0cnkgcmVtb3Zpbmcgc29tZSBvciB1c2luZyBtb3JlIGdlbmVyYWwgdGVybXMuPC9wPlxcbjxwPlN0aWxsIG5vdCBmaW5kaW5nIHdoYXQgeW91IHdhbnRlZD88L3A+XFxuPHA+RGlkIHlvdSBtZWFuIHRvOjwvcD5cXG48L3NwYW4+XFxuXFx0PHVsPlxcblxcdFxcdDwlIGlmICh1aS5wcm9qZWN0LnNob3cpIHsgJT5cXG5cXHRcXHQ8bGk+TG9vayBmb3IgPHNwYW4gZGF0YS1pMThuPVxcXCJQcm9qZWN0SW5kZWZpbml0ZVxcXCI+YSBQcm9qZWN0PC9zcGFuPj8gVHJ5IGdvaW5nIHRvIEJyb3dzZSA8c3BhbiBkYXRhLWkxOG49XFxcIlByb2plY3RQbHVyYWxcXFwiPlByb2plY3RzPC9zcGFuPiBvciBjbGlja2luZyA8YSBocmVmPScvcHJvamVjdHMnPmhlcmU8L2E+IC48L2xpPlxcblxcdFxcdDwlIH0gJT5cXG5cXHRcXHQ8bGk+TG9vayBmb3IgPHNwYW4gZGF0YS1pMThuPVxcXCJUYXNrSW5kZWZpbml0ZVxcXCI+YSBUYXNrPC9zcGFuPj8gVHJ5IGdvaW5nIHRvIEJyb3dzZSA8c3BhbiBkYXRhLWkxOG49XFxcIlRhc2tQbHVyYWxcXFwiPlRhc2tzPC9zcGFuPiBvciBjbGlja2luZyA8YSBocmVmPScvdGFza3MnPmhlcmU8L2E+IC4gPC9saT5cXG5cXHRcXHQ8JSBpZiAodWkuZmFxLnNob3cpIHsgJT5cXG5cXHRcXHQ8bGk+R2V0IGFuIGFuc3dlciB0byBhIGdlbmVyYWwgcXVlc3Rpb24/IFRyeSByZWFkaW5nIHRoZSBGQVEgYnkgY2xpY2tpbmcgPGEgaHJlZj0nPCUtIHVpLmZhcS51cmwgJT4nPmhlcmU8L2E+IC48L2xpPlxcblxcdFxcdDwlIH0gJT5cXG5cXHRcXHQ8bGk+R2V0IGFuIGFuc3dlciB0byBhIHNwZWNpZmljIHF1ZXN0aW9uIHlvdSBjYW4ndCBmaW5kIGVsc2V3aGVyZT8gVHJ5aW5nIDxhIGhyZWY9J21haWx0bzo8JS0gdWkuc3lzdGVtRW1haWwgJT4nPnNlbmRpbmcgYW4gZW1haWwgdG8gdGhlIHRlYW0gLjwvYT48L2xpPlxcblxcdDwvdWw+XCI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGxpIGRhdGEtaWQ9XFxcIjwlLSBpdGVtLmlkICU+XFxcIiBjbGFzcz1cXFwiYm94IHByb2plY3QtYm94XFxcIj5cXG4gIDwlIGlmIChpdGVtLmNvdmVySWQpIHsgJT5cXG4gIDxkaXYgY2xhc3M9XFxcInByb2plY3QtYmFja2dyb3VuZC1pbWFnZSBib3JkZXItYm90dG9tXFxcIiBzdHlsZT1cXFwiYmFja2dyb3VuZC1pbWFnZTogdXJsKC9hcGkvZmlsZS9nZXQvPCU9IGl0ZW0uY292ZXJJZCAlPilcXFwiPlxcbiAgPCUgfSBlbHNlIHsgJT5cXG4gIDxkaXYgY2xhc3M9XFxcInByb2plY3QtYmFja2dyb3VuZC1pbWFnZSBib3JkZXItYm90dG9tIHByb2plY3QtYmFja2dyb3VuZC1pbWFnZS1kZWZhdWx0XFxcIj5cXG4gIDwlIH0gJT5cXG4gIDwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwicHJvamVjdC10aXRsZVxcXCI+XFxuICAgIDxhIGhyZWY9XFxcIi9wcm9qZWN0cy88JS0gaXRlbS5pZCAlPlxcXCIgY2xhc3M9XFxcImxpbmstYmFja2JvbmUgYzFcXFwiPlxcbiAgICAgIDwlLSBpdGVtLnRpdGxlICU+XFxuICAgIDwvYT5cXG4gIDwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwicHJvamVjdC1saXN0LWRlc2NyaXB0aW9uXFxcIj5cXG4gICAgPCU9IGl0ZW0uZGVzY3JpcHRpb25IdG1sICU+XFxuICA8L2Rpdj5cXG5cXG4gIDxkaXYgY2xhc3M9XFxcInByb2plY3QtbGlzdC1ib3R0b20td3JhcHBlciBib3JkZXItdG9wXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwicHJvamVjdC1saXN0LWNvdW50c1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwicHJvamVjdC1saXN0LWNvdW50cy1jb2xcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwicHJvamVjdC1saXN0LWNvdW50IGMyXFxcIj5cXG4gICAgICAgICAgPCUtIGl0ZW0udGFza0NvdW50ICU+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInByb2plY3QtbGlzdC1jb3VudC10ZXh0IGMyXFxcIj5cXG4gICAgICAgICAgb3BwPCUgaWYgKGl0ZW0udGFza0NvdW50ICE9IDEpIHsgJT5zPCUgfSAlPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwicHJvamVjdC1saXN0LWNvdW50cy1jb2xcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwicHJvamVjdC1saXN0LWNvdW50IGMyXFxcIj5cXG4gICAgICAgICAgPCUtIGl0ZW0uY29tbWVudENvdW50ICU+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInByb2plY3QtbGlzdC1jb3VudC10ZXh0IGMyXFxcIj5cXG4gICAgICAgICAgY29tbWVudDwlIGlmIChpdGVtLmNvbW1lbnRDb3VudCAhPSAxKSB7ICU+czwlIH0gJT5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInByb2plY3QtbGlzdC1jb3VudHMtY29sXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInByb2plY3QtbGlzdC1jb3VudCBjMlxcXCI+XFxuICAgICAgICAgIDwlLSBpdGVtLm93bmVyQ291bnQgJT5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwicHJvamVjdC1saXN0LWNvdW50LXRleHQgYzIgIFxcXCI+XFxuICAgICAgICAgIDwlIGlmIChpdGVtLm93bmVyQ291bnQgIT0gMSkgeyAlPnBlb3BsZTwlIH0gZWxzZSB7ICU+cGVyc29uPCUgfSAlPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC9saT5cIjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8bGkgZGF0YS1pZD1cXFwiPCUtIGl0ZW0uaWQgJT5cXFwiIGNsYXNzPVxcXCJib3ggdGFzay1ib3hcXFwiPlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ0YXNrLWxpc3QtdGl0bGUgdGFzay10aXRsZS1vdmVyZmxvdy1tdWx0aVxcXCI+XFxuICAgICAgPGEgaHJlZj1cXFwiL3Rhc2tzLzwlLSBpdGVtLmlkICU+XFxcIiBjbGFzcz1cXFwibGluay1iYWNrYm9uZSBjMVxcXCI+XFxuICAgICAgICA8JS0gaXRlbS50aXRsZSAlPlxcbiAgICAgIDwvYT5cXG4gICAgPC9kaXY+XFxuXFxuICA8ZGl2IGNsYXNzPVxcXCJ0YXNrLWxpc3QtZGVzY3JpcHRpb24gdGFzay1kZXNjLW92ZXJmbG93LW11bHRpXFxcIj5cXG4gICAgPCU9IGl0ZW0uZGVzY3JpcHRpb25IdG1sICU+XFxuICA8L2Rpdj5cXG5cXG4gIDxkaXYgY2xhc3M9XFxcInRhc2stbGlzdC1ib3R0b20gYm9yZGVyLXRvcFxcXCI+XFxuXFxuICAgIDwlIF8uZWFjaCh0YWdTaG93LCBmdW5jdGlvbiAodGFnVHlwZSkgeyAlPlxcblxcbiAgICAgIDwlIGlmICh0YWdzW3RhZ1R5cGVdKSB7ICU+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwidGFzay1saXN0LXRhZ3MgYzAgdGFzay1zaW5nbGUtb3ZlcmZsb3dcXFwiPlxcbiAgICAgICAgPGkgY2xhc3M9XFxcInRhc2stbGlzdC1pY29uLWNlbnRlciA8JT0gdGFnQ29uZmlnLnRhZ3NbdGFnVHlwZV0uaWNvbiAlPlxcXCI+PC9pPlxcbiAgICAgICAgPCUgXy5lYWNoKHRhZ3NbdGFnVHlwZV0sIGZ1bmN0aW9uICh0LCBpKSB7ICU+XFxuICAgICAgICAgIDwlPSB0Lm5hbWUgJT48JSBpZiAoaSArIDEgPCB0YWdzW3RhZ1R5cGVdLmxlbmd0aCkgeyAlPiw8JSB9ICU+XFxuICAgICAgICA8JSB9KTsgJT5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8JSB9ICU+XFxuXFxuICAgIDwlIH0pOyAlPlxcblxcbiAgPC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJ0YXNrLWxpc3QtYm90dG9tLXBlcnNvbiBib3JkZXItdG9wXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwidGFzay1saXN0LXBlcnNvblxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwicHJvamVjdC1wZW9wbGUtZGl2IGZsb2F0LWxlZnRcXFwiIGRhdGEtdXNlcmlkPVxcXCI8JT0gaXRlbS51c2VySWQgJT5cXFwiIHN0eWxlPVxcXCJ0ZXh0LWFsaWduOiByaWdodDtcXFwiPlxcbiAgICAgICAgPGltZyBzcmM9XFxcIi9hcGkvdXNlci9waG90by88JT0gaXRlbS51c2VySWQgJT5cXFwiIGNsYXNzPVxcXCJwcm9qZWN0LXBlb3BsZVxcXCIvPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInRhc2stbGlzdC1yZXF1ZXN0Ym94XFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInRhc2stbGlzdC1yZXF1ZXN0ZWRcXFwiPnJlcXVlc3RlZCBieTwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidGFzay1saXN0LW5hbWVcXFwiPjwlLSBpdGVtLnVzZXIubmFtZSAlPjwvZGl2PlxcbiAgICAgICAgPCUgaWYgKGl0ZW0udXNlci5hZ2VuY3kpIHsgJT5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInRhc2stbGlzdC1hZ2VuY3kgdGFzay1zaW5nbGUtb3ZlcmZsb3dcXFwiPjwlPSBpdGVtLnVzZXIuYWdlbmN5LnRhZy5uYW1lICU+PC9kaXY+XFxuICAgICAgICA8JSB9ICU+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcblxcbiAgPC9kaXY+XFxuXFxuPC9saT5cIjtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciBhc3luYyA9IHJlcXVpcmUoJ2FzeW5jJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgVUlDb25maWcgPSByZXF1aXJlKCcuLi8uLi8uLi9jb25maWcvdWkuanNvbicpO1xudmFyIG1hcmtlZCA9IHJlcXVpcmUoJ21hcmtlZCcpO1xudmFyIFRhZ0NvbmZpZyA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbmZpZy90YWcnKTtcbnZhciBQcm9qZWN0TGlzdEl0ZW0gPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvcHJvamVjdF9saXN0X2l0ZW0uaHRtbCcpO1xudmFyIFRhc2tMaXN0SXRlbSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy90YXNrX2xpc3RfaXRlbS5odG1sJyk7XG52YXIgTm9MaXN0SXRlbSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy9ub19zZWFyY2hfcmVzdWx0cy5odG1sJyk7XG5cblxudmFyIEJyb3dzZUxpc3RWaWV3ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHBhZ2VTaXplID0gMjc7XG4gICAgaWYgKFVJQ29uZmlnLmJyb3dzZSAmJiBVSUNvbmZpZy5icm93c2UucGFnZVNpemUpXG4gICAgICBwYWdlU2l6ZSA9IFVJQ29uZmlnLmJyb3dzZS5wYWdlU2l6ZTtcblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5kYXRhID0ge1xuICAgICAgcGFnZVNpemU6IHBhZ2VTaXplLFxuICAgICAgcGFnZTogMVxuICAgIH1cbiAgICAkKHdpbmRvdykub24oJ3Njcm9sbCcsZnVuY3Rpb24oZSl7XG4gICAgICBzZWxmLnNjcm9sbENoZWNrKGUpO1xuICAgIH0pO1xuICB9LFxuXG4gIG9yZ2FuaXplVGFnczogZnVuY3Rpb24gKHRhZ3MpIHtcbiAgICAvLyBwdXQgdGhlIHRhZ3MgaW50byB0aGVpciB0eXBlc1xuICAgIHZhciBvdXRUYWdzID0ge307XG4gICAgZm9yICh0IGluIHRhZ3MpIHtcbiAgICAgIGlmICghKF8uaGFzKG91dFRhZ3MsIHRhZ3NbdF0udGFnLnR5cGUpKSkge1xuICAgICAgICBvdXRUYWdzW3RhZ3NbdF0udGFnLnR5cGVdID0gW107XG4gICAgICB9XG4gICAgICBvdXRUYWdzW3RhZ3NbdF0udGFnLnR5cGVdLnB1c2godGFnc1t0XS50YWcpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0VGFncztcbiAgfSxcblxuICBzY3JvbGxDaGVjazogZnVuY3Rpb24oZSkge1xuICAgIHZhciBjdXJyZW50U2Nyb2xsUG9zID0gJCh3aW5kb3cpLnNjcm9sbFRvcCgpO1xuICAgIHZhciBjdXJyZW50TWF4SGVpZ2h0ID0gJCgnI2NvbnRhaW5lcicpLmhlaWdodCgpO1xuICAgIHZhciBidWZmZXIgICAgICAgICAgID0gNjAwO1xuXG4gICAgaWYgKCAodGhpcy5vcHRpb25zLmNvbGxlY3Rpb24ubGVuZ3RoIC8gdGhpcy5kYXRhLnBhZ2UpID4gMSAmJiBNYXRoLmNlaWwodGhpcy5vcHRpb25zLmNvbGxlY3Rpb24ubGVuZ3RoIC8gdGhpcy5kYXRhLnBhZ2VTaXplKSA+PSB0aGlzLmRhdGEucGFnZSAmJiBjdXJyZW50U2Nyb2xsUG9zICsgYnVmZmVyID4gY3VycmVudE1heEhlaWdodCApe1xuICAgICAgdGhpcy5kYXRhLnBhZ2UgKz0gMTtcbiAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuXG4gICAgLy9zZXR0aW5ncyBmb3IgaW5maW5pdGUgc2Nyb2xsXG4gICAgaWYgKCBVSUNvbmZpZy5icm93c2UgJiYgVUlDb25maWcuYnJvd3NlLnVzZUluZmluaXRlU2Nyb2xsICkge1xuICAgICAgaWYgKCB0aGlzLmRhdGEucGFnZSA9PSAxICl7XG4gICAgICAgIHZhciBzdGFydCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc3RhcnQgPSAodGhpcy5kYXRhLnBhZ2UtMSkgKiB0aGlzLmRhdGEucGFnZVNpemU7XG4gICAgICB9XG4gICAgICB2YXIgbGltaXQgICAgPSBzdGFydCArIHRoaXMuZGF0YS5wYWdlU2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy9yZXNldCBwYWdlIHRvIDEgYW5kIHJldHVyblxuICAgICAgaWYgKCB0aGlzLmRhdGEucGFnZSA+IDEgKSB7XG4gICAgICAgIHRoaXMuZGF0YS5wYWdlID0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgbGltaXQgPSB0aGlzLm9wdGlvbnMuY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICB2YXIgc3RhcnQgPSAwO1xuICAgIH1cblxuICAgIGlmICggdGhpcy5vcHRpb25zLmNvbGxlY3Rpb24ubGVuZ3RoID09IDAgKXtcbiAgICAgIHZhciBzZXR0aW5ncyA9IHtcbiAgICAgICAgdWk6IFVJQ29uZmlnXG4gICAgICB9XG4gICAgICBjb21waWxlZFRlbXBsYXRlID0gXy50ZW1wbGF0ZShOb0xpc3RJdGVtKShzZXR0aW5ncyk7XG4gICAgICB0aGlzLiRlbC5hcHBlbmQoY29tcGlsZWRUZW1wbGF0ZSk7XG4gICAgfSBlbHNlIHtcblxuICAgICAgZm9yICggaSA9IHN0YXJ0OyBpIDwgbGltaXQ7IGkrKyApe1xuXG4gICAgICBpZiAoIHR5cGVvZiB0aGlzLm9wdGlvbnMuY29sbGVjdGlvbltpXSA9PSAndW5kZWZpbmVkJyApeyBicmVhazsgfVxuICAgICAgICB2YXIgaXRlbSA9IHtcbiAgICAgICAgICBpdGVtOiB0aGlzLm9wdGlvbnMuY29sbGVjdGlvbltpXSxcbiAgICAgICAgICB1c2VyOiB3aW5kb3cuY2FjaGUuY3VycmVudFVzZXIsXG4gICAgICAgICAgdGFnQ29uZmlnOiBUYWdDb25maWcsXG4gICAgICAgICAgdGFnU2hvdzogWydsb2NhdGlvbicsICdza2lsbCcsICd0b3BpYycsICd0YXNrLXRpbWUtZXN0aW1hdGUnLCAndGFzay10aW1lLXJlcXVpcmVkJ11cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNvbGxlY3Rpb25baV0udGFncykge1xuICAgICAgICAgIGl0ZW0udGFncyA9IHRoaXMub3JnYW5pemVUYWdzKHRoaXMub3B0aW9ucy5jb2xsZWN0aW9uW2ldLnRhZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW0udGFncyA9W107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb2xsZWN0aW9uW2ldLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgaXRlbS5pdGVtLmRlc2NyaXB0aW9uSHRtbCA9IG1hcmtlZCh0aGlzLm9wdGlvbnMuY29sbGVjdGlvbltpXS5kZXNjcmlwdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbXBpbGVkVGVtcGxhdGUgPSAnJztcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50YXJnZXQgPT0gJ3Byb2plY3RzJykge1xuICAgICAgICAgIGNvbXBpbGVkVGVtcGxhdGUgPSBfLnRlbXBsYXRlKFByb2plY3RMaXN0SXRlbSkoaXRlbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tcGlsZWRUZW1wbGF0ZSA9IF8udGVtcGxhdGUoVGFza0xpc3RJdGVtKShpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRlbC5hcHBlbmQoY29tcGlsZWRUZW1wbGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuJGVsLmkxOG4oKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBCcm93c2VMaXN0VmlldztcbiIsInZhciBzZWxlY3QyID0gcmVxdWlyZSgnc2VsZWN0MicpO1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vbWl4aW5zL3V0aWxpdGllcycpO1xudmFyIFVJQ29uZmlnID0gcmVxdWlyZSgnLi4vLi4vLi4vY29uZmlnL3VpLmpzb24nKTtcbnZhciBQb3BvdmVycyA9IHJlcXVpcmUoJy4uLy4uLy4uL21peGlucy9wb3BvdmVycycpO1xudmFyIFRhZ0NvbmZpZyA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbmZpZy90YWcnKTtcbnZhciBCcm93c2VMaXN0VmlldyA9IHJlcXVpcmUoJy4vYnJvd3NlX2xpc3RfdmlldycpO1xudmFyIEJyb3dzZU1haW5UZW1wbGF0ZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy9icm93c2VfbWFpbl92aWV3X3RlbXBsYXRlLmh0bWwnKTtcbnZhciBCcm93c2VTZWFyY2hUYWcgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvYnJvd3NlX3NlYXJjaF90YWcuaHRtbCcpO1xuXG5cbnZhciBwb3BvdmVycyA9IG5ldyBQb3BvdmVycygpO1xuXG52YXIgQnJvd3NlTWFpblZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG5cbiAgZXZlbnRzOiB7XG4gICAgXCJzdWJtaXQgI3NlYXJjaC1mb3JtXCIgICAgICAgICAgICAgOiBcInNlYXJjaFwiLFxuICAgIFwiY2xpY2sgLnNlYXJjaC10YWctcmVtb3ZlXCIgICAgICAgIDogXCJzZWFyY2hUYWdSZW1vdmVcIixcbiAgICBcImNsaWNrIC5zZWFyY2gtY2xlYXJcIiAgICAgICAgICAgICA6IFwic2VhcmNoQ2xlYXJcIixcbiAgICBcImNoYW5nZSAuc3RhdGVGaWx0ZXJcIiAgICAgICAgICAgICA6IFwic2VhcmNoVGFnUmVtb3ZlXCIsXG4gICAgXCJtb3VzZWVudGVyIC5wcm9qZWN0LXBlb3BsZS1kaXZcIiAgOiBwb3BvdmVycy5wb3BvdmVyUGVvcGxlT24sXG4gICAgXCJjbGljayAgICAgIC5wcm9qZWN0LXBlb3BsZS1kaXZcIiAgOiBwb3BvdmVycy5wb3BvdmVyQ2xpY2ssXG4gICAgXCJrZXl1cCAuc2VsZWN0Mi1jb250YWluZXJcIiAgICAgICAgOiBcInN1Ym1pdE9uRW50ZXJcIlxuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIHRhcmdldDogdGhpcy5vcHRpb25zLnRhcmdldCxcbiAgICAgIHVzZXI6IHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlcixcbiAgICAgIHVpOiBVSUNvbmZpZ1xuICAgIH07XG4gICAgdGhpcy5jb21waWxlZFRlbXBsYXRlID0gXy50ZW1wbGF0ZShCcm93c2VNYWluVGVtcGxhdGUpKG9wdGlvbnMpXG4gICAgdGhpcy4kZWwuaHRtbCh0aGlzLmNvbXBpbGVkVGVtcGxhdGUpO1xuICAgIHRoaXMuJGVsLmkxOG4oKTtcblxuICAgIHRoaXMuaW5pdGlhbGl6ZVNlYXJjaCgpO1xuXG4gICAgLy8gQWxsb3cgY2hhaW5pbmcuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgZm9ybWF0OiBmdW5jdGlvbiAoc2VsZiwgb2JqZWN0LCBjb250YWluZXIsIHF1ZXJ5KSB7XG4gICAgdmFyIG5hbWUgPSBvYmplY3QubmFtZSB8fCBvYmplY3QudGl0bGU7XG4gICAgdmFyIGljb24gPSB0aGlzLnRhZ0ljb25bb2JqZWN0LnR5cGVdO1xuICAgIGlmIChvYmplY3QudGFyZ2V0ID09ICdwcm9qZWN0Jykge1xuICAgICAgaWNvbiA9ICdmYSBmYS1mb2xkZXItbyc7XG4gICAgfSBlbHNlIGlmIChvYmplY3QudGFyZ2V0ID09ICd0YXNrJykge1xuICAgICAgaWNvbiA9ICdmYSBmYS10YWcnO1xuICAgIH1cbiAgICByZXR1cm4gJzxpIGNsYXNzPVwiJyArIGljb24gKyAnXCI+PC9pPiA8c3BhbiBjbGFzcz1cImJveC1pY29uLXRleHRcIj4nICsgbmFtZSArICc8L3NwYW4+JztcbiAgfSxcblxuICBpbml0aWFsaXplU2VhcmNoOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5zZWFyY2hUZXJtcyA9IFtdO1xuICAgIHRoaXMudGFncyA9IFtdO1xuXG4gICAgLy8gZmlndXJlIG91dCB3aGljaCB0YWdzIGFwcGx5XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBUYWdDb25maWdbdGhpcy5vcHRpb25zLnRhcmdldF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFRhZ0NvbmZpZy50YWdzW1RhZ0NvbmZpZ1t0aGlzLm9wdGlvbnMudGFyZ2V0XVtpXV0pO1xuICAgIH1cblxuICAgIC8vIGV4dHJhY3QgdGFnIGljb25zIGFuZCBjbGFzc2VzXG4gICAgdGhpcy50YWdJY29uID0ge307XG4gICAgdGhpcy50YWdDbGFzcyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50YWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnRhZ0ljb25bdGhpcy50YWdzW2ldLnR5cGVdID0gdGhpcy50YWdzW2ldLmljb247XG4gICAgICB0aGlzLnRhZ0NsYXNzW3RoaXMudGFnc1tpXS50eXBlXSA9IHRoaXMudGFnc1tpXVsnY2xhc3MnXTtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0UmVzdWx0ID0gZnVuY3Rpb24gKG9iamVjdCwgY29udGFpbmVyLCBxdWVyeSkge1xuICAgICAgcmV0dXJuIHNlbGYuZm9ybWF0KHNlbGYsIG9iamVjdCwgY29udGFpbmVyLCBxdWVyeSk7XG4gICAgfTtcblxuICAgIC8vIEluaXRpYWxpemUgU2VsZWN0MlxuICAgICQoXCIjc2VhcmNoXCIpLnNlbGVjdDIoe1xuICAgICAgcGxhY2Vob2xkZXI6ICdJXFwnbSBsb29raW5nIGZvci4uLicsXG4gICAgICBtdWx0aXBsZTogdHJ1ZSxcbiAgICAgIGZvcm1hdFJlc3VsdDogZm9ybWF0UmVzdWx0LFxuICAgICAgZm9ybWF0U2VsZWN0aW9uOiBmdW5jdGlvbihvYmplY3QsY29udGFpbmVyLHF1ZXJ5KSB7XG4gICAgICAgICAgLy9udWxsIG9iamVjdC50YXJnZXQgdG8gcmVtb3ZlIHRoZSB0YXNrIC8gcHJvamVjdCBpY29ucyB0aGF0IGdldCByZWFkZGVkIHdoZW4gdGVybXMgZ29cbiAgICAgICAgICAvLyAgICAgdG8gdGhlIHNlYXJjaCBib3ggb24gdGhlIHJpZ2h0XG4gICAgICAgICAgb2JqZWN0LnRhcmdldCA9IG51bGw7XG4gICAgICAgICAgb2JqZWN0LnR5cGUgICA9IG9iamVjdC5uYW1lIHx8IG9iamVjdC50aXRsZTtcbiAgICAgICAgICBvYmplY3QuaWQgICAgID0gb2JqZWN0Lm5hbWUgfHwgb2JqZWN0LnRpdGxlO1xuICAgICAgICAgIG9iamVjdC52YWx1ZSAgPSBvYmplY3QubmFtZSB8fCBvYmplY3QudGl0bGU7XG4gICAgICAgICAgb2JqZWN0LnVubWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdC5uYW1lIHx8IG9iamVjdC50aXRsZTtcbiAgICAgIH0sXG4gICAgICBjcmVhdGVTZWFyY2hDaG9pY2U6IGZ1bmN0aW9uICh0ZXJtKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdW5tYXRjaGVkOiB0cnVlLGlkOiB0ZXJtLCB2YWx1ZTogdGVybSwgbmFtZTogXCI8Yj5cIit0ZXJtK1wiPC9iPiA8aT5jbGljayB0byB0ZXh0IHNlYXJjaCBmb3IgdGhpcyB2YWx1ZS48L2k+XCIgfTtcbiAgICAgIH0sXG4gICAgICBhamF4OiB7XG4gICAgICAgIHVybDogJy9hcGkvYWMvc2VhcmNoLycgKyBzZWxmLm9wdGlvbnMudGFyZ2V0LFxuICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICBkYXRhOiBmdW5jdGlvbiAodGVybSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBUYWdDb25maWdbc2VsZi5vcHRpb25zLnRhcmdldF0uam9pbigpLFxuICAgICAgICAgICAgcTogdGVybVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHJlc3VsdHM6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIHsgcmVzdWx0czogZGF0YSB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkub24oXCJzZWxlY3QyLXNlbGVjdGluZ1wiLCBmdW5jdGlvbiAoZSl7XG4gICAgICAgIGlmICggZS5jaG9pY2UuaGFzT3duUHJvcGVydHkoXCJ1bm1hdGNoZWRcIikgJiYgZS5jaG9pY2UudW5tYXRjaGVkICl7XG4gICAgICAgICAgLy9yZW1vdmUgdGhlIGhpbnQgYmVmb3JlIGFkZGluZyBpdCB0byB0aGUgbGlzdFxuICAgICAgICAgIGUuY2hvaWNlLm5hbWUgPSBlLnZhbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH0sXG5cbiAgc3VibWl0T25FbnRlcjogZnVuY3Rpb24gKGUpIHtcbiAgICBpZihlLmtleUNvZGUgPT09IDEzKSB7XG4gICAgICB0aGlzLnNlYXJjaChlKTtcbiAgICB9XG4gIH0sXG5cbiAgc2VhcmNoOiBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIC8vIGdldCB2YWx1ZXMgZnJvbSBzZWxlY3QyXG4gICAgdmFyIGRhdGEgPSAkKFwiI3NlYXJjaFwiKS5zZWxlY3QyKFwiZGF0YVwiKTtcbiAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAkKFwiI3NlYXJjaC1ub25lXCIpLmhpZGUoKTtcbiAgICAgICQoXCIuc2VhcmNoLWNsZWFyXCIpLnNob3coKTtcbiAgICB9XG4gICAgXy5lYWNoKGRhdGEsIGZ1bmN0aW9uIChkKSB7XG4gICAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICAgIC8vIGNoZWNrIGlmIHRoaXMgc2VhcmNoIHRlcm0gYWxyZWFkeSBpcyBjaG9zZW5cbiAgICAgIGZvciAodmFyIGkgaW4gc2VsZi5zZWFyY2hUZXJtcykge1xuICAgICAgICBpZiAoc2VsZi5zZWFyY2hUZXJtc1tpXS5pZCA9PSBkLmlkKSB7XG4gICAgICAgICAgaWYgKHNlbGYuc2VhcmNoVGVybXNbaV0udGl0bGUgJiYgKHNlbGYuc2VhcmNoVGVybXNbaV0udGl0bGUgPT0gZC50aXRsZSkpIHtcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoc2VsZi5zZWFyY2hUZXJtc1tpXS5uYW1lICYmIChzZWxmLnNlYXJjaFRlcm1zW2ldLm5hbWUgPT0gZC5uYW1lKSkge1xuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gcmV0dXJuIGlmIHRoZSBzZWFyY2ggdGVybSBpcyBmb3VuZFxuICAgICAgaWYgKGZvdW5kKSByZXR1cm47XG4gICAgICAvLyBhZGQgaXQgdG8gb3VyIGxpc3Qgb2Ygc2VhcmNoIHRlcm1zXG4gICAgICBzZWxmLnNlYXJjaFRlcm1zLnB1c2goZCk7XG4gICAgICAvLyByZW5kZXIgdGhlIHNlYXJjaCB0ZXJtIGluIHRoZSBsaXN0XG4gICAgICB2YXIgdGVtcGxEYXRhID0ge1xuICAgICAgICBkYXRhOiBkLFxuICAgICAgICBmb3JtYXQ6IHNlbGYuZm9ybWF0KHNlbGYsIGQpXG4gICAgICB9O1xuICAgICAgdmFyIHRlbXBsID0gXy50ZW1wbGF0ZShCcm93c2VTZWFyY2hUYWcpKHRlbXBsRGF0YSk7XG4gICAgICBpZiAoZC50YXJnZXQgPT0gJ3RhZ2VudGl0eScpIHtcbiAgICAgICAgJChcIiNzZWFyY2gtdGFnc1wiKS5hcHBlbmQodGVtcGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJChcIiNzZWFyY2gtcHJvanNcIikuYXBwZW5kKHRlbXBsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAkKFwiI3NlYXJjaFwiKS5zZWxlY3QyKFwiZGF0YVwiLFwiXCIpO1xuICAgIHNlbGYuc2VhcmNoRXhlYyhzZWxmLnNlYXJjaFRlcm1zKTtcbiAgfSxcblxuICByZW5kZXJMaXN0OiBmdW5jdGlvbiAoY29sbGVjdGlvbikge1xuICAgIC8vIGNyZWF0ZSBhIG5ldyB2aWV3IGZvciB0aGUgcmV0dXJuZWQgZGF0YVxuICAgIGlmICh0aGlzLmJyb3dzZUxpc3RWaWV3KSB7IHRoaXMuYnJvd3NlTGlzdFZpZXcuY2xlYW51cCgpOyB9XG5cbiAgICB2YXIgZmlsdGVyZWRDb2xsZWN0aW9uID0gdGhpcy5hcHBseVN0YXRlRmlsdGVycyhjb2xsZWN0aW9uKTtcblxuICAgIHRoaXMuYnJvd3NlTGlzdFZpZXcgPSBuZXcgQnJvd3NlTGlzdFZpZXcoe1xuICAgICAgZWw6ICcjYnJvd3NlLWxpc3QnLFxuICAgICAgdGFyZ2V0OiB0aGlzLm9wdGlvbnMudGFyZ2V0LFxuICAgICAgY29sbGVjdGlvbjogZmlsdGVyZWRDb2xsZWN0aW9uLFxuICAgIH0pO1xuICAgIC8vIFNob3cgZHJhZnQgZmlsdGVyXG4gICAgdmFyIGRyYWZ0ID0gXyhjb2xsZWN0aW9uKS5jaGFpbigpXG4gICAgICAgICAgLnBsdWNrKCdzdGF0ZScpXG4gICAgICAgICAgLmluZGV4T2YoJ2RyYWZ0JykudmFsdWUoKSA+PSAwO1xuICAgICQoXCIuZHJhZnQtZmlsdGVyXCIpLnRvZ2dsZUNsYXNzKCdoaWRkZW4nLCAhZHJhZnQpO1xuICAgICQoXCIjYnJvd3NlLXNlYXJjaC1zcGlubmVyXCIpLmhpZGUoKTtcbiAgICAkKFwiI2Jyb3dzZS1saXN0XCIpLnNob3coKTtcbiAgICB0aGlzLmJyb3dzZUxpc3RWaWV3LnJlbmRlcigpO1xuICAgIHBvcG92ZXJzLnBvcG92ZXJQZW9wbGVJbml0KFwiLnByb2plY3QtcGVvcGxlLWRpdlwiKTtcbiAgfSxcblxuICBzZWFyY2hFeGVjOiBmdW5jdGlvbiAodGVybXMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoIXRlcm1zIHx8ICh0ZXJtcy5sZW5ndGggPT0gMCkpIHtcbiAgICAgIC8vIHJlLXJlbmRlciB0aGUgY29sbGVjdGlvblxuICAgICAgc2VsZi5yZW5kZXJMaXN0KHRoaXMub3B0aW9ucy5jb2xsZWN0aW9uLnRvSlNPTigpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgYSBzZWFyY2ggb2JqZWN0XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBpdGVtczogW10sXG4gICAgICB0YWdzOiBbXSxcbiAgICAgIGZyZWVUZXh0OiBbXSxcbiAgICAgIHRhcmdldDogc2VsZi5vcHRpb25zLnRhcmdldFxuICAgIH07XG4gICAgXy5lYWNoKHRlcm1zLCBmdW5jdGlvbiAodCkge1xuICAgICAgaWYgKCB0LnVubWF0Y2hlZCApIHtcbiAgICAgICAgZGF0YS5mcmVlVGV4dC5wdXNoKHQudmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YS5pdGVtcy5wdXNoKHQuaWQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgICQuYWpheCh7XG4gICAgICB1cmw6ICcvYXBpL3NlYXJjaCcsXG4gICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICBkYXRhOiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgfSkuZG9uZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgLy8gcmVuZGVyIHRoZSBzZWFyY2ggcmVzdWx0c1xuICAgICAgc2VsZi5yZW5kZXJMaXN0KGRhdGEpO1xuICAgIH0pO1xuICB9LFxuXG4gIGFwcGx5U3RhdGVGaWx0ZXJzOiBmdW5jdGlvbiAoZGF0YSkge1xuXG4gICAgaWYgKCAhXy5pc09iamVjdChkYXRhKSB8fCAhJChcIiNzdGF0ZUZpbHRlcnNcIikubGVuZ3RoICl7IHJldHVybiBkYXRhOyB9XG4gICAgdmFyIGtlZXBlcnMgPSBbXTtcbiAgICAvL2dldCBjaGVjayBzdGF0ZUZpbHRlciBpbnB1dHNcbiAgICB2YXIgaW5wdXRzID0gJChcIi5zdGF0ZUZpbHRlcjpjaGVja2VkXCIpO1xuXG4gICAgXy5lYWNoKGRhdGEsZnVuY3Rpb24oaXRlbSl7XG4gICAgICBfLmVhY2goaW5wdXRzLGZ1bmN0aW9uKHRlc3Qpe1xuICAgICAgICAgaWYgKCBpdGVtLnN0YXRlID09IHRlc3QudmFsdWUgKXtcbiAgICAgICAgICAga2VlcGVycy5wdXNoKGl0ZW0pO1xuICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ga2VlcGVycztcbiAgfSxcblxuICBzZWFyY2hUYWdSZW1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICggJChlLmN1cnJlbnRUYXJnZXQpLmhhc0NsYXNzKFwic3RhdGVGaWx0ZXJcIikgKXtcbiAgICAgIGlmICggJChcIiNzZWFyY2gtdGFnc1wiKS5sZW5ndGggPiAwICkge1xuICAgICAgICB2YXIgcGFyZW50ID0gJChcIiNzZWFyY2gtdGFnc1wiKTtcbiAgICAgICAgdmFyIGlkID0gXCJzZWFyY2gtdGFnc1wiO1xuICAgICAgICB2YXIgcHJvamVjdCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFyZW50ID0gJChlLmN1cnJlbnRUYXJnZXQpLnBhcmVudHMoJ2xpJylbMF07XG4gICAgICB2YXIgaWQgPSAkKHBhcmVudCkuZGF0YSgnaWQnKTtcbiAgICAgIHZhciB0eXBlID0gJCgkKGUuY3VycmVudFRhcmdldCkucGFyZW50cygndWwnKVswXSkuYXR0cignaWQnKTtcbiAgICAgIHZhciBwcm9qZWN0ID0gZmFsc2U7XG5cbiAgICAgIGlmICh0eXBlID09ICdzZWFyY2gtcHJvanMnKSB7XG4gICAgICAgIHByb2plY3QgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSBpbiBzZWxmLnNlYXJjaFRlcm1zKSB7XG4gICAgICBpZiAoc2VsZi5zZWFyY2hUZXJtc1tpXS5pZCA9PSBpZCkge1xuICAgICAgICBpZiAocHJvamVjdCAmJiBzZWxmLnNlYXJjaFRlcm1zW2ldLnRpdGxlKSB7XG4gICAgICAgICAgc2VsZi5zZWFyY2hUZXJtcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZi5zZWFyY2hUZXJtc1tpXS5uYW1lKSB7XG4gICAgICAgICAgc2VsZi5zZWFyY2hUZXJtcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoICEkKGUuY3VycmVudFRhcmdldCkuaGFzQ2xhc3MoXCJzdGF0ZUZpbHRlclwiKSApe1xuICAgICAgcGFyZW50LnJlbW92ZSgpO1xuICAgIH1cbiAgICBpZiAoc2VsZi5zZWFyY2hUZXJtcy5sZW5ndGggPT0gMCkge1xuICAgICAgJChcIiNzZWFyY2gtbm9uZVwiKS5zaG93KCk7XG4gICAgICAkKFwiLnNlYXJjaC1jbGVhclwiKS5oaWRlKCk7XG4gICAgfVxuICAgIHNlbGYuc2VhcmNoRXhlYyhzZWxmLnNlYXJjaFRlcm1zKTtcbiAgfSxcblxuICBzZWFyY2hDbGVhcjogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuc2VhcmNoVGVybXMgPSBbXTtcbiAgICAkKFwiI3NlYXJjaC1wcm9qc1wiKS5jaGlsZHJlbigpLnJlbW92ZSgpO1xuICAgICQoXCIjc2VhcmNoLXRhZ3NcIikuY2hpbGRyZW4oKS5yZW1vdmUoKTtcbiAgICAkKFwiI3NlYXJjaC1ub25lXCIpLnNob3coKTtcbiAgICAkKFwiLnNlYXJjaC1jbGVhclwiKS5oaWRlKCk7XG4gICAgdGhpcy5zZWFyY2hFeGVjKHNlbGYuc2VhcmNoVGVybXMpO1xuICB9LFxuXG4gIGNsZWFudXA6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmJyb3dzZUxpc3RWaWV3KSB7IHRoaXMuYnJvd3NlTGlzdFZpZXcuY2xlYW51cCgpOyB9XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBCcm93c2VNYWluVmlldztcbiIsIlxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vbWl4aW5zL3V0aWxpdGllcycpO1xudmFyIFRpbWVBZ28gPSByZXF1aXJlKCcuLi8uLi8uLi8uLi8uLi92ZW5kb3IvanF1ZXJ5LnRpbWVhZ28nKTtcbnZhciBQb3BvdmVycyA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL21peGlucy9wb3BvdmVycycpO1xudmFyIENvbW1lbnRDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vZW50aXRpZXMvY29tbWVudHMvY29tbWVudF9jb2xsZWN0aW9uJyk7XG52YXIgQ29tbWVudEZvcm1WaWV3ID0gcmVxdWlyZSgnLi4vLi4vbmV3L3ZpZXdzL2NvbW1lbnRfZm9ybV92aWV3Jyk7XG52YXIgQ29tbWVudEl0ZW1WaWV3ID0gcmVxdWlyZSgnLi4vdmlld3MvY29tbWVudF9pdGVtX3ZpZXcnKTtcbnZhciBDb21tZW50V3JhcHBlciA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy9jb21tZW50X3dyYXBwZXJfdGVtcGxhdGUuaHRtbCcpO1xuXG5cbnZhciBwb3BvdmVycyA9IG5ldyBQb3BvdmVycygpO1xuXG5Db21tZW50ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuXG4gIGVsOiBcIi5jb21tZW50LWxpc3Qtd3JhcHBlclwiLFxuXG4gIGV2ZW50czoge1xuICAgIFwiY2xpY2sgLm5ldy10b3BpY1wiICAgICAgICAgICAgICAgICAgOiBcIm5ld1RvcGljXCIsXG4gICAgXCJjbGljayAuY29tbWVudC1leHBhbmRcIiAgICAgICAgICAgICA6IFwidG9waWNFeHBhbmRcIixcbiAgICBcImNsaWNrIC5jb21tZW50LWNvbnRyYWN0XCIgICAgICAgICAgIDogXCJ0b3BpY0NvbnRyYWN0XCIsXG4gICAgXCJtb3VzZWVudGVyIC5jb21tZW50LXVzZXItbGlua1wiICAgICA6IHBvcG92ZXJzLnBvcG92ZXJQZW9wbGVPbixcbiAgICBcImNsaWNrIC5jb21tZW50LXVzZXItbGlua1wiICAgICAgICAgIDogcG9wb3ZlcnMucG9wb3ZlckNsaWNrLFxuICAgIFwiY2xpY2sgLmxpbmstYmFja2JvbmVcIiAgICAgICAgICAgICAgOiBsaW5rQmFja2JvbmUsXG4gICAgXCJjbGljayBhW2hyZWY9JyNyZXBseS10by1jb21tZW50J11cIiA6IFwicmVwbHlcIlxuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICB0aGlzLmluaXRpYWxpemVSZW5kZXIoKTtcbiAgICB0aGlzLmluaXRpYWxpemVDb21tZW50Q29sbGVjdGlvbigpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZUxpc3RlbmVycygpO1xuXG4gICAgLy8gUG9wdWxhdGluZyB0aGUgRE9NIGFmdGVyIGEgY29tbWVudCB3YXMgY3JlYXRlZC5cbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29tbWVudENvbGxlY3Rpb24sIFwiY29tbWVudDpzYXZlOnN1Y2Nlc3NcIiwgZnVuY3Rpb24gKG1vZGVsLCBtb2RlbEpzb24sIGN1cnJlbnRUYXJnZXQpIHtcbiAgICAgIGlmIChtb2RlbEpzb24udG9waWMpIHtcbiAgICAgICAgLy8gY2xlYW51cCB0aGUgdG9waWMgZm9ybVxuICAgICAgICBpZiAodGhpcy50b3BpY0Zvcm0pIHRoaXMudG9waWNGb3JtLmNsZWFudXAoKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuYWRkTmV3Q29tbWVudFRvRG9tKG1vZGVsSnNvbiwgY3VycmVudFRhcmdldCk7XG4gICAgfSk7XG5cbiAgfSxcblxuICBpbml0aWFsaXplUmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBfLnRlbXBsYXRlKENvbW1lbnRXcmFwcGVyKSh7IHVzZXI6IHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlciB9KTtcbiAgICB0aGlzLiRlbC5odG1sKHRlbXBsYXRlKTtcbiAgfSxcblxuICBpbml0aWFsaXplQ29tbWVudENvbGxlY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5jb21tZW50Q29sbGVjdGlvbikgeyB0aGlzLnJlbmRlclZpZXcoKSB9XG4gICAgZWxzZSB7IHRoaXMuY29tbWVudENvbGxlY3Rpb24gPSBuZXcgQ29tbWVudENvbGxlY3Rpb24oKTsgfVxuXG4gICAgdGhpcy5jb21tZW50Q29sbGVjdGlvbi5mZXRjaCh7XG4gICAgICB1cmw6ICcvYXBpL2NvbW1lbnQvZmluZEFsbEJ5JyArIHRoaXMub3B0aW9ucy50YXJnZXQgKyAnSWQvJyArIHRoaXMub3B0aW9ucy5pZCxcbiAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XG4gICAgICAgIHNlbGYuY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gICAgICAgIHNlbGYucmVuZGVyVmlldyhjb2xsZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBpbml0aWFsaXplTGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29tbWVudENvbGxlY3Rpb24sIFwiY29tbWVudDp0b3BpYzpuZXdcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB0b3BpYzogdHJ1ZVxuICAgICAgfTtcbiAgICAgIGRhdGFbc2VsZi5vcHRpb25zLnRhcmdldCArICdJZCddID0gc2VsZi5vcHRpb25zLmlkO1xuXG4gICAgICAvLyBUT0RPOiBETTogRml4IHRoaXMgdG8gYWRkIHRvIHRoZSBjb2xsZWN0aW9uIGFwcHJvcHJpYXRlbHksXG4gICAgICAvLyBhbmQgZmV0Y2gvcmUtcmVuZGVyIGFzIG5lZWRlZC4gIFRoaXMgaXMgYSBoYWNrIHRvIGdldCBpdCB0byB3b3JrXG4gICAgICAkLmFqYXgoe1xuICAgICAgICB1cmw6ICcvYXBpL2NvbW1lbnQnLFxuICAgICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIHByb2Nlc3NEYXRhOiBmYWxzZSxcbiAgICAgICAgZGF0YTogSlNPTi5zdHJpbmdpZnkoZGF0YSlcbiAgICAgIH0pLmRvbmUoZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBzZWxmLmNvbW1lbnRDb2xsZWN0aW9uLmZldGNoKHtcbiAgICAgICAgICB1cmw6ICcvYXBpL2NvbW1lbnQvZmluZEFsbEJ5JyArIHNlbGYub3B0aW9ucy50YXJnZXQgKyAnSWQvJyArIHNlbGYub3B0aW9ucy5pZCxcbiAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoY29sbGVjdGlvbikge1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSxcblxuICByZW5kZXJWaWV3OiBmdW5jdGlvbiAoY29sbGVjdGlvbikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLnBhcmVudE1hcCA9IHt9O1xuICAgIHRoaXMudG9waWNzID0gW107XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBjb21tZW50czogY29sbGVjdGlvbi50b0pTT04oKVswXS5jb21tZW50c1xuICAgIH07XG5cbiAgICAvLyBjb21wdXRlIHRoZSBkZXB0aCBvZiBlYWNoIGNvbW1lbnQgdG8gdXNlIGFzIG1ldGFkYXRhIHdoZW4gcmVuZGVyaW5nXG4gICAgLy8gaW4gdGhlIHByb2Nlc3MsIGNyZWF0ZSBhIG1hcCBvZiB0aGUgaWRzIG9mIGVhY2ggY29tbWVudCdzIGNoaWxkcmVuXG4gICAgdmFyIGRlcHRoID0ge307XG4gICAgaWYgKCFkYXRhLmNvbW1lbnRzKSB7XG4gICAgICBkYXRhLmNvbW1lbnRzID0gW107XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5jb21tZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKGRhdGEuY29tbWVudHNbaV0udG9waWMgPT09IHRydWUpIHtcbiAgICAgICAgZGVwdGhbZGF0YS5jb21tZW50c1tpXS5pZF0gPSAwO1xuICAgICAgICBkYXRhLmNvbW1lbnRzW2ldWydkZXB0aCddID0gZGVwdGhbZGF0YS5jb21tZW50c1tpXS5pZF07XG4gICAgICAgIHRoaXMudG9waWNzLnB1c2goZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZXB0aFtkYXRhLmNvbW1lbnRzW2ldLmlkXSA9IGRlcHRoW2RhdGEuY29tbWVudHNbaV0ucGFyZW50SWRdICsgMTtcbiAgICAgICAgZGF0YS5jb21tZW50c1tpXVsnZGVwdGgnXSA9IGRlcHRoW2RhdGEuY29tbWVudHNbaV0uaWRdO1xuICAgICAgICAvLyBhdWdtZW50IHRoZSBwYXJlbnRNYXAgd2l0aCB0aGlzIGNvbW1lbnRcbiAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQodGhpcy5wYXJlbnRNYXBbZGF0YS5jb21tZW50c1tpXS5wYXJlbnRJZF0pKSB7XG4gICAgICAgICAgdGhpcy5wYXJlbnRNYXBbZGF0YS5jb21tZW50c1tpXS5wYXJlbnRJZF0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcmVudE1hcFtkYXRhLmNvbW1lbnRzW2ldLnBhcmVudElkXS5wdXNoKGRhdGEuY29tbWVudHNbaV0uaWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGhpZGUgdGhlIGxvYWRpbmcgc3Bpbm5lclxuICAgIHRoaXMuJCgnLmNvbW1lbnQtc3Bpbm5lcicpLmhpZGUoKTtcblxuICAgIHRoaXMuY29tbWVudFZpZXdzID0gW107XG4gICAgdGhpcy5jb21tZW50Rm9ybXMgPSBbXTtcbiAgICBpZiAoZGF0YS5jb21tZW50cy5sZW5ndGggPT0gMCkge1xuICAgICAgdGhpcy4kKCcjY29tbWVudC1lbXB0eScpLnNob3coKTtcbiAgICB9XG4gICAgXy5lYWNoKGRhdGEuY29tbWVudHMsIGZ1bmN0aW9uIChjb21tZW50LCBpKSB7XG4gICAgICBzZWxmLnJlbmRlckNvbW1lbnQoc2VsZiwgY29tbWVudCwgY29sbGVjdGlvbiwgc2VsZi5wYXJlbnRNYXApO1xuICAgIH0pO1xuXG4gICAgdGhpcy5pbml0aWFsaXplQ29tbWVudFVJQWRkaXRpb25zKCk7XG4gIH0sXG5cbiAgcmVuZGVyQ29tbWVudDogZnVuY3Rpb24gKHNlbGYsIGNvbW1lbnQsIGNvbGxlY3Rpb24sIG1hcCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAvLyBjb3VudCB0aGUgbnVtYmVyIG9mIHJlcGxpZXMgaW4gYSB0b3BpYywgcmVjdXJzaXZlbHlcbiAgICB2YXIgY291bnRDaGlsZHJlbiA9IGZ1bmN0aW9uIChtYXAsIGNvbW1lbnQpIHtcbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKG1hcFtjb21tZW50XSkpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICB2YXIgY291bnQgPSBtYXBbY29tbWVudF0ubGVuZ3RoO1xuICAgICAgXy5lYWNoKG1hcFtjb21tZW50XSwgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgY291bnQgKz0gY291bnRDaGlsZHJlbihtYXAsIGMpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gY291bnQ7XG4gICAgfTtcbiAgICAvLyBpZiB0aGlzIGlzIGEgdG9waWMsIGNvdW50IHRoZSBjaGlsZHJlbiBmb3IgcmVuZGVyaW5nXG4gICAgaWYgKGNvbW1lbnQudG9waWMgPT09IHRydWUpIHtcbiAgICAgIGNvbW1lbnQubnVtQ2hpbGRyZW4gPSBjb3VudENoaWxkcmVuKG1hcCwgY29tbWVudC5pZCk7XG4gICAgfVxuICAgIC8vIFJlbmRlciB0aGUgdG9waWMgdmlldyBhbmQgdGhlbiBpbiB0aGF0IHZpZXcgc3BldyBvdXQgYWxsIG9mIGl0cyBjaGlsZHJlbi5cbiAgICB2YXIgY29tbWVudElWID0gbmV3IENvbW1lbnRJdGVtVmlldyh7XG4gICAgICBlbDogXCIjY29tbWVudC1saXN0LVwiICsgKGNvbW1lbnQudG9waWMgPyAnbnVsbCcgOiBjb21tZW50LnBhcmVudElkKSxcbiAgICAgIG1vZGVsOiBjb21tZW50LFxuICAgICAgdGFyZ2V0OiB0aGlzLm9wdGlvbnMudGFyZ2V0LFxuICAgICAgcHJvamVjdElkOiBjb21tZW50LnByb2plY3RJZCxcbiAgICAgIHRhc2tJZDogY29tbWVudC50YXNrSWQsXG4gICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uXG4gICAgfSkucmVuZGVyKCk7XG4gICAgc2VsZi5jb21tZW50Vmlld3MucHVzaChjb21tZW50SVYpO1xuICAgIGlmIChjb21tZW50LmRlcHRoIDw9IDEpIHtcbiAgICAgIC8vIFBsYWNlIHRoZSBjb21tZW50Rm9ybSBhdCB0aGUgYm90dG9tIG9mIHRoZSBsaXN0IG9mIGNvbW1lbnRzIGZvciB0aGF0IHRvcGljLlxuICAgICAgdmFyIGNvbW1lbnRGViA9IG5ldyBDb21tZW50Rm9ybVZpZXcoe1xuICAgICAgICBlbDogJyNjb21tZW50LWZvcm0tJyArIGNvbW1lbnQuaWQsXG4gICAgICAgIHRhcmdldDogdGhpcy5vcHRpb25zLnRhcmdldCxcbiAgICAgICAgcHJvamVjdElkOiBjb21tZW50LnByb2plY3RJZCxcbiAgICAgICAgdGFza0lkOiBjb21tZW50LnRhc2tJZCxcbiAgICAgICAgcGFyZW50SWQ6IGNvbW1lbnQuaWQsXG4gICAgICAgIGNvbGxlY3Rpb246IGNvbGxlY3Rpb24sXG4gICAgICAgIGRlcHRoOiBjb21tZW50WydkZXB0aCddXG4gICAgICB9KTtcbiAgICAgIHNlbGYuY29tbWVudEZvcm1zLnB1c2goY29tbWVudEZWKTtcbiAgICB9XG4gICAgcmV0dXJuICQoXCIjY29tbWVudC1saXN0LVwiICsgKGNvbW1lbnQudG9waWMgPyAnbnVsbCcgOiBjb21tZW50LnBhcmVudElkKSk7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZUNvbW1lbnRVSUFkZGl0aW9uczogZnVuY3Rpb24gKCRjb21tZW50KSB7XG4gICAgaWYgKF8uaXNVbmRlZmluZWQoJGNvbW1lbnQpKSB7XG4gICAgICB0aGlzLiQoXCJ0aW1lLnRpbWVhZ29cIikudGltZWFnbygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkY29tbWVudC5maW5kKFwidGltZS50aW1lYWdvXCIpLnRpbWVhZ28oKTtcbiAgICB9XG4gICAgcG9wb3ZlcnMucG9wb3ZlclBlb3BsZUluaXQoXCIuY29tbWVudC11c2VyLWxpbmtcIik7XG4gICAgcG9wb3ZlcnMucG9wb3ZlclBlb3BsZUluaXQoXCIucHJvamVjdC1wZW9wbGUtZGl2XCIpO1xuICB9LFxuXG4gIHRvcGljRXhwYW5kOiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgLy8gdG9nZ2xlIGFsbCB0aGUgc3VibGlzdHNcbiAgICB2YXIgdGFyZ2V0ID0gJCgkKGUuY3VycmVudFRhcmdldCkucGFyZW50cygnbGknKVswXSlcbiAgICAkKGUuY3VycmVudFRhcmdldCkuaGlkZSgpO1xuICAgICQodGFyZ2V0LmZpbmQoJy5jb21tZW50LWNvbnRyYWN0JylbMF0pLnNob3coKTtcbiAgICAkKHRhcmdldC5jaGlsZHJlbignLmNvbW1lbnQtc3VibGlzdC13cmFwcGVyJylbMF0pLnNsaWRlVG9nZ2xlKCk7XG4gIH0sXG5cbiAgdG9waWNDb250cmFjdDogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIC8vIHRvZ2dsZSBhbGwgdGhlIHN1Ymxpc3RzXG4gICAgdmFyIHRhcmdldCA9ICQoJChlLmN1cnJlbnRUYXJnZXQpLnBhcmVudHMoJ2xpJylbMF0pXG4gICAgJChlLmN1cnJlbnRUYXJnZXQpLmhpZGUoKTtcbiAgICAkKHRhcmdldC5maW5kKCcuY29tbWVudC1leHBhbmQnKVswXSkuc2hvdygpO1xuICAgICQodGFyZ2V0LmNoaWxkcmVuKCcuY29tbWVudC1zdWJsaXN0LXdyYXBwZXInKVswXSkuc2xpZGVUb2dnbGUoKTtcbiAgfSxcblxuICByZXBseTogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIC8vIFRoZSBjb21tZW50IGZvcm0gaXMgYWRqYWNlbnQsIG5vdCBhIGNoaWxkIG9mIHRoZSBjdXJyZW50IHRhcmdldC5cbiAgICAvLyBzbyBmaW5kIHRoZSBsaSBjb250YWluZXIsIGFuZCB0aGVuIHRoZSBmb3JtIGluc2lkZVxuICAgIHZhciB0YXJnZXQgPSAkKCQoJChlLmN1cnJlbnRUYXJnZXQpLnBhcmVudHMoJ2xpLmNvbW1lbnQtaXRlbScpWzBdKS5jaGlsZHJlbignLmNvbW1lbnQtZm9ybScpWzBdKTtcbiAgICBpZiAodGFyZ2V0LmRhdGEoJ2NsaWNrZWQnKSA9PSAndHJ1ZScpIHtcbiAgICAgIHRhcmdldC5oaWRlKCk7XG4gICAgICB0YXJnZXQuZGF0YSgnY2xpY2tlZCcsICdmYWxzZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQuc2hvdygpO1xuICAgICAgdGFyZ2V0LmRhdGEoJ2NsaWNrZWQnLCAndHJ1ZScpO1xuICAgIH1cbiAgfSxcblxuICBuZXdUb3BpYzogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgaWYgKHRoaXMudG9waWNGb3JtKSB0aGlzLnRvcGljRm9ybS5jbGVhbnVwKCk7XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBlbDogJy50b3BpYy1mb3JtLXdyYXBwZXInLFxuICAgICAgdGFyZ2V0OiB0aGlzLm9wdGlvbnMudGFyZ2V0LFxuICAgICAgY29sbGVjdGlvbjogdGhpcy5jb2xsZWN0aW9uLFxuICAgICAgdG9waWM6IHRydWUsXG4gICAgICBkZXB0aDogLTFcbiAgICB9XG4gICAgb3B0aW9uc1t0aGlzLm9wdGlvbnMudGFyZ2V0ICsgJ0lkJ10gPSB0aGlzLm9wdGlvbnMuaWQ7XG4gICAgdGhpcy50b3BpY0Zvcm0gPSBuZXcgQ29tbWVudEZvcm1WaWV3KG9wdGlvbnMpO1xuICB9LFxuXG4gIGFkZE5ld0NvbW1lbnRUb0RvbTogZnVuY3Rpb24gKG1vZGVsSnNvbiwgY3VycmVudFRhcmdldCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBtb2RlbEpzb25bJ3VzZXInXSA9IHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlcjtcbiAgICAvLyBpbmNyZW1lbnQgdGhlIGNvbW1lbnQgY291bnRlclxuICAgIGlmICgkKGN1cnJlbnRUYXJnZXQpLmRhdGEoJ2RlcHRoJykgPj0gMCkge1xuICAgICAgdmFyIGl0ZW1Db250YWluZXIgPSAkKGN1cnJlbnRUYXJnZXQpLnBhcmVudHMoJy5jb21tZW50LWl0ZW0uYm9yZGVyLWxlZnQnKVswXTtcbiAgICAgIHZhciBjb3VudFNwYW4gPSAkKGl0ZW1Db250YWluZXIpLmZpbmQoJy5jb21tZW50LWNvdW50LW51bScpWzBdO1xuICAgICAgJChjb3VudFNwYW4pLmh0bWwocGFyc2VJbnQoJChjb3VudFNwYW4pLnRleHQoKSkgKyAxKTtcbiAgICB9XG4gICAgLy8gc2V0IHRoZSBkZXB0aCBiYXNlZCBvbiB0aGUgcG9zaXRpb24gaW4gdGhlIHRyZWVcbiAgICBtb2RlbEpzb25bJ2RlcHRoJ10gPSAkKGN1cnJlbnRUYXJnZXQpLmRhdGEoJ2RlcHRoJykgKyAxO1xuICAgIC8vIHVwZGF0ZSB0aGUgcGFyZW50TWFwIGZvciBzb3J0aW5nXG4gICAgaWYgKCFfLmlzTnVsbChtb2RlbEpzb24ucGFyZW50SWQpKSB7XG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZCh0aGlzLnBhcmVudE1hcFttb2RlbEpzb24ucGFyZW50SWRdKSkge1xuICAgICAgICB0aGlzLnBhcmVudE1hcFttb2RlbEpzb24ucGFyZW50SWRdID0gW107XG4gICAgICB9XG4gICAgICB0aGlzLnBhcmVudE1hcFttb2RlbEpzb24ucGFyZW50SWRdLnB1c2gobW9kZWxKc29uLmlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50b3BpY3MucHVzaChtb2RlbEpzb24pO1xuICAgIH1cbiAgICAvLyBoaWRlIHRoZSBlbXB0eSBwbGFjZWhvbGRlciwganVzdCBpbiBjYXNlIGl0IGlzIHN0aWxsIHNob3dpbmdcbiAgICAkKFwiI2NvbW1lbnQtZW1wdHlcIikuaGlkZSgpO1xuICAgIC8vIHJlbmRlciBjb21tZW50IGFuZCBVSSBhZGRvbnNcbiAgICB2YXIgJGNvbW1lbnQgPSBzZWxmLnJlbmRlckNvbW1lbnQoc2VsZiwgbW9kZWxKc29uLCBzZWxmLmNvbGxlY3Rpb24sIHNlbGYucGFyZW50TWFwKTtcbiAgICBzZWxmLmluaXRpYWxpemVDb21tZW50VUlBZGRpdGlvbnMoJGNvbW1lbnQpO1xuXG4gICAgLy8gQ2xlYXIgb3V0IHRoZSBjdXJyZW50IGRpdlxuICAgICQoY3VycmVudFRhcmdldCkuZmluZChcImRpdltjb250ZW50RWRpdGFibGU9dHJ1ZV1cIikudGV4dChcIlwiKTtcbiAgfSxcblxuICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSBpbiB0aGlzLmNvbW1lbnRGb3Jtcy5yZXZlcnNlKCkpIHtcbiAgICAgIGlmICh0aGlzLmNvbW1lbnRGb3Jtc1tpXSkgeyB0aGlzLmNvbW1lbnRGb3Jtc1tpXS5jbGVhbnVwKCk7IH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSBpbiB0aGlzLmNvbW1lbnRWaWV3cy5yZXZlcnNlKCkpIHtcbiAgICAgIGlmICh0aGlzLmNvbW1lbnRWaWV3c1tpXSkgeyB0aGlzLmNvbW1lbnRWaWV3c1tpXS5jbGVhbnVwKCk7IH1cbiAgICB9XG4gICAgaWYgKHRoaXMudG9waWNGb3JtKSB7XG4gICAgICB0aGlzLnRvcGljRm9ybS5jbGVhbnVwKCk7XG4gICAgfVxuICAgIHJlbW92ZVZpZXcodGhpcyk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tbWVudDtcblxuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxsaSBjbGFzcz1cXFwiY29tbWVudC1pdGVtIGNsZWFyZml4IDwlIGlmICh0b3BpYykgeyAlPmJvcmRlci1sZWZ0IGJveC1wYWQtbHI8JSB9IGVsc2UgeyAlPmJvcmRlci10b3A8JSB9ICU+XFxcIj5cXG5cXG4gIDxkaXYgY2xhc3M9XFxcImNvbW1lbnQtY29udGVudFxcXCI+XFxuICAgIDwlIGlmICh0b3BpYykgeyAlPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb21tZW50LWV4cGFuZFxcXCI+XFxuICAgICAgPHNwYW4gY2xhc3M9XFxcImNvbnRlbnRcXFwiPmV4cGFuZDwvc3Bhbj4gPGkgY2xhc3M9XFxcImZhIGZhLWFuZ2xlLWRvdWJsZS1kb3duXFxcIj48L2k+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb21tZW50LWNvbnRyYWN0XFxcIj5cXG4gICAgICA8c3BhbiBjbGFzcz1cXFwiY29udGVudFxcXCI+Y29udHJhY3Q8L3NwYW4+IDxpIGNsYXNzPVxcXCJmYSBmYS1hbmdsZS1kb3VibGUtdXBcXFwiPjwvaT5cXG4gICAgPC9kaXY+XFxuICAgIDwlIH0gJT5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY29tbWVudC1pbWFnZVxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwicHJvamVjdC1wZW9wbGUtZGl2XFxcIiBkYXRhLXVzZXJpZD1cXFwiPCUtIHVzZXJJZCAlPlxcXCI+XFxuICAgICAgICA8aW1nIHNyYz1cXFwiL2FwaS91c2VyL3Bob3RvLzwlPSB1c2VySWQgJT5cXFwiIGFsdD1cXFwiPCUtIHVzZXIubmFtZSAlPlxcXCIgY2xhc3M9XFxcInByb2plY3QtcGVvcGxlXFxcIiAvPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY29tbWVudC1pbm5lciA8JSBpZiAodG9waWMpIHsgJT50b3BpYzwlIH0lPlxcXCI+XFxuICAgICAgPHNwYW4gY2xhc3M9XFxcInVzZXItdXNlcm5hbWVcXFwiIGRhdGEtdXNlcmlkPVxcXCI8JS0gdXNlcklkICU+XFxcIj5cXG4gICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJjb21tZW50LXVzZXItbGlua1xcXCIgZGF0YS11c2VyaWQ9XFxcIjwlLSB1c2VySWQgJT5cXFwiPlxcbiAgICAgICAgICA8JSBpZiAodXNlci5uYW1lKSB7ICU+XFxuICAgICAgICAgICAgPCUtIHVzZXIubmFtZSAlPlxcbiAgICAgICAgICA8JSB9IGVsc2UgeyAlPlxcbiAgICAgICAgICAgIDwlLSB1c2VyLnVzZXJuYW1lICU+XFxuICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgIDwvYT5cXG4gICAgICA8L3NwYW4+XFxuXFxuICAgICAgPCU9IHZhbHVlSHRtbCAlPlxcblxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbW1lbnQtbWV0YWRhdGFcXFwiPlxcbiAgICAgICAgPHRpbWUgY2xhc3M9XFxcInRpbWVhZ28gY29tbWVudC1jcmVhdGVkLWF0XFxcIiBkYXRldGltZT1cXFwiPCUtIGNyZWF0ZWRBdCAlPlxcXCI+PCUtIGNyZWF0ZWRBdCAlPjwvdGltZT5cXG4gICAgICAgIDwlIGlmICh0b3BpYykgeyAlPlxcbiAgICAgICAgJmJ1bGw7Jm5ic3A7XFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwiY29tbWVudC1jb3VudFxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLWNvbW1lbnRzXFxcIj48L2k+IDxzcGFuIGNsYXNzPVxcXCJjb21tZW50LWNvdW50LW51bVxcXCI+PCUtIG51bUNoaWxkcmVuICU+PC9zcGFuPiBjb21tZW50czwvc3Bhbj5cXG4gICAgICAgIDwlIH0gJT5cXG4gICAgICAgIDwlIGlmIChkZXB0aCA9PSAxKSAgeyAlPlxcbiAgICAgICAgPCUgaWYgKGN1cnJlbnRVc2VyKSB7ICU+XFxuICAgICAgICAmYnVsbDtcXG4gICAgICAgIDxhIGhyZWY9XFxcIiNyZXBseS10by1jb21tZW50XFxcIiBjbGFzcz1cXFwicmVwbHktdG8tPCU9IGlkICU+XFxcIiBkYXRhLWRlcHRoPVxcXCI8JT0gZGVwdGggJT5cXFwiPlJlcGx5PC9hPlxcbiAgICAgICAgPCUgfSAlPlxcbiAgICAgICAgPCUgfSAlPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcblxcbiAgPGRpdiBjbGFzcz1cXFwiY29tbWVudC1zdWJsaXN0LXdyYXBwZXJcXFwiPlxcblxcbiAgICA8dWwgaWQ9XFxcImNvbW1lbnQtbGlzdC08JT0gaWQgJT5cXFwiPjwvdWw+XFxuICA8L2Rpdj5cXG5cXG4gIDxkaXYgY2xhc3M9XFxcImNvbW1lbnQtZm9ybVxcXCIgPCUgaWYgKChkZXB0aCA+PSAxKSB8fCAoIWN1cnJlbnRVc2VyKSkgeyAlPnN0eWxlPVxcXCJkaXNwbGF5OiBub25lO1xcXCI8JSB9ICU+IGlkPVxcXCJjb21tZW50LWZvcm0tPCU9IGlkICU+XFxcIj48L2Rpdj5cXG5cXG48L2xpPlxcblwiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImJveC1wYWQtbHIgYm9yZGVyLWJvdHRvbVxcXCI+XFxuICA8aDI+RGlzY3Vzc2lvblxcbiAgPCUgaWYgKHVzZXIpIHsgJT5cXG4gIDxidXR0b24gY2xhc3M9XFxcImJ0biBidG4tYzAgYnRuLXNtIGZpbGUtYWRkIG5ldy10b3BpY1xcXCIgaWQ9XFxcInByb2plY3QtdG9waWMtbmV3XFxcIj5OZXcgVG9waWM8L2J1dHRvbj5cXG4gIDwlIH0gJT5cXG4gIDwvaDI+XFxuPC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwiYm94LXBhZC1sciBib3gtcGFkLXQgdG9waWMtZm9ybS13cmFwcGVyXFxcIj48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJjb21tZW50LXNwaW5uZXIgZnVsbHdpZHRoIHRleHQtY2VudGVyXFxcIj5cXG4gIExvYWRpbmcgZGlzY3Vzc2lvbi4uLiA8aSBjbGFzcz1cXFwiZmEgZmEtc3Bpbm5lciBmYS1zcGluXFxcIj48L2k+XFxuPC9kaXY+XFxuPHVsIGlkPVxcXCJjb21tZW50LWxpc3QtbnVsbFxcXCI+XFxuICA8bGkgY2xhc3M9XFxcImNvbW1lbnQtaXRlbSBjbGVhcmZpeCBib3JkZXItbGVmdCBib3gtcGFkLWxyXFxcIiBpZD1cXFwiY29tbWVudC1lbXB0eVxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPlxcbiAgICBObyBkaXNjdXNzaW9uIHlldC4gIFN0YXJ0IGEgdG9waWMhXFxuICA8L2xpPlxcbjwvdWw+XFxuXCI7XG4iLCJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciB1dGlsaXRpZXMgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgQXV0b2xpbmtlciA9IHJlcXVpcmUoJ2F1dG9saW5rZXInKTtcbnZhciBDb21tZW50SXRlbVRlbXBsYXRlID0gcmVxdWlyZSgnLi4vdGVtcGxhdGVzL2NvbW1lbnRfaXRlbV90ZW1wbGF0ZS5odG1sJyk7XG5cblxudmFyIENvbW1lbnRJdGVtVmlldyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm1vZGVsLmN1cnJlbnRVc2VyID0gd2luZG93LmNhY2hlLmN1cnJlbnRVc2VyO1xuICAgIHRoaXMubW9kZWwudmFsdWVIdG1sID0gQXV0b2xpbmtlci5saW5rKHRoaXMubW9kZWwudmFsdWUpO1xuICAgIGlmICh0aGlzLm1vZGVsLnRvcGljKSB7XG4gICAgICB2YXIgY29tcGlsZWRUZW1wbGF0ZSA9IF8udGVtcGxhdGUoQ29tbWVudEl0ZW1UZW1wbGF0ZSkodGhpcy5tb2RlbCk7XG4gICAgICB0aGlzLiRlbC5hcHBlbmQoY29tcGlsZWRUZW1wbGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIGlmICh0aGlzLm1vZGVsLnBhcmVudElkID09PSBwYXJzZUludCgkKFwiI2NvbW1lbnQtbGlzdC1cIiArIHRoaXMubW9kZWwucGFyZW50SWQpLmF0dHIoXCJpZFwiKS5zcGxpdChcIi1cIilbJChcIiNjb21tZW50LWxpc3QtXCIrdGhpcy5tb2RlbC5wYXJlbnRJZCkuYXR0cihcImlkXCIpLnNwbGl0KFwiLVwiKS5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgdmFyIG5ld1RlbXBsYXRlID0gXy50ZW1wbGF0ZShDb21tZW50SXRlbVRlbXBsYXRlKSh0aGlzLm1vZGVsKTtcbiAgICAgICAgJChcIiNjb21tZW50LWxpc3QtXCIgKyB0aGlzLm1vZGVsLnBhcmVudElkKS5hcHBlbmQobmV3VGVtcGxhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb21tZW50SXRlbVZpZXc7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGxpIGRhdGEtdmFsdWU9JzwlLSB2YWx1ZSAlPic+XFxuICA8ZGl2IGNsYXNzPVxcXCJhYy1jb250YWluZXJcXFwiPlxcbiAgICA8JSBpZiAoaW1hZ2UgIT09IG51bGwpIHsgJT5cXG4gICAgPGltZyBzcmM9XFxcIjwlLSBpbWFnZSAlPlxcXCIgYWx0PVxcXCI8JS0gdmFsdWUgJT5cXFwiIGNsYXNzPVxcXCJhYy1pbWFnZVxcXCIvPlxcbiAgICA8JSB9IGVsc2UgaWYgKHRhcmdldCA9PSAncHJvamVjdCcpIHsgJT5cXG4gICAgPGltZyBzcmM9XFxcIi9pbWFnZXMvcHJvamVjdF9kZWZhdWx0LnBuZ1xcXCIgYWx0PVxcXCI8JS0gdmFsdWUgJT5cXFwiIGNsYXNzPVxcXCJhYy1pbWFnZVxcXCIvPlxcbiAgICA8JSB9IGVsc2UgeyAlPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJhYy1pbWFnZVxcXCI+PC9kaXY+XFxuICAgIDwlIH0gJT5cXG4gICAgPGRpdiBjbGFzcz1cXFwiYWMtY29udGVudFxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiYWMtdGl0bGVcXFwiPlxcbiAgICAgICAgPCUtIHZhbHVlICU+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiYWMtZGVzY3JpcHRpb25cXFwiPlxcbiAgICAgICAgPCUgaWYgKCh0YXJnZXQgPT0gJ3Byb2plY3QnKSB8fCAodGFyZ2V0ID09ICd1c2VyJykpIHsgJT5cXG4gICAgICAgIDwlPSBkZXNjcmlwdGlvbiAlPlxcbiAgICAgICAgPCUgfSAlPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvbGk+XCI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcImNvbC1sZy0xMiBcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJhbGVydCBhbGVydC1kYW5nZXIgY29tbWVudC1hbGVydC1lbXB0eVxcXCI+XFxuICAgICAgWW91IG11c3QgZW50ZXIgdGV4dCBiZWZvcmUgc3VibWl0dGluZyBhIGNvbW1lbnQuXFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcImNvbC1sZy0xMiBcXFwiPlxcbiAgICA8Zm9ybSBhY3Rpb249XFxcIlxcXCIgY2xhc3M9XFxcImZvcm0taW5saW5lIGNvbW1lbnQtc3VibWl0IDwlIGlmIChmb3JtLnRvcGljKSB7ICU+Y29tbWVudC1mb3JtLXRvcGljPCUgfSAlPlxcXCIgcm9sZT1cXFwiZm9ybVxcXCIgZGF0YS1kZXB0aD1cXFwiPCU9IGZvcm0uZGVwdGggJT5cXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImlucHV0LWdyb3VwXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbW1lbnQtaW5wdXQgZm9ybS1jb250cm9sIGlucHV0LXNtXFxcIiBjb250ZW50RWRpdGFibGU9XFxcInRydWVcXFwiPjwvZGl2PlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcImlucHV0LWdyb3VwLWJ0blxcXCI+XFxuICAgICAgICAgIDxpbnB1dCBjbGFzcz1cXFwiYnRuIGJ0bi1jMiBidG4tc21cXFwiIHR5cGU9XFxcInN1Ym1pdFxcXCIgdmFsdWU9XFxcIjwlIGlmIChmb3JtLnRvcGljKSB7ICU+IFN0YXJ0IFRvcGljIDwlIH0gZWxzZSBpZiAoZm9ybS5kZXB0aCA9PSAxKSB7ICU+IFJlcGx5IDwlIH0gZWxzZSB7ICU+QWRkIENvbW1lbnQ8JSB9ICU+XFxcIiB0aXRsZT1cXFwiPCUgaWYgKGZvcm0udG9waWMpIHsgJT4gU3RhcnQgVG9waWMgPCUgfSBlbHNlIGlmIChmb3JtLmRlcHRoID09IDEpIHsgJT4gUmVwbHkgPCUgfSBlbHNlIHsgJT5BZGQgQ29tbWVudDwlIH0gJT5cXFwiPlxcbiAgICAgICAgPC9zcGFuPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Zvcm0+XFxuICA8L2Rpdj5cXG48L2Rpdj5cXG5cIjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8JSBpZiAodGFyZ2V0ID09ICd1c2VyJykge1xcbiAgJT48YSBocmVmPVxcXCI8JS0gbGluayAlPlxcXCIgY2xhc3M9XFxcImNvbW1lbnQtdXNlci1saW5rXFxcIiBkYXRhLXVzZXJpZD08JS0gaWQgJT4+QDwlLSB2YWx1ZSAlPjwvYT48JSB9XFxuICBlbHNlIGlmICh0YXJnZXQgPT0gJ3Byb2plY3QnKSB7XFxuICAlPjxhIGhyZWY9XFxcIjwlLSBsaW5rICU+XFxcIiBjbGFzcz1cXFwibGluay1iYWNrYm9uZVxcXCI+PCUtIHZhbHVlICU+PC9hPjwlIH1cXG4gIGVsc2Uge1xcbiAgJT48YSBocmVmPVxcXCI8JS0gbGluayAlPlxcXCI+PCUtIHZhbHVlICU+PC9hPjwlIH0gJT5cIjtcbiIsIi8vIFRoaXMgaXMgdGhlIGNvbW1lbnQsIGFuZCB0b3BpYyBmb3JtLlxuLy8gV2Uga25vdyB3aGF0IHRvIGRvIGJhc2VkIG9uIGEgZmxhZyBiZWluZyBwYXNzZWQgaW50byB0aGlzIHZpZXdcbi8vIHZpYSB0aGUgY29udHJvbGxlci4gIFRoYXQgZmxhZyBpczpcbi8vIHRoaXMub3B0aW9ucy50b3BpYyA9IHRydWVcblxuXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIganFDYXJldCA9IHJlcXVpcmUoJ2pxdWVyeS5jYXJldC9kaXN0L2pxdWVyeS5jYXJldC5taW4nKTtcbnZhciBqcUF0ID0gcmVxdWlyZSgnanF1ZXJ5LmF0d2hvL2Rpc3QvanMvanF1ZXJ5LmF0d2hvJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgbWFya2VkID0gcmVxdWlyZSgnbWFya2VkJyk7XG52YXIgQ29tbWVudENvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9lbnRpdGllcy9jb21tZW50cy9jb21tZW50X2NvbGxlY3Rpb24nKTtcbnZhciBDb21tZW50Rm9ybVRlbXBsYXRlID0gcmVxdWlyZSgnLi4vdGVtcGxhdGVzL2NvbW1lbnRfZm9ybV90ZW1wbGF0ZS5odG1sJyk7XG52YXIgQ29tbWVudEFjVGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvY29tbWVudF9hY190ZW1wbGF0ZS5odG1sJyk7XG52YXIgQ29tbWVudElubGluZVRlbXBsYXRlID0gcmVxdWlyZSgnLi4vdGVtcGxhdGVzL2NvbW1lbnRfaW5saW5lX3RlbXBsYXRlLmh0bWwnKTtcblxuXG52YXIgQ29tbWVudEZvcm1WaWV3ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuXG4gIGV2ZW50czoge1xuICAgIFwic3VibWl0IC5jb21tZW50LXN1Ym1pdFwiOiBcInBvc3RcIlxuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnJlbmRlcigpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZGF0YSA9IHsgZm9ybTogdGhpcy5vcHRpb25zIH07XG4gICAgdmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZShDb21tZW50Rm9ybVRlbXBsYXRlKShkYXRhKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMudG9waWMpIHtcbiAgICAgIHRoaXMuJGVsLnByZXBlbmQodGVtcGxhdGUpLmFwcGVuZChcIjxkaXYgY2xhc3M9J2NsZWFyZml4Jz48L2Rpdj5cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJGVsLmFwcGVuZCh0ZW1wbGF0ZSk7XG4gICAgfVxuXG4gICAgdmFyIGdlblRlbXBsYXRlID0gZnVuY3Rpb24gKHRlbXBsYXRlLCBkYXRhKSB7XG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgLy8gdXNlIHRoZSBhZ2VuY3kvb2ZmaWNlIG5hbWUgYXMgdGhlIGRlc2NyaXB0aW9uXG4gICAgICAvLyBpZiBub25lIGV4aXN0cywgdXNlIHRoZSBqb2IgdGl0bGUuXG4gICAgICAvLyBvdGhlcndpc2UgbGVhdmUgYmxhbmsuXG4gICAgICBpZiAoZGF0YS50YXJnZXQgPT0gJ3VzZXInKSB7XG4gICAgICAgIGlmIChkYXRhLmFnZW5jeSkge1xuICAgICAgICAgIGRhdGEuZGVzY3JpcHRpb24gPSBkYXRhLmFnZW5jeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhLnRpdGxlKSB7XG4gICAgICAgICAgZGF0YS5kZXNjcmlwdGlvbiA9IGRhdGEudGl0bGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGF0YS5kZXNjcmlwdGlvbiA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBjb252ZXJ0IGRlc2NyaXB0aW9ucyB0byBtYXJrZG93bi9odG1sXG4gICAgICBpZiAoZGF0YS50YXJnZXQgPT0gJ3Byb2plY3QnKSB7XG4gICAgICAgIGlmIChkYXRhLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgZGF0YS5kZXNjcmlwdGlvbiA9IG1hcmtlZChkYXRhLmRlc2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGEuY292ZXJJZCkge1xuICAgICAgICAgIGRhdGEuY292ZXJJZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghZGF0YS5pbWFnZSkge1xuICAgICAgICBkYXRhLmltYWdlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIHJlbmRlciB0ZW1wbGF0ZVxuICAgICAgcmV0dXJuIF8udGVtcGxhdGUodGVtcGxhdGUpKGRhdGEpO1xuICAgIH07XG5cbiAgICB0aGlzLiQoXCIuY29tbWVudC1pbnB1dFwiKS5hdHdobyh7XG4gICAgICBhdDogJ0AnLFxuICAgICAgc2VhcmNoX2tleTogJ3ZhbHVlJyxcbiAgICAgIHRwbDogQ29tbWVudEFjVGVtcGxhdGUsXG4gICAgICBpbnNlcnRfdHBsOiBDb21tZW50SW5saW5lVGVtcGxhdGUsXG4gICAgICBsaW1pdDogMTAsXG4gICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgdHBsX2V2YWw6IGdlblRlbXBsYXRlLFxuICAgICAgICBzb3J0ZXI6IGZ1bmN0aW9uIChxdWVyeSwgaXRlbXMsIHNlYXJjaF9rZXkpIHtcbiAgICAgICAgICAvLyBkb24ndCBzb3J0LCB1c2UgdGhlIG9yZGVyIGZyb20gdGhlIHNlcnZlclxuICAgICAgICAgIHJldHVybiBpdGVtcztcbiAgICAgICAgfSxcbiAgICAgICAgaGlnaGxpZ2h0ZXI6IGZ1bmN0aW9uIChsaSwgcXVlcnkpIHtcbiAgICAgICAgICByZXR1cm4gbGk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGhpZ2hsaWdodGVyOiBmdW5jdGlvbiAobGksIHF1ZXJ5KSB7XG4gICAgICAgIC8vICAgdmFyIHJlZ2V4cDtcbiAgICAgICAgLy8gICBpZiAoIXF1ZXJ5KSB7XG4gICAgICAgIC8vICAgICByZXR1cm4gbGk7XG4gICAgICAgIC8vICAgfVxuICAgICAgICAvLyAgIC8vIGp1c3Qgd2FudCB0byBmaW5kIGFsbCBjYXNlIGluc2Vuc2l0aXZlIG1hdGNoZXMgYW5kIHJlcGxhY2Ugd2l0aCA8c3Ryb25nPlxuICAgICAgICAvLyAgIC8vIHNldCB1cCB0aGUgcXVlcnkgYXMgYSByZWd1bGFyIGV4cHJlc3Npb25cbiAgICAgICAgLy8gICB2YXIgcmUgPSBuZXcgUmVnRXhwKCcoJyArIHF1ZXJ5LnJlcGxhY2UoLyhbLiorP149IToke30oKXxcXFtcXF1cXC9cXFxcXSkvZywgXCJcXFxcJDFcIikgKyAnKScsICdpZycpO1xuICAgICAgICAvLyAgIC8vIHBhcnNlIHRoZSBsaSBzdHJpbmcgaW50byBhIERPTSBub2RlXG4gICAgICAgIC8vICAgdmFyIGxpRG9tID0gJC5wYXJzZUhUTUwobGkpO1xuICAgICAgICAvLyAgIHZhciB0ZXh0ID0gJChsaURvbVswXSkudGV4dCgpLnJlcGxhY2UocmUsIFwiPHN0cm9uZz4kMTwvc3Ryb25nPlwiKTtcbiAgICAgICAgLy8gICAkKGxpRG9tWzBdKS5odG1sKHRleHQpO1xuICAgICAgICAvLyAgIHJldHVybiBsaURvbVswXTtcbiAgICAgICAgLy8gfSxcbiAgICAgICAgcmVtb3RlX2ZpbHRlcjogZnVuY3Rpb24gKHF1ZXJ5LCBjYWxsYmFjaykge1xuICAgICAgICAgIC8vIGdldCBkYXRhIGZyb20gdGhlIHNlcnZlclxuICAgICAgICAgICQuZ2V0SlNPTihcIi9hcGkvYWMvaW5saW5lXCIsIHsgcTogcXVlcnkgfSwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIF8uZWFjaChkYXRhLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAvLyBBdC5qcyBleHBlY3RzIHRoZSBuYW1lIHRvIGJlIHNldCBmb3IgdGhlIG1hdGNoZXIgZm5cbiAgICAgICAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQoZC5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGQubmFtZSA9IGQudmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KS5vbihcImluc2VydGVkLmF0d2hvXCIsIGZ1bmN0aW9uKGV2ZW50LCAkbGkpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBoYWNrIHRvIGhpZGUgdGhlIHNwYWNlIGFmdGVyIGluc2VydGluZyBhbiBlbGVtZW50LlxuICAgICAgdmFyIGlkcyA9IHNlbGYuJChcInNwYW4uYXR3aG8tdmlldy1mbGFnID4gc3Bhbjp2aXNpYmxlXCIpO1xuICAgICAgLy8gaW5zZXJ0IGEgbm9uLWJyZWFraW5nIHNwYWNlIGFmdGVyIHRoZSBpbnNlcnRlZCBlbGVtZW50LCBidXQgbm90IHdpdGhpbiBpdFxuICAgICAgLy8gdGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gZGVsZXRlIHRoYXQgc3BhY2UgaWYgdGhleSB3YW50IHRvLCB3aXRob3V0IGRlbGV0aW5nXG4gICAgICAvLyB0aGUgcmVmZXJlbmNlZCBlbGVtZW50XG4gICAgICBpZHMucGFyZW50KCkuYWZ0ZXIoJyZuYnNwOycpO1xuICAgICAgaWRzLmhpZGUoKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHBvc3Q6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIHZhciBjb21tZW50SHRtbCA9IHRoaXMuJChcIi5jb21tZW50LWlucHV0XCIpLmh0bWwoKTtcbiAgICB2YXIgY29tbWVudFRleHQgPSB0aGlzLiQoXCIuY29tbWVudC1pbnB1dFwiKS50ZXh0KCkudHJpbSgpO1xuXG4gICAgLy8gYWJvcnQgaWYgdGhlIGNvbW1lbnQgaXMgZW1wdHlcbiAgICBpZiAoIWNvbW1lbnRUZXh0KSB7XG4gICAgICB0aGlzLiQoJy5jb21tZW50LWFsZXJ0LWVtcHR5Jykuc2hvdygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYXJlbnRJZDtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMucGFyZW50SWQpIHtcbiAgICAgIHBhcmVudElkID0gcGFyc2VJbnQodGhpcy5vcHRpb25zLnBhcmVudElkKTtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIGNvbW1lbnQgICA6IGNvbW1lbnRIdG1sLFxuICAgICAgdG9waWMgICAgIDogZmFsc2VcbiAgICB9O1xuICAgIGRhdGFbdGhpcy5vcHRpb25zLnRhcmdldCArICdJZCddID0gdGhpcy5vcHRpb25zW3RoaXMub3B0aW9ucy50YXJnZXQgKyAnSWQnXTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMudG9waWMpIHtcbiAgICAgIGRhdGEudG9waWMgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhLnBhcmVudElkID0gcGFyZW50SWQ7XG4gICAgfVxuICAgIHRoaXMuJCgnLmNvbW1lbnQtYWxlcnQtZW1wdHknKS5oaWRlKCk7XG5cbiAgICB2YXIgY3VycmVudFRhcmdldCA9IGUuY3VycmVudFRhcmdldDtcbiAgICB0aGlzLmNvbGxlY3Rpb24udHJpZ2dlcihcImNvbW1lbnQ6c2F2ZVwiLCBkYXRhLCBjdXJyZW50VGFyZ2V0KTtcbiAgfSxcblxuICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb21tZW50Rm9ybVZpZXc7XG4iLCJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL21peGlucy91dGlsaXRpZXMnKTtcbnZhciBQb3BvdmVycyA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL21peGlucy9wb3BvdmVycycpO1xudmFyIEV2ZW50c0NvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9lbnRpdGllcy9ldmVudHMvZXZlbnRzX2NvbGxlY3Rpb24nKTtcbnZhciBFdmVudENvbGxlY3Rpb25WaWV3ID0gcmVxdWlyZSgnLi4vdmlld3MvZXZlbnRfY29sbGVjdGlvbl92aWV3Jyk7XG52YXIgTW9kYWxDb21wb25lbnQgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb21wb25lbnRzL21vZGFsJyk7XG52YXIgRXZlbnRGb3JtVmlldyA9IHJlcXVpcmUoJy4uLy4uL25ldy92aWV3cy9ldmVudF9mb3JtX3ZpZXcnKTtcblxuXG52YXIgcG9wb3ZlcnMgPSBuZXcgUG9wb3ZlcnMoKTtcblxuRXZlbnRMaXN0ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuXG4gIGVsOiBcIiNldmVudC1saXN0LXdyYXBwZXJcIixcblxuICBldmVudHM6IHtcbiAgICAnY2xpY2sgLmFkZC1ldmVudCcgICAgICAgICAgICAgICAgOiAnYWRkJyxcbiAgICAnY2xpY2sgLnJzdnAnICAgICAgICAgICAgICAgICAgICAgOiAndG9nZ2xlUlNWUCcsXG4gICAgJ21vdXNlZW50ZXIgLmRhdGEtZXZlbnQtZmxhZy10cnVlJzogJ2J1dHRvblJTVlBPbicsXG4gICAgJ21vdXNlbGVhdmUgLmRhdGEtZXZlbnQtZmxhZy10cnVlJzogJ2J1dHRvblJTVlBPZmYnLFxuICAgIFwibW91c2VlbnRlciAucHJvamVjdC1wZW9wbGUtZGl2XCIgIDogcG9wb3ZlcnMucG9wb3ZlclBlb3BsZU9uLFxuICAgIFwiY2xpY2sgLnByb2plY3QtcGVvcGxlLWRpdlwiICAgICAgIDogcG9wb3ZlcnMucG9wb3ZlckNsaWNrXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKHNldHRpbmdzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMub3B0aW9ucyA9IF8uZXh0ZW5kKHNldHRpbmdzLCB0aGlzLmRlZmF1bHRzKTtcbiAgICB0aGlzLnJlcXVlc3RFdmVudHNDb2xsZWN0aW9uRGF0YSgpO1xuICB9LFxuXG4gIHJlcXVlc3RFdmVudHNDb2xsZWN0aW9uRGF0YTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmNvbGxlY3Rpb24gPSBuZXcgRXZlbnRzQ29sbGVjdGlvbigpO1xuICAgIHRoaXMuY29sbGVjdGlvbi5mZXRjaCh7XG4gICAgICB1cmw6ICcvYXBpL2V2ZW50L2ZpbmRBbGxCeVByb2plY3RJZC8nICsgcGFyc2VJbnQodGhpcy5vcHRpb25zLnByb2plY3RJZCksXG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoY29sbGVjdGlvbikge1xuICAgICAgICBzZWxmLmNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuICAgICAgICBzZWxmLnJlbmRlckV2ZW50Q29sbGVjdGlvblZpZXcoY29sbGVjdGlvbik7XG4gICAgICB9XG4gICAgfSlcbiAgfSxcblxuICByZW5kZXJFdmVudENvbGxlY3Rpb25WaWV3OiBmdW5jdGlvbiAoY29sbGVjdGlvbikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29sbGVjdGlvbiwgXCJldmVudDpzYXZlOnN1Y2Nlc3NcIiwgZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAkKCcjYWRkRXZlbnQnKS5iaW5kKCdoaWRkZW4uYnMubW9kYWwnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5yZXF1ZXN0RXZlbnRzQ29sbGVjdGlvbkRhdGEoKTtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRGb3JtVmlldykgdGhpcy5ldmVudEZvcm1WaWV3LmNsZWFudXAoKTtcbiAgICAgICAgaWYgKHRoaXMubW9kYWxDb21wb25lbnQpIHRoaXMubW9kYWxDb21wb25lbnQuY2xlYW51cCgpO1xuICAgICAgfSkubW9kYWwoJ2hpZGUnKTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmV2ZW50Q29sbGVjdGlvblZpZXcpIHtcbiAgICAgIHRoaXMuZXZlbnRDb2xsZWN0aW9uVmlldy5jbGVhbnVwKCk7XG4gICAgfVxuXG4gICAgdGhpcy5ldmVudENvbGxlY3Rpb25WaWV3ID0gbmV3IEV2ZW50Q29sbGVjdGlvblZpZXcoe1xuICAgICAgZWw6IFwiI2V2ZW50LWxpc3Qtd3JhcHBlclwiLFxuICAgICAgb25SZW5kZXI6IHRydWUsXG4gICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLFxuICAgICAgcHJvamVjdElkOiB0aGlzLm9wdGlvbnMucHJvamVjdElkXG4gICAgfSk7XG5cbiAgICBwb3BvdmVycy5wb3BvdmVyUGVvcGxlSW5pdChcIi5wcm9qZWN0LXBlb3BsZS1kaXZcIik7XG4gIH0sXG5cbiAgYWRkOiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAvLyBjbGVhbnVwIGV4aXN0aW5nIHZpZXdzXG4gICAgaWYgKHRoaXMuZXZlbnRGb3JtVmlldykgdGhpcy5ldmVudEZvcm1WaWV3LmNsZWFudXAoKTtcbiAgICBpZiAodGhpcy5tb2RhbENvbXBvbmVudCkgdGhpcy5tb2RhbENvbXBvbmVudC5jbGVhbnVwKCk7XG5cbiAgICAvLyBpbnN0YW50aWF0ZSB0aGUgbW9kYWwgd2l0aCB0aGUgZXZlbnQgZm9ybSB2aWV3XG4gICAgdGhpcy5tb2RhbENvbXBvbmVudCA9IG5ldyBNb2RhbENvbXBvbmVudCh7XG4gICAgICBlbDogXCIjZXZlbnQtbW9kYWwtYWRkXCIsXG4gICAgICBpZDogXCJhZGRFdmVudFwiLFxuICAgICAgbW9kYWxUaXRsZTogJ0FkZCBFdmVudCdcbiAgICB9KS5yZW5kZXIoKTtcblxuICAgIHRoaXMuZXZlbnRGb3JtVmlldyA9IG5ldyBFdmVudEZvcm1WaWV3KHtcbiAgICAgIGVsOiBcIiNldmVudC1tb2RhbC1hZGQgLm1vZGFsLXRlbXBsYXRlXCIsXG4gICAgICBwcm9qZWN0SWQ6IHRoaXMub3B0aW9ucy5wcm9qZWN0SWQsXG4gICAgICBjb2xsZWN0aW9uOiB0aGlzLmNvbGxlY3Rpb25cbiAgICB9KS5yZW5kZXIoKTtcbiAgfSxcblxuICB1cGRhdGVQZW9wbGU6IGZ1bmN0aW9uIChlLCBpbmMpIHtcbiAgICB2YXIgcGVvcGxlRGl2ID0gJCgkKGUuY3VycmVudFRhcmdldCkucGFyZW50cygnLmV2ZW50JylbMF0pLmZpbmQoJy5ldmVudC1wZW9wbGUnKVswXTtcbiAgICB2YXIgbnVtRGl2ID0gJChwZW9wbGVEaXYpLmNoaWxkcmVuKCcuZXZlbnQtcGVvcGxlLW51bWJlcicpO1xuICAgIHZhciBuZXdOdW0gPSBwYXJzZUludCgkKG51bURpdikuaHRtbCgpKTtcbiAgICBpZiAoaW5jKSB7XG4gICAgICBuZXdOdW0rK1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdOdW0tLTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYWxsb3cgcmFjZSBjb25kaXRpb25zIHRvIHNldCB0aGUgbnVtYmVyIG9mIHBlb3BsZSBiZWxvdyB6ZXJvXG4gICAgaWYgKG5ld051bSA8IDApIHtcbiAgICAgIG5ld051bSA9IDA7XG4gICAgfVxuICAgICQobnVtRGl2KS5odG1sKG5ld051bSk7XG4gICAgdmFyIHRleHREaXYgPSAkKHBlb3BsZURpdikuY2hpbGRyZW4oJy5ldmVudC1wZW9wbGUtdGV4dCcpWzBdO1xuICAgIGlmIChuZXdOdW0gPT0gMSkge1xuICAgICAgJCh0ZXh0RGl2KS5odG1sKCQodGV4dERpdikuZGF0YSgnc2luZ3VsYXInKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICQodGV4dERpdikuaHRtbCgkKHRleHREaXYpLmRhdGEoJ3BsdXJhbCcpKTtcbiAgICB9XG4gIH0sXG5cbiAgYnV0dG9uUlNWUE9uOiBmdW5jdGlvbiAoZSkge1xuICAgICQoZS5jdXJyZW50VGFyZ2V0KS5idXR0b24oJ2hvdmVyJyk7XG4gIH0sXG5cbiAgYnV0dG9uUlNWUE9mZjogZnVuY3Rpb24gKGUpIHtcbiAgICAkKGUuY3VycmVudFRhcmdldCkuYnV0dG9uKCdnb2luZycpO1xuICB9LFxuXG4gIHRvZ2dsZVJTVlA6IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgLy8gZ2V0IHRoZSBpZCBmcm9tIHRoZSBwYXJlbnQgZXZlbnQgZGl2XG4gICAgdmFyIGlkID0gJCgkKGUuY3VycmVudFRhcmdldCkucGFyZW50cygnZGl2LmV2ZW50JylbMF0pLmRhdGEoJ2lkJyk7XG4gICAgaWYgKCQoXCIucnN2cFwiKS5oYXNDbGFzcyhcImRhdGEtZXZlbnQtZmxhZy10cnVlXCIpID09PSBmYWxzZSkge1xuICAgICAgJChcIi5yc3ZwXCIpLnJlbW92ZUNsYXNzKFwiZGF0YS1ldmVudC1mbGFnLWZhbHNlXCIpO1xuICAgICAgJChcIi5yc3ZwXCIpLmFkZENsYXNzKFwiZGF0YS1ldmVudC1mbGFnLXRydWVcIik7XG4gICAgICAkKGUuY3VycmVudFRhcmdldCkuYnV0dG9uKCdnb2luZycpO1xuICAgICAgc2VsZi51cGRhdGVQZW9wbGUoZSwgdHJ1ZSk7XG4gICAgICAkLmFqYXgoe1xuICAgICAgICB1cmw6ICcvYXBpL2V2ZW50L2F0dGVuZC8nICsgaWQsXG4gICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAkKFwiLnJzdnBcIikucmVtb3ZlQ2xhc3MoXCJkYXRhLWV2ZW50LWZsYWctdHJ1ZVwiKTtcbiAgICAgICQoXCIucnN2cFwiKS5hZGRDbGFzcyhcImRhdGEtZXZlbnQtZmxhZy1mYWxzZVwiKTtcbiAgICAgICQoZS5jdXJyZW50VGFyZ2V0KS5idXR0b24oJ3JzdnAnKTtcbiAgICAgIHNlbGYudXBkYXRlUGVvcGxlKGUsIGZhbHNlKTtcbiAgICAgICQuYWpheCh7XG4gICAgICAgIHVybDogJy9hcGkvZXZlbnQvY2FuY2VsLycgKyBpZCxcbiAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH0sXG5cbiAgY2xlYW51cDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmV2ZW50Q29sbGVjdGlvblZpZXcpIHRoaXMuZXZlbnRDb2xsZWN0aW9uVmlldy5jbGVhbnVwKCk7XG4gICAgaWYgKHRoaXMuZXZlbnRGb3JtVmlldykgdGhpcy5ldmVudEZvcm1WaWV3LmNsZWFudXAoKTtcbiAgICBpZiAodGhpcy5tb2RhbENvbXBvbmVudCkgdGhpcy5tb2RhbENvbXBvbmVudC5jbGVhbnVwKCk7XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudExpc3RcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJib3gtcGFkLWxyIGJvcmRlci1ib3R0b21cXFwiPlxcbiAgPGgyPlxcbiAgICBVcGNvbWluZyBFdmVudHNcXG4gICAgPCUgaWYgKHVzZXIpIHsgJT5cXG4gICAgPGEgaHJlZj1cXFwiI2FkZEV2ZW50XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1jMCBidG4tc20gZmlsZS1hZGQgYWRkLWV2ZW50XFxcIiBkYXRhLXRvZ2dsZT1cXFwibW9kYWxcXFwiIGRhdGEtYmFja2Ryb3A9XFxcInN0YXRpY1xcXCI+QWRkIEV2ZW50PC9hPlxcbiAgICA8JSB9ICU+XFxuICA8L2gyPlxcbjwvZGl2PlxcblxcbjxkaXYgaWQ9XFxcImV2ZW50LW1vZGFsLWFkZFxcXCI+PC9kaXY+XFxuXFxuPGRpdiBjbGFzcz1cXFwidGFzay1zY3JvbGxcXFwiPlxcblxcbiAgPCUgaWYgKGV2ZW50cy5sZW5ndGggPT0gMCkgeyAlPlxcblxcbiAgPGRpdiBjbGFzcz1cXFwiZXZlbnQgYm9yZGVyLWxlZnRcXFwiIGRhdGEtaWQ9XFxcIm51bGxcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJldmVudC10aXRsZVxcXCI+XFxuICAgICAgTm8gZXZlbnRzIHNjaGVkdWxlZC5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG5cXG4gIDwlIH0gZWxzZSB7ICU+XFxuXFxuICA8JSBfLmVhY2goZXZlbnRzLCBmdW5jdGlvbiAoZXZlbnQsIGl0ZXJhdG9yKSB7ICU+XFxuICA8ZGl2IGNsYXNzPVxcXCJldmVudCBib3JkZXItbGVmdFxcXCIgZGF0YS1pZD1cXFwiPCU9IGV2ZW50LmlkICU+XFxcIj5cXG4gICAgPCUgaWYgKHVzZXIpIHsgJT5cXG4gICAgPGRpdiBjbGFzcz1cXFwiZXZlbnQtYnV0dG9uIHB1bGwtcmlnaHRcXFwiPlxcbiAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ0biBidG4tYzIgYnRuLXNtIHJzdnAgZGF0YS1ldmVudC1mbGFnLTwlPSBldmVudC5yc3ZwICU+XFxcIiBkYXRhLWdvaW5nLXRleHQ9XFxcIjxpIGNsYXNzPSdmYSBmYS1jaGVjayc+PC9pPiBJJ20gZ29pbmdcXFwiIGRhdGEtcnN2cC10ZXh0PVxcXCJSU1ZQXFxcIiBkYXRhLWhvdmVyLXRleHQ9XFxcIkNhbmNlbCBSU1ZQXFxcIj48JSBpZiAoZXZlbnQucnN2cCkgeyAlPjxpIGNsYXNzPSdmYSBmYS1jaGVjayc+PC9pPiBJJ20gZ29pbmc8JSB9IGVsc2UgeyAlPlJTVlA8JSB9ICU+PC9idXR0b24+XFxuICAgIDwvZGl2PlxcbiAgICA8JSB9ICU+XFxuICAgIDxkaXYgY2xhc3M9XFxcImV2ZW50LXRpdGxlXFxcIj5cXG4gICAgICA8JS0gZXZlbnQudGl0bGUgJT5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcImV2ZW50LWRlc2NyaXB0aW9uXFxcIj5cXG4gICAgICA8JS0gZXZlbnQuZGVzY3JpcHRpb24gJT5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcImV2ZW50LXRhZ1xcXCI+XFxuICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWNhbGVuZGFyXFxcIj48L2k+XFxuICAgICAgPHNwYW4gY2xhc3M9XFxcImJveC1pY29uLXRleHRcXFwiPlxcbiAgICAgIDwhLS0gZGF5IC0tPlxcbiAgICAgIDwlIHZhciBzdCA9IG5ldyBEYXRlKGV2ZW50LnN0YXJ0KTsgdmFyIGV0ID0gbmV3IERhdGUoZXZlbnQuZW5kKTsgJT5cXG4gICAgICA8JT0gc3QudG9Mb2NhbGVEYXRlU3RyaW5nKCkgJT5cXG4gICAgICA8JSBpZiAoc3QudG9Mb2NhbGVEYXRlU3RyaW5nKCkgIT0gZXQudG9Mb2NhbGVEYXRlU3RyaW5nKCkpIHsgJT5cXG4gICAgICAtIDwlPSBldC50b0xvY2FsZURhdGVTdHJpbmcoKSAlPlxcbiAgICAgIDwlIH0gJT5cXG4gICAgICA8IS0tIHRpbWUgLS0+XFxuICAgICAgPCU9IHN0LnRvTG9jYWxlVGltZVN0cmluZygpICU+XFxuICAgICAgPCUgaWYgKHN0LnRvTG9jYWxlRGF0ZVN0cmluZygpID09IGV0LnRvTG9jYWxlRGF0ZVN0cmluZygpKSB7ICU+XFxuICAgICAgLSA8JT0gZXQudG9Mb2NhbGVUaW1lU3RyaW5nKCkgJT5cXG4gICAgICA8JSB9ICU+XFxuICAgICAgPC9zcGFuPlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiZXZlbnQtdGFnXFxcIj5cXG4gICAgICA8c3BhbiBjbGFzcz1cXFwiZmEgZmEtbWFwLW1hcmtlclxcXCI+PC9zcGFuPlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJib3gtaWNvbi10ZXh0XFxcIj5cXG4gICAgICA8JT0gZXZlbnQubG9jYXRpb24gJT5cXG4gICAgICA8L3NwYW4+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJldmVudC10YWdcXFwiPlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJldmVudC1pY29uLWNlbnRlclxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLW1hbGVcXFwiPjwvaT48L3NwYW4+XFxuICAgICAgPHNwYW4gY2xhc3M9XFxcImJveC1pY29uLXRleHQgZXZlbnQtcGVvcGxlXFxcIj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJldmVudC1wZW9wbGUtbnVtYmVyXFxcIj48JT0gZXZlbnQucnN2cHMubGVuZ3RoICU+PC9zcGFuPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcImV2ZW50LXBlb3BsZS10ZXh0XFxcIiBkYXRhLXBsdXJhbD1cXFwicGVvcGxlXFxcIiBkYXRhLXNpbmd1bGFyPVxcXCJwZXJzb25cXFwiPlxcbiAgICAgICAgPCUgaWYgKGV2ZW50LnJzdnBzLmxlbmd0aCA9PSAxKSB7ICU+XFxuICAgICAgICAgIHBlcnNvblxcbiAgICAgICAgPCUgfSBlbHNlIHsgJT5cXG4gICAgICAgICAgcGVvcGxlXFxuICAgICAgICA8JSB9ICU+XFxuICAgICAgICA8L3NwYW4+XFxuICAgICAgICBnb2luZ1xcbiAgICAgIDwvc3Bhbj5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG4gIDwlIH0pOyAlPlxcblxcbiAgPCUgfSAlPlxcbjwvZGl2PlxcblwiO1xuIiwiXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgRXZlbnRMaXN0VGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvZXZlbnRfY29sbGVjdGlvbl92aWV3X3RlbXBsYXRlLmh0bWwnKTtcblxuXG52YXIgRXZlbnRDb2xsZWN0aW9uVmlldyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcblxuICBlbDogXCIjZXZlbnQtbGlzdC13cmFwcGVyXCIsXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV2ZW50c0pTT04gPSB7XG4gICAgICBldmVudHM6IHRoaXMub3B0aW9ucy5jb2xsZWN0aW9uLnRvSlNPTigpLFxuICAgICAgcHJvamVjdElkOiB0aGlzLm9wdGlvbnMucHJvamVjdElkLFxuICAgICAgdXNlcjogd2luZG93LmNhY2hlLmN1cnJlbnRVc2VyXG4gICAgfVxuXG4gICAgdGhpcy5jb21waWxlZFRlbXBsYXRlID0gXy50ZW1wbGF0ZShFdmVudExpc3RUZW1wbGF0ZSkoZXZlbnRzSlNPTik7XG4gICAgdGhpcy4kZWwuaHRtbCh0aGlzLmNvbXBpbGVkVGVtcGxhdGUpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgY2xlYW51cDogZnVuY3Rpb24gKCkge1xuICAgIHJlbW92ZVZpZXcodGhpcyk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRDb2xsZWN0aW9uVmlldztcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8Zm9ybSBpZD1cXFwiZXZlbnQtZm9ybVxcXCIgY2xhc3M9XFxcImZvcm0taG9yaXpvbnRhbFxcXCIgc3R5bGU9XFxcImRpc3BsYXk6IGJsb2NrO1xcXCI+XFxuXFxuICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1ib2R5XFxcIj5cXG5cXG4gICAgPGZpZWxkc2V0PlxcblxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwiZXZlbnQtdGl0bGVcXFwiIGNsYXNzPVxcXCJjb2wtbGctMiBjb250cm9sLWxhYmVsXFxcIj5UaXRsZTwvbGFiZWw+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbGctMTBcXFwiPlxcbiAgICAgICAgICA8aW5wdXQgaWQ9XFxcImV2ZW50LXRpdGxlXFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBkYXRhLXZhbGlkYXRlPVxcXCJlbXB0eSxjb3VudDEwMFxcXCI+XFxuICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJoZWxwLWJsb2NrIGVycm9yLWVtcHR5XFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI+WW91IG11c3QgZW50ZXIgYW4gZXZlbnQgdGl0bGUuPC9zcGFuPlxcbiAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaGVscC1ibG9jayBlcnJvci1jb3VudDEwMFxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPlRoZSBldmVudCB0aXRsZSBtdXN0IGJlIGxlc3MgdGhhbiAxMDAgY2hhcmFjdGVycy48L3NwYW4+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcImV2ZW50LWRlc2NyaXB0aW9uXFxcIiBjbGFzcz1cXFwiY29sLWxnLTIgY29udHJvbC1sYWJlbFxcXCI+RGVzY3JpcHRpb248L2xhYmVsPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLWxnLTEwXFxcIj5cXG4gICAgICAgICAgPHRleHRhcmVhIGlkPVxcXCJldmVudC1kZXNjcmlwdGlvblxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgdHlwZT1cXFwidGV4dFxcXCIgZGF0YS12YWxpZGF0ZT1cXFwiZW1wdHksY291bnQyNTBcXFwiIHJvd3M9XFxcIjNcXFwiPjwvdGV4dGFyZWE+XFxuICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJoZWxwLWJsb2NrIGVycm9yLWVtcHR5XFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI+WW91IG11c3QgZW50ZXIgYW4gZXZlbnQgZGVzY3JpcHRpb24uPC9zcGFuPlxcbiAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaGVscC1ibG9jayBlcnJvci1jb3VudDEwMFxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPlRoZSBldmVudCBkZXNjcmlwdGlvbiBtdXN0IGJlIGxlc3MgdGhhbiAyNTAgY2hhcmFjdGVycy48L3NwYW4+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcImV2ZW50LXN0YXJ0XFxcIiBjbGFzcz1cXFwiY29sLW1kLTIgY29udHJvbC1sYWJlbFxcXCI+VGltZTwvbGFiZWw+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMiBwYWRkaW5nLXJpZ2h0LW5vbmVcXFwiPlxcbiAgICAgICAgICA8aW5wdXQgaWQ9XFxcImV2ZW50LXN0YXJ0XFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sIGZ1bGx3aWR0aFxcXCIgdHlwZT1cXFwidGV4dFxcXCI+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0yIHBhZGRpbmctbm9uZVxcXCIgaWQ9XFxcImRpdi1ldmVudC1zdGFydC10aW1lXFxcIj5cXG4gICAgICAgICAgPGlucHV0IGlkPVxcXCJldmVudC1zdGFydC10aW1lXFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sIGZ1bGx3aWR0aCB0aW1lcGlja2VyXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTEgY29udHJvbC1sYWJlbFxcXCI+XFxuICAgICAgICAgIHRvXFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0yIHBhZGRpbmctbm9uZVxcXCIgaWQ9XFxcImRpdi1ldmVudC1lbmQtdGltZVxcXCI+XFxuICAgICAgICAgIDxpbnB1dCBpZD1cXFwiZXZlbnQtZW5kLXRpbWVcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2wgZnVsbHdpZHRoIHRpbWVwaWNrZXJcXFwiIHR5cGU9XFxcInRleHRcXFwiPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMiBwYWRkaW5nLW5vbmVcXFwiPlxcbiAgICAgICAgICA8aW5wdXQgaWQ9XFxcImV2ZW50LWVuZFxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbCBmdWxsd2lkdGhcXFwiIHR5cGU9XFxcInRleHRcXFwiPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuXFxuICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCIgc3R5bGU9XFxcIm1hcmdpbi10b3A6IC0xMHB4O1xcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMTAgY29sLW1kLW9mZnNldC0yIGV2ZW50LXRpbWV6b25lXFxcIj5cXG4gICAgICAgICAgWW91ciB0aW1lIHpvbmUgaXMgc2V0IHRvIDxzcGFuIGNsYXNzPVxcXCJ0aW1lem9uZVxcXCI+Tm9uZTwvc3Bhbj4uXFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcImV2ZW50LWxvY2F0aW9uXFxcIiBjbGFzcz1cXFwiY29sLWxnLTIgY29udHJvbC1sYWJlbFxcXCI+TG9jYXRpb248L2xhYmVsPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLWxnLTEwXFxcIj5cXG4gICAgICAgICAgPGlucHV0IGlkPVxcXCJldmVudC1sb2NhdGlvblxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgdHlwZT1cXFwidGV4dFxcXCIgZGF0YS12YWxpZGF0ZT1cXFwiZW1wdHlcXFwiPlxcbiAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaGVscC1ibG9jayBlcnJvci1lbXB0eVxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPllvdSBtdXN0IGVudGVyIGFuIGV2ZW50IGxvY2F0aW9uLjwvc3Bhbj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcblxcbiAgICA8L2ZpZWxkc2V0PlxcbiAgPC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1mb290ZXJcXFwiPlxcbiAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tYzAgd2l6YXJkLWNhbmNlbFxcXCIgZGF0YS1kaXNtaXNzPVxcXCJtb2RhbFxcXCI+Q2FuY2VsPC9idXR0b24+XFxuICAgIDxidXR0b24gY2xhc3M9XFxcImJ0biBidG4tYzJcXFwiIHR5cGU9XFxcInN1Ym1pdFxcXCI+QWRkIEV2ZW50PC9idXR0b24+XFxuICA8L2Rpdj5cXG5cXG48L2Zvcm0+XFxuXCI7XG4iLCJcbnZhciBCb290c3RyYXAgPSByZXF1aXJlKCdib290c3RyYXAnKTtcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL21peGlucy91dGlsaXRpZXMnKTtcbnZhciBEYXRlUGlja2VyID0gcmVxdWlyZSgnYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyL3NyYy9qcy9ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXInKTtcbnZhciBUaW1lUGlja2VyID0gcmVxdWlyZSgndGltZXBpY2tlci9qcXVlcnkudGltZXBpY2tlcicpO1xudmFyIEV2ZW50c0NvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9lbnRpdGllcy9ldmVudHMvZXZlbnRzX2NvbGxlY3Rpb24nKTtcbnZhciBFdmVudEZvcm1UZW1wbGF0ZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy9ldmVudF9mb3JtX3RlbXBsYXRlLmh0bWwnKTtcblxuXG52YXIgRXZlbnRGb3JtVmlldyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcblxuICBlbDogXCIjZXZlbnQtbGlzdC13cmFwcGVyXCIsXG5cbiAgZXZlbnRzOiB7XG4gICAgLy8gZmllbGQgdmFsaWRhdGlvblxuICAgIFwiYmx1ciAjZXZlbnQtdGl0bGVcIiAgICAgICA6IFwidlwiLFxuICAgIFwiYmx1ciAjZXZlbnQtZGVzY3JpcHRpb25cIiA6IFwidlwiLFxuICAgIFwiYmx1ciAjZXZlbnQtbG9jYXRpb25cIiAgICA6IFwidlwiLFxuICAgIC8vIGZvcm0gc3VibWlzc2lvblxuICAgIFwic3VibWl0ICNldmVudC1mb3JtXCIgICAgICA6IFwicG9zdFwiXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuXG4gIGluaXRpYWxpemVUaW1lWm9uZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBvZmZzZXQgPSAobmV3IERhdGUoKSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICB2YXIgdGltZXpvbmVzID0ge1xuICAgICAgICAnLTEyJzogJ1BhY2lmaWMvS3dhamFsZWluJyxcbiAgICAgICAgJy0xMSc6ICdQYWNpZmljL1NhbW9hJyxcbiAgICAgICAgJy0xMCc6ICdQYWNpZmljL0hvbm9sdWx1JyxcbiAgICAgICAgJy05JzogJ0FtZXJpY2EvSnVuZWF1JyxcbiAgICAgICAgJy04JzogJ0FtZXJpY2EvTG9zIEFuZ2VsZXMnLFxuICAgICAgICAnLTcnOiAnQW1lcmljYS9EZW52ZXInLFxuICAgICAgICAnLTYnOiAnQW1lcmljYS9NZXhpY28gQ2l0eScsXG4gICAgICAgICctNSc6ICdBbWVyaWNhL05ldyBZb3JrJyxcbiAgICAgICAgJy00JzogJ0FtZXJpY2EvQ2FyYWNhcycsXG4gICAgICAgICctMy41JzogJ0FtZXJpY2EvU3QgSm9obnMnLFxuICAgICAgICAnLTMnOiAnQW1lcmljYS9BcmdlbnRpbmEvQnVlbm9zIEFpcmVzJyxcbiAgICAgICAgJy0yJzogJ0F0bGFudGljL0F6b3JlcycsXG4gICAgICAgICctMSc6ICdBdGxhbnRpYy9Bem9yZXMnLFxuICAgICAgICAnMCc6ICdFdXJvcGUvTG9uZG9uJyxcbiAgICAgICAgJzEnOiAnRXVyb3BlL1BhcmlzJyxcbiAgICAgICAgJzInOiAnRXVyb3BlL0hlbHNpbmtpJyxcbiAgICAgICAgJzMnOiAnRXVyb3BlL01vc2NvdycsXG4gICAgICAgICczLjUnOiAnQXNpYS9UZWhyYW4nLFxuICAgICAgICAnNCc6ICdBc2lhL0Jha3UnLFxuICAgICAgICAnNC41JzogJ0FzaWEvS2FidWwnLFxuICAgICAgICAnNSc6ICdBc2lhL0thcmFjaGknLFxuICAgICAgICAnNS41JzogJ0FzaWEvQ2FsY3V0dGEnLFxuICAgICAgICAnNic6ICdBc2lhL0NvbG9tYm8nLFxuICAgICAgICAnNyc6ICdBc2lhL0Jhbmdrb2snLFxuICAgICAgICAnOCc6ICdBc2lhL1NpbmdhcG9yZScsXG4gICAgICAgICc5JzogJ0FzaWEvVG9reW8nLFxuICAgICAgICAnOS41JzogJ0F1c3RyYWxpYS9EYXJ3aW4nLFxuICAgICAgICAnMTAnOiAnUGFjaWZpYy9HdWFtJyxcbiAgICAgICAgJzExJzogJ0FzaWEvTWFnYWRhbicsXG4gICAgICAgICcxMic6ICdBc2lhL0thbWNoYXRrYSdcbiAgICB9O1xuICAgIC8vIGNyZWF0ZSBhIHRpbWV6b25lIHN0cmluZyBmb3IgZGlzcGxheVxuICAgIHZhciB0eiA9IHRpbWV6b25lc1stb2Zmc2V0IC8gNjBdO1xuICAgIHR6ICs9ICcgKCc7XG4gICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICB0eiArPSAnKyc7XG4gICAgfVxuICAgIHR6ICs9ICgtb2Zmc2V0LzYwKSArICc6MDApJztcbiAgICAkKCcudGltZXpvbmUnKS5odG1sKHR6KTtcblxuICAgIC8vIHNldCBpbnB1dCBwaWNrZXJzIGZvciB0aW1lXG4gICAgJCgnI2V2ZW50LXN0YXJ0LXRpbWUnKS50aW1lcGlja2VyKHtcbiAgICAgIHNlbGVjdE9uQmx1cjogdHJ1ZSxcbiAgICAgIGFwcGVuZFRvOiAnI2Rpdi1ldmVudC1zdGFydC10aW1lJ1xuICAgIH0pO1xuICAgICQoJyNldmVudC1lbmQtdGltZScpLnRpbWVwaWNrZXIoe1xuICAgICAgc2VsZWN0T25CbHVyOiB0cnVlLFxuICAgICAgc2hvd0R1cmF0aW9uOiB0cnVlLFxuICAgICAgZHVyYXRpb25UaW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICgkKCcjZXZlbnQtc3RhcnQtdGltZScpLnZhbCgpKTtcbiAgICAgIH0sXG4gICAgICBhcHBlbmRUbzogJyNkaXYtZXZlbnQtZW5kLXRpbWUnXG4gICAgfSk7XG4gICAgLy8gZ2V0IHRoZSBzdGFydCB0aW1lIGJ5IHJvdW5kaW5nIHRoZSBjdXJyZW50IHRpbWUgdG8gdGhlIG5lYXJlc3QgMzAgbWludXRlc1xuICAgIHZhciBjb2VmZiA9IDEwMDAgKiA2MCAqIDMwO1xuICAgIHZhciBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpOyAgLy9vciB1c2UgYW55IG90aGVyIGRhdGVcbiAgICBzdGFydFRpbWUgPSBuZXcgRGF0ZShNYXRoLmNlaWwoc3RhcnRUaW1lLmdldFRpbWUoKSAvIGNvZWZmKSAqIGNvZWZmKVxuICAgIC8vIHRoZSBpbml0aWFsIGVuZCB0aW1lIHNob3VsZCBiZSAxIGhvdXIgYWZ0ZXIgdGhlIGluaXRpYWwgc3RhcnQgdGltZVxuICAgIHZhciBlbmRUaW1lID0gbmV3IERhdGUoc3RhcnRUaW1lLmdldFRpbWUoKSArIDEwMDAqNjAqNjApO1xuICAgICQoJyNldmVudC1zdGFydC10aW1lJykudGltZXBpY2tlcignc2V0VGltZScsIHN0YXJ0VGltZSk7XG4gICAgJCgnI2V2ZW50LWVuZC10aW1lJykudGltZXBpY2tlcignc2V0VGltZScsIGVuZFRpbWUpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgZGF0ZSBwaWNrZXJzXG4gICAgdmFyIHN0YXJ0RGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgJCgnI2V2ZW50LXN0YXJ0JykuZGF0ZXRpbWVwaWNrZXIoe1xuICAgICAgcGlja0RhdGU6IHRydWUsXG4gICAgICBwaWNrVGltZTogZmFsc2UsXG4gICAgICBzdGFydERhdGU6IHN0YXJ0RGF0ZVxuICAgIH0pO1xuICAgICQoJyNldmVudC1lbmQnKS5kYXRldGltZXBpY2tlcih7XG4gICAgICBwaWNrRGF0ZTogdHJ1ZSxcbiAgICAgIHBpY2tUaW1lOiBmYWxzZSxcbiAgICAgIHN0YXJ0RGF0ZTogc3RhcnREYXRlXG4gICAgfSk7XG4gICAgLy8gU2V0IHRoZSBpbml0aWFsIGRhdGUgdG8gbm93ICh0b2RheSlcbiAgICAkKCcjZXZlbnQtc3RhcnQnKS5kYXRhKFwiRGF0ZVRpbWVQaWNrZXJcIikuc2V0RGF0ZShzdGFydERhdGUpO1xuICAgICQoJyNldmVudC1lbmQnKS5kYXRhKFwiRGF0ZVRpbWVQaWNrZXJcIikuc2V0RGF0ZShzdGFydERhdGUpO1xuXG4gICAgLy8gV2hlbiB0aGUgc3RhcnQgZGF0ZSBjaGFuZ2VzLFxuICAgIC8vIHNldCB0aGUgZW5kIGRhdGUgdG8gYmUgYXQgbGVhc3QgdGhlIHN0YXJ0IGRhdGVcbiAgICAkKCcjZXZlbnQtc3RhcnQnKS5vbihcImNoYW5nZS5kcFwiLGZ1bmN0aW9uIChlKSB7XG4gICAgICAkKCcjZXZlbnQtZW5kJykuZGF0YShcIkRhdGVUaW1lUGlja2VyXCIpLnNldFN0YXJ0RGF0ZShlLmRhdGUpO1xuICAgICAgdmFyIGRpZmYgPSAkKCcjZXZlbnQtZW5kJykuZGF0YShcIkRhdGVUaW1lUGlja2VyXCIpLmdldERhdGUoKS51bml4KCkgLSBlLmRhdGUudW5peCgpO1xuICAgICAgaWYgKGRpZmYgPCAwKSB7XG4gICAgICAgICQoJyNldmVudC1lbmQnKS5kYXRhKFwiRGF0ZVRpbWVQaWNrZXJcIikuc2V0RGF0ZShlLmRhdGUpO1xuICAgICAgfVxuICAgICAgJChlLmN1cnJlbnRUYXJnZXQpLmJsdXIoKTtcbiAgICB9KTtcbiAgICAvLyBXaGVuIHRoZSBlbmQgZGF0ZSBjaGFuZ2VzLFxuICAgIC8vIEVuYWJsZS9kaXNhYmxlIGR1cmF0aW9uIGluIHRoZSB0aW1lcGlja2VyIGJhc2VkIG9uIHdoZXRoZXIgdGhlXG4gICAgLy8gc3RhcnQgYW5kIGVuZCBkYXRlcyBtYXRjaFxuICAgICQoJyNldmVudC1lbmQnKS5vbihcImNoYW5nZS5kcFwiLGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgZGlmZiA9IGUuZGF0ZS51bml4KCkgLSAkKCcjZXZlbnQtc3RhcnQnKS5kYXRhKFwiRGF0ZVRpbWVQaWNrZXJcIikuZ2V0RGF0ZSgpLnVuaXgoKTtcbiAgICAgIGlmIChkaWZmID09PSAwKSB7XG4gICAgICAgICQoJyNldmVudC1lbmQtdGltZScpLnRpbWVwaWNrZXIoJ29wdGlvbicsICdzaG93RHVyYXRpb24nLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICQoJyNldmVudC1lbmQtdGltZScpLnRpbWVwaWNrZXIoJ29wdGlvbicsICdzaG93RHVyYXRpb24nLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICAkKGUuY3VycmVudFRhcmdldCkuYmx1cigpO1xuICAgIH0pO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciB0ZW1wbGF0ZSA9IF8udGVtcGxhdGUoRXZlbnRGb3JtVGVtcGxhdGUpO1xuICAgIHRoaXMuJGVsLmh0bWwodGVtcGxhdGUpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZVRpbWVab25lKCk7XG4gIH0sXG5cbiAgdjogZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gdmFsaWRhdGUoZSk7XG4gIH0sXG5cbiAgcG9zdDogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgLy8gdmFsaWRhdGUgdGhlIGZpZWxkczsgaWYgYW55IGlzIG5vdCB2YWxpZGF0ZWQsIGFib3J0IGZvcm0gc3VibWlzc2lvblxuICAgIHZhciB2YWxpZGF0ZUlkcyA9IFsnI2V2ZW50LXRpdGxlJywgJyNldmVudC1kZXNjcmlwdGlvbicsICcjZXZlbnQtbG9jYXRpb24nXTtcbiAgICB2YXIgYWJvcnQgPSBmYWxzZTtcbiAgICBmb3IgKGkgaW4gdmFsaWRhdGVJZHMpIHtcbiAgICAgIHZhciBpQWJvcnQgPSB2YWxpZGF0ZSh7IGN1cnJlbnRUYXJnZXQ6IHZhbGlkYXRlSWRzW2ldIH0pO1xuICAgICAgYWJvcnQgPSBhYm9ydCB8fCBpQWJvcnQ7XG4gICAgfVxuICAgIGlmIChhYm9ydCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHByb2Nlc3MgdGhlIGZvcm07IGNyZWF0ZSB0aW1lIG9iamVjdHNcbiAgICB2YXIgc3RhcnQgPSAkKCcjZXZlbnQtc3RhcnQnKS5kYXRhKFwiRGF0ZVRpbWVQaWNrZXJcIikuZ2V0RGF0ZSgpLmNsb25lKCkudG9EYXRlKCk7XG4gICAgdmFyIGVuZCA9ICQoJyNldmVudC1zdGFydCcpLmRhdGEoXCJEYXRlVGltZVBpY2tlclwiKS5nZXREYXRlKCkuY2xvbmUoKS50b0RhdGUoKTtcbiAgICBzdGFydCA9ICQoJyNldmVudC1zdGFydC10aW1lJykudGltZXBpY2tlcignZ2V0VGltZScsIHN0YXJ0KTtcbiAgICBlbmQgPSAkKCcjZXZlbnQtZW5kLXRpbWUnKS50aW1lcGlja2VyKCdnZXRUaW1lJywgZW5kKTtcblxuICAgIHZhciBkYXRhID0ge1xuICAgICAgdGl0bGUgICAgICAgOiAkKFwiI2V2ZW50LXRpdGxlXCIpLnZhbCgpLFxuICAgICAgZGVzY3JpcHRpb24gOiAkKFwiI2V2ZW50LWRlc2NyaXB0aW9uXCIpLnZhbCgpLFxuICAgICAgc3RhcnQgICAgICAgOiBzdGFydC50b0lTT1N0cmluZygpLFxuICAgICAgZW5kICAgICAgICAgOiBlbmQudG9JU09TdHJpbmcoKSxcbiAgICAgIGxvY2F0aW9uICAgIDogJChcIiNldmVudC1sb2NhdGlvblwiKS52YWwoKSxcbiAgICAgIHByb2plY3RJZCAgIDogdGhpcy5vcHRpb25zLnByb2plY3RJZFxuICAgIH07XG5cbiAgICB0aGlzLmNvbGxlY3Rpb24udHJpZ2dlcihcImV2ZW50OnNhdmVcIiwgZGF0YSk7XG4gIH0sXG5cbiAgY2xlYW51cDogZnVuY3Rpb24gKCkge1xuICAgIHJlbW92ZVZpZXcodGhpcyk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRGb3JtVmlldztcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8Zm9vdGVyIGNsYXNzPVxcXCJjb250YWluZXJcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTEyXFxcIj5cXG4gICAgICA8YSBocmVmPVxcXCJodHRwczovL2dpdGh1Yi5jb20vMThGL21pZGFzXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtZ2l0aHViXFxcIj48L2k+IHBvd2VyZWQgYnkgbWlkYXM8L2E+XFxuICAgICAgPCUgaWYgKGxvZ2luLnRlcm1zLmVuYWJsZWQgPT09IHRydWUpIHsgJT5cXG4gICAgICB8XFxuICAgICAgPGEgaHJlZj1cXFwiPCU9IGxvZ2luLnRlcm1zLmxpbmsgJT5cXFwiPjwlPSBsb2dpbi50ZXJtcy5uYW1lICU+PC9hPlxcbiAgICAgIDwlIH0gJT5cXG4gICAgICB8XFxuICAgICAgTG9jYXRpb25zIHByb3ZpZGVkIGJ5IDxhIGhyZWY9XFxcImh0dHA6Ly93d3cuZ2VvbmFtZXMub3JnL1xcXCI+R2VvTmFtZXM8L2E+LlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZm9vdGVyPlxcblwiO1xuIiwiXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgTG9naW4gPSByZXF1aXJlKCcuLi8uLi8uLi9jb25maWcvbG9naW4uanNvbicpO1xudmFyIEZvb3RlclRlbXBsYXRlID0gcmVxdWlyZSgnLi4vdGVtcGxhdGVzL2Zvb3Rlcl90ZW1wbGF0ZS5odG1sJyk7XG5cblxudmFyIEZvb3RlclZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG5cbiAgZXZlbnRzOiB7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBkYXRhID0ge1xuICAgICAgdmVyc2lvbjogdmVyc2lvbixcbiAgICAgIGxvZ2luOiBMb2dpblxuICAgIH07XG4gICAgdmFyIGNvbXBpbGVkVGVtcGxhdGUgPSBfLnRlbXBsYXRlKEZvb3RlclRlbXBsYXRlKShkYXRhKTtcbiAgICB0aGlzLiRlbC5odG1sKGNvbXBpbGVkVGVtcGxhdGUpO1xuXG4gICAgZnVuY3Rpb24gcmVzaXplRWxlbWVudHMoKSB7XG4gICAgICBoZWFkZXJIZWlnaHQgPSAkKCcubmF2YmFyJykuaGVpZ2h0KCk7XG4gICAgICBmb290ZXJIZWlnaHQgPSAkKCdmb290ZXInKS5oZWlnaHQoKTtcbiAgICAgIGlmICgoJChkb2N1bWVudC5ib2R5KS5oZWlnaHQoKSArIGZvb3RlckhlaWdodCkgPCAkKHdpbmRvdykuaGVpZ2h0KCkpIHtcbiAgICAgICAgc2VsZi4kZWwuYWRkQ2xhc3MoJ25hdmJhci1maXhlZC1ib3R0b20nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuJGVsLnJlbW92ZUNsYXNzKCduYXZiYXItZml4ZWQtYm90dG9tJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc2l6ZUVsZW1lbnRzKCk7XG4gICAgJChcIi5jb250YWluZXJcIikuYmluZChcIkRPTVN1YnRyZWVNb2RpZmllZFwiLCByZXNpemVFbGVtZW50cyk7XG4gIH0sXG5cbiAgY2xlYW51cDogZnVuY3Rpb24gKCkge1xuICAgIHJlbW92ZVZpZXcodGhpcyk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRm9vdGVyVmlldztcblxuIiwiXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBhc3luYyA9IHJlcXVpcmUoJ2FzeW5jJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vbWl4aW5zL3V0aWxpdGllcycpO1xudmFyIEJhc2VDb250cm9sbGVyID0gcmVxdWlyZSgnLi4vLi4vLi4vYmFzZS9iYXNlX2NvbnRyb2xsZXInKTtcbnZhciBIb21lVmlldyA9IHJlcXVpcmUoJy4uL3ZpZXdzL2hvbWVfdmlldycpO1xuXG5cbkhvbWUgPSB7fTtcblxuSG9tZS5Db250cm9sbGVyID0gQmFzZUNvbnRyb2xsZXIuZXh0ZW5kKHtcblxuICBldmVudHM6IHtcbiAgfSxcblxuICAvLyBUaGUgaW5pdGlhbGl6ZSBtZXRob2QgaXMgbWFpbmx5IHVzZWQgZm9yIGV2ZW50IGJpbmRpbmdzIChmb3IgZWZmaWNpZW5jeSlcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5ob21lVmlldyA9IG5ldyBIb21lVmlldygpLnJlbmRlcigpO1xuICB9LFxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLz0gVXRpbGl0eSBNZXRob2RzXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBjbGVhbnVwOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5ob21lVmlldykgdGhpcy5ob21lVmlldy5jbGVhbnVwKCk7XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBIb21lLkNvbnRyb2xsZXI7XG5cbiIsIm1vZHVsZS5leHBvcnRzID0gXCIgIDxkaXYgY2xhc3M9XFxcImNvbnRhaW5lci1mbHVpZCBwYWRkaW5nLWxlZnQtbm9uZSBwYWRkaW5nLXJpZ2h0LW5vbmVcXFwiIGlkPVxcXCJob21lXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwic3BsYXNoLXdyYXBcXFwiIGlkPVxcXCJzcGxhc2gxXFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJzcGxhc2gtY2VudGVyXFxcIj5cXG4gICAgICA8aDEgY2xhc3M9XFxcInRleHQtY2VudGVyXFxcIiBkYXRhLWkxOG49XFxcImhvbWUuaGVhZGxpbmVcXFwiPkhhc3NsZSBGcmVlIENvbGxhYm9yYXRpb248L2gxPlxcbiAgICAgIDxwIGNsYXNzPVxcXCJsZWFkIHRleHQtY2VudGVyXFxcIiBkYXRhLWkxOG49XFxcImhvbWUuc3ViaGVhZFxcXCI+V29yayB3aXRoIG90aGVyIGZlZGVyYWwgZW1wbG95ZWVzIG9uIHByb2plY3RzIHlvdSBhcmUgcGFzc2lvbmF0ZSBhYm91dC48L3A+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwidGV4dC1jZW50ZXJcXFwiPjxhIGNsYXNzPVxcXCJsb2dpblxcXCIgaHJlZj1cXFwiL2F1dGhcXFwiPjxidXR0b24gY2xhc3M9XFxcImJ0biBidG4tbWlkYXNcXFwiIGlkPVxcXCJjZW50ZXJcXFwiIGRhdGEtaTE4bj1cXFwiaG9tZS5jYWxsVG9BY3Rpb25cXFwiPkdldCBTdGFydGVkIFRvZGF5PC9idXR0b24+PC9hPjwvZGl2PlxcbiAgICAgIDwhLS1kaXYgY2xhc3M9XFxcInRleHQtY2VudGVyIHRleHQtb24tZGFyayB0ZXh0LW11dGVkXFxcIj48YSBocmVmPVxcXCIjXFxcIj5MZWFybiBNb3JlPC9hPjwvZGl2LS0+XFxuICAgIDwvZGl2PjwhLS0gLyNzcGxhc2ggLS0+XFxuICAgIDwvZGl2PjwhLS0gLy5zcGxhc2gtd3JhcCAtLT5cXG5cXG4gIDxkaXYgY2xhc3M9XFxcImlubGluZS1ibG9jay1jZW50ZXJcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ2YWx1ZS1wcm9wXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImljb25cXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1jb21tZW50c1xcXCI+PC9pPjwvZGl2PiA8IS0tIGljb24gLS0+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0ZXh0XFxcIj5NYWtlIENvbm5lY3Rpb25zPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ2YWx1ZS1wcm9wXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImljb25cXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1jb2dzXFxcIj48L2k+PC9kaXY+IDwhLS0gaWNvbiAtLT5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInRleHRcXFwiPkJ1aWxkIFNraWxsczwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwidmFsdWUtcHJvcFxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpY29uXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtbGluZS1jaGFydFxcXCI+PC9pPjwvZGl2PiA8IS0tIGljb24gLS0+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0ZXh0XFxcIj5NYWtlIGEgRGlmZmVyZW5jZTwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwidGV4dC1jZW50ZXJcXFwiPjxhIGNsYXNzPVxcXCJsb2dpblxcXCIgaHJlZj1cXFwiL2F1dGhcXFwiPjxidXR0b24gY2xhc3M9XFxcImJ0biBidG4tbWlkYXNcXFwiIGlkPVxcXCJjZW50ZXJcXFwiIGRhdGEtaTE4bj1cXFwiaG9tZS5jYWxsVG9BY3Rpb25cXFwiPkdldCBTdGFydGVkIFRvZGF5PC9idXR0b24+PC9hPjwvZGl2PlxcblxcblxcbiAgPC9kaXY+PCEtLSAvLmNvbnRhaW5lci1mbHVpZC0tPlxcblwiO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIGFzeW5jID0gcmVxdWlyZSgnYXN5bmMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uL21peGlucy91dGlsaXRpZXMnKTtcbnZhciBVSUNvbmZpZyA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbmZpZy91aS5qc29uJyk7XG52YXIgTG9naW4gPSByZXF1aXJlKCcuLi8uLi8uLi9jb25maWcvbG9naW4uanNvbicpO1xudmFyIExvZ2luQ29udHJvbGxlciA9IHJlcXVpcmUoJy4uLy4uL2xvZ2luL2NvbnRyb2xsZXJzL2xvZ2luX2NvbnRyb2xsZXInKTtcbnZhciBIb21lVGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvaG9tZV92aWV3X3RlbXBsYXRlLmh0bWwnKTtcblxuXG52YXIgSG9tZVZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG5cbiAgZWw6IFwiI2NvbnRhaW5lclwiLFxuXG4gIGV2ZW50czoge1xuICAgICdjbGljayAubG9naW4nICAgICAgICAgIDogJ2xvZ2luQ2xpY2snXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMubGlzdGVuVG8od2luZG93LmNhY2hlLnVzZXJFdmVudHMsIFwidXNlcjpsb2dpbjpzdWNjZXNzXCIsIGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICBCYWNrYm9uZS5oaXN0b3J5Lm5hdmlnYXRlKFVJQ29uZmlnLmhvbWUubG9nZ2VkX2luX3BhdGgsIHsgdHJpZ2dlcjogdHJ1ZSB9KTtcbiAgICB9KTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29tcGlsZWRUZW1wbGF0ZTtcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIGhvc3RuYW1lOiB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUsXG4gICAgICB1c2VyOiB3aW5kb3cuY2FjaGUuY3VycmVudFVzZXIgfHwge30sXG4gICAgfTtcblxuICAgIHRoaXMuJGVsLmFkZENsYXNzKCdob21lJyk7XG4gICAgY29tcGlsZWRUZW1wbGF0ZSA9IF8udGVtcGxhdGUoSG9tZVRlbXBsYXRlKShkYXRhKTtcbiAgICB0aGlzLiRlbC5odG1sKGNvbXBpbGVkVGVtcGxhdGUpO1xuICAgIHRoaXMuJGVsLmkxOG4oKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGxvZ2luQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAod2luZG93LmNhY2hlLmN1cnJlbnRVc2VyKSB7XG4gICAgICAvLyB3ZSdyZSBhbHJlYWR5IGxvZ2dlZCBpblxuICAgICAgQmFja2JvbmUuaGlzdG9yeS5uYXZpZ2F0ZShVSUNvbmZpZy5ob21lLmxvZ2dlZF9pbl9wYXRoLCB7IHRyaWdnZXI6IHRydWUgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9naW4oKTtcbiAgICB9XG4gIH0sXG5cbiAgbG9naW46IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMubG9naW5Db250cm9sbGVyKSB7XG4gICAgICB0aGlzLmxvZ2luQ29udHJvbGxlci5jbGVhbnVwKCk7XG4gICAgfVxuICAgIHRoaXMubG9naW5Db250cm9sbGVyID0gbmV3IExvZ2luQ29udHJvbGxlcih7XG4gICAgICBlbDogJyNsb2dpbi13cmFwcGVyJyxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICB9KTtcbiAgfSxcblxuICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy4kZWwucmVtb3ZlQ2xhc3MoJ2hvbWUnKTtcbiAgICByZW1vdmVWaWV3KHRoaXMpO1xuICB9LFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gSG9tZVZpZXc7XG4iLCJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciBCb290c3RyYXAgPSByZXF1aXJlKCdib290c3RyYXAnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uL21peGlucy91dGlsaXRpZXMnKTtcbnZhciBCYXNlQ29udHJvbGxlciA9IHJlcXVpcmUoJy4uLy4uLy4uL2Jhc2UvYmFzZV9jb250cm9sbGVyJyk7XG52YXIgTG9naW5WaWV3ID0gcmVxdWlyZSgnLi4vdmlld3MvbG9naW5fdmlldycpO1xudmFyIGxvZ2luID0gcmVxdWlyZSgnLi4vLi4vLi4vY29uZmlnL2xvZ2luLmpzb24nKTtcbnZhciBNb2RhbENvbXBvbmVudCA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbXBvbmVudHMvbW9kYWwnKTtcblxuXG5Mb2dpbiA9IEJhc2VDb250cm9sbGVyLmV4dGVuZCh7XG5cbiAgZXZlbnRzOiB7XG4gICAgXCJjbGljayAjcmVnaXN0ZXItY2FuY2VsXCIgICA6IFwic2hvd0xvZ2luXCIsXG4gICAgXCJjbGljayAjbG9naW4tcmVnaXN0ZXJcIiAgICA6IFwic2hvd1JlZ2lzdGVyXCIsXG4gICAgXCJjbGljayAjZm9yZ290LWRvbmUtY2FuY2VsXCI6IFwic2hvd0xvZ2luXCIsXG4gICAgXCJjbGljayAjZm9yZ290LWNhbmNlbFwiICAgICA6IFwic2hvd0xvZ2luXCIsXG4gICAgXCJjbGljayAjZm9yZ290LXBhc3N3b3JkXCIgICA6IFwic2hvd0ZvcmdvdFwiXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCBvcHRpb25zICkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuaW5pdGlhbGl6ZVZpZXcoKTtcbiAgfSxcblxuICBpbml0aWFsaXplVmlldzogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAodGhpcy5sb2dpblZpZXcpIHtcbiAgICAgIHRoaXMubG9naW5WaWV3LmNsZWFudXAoKTtcbiAgICAgIHRoaXMubW9kYWxDb21wb25lbnQuY2xlYW51cCgpO1xuICAgIH1cblxuICAgIC8vIGluaXRpYWxpemUgdGhlIG1vZGFsXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHRoaXMub3B0aW9ucy5tZXNzYWdlKSkge1xuICAgICAgdmFyIGRpc2FibGVDbG9zZSA9IHRoaXMub3B0aW9ucy5tZXNzYWdlLmRpc2FibGVDbG9zZSB8fCBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5tb2RhbENvbXBvbmVudCA9IG5ldyBNb2RhbENvbXBvbmVudCh7XG4gICAgICBlbDogdGhpcy5lbCxcbiAgICAgIGlkOiBcImxvZ2luXCIsXG4gICAgICBtb2RhbFRpdGxlOiBcIkxvZ2luIG9yIFJlZ2lzdGVyXCIsXG4gICAgICBkaXNhYmxlQ2xvc2U6IGRpc2FibGVDbG9zZVxuICAgIH0pLnJlbmRlcigpO1xuXG4gICAgLy8gcHV0IHRoZSBsb2dpbiB2aWV3IGluc2lkZSB0aGUgbW9kYWxcbiAgICB0aGlzLmxvZ2luVmlldyA9IG5ldyBMb2dpblZpZXcoe1xuICAgICAgZWw6IFwiLm1vZGFsLXRlbXBsYXRlXCIsXG4gICAgICBsb2dpbjogbG9naW4sXG4gICAgICBtZXNzYWdlOiB0aGlzLm9wdGlvbnMubWVzc2FnZVxuICAgIH0pLnJlbmRlcigpO1xuICAgIHRoaXMuJChcIiNyZWdpc3RyYXRpb24tdmlld1wiKS5oaWRlKCk7XG4gICAgdGhpcy4kKFwiI2ZvcmdvdC12aWV3XCIpLmhpZGUoKTtcbiAgICB0aGlzLiQoXCIjZm9yZ290LWRvbmUtdmlld1wiKS5oaWRlKCk7XG4gICAgJChcIiNsb2dpblwiKS5tb2RhbCgnc2hvdycpO1xuXG4gICAgc2VsZi5saXN0ZW5Ubyh3aW5kb3cuY2FjaGUudXNlckV2ZW50cywgXCJ1c2VyOmxvZ2luXCIsIGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAvLyBoaWRlIHRoZSBtb2RhbFxuICAgICAgc2VsZi5zdG9wTGlzdGVuaW5nKHdpbmRvdy5jYWNoZS51c2VyRXZlbnRzKTtcbiAgICAgIC8vIHdpbmRvdy5jYWNoZS51c2VyRXZlbnRzLnN0b3BMaXN0ZW5pbmcoKTtcbiAgICAgICQoJyNsb2dpbicpLmJpbmQoJ2hpZGRlbi5icy5tb2RhbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyByZWxvYWQgdGhlIHBhZ2UgYWZ0ZXIgbG9naW5cbiAgICAgICAgQmFja2JvbmUuaGlzdG9yeS5sb2FkVXJsKCk7XG4gICAgICAgIHdpbmRvdy5jYWNoZS51c2VyRXZlbnRzLnRyaWdnZXIoXCJ1c2VyOmxvZ2luOnN1Y2Nlc3NcIiwgdXNlcik7XG4gICAgICAgIHNlbGYuY2xlYW51cCgpO1xuICAgICAgfSkubW9kYWwoJ2hpZGUnKTtcbiAgICB9KTtcbiAgfSxcblxuICBzaG93UmVnaXN0ZXI6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLiQoXCIjbG9naW4tdmlld1wiKS5oaWRlKCk7XG4gICAgdGhpcy4kKFwiI2xvZ2luLWZvb3RlclwiKS5oaWRlKCk7XG4gICAgdGhpcy4kKFwiI3JlZ2lzdHJhdGlvbi12aWV3XCIpLnNob3coKTtcbiAgICB0aGlzLiQoXCIjcmVnaXN0cmF0aW9uLWZvb3RlclwiKS5zaG93KCk7XG4gICAgdGhpcy4kKFwiI2ZvcmdvdC12aWV3XCIpLmhpZGUoKTtcbiAgICB0aGlzLiQoXCIjZm9yZ290LWZvb3RlclwiKS5oaWRlKCk7XG4gICAgdGhpcy4kKFwiI2ZvcmdvdC1kb25lLXZpZXdcIikuaGlkZSgpO1xuICAgIHRoaXMuJChcIiNmb3Jnb3QtZG9uZS1mb290ZXJcIikuaGlkZSgpO1xuICB9LFxuXG4gIHNob3dMb2dpbjogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuJChcIiNsb2dpbi12aWV3XCIpLnNob3coKTtcbiAgICB0aGlzLiQoXCIjbG9naW4tZm9vdGVyXCIpLnNob3coKTtcbiAgICB0aGlzLiQoXCIjcmVnaXN0cmF0aW9uLXZpZXdcIikuaGlkZSgpO1xuICAgIHRoaXMuJChcIiNyZWdpc3RyYXRpb24tZm9vdGVyXCIpLmhpZGUoKTtcbiAgICB0aGlzLiQoXCIjZm9yZ290LXZpZXdcIikuaGlkZSgpO1xuICAgIHRoaXMuJChcIiNmb3Jnb3QtZm9vdGVyXCIpLmhpZGUoKTtcbiAgICB0aGlzLiQoXCIjZm9yZ290LWRvbmUtdmlld1wiKS5oaWRlKCk7XG4gICAgdGhpcy4kKFwiI2ZvcmdvdC1kb25lLWZvb3RlclwiKS5oaWRlKCk7XG4gIH0sXG5cbiAgc2hvd0ZvcmdvdDogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuJChcIiNmb3Jnb3Qtdmlld1wiKS5zaG93KCk7XG4gICAgdGhpcy4kKFwiI2ZvcmdvdC1mb290ZXJcIikuc2hvdygpO1xuICAgIHRoaXMuJChcIiNyZWdpc3RyYXRpb24tdmlld1wiKS5oaWRlKCk7XG4gICAgdGhpcy4kKFwiI3JlZ2lzdHJhdGlvbi1mb290ZXJcIikuaGlkZSgpO1xuICAgIHRoaXMuJChcIiNsb2dpbi12aWV3XCIpLmhpZGUoKTtcbiAgICB0aGlzLiQoXCIjbG9naW4tZm9vdGVyXCIpLmhpZGUoKTtcbiAgICB0aGlzLiQoXCIjZm9yZ290LWRvbmUtdmlld1wiKS5oaWRlKCk7XG4gICAgdGhpcy4kKFwiI2ZvcmdvdC1kb25lLWZvb3RlclwiKS5oaWRlKCk7XG4gIH0sXG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vPSBVVElMSVRZIE1FVEhPRFNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGNsZWFudXA6IGZ1bmN0aW9uKCkge1xuICAgIC8vIGRvbid0IGRvIGFueXRoaW5nXG4gICAgaWYgKHRoaXMubG9naW5WaWV3KSB7IHRoaXMubG9naW5WaWV3LmNsZWFudXAoKTsgfVxuICAgIGlmICh0aGlzLm1vZGFsQ29tcG9uZW50KSB7IHRoaXMubW9kYWxDb21wb25lbnQuY2xlYW51cCgpOyB9XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBMb2dpbjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiY29sLXNtLTkgc20tbm9wYWRkaW5nXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuICAgICAgPGxhYmVsIGZvcj1cXFwicnBhc3N3b3JkXFxcIiBjbGFzcz1cXFwiY29udHJvbC1sYWJlbFxcXCI+UGFzc3dvcmQ8L2xhYmVsPlxcbiAgICAgIDxpbnB1dCB0eXBlPVxcXCJwYXNzd29yZFxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbCB2YWxpZGF0ZVxcXCIgaWQ9XFxcInJwYXNzd29yZFxcXCIgbmFtZT1cXFwicGFzc3dvcmRcXFwiIHBsYWNlaG9sZGVyPVxcXCJQYXNzd29yZFxcXCIgZGF0YS12YWxpZGF0ZT1cXFwiZW1wdHkscGFzc3dvcmQsY29uZmlybVxcXCIvPlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJoZWxwLWJsb2NrIGVycm9yLWVtcHR5XFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI+WW91IG11c3QgZW50ZXIgYSBwYXNzd29yZC48L3NwYW4+XFxuICAgICAgPHNwYW4gY2xhc3M9XFxcImhlbHAtYmxvY2sgZXJyb3ItcGFzc3dvcmRcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIj5Zb3VyIHBhc3N3b3JkIGRvZXMgbm90IG1lZXQgcGFzc3dvcmQgcnVsZXMuPC9zcGFuPlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuICAgICAgPGxhYmVsIGZvcj1cXFwicnBhc3N3b3JkLWNvbmZpcm1cXFwiIGNsYXNzPVxcXCJjb250cm9sLWxhYmVsXFxcIj5Db25maXJtIFBhc3N3b3JkPC9sYWJlbD5cXG4gICAgICA8aW5wdXQgdHlwZT1cXFwicGFzc3dvcmRcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIGlkPVxcXCJycGFzc3dvcmQtY29uZmlybVxcXCIgcGxhY2Vob2xkZXI9XFxcIkNvbmZpcm0gUGFzc3dvcmRcXFwiLz5cXG4gICAgICA8c3BhbiBjbGFzcz1cXFwiaGVscC1ibG9jayBlcnJvci1jb25maXJtXFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI+WW91ciBwYXNzd29yZCBkb2VzIG5vdCBtYXRjaCB0aGUgcGFzc3dvcmQgZW50ZXJlZCBhYm92ZS48L3NwYW4+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJjb2wtc20tMyBub3BhZGRpbmdcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJwYXNzd29yZC1ydWxlcy10aXRsZVxcXCI+XFxuICAgICAgTXVzdCBDb250YWluOlxcbiAgICA8L2Rpdj5cXG4gICAgPHVsIGNsYXNzPVxcXCJwYXNzd29yZC1ydWxlc1xcXCI+XFxuICAgICAgPGxpIGNsYXNzPVxcXCJzdWNjZXNzIHJ1bGUtdXNlcm5hbWVcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1jaGVja1xcXCI+PC9pPiBOb3QgeW91ciBlbWFpbDwvbGk+XFxuICAgICAgPGxpIGNsYXNzPVxcXCJlcnJvciBydWxlLXVzZXJuYW1lXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtcmVtb3ZlXFxcIj48L2k+IE5vdCB5b3VyIGVtYWlsPC9saT5cXG4gICAgICA8bGkgY2xhc3M9XFxcInN1Y2Nlc3MgcnVsZS1sZW5ndGhcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1jaGVja1xcXCI+PC9pPiA4IGNoYXJhY3RlcnMgb3IgbW9yZTwvbGk+XFxuICAgICAgPGxpIGNsYXNzPVxcXCJlcnJvciBydWxlLWxlbmd0aFxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXJlbW92ZVxcXCI+PC9pPiA4IGNoYXJhY3RlcnMgb3IgbW9yZTwvbGk+XFxuICAgICAgPGxpIGNsYXNzPVxcXCJzdWNjZXNzIHJ1bGUtdXBwZXJcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1jaGVja1xcXCI+PC9pPiBVcHBlcmNhc2U8L2xpPlxcbiAgICAgIDxsaSBjbGFzcz1cXFwiZXJyb3IgcnVsZS11cHBlclxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXJlbW92ZVxcXCI+PC9pPiBVcHBlcmNhc2U8L2xpPlxcbiAgICAgIDxsaSBjbGFzcz1cXFwic3VjY2VzcyBydWxlLWxvd2VyXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtY2hlY2tcXFwiPjwvaT4gTG93ZXJjYXNlPC9saT5cXG4gICAgICA8bGkgY2xhc3M9XFxcImVycm9yIHJ1bGUtbG93ZXJcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1yZW1vdmVcXFwiPjwvaT4gTG93ZXJjYXNlPC9saT5cXG4gICAgICA8bGkgY2xhc3M9XFxcInN1Y2Nlc3MgcnVsZS1udW1iZXJcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1jaGVja1xcXCI+PC9pPiBBIE51bWJlcjwvbGk+XFxuICAgICAgPGxpIGNsYXNzPVxcXCJlcnJvciBydWxlLW51bWJlclxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXJlbW92ZVxcXCI+PC9pPiBBIE51bWJlcjwvbGk+XFxuICAgICAgPGxpIGNsYXNzPVxcXCJzdWNjZXNzIHJ1bGUtc3ltYm9sXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtY2hlY2tcXFwiPjwvaT4gQSBTeW1ib2w8L2xpPlxcbiAgICAgIDxsaSBjbGFzcz1cXFwiZXJyb3IgcnVsZS1zeW1ib2xcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1yZW1vdmVcXFwiPjwvaT4gQSBTeW1ib2w8L2xpPlxcbiAgICA8L3VsPlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGZvcm0gcm9sZT1cXFwiZm9ybVxcXCIgaWQ9XFxcImxvZ2luLXBhc3N3b3JkLWZvcm1cXFwiPlxcbjxkaXYgY2xhc3M9XFxcIm1vZGFsLWJvZHkgcGFkZGluZy1ib3R0b20tbm9uZVxcXCIgaWQ9XFxcImxvZ2luLXZpZXdcXFwiPlxcblxcbiAgPCUgaWYgKG1lc3NhZ2UgJiYgIV8uaXNVbmRlZmluZWQobWVzc2FnZS5tZXNzYWdlKSkgeyAlPlxcbiAgPGRpdiBjbGFzcz1cXFwiYWxlcnQgYWxlcnQtd2FybmluZ1xcXCI+XFxuICAgIDwlPSBtZXNzYWdlLm1lc3NhZ2UgJT5cXG4gIDwvZGl2PlxcbiAgPCUgfSAlPlxcblxcbiAgPCUgaWYgKGxvZ2luLm9hdXRoLmxlbmd0aCA+IDApIHsgJT5cXG4gIDxkaXYgY2xhc3M9XFxcImxvZ2luLW9hdXRoXFxcIj5Mb2dpbiB3aXRoXFxuICA8JSBfLmVhY2gobG9naW4ub2F1dGgsIGZ1bmN0aW9uIChlKSB7ICU+XFxuICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtc20tb2Zmc2V0LTMgY29sLXNtLTZcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImxvZ2luLW9wdGlvblxcXCI+XFxuICAgICAgICA8YSBocmVmPVxcXCI8JT0gbG9naW4uY29uZmlnW2VdLmVuZHBvaW50ICU+XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1jMCBidG4tbG9naW5cXFwiPlxcbiAgICAgICAgICA8aW1nIHNyYz1cXFwiPCU9IGxvZ2luLmNvbmZpZ1tlXS5pbWFnZSAlPlxcXCIgYWx0PVxcXCI8JT0gbG9naW4uY29uZmlnW2VdLm5hbWUgJT5cXFwiIGNsYXNzPVxcXCJidG4tbG9naW4tcmVzcG9uc2l2ZVxcXCIvPlxcbiAgICAgICAgPC9hPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbiAgPCUgfSk7ICU+XFxuICA8L2Rpdj5cXG4gIDwlIH0gJT5cXG5cXG4gIDwlIGlmIChsb2dpbi5sb2NhbC5lbmFibGVkID09PSB0cnVlKSB7ICU+XFxuICAgIDwlIGlmIChsb2dpbi5vYXV0aC5sZW5ndGggPiAwKSB7ICU+XFxuICAgIDxoci8+XFxuICAgIDwlIH0gJT5cXG4gICAgPGRpdiBjbGFzcz1cXFwiYWxlcnQgYWxlcnQtZGFuZ2VyXFxcIiBpZD1cXFwibG9naW4tZXJyb3JcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIj48L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcInVzZXJuYW1lXFxcIiBjbGFzcz1cXFwiY29udHJvbC1sYWJlbFxcXCIgZGF0YS1pMThuPVxcXCJsb2dpbk1vZGFsLmVtYWlsQWRkcmVzc1xcXCI+RW1haWwgQWRkcmVzczwvbGFiZWw+XFxuICAgICAgICA8aW5wdXQgdHlwZT1cXFwiZW1haWxcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIGlkPVxcXCJ1c2VybmFtZVxcXCIgbmFtZT1cXFwidXNlcm5hbWVcXFwiIHBsYWNlaG9sZGVyPVxcXCJFbWFpbCBBZGRyZXNzXFxcIi8+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cCBtYXJnaW4tYm90dG9tLW5vbmVcXFwiPlxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwicGFzc3dvcmRcXFwiIGNsYXNzPVxcXCJjb250cm9sLWxhYmVsXFxcIj5QYXNzd29yZDwvbGFiZWw+XFxuICAgICAgICA8aW5wdXQgdHlwZT1cXFwicGFzc3dvcmRcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIGlkPVxcXCJwYXNzd29yZFxcXCIgbmFtZT1cXFwicGFzc3dvcmRcXFwiIHBsYWNlaG9sZGVyPVxcXCJQYXNzd29yZFxcXCIvPlxcbiAgICAgICAgPGEgaHJlZj1cXFwiI2ZvcmdvdC1wYXNzd29yZFxcXCIgY2xhc3M9XFxcImZvcmdvdC1wYXNzd29yZFxcXCIgaWQ9XFxcImZvcmdvdC1wYXNzd29yZFxcXCI+Rm9yZ290IHlvdXIgcGFzc3dvcmQ/PC9hPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwibW9kYWwtZm9vdGVyIG1vZGFsLWZvb3Rlci1ncmV5XFxcIiBpZD1cXFwibG9naW4tZm9vdGVyXFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTEyXFxcIj5cXG4gICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJzdWJtaXRcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWMyIHB1bGwtcmlnaHRcXFwiPlNpZ24gaW48L2J1dHRvbj5cXG4gICAgICAgICAgPHAgY2xhc3M9XFxcInB1bGwtbGVmdCBsb2dpbi1yZWdpc3Rlci1sYWJlbFxcXCIgaWQ9XFxcImxvZ2luLXJlZ2lzdGVyLWxhYmVsXFxcIj5cXG4gICAgICAgICAgICBOZWVkIGFuIGFjY291bnQ/IFxcbiAgICAgICAgICAgIDxhIGhyZWY9XFxcIiNsb2dpbi1yZWdpc3RlclxcXCIgaWQ9XFxcImxvZ2luLXJlZ2lzdGVyXFxcIj5cXG4gICAgICAgICAgICAgIDxzdHJvbmc+U2lnbiB1cCBub3c8L3N0cm9uZz5cXG4gICAgICAgICAgICA8L2E+XFxuICAgICAgICAgIDwvcD5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwlIH0gZWxzZSB7ICU+XFxuICA8L2Rpdj5cXG4gIDwlIH0gJT5cXG48L2Zvcm0+XFxuXFxuPGZvcm0gcm9sZT1cXFwiZm9ybVxcXCIgaWQ9XFxcInJlZ2lzdHJhdGlvbi1mb3JtXFxcIj5cXG48ZGl2IGNsYXNzPVxcXCJtb2RhbC1ib2R5IHBhZGRpbmctYm90dG9tLW5vbmVcXFwiIGlkPVxcXCJyZWdpc3RyYXRpb24tdmlld1xcXCI+XFxuICAgIDxoMj5DcmVhdGUgYSBOZXcgQWNjb3VudDwvaDI+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLXNtLTEyXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJybmFtZVxcXCIgY2xhc3M9XFxcImNvbnRyb2wtbGFiZWxcXFwiIGRhdGEtaTE4bj1cXFwibG9naW5Nb2RhbC5uYW1lXFxcIj5OYW1lPC9sYWJlbD5cXG4gICAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2wgdmFsaWRhdGVcXFwiIGlkPVxcXCJybmFtZVxcXCIgbmFtZT1cXFwicm5hbWVcXFwiIHBsYWNlaG9sZGVyPVxcXCJGdWxsIE5hbWVcXFwiIGRhdGEtdmFsaWRhdGU9XFxcImVtcHR5XFxcIj5cXG4gICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImhlbHAtYmxvY2sgZXJyb3ItZW1wdHlcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIj5QbGVhc2UgZW50ZXIgeW91ciBmdWxsIG5hbWUuPC9zcGFuPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLXNtLTEyXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJydXNlcm5hbWVcXFwiIGNsYXNzPVxcXCJjb250cm9sLWxhYmVsXFxcIiBkYXRhLWkxOG49XFxcImxvZ2luTW9kYWwuZW1haWxBZGRyZXNzXFxcIj5FbWFpbCBBZGRyZXNzPC9sYWJlbD5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXBcXFwiPlxcbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sIHZhbGlkYXRlXFxcIiBpZD1cXFwicnVzZXJuYW1lXFxcIiBuYW1lPVxcXCJ1c2VybmFtZVxcXCIgcGxhY2Vob2xkZXI9XFxcIkVtYWlsIEFkZHJlc3NcXFwiIGRhdGEtdmFsaWRhdGU9XFxcImJ1dHRvblxcXCIvPlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpbnB1dC1ncm91cC1idG5cXFwiPlxcbiAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgY2xhc3M9XFxcImJ0biBidG4tZGFuZ2VyXFxcIiBpZD1cXFwicnVzZXJuYW1lLWJ1dHRvblxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj5cXG4gICAgICAgICAgICAgICAgPGkgaWQ9XFxcInJ1c2VybmFtZS1jaGVja1xcXCIgY2xhc3M9XFxcImZhIGZhLXRpbWVzXFxcIj48L2k+XFxuICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImhlbHAtYmxvY2sgZXJyb3ItYnV0dG9uXFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI+VGhlIGVtYWlsIGFkZHJlc3MgaXMgbm90IHZhbGlkIG9yIGlzIGFscmVhZHkgaW4gdXNlLjwvc3Bhbj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwicGFzc3dvcmQtdmlld1xcXCI+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjaGVja2JveFxcXCI+XFxuICAgICAgPGxhYmVsPlxcbiAgICAgICAgPCUgaWYgKGxvZ2luLnRlcm1zLmVuYWJsZWQgPT09IHRydWUpIHsgJT5cXG4gICAgICAgIDxpbnB1dCB0eXBlPVxcXCJjaGVja2JveFxcXCIgaWQ9XFxcInJ0ZXJtc1xcXCIgY2xhc3M9XFxcInZhbGlkYXRlXFxcIiBkYXRhLXZhbGlkYXRlPVxcXCJjaGVja2VkXFxcIj4gPHNwYW4gZGF0YS1pMThuPVxcXCJsb2dpbk1vZGFsLnRvc0NoZWNrYm94XFxcIj5ZZXMsIEkgYWdyZWUgdG8gdGhlIDwvc3Bhbj48YSBocmVmPVxcXCI8JT0gbG9naW4udGVybXMubGluayAlPlxcXCI+PCU9IGxvZ2luLnRlcm1zLm5hbWUgJT48L2E+LlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcImhlbHAtYmxvY2sgZXJyb3ItY2hlY2tlZFxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPllvdSBtdXN0IGFjY2VwdCB0aGUgPCU9IGxvZ2luLnRlcm1zLm5hbWUgJT4gdG8gcmVnaXN0ZXIuPC9zcGFuPlxcbiAgICAgICAgPCUgfSAlPlxcbiAgICAgIDwvbGFiZWw+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwIG1hcmdpbi1ib3R0b20tbm9uZVxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1zbS0xMlxcXCI+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImFsZXJ0IGFsZXJ0LWRhbmdlclxcXCIgaWQ9XFxcInJlZ2lzdHJhdGlvbi1lcnJvclxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPjwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcIm1vZGFsLWZvb3RlciBtb2RhbC1mb290ZXItZ3JleVxcXCIgaWQ9XFxcInJlZ2lzdHJhdGlvbi1mb290ZXJcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImNvbC1zbS0xMlxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwicHVsbC1yaWdodFxcXCI+XFxuICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgaWQ9XFxcInJlZ2lzdGVyLWNhbmNlbFxcXCIgY2xhc3M9XFxcImJ0biBidG4tYzBcXFwiPkNhbmNlbDwvYnV0dG9uPlxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJzdWJtaXRcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWMyXFxcIj5SZWdpc3RlcjwvYnV0dG9uPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcbjwvZm9ybT5cXG5cXG48Zm9ybSByb2xlPVxcXCJmb3JtXFxcIiBpZD1cXFwiZm9yZ290LWZvcm1cXFwiPlxcbjxkaXYgY2xhc3M9XFxcIm1vZGFsLWJvZHkgcGFkZGluZy1ib3R0b20tbm9uZVxcXCIgaWQ9XFxcImZvcmdvdC12aWV3XFxcIj5cXG4gICAgPGgyPlJlc2V0IFlvdXIgUGFzc3dvcmQ8L2gyPlxcblxcbiAgICA8cD5QbGVhc2UgZW50ZXIgeW91ciBlbWFpbCBhZGRyZXNzIGFuZCB3ZSdsbCBzZW5kIHlvdSBhIGxpbmsgdG8gcmVzZXQgeW91ciBwYXNzd29yZDwvcD5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuICAgICAgPGxhYmVsIGZvcj1cXFwiZnVzZXJuYW1lXFxcIiBjbGFzcz1cXFwiY29udHJvbC1sYWJlbFxcXCI+RW1haWwgQWRkcmVzczwvbGFiZWw+XFxuICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2wgdmFsaWRhdGVcXFwiIGlkPVxcXCJmdXNlcm5hbWVcXFwiIG5hbWU9XFxcInVzZXJuYW1lXFxcIiBwbGFjZWhvbGRlcj1cXFwiRW1haWwgQWRkcmVzc1xcXCIgZGF0YS12YWxpZGF0ZT1cXFwiYnV0dG9uXFxcIi8+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwIG1hcmdpbi1ib3R0b20tbm9uZVxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1zbS0xMlxcXCI+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImFsZXJ0IGFsZXJ0LWRhbmdlclxcXCIgaWQ9XFxcImZvcmdvdC1lcnJvclxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPjwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcIm1vZGFsLWZvb3RlciBtb2RhbC1mb290ZXItZ3JleVxcXCIgaWQ9XFxcImZvcmdvdC1mb290ZXJcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImNvbC1zbS0xMlxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwicHVsbC1yaWdodFxcXCI+XFxuICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgaWQ9XFxcImZvcmdvdC1jYW5jZWxcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWMwXFxcIj5DYW5jZWw8L2J1dHRvbj5cXG4gICAgICAgIDxidXR0b24gdHlwZT1cXFwic3VibWl0XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1jMlxcXCI+UmVzZXQgUGFzc3dvcmQ8L2J1dHRvbj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG48L2Rpdj5cXG48L2Zvcm0+XFxuXFxuPGRpdiBjbGFzcz1cXFwibW9kYWwtYm9keSBwYWRkaW5nLWJvdHRvbS1ub25lXFxcIiBpZD1cXFwiZm9yZ290LWRvbmUtdmlld1xcXCI+XFxuICAgIDxoMj5SZXNldCBZb3VyIFBhc3N3b3JkPC9oMj5cXG5cXG4gICAgPHA+XFxuICAgICAgVGhhbmsgeW91ISBBbiBlbWFpbCB3aWxsIGFycml2ZSBzaG9ydGx5IHdpdGggYSBsaW5rIHRvIHJlc2V0IHlvdXIgcGFzc3dvcmQuXFxuICAgIDwvcD5cXG4gICAgPHA+XFxuICAgICAgSWYgeW91IGRvbid0IHJlY2VpdmUgYW4gZW1haWwgc2hvcnRseSwgY2hlY2sgeW91ciBzcGFtIGZvbGRlci5cXG4gICAgPC9wPlxcbjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcIm1vZGFsLWZvb3RlciBtb2RhbC1mb290ZXItZ3JleVxcXCIgaWQ9XFxcImZvcmdvdC1kb25lLWZvb3RlclxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY29sLXNtLTEyXFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJwdWxsLXJpZ2h0XFxcIj5cXG4gICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBpZD1cXFwiZm9yZ290LWRvbmUtY2FuY2VsXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1jMlxcXCI+UmV0dXJuIHRvIExvZ2luPC9idXR0b24+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC9kaXY+XCI7XG4iLCJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uL21peGlucy91dGlsaXRpZXMnKTtcbnZhciBMb2dpblBhc3N3b3JkVGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvbG9naW5fcGFzc3dvcmRfdGVtcGxhdGUuaHRtbCcpO1xuXG5cbnZhciBMb2dpblBhc3N3b3JkVmlldyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZShMb2dpblBhc3N3b3JkVGVtcGxhdGUpO1xuICAgIHRoaXMuJGVsLmh0bWwodGVtcGxhdGUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGNsZWFudXA6IGZ1bmN0aW9uICgpIHtcbiAgICByZW1vdmVWaWV3KHRoaXMpO1xuICB9LFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTG9naW5QYXNzd29yZFZpZXc7XG5cbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uL21peGlucy91dGlsaXRpZXMnKTtcbnZhciBMb2dpblBhc3N3b3JkVmlldyA9IHJlcXVpcmUoJy4vbG9naW5fcGFzc3dvcmRfdmlldycpO1xudmFyIExvZ2luVGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvbG9naW5fdGVtcGxhdGUuaHRtbCcpO1xudmFyIE1vZGFsQ29tcG9uZW50ID0gcmVxdWlyZSgnLi4vLi4vLi4vY29tcG9uZW50cy9tb2RhbCcpO1xuXG5cbnZhciBMb2dpblZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG5cbiAgZXZlbnRzOiB7XG4gICAgJ2NsaWNrIC5vYXV0aC1saW5rJyAgICAgICAgICAgICAgOiAnbGluaycsXG4gICAgJ2tleXVwICNybmFtZScgICAgICAgICAgICAgICAgICAgOiAnY2hlY2tOYW1lJyxcbiAgICAnY2hhbmdlICNybmFtZScgICAgICAgICAgICAgICAgICA6ICdjaGVja05hbWUnLFxuICAgICdibHVyICNybmFtZScgICAgICAgICAgICAgICAgICAgIDogJ2NoZWNrTmFtZScsXG4gICAgJ2tleXVwICNydXNlcm5hbWUnICAgICAgICAgICAgICAgOiAnY2hlY2tVc2VybmFtZScsXG4gICAgJ2NoYW5nZSAjcnVzZXJuYW1lJyAgICAgICAgICAgICAgOiAnY2hlY2tVc2VybmFtZScsXG4gICAgJ2NsaWNrICNydXNlcm5hbWUtYnV0dG9uJyAgICAgICAgOiAnY2xpY2tVc2VybmFtZScsXG4gICAgJ2tleXVwICNycGFzc3dvcmQnICAgICAgICAgICAgICAgOiAnY2hlY2tQYXNzd29yZCcsXG4gICAgJ2JsdXIgI3JwYXNzd29yZCcgICAgICAgICAgICAgICAgOiAnY2hlY2tQYXNzd29yZCcsXG4gICAgJ2tleXVwICNycGFzc3dvcmQtY29uZmlybScgICAgICAgOiAnY2hlY2tQYXNzd29yZENvbmZpcm0nLFxuICAgICdibHVyICNycGFzc3dvcmQtY29uZmlybScgICAgICAgIDogJ2NoZWNrUGFzc3dvcmRDb25maXJtJyxcbiAgICAnc3VibWl0ICNsb2dpbi1wYXNzd29yZC1mb3JtJyAgICA6ICdzdWJtaXRMb2dpbicsXG4gICAgJ3N1Ym1pdCAjcmVnaXN0cmF0aW9uLWZvcm0nICAgICAgOiAnc3VibWl0UmVnaXN0ZXInLFxuICAgICdzdWJtaXQgI2ZvcmdvdC1mb3JtJyAgICAgICAgICAgIDogJ3N1Ym1pdEZvcmdvdCdcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBkYXRhID0ge1xuICAgICAgbG9naW46IHRoaXMub3B0aW9ucy5sb2dpbixcbiAgICAgIG1lc3NhZ2U6IHRoaXMub3B0aW9ucy5tZXNzYWdlXG4gICAgfTtcbiAgICB2YXIgdGVtcGxhdGUgPSBfLnRlbXBsYXRlKExvZ2luVGVtcGxhdGUpKGRhdGEpO1xuICAgIHRoaXMuJGVsLmh0bWwodGVtcGxhdGUpO1xuICAgIHRoaXMuJGVsLmkxOG4oKTtcbiAgICB0aGlzLmxvZ2luUGFzc3dvcmRWaWV3ID0gbmV3IExvZ2luUGFzc3dvcmRWaWV3KHtcbiAgICAgIGVsOiB0aGlzLiQoXCIucGFzc3dvcmQtdmlld1wiKVxuICAgIH0pLnJlbmRlcigpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi4kKFwiI3VzZXJuYW1lXCIpLmZvY3VzKCk7XG4gICAgfSwgNTAwKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBsaW5rOiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIGxpbmsgPSAkKGUuY3VycmVudFRhcmdldCkuYXR0cignaHJlZicpO1xuICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gbGluaztcbiAgfSxcblxuICB2OiBmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiB2YWxpZGF0ZShlKTtcbiAgfSxcblxuICBzdWJtaXRMb2dpbjogZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIHVzZXJuYW1lOiB0aGlzLiQoXCIjdXNlcm5hbWVcIikudmFsKCksXG4gICAgICBwYXNzd29yZDogdGhpcy4kKFwiI3Bhc3N3b3JkXCIpLnZhbCgpLFxuICAgICAganNvbjogdHJ1ZVxuICAgIH07XG4gICAgJC5hamF4KHtcbiAgICAgIHVybDogJy9hcGkvYXV0aC9sb2NhbCcsXG4gICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSkuZG9uZShmdW5jdGlvbiAoc3VjY2Vzcykge1xuICAgICAgLy8gU2V0IHRoZSB1c2VyIG9iamVjdCBhbmQgdHJpZ2dlciB0aGUgdXNlciBsb2dpbiBldmVudFxuICAgICAgd2luZG93LmNhY2hlLmN1cnJlbnRVc2VyID0gc3VjY2VzcztcbiAgICAgIHdpbmRvdy5jYWNoZS51c2VyRXZlbnRzLnRyaWdnZXIoXCJ1c2VyOmxvZ2luXCIsIHN1Y2Nlc3MpO1xuICAgIH0pLmZhaWwoZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICB2YXIgZCA9IEpTT04ucGFyc2UoZXJyb3IucmVzcG9uc2VUZXh0KTtcbiAgICAgIHNlbGYuJChcIiNsb2dpbi1lcnJvclwiKS5odG1sKGQubWVzc2FnZSk7XG4gICAgICBzZWxmLiQoXCIjbG9naW4tZXJyb3JcIikuc2hvdygpO1xuICAgIH0pO1xuICB9LFxuXG4gIHN1Ym1pdFJlZ2lzdGVyOiBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgJHN1Ym1pdEJ1dHRvbiA9IHNlbGYuJCgnI3JlZ2lzdHJhdGlvbi1mb3JtIFt0eXBlPVwic3VibWl0XCJdJyk7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICRzdWJtaXRCdXR0b24ucHJvcCgnZGlzYWJsZWQnLCB0cnVlKTtcbiAgICAvLyB2YWxpZGF0ZSBpbnB1dCBmaWVsZHNcbiAgICB2YXIgdmFsaWRhdGVJZHMgPSBbJyNybmFtZScsICcjcnVzZXJuYW1lJywgJyNycGFzc3dvcmQnXTtcbiAgICAvLyBPbmx5IHZhbGlkYXRlIHRlcm1zICYgY29uZGl0aW9ucyBpZiBpdCBpcyBlbmFibGVkXG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2dpbi50ZXJtcy5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICB2YWxpZGF0ZUlkcy5wdXNoKCcjcnRlcm1zJyk7XG4gICAgfVxuICAgIHZhciBhYm9ydCA9IGZhbHNlO1xuICAgIGZvciAoaSBpbiB2YWxpZGF0ZUlkcykge1xuICAgICAgdmFyIGlBYm9ydCA9IHZhbGlkYXRlKHsgY3VycmVudFRhcmdldDogdmFsaWRhdGVJZHNbaV0gfSk7XG4gICAgICBhYm9ydCA9IGFib3J0IHx8IGlBYm9ydDtcbiAgICB9XG4gICAgdmFyIHBhc3N3b3JkU3VjY2VzcyA9IHRoaXMuY2hlY2tQYXNzd29yZCgpO1xuICAgIHZhciBwYXJlbnQgPSAkKHRoaXMuJChcIiNycGFzc3dvcmRcIikucGFyZW50cygnLmZvcm0tZ3JvdXAnKVswXSk7XG4gICAgaWYgKHBhc3N3b3JkU3VjY2VzcyAhPT0gdHJ1ZSkge1xuICAgICAgcGFyZW50LmFkZENsYXNzKCdoYXMtZXJyb3InKTtcbiAgICAgICQocGFyZW50LmZpbmQoJy5lcnJvci1wYXNzd29yZCcpWzBdKS5zaG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICQocGFyZW50LmZpbmQoJy5lcnJvci1wYXNzd29yZCcpWzBdKS5oaWRlKCk7XG4gICAgfVxuICAgIHZhciBwYXNzd29yZENvbmZpcm1TdWNjZXNzID0gdGhpcy5jaGVja1Bhc3N3b3JkQ29uZmlybSgpO1xuICAgIHZhciBwYXNzd29yZENvbmZpcm1QYXJlbnQgPSAkKHRoaXMuJChcIiNycGFzc3dvcmQtY29uZmlybVwiKS5wYXJlbnRzKCcuZm9ybS1ncm91cCcpWzBdKTtcbiAgICBpZiAocGFzc3dvcmRDb25maXJtU3VjY2VzcyAhPT0gdHJ1ZSkge1xuICAgICAgcGFzc3dvcmRDb25maXJtUGFyZW50LmFkZENsYXNzKCdoYXMtZXJyb3InKTtcbiAgICAgICQocGFzc3dvcmRDb25maXJtUGFyZW50LmZpbmQoJy5lcnJvci1wYXNzd29yZCcpWzBdKS5zaG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICQocGFzc3dvcmRDb25maXJtUGFyZW50LmZpbmQoJy5lcnJvci1wYXNzd29yZCcpWzBdKS5oaWRlKCk7XG4gICAgfVxuICAgIGlmIChhYm9ydCA9PT0gdHJ1ZSB8fCBwYXNzd29yZFN1Y2Nlc3MgIT09IHRydWUgfHwgcGFzc3dvcmRDb25maXJtU3VjY2VzcyAhPT0gdHJ1ZSkge1xuICAgICAgJHN1Ym1pdEJ1dHRvbi5wcm9wKCdkaXNhYmxlZCcsIGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYSBkYXRhIG9iamVjdCB3aXRoIHRoZSByZXF1aXJlZCBmaWVsZHNcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIG5hbWU6IHRoaXMuJChcIiNybmFtZVwiKS52YWwoKSxcbiAgICAgIHVzZXJuYW1lOiB0aGlzLiQoXCIjcnVzZXJuYW1lXCIpLnZhbCgpLFxuICAgICAgcGFzc3dvcmQ6IHRoaXMuJChcIiNycGFzc3dvcmRcIikudmFsKCksXG4gICAgICBqc29uOiB0cnVlXG4gICAgfTtcbiAgICAvLyBBZGQgaW4gYWRkaXRpb25hbCwgb3B0aW9uYWwgZmllbGRzXG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2dpbi50ZXJtcy5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICBkYXRhWyd0ZXJtcyddID0gKHRoaXMuJChcIiNydGVybXNcIikudmFsKCkgPT0gXCJvblwiKTtcbiAgICB9XG4gICAgLy8gUG9zdCB0aGUgcmVnaXN0cmF0aW9uIHJlcXVlc3QgdG8gdGhlIHNlcnZlclxuICAgICQuYWpheCh7XG4gICAgICB1cmw6ICcvYXBpL2F1dGgvcmVnaXN0ZXInLFxuICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pLmRvbmUoZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcbiAgICAgIC8vIFNldCB0aGUgdXNlciBvYmplY3QgYW5kIHRyaWdnZXIgdGhlIHVzZXIgbG9naW4gZXZlbnRcbiAgICAgIHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlciA9IHN1Y2Nlc3M7XG4gICAgICB3aW5kb3cuY2FjaGUudXNlckV2ZW50cy50cmlnZ2VyKFwidXNlcjpsb2dpblwiLCBzdWNjZXNzKTtcbiAgICB9KS5mYWlsKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgdmFyIGQgPSBKU09OLnBhcnNlKGVycm9yLnJlc3BvbnNlVGV4dCk7XG4gICAgICBzZWxmLiQoXCIjcmVnaXN0cmF0aW9uLWVycm9yXCIpLmh0bWwoZC5tZXNzYWdlKTtcbiAgICAgIHNlbGYuJChcIiNyZWdpc3RyYXRpb24tZXJyb3JcIikuc2hvdygpO1xuICAgICAgJHN1Ym1pdEJ1dHRvbi5wcm9wKCdkaXNhYmxlZCcsIGZhbHNlKTtcbiAgICB9KTtcbiAgfSxcblxuICBzdWJtaXRGb3Jnb3Q6IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICB1c2VybmFtZTogdGhpcy4kKFwiI2Z1c2VybmFtZVwiKS52YWwoKVxuICAgIH07XG4gICAgLy8gUG9zdCB0aGUgcmVnaXN0cmF0aW9uIHJlcXVlc3QgdG8gdGhlIHNlcnZlclxuICAgICQuYWpheCh7XG4gICAgICB1cmw6ICcvYXBpL2F1dGgvZm9yZ290JyxcbiAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KS5kb25lKGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAvLyBTZXQgdGhlIHVzZXIgb2JqZWN0IGFuZCB0cmlnZ2VyIHRoZSB1c2VyIGxvZ2luIGV2ZW50XG4gICAgICBzZWxmLiQoXCIjZm9yZ290LXZpZXdcIikuaGlkZSgpO1xuICAgICAgc2VsZi4kKFwiI2ZvcmdvdC1mb290ZXJcIikuaGlkZSgpO1xuICAgICAgc2VsZi4kKFwiI2ZvcmdvdC1kb25lLXZpZXdcIikuc2hvdygpO1xuICAgICAgc2VsZi4kKFwiI2ZvcmdvdC1kb25lLWZvb3RlclwiKS5zaG93KCk7XG4gICAgfSkuZmFpbChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHZhciBkID0gSlNPTi5wYXJzZShlcnJvci5yZXNwb25zZVRleHQpO1xuICAgICAgc2VsZi4kKFwiI2ZvcmdvdC1lcnJvclwiKS5odG1sKGQubWVzc2FnZSk7XG4gICAgICBzZWxmLiQoXCIjZm9yZ290LWVycm9yXCIpLnNob3coKTtcbiAgICB9KTtcbiAgfSxcblxuICBjaGVja05hbWU6IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIG5hbWUgPSB0aGlzLiQoXCIjcm5hbWVcIikudmFsKCk7XG4gICAgaWYgKG5hbWUgJiYgbmFtZSAhPT0gJycpIHtcbiAgICAgICQoXCIjcm5hbWVcIikuY2xvc2VzdChcIi5mb3JtLWdyb3VwXCIpLmZpbmQoXCIuaGVscC1ibG9ja1wiKS5oaWRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICQoXCIjcm5hbWVcIikuY2xvc2VzdChcIi5mb3JtLWdyb3VwXCIpLmZpbmQoXCIuaGVscC1ibG9ja1wiKS5zaG93KCk7XG4gICAgfVxuICB9LFxuXG4gIGNoZWNrVXNlcm5hbWU6IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHVzZXJuYW1lID0gJChcIiNydXNlcm5hbWVcIikudmFsKCk7XG4gICAgJC5hamF4KHtcbiAgICAgIHVybDogJy9hcGkvdXNlci91c2VybmFtZS8nICsgdXNlcm5hbWUsXG4gICAgfSkuZG9uZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgJChcIiNydXNlcm5hbWUtYnV0dG9uXCIpLnJlbW92ZUNsYXNzKCdidG4tc3VjY2VzcycpO1xuICAgICAgJChcIiNydXNlcm5hbWUtYnV0dG9uXCIpLnJlbW92ZUNsYXNzKCdidG4tZGFuZ2VyJyk7XG4gICAgICAkKFwiI3J1c2VybmFtZS1jaGVja1wiKS5yZW1vdmVDbGFzcygnZmEgZmEtY2hlY2snKTtcbiAgICAgICQoXCIjcnVzZXJuYW1lLWNoZWNrXCIpLnJlbW92ZUNsYXNzKCdmYSBmYS10aW1lcycpO1xuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgLy8gdXNlcm5hbWUgaXMgdGFrZW5cbiAgICAgICAgJChcIiNydXNlcm5hbWUtYnV0dG9uXCIpLmFkZENsYXNzKCdidG4tZGFuZ2VyJyk7XG4gICAgICAgICQoXCIjcnVzZXJuYW1lLWNoZWNrXCIpLmFkZENsYXNzKCdmYSBmYS10aW1lcycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdXNlcm5hbWUgaXMgYXZhaWxhYmxlXG4gICAgICAgICQoXCIjcnVzZXJuYW1lLWJ1dHRvblwiKS5hZGRDbGFzcygnYnRuLXN1Y2Nlc3MnKTtcbiAgICAgICAgJChcIiNydXNlcm5hbWUtY2hlY2tcIikuYWRkQ2xhc3MoJ2ZhIGZhLWNoZWNrJyk7XG4gICAgICAgICQoXCIjcnVzZXJuYW1lXCIpLmNsb3Nlc3QoXCIuZm9ybS1ncm91cFwiKS5yZW1vdmVDbGFzcygnaGFzLWVycm9yJyk7XG4gICAgICAgICQoXCIjcnVzZXJuYW1lXCIpLmNsb3Nlc3QoXCIuZm9ybS1ncm91cFwiKS5maW5kKFwiLmhlbHAtYmxvY2tcIikuaGlkZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIGNoZWNrUGFzc3dvcmQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHJ1bGVzID0gdmFsaWRhdGVQYXNzd29yZCh0aGlzLiQoXCIjcnVzZXJuYW1lXCIpLnZhbCgpLCB0aGlzLiQoXCIjcnBhc3N3b3JkXCIpLnZhbCgpKTtcbiAgICB2YXIgdmFsdWVzQXJyYXkgPSBfLnZhbHVlcyhydWxlcyk7XG4gICAgdmFyIHZhbGlkUnVsZXMgPSBfLmV2ZXJ5KHZhbHVlc0FycmF5KTtcbiAgICB2YXIgc3VjY2VzcyA9IHRydWU7XG4gICAgaWYgKHZhbGlkUnVsZXMgPT09IHRydWUpIHtcbiAgICAgICQoXCIjcnBhc3N3b3JkXCIpLmNsb3Nlc3QoXCIuZm9ybS1ncm91cFwiKS5yZW1vdmVDbGFzcygnaGFzLWVycm9yJyk7XG4gICAgICAkKFwiI3JwYXNzd29yZFwiKS5jbG9zZXN0KFwiLmZvcm0tZ3JvdXBcIikuZmluZChcIi5oZWxwLWJsb2NrXCIpLmhpZGUoKTtcbiAgICB9XG4gICAgXy5lYWNoKHJ1bGVzLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuJChcIi5wYXNzd29yZC1ydWxlcyAuc3VjY2Vzcy5ydWxlLVwiICsga2V5KS5zaG93KCk7XG4gICAgICAgIHRoaXMuJChcIi5wYXNzd29yZC1ydWxlcyAuZXJyb3IucnVsZS1cIiArIGtleSkuaGlkZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4kKFwiLnBhc3N3b3JkLXJ1bGVzIC5zdWNjZXNzLnJ1bGUtXCIgKyBrZXkpLmhpZGUoKTtcbiAgICAgICAgdGhpcy4kKFwiLnBhc3N3b3JkLXJ1bGVzIC5lcnJvci5ydWxlLVwiICsga2V5KS5zaG93KCk7XG4gICAgICB9XG4gICAgICBzdWNjZXNzID0gc3VjY2VzcyAmJiB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gc3VjY2VzcztcbiAgfSxcblxuICBjaGVja1Bhc3N3b3JkQ29uZmlybTogZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgc3VjY2VzcyA9IHRydWU7XG4gICAgdmFyIHBhc3N3b3JkID0gdGhpcy4kKFwiI3JwYXNzd29yZFwiKS52YWwoKTtcbiAgICB2YXIgY29uZmlybSA9IHRoaXMuJChcIiNycGFzc3dvcmQtY29uZmlybVwiKS52YWwoKVxuICAgIGlmIChwYXNzd29yZCA9PT0gY29uZmlybSkge1xuICAgICAgJChcIiNycGFzc3dvcmQtY29uZmlybVwiKS5jbG9zZXN0KFwiLmZvcm0tZ3JvdXBcIikuZmluZChcIi5oZWxwLWJsb2NrXCIpLmhpZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJChcIiNycGFzc3dvcmQtY29uZmlybVwiKS5jbG9zZXN0KFwiLmZvcm0tZ3JvdXBcIikuZmluZChcIi5oZWxwLWJsb2NrXCIpLnNob3coKTtcbiAgICAgIHN1Y2Nlc3MgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1Y2Nlc3M7XG4gIH0sXG5cbiAgY2xpY2tVc2VybmFtZTogZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0sXG5cbiAgY2xlYW51cDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmxvZ2luUGFzc3dvcmRWaWV3KSB7IHRoaXMubG9naW5QYXNzd29yZFZpZXcuY2xlYW51cCgpOyB9XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfSxcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExvZ2luVmlldztcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGlkPVxcXCJsb2dpbi13cmFwcGVyXFxcIj48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJuYXZiYXIgbmF2YmFyLWRlZmF1bHQgbmF2YmFyLXN0YXRpYy10b3BcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiY29udGFpbmVyXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwibmF2YmFyLWhlYWRlclxcXCI+XFxuICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJuYXZiYXItdG9nZ2xlXFxcIiBkYXRhLXRvZ2dsZT1cXFwiY29sbGFwc2VcXFwiIGRhdGEtdGFyZ2V0PVxcXCIubmF2YmFyLWNvbGxhcHNlXFxcIj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpY29uLWJhclxcXCI+PC9zcGFuPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcImljb24tYmFyXFxcIj48L3NwYW4+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaWNvbi1iYXJcXFwiPjwvc3Bhbj5cXG4gICAgICA8L2J1dHRvbj5cXG4gICAgICA8YSBjbGFzcz1cXFwibmF2YmFyLWJyYW5kXFxcIiBocmVmPVxcXCIvXFxcIiB0aXRsZT1cXFwiPCUtIHN5c3RlbU5hbWUgJT4gSG9tZVxcXCI+XFxuICAgICAgPC9hPlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwibmF2YmFyLWNvbGxhcHNlIGNvbGxhcHNlIHB1bGwtcmlnaHRcXFwiPlxcbiAgICAgIDx1bCBjbGFzcz1cXFwibmF2IG5hdmJhci1uYXZcXFwiPlxcblxcbiAgICAgICAgPCUgaWYgKHVpLnByb2plY3Quc2hvdykgeyAlPlxcbiAgICAgICAgPGxpIGNsYXNzPVxcXCJwcm9qZWN0c1xcXCI+XFxuICAgICAgICAgIDxhIGhyZWY9XFxcIi9wcm9qZWN0c1xcXCIgY2xhc3M9XFxcIm5hdi1saW5rXFxcIj5cXG4gICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtcm9ja2V0XFxcIj48L2k+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcIm5hdmJhci10aXRsZS1zbWFsbFxcXCIgZGF0YS1pMThuPVxcXCJCcm93c2VcXFwiPkJyb3dzZTwvc3Bhbj48YnIvPlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJuYXZiYXItdGl0bGUtYmlnXFxcIiBkYXRhLWkxOG49XFxcIlByb2plY3RQbHVyYWxcXFwiPlByb2plY3RzPC9zcGFuPlxcbiAgICAgICAgICA8L2E+XFxuICAgICAgICA8L2xpPlxcbiAgICAgICAgPCUgfSAlPlxcbiAgICAgICAgPGxpIGNsYXNzPVxcXCJ0YXNrc1xcXCI+XFxuICAgICAgICAgIDxhIGhyZWY9XFxcIi90YXNrc1xcXCIgY2xhc3M9XFxcIm5hdi1saW5rXFxcIj5cXG4gICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtdGFnc1xcXCI+PC9pPlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJuYXZiYXItdGl0bGUtc21hbGxcXFwiIGRhdGEtaTE4bj1cXFwiQnJvd3NlXFxcIj5Ccm93c2U8L3NwYW4+PGJyLz5cXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwibmF2YmFyLXRpdGxlLWJpZ1xcXCIgZGF0YS1pMThuPVxcXCJUYXNrUGx1cmFsXFxcIj5UYXNrczwvc3Bhbj5cXG4gICAgICAgICAgPC9hPlxcbiAgICAgICAgPC9saT5cXG5cXG4gICAgICAgIDxsaSBjbGFzcz1cXFwiZGl2aWRlci12ZXJ0aWNhbCBuYXZiYXItdGV4dFxcXCI+PC9saT5cXG4gICAgICAgIDwlIGlmICh1c2VyKSB7ICU+XFxuICAgICAgICAgIDxsaSBjbGFzcz1cXFwicHJvZmlsZSBkcm9wZG93blxcXCI+PGEgaHJlZj1cXFwiL3Byb2ZpbGVcXFwiIGlkPVxcXCJuYXZiYXItcHJvZmlsZVxcXCIgcm9sZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiZHJvcGRvd24tdG9nZ2xlXFxcIiBkYXRhLXRvZ2dsZT1cXFwiZHJvcGRvd25cXFwiPlxcbiAgICAgICAgICAgIDxpbWcgc3JjPVxcXCIvYXBpL3VzZXIvcGhvdG8vPCUtIHVzZXIuaWQgJT5cXFwiIGNsYXNzPVxcXCJuYXZiYXItcGVvcGxlXFxcIi8+ICZuYnNwO1xcbiAgICAgICAgICAgICAgPCUgaWYgKHVzZXIubmFtZSkgeyAlPjwlLSB1c2VyLm5hbWUgJT5cXG4gICAgICAgICAgICAgIDwlIH0gZWxzZSB7ICU+PCUtIHVzZXIudXNlcm5hbWUgJT5cXG4gICAgICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgPHVsIGNsYXNzPVxcXCJkcm9wZG93bi1tZW51XFxcIiByb2xlPVxcXCJtZW51XFxcIiBhcmlhLWxhYmVsbGVkYnk9XFxcIm5hdmJhci1wcm9maWxlXFxcIj5cXG4gICAgICAgICAgICAgIDxsaSByb2xlPVxcXCJwcmVzZW50YXRpb25cXFwiPjxhIHJvbGU9XFxcIm1lbnVpdGVtXFxcIiBjbGFzcz1cXFwibmF2LWxpbmtcXFwiIHRhYmluZGV4PVxcXCItMVxcXCIgaHJlZj1cXFwiL3Byb2ZpbGVcXFwiPlByb2ZpbGU8L2E+PC9saT5cXG4gICAgICAgICAgICAgIDwlIGlmICh1c2VyLmlzQWRtaW4gPT09IHRydWUpIHsgJT5cXG4gICAgICAgICAgICAgIDxsaSByb2xlPVxcXCJwcmVzZW50YXRpb25cXFwiIGNsYXNzPVxcXCJkaXZpZGVyXFxcIj48L2xpPlxcbiAgICAgICAgICAgICAgPGxpIHJvbGU9XFxcInByZXNlbnRhdGlvblxcXCI+PGEgcm9sZT1cXFwibWVudWl0ZW1cXFwiXFxuICAgICAgICAgICAgICAgICB0YWJpbmRleD1cXFwiLTFcXFwiIGhyZWY9XFxcIi9hZG1pblxcXCIgY2xhc3M9XFxcIm5hdi1saW5rXFxcIj5BZG1pbmlzdHJhdGlvbjwvYT48L2xpPlxcbiAgICAgICAgICAgICAgPCUgfSAlPlxcbiAgICAgICAgICAgICAgPCUgaWYgKGxvZ2luLmxvY2FsLmxvZ291dCkgeyAlPlxcbiAgICAgICAgICAgICAgPGxpIHJvbGU9XFxcInByZXNlbnRhdGlvblxcXCIgY2xhc3M9XFxcImRpdmlkZXJcXFwiPjwvbGk+XFxuICAgICAgICAgICAgICA8bGkgcm9sZT1cXFwicHJlc2VudGF0aW9uXFxcIj48YSByb2xlPVxcXCJtZW51aXRlbVxcXCJcXG4gICAgICAgICAgICAgICAgIHRhYmluZGV4PVxcXCItMVxcXCIgaHJlZj1cXFwiL2F1dGgvbG9nb3V0XFxcIiBjbGFzcz1cXFwibG9nb3V0XFxcIj5Mb2dvdXQ8L2E+PC9saT5cXG4gICAgICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgICA8L3VsPlxcbiAgICAgICAgICA8L2xpPlxcbiAgICAgICAgPCUgfSBlbHNlIHsgJT5cXG4gICAgICAgICAgPCUgaWYgKGxvZ2luLnNpZ25pbiAhPT0gZmFsc2UpIHsgJT5cXG4gICAgICAgICAgPGxpIGNsYXNzPVxcXCJuYXZiYXItMWxpbmVcXFwiPjxhIGhyZWY9XFxcIi9hdXRoXFxcIiBjbGFzcz1cXFwibG9naW5cXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1wbHVzLWNpcmNsZVxcXCI+PC9pPiBTaWduIEluPC9hPjwvbGk+XFxuICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgIDwlIH07ICU+XFxuICAgICAgPC91bD5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG48L2Rpdj5cXG5cIjtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uL21peGlucy91dGlsaXRpZXMnKTtcbnZhciBVSUNvbmZpZyA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbmZpZy91aS5qc29uJyk7XG52YXIgTG9naW4gPSByZXF1aXJlKCcuLi8uLi8uLi9jb25maWcvbG9naW4uanNvbicpO1xudmFyIExvZ2luQ29udHJvbGxlciA9IHJlcXVpcmUoJy4uLy4uL2xvZ2luL2NvbnRyb2xsZXJzL2xvZ2luX2NvbnRyb2xsZXInKTtcbnZhciBOYXZUZW1wbGF0ZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy9uYXZfdGVtcGxhdGUuaHRtbCcpO1xuXG5cbnZhciBOYXZWaWV3ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuXG4gIGV2ZW50czoge1xuICAgICdjbGljayAubmF2YmFyLWJyYW5kJyAgIDogbGlua0JhY2tib25lLFxuICAgICdjbGljayAubmF2LWxpbmsnICAgICAgIDogbGlua0JhY2tib25lLFxuICAgICdjbGljayAubG9naW4nICAgICAgICAgIDogJ2xvZ2luQ2xpY2snLFxuICAgICdjbGljayAubG9nb3V0JyAgICAgICAgIDogJ2xvZ291dCdcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgdGhpcy5saXN0ZW5Ubyh3aW5kb3cuY2FjaGUudXNlckV2ZW50cywgXCJ1c2VyOmxvZ2luOnN1Y2Nlc3NcIiwgZnVuY3Rpb24gKHVzZXJEYXRhKSB7XG4gICAgICBzZWxmLmRvUmVuZGVyKHsgdXNlcjogdXNlckRhdGEgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmxpc3RlblRvKHdpbmRvdy5jYWNoZS51c2VyRXZlbnRzLCBcInVzZXI6bG9nb3V0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuZG9SZW5kZXIoeyB1c2VyOiBudWxsIH0pO1xuICAgICAgQmFja2JvbmUuaGlzdG9yeS5sb2FkVXJsKCk7XG4gICAgICB3aW5kb3cuY2FjaGUudXNlckV2ZW50cy50cmlnZ2VyKFwidXNlcjpsb2dvdXQ6c3VjY2Vzc1wiKTtcbiAgICB9KTtcblxuICAgIC8vIHJlcXVlc3QgdGhhdCB0aGUgdXNlciBsb2cgaW4gdG8gc2VlIHRoZSBwYWdlXG4gICAgdGhpcy5saXN0ZW5Ubyh3aW5kb3cuY2FjaGUudXNlckV2ZW50cywgXCJ1c2VyOnJlcXVlc3Q6bG9naW5cIiwgZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgIC8vIHRyaWdnZXIgdGhlIGxvZ2luIG1vZGFsXG4gICAgICBzZWxmLmxvZ2luKG1lc3NhZ2UpO1xuICAgIH0pO1xuXG4gICAgLy8gdXBkYXRlIHRoZSBuYXZiYXIgd2hlbiB0aGUgcHJvZmlsZSBjaGFuZ2VzXG4gICAgdGhpcy5saXN0ZW5Ubyh3aW5kb3cuY2FjaGUudXNlckV2ZW50cywgXCJ1c2VyOnByb2ZpbGU6c2F2ZVwiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgLy8gcmVzZXQgdGhlIGN1cnJlbnRVc2VyIG9iamVjdFxuICAgICAgd2luZG93LmNhY2hlLmN1cnJlbnRVc2VyID0gZGF0YTtcbiAgICAgIC8vIHJlLXJlbmRlciB0aGUgdmlld1xuICAgICAgc2VsZi5yZW5kZXIoKTtcbiAgICB9KTtcblxuICAgIC8vIHVwZGF0ZSB0aGUgdXNlcidzIHBob3RvIHdoZW4gdGhleSBjaGFuZ2UgaXRcbiAgICB0aGlzLmxpc3RlblRvKHdpbmRvdy5jYWNoZS51c2VyRXZlbnRzLCBcInVzZXI6cHJvZmlsZTpwaG90bzpzYXZlXCIsIGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICQoXCIubmF2YmFyLXBlb3BsZVwiKS5hdHRyKCdzcmMnLCB1cmwpO1xuICAgIH0pO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmRvUmVuZGVyKHsgdXNlcjogd2luZG93LmNhY2hlLmN1cnJlbnRVc2VyLCBzeXN0ZW1OYW1lOiB3aW5kb3cuY2FjaGUuc3lzdGVtLm5hbWUgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgZG9SZW5kZXI6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGF0YS5sb2dpbiA9IExvZ2luO1xuICAgIGRhdGEudWkgPSBVSUNvbmZpZztcbiAgICB2YXIgdGVtcGxhdGUgPSBfLnRlbXBsYXRlKE5hdlRlbXBsYXRlKShkYXRhKTtcbiAgICB0aGlzLiRlbC5odG1sKHRlbXBsYXRlKTtcbiAgICB0aGlzLiRlbC5pMThuKCk7XG4gICAgJChcIi5uYXYgbGlcIikub24oXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAkKFwiLm5hdiBsaVwiKS5yZW1vdmVDbGFzcyhcImFjdGl2ZVwiKTtcbiAgICAgICQodGhpcykuYWRkQ2xhc3MoXCJhY3RpdmVcIik7XG4gICAgfSk7XG4gIH0sXG5cbiAgbG9naW5DbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMubG9naW4oKTtcbiAgfSxcblxuICBsb2dpbjogZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5sb2dpbkNvbnRyb2xsZXIpIHtcbiAgICAgIHRoaXMubG9naW5Db250cm9sbGVyLmNsZWFudXAoKTtcbiAgICB9XG4gICAgdGhpcy5sb2dpbkNvbnRyb2xsZXIgPSBuZXcgTG9naW5Db250cm9sbGVyKHtcbiAgICAgIGVsOiAnI2xvZ2luLXdyYXBwZXInLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgIH0pO1xuICB9LFxuXG4gIGxvZ291dDogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICQuYWpheCh7XG4gICAgICB1cmw6ICcvYXBpL2F1dGgvbG9nb3V0P2pzb249dHJ1ZScsXG4gICAgfSkuZG9uZShmdW5jdGlvbiAoc3VjY2Vzcykge1xuICAgICAgd2luZG93LmNhY2hlLmN1cnJlbnRVc2VyID0gbnVsbDtcbiAgICAgIHdpbmRvdy5jYWNoZS51c2VyRXZlbnRzLnRyaWdnZXIoXCJ1c2VyOmxvZ291dFwiKTtcbiAgICB9KS5mYWlsKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH0pO1xuICB9LFxuXG4gIGNsZWFudXA6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5sb2dpbkNvbnRyb2xsZXIpIHsgdGhpcy5sb2dpbkNvbnRyb2xsZXIuY2xlYW51cCgpOyB9XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfSxcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5hdlZpZXc7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGZvcm0gcm9sZT1cXFwiZm9ybVxcXCIgYWN0aW9uPVxcXCJcXFwiIGlkPVxcXCJlbWFpbC1mb3JtXFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWJvZHlcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJhbGVydCBhbGVydC13YXJuaW5nXFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI+PC9kaXY+XFxuICAgIDxmaWVsZHNldD5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcImVtYWlsXFxcIj5FbWFpbCBBZGRyZXNzPC9sYWJlbD5cXG4gICAgICAgIDxpbnB1dCB0eXBlPVxcXCJlbWFpbFxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgaWQ9XFxcImVtYWlsXFxcIiBuYW1lPVxcXCJlbWFpbFxcXCIgcGxhY2Vob2xkZXI9XFxcIm5hbWVAZG9tYWluLmNvbVxcXCIvPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2ZpZWxkc2V0PlxcbiAgPC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1mb290ZXJcXFwiPlxcbiAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tYzBcXFwiIGRhdGEtZGlzbWlzcz1cXFwibW9kYWxcXFwiPkNhbmNlbDwvYnV0dG9uPlxcbiAgICA8aW5wdXQgdHlwZT1cXFwic3VibWl0XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1jMlxcXCIgaWQ9XFxcInN1Ym1pdFxcXCIgdmFsdWU9XFxcIkFkZCBFbWFpbCBBZGRyZXNzXFxcIi8+XFxuICA8L2Rpdj5cXG48L2Zvcm0+XFxuXCI7XG4iLCJcbnZhciBCb290c3RyYXAgPSByZXF1aXJlKCdib290c3RyYXAnKTtcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL21peGlucy91dGlsaXRpZXMnKTtcbnZhciBFbWFpbEZvcm1UZW1wbGF0ZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy9wcm9maWxlX2VtYWlsX2Zvcm0uaHRtbCcpO1xuXG5cbnZhciBFbWFpbEZvcm1WaWV3ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuXG4gIGV2ZW50czoge1xuICAgIFwic3VibWl0ICNlbWFpbC1mb3JtXCIgOiBcInBvc3RcIlxuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy50YXJnZXQgPSBvcHRpb25zLnRhcmdldDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciB0ZW1wbGF0ZSA9IF8udGVtcGxhdGUoRW1haWxGb3JtVGVtcGxhdGUpKHt9KTtcbiAgICB0aGlzLiRlbC5odG1sKHRlbXBsYXRlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBwb3N0OiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIGRhdGE7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy4kKFwiLmFsZXJ0XCIpLmhpZGUoKTtcbiAgICBkYXRhID0ge1xuICAgICAgZW1haWw6ICQoZS5jdXJyZW50VGFyZ2V0KS5maW5kKFwiI2VtYWlsXCIpLnZhbCgpLFxuICAgIH1cblxuICAgICQuYWpheCh7XG4gICAgICB1cmw6ICcvYXBpL3VzZXJlbWFpbCcsXG4gICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICBkYXRhOiBkYXRhLFxuICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAvLyBQYXNzIHRoZSB0YWcgYmFja1xuICAgICAgICBzZWxmLm9wdGlvbnMubW9kZWwudHJpZ2dlcihzZWxmLnRhcmdldCArIFwiOmVtYWlsOm5ld1wiLCByZXN1bHQpO1xuICAgICAgfSxcbiAgICAgIGVycm9yOiBmdW5jdGlvbiAocmVxLCBzdGF0dXMsIGVycm9yKSB7XG4gICAgICAgIHNlbGYuJChcIi5hbGVydFwiKS5odG1sKHJlcS5yZXNwb25zZUpTT04ubWVzc2FnZSk7XG4gICAgICAgIHNlbGYuJChcIi5hbGVydFwiKS5zaG93KCk7XG4gICAgICAgIHNlbGYub3B0aW9ucy5tb2RlbC50cmlnZ2VyKHNlbGYudGFyZ2V0ICsgXCI6ZW1haWw6ZXJyb3JcIiwgcmVxLnJlc3BvbnNlSlNPTik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgfSxcblxuICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBFbWFpbEZvcm1WaWV3O1xuIiwiXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgQmFzZUNvbnRyb2xsZXIgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9iYXNlL2Jhc2VfY29udHJvbGxlcicpO1xudmFyIFByb2ZpbGVNb2RlbCA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2VudGl0aWVzL3Byb2ZpbGVzL3Byb2ZpbGVfbW9kZWwnKTtcbnZhciBQcm9maWxlVmlldyA9IHJlcXVpcmUoJy4uL3ZpZXdzL3Byb2ZpbGVfc2hvd192aWV3Jyk7XG52YXIgUHJvZmlsZVNldHRpbmdzVmlldyA9IHJlcXVpcmUoJy4uL3ZpZXdzL3Byb2ZpbGVfc2V0dGluZ3NfdmlldycpO1xudmFyIFByb2ZpbGVSZXNldFZpZXcgPSByZXF1aXJlKCcuLi92aWV3cy9wcm9maWxlX3Jlc2V0X3ZpZXcnKTtcbnZhciBMb2dpbiA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2NvbmZpZy9sb2dpbi5qc29uJyk7XG52YXIgQWxlcnRUZW1wbGF0ZSA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2NvbXBvbmVudHMvYWxlcnRfdGVtcGxhdGUuaHRtbCcpO1xuXG5Qcm9maWxlID0gQmFzZUNvbnRyb2xsZXIuZXh0ZW5kKHtcblxuICAvLyBIZXJlIHdlIGFyZSBkZWZpbmluZyB3ZXRoZXIgb3Igbm90IHRoaXMgaXMgYSBmdWxsLXJlZ2lvbiBvYmplY3RcbiAgLy8gb3IgYSBzdWItcmVnaW9uIG9mIGFub3RoZXIgcmVnaW9uLlxuICByZWdpb246IHRydWUsXG4gIHN1YlJlZ2lvbjogZmFsc2UsXG5cbiAgZWw6IFwiI2NvbnRhaW5lclwiLFxuXG4gIGV2ZW50czoge1xuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnJvdXRlSWQgPSBvcHRpb25zLmlkO1xuICAgIHRoaXMuYWN0aW9uID0gb3B0aW9ucy5hY3Rpb247XG4gICAgdGhpcy5kYXRhID0gb3B0aW9ucy5kYXRhO1xuICAgIHRoaXMuaW5pdGlhbGl6ZUNvbnRyb2xsZXIoKTtcbiAgfSxcblxuICBpbml0aWFsaXplQ29udHJvbGxlcjogZnVuY3Rpb24gKCkge1xuICAgIC8vIENsZWFuIHVwIHByZXZpb3VzIHZpZXdzXG4gICAgaWYgKHRoaXMucHJvZmlsZVZpZXcpIHsgdGhpcy5wcm9maWxlVmlldy5jbGVhbnVwKCk7IH1cbiAgICBpZiAodGhpcy5zZXR0aW5nc1ZpZXcpIHsgdGhpcy5zZXR0aW5nc1ZpZXcuY2xlYW51cCgpOyB9XG4gICAgaWYgKHRoaXMucHJvZmlsZVJlc2V0VmlldykgeyB0aGlzLnByb2ZpbGVSZXNldFZpZXcuY2xlYW51cCgpOyB9XG4gICAgLy8gSWYgdGhlIGFjdGlvbiBkb2VzIG5vdCByZXF1aXJlIHRoZSBwcm9maWxlIG1vZGVsLCBkaXNwbGF5IHRoYXQgYWN0aW9uXG4gICAgaWYgKHRoaXMucm91dGVJZCA9PSAncmVzZXQnKSB7XG4gICAgICB0aGlzLnByb2ZpbGVSZXNldFZpZXcgPSBuZXcgUHJvZmlsZVJlc2V0Vmlldyh7XG4gICAgICAgIGVsOiB0aGlzLiRlbCxcbiAgICAgICAgcm91dGVJZDogdGhpcy5yb3V0ZUlkLFxuICAgICAgICBhY3Rpb246IHRoaXMuYWN0aW9uLFxuICAgICAgICBkYXRhOiB0aGlzLmRhdGFcbiAgICAgIH0pLnJlbmRlcigpO1xuICAgIH1cbiAgICAvLyBvdGhlcndpc2UgbG9hZCB0aGUgcHJvZmlsZSBtb2RlbCBhbmQgZGlzcGxheSB0aGUgYXBwcm9wcmlhdGUgdmlld1xuICAgIGVsc2Uge1xuICAgICAgdGhpcy5pbml0aWFsaXplUHJvZmlsZU1vZGVsSW5zdGFuY2UoKTtcbiAgICB9XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZVByb2ZpbGVNb2RlbEluc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMubW9kZWwpIHRoaXMubW9kZWwucmVtb3ZlKCk7XG4gICAgdGhpcy5tb2RlbCA9IG5ldyBQcm9maWxlTW9kZWwoKTtcblxuICAgIC8vIHByZXZlbnQgZGlyZWN0bHkgZWRpdGluZyBwcm9maWxlcyB3aGVuIGRpc2FibGVkXG4gICAgaWYgKChMb2dpbi5wcm9maWxlLmVkaXQgPT09IGZhbHNlKSAmJiAodGhpcy5hY3Rpb24gPT0gJ2VkaXQnKSkge1xuICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgIGFsZXJ0OiB7XG4gICAgICAgICAgbWVzc2FnZTogXCI8c3Ryb25nPkRpcmVjdCBlZGl0aW5nIG9mIHByb2ZpbGVzIGlzIGRpc2FibGVkLjwvc3Ryb25nPiAgPGEgaHJlZj1cXFwiXCIgKyBMb2dpbi5wcm9maWxlLmVkaXRVcmwgKyBcIlxcXCIgdGl0bGU9XFxcIkVkaXQgUHJvZmlsZVxcXCI+Q2xpY2sgaGVyZSB0byBlZGl0IHlvdXIgcHJvZmlsZTwvYT5cIlxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZShBbGVydFRlbXBsYXRlKShkYXRhKVxuICAgICAgdGhpcy4kZWwuaHRtbCh0ZW1wbGF0ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHZhciBmZXRjaElkID0gbnVsbDtcbiAgICAvLyBpZiAodGhpcy5pZCAmJiB0aGlzLmlkICE9ICdlZGl0JykgeyBmZXRjaElkID0gdGhpcy5pZDsgfVxuICAgIHRoaXMubW9kZWwudHJpZ2dlcihcInByb2ZpbGU6ZmV0Y2hcIiwgdGhpcy5yb3V0ZUlkKTtcbiAgICAvLyBwcm9jZXNzIGEgc3VjY2Vzc2Z1bCBtb2RlbCBmZXRjaCwgYW5kIGRpc3BsYXkgdGhlIG1vZGVsXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCBcInByb2ZpbGU6ZmV0Y2g6c3VjY2Vzc1wiLCBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgIC8vIEBpbnN0YW5jZVxuICAgICAgc2VsZi5tb2RlbCA9IG1vZGVsO1xuICAgICAgdmFyIG1vZGVsSnNvbiA9IG1vZGVsLnRvSlNPTigpO1xuICAgICAgZm9yIChpIGluIG1vZGVsSnNvbi50YWdzKSB7XG4gICAgICAgIGlmIChtb2RlbEpzb24udGFnc1tpXS50YWcudHlwZSA9PSAnYWdlbmN5Jykge1xuICAgICAgICAgIHNlbGYubW9kZWwuYWdlbmN5ID0gbW9kZWxKc29uLnRhZ3NbaV0udGFnO1xuICAgICAgICAgIHNlbGYubW9kZWwuYWdlbmN5Wyd0YWdJZCddID0gbW9kZWxKc29uLnRhZ3NbaV0uaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobW9kZWxKc29uLnRhZ3NbaV0udGFnLnR5cGUgPT0gJ2xvY2F0aW9uJykge1xuICAgICAgICAgIHNlbGYubW9kZWwubG9jYXRpb24gPSBtb2RlbEpzb24udGFnc1tpXS50YWc7XG4gICAgICAgICAgc2VsZi5tb2RlbC5sb2NhdGlvblsndGFnSWQnXSA9IG1vZGVsSnNvbi50YWdzW2ldLmlkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZWxmLmluaXRpYWxpemVQcm9maWxlVmlld0luc3RhbmNlKCk7XG4gICAgfSk7XG4gICAgLy8gaWYgdGhlIHByb2ZpbGUgZmV0Y2ggZmFpbHMsIGNoZWNrIGlmIGl0IGlzIGR1ZSB0byB0aGUgdXNlclxuICAgIC8vIG5vdCBiZWluZyBsb2dnZWQgaW5cbiAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsIFwicHJvZmlsZTpmZXRjaDplcnJvclwiLCBmdW5jdGlvbiAobW9kZWwsIHJlc3BvbnNlKSB7XG4gICAgICAvLyBpZiB0aGUgdXNlciBpc24ndCBsb2dnZWQgaW4sIHRyaWdnZXIgdGhlIGxvZ2luIHdpbmRvd1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgIHdpbmRvdy5jYWNoZS51c2VyRXZlbnRzLnRyaWdnZXIoXCJ1c2VyOnJlcXVlc3Q6bG9naW5cIiwge1xuICAgICAgICAgIG1lc3NhZ2U6IFwiWW91IG11c3QgYmUgbG9nZ2VkIGluIHRvIHZpZXcgcHJvZmlsZXNcIixcbiAgICAgICAgICBkaXNhYmxlQ2xvc2U6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgIGFsZXJ0OiB7XG4gICAgICAgICAgbWVzc2FnZTogXCI8c3Ryb25nPlVuYWJsZSB0byBsb2FkIHByb2ZpbGUuICBQbGVhc2UgcmVsb2FkIHRoaXMgcGFnZSB0byB0cnkgYWdhaW4uPC9zdHJvbmc+PGJyLz5FcnJvcjogXCJcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIC8vIGNoZWNrIGlmIHRoZSByZXNwb25zZSBwcm92aWRlZCBhbiBlcnJvclxuICAgICAgaWYgKHJlc3BvbnNlLnJlc3BvbnNlVGV4dCkge1xuICAgICAgICB2YXIgZXJyID0gSlNPTi5wYXJzZShyZXNwb25zZS5yZXNwb25zZVRleHQpO1xuICAgICAgICBpZiAoZXJyLm1lc3NhZ2UpIHtcbiAgICAgICAgICBkYXRhLmFsZXJ0Lm1lc3NhZ2UgKz0gZXJyLm1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB0ZW1wbGF0ZSA9IF8udGVtcGxhdGUoQWxlcnRUZW1wbGF0ZSkoZGF0YSlcbiAgICAgIHNlbGYuJGVsLmh0bWwodGVtcGxhdGUpO1xuICAgIH0pO1xuICB9LFxuXG4gIGluaXRpYWxpemVQcm9maWxlVmlld0luc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuYWN0aW9uID09ICdzZXR0aW5ncycpIHtcbiAgICAgIHRoaXMuc2V0dGluZ3NWaWV3ID0gbmV3IFByb2ZpbGVTZXR0aW5nc1ZpZXcoe1xuICAgICAgICBlbDogdGhpcy4kZWwsXG4gICAgICAgIG1vZGVsOiB0aGlzLm1vZGVsLFxuICAgICAgICByb3V0ZUlkOiB0aGlzLnJvdXRlSWQsXG4gICAgICAgIGFjdGlvbjogdGhpcy5hY3Rpb24sXG4gICAgICAgIGRhdGE6IHRoaXMuZGF0YVxuICAgICAgfSkucmVuZGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJvZmlsZVZpZXcgPSBuZXcgUHJvZmlsZVZpZXcoe1xuICAgICAgICBlbDogdGhpcy4kZWwsXG4gICAgICAgIG1vZGVsOiB0aGlzLm1vZGVsLFxuICAgICAgICByb3V0ZUlkOiB0aGlzLnJvdXRlSWQsXG4gICAgICAgIGFjdGlvbjogdGhpcy5hY3Rpb24sXG4gICAgICAgIGRhdGE6IHRoaXMuZGF0YVxuICAgICAgfSkucmVuZGVyKCk7XG4gICAgfVxuICB9LFxuXG4gIGNsZWFudXA6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnByb2ZpbGVWaWV3KSB7IHRoaXMucHJvZmlsZVZpZXcuY2xlYW51cCgpOyB9XG4gICAgaWYgKHRoaXMuc2V0dGluZ3NWaWV3KSB7IHRoaXMuc2V0dGluZ3NWaWV3LmNsZWFudXAoKTsgfVxuICAgIHJlbW92ZVZpZXcodGhpcyk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvZmlsZTtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8dWwgY2xhc3M9XFxcIm5hdiBuYXYtdGFic1xcXCI+XFxuICA8bGkgY2xhc3M9XFxcImFjdGl2ZVxcXCI+PGEgaHJlZj1cXFwiIzwlPSBoYW5kbGUgJT4tdGFiLW9wZW5cXFwiIGRhdGEtdG9nZ2xlPVxcXCJ0YWJcXFwiPk9wZW48L2E+PC9saT5cXG4gIDxsaT48YSBocmVmPVxcXCIjPCU9IGhhbmRsZSAlPi10YWItY2xvc2VkXFxcIiBkYXRhLXRvZ2dsZT1cXFwidGFiXFxcIj5DbG9zZWQ8L2E+PC9saT5cXG48L3VsPlxcblxcbjxkaXYgY2xhc3M9XFxcInRhYi1jb250ZW50XFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcInRhYi1wYW5lIGFjdGl2ZVxcXCIgaWQ9XFxcIjwlPSBoYW5kbGUgJT4tdGFiLW9wZW5cXFwiPlxcbiAgICA8dGFibGUgY2xhc3M9XFxcInRhYmxlIHRhYmxlLWNvbmRlbnNlZCB0YWJsZS1ob3ZlclxcXCI+XFxuICAgICAgPCUgaWYgKCBjb3VudC5vcGVuID4gMCB8fCBjb3VudC5hc3NpZ25lZCA+IDAgfHwgY291bnQuZHJhZnQgPiAwKSB7ICU+XFxuICAgICAgICA8dGhlYWQ+XFxuICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICA8dGggZGF0YS1pMThuPVxcXCI8JT0gdGFyZ2V0Q2FwaXRhbGl6ZWQgJT5cXFwiPlByb2plY3Q8L3RoPlxcbiAgICAgICAgICAgIDx0aD5DcmVhdGVkPC90aD5cXG4gICAgICAgICAgICA8dGg+TGlrZXM8L3RoPlxcbiAgICAgICAgICA8L3RyPlxcbiAgICAgICAgPC90aGVhZD5cXG4gICAgICAgIDx0Ym9keT5cXG4gICAgICAgIDwlIGZvciAodmFyIGkgaW4gZGF0YSkgeyAlPlxcbiAgICAgICAgICA8JSBpZiAoZGF0YVtpXS5zdGF0ZSA9PSAnY29tcGxldGVkJyB8fCBkYXRhW2ldLnN0YXRlID09ICdhcmNoaXZlZCcpIHsgY29udGludWU7IH0gJT5cXG4gICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgIDx0ZD5cXG4gICAgICAgICAgICAgIDwlIGlmIChkYXRhW2ldLnN0YXRlID09ICdkcmFmdCcpIHsgJT5cXG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJsYWJlbCBsYWJlbC13YXJuaW5nXFxcIj5kcmFmdDwvc3Bhbj5cXG4gICAgICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgICAgIDxhIGhyZWY9XFxcIjwlPSB0YXJnZXQgJT5zLzwlPSBkYXRhW2ldLmlkICU+XFxcIiBjbGFzcz1cXFwiYWN0aXZpdHktbGlua1xcXCIgZGF0YS1pZD1cXFwiPCU9IGRhdGFbaV0uaWQgJT5cXFwiPjwlPSBkYXRhW2ldLnRpdGxlICU+PC9hPlxcbiAgICAgICAgICAgIDwvdGQ+XFxuICAgICAgICAgICAgPHRkPlxcbiAgICAgICAgICAgICAgPCUgdmFyIGNyZWF0ZWQgPSBuZXcgRGF0ZShkYXRhW2ldLmNyZWF0ZWRBdCk7ICU+XFxuICAgICAgICAgICAgICA8JT0gY3JlYXRlZC50b0xvY2FsZURhdGVTdHJpbmcoKSAlPiA8JT0gY3JlYXRlZC50b0xvY2FsZVRpbWVTdHJpbmcoKSAlPjwvdGQ+XFxuICAgICAgICAgICAgPHRkPjwlPSBkYXRhW2ldLmxpa2VDb3VudCAlPjwvdGQ+XFxuICAgICAgICAgIDwvdHI+XFxuICAgICAgICA8JSB9ICU+XFxuICAgICAgICA8L3Rib2R5PlxcbiAgICAgIDwlIH0gZWxzZSB7ICU+XFxuICAgICAgICA8dGJvZHk+XFxuICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICA8dGQ+Tm8gPCU9IHRhcmdldHNGcmllbmRseSAlPjwvdGQ+XFxuICAgICAgICAgIDwvdHI+XFxuICAgICAgICA8L3Rib2R5PlxcbiAgICAgIDwlIH0gJT5cXG4gICAgPC90YWJsZT5cXG4gIDwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwidGFiLXBhbmVcXFwiIGlkPVxcXCI8JT0gaGFuZGxlICU+LXRhYi1jbG9zZWRcXFwiPlxcbiAgICA8dGFibGUgY2xhc3M9XFxcInRhYmxlIHRhYmxlLWNvbmRlbnNlZCB0YWJsZS1ob3ZlclxcXCI+XFxuICAgICAgPCUgaWYgKGNvdW50LmNvbXBsZXRlZCA+IDAgfHwgY291bnQuYXJjaGl2ZWQgPiAwKSB7ICU+XFxuICAgICAgICA8dGhlYWQ+XFxuICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICA8dGggZGF0YS1pMThuPVxcXCI8JT0gdGFyZ2V0Q2FwaXRhbGl6ZWQgJT5cXFwiPlByb2plY3Q8L3RoPlxcbiAgICAgICAgICAgIDx0aD5DcmVhdGVkPC90aD5cXG4gICAgICAgICAgICA8dGg+TGlrZXM8L3RoPlxcbiAgICAgICAgICA8L3RyPlxcbiAgICAgICAgPC90aGVhZD5cXG4gICAgICAgIDx0Ym9keT5cXG4gICAgICAgIDwlIGZvciAodmFyIGkgaW4gZGF0YSkgeyAlPlxcbiAgICAgICAgICA8JSBpZiAoZGF0YVtpXS5zdGF0ZSAhPT0gJ2NvbXBsZXRlZCcgJiYgZGF0YVtpXS5zdGF0ZSAhPT0gJ2FyY2hpdmVkJykgeyBjb250aW51ZTsgfSAlPlxcbiAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgPHRkPlxcbiAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiPCU9IHRhcmdldCAlPnMvPCU9IGRhdGFbaV0uaWQgJT5cXFwiIGNsYXNzPVxcXCJhY3Rpdml0eS1saW5rXFxcIiBkYXRhLWlkPVxcXCI8JT0gZGF0YVtpXS5pZCAlPlxcXCI+PCU9IGRhdGFbaV0udGl0bGUgJT48L2E+XFxuICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgICAgICA8dGQ+PCU9IGRhdGFbaV0uY3JlYXRlZEF0ICU+PC90ZD5cXG4gICAgICAgICAgICA8dGQ+PCU9IGRhdGFbaV0ubGlrZUNvdW50ICU+PC90ZD5cXG4gICAgICAgICAgPC90cj5cXG4gICAgICAgIDwlIH0gJT5cXG4gICAgICAgIDwvdGJvZHk+XFxuICAgICAgPCUgfSBlbHNlIHsgJT5cXG4gICAgICAgIDx0Ym9keT5cXG4gICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgIDx0ZD5ObyA8JT0gdGFyZ2V0c0ZyaWVuZGx5ICU+PC90ZD5cXG4gICAgICAgICAgPC90cj5cXG4gICAgICAgIDwvdGJvZHk+XFxuICAgICAgPCUgfSAlPlxcbiAgICA8L3RhYmxlPlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwicmFkaW9cXFwiPlxcbiAgPGxhYmVsPlxcbiAgICA8aW5wdXQgdHlwZT1cXFwicmFkaW9cXFwiIG5hbWU9XFxcInByaW1hcnlFbWFpbFxcXCIgaWQ9XFxcImVtYWlsLTwlLSBlbWFpbC5pZCAlPlxcXCIgdmFsdWU9XFxcIjwlLSBlbWFpbC5lbWFpbCAlPlxcXCIgPCUgaWYgKGVtYWlsLmlzUHJpbWFyeSkgeyAlPmNoZWNrZWQ8JSB9ICU+PlxcbiAgICA8YSBocmVmPVxcXCIjXFxcIiBjbGFzcz1cXFwiZW1haWwtcmVtb3ZlXFxcIiBpZD1cXFwiZW1haWwtcmVtb3ZlLTwlLSBlbWFpbC5pZCAlPlxcXCIgZGF0YS1pZD1cXFwiPCUtIGVtYWlsLmlkICU+XFxcIj48c3BhbiBjbGFzcz1cXFwiZmEgZmEtdHJhc2hcXFwiPjwvc3Bhbj48L2E+IDwlLSBlbWFpbC5lbWFpbCAlPlxcbiAgPC9sYWJlbD5cXG48L2Rpdj5cXG5cIjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcblxcbiAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTYgY29sLW1kLW9mZnNldC0zIGJveFxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiYm94LW1haW5cXFwiPlxcblxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwicHJvZmlsZS1yZXNldCBjZW50ZXJcXFwiIGlkPVxcXCJwcm9maWxlLXJlc2V0LWNoZWNrXFxcIj5cXG4gICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLXNwaW4gZmEtc3Bpbm5lclxcXCI+PC9pPiBMb29raW5nIHVwIHBhc3N3b3JkIHJlc2V0IGNvZGUuLi5cXG4gICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwicHJvZmlsZS1yZXNldCBlcnJvclxcXCIgaWQ9XFxcInByb2ZpbGUtcmVzZXQtY2hlY2stZXJyb3JcXFwiIHN0eWxlPVxcXCJkaXNwbGF5OiBub25lO1xcXCI+XFxuICAgICAgICAgIFRoaXMgaXMgbm90IGEgdmFsaWQgcGFzc3dvcmQgcmVzZXQgY29kZS4gIFBsZWFzZSB0cnkgcmVzZXR0aW5nIHlvdXIgcGFzc3dvcmQgYWdhaW4gYW5kIGNsaWNraW5nIG9uIHRoZSBsaW5rIGluIHRoZSBlbWFpbC5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwicHJvZmlsZS1yZXNldCBlcnJvclxcXCIgaWQ9XFxcInByb2ZpbGUtcmVzZXQtc3VibWl0LWVycm9yXFxcIiBzdHlsZT1cXFwiZGlzcGxheTogbm9uZTtcXFwiPlxcbiAgICAgICAgICBBbiBlcnJvciBvY2N1cnJlZCByZXNldHRpbmcgeW91ciBwYXNzd29yZC4gIFBsZWFzZSByZWxvYWQgdGhpcyBwYWdlIGFuZCB0cnkgYWdhaW4uXFxuICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInByb2ZpbGUtcmVzZXRcXFwiIGlkPVxcXCJwcm9maWxlLXJlc2V0LWRpYWxvZ1xcXCIgc3R5bGU9XFxcImRpc3BsYXk6IG5vbmU7XFxcIj5cXG4gICAgICAgICAgPGZvcm0gaWQ9XFxcImZvcm0tcGFzc3dvcmQtcmVzZXRcXFwiIHRpdGxlPVxcXCJQYXNzd29yZCBSZXNldFxcXCI+XFxuICAgICAgICAgICAgPGgxPlxcbiAgICAgICAgICAgICAgUGxlYXNlIHNldCBhIG5ldyBwYXNzd29yZCBmb3IgeW91ciBhY2NvdW50LlxcbiAgICAgICAgICAgIDwvaDE+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicGFzc3dvcmQtdmlld1xcXCI+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdj5cXG4gICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJzdWJtaXRcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWMxXFxcIiB2YWx1ZT1cXFwiUmVzZXQgUGFzc3dvcmRcXFwiLz5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPC9mb3JtPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwcm9maWxlLXJlc2V0IGNlbnRlclxcXCIgaWQ9XFxcInByb2ZpbGUtcmVzZXQtc3VibWl0XFxcIiBzdHlsZT1cXFwiZGlzcGxheTogbm9uZTtcXFwiPlxcbiAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtc3BpbiBmYS1zcGlubmVyXFxcIj48L2k+IFBlcmZvcm1pbmcgcGFzc3dvcmQgcmVzZXQuICBQbGVhc2Ugc3RhbmQgYnkuLi5cXG4gICAgICAgIDwvZGl2PlxcblxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcblxcbjwvZGl2PlxcblwiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuXFxuICA8ZGl2IGNsYXNzPVxcXCJhbGVydCBhbGVydC1pbmZvXFxcIj5cXG4gICAgUHJvZmlsZSBzZXR0aW5ncyBhcmUgbm90IHlldCBpbXBsZW1lbnRlZC4gIFBsZWFzZSBjb250YWN0IHRoZSBhZG1pbmlzdHJhdG9yIG9mIHRoaXMgc3lzdGVtIHRvIHVwZGF0ZSB5b3VyIGVtYWlsIHNldHRpbmdzLiAgT3VyIGFwb2xvZ2llcywgc3RheSB0dW5lZCFcXG4gIDwvZGl2PlxcblxcbjwvZGl2PlxcblwiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuXFxuICA8JSBpZiAodXNlci5pc0FkbWluKSB7ICU+XFxuICA8ZGl2IGNsYXNzPVxcXCJhbGVydCBhbGVydC1pbmZvXFxcIj5cXG4gICAgWW91IGFyZSBhbiBhZG1pbmlzdHJhdG9yLlxcbiAgICA8JSBpZiAodXNlci5pZCAhPT0gZGF0YS5pZCkgeyAlPlxcbiAgICAgIDwlIGlmIChlZGl0ID09PSB0cnVlKSB7ICU+XFxuICAgICAgICA8c3Ryb25nPllvdSBhcmUgZWRpdGluZyBhbm90aGVyIHVzZXIncyBwcm9maWxlLjwvc3Ryb25nPlxcbiAgICAgIDwlIH0gZWxzZSB7ICU+XFxuICAgICAgICBZb3UgYXJlIHZpZXdpbmcgYW5vdGhlciB1c2VyJ3MgcHJvZmlsZS5cXG4gICAgICA8JSB9ICU+XFxuICAgIDwlIH0gJT5cXG4gIDwvZGl2PlxcbiAgPCUgfSAlPlxcblxcbiAgPCUgaWYgKHNhdmVkKSB7ICU+XFxuICA8ZGl2IGNsYXNzPVxcXCJhbGVydCBhbGVydC1zdWNjZXNzXFxcIj5Zb3VyIHByb2ZpbGUgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IHVwZGF0ZWQuPC9kaXY+XFxuICA8JSB9ICU+XFxuXFxuICA8ZGl2IGNsYXNzPVxcXCJjb2wtc20tMyBjb2wtbWQtNCBwcm9qZWN0LXNpZGViYXJcXFwiPlxcbiAgICA8IS0tIExFRlQgU0lERUJBUiAtLT5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMTIgYm94IHByb2plY3QtaGVhZGVyLXdyYXBwZXJcXFwiPlxcbiAgICAgICAgPGRpdiBpZD1cXFwicHJvamVjdC1oZWFkZXJcXFwiIHN0eWxlPVxcXCJiYWNrZ3JvdW5kLWltYWdlOnVybCgnL2FwaS91c2VyL3Bob3RvLzwlLSBkYXRhLmlkICU+Jyk7XFxcIj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiYnRuIGJ0bi1jMiBmaWxlaW5wdXQtYnV0dG9uXFxcIiA8JSBpZiAoISgoZGF0YS5pc093bmVyIHx8IHVzZXIuaXNBZG1pbikgJiYgZWRpdCkpIHsgJT5zdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI8JSB9ICU+PlxcbiAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1jYW1lcmEgZmEtbGdcXFwiIHRpdGxlPVxcXCJDaGFuZ2UgQ292ZXIgUGhvdG9cXFwiIGlkPVxcXCJmaWxldXBsb2FkLWljb25cXFwiPjwvaT5cXG4gICAgICAgICAgICA8aW5wdXQgaWQ9XFxcImZpbGV1cGxvYWRcXFwiIHR5cGU9XFxcImZpbGVcXFwiIG5hbWU9XFxcImZpbGVzW11cXFwiIHRpdGxlPVxcXCJVcGxvYWQgUGhvdG9cXFwiPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBpZD1cXFwiZmlsZS11cGxvYWQtcHJvZ3Jlc3MtY29udGFpbmVyXFxcIiBzdHlsZT1cXFwiZGlzcGxheTogbm9uZTtcXFwiIGNsYXNzPVxcXCJwcm9ncmVzcyBwcm9ncmVzcy1zdHJpcGVkIGFjdGl2ZVxcXCI+XFxuICAgICAgICAgIDxkaXYgaWQ9XFxcImZpbGUtdXBsb2FkLXByb2dyZXNzXFxcIiBjbGFzcz1cXFwicHJvZ3Jlc3MtYmFyXFxcIiBzdHlsZT1cXFwid2lkdGg6IDBcXFwiPjwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IGlkPVxcXCJmaWxlLXVwbG9hZC1hbGVydFxcXCIgY2xhc3M9XFxcImFsZXJ0IGFsZXJ0LXdhcm5pbmdcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMTIgYm94XFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImJveC1tYWluIHRhZy13cmFwcGVyXFxcIj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcblxcbiAgPGRpdiBjbGFzcz1cXFwiY29sLXNtLTkgY29sLW1kLThcXFwiPlxcbiAgICA8IS0tIFJJR0hUIE1BSU4gQkFSIC0tPlxcbiAgICA8JSBpZiAoZWRpdCkgeyAlPiA8IS0tIGluIGVkaXQgbW9kZSAtLT5cXG4gICAgPGRpdiBjbGFzcz1cXFwiYm94IGJveC1tYWluXFxcIj5cXG4gICAgICA8ZGl2IGlkPVxcXCJlbWFpbE1vZGFsXFxcIj48L2Rpdj5cXG5cXG4gICAgICA8Zm9ybSBjbGFzcz1cXFwiZm9ybS1ob3Jpem9udGFsXFxcIiByb2xlPVxcXCJmb3JtXFxcIiBpZD1cXFwicHJvZmlsZS1mb3JtXFxcIj5cXG4gICAgICAgIDxoMT5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2wgaW5wdXQtbGdcXFwiIGlkPVxcXCJuYW1lXFxcIiBuYW1lPVxcXCJuYW1lXFxcIiBwbGFjZWhvbGRlcj1cXFwiWW91ciBGdWxsIE5hbWVcXFwiIHZhbHVlPVxcXCI8JSBpZiAoZGF0YS5uYW1lKSB7ICU+PCUtIGRhdGEubmFtZSAlPjwlIH0gJT5cXFwiIHRpdGxlPVxcXCJZb3VyIEZ1bGwgTmFtZVxcXCIvPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvaDE+XFxuXFxuICAgICAgICA8aDI+IEJpbyA8L2gyPlxcblxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuICAgICAgICAgIDxsYWJlbCBmb3I9XFxcInRpdGxlXFxcIiBjbGFzcz1cXFwiY29sLW1kLTMgY29udHJvbC1sYWJlbFxcXCI+VGl0bGU8L2xhYmVsPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtOVxcXCI+XFxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIGlkPVxcXCJ0aXRsZVxcXCIgbmFtZT1cXFwidGl0bGVcXFwiIHBsYWNlaG9sZGVyPVxcXCJUaXRsZVxcXCIgdmFsdWU9XFxcIjwlIGlmIChkYXRhLnRpdGxlKSB7ICU+PCUtIGRhdGEudGl0bGUgJT48JSB9ICU+XFxcIi8+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgICAgPGxhYmVsIGZvcj1cXFwiY29tcGFueVxcXCIgY2xhc3M9XFxcImNvbC1tZC0zIGNvbnRyb2wtbGFiZWxcXFwiPkFnZW5jeTwvbGFiZWw+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC05XFxcIj5cXG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwiaGlkZGVuXFxcIiBpZD1cXFwiY29tcGFueVxcXCIgbmFtZT1cXFwiY29tcGFueVxcXCIgc3R5bGU9XFxcIndpZHRoOiAxMDAlXFxcIi8+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgICAgPGxhYmVsIGZvcj1cXFwibG9jYXRpb25cXFwiIGNsYXNzPVxcXCJjb2wtbWQtMyBjb250cm9sLWxhYmVsXFxcIj5Mb2NhdGlvbjwvbGFiZWw+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC05XFxcIj5cXG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwiaGlkZGVuXFxcIiBpZD1cXFwibG9jYXRpb25cXFwiIG5hbWU9XFxcImxvY2F0aW9uXFxcIiBzdHlsZT1cXFwid2lkdGg6IDEwMCVcXFwiLz5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJiaW9cXFwiIGNsYXNzPVxcXCJjb2wtbWQtMyBjb250cm9sLWxhYmVsXFxcIj5BIGJyaWVmIHB1YmxpYyBiaW9ncmFwaHk8L2xhYmVsPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtOVxcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwibWFya2Rvd24tZWRpdFxcXCI+PC9kaXY+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICA8aDI+IEFjY291bnQgSW5mb3JtYXRpb24gPC9oMj5cXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJwcm9maWxlLWVtYWlsXFxcIiBjbGFzcz1cXFwiY29sLW1kLTMgY29udHJvbC1sYWJlbFxcXCI+RW1haWw8L2xhYmVsPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtOVxcXCI+XFxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIGlkPVxcXCJwcm9maWxlLWVtYWlsXFxcIiBuYW1lPVxcXCJlbWFpbFxcXCJcXG4gICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVxcXCJFbWFpbFxcXCIgdmFsdWU9XFxcIjwlIGlmIChlbWFpbCkgeyAlPjwlLSBlbWFpbC5lbWFpbCAlPjwlIH0gJT5cXFwiPlxcbiAgICAgICAgICAgIDxkaXYgaWQ9XFxcImVtYWlsLXVwZGF0ZS1hbGVydFxcXCIgY2xhc3M9XFxcImFsZXJ0IGFsZXJ0LXdhcm5pbmdcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIj48L2Rpdj5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICAgICAgICA8JSBpZiAobG9naW4ub2F1dGgubGVuZ3RoID4gMCkgeyAlPlxcbiAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJzZXJ2aWNlc1xcXCIgY2xhc3M9XFxcImNvbC1tZC0zIGNvbnRyb2wtbGFiZWxcXFwiPkNvbm5lY3RlZCBBY2NvdW50czwvbGFiZWw+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC05XFxcIiBpZD1cXFwic2VydmljZXNcXFwiPlxcbiAgICAgICAgICAgIDxmb3JtIGNsYXNzPVxcXCJmb3JtLWhvcml6b250YWxcXFwiIHJvbGU9XFxcImZvcm1cXFwiPlxcbiAgICAgICAgICAgIDwlIF8uZWFjaChsb2dpbi5vYXV0aCwgZnVuY3Rpb24gKGEpIHsgJT5cXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wteHMtOCBjb2wtc20tOSBjb2wtbWQtOVxcXCI+XFxuICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XFxcIjwlPSBsb2dpbi5jb25maWdbYV0uaW1hZ2UgJT5cXFwiIGFsdD1cXFwiPCU9IGxvZ2luLmNvbmZpZ1thXS5uYW1lICU+XFxcIiBzdHlsZT1cXFwiaGVpZ2h0OiAzMHB4XFxcIi8+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wteHMtNCBjb2wtc20tMyBjb2wtbWQtM1xcXCI+XFxuICAgICAgICAgICAgICAgICAgPCUgaWYgKF8uY29udGFpbnMoZGF0YS5hdXRocywgYSkpIHsgJT5cXG4gICAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCIjXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kYW5nZXIgYnRuLXNtIHJlbW92ZUF1dGggcHVsbC1yaWdodFxcXCIgZGF0YS1zZXJ2aWNlPVxcXCI8JT0gYSAlPlxcXCI+PHNwYW4gY2xhc3M9XFxcImZhIGZhLXJlbW92ZVxcXCI+PC9zcGFuPiBEaXNjb25uZWN0PC9hPlxcbiAgICAgICAgICAgICAgICAgIDwlIH0gZWxzZSB7ICU+XFxuICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiPCU9IGxvZ2luLmNvbmZpZ1thXS5lbmRwb2ludCAlPlxcXCIgY2xhc3M9XFxcImJ0biBidG4tc3VjY2VzcyBidG4tc20gcHVsbC1yaWdodFxcXCI+PHNwYW4gY2xhc3M9XFxcImZhIGZhLXBsdXNcXFwiPjwvc3Bhbj4gQ29ubmVjdDwvYT5cXG4gICAgICAgICAgICAgICAgICA8JSB9ICU+XFxuICAgICAgICAgICAgICAgICAgPCEtLSA8JT0gbG9naW4uY29uZmlnW2FdLm5hbWUgJT4gLS0+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPCUgfSk7ICU+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8JSB9ICU+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtb2Zmc2V0LTMgY29sLW1kLTlcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInB1bGwtcmlnaHRcXFwiPlxcbiAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgY2xhc3M9XFxcImJ0biBidG4tYzBcXFwiIGlkPVxcXCJwcm9maWxlLWNhbmNlbFxcXCI+RGlzY2FyZCBDaGFuZ2VzPC9hPlxcblxcbiAgICAgICAgICAgICAgPGJ1dHRvbiBpZD1cXFwic3VibWl0XFxcIiB0eXBlPVxcXCJzdWJtaXRcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWMyXFxcIiBkaXNhYmxlZD1cXFwiZGlzYWJsZWRcXFwiIGRhdGEtbG9hZGluZy10ZXh0PVxcXCI8aSBjbGFzcz0nZmEgZmEtc3Bpbm5lciBmYS1zcGluJz48L2k+IFNhdmluZy4uLlxcXCIgZGF0YS1zdWNjZXNzLXRleHQ9XFxcIlNhdmVkIVxcXCIgZGF0YS1mYWlsLXRleHQ9XFxcIlNhdmUgRmFpbGVkLlxcXCI+U2F2ZSBQcm9maWxlPC9idXR0b24+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgPC9mb3JtPlxcbiAgICA8L2Rpdj5cXG4gICAgPCUgfSBlbHNlIHsgJT4gPCEtLSBub3QgaW4gZWRpdCBtb2RlIC0tPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC05IHNtLW5vcGFkZGluZyBtZC1ub3BhZGRpbmdcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiYm94IGJveC1tYWluXFxcIj5cXG4gICAgICAgICAgPGgxPjwlIGlmIChkYXRhLm5hbWUpIHsgJT48JS0gZGF0YS5uYW1lICU+PCUgfSBlbHNlIHsgJT48JS0gZGF0YS51c2VybmFtZSAlPjwlIH0gJT48L2gxPlxcblxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwcm9maWxlLWpvYnRpdGxlXFxcIj48JSBpZiAoZGF0YS50aXRsZSkgeyAlPjxpIGNsYXNzPVxcXCJmYSBmYS1icmllZmNhc2VcXFwiPjwvaT4gPHNwYW4gY2xhc3M9XFxcImJveC1pY29uLXRleHRcXFwiPjwlLSBkYXRhLnRpdGxlICU+PC9zcGFuPjwlIH0gJT48L2Rpdj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwicHJvZmlsZS1jb21wYW55XFxcIj48JSBpZiAoZGF0YS5hZ2VuY3kpIHsgJT48aSBjbGFzcz1cXFwiaWNvbi1saWJyYXJ5XFxcIj48L2k+IDxzcGFuIGNsYXNzPVxcXCJib3gtaWNvbi10ZXh0XFxcIj48JS0gZGF0YS5hZ2VuY3kudGFnLm5hbWUgJT48L3NwYW4+PCUgfSAlPjwvZGl2PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwcm9maWxlLWxvY2F0aW9uXFxcIj48JSBpZiAoZGF0YS5sb2NhdGlvbikgeyAlPjxzcGFuIGNsYXNzPVxcXCJmYSBmYS1tYXAtbWFya2VyXFxcIj48L3NwYW4+IDxzcGFuIGNsYXNzPVxcXCJib3gtaWNvbi10ZXh0XFxcIj48JS0gZGF0YS5sb2NhdGlvbi50YWcubmFtZSAlPjwvc3Bhbj48JSB9ICU+PC9kaXY+XFxuXFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInByb2ZpbGUtYmlvIGJveC1wYWQtdFxcXCI+XFxuICAgICAgICAgICAgPCUgaWYgKGRhdGEuYmlvSHRtbCkgeyAlPjwlPSBkYXRhLmJpb0h0bWwgJT48JSB9IGVsc2UgeyAlPlRoaXMgcGVyc29uIGRvZXNuJ3QgaGF2ZSBhIGJpbyB5ZXQuPCUgfSAlPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0zIHNtLW5vcGFkZGluZyBtZC1ub3BhZGRpbmcgcGFkZGluZy1sZWZ0LW5vbmVcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiYm94IHBhZGRpbmctbm9uZVxcXCI+XFxuPCEtLVxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJuYXZiYXItc2lkZSBsaWtlLXJvdyBib3JkZXItYm90dG9tXFxcIj5cXG4gICAgICAgICAgICA8YSBocmVmPVxcXCIjXFxcIiBpZD1cXFwibGlrZS1idXR0b25cXFwiIGNsYXNzPVxcXCJsaWtlLWJ1dHRvblxcXCI+XFxuICAgICAgICAgICAgICA8aSBpZD1cXFwibGlrZS1idXR0b24taWNvblxcXCIgY2xhc3M9XFxcImZhIGZhLXN0YXItbyBmYS1sZyBnb2xkXFxcIj48L2k+XFxuICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJsaWtlLW51bWJlclxcXCIgaWQ9XFxcImxpa2UtbnVtYmVyXFxcIj48JS0gZGF0YS5saWtlQ291bnQgJT48L3NwYW4+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImxpa2UtcGx1cmFsXFxcIiBpZD1cXFwibGlrZS10ZXh0XFxcIiBkYXRhLXBsdXJhbD1cXFwiZm9sbG93ZXJzXFxcIiBkYXRhLXNpbmd1bGFyPVxcXCJmb2xsb3dlclxcXCI+Zm9sbG93ZXJzPC9zcGFuPlxcbiAgICAgICAgICA8L2Rpdj5cXG4tLT5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwibmF2YmFyLXNpZGUgPCUgaWYgKGRhdGEuaXNPd25lciB8fCB1c2VyLmlzQWRtaW4pIHsgJT5ib3JkZXItYm90dG9tPCUgfSAlPlxcXCI+XFxuICAgICAgICAgICAgPHVsIGNsYXNzPVxcXCJuYXYgbmF2LXBpbGxzIG5hdi1zdGFja2VkXFxcIj5cXG4gICAgICAgICAgICAgIDxsaT5cXG4gICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgaWQ9XFxcImVtYWlsXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtZW52ZWxvcGUtb1xcXCI+PC9pPiA8c3BhbiBjbGFzcz1cXFwiYm94LWljb24tdGV4dFxcXCI+U2hhcmU8L3NwYW4+PC9hPlxcbiAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICAgIDwlIGlmIChkYXRhLmlzT3duZXIgfHwgdXNlci5pc0FkbWluKSB7ICU+XFxuICAgICAgICAgICAgICA8bGk+XFxuICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIi9hcGkvZXZlbnQvaWNhbC9cXFwiPjxzcGFuIGNsYXNzPVxcXCJmYSBmYS1jYWxlbmRhclxcXCI+PC9zcGFuPiA8c3BhbiBjbGFzcz1cXFwiYm94LWljb24tdGV4dFxcXCI+Q2FsZW5kYXI8L3NwYW4+PC9hPlxcbiAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICA8L3VsPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwibmF2YmFyLXNpZGVcXFwiPlxcbiAgICAgICAgICAgICAgPHVsIGNsYXNzPVxcXCJuYXYgbmF2LXBpbGxzIG5hdi1zdGFja2VkXFxcIj5cXG4gICAgICAgICAgICAgIDxsaT5cXG4gICAgICAgICAgICAgICAgPCUgaWYgKGxvZ2luLnByb2ZpbGUuZWRpdCA9PT0gdHJ1ZSkgeyAlPlxcbiAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCIvcHJvZmlsZS88JS0gZGF0YS5pZCAlPi9lZGl0XFxcIiBjbGFzcz1cXFwibGluay1iYWNrYm9uZVxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXBlbmNpbFxcXCI+PC9pPiA8c3BhbiBjbGFzcz1cXFwiYm94LWljb24tdGV4dFxcXCI+RWRpdCBQcm9maWxlPC9zcGFuPjwvYT5cXG4gICAgICAgICAgICAgICAgPCUgfSBlbHNlIGlmIChsb2dpbi5wcm9maWxlLmVkaXRVcmwpIHsgJT5cXG4gICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiPCU9IGxvZ2luLnByb2ZpbGUuZWRpdFVybCAlPlxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1wZW5jaWxcXFwiPjwvaT4gPHNwYW4gY2xhc3M9XFxcImJveC1pY29uLXRleHRcXFwiPkVkaXQgUHJvZmlsZTwvc3Bhbj48L2E+XFxuICAgICAgICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgICA8JSB9ICU+XFxuICAgICAgICAgICAgPC91bD5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDwlIGlmIChkYXRhLmlzT3duZXIpIHsgJT5cXG4gICAgPGRpdiBjbGFzcz1cXFwiYm94XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJib3gtcGFkLWxyIGJvcmRlci1ib3R0b21cXFwiPlxcbiAgICAgICAgPGgyPkFjY291bnQgSW5mb3JtYXRpb248L2gyPlxcbiAgICAgIDwvZGl2PlxcblxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImJveC1wYWQtbHIgYm94LXBhZC10XFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC14cy0zIGNvbC1zbS0zIGNvbC1tZC0zXFxcIj5cXG4gICAgICAgICAgICBFbWFpbDwlIGlmIChkYXRhLmVtYWlscy5sZW5ndGggPiAxKSB7ICU+czwlIH0lPjpcXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC14cy05IGNvbC1zbS05IGNvbC1tZC05XFxcIj5cXG4gICAgICAgICAgICA8JSBmb3IgKHZhciBlID0gMDsgZSA8IGRhdGEuZW1haWxzLmxlbmd0aDsgZSsrKSB7ICU+XFxuICAgICAgICAgICAgICA8JSBpZiAoZGF0YS5lbWFpbHNbZV0uaXNQcmltYXJ5KSB7ICU+eDwlIH0gJT5cXG4gICAgICAgICAgICAgIDwlLSBkYXRhLmVtYWlsc1tlXS5lbWFpbCAlPjxici8+XFxuICAgICAgICAgICAgPCUgfSAlPlxcbiAgICAgICAgICAgIDwlIGlmIChkYXRhLmVtYWlscy5sZW5ndGggPT0gMCkgeyAlPlxcbiAgICAgICAgICAgIE5vIGVtYWlsIGFkZHJlc3Nlc1xcbiAgICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgIDwlIGlmIChsb2dpbi5vYXV0aC5sZW5ndGggPiAwKSB7ICU+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wteHMtMyBjb2wtc20tMyBjb2wtbWQtM1xcXCI+XFxuICAgICAgICAgICAgQ29ubmVjdGVkIEFjY291bnRzOlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLXhzLTkgY29sLXNtLTkgY29sLW1kLTlcXFwiPlxcbiAgICAgICAgICAgIDwlIGlmIChkYXRhLmF1dGhzLmxlbmd0aCA9PT0gMCkgeyAlPlxcbiAgICAgICAgICAgICAgTm8gY29ubmVjdGVkIGFjY291bnRzLlxcbiAgICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgICA8JSBfLmVhY2gobG9naW4ub2F1dGgsIGZ1bmN0aW9uIChhKSB7ICU+XFxuICAgICAgICAgICAgICA8JSBpZiAoXy5jb250YWlucyhkYXRhLmF1dGhzLCBhKSkgeyAlPlxcbiAgICAgICAgICAgICAgPGRpdj5cXG4gICAgICAgICAgICAgICAgPCU9IGxvZ2luLmNvbmZpZ1thXS5uYW1lICU+XFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJsYWJlbCBsYWJlbC1zdWNjZXNzXFxcIj5Db25uZWN0ZWQ8L3NwYW4+XFxuICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgICA8JSB9KTsgJT5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwlIH0gJT5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDwlIH0gJT5cXG5cXG4gICAgPCUgaWYgKHVpLnByb2plY3Quc2hvdykgeyAlPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJib3hcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImJveC1wYWQtbHIgYm9yZGVyLWJvdHRvbVxcXCI+XFxuICAgICAgICA8aDI+PHNwYW4gZGF0YS1pMThuPVxcXCJQcm9qZWN0UGx1cmFsXFxcIj5Qcm9qZWN0czwvc3Bhbj48L2gyPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImJveC1wYWQtbHIgYm94LXBhZC10XFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInByb2plY3QtYWN0aXZpdHktd3JhcHBlclxcXCI+PC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8JSB9ICU+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcImJveFxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiYm94LXBhZC1sciBib3JkZXItYm90dG9tXFxcIj5cXG4gICAgICAgIDxoMj48c3BhbiBkYXRhLWkxOG49XFxcIlRhc2tQbHVyYWxcXFwiPk9wcG9ydHVuaXRpZXM8L3NwYW4+IFZvbHVudGVlcmVkIEZvcjwvaDI+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiYm94LXBhZC1sciBib3gtcGFkLXRcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidGFzay1hY3Rpdml0eS13cmFwcGVyXFxcIj48L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcImJveFxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiYm94LXBhZC1sciBib3JkZXItYm90dG9tXFxcIj5cXG4gICAgICAgIDxoMj48c3BhbiBkYXRhLWkxOG49XFxcIlRhc2tQbHVyYWxcXFwiPk9wcG9ydHVuaXRpZXM8L3NwYW4+IENyZWF0ZWQ8L2gyPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImJveC1wYWQtbHIgYm94LXBhZC10XFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInRhc2stY3JlYXRlZGFjdGl2aXR5LXdyYXBwZXJcXFwiPjwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPCUgfSAlPiA8IS0tIC9lZGl0IGNoZWNrIC0tPlxcblxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgVUlDb25maWcgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb25maWcvdWkuanNvbicpO1xudmFyIGFzeW5jID0gcmVxdWlyZSgnYXN5bmMnKTtcbnZhciBBY3RUZW1wbGF0ZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy9wcm9maWxlX2FjdGl2aXR5X3RlbXBsYXRlLmh0bWwnKTtcblxuXG52YXIgUHJvZmlsZUFjdGl2aXR5VmlldyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcblxuICBldmVudHM6IHtcbiAgICAnY2xpY2sgLmFjdGl2aXR5LWxpbmsnICAgIDogJ2xpbmsnXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIC8vIHNvcnQgaW5pdGlhbGx5IGJ5IGRhdGUsIGRlc2NlbmRpbmcuXG4gICAgdmFyIHJlc3VsdHMgPSB0aGlzLm9wdGlvbnMuZGF0YS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoYi5jcmVhdGVkQXQpIC0gbmV3IERhdGUoYS5jcmVhdGVkQXQpO1xuICAgIH0pO1xuICAgIHZhciBkYXRhID0ge1xuICAgICAgdWk6IFVJQ29uZmlnLFxuICAgICAgdGFyZ2V0OiB0aGlzLm9wdGlvbnMudGFyZ2V0LFxuICAgICAgdGFyZ2V0RnJpZW5kbHk6IGkxOG4udCh0aGlzLm9wdGlvbnMudGFyZ2V0KSxcbiAgICAgIHRhcmdldHNGcmllbmRseTogaTE4bi50KHRoaXMub3B0aW9ucy50YXJnZXQgKyAnUGx1cmFsJyksXG4gICAgICB0YXJnZXRDYXBpdGFsaXplZDogdGhpcy5vcHRpb25zLnRhcmdldC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRoaXMub3B0aW9ucy50YXJnZXQuc2xpY2UoMSksXG4gICAgICBoYW5kbGU6IHRoaXMub3B0aW9ucy5oYW5kbGUsXG4gICAgICBkYXRhOiByZXN1bHRzLFxuICAgICAgY291bnQ6IHt9XG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgaW4gdGhpcy5vcHRpb25zLmRhdGEpIHtcbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKGRhdGEuY291bnRbdGhpcy5vcHRpb25zLmRhdGFbaV0uc3RhdGVdKSkge1xuICAgICAgICBkYXRhLmNvdW50W3RoaXMub3B0aW9ucy5kYXRhW2ldLnN0YXRlXSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhLmNvdW50W3RoaXMub3B0aW9ucy5kYXRhW2ldLnN0YXRlXSsrXG4gICAgICB9XG4gICAgfVxuICAgIHZhciB0ZW1wbGF0ZSA9IF8udGVtcGxhdGUoQWN0VGVtcGxhdGUpKGRhdGEpO1xuICAgIHRoaXMuJGVsLmh0bWwodGVtcGxhdGUpO1xuICAgIHRoaXMuJGVsLmkxOG4oKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGxpbms6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBCYWNrYm9uZS5oaXN0b3J5Lm5hdmlnYXRlKHRoaXMub3B0aW9ucy50YXJnZXQgKyAncy8nICsgJChlLmN1cnJlbnRUYXJnZXQpLmRhdGEoJ2lkJyksIHsgdHJpZ2dlcjogdHJ1ZSB9KTtcbiAgfSxcblxuICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfSxcblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvZmlsZUFjdGl2aXR5VmlldztcbiIsIlxudmFyIGFzeW5jID0gcmVxdWlyZSgnYXN5bmMnKTtcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL21peGlucy91dGlsaXRpZXMnKTtcbnZhciBMb2dpblBhc3N3b3JkVmlldyA9IHJlcXVpcmUoJy4uLy4uLy4uL2xvZ2luL3ZpZXdzL2xvZ2luX3Bhc3N3b3JkX3ZpZXcnKTtcbnZhciBQcm9maWxlUmVzZXRUZW1wbGF0ZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy9wcm9maWxlX3Jlc2V0X3RlbXBsYXRlLmh0bWwnKTtcblxuXG52YXIgUHJvZmlsZVJlc2V0VmlldyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcblxuICBldmVudHM6IHtcbiAgICAna2V5dXAgI3JwYXNzd29yZCcgICAgICAgICAgICAgICA6ICdjaGVja1Bhc3N3b3JkJyxcbiAgICAnYmx1ciAjcnBhc3N3b3JkJyAgICAgICAgICAgICAgICA6ICdjaGVja1Bhc3N3b3JkJyxcbiAgICAnc3VibWl0ICNmb3JtLXBhc3N3b3JkLXJlc2V0JyAgICA6ICdzdWJtaXRSZXNldCdcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5kYXRhID0gb3B0aW9ucy5kYXRhO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhID0ge1xuICAgICAgdXNlcjogd2luZG93LmNhY2hlLmN1cnJlbnRVc2VyIHx8IHt9XG4gICAgfTtcbiAgICB2YXIgdGVtcGxhdGUgPSBfLnRlbXBsYXRlKFByb2ZpbGVSZXNldFRlbXBsYXRlKShkYXRhKTtcbiAgICB0aGlzLiRlbC5odG1sKHRlbXBsYXRlKTtcbiAgICB0aGlzLmxvZ2luUGFzc3dvcmRWaWV3ID0gbmV3IExvZ2luUGFzc3dvcmRWaWV3KHtcbiAgICAgIGVsOiB0aGlzLiQoXCIucGFzc3dvcmQtdmlld1wiKVxuICAgIH0pLnJlbmRlcigpO1xuICAgIHRoaXMuY2hlY2tWYWxpZENvZGUodGhpcy5vcHRpb25zLmFjdGlvbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgY2hlY2tQYXNzd29yZDogZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgcnVsZXMgPSB2YWxpZGF0ZVBhc3N3b3JkKHRoaXMudG9rZW4uZW1haWwsIHRoaXMuJChcIiNycGFzc3dvcmRcIikudmFsKCkpO1xuICAgIHZhciBzdWNjZXNzID0gdHJ1ZTtcbiAgICBfLmVhY2gocnVsZXMsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy4kKFwiLnBhc3N3b3JkLXJ1bGVzIC5zdWNjZXNzLnJ1bGUtXCIgKyBrZXkpLnNob3coKTtcbiAgICAgICAgdGhpcy4kKFwiLnBhc3N3b3JkLXJ1bGVzIC5lcnJvci5ydWxlLVwiICsga2V5KS5oaWRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiQoXCIucGFzc3dvcmQtcnVsZXMgLnN1Y2Nlc3MucnVsZS1cIiArIGtleSkuaGlkZSgpO1xuICAgICAgICB0aGlzLiQoXCIucGFzc3dvcmQtcnVsZXMgLmVycm9yLnJ1bGUtXCIgKyBrZXkpLnNob3coKTtcbiAgICAgIH1cbiAgICAgIHN1Y2Nlc3MgPSBzdWNjZXNzICYmIHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiBzdWNjZXNzO1xuICB9LFxuXG4gIGNoZWNrVmFsaWRDb2RlOiBmdW5jdGlvbiAoY29kZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAvLyBjaGVjayBpZiB0aGUgY29kZSBpcyB2YWxpZCBhbmQgdXBkYXRlIHRoZSBET00gYWNjb3JkaW5nbHlcbiAgICAkLmFqYXgoe1xuICAgICAgdXJsOiAnL2FwaS9hdXRoL2NoZWNrVG9rZW4vJyArIGNvZGUsXG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBzZWxmLiQoXCIjcHJvZmlsZS1yZXNldC1jaGVja1wiKS5oaWRlKCk7XG4gICAgICAgIC8vIHRydWUgbWVhbnMgdGhlIHRva2VuIGlzIGEgdmFsaWQgcmVzZXQgdG9rZW5cbiAgICAgICAgaWYgKGRhdGEgPT09IGZhbHNlKSB7XG4gICAgICAgICAgc2VsZi4kKFwiI3Byb2ZpbGUtcmVzZXQtY2hlY2stZXJyb3JcIikuc2hvdygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNlbGYudG9rZW4gPSBkYXRhO1xuICAgICAgICAgIHNlbGYuJChcIiNwcm9maWxlLXJlc2V0LWRpYWxvZ1wiKS5zaG93KCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBlcnJvcjogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgc2VsZi4kKFwiI3Byb2ZpbGUtcmVzZXQtY2hlY2tcIikuaGlkZSgpO1xuICAgICAgICBzZWxmLiQoXCIjcHJvZmlsZS1yZXNldC1jaGVjay1lcnJvclwiKS5zaG93KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgc3VibWl0UmVzZXQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICB2YXIgcGFzc3dvcmRTdWNjZXNzID0gdGhpcy5jaGVja1Bhc3N3b3JkKCk7XG4gICAgdmFyIHBhcmVudCA9ICQodGhpcy4kKFwiI3JwYXNzd29yZFwiKS5wYXJlbnRzKCcuZm9ybS1ncm91cCcpWzBdKTtcbiAgICBpZiAocGFzc3dvcmRTdWNjZXNzICE9PSB0cnVlKSB7XG4gICAgICBwYXJlbnQuYWRkQ2xhc3MoJ2hhcy1lcnJvcicpO1xuICAgICAgJChwYXJlbnQuZmluZCgnLmVycm9yLXBhc3N3b3JkJylbMF0pLnNob3coKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgJChwYXJlbnQuZmluZCgnLmVycm9yLXBhc3N3b3JkJylbMF0pLmhpZGUoKTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYSBkYXRhIG9iamVjdCB3aXRoIHRoZSByZXF1aXJlZCBmaWVsZHNcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIHRva2VuOiB0aGlzLm9wdGlvbnMuYWN0aW9uLFxuICAgICAgcGFzc3dvcmQ6IHRoaXMuJChcIiNycGFzc3dvcmRcIikudmFsKCksXG4gICAgICBqc29uOiB0cnVlXG4gICAgfTtcbiAgICBzZWxmLiQoXCIjcHJvZmlsZS1yZXNldC1zdWJtaXRcIikuc2hvdygpO1xuICAgIHNlbGYuJChcIiNwcm9maWxlLXJlc2V0LXN1Ym1pdC1lcnJvclwiKS5oaWRlKCk7XG4gICAgJC5hamF4KHtcbiAgICAgIHVybDogJy9hcGkvYXV0aC9yZXNldC8nLFxuICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHNlbGYuJChcIiNwcm9maWxlLXJlc2V0LXN1Ym1pdFwiKS5oaWRlKCk7XG4gICAgICAgIC8vIHRydWUgbWVhbnMgdGhlIHRva2VuIGlzIGEgdmFsaWQgcmVzZXQgdG9rZW5cbiAgICAgICAgaWYgKGRhdGEgPT09IGZhbHNlKSB7XG4gICAgICAgICAgc2VsZi4kKFwiI3Byb2ZpbGUtcmVzZXQtc3VibWl0LWVycm9yXCIpLnNob3coKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBuYXZpZ2F0ZSB0byB0aGUgcHJvamVjdHMgbWFpbiBwYWdlXG4gICAgICAgICAgQmFja2JvbmUuaGlzdG9yeS5uYXZpZ2F0ZSgnLycsIHsgdHJpZ2dlcjogdHJ1ZSB9KTtcbiAgICAgICAgICAvLyBzaG93IGxvZyBpbiBzY3JlZW4gd2l0aCBub3RpY2UgdG8gbG9nIGluLlxuICAgICAgICAgIHdpbmRvdy5jYWNoZS51c2VyRXZlbnRzLnRyaWdnZXIoXCJ1c2VyOnJlcXVlc3Q6bG9naW5cIiwge1xuICAgICAgICAgICAgbWVzc2FnZTogXCJZb3VyIHBhc3N3b3JkIGhhcyBiZWVuIHJlc2V0LiAgUGxlYXNlIGxvZyBpbiB0byBjb250aW51ZS5cIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZXJyb3I6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHNlbGYuJChcIiNwcm9maWxlLXJlc2V0LXN1Ym1pdFwiKS5oaWRlKCk7XG4gICAgICAgIHNlbGYuJChcIiNwcm9maWxlLXJlc2V0LXN1Ym1pdC1lcnJvclwiKS5zaG93KCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgfSxcblxuICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfSxcblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvZmlsZVJlc2V0VmlldztcblxuIiwiXG52YXIgYXN5bmMgPSByZXF1aXJlKCdhc3luYycpO1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vbWl4aW5zL3V0aWxpdGllcycpO1xudmFyIFByb2ZpbGVTZXR0aW5nc1RlbXBsYXRlID0gcmVxdWlyZSgnLi4vdGVtcGxhdGVzL3Byb2ZpbGVfc2V0dGluZ3NfdGVtcGxhdGUuaHRtbCcpO1xuXG5cbnZhciBQcm9maWxlU2V0dGluZ3NWaWV3ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuXG4gIGV2ZW50czoge1xuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmRhdGEgPSBvcHRpb25zLmRhdGE7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICB1c2VyOiB3aW5kb3cuY2FjaGUuY3VycmVudFVzZXIgfHwge31cbiAgICB9XG4gICAgdmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZShQcm9maWxlU2V0dGluZ3NUZW1wbGF0ZSkoZGF0YSk7XG4gICAgdGhpcy4kZWwuaHRtbCh0ZW1wbGF0ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgY2xlYW51cDogZnVuY3Rpb24gKCkge1xuICAgIHJlbW92ZVZpZXcodGhpcyk7XG4gIH0sXG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb2ZpbGVTZXR0aW5nc1ZpZXc7XG5cbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL21peGlucy91dGlsaXRpZXMnKTtcbnZhciBVSUNvbmZpZyA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2NvbmZpZy91aS5qc29uJyk7XG52YXIgYXN5bmMgPSByZXF1aXJlKCdhc3luYycpO1xudmFyIGpxSWZyYW1lID0gcmVxdWlyZSgnYmx1ZWltcC1maWxlLXVwbG9hZC9qcy9qcXVlcnkuaWZyYW1lLXRyYW5zcG9ydCcpO1xudmFyIGpxRlUgPSByZXF1aXJlKCdibHVlaW1wLWZpbGUtdXBsb2FkL2pzL2pxdWVyeS5maWxldXBsb2FkLmpzJyk7XG52YXIgTWFya2Rvd25FZGl0b3IgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb21wb25lbnRzL21hcmtkb3duX2VkaXRvcicpO1xudmFyIG1hcmtlZCA9IHJlcXVpcmUoJ21hcmtlZCcpO1xudmFyIFRhZ1Nob3dWaWV3ID0gcmVxdWlyZSgnLi4vLi4vLi4vdGFnL3Nob3cvdmlld3MvdGFnX3Nob3dfdmlldycpO1xudmFyIFByb2ZpbGVUZW1wbGF0ZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy9wcm9maWxlX3Nob3dfdGVtcGxhdGUuaHRtbCcpO1xudmFyIEVtYWlsVGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvcHJvZmlsZV9lbWFpbF90ZW1wbGF0ZS5odG1sJyk7XG52YXIgTG9naW4gPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb25maWcvbG9naW4uanNvbicpO1xudmFyIE1vZGFsQ29tcG9uZW50ID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29tcG9uZW50cy9tb2RhbCcpO1xudmFyIFBBVmlldyA9IHJlcXVpcmUoJy4vcHJvZmlsZV9hY3Rpdml0eV92aWV3Jyk7XG52YXIgRW1haWxGb3JtVmlldyA9IHJlcXVpcmUoJy4uLy4uL2VtYWlsL3ZpZXdzL3Byb2ZpbGVfZW1haWxfdmlldycpO1xudmFyIFRhZ0ZhY3RvcnkgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb21wb25lbnRzL3RhZ19mYWN0b3J5Jyk7XG5cblxudmFyIFByb2ZpbGVTaG93VmlldyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcblxuICBldmVudHM6IHtcbiAgICBcInN1Ym1pdCAjcHJvZmlsZS1mb3JtXCIgICAgICAgOiBcInByb2ZpbGVTdWJtaXRcIixcbiAgICBcImNsaWNrICNwcm9maWxlLXNhdmVcIiAgICAgICAgOiBcInByb2ZpbGVTYXZlXCIsXG4gICAgXCJjbGljayAubGluay1iYWNrYm9uZVwiICAgICAgIDogbGlua0JhY2tib25lLFxuICAgIFwiY2xpY2sgI3Byb2ZpbGUtY2FuY2VsXCIgICAgICA6IFwicHJvZmlsZUNhbmNlbFwiLFxuICAgIFwiY2xpY2sgI2xpa2UtYnV0dG9uXCIgICAgICAgICA6IFwibGlrZVwiLFxuICAgIFwia2V5dXAgI25hbWUsICN0aXRsZSwgI2Jpb1wiICA6IFwiZmllbGRNb2RpZmllZFwiLFxuICAgIFwiY2xpY2sgLnJlbW92ZUF1dGhcIiAgICAgICAgICA6IFwicmVtb3ZlQXV0aFwiXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuZGF0YSA9IG9wdGlvbnMuZGF0YTtcbiAgICB0aGlzLnRhZ0ZhY3RvcnkgPSBuZXcgVGFnRmFjdG9yeSgpO1xuICAgIHRoaXMuZGF0YS5uZXdJdGVtVGFncyA9IFtdO1xuICAgIHRoaXMuZWRpdCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYWN0aW9uID09ICdlZGl0Jykge1xuICAgICAgdGhpcy5lZGl0ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGF0YS5zYXZlZCkge1xuICAgICAgdGhpcy5zYXZlZCA9IHRydWU7XG4gICAgICB0aGlzLmRhdGEuc2F2ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBsb2dpbjogTG9naW4sXG4gICAgICBkYXRhOiB0aGlzLm1vZGVsLnRvSlNPTigpLFxuICAgICAgdXNlcjogd2luZG93LmNhY2hlLmN1cnJlbnRVc2VyIHx8IHt9LFxuICAgICAgZWRpdDogdGhpcy5lZGl0LFxuICAgICAgc2F2ZWQ6IHRoaXMuc2F2ZWQsXG4gICAgICB1aTogVUlDb25maWdcbiAgICB9XG5cbiAgICBkYXRhLmVtYWlsID0gKGRhdGEuZGF0YS5lbWFpbHMgJiYgZGF0YS5kYXRhLmVtYWlscy5sZW5ndGgpID8gZGF0YS5kYXRhLmVtYWlsc1swXSA6ICcnO1xuXG4gICAgaWYgKGRhdGEuZGF0YS5iaW8pIHtcbiAgICAgIGRhdGEuZGF0YS5iaW9IdG1sID0gbWFya2VkKGRhdGEuZGF0YS5iaW8pO1xuICAgIH1cbiAgICB2YXIgdGVtcGxhdGUgPSBfLnRlbXBsYXRlKFByb2ZpbGVUZW1wbGF0ZSkoZGF0YSk7XG4gICAgdGhpcy4kZWwuaHRtbCh0ZW1wbGF0ZSk7XG4gICAgdGhpcy4kZWwuaTE4bigpO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSBzdWIgY29tcG9uZW50c1xuICAgIHRoaXMuaW5pdGlhbGl6ZUZpbGVVcGxvYWQoKTtcbiAgICB0aGlzLmluaXRpYWxpemVGb3JtKCk7XG4gICAgdGhpcy5pbml0aWFsaXplU2VsZWN0MigpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZUxpa2VzKCk7XG4gICAgdGhpcy5pbml0aWFsaXplVGFncygpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZVBBVmlldygpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZVRleHRBcmVhKCk7XG4gICAgdGhpcy51cGRhdGVQaG90bygpO1xuICAgIHRoaXMudXBkYXRlUHJvZmlsZUVtYWlsKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZUZpbGVVcGxvYWQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAkKCcjZmlsZXVwbG9hZCcpLmZpbGV1cGxvYWQoe1xuICAgICAgICB1cmw6IFwiL2FwaS9maWxlL2NyZWF0ZVwiLFxuICAgICAgICBkYXRhVHlwZTogJ3RleHQnLFxuICAgICAgICBhY2NlcHRGaWxlVHlwZXM6IC8oXFwufFxcLykoZ2lmfGpwZT9nfHBuZykkL2ksXG4gICAgICAgIGZvcm1EYXRhOiB7ICd0eXBlJzogJ2ltYWdlX3NxdWFyZScgfSxcbiAgICAgICAgYWRkOiBmdW5jdGlvbiAoZSwgZGF0YSkge1xuICAgICAgICAgIHNlbGYuJCgnI2ZpbGUtdXBsb2FkLXByb2dyZXNzLWNvbnRhaW5lcicpLnNob3coKTtcbiAgICAgICAgICBkYXRhLnN1Ym1pdCgpO1xuICAgICAgICB9LFxuICAgICAgICBwcm9ncmVzc2FsbDogZnVuY3Rpb24gKGUsIGRhdGEpIHtcbiAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSBwYXJzZUludChkYXRhLmxvYWRlZCAvIGRhdGEudG90YWwgKiAxMDAsIDEwKTtcbiAgICAgICAgICBzZWxmLiQoJyNmaWxlLXVwbG9hZC1wcm9ncmVzcycpLmNzcyhcbiAgICAgICAgICAgICd3aWR0aCcsXG4gICAgICAgICAgICBwcm9ncmVzcyArICclJ1xuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIGRvbmU6IGZ1bmN0aW9uIChlLCBkYXRhKSB7XG4gICAgICAgICAgLy8gZm9yIElFOC85IHRoYXQgdXNlIGlmcmFtZVxuICAgICAgICAgIGlmIChkYXRhLmRhdGFUeXBlID09ICdpZnJhbWUgdGV4dCcpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBKU09OLnBhcnNlKGRhdGEucmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZm9yIG1vZGVybiBYSFIgYnJvd3NlcnNcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBKU09OLnBhcnNlKCQoZGF0YS5yZXN1bHQpLnRleHQoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYubW9kZWwudHJpZ2dlcihcInByb2ZpbGU6dXBkYXRlV2l0aFBob3RvSWRcIiwgcmVzdWx0WzBdKTtcbiAgICAgICAgfSxcbiAgICAgICAgZmFpbDogZnVuY3Rpb24gKGUsIGRhdGEpIHtcbiAgICAgICAgICAvLyBub3RpZnkgdGhlIHVzZXIgdGhhdCB0aGUgdXBsb2FkIGZhaWxlZFxuICAgICAgICAgIHZhciBtZXNzYWdlID0gZGF0YS5lcnJvclRocm93bjtcbiAgICAgICAgICBzZWxmLiQoJyNmaWxlLXVwbG9hZC1wcm9ncmVzcy1jb250YWluZXInKS5oaWRlKCk7XG4gICAgICAgICAgaWYgKGRhdGEuanFYSFIuc3RhdHVzID09IDQxMykge1xuICAgICAgICAgICAgbWVzc2FnZSA9IFwiVGhlIHVwbG9hZGVkIGZpbGUgZXhjZWVkcyB0aGUgbWF4aW11bSBmaWxlIHNpemUuXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYuJChcIiNmaWxlLXVwbG9hZC1hbGVydFwiKS5odG1sKG1lc3NhZ2UpXG4gICAgICAgICAgc2VsZi4kKFwiI2ZpbGUtdXBsb2FkLWFsZXJ0XCIpLnNob3coKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gIH0sXG5cbiAgdXBkYXRlUHJvZmlsZUVtYWlsOiBmdW5jdGlvbigpe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAkLmFqYXgoe1xuICAgICAgdXJsOiBlbmNvZGVVUkkoJy9hcGkvZW1haWwvbWFrZVVSTD9lbWFpbD1jb250YWN0VXNlckFib3V0UHJvZmlsZSZzdWJqZWN0PUNoZWNrIE91dCBcIicrIHNlbGYubW9kZWwuYXR0cmlidXRlcy5uYW1lICsgJ1wiJyArXG4gICAgICAnJnByb2ZpbGVUaXRsZT0nICsgKHNlbGYubW9kZWwuYXR0cmlidXRlcy50aXRsZSB8fCAnJykgK1xuICAgICAgJyZwcm9maWxlTGluaz0nICsgd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgd2luZG93LmxvY2F0aW9uLmhvc3QgKyBcIlwiICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICtcbiAgICAgICcmcHJvZmlsZU5hbWU9JyArIChzZWxmLm1vZGVsLmF0dHJpYnV0ZXMubmFtZSB8fCAnJykgK1xuICAgICAgJyZwcm9maWxlTG9jYXRpb249JyArIChzZWxmLm1vZGVsLmF0dHJpYnV0ZXMubG9jYXRpb24gPyBzZWxmLm1vZGVsLmF0dHJpYnV0ZXMubG9jYXRpb24udGFnLm5hbWUgOiAnJykgK1xuICAgICAgJyZwcm9maWxlQWdlbmN5PScgKyAoc2VsZi5tb2RlbC5hZ2VuY3kgPyBzZWxmLm1vZGVsLmFnZW5jeS5uYW1lIDogJycpKSxcbiAgICAgIHR5cGU6ICdHRVQnXG4gICAgfSkuZG9uZSggZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHNlbGYuJCgnI2VtYWlsJykuYXR0cignaHJlZicsIGRhdGEpO1xuICAgIH0pO1xuICB9LFxuXG4gIGluaXRpYWxpemVUYWdzOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy50YWdWaWV3KSB7IHRoaXMudGFnVmlldy5jbGVhbnVwKCk7IH1cbiAgICB0aGlzLnRhZ1ZpZXcgPSBuZXcgVGFnU2hvd1ZpZXcoe1xuICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICBlbDogJy50YWctd3JhcHBlcicsXG4gICAgICB0YXJnZXQ6ICdwcm9maWxlJyxcbiAgICAgIHRhcmdldElkOiAndXNlcklkJyxcbiAgICAgIGVkaXQ6IHRoaXMuZWRpdCxcbiAgICAgIHVybDogJy9hcGkvdGFnL2ZpbmRBbGxCeVVzZXJJZC8nXG4gICAgfSk7XG4gICAgdGhpcy50YWdWaWV3LnJlbmRlcigpO1xuICB9LFxuXG4gIGluaXRpYWxpemVQQVZpZXc6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5wcm9qZWN0VmlldykgeyB0aGlzLnByb2plY3RWaWV3LmNsZWFudXAoKTsgfVxuICAgIGlmICh0aGlzLnRhc2tWaWV3KSB7IHRoaXMudGFza1ZpZXcuY2xlYW51cCgpOyB9XG4gICAgaWYgKHRoaXMudm9sVmlldykgeyB0aGlzLnZvbFZpZXcuY2xlYW51cCgpOyB9XG4gICAgJC5hamF4KCcvYXBpL3VzZXIvYWN0aXZpdGllcy8nICsgdGhpcy5tb2RlbC5hdHRyaWJ1dGVzLmlkKS5kb25lKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICB0aGlzLnByb2plY3RWaWV3ID0gbmV3IFBBVmlldyh7XG4gICAgICAgIG1vZGVsOiB0aGlzLm1vZGVsLFxuICAgICAgICBlbDogJy5wcm9qZWN0LWFjdGl2aXR5LXdyYXBwZXInLFxuICAgICAgICB0YXJnZXQ6ICdwcm9qZWN0JyxcbiAgICAgICAgaGFuZGxlOiAncHJvamVjdCcsXG4gICAgICAgIGRhdGE6IGRhdGEucHJvamVjdHNcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wcm9qZWN0Vmlldy5yZW5kZXIoKTtcbiAgICAgIHRoaXMudGFza1ZpZXcgPSBuZXcgUEFWaWV3KHtcbiAgICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICAgIGVsOiAnLnRhc2stY3JlYXRlZGFjdGl2aXR5LXdyYXBwZXInLFxuICAgICAgICB0YXJnZXQ6ICd0YXNrJyxcbiAgICAgICAgaGFuZGxlOiAndGFzaycsXG4gICAgICAgIGRhdGE6IGRhdGEudGFza3NcbiAgICAgIH0pO1xuICAgICAgdGhpcy50YXNrVmlldy5yZW5kZXIoKTtcbiAgICAgIHRoaXMudm9sVmlldyA9IG5ldyBQQVZpZXcoe1xuICAgICAgICBtb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgICAgZWw6ICcudGFzay1hY3Rpdml0eS13cmFwcGVyJyxcbiAgICAgICAgdGFyZ2V0OiAndGFzaycsXG4gICAgICAgIGhhbmRsZTogJ3ZvbFRhc2snLFxuICAgICAgICBkYXRhOiBkYXRhLnZvbFRhc2tzXG4gICAgICB9KTtcbiAgICAgIHRoaXMudm9sVmlldy5yZW5kZXIoKTtcblxuICAgIH0pO1xuICB9LFxuXG4gIHVwZGF0ZVBob3RvOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMubW9kZWwub24oXCJwcm9maWxlOnVwZGF0ZWRQaG90b1wiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgdmFyIHVybCA9ICcvYXBpL3VzZXIvcGhvdG8vJyArIGRhdGEuYXR0cmlidXRlcy5pZDtcbiAgICAgIC8vIGZvcmNlIHRoZSBuZXcgaW1hZ2UgdG8gYmUgbG9hZGVkXG4gICAgICAkLmdldCh1cmwsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICQoXCIjcHJvamVjdC1oZWFkZXJcIikuY3NzKCdiYWNrZ3JvdW5kLWltYWdlJywgXCJ1cmwoJ1wiICsgdXJsICsgXCInKVwiKTtcbiAgICAgICAgJCgnI2ZpbGUtdXBsb2FkLXByb2dyZXNzLWNvbnRhaW5lcicpLmhpZGUoKTtcbiAgICAgICAgLy8gbm90aWZ5IGxpc3RlbmVycyBvZiB0aGUgbmV3IHVzZXIgaW1hZ2UsIGJ1dCBvbmx5IGZvciB0aGUgY3VycmVudCB1c2VyXG4gICAgICAgIGlmIChzZWxmLm1vZGVsLnRvSlNPTigpLmlkID09IHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlci5pZCkge1xuICAgICAgICAgIHdpbmRvdy5jYWNoZS51c2VyRXZlbnRzLnRyaWdnZXIoXCJ1c2VyOnByb2ZpbGU6cGhvdG86c2F2ZVwiLCB1cmwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSxcblxuICBpbml0aWFsaXplRm9ybTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgJChcIiN0b3BpY3NcIikub24oJ2NoYW5nZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBzZWxmLm1vZGVsLnRyaWdnZXIoXCJwcm9maWxlOmlucHV0OmNoYW5nZWRcIiwgZSk7XG4gICAgfSk7XG5cbiAgICAkKFwiI3NraWxsc1wiKS5vbignY2hhbmdlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHNlbGYubW9kZWwudHJpZ2dlcihcInByb2ZpbGU6aW5wdXQ6Y2hhbmdlZFwiLCBlKTtcbiAgICB9KTtcblxuICAgIHRoaXMubGlzdGVuVG8oc2VsZi5tb2RlbCwgXCJwcm9maWxlOnNhdmU6c3VjY2Vzc1wiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgLy8gQm9vdHN0cmFwIC5idXR0b24oKSBoYXMgZXhlY3V0aW9uIG9yZGVyIGlzc3VlIHNpbmNlIGl0XG4gICAgICAvLyB1c2VzIHNldFRpbWVvdXQgdG8gY2hhbmdlIHRoZSB0ZXh0IG9mIGJ1dHRvbnMuXG4gICAgICAvLyBtYWtlIHN1cmUgYXR0cigpIHJ1bnMgbGFzdFxuICAgICAgJChcIiNzdWJtaXRcIikuYnV0dG9uKCdzdWNjZXNzJyk7XG4gICAgICAvLyBub3RpZnkgbGlzdGVuZXJzIGlmIHRoZSBjdXJyZW50IHVzZXIgaGFzIGJlZW4gdXBkYXRlZFxuICAgICAgaWYgKHNlbGYubW9kZWwudG9KU09OKCkuaWQgPT0gd2luZG93LmNhY2hlLmN1cnJlbnRVc2VyLmlkKSB7XG4gICAgICAgIHdpbmRvdy5jYWNoZS51c2VyRXZlbnRzLnRyaWdnZXIoXCJ1c2VyOnByb2ZpbGU6c2F2ZVwiLCBkYXRhLnRvSlNPTigpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRhZ3MgPSBbXG4gICAgICAgICQoXCIjY29tcGFueVwiKS5zZWxlY3QyKCdkYXRhJyksXG4gICAgICAgICQoXCIjbG9jYXRpb25cIikuc2VsZWN0MignZGF0YScpXG4gICAgICBdO1xuICAgICAgc2VsZi5tb2RlbC50cmlnZ2VyKFwicHJvZmlsZTp0YWdzOnNhdmVcIiwgdGFncyk7XG4gICAgfSk7XG5cbiAgICBzZWxmLm9uKCduZXdUYWdTYXZlRG9uZScsZnVuY3Rpb24gKCl7XG5cbiAgICAgIHRhZ3MgICAgICAgICA9IFtdO1xuICAgICAgdmFyIHRlbXBUYWdzID0gW107XG5cbiAgICAgIC8vZ2V0IG5ld2x5IGNyZWF0ZWQgdGFncyBmcm9tIGJpZyB0aHJlZSB0eXBlc1xuICAgICAgXy5lYWNoKHNlbGYuZGF0YS5uZXdJdGVtVGFncywgZnVuY3Rpb24obmV3SXRlbVRhZyl7XG4gICAgICAgIHRhZ3MucHVzaChuZXdJdGVtVGFnKTtcbiAgICAgIH0pO1xuXG4gICAgICB0ZW1wVGFncy5wdXNoLmFwcGx5KHRlbXBUYWdzLHNlbGYuJChcIiN0YWdfdG9waWNcIikuc2VsZWN0MignZGF0YScpKTtcbiAgICAgIHRlbXBUYWdzLnB1c2guYXBwbHkodGVtcFRhZ3Msc2VsZi4kKFwiI3RhZ19za2lsbFwiKS5zZWxlY3QyKCdkYXRhJykpO1xuICAgICAgdGVtcFRhZ3MucHVzaC5hcHBseSh0ZW1wVGFncyxzZWxmLiQoXCIjdGFnX2xvY2F0aW9uXCIpLnNlbGVjdDIoJ2RhdGEnKSk7XG4gICAgICB0ZW1wVGFncy5wdXNoLmFwcGx5KHRlbXBUYWdzLHNlbGYuJChcIiN0YWdfYWdlbmN5XCIpLnNlbGVjdDIoJ2RhdGEnKSk7XG5cbiAgICAgIC8vc2VlIGlmIHRoZXJlIGFyZSBhbnkgcHJldmlvdXNseSBjcmVhdGVkIGJpZyB0aHJlZSB0YWdzIGFuZCBhZGQgdGhlbSB0byB0aGUgdGFnIGFycmF5XG4gICAgICBfLmVhY2godGVtcFRhZ3MsZnVuY3Rpb24odGVtcFRhZyl7XG4gICAgICAgICAgaWYgKCB0ZW1wVGFnLmlkICE9PSB0ZW1wVGFnLm5hbWUgKXtcbiAgICAgICAgICB0YWdzLnB1c2godGVtcFRhZyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB2YXIgdGFnTWFwID0ge307XG5cbiAgICAgICAgLy8gaWYgYSBkaWZmZXJlbnQgcHJvZmlsZSBpcyBiZWluZyBlZGl0ZWQsIGFkZCBpdHMgdXNlcklkXG4gICAgICAgIGlmIChzZWxmLm1vZGVsLnRvSlNPTigpLmlkICE9PSB3aW5kb3cuY2FjaGUuY3VycmVudFVzZXIuaWQpIHtcbiAgICAgICAgICB0YWdNYXAudXNlcklkID0gc2VsZi5tb2RlbC50b0pTT04oKS5pZDtcbiAgICAgICAgfVxuXG4gICAgICBhc3luYy5mb3JFYWNoKHRhZ3MsIGZ1bmN0aW9uKHRhZywgY2FsbGJhY2spe1xuICAgICAgICAvL2RpZmZBZGQsc2VsZi5tb2RlbC5hdHRyaWJ1dGVzLmlkLFwidGFza0lkXCIsY2FsbGJhY2tcbiAgICAgICAgcmV0dXJuIHNlbGYudGFnRmFjdG9yeS5hZGRUYWcodGFnLHRhZ01hcC51c2VySWQsXCJ1c2VySWRcIixjYWxsYmFjayk7XG4gICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgc2VsZi5tb2RlbC50cmlnZ2VyKFwicHJvZmlsZTp0YWdzOnNhdmU6c3VjY2Vzc1wiLCBlcnIpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmxpc3RlblRvKHNlbGYubW9kZWwsIFwicHJvZmlsZTp0YWdzOnNhdmVcIiwgZnVuY3Rpb24gKHRhZ3MpIHtcblxuICAgICAgdmFyIG5ld1RhZ3MgPSBbXTtcblxuICAgICAgbmV3VGFncyA9IG5ld1RhZ3MuY29uY2F0KFxuICAgICAgICBzZWxmLiQoXCIjdGFnX3RvcGljXCIpLnNlbGVjdDIoJ2RhdGEnKSxcbiAgICAgICAgc2VsZi4kKFwiI3RhZ19za2lsbFwiKS5zZWxlY3QyKCdkYXRhJyksXG4gICAgICAgIHNlbGYuJChcIiN0YWdfbG9jYXRpb25cIikuc2VsZWN0MignZGF0YScpLFxuICAgICAgICBzZWxmLiQoXCIjbG9jYXRpb25cIikuc2VsZWN0MignZGF0YScpLFxuICAgICAgICBzZWxmLiQoXCIjdGFnX2FnZW5jeVwiKS5zZWxlY3QyKCdkYXRhJylcbiAgICAgICk7XG5cbiAgICAgIHZhciByZW1vdmVUYWcgPSBmdW5jdGlvbih0eXBlLCBkb25lKSB7XG4gICAgICAgIGlmIChzZWxmLm1vZGVsW3R5cGVdKSB7XG4gICAgICAgICAgLy8gZGVsZXRlIHRoZSBleGlzdGluZyB0YWdcbiAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgdXJsOiAnL2FwaS90YWcvJyArIHNlbGYubW9kZWxbdHlwZV0udGFnSWQsXG4gICAgICAgICAgICB0eXBlOiAnREVMRVRFJyxcbiAgICAgICAgICB9KS5kb25lKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYWRkVGFnID0gZnVuY3Rpb24gKHRhZywgZG9uZSkge1xuICAgICAgICAvLyB0aGUgdGFnIGlzIGludmFsaWQgb3IgaGFzbid0IGJlZW4gc2VsZWN0ZWRcbiAgICAgICAgaWYgKCF0YWcgfHwgIXRhZy5pZCkge1xuICAgICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIHRhZyBhbHJlYWR5IGlzIHN0b3JlZCBpbiB0aGUgZGJcbiAgICAgICAgaWYgKHRhZy50YWdJZCkge1xuICAgICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRhZ01hcCA9IHtcbiAgICAgICAgICB0YWdJZDogdGFnLmlkXG4gICAgICAgIH07XG4gICAgICAgIC8vIGlmIGEgZGlmZmVyZW50IHByb2ZpbGUgaXMgYmVpbmcgZWRpdGVkLCBhZGQgaXRzIHVzZXJJZFxuICAgICAgICBpZiAoc2VsZi5tb2RlbC50b0pTT04oKS5pZCAhPT0gd2luZG93LmNhY2hlLmN1cnJlbnRVc2VyLmlkKSB7XG4gICAgICAgICAgdGFnTWFwLnVzZXJJZCA9IHNlbGYubW9kZWwudG9KU09OKCkuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICB1cmw6ICcvYXBpL3RhZycsXG4gICAgICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgICAgIGRhdGE6IHRhZ01hcFxuICAgICAgICB9KS5kb25lKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgYXN5bmMuZm9yRWFjaChcbiAgICAgICAgbmV3VGFncyxcbiAgICAgICAgZnVuY3Rpb24obmV3VGFnLCBjYWxsYmFjaykge1xuICAgICAgICAgIHJldHVybiBzZWxmLnRhZ0ZhY3RvcnkuYWRkVGFnRW50aXRpZXMobmV3VGFnLHNlbGYsY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gbmV4dChlcnIpO1xuXG4gICAgICAgICAgdGFncyA9IF8uZmlsdGVyKHRhZ3MsIGZ1bmN0aW9uKHRhZykge1xuICAgICAgICAgICAgcmV0dXJuICh0YWcgJiYgdGFnLmlkICE9PSB0YWcubmFtZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYXN5bmMuZWFjaChbJ2FnZW5jeScsJ2xvY2F0aW9uJ10sIHJlbW92ZVRhZywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgYXN5bmMuZWFjaCh0YWdzLCBhZGRUYWcsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKFwibmV3VGFnU2F2ZURvbmVcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgIH0pO1xuXG4gICAgdGhpcy5saXN0ZW5UbyhzZWxmLm1vZGVsLCBcInByb2ZpbGU6dGFnczpzYXZlOnN1Y2Nlc3NcIiwgZnVuY3Rpb24gKGVycikge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgJChcIiNwcm9maWxlLXNhdmUsICNzdWJtaXRcIikuYXR0cihcImRpc2FibGVkXCIsIFwiZGlzYWJsZWRcIikgfSwwKTtcbiAgICAgICQoXCIjcHJvZmlsZS1zYXZlLCAjc3VibWl0XCIpLnJlbW92ZUNsYXNzKFwiYnRuLXByaW1hcnlcIik7XG4gICAgICAkKFwiI3Byb2ZpbGUtc2F2ZSwgI3N1Ym1pdFwiKS5hZGRDbGFzcyhcImJ0bi1zdWNjZXNzXCIpO1xuICAgICAgc2VsZi5kYXRhLnNhdmVkID0gdHJ1ZTtcbiAgICAgIEJhY2tib25lLmhpc3RvcnkubmF2aWdhdGUoJ3Byb2ZpbGUvJyArIHNlbGYubW9kZWwudG9KU09OKCkuaWQsIHsgdHJpZ2dlcjogdHJ1ZSB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMubGlzdGVuVG8oc2VsZi5tb2RlbCwgXCJwcm9maWxlOnNhdmU6ZmFpbFwiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgJChcIiNzdWJtaXRcIikuYnV0dG9uKCdmYWlsJyk7XG4gICAgfSk7XG4gICAgdGhpcy5saXN0ZW5UbyhzZWxmLm1vZGVsLCBcInByb2ZpbGU6cmVtb3ZlQXV0aDpzdWNjZXNzXCIsIGZ1bmN0aW9uIChkYXRhLCBpZCkge1xuICAgICAgc2VsZi5yZW5kZXIoKTtcbiAgICB9KTtcbiAgICB0aGlzLmxpc3RlblRvKHNlbGYubW9kZWwsIFwicHJvZmlsZTppbnB1dDpjaGFuZ2VkXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAkKFwiI3Byb2ZpbGUtc2F2ZSwgI3N1Ym1pdFwiKS5idXR0b24oJ3Jlc2V0Jyk7XG4gICAgICAkKFwiI3Byb2ZpbGUtc2F2ZSwgI3N1Ym1pdFwiKS5yZW1vdmVBdHRyKFwiZGlzYWJsZWRcIik7XG4gICAgICAkKFwiI3Byb2ZpbGUtc2F2ZSwgI3N1Ym1pdFwiKS5yZW1vdmVDbGFzcyhcImJ0bi1zdWNjZXNzXCIpO1xuICAgICAgJChcIiNwcm9maWxlLXNhdmUsICNzdWJtaXRcIikuYWRkQ2xhc3MoXCJidG4tYzJcIik7XG4gICAgfSk7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZUxpa2VzOiBmdW5jdGlvbigpIHtcbiAgICAkKFwiI2xpa2UtbnVtYmVyXCIpLnRleHQodGhpcy5tb2RlbC5hdHRyaWJ1dGVzLmxpa2VDb3VudCk7XG4gICAgaWYgKHBhcnNlSW50KHRoaXMubW9kZWwuYXR0cmlidXRlcy5saWtlQ291bnQpID09PSAxKSB7XG4gICAgICAkKFwiI2xpa2UtdGV4dFwiKS50ZXh0KCQoXCIjbGlrZS10ZXh0XCIpLmRhdGEoJ3Npbmd1bGFyJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkKFwiI2xpa2UtdGV4dFwiKS50ZXh0KCQoXCIjbGlrZS10ZXh0XCIpLmRhdGEoJ3BsdXJhbCcpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubW9kZWwuYXR0cmlidXRlcy5saWtlKSB7XG4gICAgICAkKFwiI2xpa2UtYnV0dG9uLWljb25cIikucmVtb3ZlQ2xhc3MoJ2ZhIGZhLXN0YXItbycpO1xuICAgICAgJChcIiNsaWtlLWJ1dHRvbi1pY29uXCIpLmFkZENsYXNzKCdmYSBmYS1zdGFyJyk7XG4gICAgfVxuICB9LFxuXG4gIGluaXRpYWxpemVTZWxlY3QyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIGZvcm1hdFJlc3VsdCA9IGZ1bmN0aW9uIChvYmplY3QsIGNvbnRhaW5lciwgcXVlcnkpIHtcbiAgICAgIHJldHVybiBvYmplY3QubmFtZTtcbiAgICB9O1xuXG4gICAgdmFyIG1vZGVsSnNvbiA9IHRoaXMubW9kZWwudG9KU09OKCk7XG5cbiAgICB2YXIgbG9jYXRpb25TZXR0aW5ncyA9IHtcbiAgICAgIHBsYWNlaG9sZGVyOiAnU2VsZWN0IGEgTG9jYXRpb24nLFxuICAgICAgZm9ybWF0UmVzdWx0OiBmb3JtYXRSZXN1bHQsXG4gICAgICBmb3JtYXRTZWxlY3Rpb246IGZvcm1hdFJlc3VsdCxcbiAgICAgIG1pbmltdW1JbnB1dExlbmd0aDogMSxcbiAgICAgIGRhdGE6IFsgbG9jYXRpb24gXSxcbiAgICAgIGNyZWF0ZVNlYXJjaENob2ljZTogZnVuY3Rpb24gKHRlcm0sIHZhbHVlcykge1xuICAgICAgICB2YXIgdmFscyA9IHZhbHVlcy5tYXAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUudmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy91bm1hdGNoZWQgPSB0cnVlIGlzIHRoZSBmbGFnIGZvciBzYXZpbmcgdGhlc2UgXCJuZXdcIiB0YWdzIHRvIHRhZ0VudGl0eSB3aGVuIHRoZSBvcHAgaXMgc2F2ZWRcbiAgICAgICAgcmV0dXJuICh2YWxzLmluZGV4T2YodGVybS50b0xvd2VyQ2FzZSgpKSA+PTApID8gZmFsc2UgOiB7XG4gICAgICAgICAgdGFnVHlwZTogJ2xvY2F0aW9uJyxcbiAgICAgICAgICBpZDogdGVybSxcbiAgICAgICAgICB2YWx1ZTogdGVybSxcbiAgICAgICAgICB0ZW1wOiB0cnVlLFxuICAgICAgICAgIG5hbWU6IFwiPGI+XCIrdGVybStcIjwvYj4gPGk+c2VhcmNoIGZvciB0aGlzIGxvY2F0aW9uPC9pPlwiXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgYWpheDoge1xuICAgICAgICB1cmw6ICcvYXBpL2FjL3RhZycsXG4gICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgIGRhdGE6IGZ1bmN0aW9uICh0ZXJtKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdsb2NhdGlvbicsXG4gICAgICAgICAgICBxOiB0ZXJtXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzdWx0czogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICByZXR1cm4geyByZXN1bHRzOiBkYXRhIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgJChcIiNjb21wYW55XCIpLnNlbGVjdDIoe1xuICAgICAgcGxhY2Vob2xkZXI6ICdTZWxlY3QgYW4gQWdlbmN5JyxcbiAgICAgIGZvcm1hdFJlc3VsdDogZm9ybWF0UmVzdWx0LFxuICAgICAgZm9ybWF0U2VsZWN0aW9uOiBmb3JtYXRSZXN1bHQsXG4gICAgICBtaW5pbXVtSW5wdXRMZW5ndGg6IDIsXG4gICAgICBhamF4OiB7XG4gICAgICAgIHVybDogJy9hcGkvYWMvdGFnJyxcbiAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgZGF0YTogZnVuY3Rpb24gKHRlcm0pIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2FnZW5jeScsXG4gICAgICAgICAgICBxOiB0ZXJtXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzdWx0czogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICByZXR1cm4geyByZXN1bHRzOiBkYXRhIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAobW9kZWxKc29uLmFnZW5jeSkge1xuICAgICAgJChcIiNjb21wYW55XCIpLnNlbGVjdDIoJ2RhdGEnLCBtb2RlbEpzb24uYWdlbmN5LnRhZyk7XG4gICAgfVxuXG4gICAgJChcIiN0b3BpY3NcIikub24oJ2NoYW5nZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBzZWxmLm1vZGVsLnRyaWdnZXIoXCJwcm9maWxlOmlucHV0OmNoYW5nZWRcIiwgZSk7XG4gICAgfSk7XG5cbiAgICAkKFwiI3NraWxsc1wiKS5vbignY2hhbmdlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHNlbGYubW9kZWwudHJpZ2dlcihcInByb2ZpbGU6aW5wdXQ6Y2hhbmdlZFwiLCBlKTtcbiAgICB9KTtcblxuICAgICQoXCIjY29tcGFueVwiKS5vbignY2hhbmdlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHNlbGYubW9kZWwudHJpZ2dlcihcInByb2ZpbGU6aW5wdXQ6Y2hhbmdlZFwiLCBlKTtcbiAgICB9KTtcbiAgICAkKCcjbG9jYXRpb24nKS5zZWxlY3QyKGxvY2F0aW9uU2V0dGluZ3MpLm9uKCdzZWxlY3QyLXNlbGVjdGluZycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciAkZWwgPSBzZWxmLiQoZS5jdXJyZW50VGFyZ2V0KSxcbiAgICAgICAgICBlbCA9IHRoaXM7XG4gICAgICBpZiAoZS5jaG9pY2UudGVtcCkge1xuICAgICAgICB0aGlzLnRlbXAgPSB0cnVlO1xuICAgICAgICAkKCcjbG9jYXRpb24nKS5zZWxlY3QyKCdkYXRhJywgZS5jaG9pY2UubmFtZSk7XG4gICAgICAgICQuZ2V0KCcvYXBpL2xvY2F0aW9uL3N1Z2dlc3Q/cT0nICsgZS5jaG9pY2UudmFsdWUsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICBkID0gXyhkKS5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgaWQ6IGl0ZW0ubmFtZSxcbiAgICAgICAgICAgICAgdGV4dDogaXRlbS5uYW1lLFxuICAgICAgICAgICAgICBuYW1lOiBpdGVtLm5hbWUsXG4gICAgICAgICAgICAgIHVubWF0Y2hlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdGFnVHlwZTogJ2xvY2F0aW9uJyxcbiAgICAgICAgICAgICAgZGF0YTogXyhpdGVtKS5vbWl0KCduYW1lJylcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZWwucmVsb2FkID0gdHJ1ZTtcbiAgICAgICAgICBlbC5vcGVuID0gdHJ1ZTtcbiAgICAgICAgICAkKCcjbG9jYXRpb24nKS5zZWxlY3QyKHsgZGF0YTogZCB9KS5zZWxlY3QyKCdvcGVuJyk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMudGVtcDtcbiAgICAgIH1cbiAgICB9KS5vbignc2VsZWN0Mi1vcGVuJywgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKCF0aGlzLnJlbG9hZCAmJiB0aGlzLm9wZW4pIHtcbiAgICAgICAgZGVsZXRlIHRoaXMub3BlbjtcbiAgICAgICAgZGVsZXRlIHRoaXMudGVtcDtcbiAgICAgICAgdmFyIGNhY2hlID0gJChcIiNsb2NhdGlvblwiKS5zZWxlY3QyKCdkYXRhJyk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgJChcIiNsb2NhdGlvblwiKS5zZWxlY3QyKGxvY2F0aW9uU2V0dGluZ3MpXG4gICAgICAgICAgICAuc2VsZWN0MignZGF0YScsIGNhY2hlKVxuICAgICAgICAgICAgLnNlbGVjdDIoJ29wZW4nKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucmVsb2FkICYmIHRoaXMub3Blbikge1xuICAgICAgICBkZWxldGUgdGhpcy5yZWxvYWQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKG1vZGVsSnNvbi5sb2NhdGlvbikge1xuICAgICAgJChcIiNsb2NhdGlvblwiKS5zZWxlY3QyKCdkYXRhJywgbW9kZWxKc29uLmxvY2F0aW9uLnRhZyk7XG4gICAgfVxuICAgICQoXCIjbG9jYXRpb25cIikub24oJ2NoYW5nZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBzZWxmLm1vZGVsLnRyaWdnZXIoXCJwcm9maWxlOmlucHV0OmNoYW5nZWRcIiwgZSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZVRleHRBcmVhOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMubWQpIHsgdGhpcy5tZC5jbGVhbnVwKCk7IH1cbiAgICB0aGlzLm1kID0gbmV3IE1hcmtkb3duRWRpdG9yKHtcbiAgICAgIGRhdGE6IHRoaXMubW9kZWwudG9KU09OKCkuYmlvLFxuICAgICAgZWw6IFwiLm1hcmtkb3duLWVkaXRcIixcbiAgICAgIGlkOiAnYmlvJyxcbiAgICAgIHBsYWNlaG9sZGVyOiAnQSBzaG9ydCBiaW9ncmFwaHkuJyxcbiAgICAgIHRpdGxlOiAnQmlvZ3JhcGh5JyxcbiAgICAgIHJvd3M6IDZcbiAgICB9KS5yZW5kZXIoKTtcbiAgfSxcblxuICBmaWVsZE1vZGlmaWVkOiBmdW5jdGlvbiAoZSkge1xuICAgIHRoaXMubW9kZWwudHJpZ2dlcihcInByb2ZpbGU6aW5wdXQ6Y2hhbmdlZFwiLCBlKTtcbiAgfSxcblxuICBwcm9maWxlQ2FuY2VsOiBmdW5jdGlvbiAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBCYWNrYm9uZS5oaXN0b3J5Lm5hdmlnYXRlKCdwcm9maWxlLycgKyB0aGlzLm1vZGVsLnRvSlNPTigpLmlkLCB7IHRyaWdnZXI6IHRydWUgfSk7XG4gIH0sXG5cbiAgcHJvZmlsZVNhdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICQoXCIjcHJvZmlsZS1mb3JtXCIpLnN1Ym1pdCgpO1xuICB9LFxuXG4gIHByb2ZpbGVTdWJtaXQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICQoXCIjcHJvZmlsZS1zYXZlLCAjc3VibWl0XCIpLmJ1dHRvbignbG9hZGluZycpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7ICQoXCIjcHJvZmlsZS1zYXZlLCAjc3VibWl0XCIpLmF0dHIoXCJkaXNhYmxlZFwiLCBcImRpc2FibGVkXCIpIH0sIDApO1xuICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgIG5hbWU6ICQoXCIjbmFtZVwiKS52YWwoKSxcbiAgICAgICAgICB0aXRsZTogJChcIiN0aXRsZVwiKS52YWwoKSxcbiAgICAgICAgICBiaW86ICQoXCIjYmlvXCIpLnZhbCgpXG4gICAgICAgIH0sXG4gICAgICAgIGVtYWlsID0gdGhpcy5tb2RlbC5nZXQoJ2VtYWlscycpWzBdLFxuICAgICAgICBzZWxmID0gdGhpcztcblxuICAgIGlmICgkKFwiI3Byb2ZpbGUtZW1haWxcIikudmFsKCkgIT09IGVtYWlsLmVtYWlsKSB7XG4gICAgICAkLmFqYXgoe1xuICAgICAgICB1cmw6ICcvYXBpL3VzZXJlbWFpbC8nICsgZW1haWwuaWQsXG4gICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgIG1ldGhvZDogJ3B1dCcsXG4gICAgICAgIGRhdGE6IHsgZW1haWw6ICQoXCIjcHJvZmlsZS1lbWFpbFwiKS52YWwoKSB9LFxuICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbigpIHsgc2VsZi5tb2RlbC50cmlnZ2VyKFwicHJvZmlsZTpzYXZlXCIsIGRhdGEpOyB9LFxuICAgICAgICBlcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIG1zZyA9ICdGYWlsZWQgdG8gdXBkYXRlIHlvdXIgZW1haWwgYWRkcmVzcy4gUGxlYXNlIHZlcmlmeSBpdCBcXFxuICAgICAgICAgICAgICAgICAgICAgaXMgYSB2YWxpZCBlbWFpbCBhZGRyZXNzIGFuZCB0cnkgYWdhaW4uJztcbiAgICAgICAgICAkKFwiI2VtYWlsLXVwZGF0ZS1hbGVydFwiKS5odG1sKG1zZyk7XG4gICAgICAgICAgJChcIiNlbWFpbC11cGRhdGUtYWxlcnRcIikuc2hvdygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tb2RlbC50cmlnZ2VyKFwicHJvZmlsZTpzYXZlXCIsIGRhdGEpO1xuICAgIH1cbiAgfSxcblxuICByZW1vdmVBdXRoOiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIG5vZGUgPSAkKGUudGFyZ2V0KTtcbiAgICAvLyB3YWxrIHVwIHRoZSB0cmVlIHVudGlsIHdlIGdldCB0byB0aGUgbWFya2VkIG5vZGVcbiAgICB3aGlsZSAoIShub2RlLmhhc0NsYXNzKFwicmVtb3ZlQXV0aFwiKSkpIHtcbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudCgpO1xuICAgIH1cbiAgICB0aGlzLm1vZGVsLnRyaWdnZXIoXCJwcm9maWxlOnJlbW92ZUF1dGhcIiwgbm9kZS5hdHRyKFwiaWRcIikpO1xuICB9LFxuXG4gIGxpa2U6IGZ1bmN0aW9uIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2hpbGQgPSAkKGUuY3VycmVudFRhcmdldCkuY2hpbGRyZW4oXCIjbGlrZS1idXR0b24taWNvblwiKTtcbiAgICB2YXIgbGlrZW51bWJlciA9ICQoXCIjbGlrZS1udW1iZXJcIik7XG4gICAgLy8gTm90IHlldCBsaWtlZCwgaW5pdGlhdGUgbGlrZVxuICAgIGlmIChjaGlsZC5oYXNDbGFzcygnZmEtc3Rhci1vJykpIHtcbiAgICAgIGNoaWxkLnJlbW92ZUNsYXNzKCdmYS1zdGFyLW8nKTtcbiAgICAgIGNoaWxkLmFkZENsYXNzKCdmYSBmYS1zdGFyJyk7XG4gICAgICBsaWtlbnVtYmVyLnRleHQocGFyc2VJbnQobGlrZW51bWJlci50ZXh0KCkpICsgMSk7XG4gICAgICBpZiAocGFyc2VJbnQobGlrZW51bWJlci50ZXh0KCkpID09PSAxKSB7XG4gICAgICAgICQoXCIjbGlrZS10ZXh0XCIpLnRleHQoJChcIiNsaWtlLXRleHRcIikuZGF0YSgnc2luZ3VsYXInKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkKFwiI2xpa2UtdGV4dFwiKS50ZXh0KCQoXCIjbGlrZS10ZXh0XCIpLmRhdGEoJ3BsdXJhbCcpKTtcbiAgICAgIH1cbiAgICAgICQuYWpheCh7XG4gICAgICAgIHVybDogJy9hcGkvbGlrZS9saWtldS8nICsgc2VsZi5tb2RlbC5hdHRyaWJ1dGVzLmlkXG4gICAgICB9KS5kb25lKCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAvLyBsaWtlZCFcbiAgICAgICAgLy8gcmVzcG9uc2Ugc2hvdWxkIGJlIHRoZSBsaWtlIG9iamVjdFxuICAgICAgICAvLyBjb25zb2xlLmxvZyhkYXRhLmlkKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBMaWtlZCwgaW5pdGlhdGUgdW5saWtlXG4gICAgZWxzZSB7XG4gICAgICBjaGlsZC5yZW1vdmVDbGFzcygnZmEtc3RhcicpO1xuICAgICAgY2hpbGQuYWRkQ2xhc3MoJ2ZhLXN0YXItbycpO1xuICAgICAgbGlrZW51bWJlci50ZXh0KHBhcnNlSW50KGxpa2VudW1iZXIudGV4dCgpKSAtIDEpO1xuICAgICAgaWYgKHBhcnNlSW50KGxpa2VudW1iZXIudGV4dCgpKSA9PT0gMSkge1xuICAgICAgICAkKFwiI2xpa2UtdGV4dFwiKS50ZXh0KCQoXCIjbGlrZS10ZXh0XCIpLmRhdGEoJ3Npbmd1bGFyJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJChcIiNsaWtlLXRleHRcIikudGV4dCgkKFwiI2xpa2UtdGV4dFwiKS5kYXRhKCdwbHVyYWwnKSk7XG4gICAgICB9XG4gICAgICAkLmFqYXgoe1xuICAgICAgICB1cmw6ICcvYXBpL2xpa2UvdW5saWtldS8nICsgc2VsZi5tb2RlbC5hdHRyaWJ1dGVzLmlkXG4gICAgICB9KS5kb25lKCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAvLyB1bi1saWtlZCFcbiAgICAgICAgLy8gcmVzcG9uc2Ugc2hvdWxkIGJlIG51bGwgKGVtcHR5KVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMubWQpIHsgdGhpcy5tZC5jbGVhbnVwKCk7IH1cbiAgICBpZiAodGhpcy50YWdWaWV3KSB7IHRoaXMudGFnVmlldy5jbGVhbnVwKCk7IH1cbiAgICBpZiAodGhpcy5wcm9qZWN0VmlldykgeyB0aGlzLnByb2plY3RWaWV3LmNsZWFudXAoKTsgfVxuICAgIGlmICh0aGlzLnRhc2tWaWV3KSB7IHRoaXMudGFza1ZpZXcuY2xlYW51cCgpOyB9XG4gICAgaWYgKHRoaXMudm9sVmlldykgeyB0aGlzLnZvbFZpZXcuY2xlYW51cCgpOyB9XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfSxcblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvZmlsZVNob3dWaWV3O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxmb3JtIGFjdGlvbj1cXFwiXFxcIiBpZD1cXFwicHJvamVjdC1mb3JtXFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWJvZHlcXFwiPlxcbiAgICA8ZmllbGRzZXQ+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJwcm9qZWN0LWZvcm0tdGl0bGVcXFwiPjxzcGFuIGRhdGEtaTE4bj1cXFwiUHJvamVjdFxcXCI+UHJvamVjdDwvc3Bhbj4gVGl0bGU8L2xhYmVsPlxcbiAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIGNsYXNzPVxcXCJwcm9qZWN0LXRpdGxlLWZvcm0gZm9ybS1jb250cm9sXFxcIiBpZD1cXFwicHJvamVjdC1mb3JtLXRpdGxlXFxcIiBuYW1lPVxcXCJwcm9qZWN0LWZvcm0tdGl0bGVcXFwiIHBsYWNlaG9sZGVyPVxcXCJUaXRsZVxcXCIgZGF0YS12YWxpZGF0ZT1cXFwiZW1wdHksY291bnQxMDBcXFwiPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcImhlbHAtYmxvY2sgZXJyb3ItZW1wdHlcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIj5Zb3UgbXVzdCBlbnRlciBhIHRpdGxlLjwvc3Bhbj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJoZWxwLWJsb2NrIGVycm9yLWNvdW50MTAwXFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI+VGhlIHRpdGxlIG11c3QgYmUgbGVzcyB0aGFuIDEwMCBjaGFyYWN0ZXJzLjwvc3Bhbj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcInByb2plY3QtZm9ybS1kZXNjcmlwdGlvblxcXCI+PHNwYW4gZGF0YS1pMThuPVxcXCJQcm9qZWN0XFxcIj5Qcm9qZWN0PC9zcGFuPiBEZXNjcmlwdGlvbjwvbGFiZWw+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtYXJrZG93bi1lZGl0XFxcIj48L2Rpdj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJoZWxwLWJsb2NrIGVycm9yLWVtcHR5XFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI+WW91IG11c3QgZW50ZXIgYSBkZXNjcmlwdGlvbi48L3NwYW4+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZmllbGRzZXQ+XFxuICA8L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWZvb3RlclxcXCI+XFxuICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1jMFxcXCIgZGF0YS1kaXNtaXNzPVxcXCJtb2RhbFxcXCI+Q2FuY2VsPC9idXR0b24+XFxuICAgIDxpbnB1dCB0eXBlPVxcXCJzdWJtaXRcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWMyIGJ0bi1hZGQtcHJvamVjdFxcXCIgaWQ9XFxcInN1Ym1pdFxcXCIgdmFsdWU9XFxcIkFkZCBQcm9qZWN0XFxcIi8+XFxuICA8L2Rpdj5cXG48L2Zvcm0+XFxuXCI7XG4iLCJ2YXIgQm9vdHN0cmFwID0gcmVxdWlyZSgnYm9vdHN0cmFwJyk7XG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgTWFya2Rvd25FZGl0b3IgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb21wb25lbnRzL21hcmtkb3duX2VkaXRvcicpO1xudmFyIFByb2plY3RzQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2VudGl0aWVzL3Byb2plY3RzL3Byb2plY3RzX2NvbGxlY3Rpb24nKTtcbnZhciBQcm9qZWN0Rm9ybVRlbXBsYXRlID0gcmVxdWlyZSgnLi4vdGVtcGxhdGVzL3Byb2plY3RfbmV3X2Zvcm1fdGVtcGxhdGUuaHRtbCcpO1xuXG5cbnZhciBQcm9qZWN0Rm9ybVZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG5cbiAgZXZlbnRzOiB7XG4gICAgXCJibHVyICNwcm9qZWN0LWZvcm0tdGl0bGVcIiAgICAgIDogXCJ2XCIsXG4gICAgXCJibHVyICNwcm9qZWN0LWZvcm0tZGVzY3JpcHRpb25cIjogXCJ2XCIsXG4gICAgXCJzdWJtaXQgI3Byb2plY3QtZm9ybVwiICAgICAgICAgIDogXCJwb3N0XCJcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBfLnRlbXBsYXRlKFByb2plY3RGb3JtVGVtcGxhdGUpO1xuICAgIHRoaXMuJGVsLmh0bWwodGVtcGxhdGUpO1xuXG4gICAgdGhpcy4kZWwuaTE4bigpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZVRleHRBcmVhKCk7XG4gICAgdGhpcy4kKFwiLmJ0bi1hZGQtcHJvamVjdFwiKS52YWwoJ0FkZCAnICsgaTE4bi50KCdQcm9qZWN0JykpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHY6IGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlKGUpO1xuICB9LFxuXG4gIGluaXRpYWxpemVUZXh0QXJlYTogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm1kKSB7IHRoaXMubWQuY2xlYW51cCgpOyB9XG4gICAgdGhpcy5tZCA9IG5ldyBNYXJrZG93bkVkaXRvcih7XG4gICAgICBkYXRhOiAnJyxcbiAgICAgIGVsOiBcIi5tYXJrZG93bi1lZGl0XCIsXG4gICAgICBpZDogJ3Byb2plY3QtZm9ybS1kZXNjcmlwdGlvbicsXG4gICAgICBwbGFjZWhvbGRlcjogJ0EgZGVzY3JpcHRpb24gb2YgeW91ciAnICsgaTE4bi50KCdwcm9qZWN0JykgKyAnIHRoYXQgZXhwbGFpbnMgdGhlIGZvY3VzLCBvYmplY3RpdmVzLCBhbmQgZGVsaXZlcmFibGVzLicsXG4gICAgICB0aXRsZTogaTE4bi50KCdQcm9qZWN0JykgKyAnIERlc2NyaXB0aW9uJyxcbiAgICAgIHJvd3M6IDYsXG4gICAgICB2YWxpZGF0ZTogWydlbXB0eSddXG4gICAgfSkucmVuZGVyKCk7XG4gIH0sXG5cbiAgcG9zdDogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgLy8gdmFsaWRhdGUgaW5wdXQgZmllbGRzXG4gICAgdmFyIHZhbGlkYXRlSWRzID0gWycjcHJvamVjdC1mb3JtLXRpdGxlJywgJyNwcm9qZWN0LWZvcm0tZGVzY3JpcHRpb24nXTtcbiAgICB2YXIgYWJvcnQgPSBmYWxzZTtcbiAgICBmb3IgKGkgaW4gdmFsaWRhdGVJZHMpIHtcbiAgICAgIHZhciBpQWJvcnQgPSB2YWxpZGF0ZSh7IGN1cnJlbnRUYXJnZXQ6IHZhbGlkYXRlSWRzW2ldIH0pO1xuICAgICAgYWJvcnQgPSBhYm9ydCB8fCBpQWJvcnQ7XG4gICAgfVxuICAgIGlmIChhYm9ydCA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHByb2Nlc3MgcHJvamVjdCBmb3JtXG4gICAgdmFyIGRhdGE7XG4gICAgZGF0YSA9IHtcbiAgICAgIHRpdGxlICAgICAgIDogdGhpcy4kKFwiLnByb2plY3QtdGl0bGUtZm9ybVwiKS52YWwoKSxcbiAgICAgIGRlc2NyaXB0aW9uIDogdGhpcy4kKFwiI3Byb2plY3QtZm9ybS1kZXNjcmlwdGlvblwiKS52YWwoKVxuICAgIH07XG5cbiAgICB0aGlzLmNvbGxlY3Rpb24udHJpZ2dlcihcInByb2plY3Q6c2F2ZVwiLCBkYXRhKTtcbiAgfSxcblxuICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMubWQpIHsgdGhpcy5tZC5jbGVhbnVwKCk7IH1cbiAgICByZW1vdmVWaWV3KHRoaXMpO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb2plY3RGb3JtVmlldztcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIGFzeW5jID0gcmVxdWlyZSgnYXN5bmMnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgUG9wb3ZlcnMgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9taXhpbnMvcG9wb3ZlcnMnKTtcbnZhciBCYXNlQ29udHJvbGxlciA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2Jhc2UvYmFzZV9jb250cm9sbGVyJyk7XG52YXIgUHJvamVjdEl0ZW1WaWV3ID0gcmVxdWlyZSgnLi4vdmlld3MvcHJvamVjdF9pdGVtX3ZpZXcnKTtcbnZhciBQcm9qZWN0SXRlbUNvcmVNZXRhVmlldyA9IHJlcXVpcmUoJy4uL3ZpZXdzL3Byb2plY3RfaXRlbV9jb3JlbWV0YV92aWV3Jyk7XG52YXIgUHJvamVjdG93bmVyU2hvd1ZpZXcgPSByZXF1aXJlKCcuLi8uLi8uLi9wcm9qZWN0b3duZXIvc2hvdy92aWV3cy9wcm9qZWN0b3duZXJfc2hvd192aWV3Jyk7XG52YXIgQXR0YWNobWVudFZpZXcgPSByZXF1aXJlKCcuLi8uLi8uLi9hdHRhY2htZW50L3ZpZXdzL2F0dGFjaG1lbnRfc2hvd192aWV3Jyk7XG52YXIgVGFza0xpc3RDb250cm9sbGVyID0gcmVxdWlyZSgnLi4vLi4vLi4vdGFza3MvbGlzdC9jb250cm9sbGVycy90YXNrX2xpc3RfY29udHJvbGxlcicpO1xudmFyIEV2ZW50TGlzdENvbnRyb2xsZXIgPSByZXF1aXJlKCcuLi8uLi8uLi9ldmVudHMvbGlzdC9jb250cm9sbGVycy9ldmVudF9saXN0X2NvbnRyb2xsZXInKTtcbnZhciBDb21tZW50TGlzdENvbnRyb2xsZXIgPSByZXF1aXJlKCcuLi8uLi8uLi9jb21tZW50cy9saXN0L2NvbnRyb2xsZXJzL2NvbW1lbnRfbGlzdF9jb250cm9sbGVyJyk7XG52YXIgQ29tbWVudEZvcm1WaWV3ID0gcmVxdWlyZSgnLi4vLi4vLi4vY29tbWVudHMvbmV3L3ZpZXdzL2NvbW1lbnRfZm9ybV92aWV3Jyk7XG52YXIgTW9kYWxDb21wb25lbnQgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb21wb25lbnRzL21vZGFsJyk7XG52YXIgTW9kYWxBbGVydCA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2NvbXBvbmVudHMvbW9kYWxfYWxlcnQnKTtcbnZhciBUYXNrTW9kZWwgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9lbnRpdGllcy90YXNrcy90YXNrX21vZGVsJyk7XG52YXIgUHJvamVjdE9wZW5UYXNrc1dhcm5pbmdUZW1wbGF0ZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy9wcm9qZWN0X29wZW5fdGFza3Nfd2FybmluZ190ZW1wbGF0ZS5odG1sJyk7XG5cblxudmFyIHBvcG92ZXJzID0gbmV3IFBvcG92ZXJzKCk7XG5cblByb2plY3QgPSB7fTtcblxuUHJvamVjdC5TaG93Q29udHJvbGxlciA9IEJhc2VDb250cm9sbGVyLmV4dGVuZCh7XG5cbiAgZWw6IFwiI2NvbnRhaW5lclwiLFxuXG4gIC8vIFNldCB0aGUgbW9kZWwgdG8gbnVsbCwgYmVmb3JlIGl0IGlzIGZldGNoZWQgZnJvbSB0aGUgc2VydmVyLlxuICAvLyBUaGlzIGFsbG93cyB1cyB0byBjbGVhciBvdXQgdGhlIHByZXZpb3VzIGRhdGEgZnJvbSB0aGUgbGlzdF92aWV3LFxuICAvLyBhbmQgZ2V0IHJlYWR5IGZvciB0aGUgbmV3IGRhdGEgZm9yIHRoZSBwcm9qZWN0IHNob3cgdmlldy5cbiAgbW9kZWw6IG51bGwsXG5cbiAgZXZlbnRzOiB7XG4gICAgXCJjbGljayAjbGlrZS1idXR0b25cIiAgICAgICAgICAgICAgOiBcImxpa2VcIixcbiAgICBcImtleXVwIC5jb21tZW50LWNvbnRlbnRcIiAgICAgICAgICA6IFwic2VhcmNoXCIsXG4gICAgXCJjbGljayAjdGFnLXNhdmVcIiAgICAgICAgICAgICAgICAgOiBcInRhZ1NhdmVcIixcbiAgICBcImNsaWNrICN0YWctY3JlYXRlXCIgICAgICAgICAgICAgICA6IFwidGFnQ3JlYXRlXCIsXG4gICAgXCJjbGljayAudGFnLWRlbGV0ZVwiICAgICAgICAgICAgICAgOiBcInRhZ0RlbGV0ZVwiLFxuICAgIFwiY2xpY2sgI3Byb2plY3QtY2xvc2VcIiAgICAgICAgICAgIDogXCJzdGF0ZUNsb3NlXCIsXG4gICAgXCJjbGljayAjcHJvamVjdC1yZW9wZW5cIiAgICAgICAgICAgOiBcInN0YXRlUmVvcGVuXCIsXG4gICAgJ2NsaWNrICNlZGl0UHJvamVjdCcgICAgICAgICAgICAgIDogJ3RvZ2dsZUVkaXRNb2RlJyxcbiAgICBcIm1vdXNlZW50ZXIgLnByb2plY3QtcGVvcGxlLWRpdlwiICA6IHBvcG92ZXJzLnBvcG92ZXJQZW9wbGVPbixcbiAgICBcImNsaWNrIC5wcm9qZWN0LXBlb3BsZS1kaXZcIiAgICAgICA6IHBvcG92ZXJzLnBvcG92ZXJDbGlja1xuICB9LFxuXG4gIC8vIFRoZSBpbml0aWFsaXplIG1ldGhvZCBpcyBtYWlubHkgdXNlZCBmb3IgZXZlbnQgYmluZGluZ3MgKGZvciBlZmZlY2llbmN5KVxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMucm91dGVyID0gb3B0aW9ucy5yb3V0ZXI7XG4gICAgdGhpcy5pZCA9IG9wdGlvbnMuaWQ7XG4gICAgdGhpcy5kYXRhID0gb3B0aW9ucy5kYXRhO1xuICAgIHRoaXMuYWN0aW9uID0gb3B0aW9ucy5hY3Rpb247XG5cbiAgICB0aGlzLm1vZGVsLnRyaWdnZXIoXCJwcm9qZWN0Om1vZGVsOmZldGNoXCIsIHRoaXMubW9kZWwuaWQpO1xuICAgIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbCwgXCJwcm9qZWN0Om1vZGVsOmZldGNoOnN1Y2Nlc3NcIiwgZnVuY3Rpb24gKHByb2plY3RNb2RlbCkge1xuICAgICAgc2VsZi5tb2RlbCA9IHByb2plY3RNb2RlbDtcbiAgICAgIGlmIChzZWxmLmFjdGlvbiA9PSAnZWRpdCcpIHtcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbC50b0pTT04oKTtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHVzZXIgb3ducyB0aGUgdGFza1xuICAgICAgICB2YXIgb3duZXIgPSBtb2RlbC5pc093bmVyO1xuICAgICAgICBpZiAob3duZXIgIT09IHRydWUpIHtcbiAgICAgICAgICAvLyBpZiBub25lIG9mIHRoZXNlIGFwcGx5LCBhcmUgdGhleSBhbiBhZG1pbj9cbiAgICAgICAgICBpZiAod2luZG93LmNhY2hlLmN1cnJlbnRVc2VyKSB7XG4gICAgICAgICAgICBpZiAod2luZG93LmNhY2hlLmN1cnJlbnRVc2VyLmlzQWRtaW4gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgb3duZXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBub3QgdGhlIG93bmVyLCB0cmlnZ2VyIHRoZSBsb2dpbiBkaWFsb2cuXG4gICAgICAgIGlmIChvd25lciAhPT0gdHJ1ZSkge1xuICAgICAgICAgIHdpbmRvdy5jYWNoZS51c2VyRXZlbnRzLnRyaWdnZXIoXCJ1c2VyOnJlcXVlc3Q6bG9naW5cIiwge1xuICAgICAgICAgICAgbWVzc2FnZTogXCJZb3UgYXJlIG5vdCB0aGUgb3duZXIgb2YgdGhpcyBwcm9qZWN0LiA8YSBjbGFzcz0nbGluay1iYWNrYm9uZScgaHJlZj0nL3Byb2plY3RzL1wiICsgbW9kZWwuaWQgKyBcIic+VmlldyB0aGUgcHJvamVjdCBpbnN0ZWFkLjwvYT5cIixcbiAgICAgICAgICAgIGRpc2FibGVDbG9zZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2VsZi5pbml0aWFsaXplSXRlbVZpZXcoKTtcbiAgICB9KTtcblxuICAgIHRoaXMubW9kZWwub24oXCJwcm9qZWN0OnNob3c6cmVuZGVyZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5pbml0aWFsaXplSXRlbUNvcmVNZXRhVmlldygpO1xuICAgICAgc2VsZi5pbml0aWFsaXplT3duZXJzKCk7XG4gICAgICBzZWxmLmluaXRpYWxpemVJdGVtVmlld0NvbnRyb2xsZXJzKCk7XG4gICAgICBzZWxmLmluaXRpYWxpemVIYW5kbGVycygpO1xuICAgICAgc2VsZi5pbml0aWFsaXplTGlrZXMoKTtcbiAgICAgIHNlbGYuaW5pdGlhbGl6ZVVJKCk7XG4gICAgfSk7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZUl0ZW1WaWV3OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucHJvamVjdFNob3dJdGVtVmlldykgdGhpcy5wcm9qZWN0U2hvd0l0ZW1WaWV3LmNsZWFudXAoKTtcbiAgICB0aGlzLnByb2plY3RTaG93SXRlbVZpZXcgID0gbmV3IFByb2plY3RJdGVtVmlldyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogdGhpcy5hY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5yZW5kZXIoKTtcbiAgfSxcblxuICBpbml0aWFsaXplSXRlbUNvcmVNZXRhVmlldzogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnByb2plY3RTaG93SXRlbUNvcmVNZXRhVmlldykgdGhpcy5wcm9qZWN0U2hvd0l0ZW1Db3JlTWV0YVZpZXcuY2xlYW51cCgpO1xuICAgIHRoaXMucHJvamVjdFNob3dJdGVtQ29yZU1ldGFWaWV3ICA9IG5ldyBQcm9qZWN0SXRlbUNvcmVNZXRhVmlldyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogdGhpcy5hY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkucmVuZGVyKCk7XG4gIH0sXG5cblxuICBpbml0aWFsaXplT3duZXJzIDogZnVuY3Rpb24oKXtcbiAgICBpZiAodGhpcy5wcm9qZWN0b3duZXJTaG93VmlldykgdGhpcy5wcm9qZWN0b3duZXJTaG93Vmlldy5jbGVhbnVwKCk7XG4gICAgdGhpcy5wcm9qZWN0b3duZXJTaG93VmlldyA9IG5ldyBQcm9qZWN0b3duZXJTaG93Vmlldyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogdGhpcy5hY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkucmVuZGVyKCk7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZUl0ZW1WaWV3Q29udHJvbGxlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5hY3Rpb24gIT0gJ2VkaXQnKSB7XG4gICAgICAvLyBUYXNrc1xuICAgICAgaWYgKHRoaXMudGFza0xpc3RDb250cm9sbGVyKSB0aGlzLnRhc2tMaXN0Q29udHJvbGxlci5jbGVhbnVwKCk7XG4gICAgICB0aGlzLnRhc2tMaXN0Q29udHJvbGxlciA9IG5ldyBUYXNrTGlzdENvbnRyb2xsZXIoe1xuICAgICAgICBwcm9qZWN0SWQ6IHRoaXMubW9kZWwuaWRcbiAgICAgIH0pO1xuXG4gICAgICAvLyBFdmVudHNcbiAgICAgIGlmICh0aGlzLmV2ZW50TGlzdENvbnRyb2xsZXIpIHRoaXMuZXZlbnRMaXN0Q29udHJvbGxlci5jbGVhbnVwKCk7XG4gICAgICB0aGlzLmV2ZW50TGlzdENvbnRyb2xsZXIgPSBuZXcgRXZlbnRMaXN0Q29udHJvbGxlcih7XG4gICAgICAgIHByb2plY3RJZDogdGhpcy5tb2RlbC5pZFxuICAgICAgfSk7XG4gICAgICAvLyBDb21tZW50c1xuICAgICAgaWYgKHRoaXMuY29tbWVudExpc3RDb250cm9sbGVyKSB0aGlzLmNvbW1lbnRMaXN0Q29udHJvbGxlci5jbGVhbnVwKCk7XG4gICAgICB0aGlzLmNvbW1lbnRMaXN0Q29udHJvbGxlciA9IG5ldyBDb21tZW50TGlzdENvbnRyb2xsZXIoe1xuICAgICAgICB0YXJnZXQ6ICdwcm9qZWN0JyxcbiAgICAgICAgaWQ6IHRoaXMubW9kZWwuaWRcbiAgICAgIH0pO1xuICAgICAgLy8gQXR0YWNobWVudHNcbiAgICAgIGlmICh0aGlzLmF0dGFjaG1lbnRWaWV3KSB0aGlzLmF0dGFjaG1lbnRWaWV3LmNsZWFudXAoKTtcbiAgICAgIHRoaXMuYXR0YWNobWVudFZpZXcgPSBuZXcgQXR0YWNobWVudFZpZXcoe1xuICAgICAgICB0YXJnZXQ6ICdwcm9qZWN0JyxcbiAgICAgICAgaWQ6IHRoaXMubW9kZWwuYXR0cmlidXRlcy5pZCxcbiAgICAgICAgYWN0aW9uOiB0aGlzLmFjdGlvbixcbiAgICAgICAgZGF0YTogdGhpcy5kYXRhLFxuICAgICAgICBvd25lcjogdGhpcy5tb2RlbC5hdHRyaWJ1dGVzLmlzT3duZXIsXG4gICAgICAgIGVsOiAnLmF0dGFjaG1lbnQtd3JhcHBlcidcbiAgICAgIH0pLnJlbmRlcigpO1xuICAgIH1cbiAgfSxcblxuICBpbml0aWFsaXplTGlrZXM6IGZ1bmN0aW9uKCkge1xuICAgICQoXCIjbGlrZS1udW1iZXJcIikudGV4dCh0aGlzLm1vZGVsLmF0dHJpYnV0ZXMubGlrZUNvdW50KTtcbiAgICBpZiAocGFyc2VJbnQodGhpcy5tb2RlbC5hdHRyaWJ1dGVzLmxpa2VDb3VudCkgPT09IDEpIHtcbiAgICAgICQoXCIjbGlrZS10ZXh0XCIpLnRleHQoJChcIiNsaWtlLXRleHRcIikuZGF0YSgnc2luZ3VsYXInKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICQoXCIjbGlrZS10ZXh0XCIpLnRleHQoJChcIiNsaWtlLXRleHRcIikuZGF0YSgncGx1cmFsJykpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tb2RlbC5hdHRyaWJ1dGVzLmxpa2UpIHtcbiAgICAgICQoXCIjbGlrZS1idXR0b24taWNvblwiKS5yZW1vdmVDbGFzcygnZmEtc3Rhci1vJyk7XG4gICAgICAkKFwiI2xpa2UtYnV0dG9uLWljb25cIikuYWRkQ2xhc3MoJ2ZhIGZhLXN0YXInKTtcbiAgICB9XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZUhhbmRsZXJzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsIFwicHJvamVjdDp1cGRhdGU6c3RhdGU6c3VjY2Vzc1wiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgaWYgKGRhdGEuYXR0cmlidXRlcy5zdGF0ZSA9PSAnY2xvc2VkJykge1xuICAgICAgICAkKFwiI2xpLXByb2plY3QtY2xvc2VcIikuaGlkZSgpO1xuICAgICAgICAkKFwiI2xpLXByb2plY3QtcmVvcGVuXCIpLnNob3coKTtcbiAgICAgICAgJChcIiNhbGVydC1jbG9zZWRcIikuc2hvdygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJChcIiNsaS1wcm9qZWN0LWNsb3NlXCIpLnNob3coKTtcbiAgICAgICAgJChcIiNsaS1wcm9qZWN0LXJlb3BlblwiKS5oaWRlKCk7XG4gICAgICAgICQoXCIjYWxlcnQtY2xvc2VkXCIpLmhpZGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBpbml0aWFsaXplVUk6IGZ1bmN0aW9uKCkge1xuICAgIHBvcG92ZXJzLnBvcG92ZXJQZW9wbGVJbml0KFwiLnByb2plY3QtcGVvcGxlLWRpdlwiKTtcbiAgfSxcblxuICB0b2dnbGVFZGl0TW9kZTogZnVuY3Rpb24oZSl7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB2YXIgYWN0aW9uID0gJyc7XG4gICAgaWYgKCEodGhpcy5hY3Rpb24gJiYgdGhpcy5hY3Rpb24gPT0gJ2VkaXQnKSkge1xuICAgICAgYWN0aW9uID0gJy9lZGl0JztcbiAgICB9XG4gICAgQmFja2JvbmUuaGlzdG9yeS5uYXZpZ2F0ZSgncHJvamVjdHMvJyArIHRoaXMuaWQgKyBhY3Rpb24sIHsgdHJpZ2dlcjogdHJ1ZSB9KTtcbiAgfSxcblxuICBzdGF0ZUNsb3NlOiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHByb2plY3RUYXNrcyA9IHNlbGYubW9kZWwuaGFzT3BlblRhc2tzKHNlbGYudGFza0xpc3RDb250cm9sbGVyLmNvbGxlY3Rpb24pO1xuICAgIGlmICh0aGlzLm1vZGFsQWxlcnQpIHsgdGhpcy5tb2RhbEFsZXJ0LmNsZWFudXAoKTsgfVxuICAgIGlmICh0aGlzLm1vZGFsQ29tcG9uZW50KSB7IHRoaXMubW9kYWxDb21wb25lbnQuY2xlYW51cCgpOyB9XG4gICAgdGhpcy5tb2RhbENvbXBvbmVudCA9IG5ldyBNb2RhbENvbXBvbmVudCh7XG4gICAgICBlbDogXCIjbW9kYWwtY2xvc2VcIixcbiAgICAgIGlkOiBcImNoZWNrLWNsb3NlXCIsXG4gICAgICBtb2RhbFRpdGxlOiBcIkNsb3NlIFwiK2kxOG4udChcIlByb2plY3RcIilcbiAgICB9KS5yZW5kZXIoKTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgaWYgKCBwcm9qZWN0VGFza3MuaGFzT3BlblRhc2tzICl7XG4gICAgICB2YXIgbW9kYWxDb250ZW50ID0gXy50ZW1wbGF0ZShQcm9qZWN0T3BlblRhc2tzV2FybmluZ1RlbXBsYXRlKSh7Y291bnQ6IHByb2plY3RUYXNrcy5jb3VudH0pO1xuICAgICAgdmFyIHN1Ym1pdExhYmVsID0gXCJJIFVuZGVyc3RhbmQgYW5kIFdhbnQgdG8gQ2xvc2UgVGhpcyBcIitpMThuLnQoXCJQcm9qZWN0XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbW9kYWxDb250ZW50ID0gJzxwPkFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBjbG9zZSB0aGlzICcraTE4bi50KFwicHJvamVjdFwiKSsnPyAgT25jZSB0aGUgJytpMThuLnQoXCJwcm9qZWN0XCIpKycgaXMgY2xvc2VkLCBwYXJ0aWNpcGFudHMgd2lsbCBubyBsb25nZXIgYmUgYWJsZSB0byBjb250cmlidXRlLjwvcD4nO1xuICAgICAgdmFyIHN1Ym1pdExhYmVsID0gXCJDbG9zZSBcIitpMThuLnQoXCJQcm9qZWN0XCIpO1xuICAgIH1cblxuICAgIHRoaXMubW9kYWxBbGVydCA9IG5ldyBNb2RhbEFsZXJ0KHtcbiAgICAgIGVsOiBcIiNjaGVjay1jbG9zZSAubW9kYWwtdGVtcGxhdGVcIixcbiAgICAgIG1vZGFsRGl2OiAnI2NoZWNrLWNsb3NlJyxcbiAgICAgIGNvbnRlbnQ6IG1vZGFsQ29udGVudCxcbiAgICAgIGNhbmNlbDogJ0NhbmNlbCcsXG4gICAgICBzdWJtaXQ6IHN1Ym1pdExhYmVsLFxuICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIC8vIHVzZXIgY2xpY2tlZCB0aGUgc3VibWl0IGJ1dHRvblxuICAgICAgICBpZiAoIHByb2plY3RUYXNrcy5oYXNPcGVuVGFza3MgKSB7IHNlbGYubW9kZWwudHJpZ2dlcihcInByb2plY3Q6dXBkYXRlOnRhc2tzOm9ycGhhblwiLHNlbGYudGFza0xpc3RDb250cm9sbGVyLmNvbGxlY3Rpb24pOyB9XG4gICAgICAgIHNlbGYubW9kZWwudHJpZ2dlcihcInByb2plY3Q6dXBkYXRlOnN0YXRlXCIsICdjbG9zZWQnKTtcbiAgICAgICAgc2VsZi5pbml0aWFsaXplSXRlbVZpZXcoKTtcbiAgICAgIH1cbiAgICB9KS5yZW5kZXIoKTtcbiAgfSxcblxuICBzdGF0ZVJlb3BlbjogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMubW9kZWwudHJpZ2dlcihcInByb2plY3Q6dXBkYXRlOnN0YXRlXCIsICdvcGVuJyk7XG4gIH0sXG5cbiAgbGlrZTogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2hpbGQgPSAkKGUuY3VycmVudFRhcmdldCkuY2hpbGRyZW4oXCIjbGlrZS1idXR0b24taWNvblwiKTtcbiAgICB2YXIgbGlrZW51bWJlciA9ICQoXCIjbGlrZS1udW1iZXJcIik7XG4gICAgLy8gTm90IHlldCBsaWtlZCwgaW5pdGlhdGUgbGlrZVxuICAgIGlmIChjaGlsZC5oYXNDbGFzcygnZmEtc3Rhci1vJykpIHtcbiAgICAgIGNoaWxkLnJlbW92ZUNsYXNzKCdmYS1zdGFyLW8nKTtcbiAgICAgIGNoaWxkLmFkZENsYXNzKCdmYSBmYS1zdGFyJyk7XG4gICAgICBsaWtlbnVtYmVyLnRleHQocGFyc2VJbnQobGlrZW51bWJlci50ZXh0KCkpICsgMSk7XG4gICAgICBpZiAocGFyc2VJbnQobGlrZW51bWJlci50ZXh0KCkpID09PSAxKSB7XG4gICAgICAgICQoXCIjbGlrZS10ZXh0XCIpLnRleHQoJChcIiNsaWtlLXRleHRcIikuZGF0YSgnc2luZ3VsYXInKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkKFwiI2xpa2UtdGV4dFwiKS50ZXh0KCQoXCIjbGlrZS10ZXh0XCIpLmRhdGEoJ3BsdXJhbCcpKTtcbiAgICAgIH1cbiAgICAgICQuYWpheCh7XG4gICAgICAgIHVybDogJy9hcGkvbGlrZS9saWtlLycgKyB0aGlzLm1vZGVsLmF0dHJpYnV0ZXMuaWRcbiAgICAgIH0pLmRvbmUoIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIC8vIGxpa2VkIVxuICAgICAgICAvLyByZXNwb25zZSBzaG91bGQgYmUgdGhlIGxpa2Ugb2JqZWN0XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGRhdGEuaWQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIExpa2VkLCBpbml0aWF0ZSB1bmxpa2VcbiAgICBlbHNlIHtcbiAgICAgIGNoaWxkLnJlbW92ZUNsYXNzKCdmYS1zdGFyJyk7XG4gICAgICBjaGlsZC5hZGRDbGFzcygnZmEtc3Rhci1vJyk7XG4gICAgICBsaWtlbnVtYmVyLnRleHQocGFyc2VJbnQobGlrZW51bWJlci50ZXh0KCkpIC0gMSk7XG4gICAgICBpZiAocGFyc2VJbnQobGlrZW51bWJlci50ZXh0KCkpID09PSAxKSB7XG4gICAgICAgICQoXCIjbGlrZS10ZXh0XCIpLnRleHQoJChcIiNsaWtlLXRleHRcIikuZGF0YSgnc2luZ3VsYXInKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkKFwiI2xpa2UtdGV4dFwiKS50ZXh0KCQoXCIjbGlrZS10ZXh0XCIpLmRhdGEoJ3BsdXJhbCcpKTtcbiAgICAgIH1cbiAgICAgICQuYWpheCh7XG4gICAgICAgIHVybDogJy9hcGkvbGlrZS91bmxpa2UvJyArIHRoaXMubW9kZWwuYXR0cmlidXRlcy5pZFxuICAgICAgfSkuZG9uZSggZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgLy8gdW4tbGlrZWQhXG4gICAgICAgIC8vIHJlc3BvbnNlIHNob3VsZCBiZSBudWxsIChlbXB0eSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy89IFV0aWxpdHkgTWV0aG9kc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgY2xlYW51cDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMucHJvamVjdFNob3dJdGVtQ29yZU1ldGFWaWV3KSB0aGlzLnByb2plY3RTaG93SXRlbUNvcmVNZXRhVmlldy5jbGVhbnVwKCk7XG4gICAgaWYgKHRoaXMudGFza0xpc3RDb250cm9sbGVyKSB0aGlzLnRhc2tMaXN0Q29udHJvbGxlci5jbGVhbnVwKCk7XG4gICAgaWYgKHRoaXMuZXZlbnRMaXN0Q29udHJvbGxlcikgdGhpcy5ldmVudExpc3RDb250cm9sbGVyLmNsZWFudXAoKTtcbiAgICBpZiAodGhpcy5jb21tZW50TGlzdENvbnRyb2xsZXIpIHRoaXMuY29tbWVudExpc3RDb250cm9sbGVyLmNsZWFudXAoKTtcbiAgICBpZiAodGhpcy5wcm9qZWN0U2hvd0l0ZW1WaWV3KSB0aGlzLnByb2plY3RTaG93SXRlbVZpZXcuY2xlYW51cCgpO1xuICAgIGlmICh0aGlzLnByb2plY3Rvd25lclNob3dWaWV3KSB0aGlzLnByb2plY3Rvd25lclNob3dWaWV3LmNsZWFudXAoKTtcbiAgICBpZiAodGhpcy5hdHRhY2htZW50VmlldykgdGhpcy5hdHRhY2htZW50Vmlldy5jbGVhbnVwKCk7XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9qZWN0LlNob3dDb250cm9sbGVyO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgaWQ9XFxcInByb2plY3QtY29yZW1ldGEtc2hvd1xcXCIgY2xhc3M9XFxcImNvcmVtZXRhLWZvcm0tdG9nZ2xlXFxcIj5cXG5cXG4gICAgPGgxPjwlPSBkYXRhLnRpdGxlICU+PC9oMT5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwicHJvamVjdC1kZXNjcmlwdGlvblxcXCI+XFxuICAgICAgPCU9IGRhdGEuZGVzY3JpcHRpb25IdG1sICU+XFxuICAgIDwvZGl2PlxcblxcblxcbjwvZGl2PiA8IS0tIC9tYWluLXNlY3Rpb24gLS0+XFxuPGRpdiBpZD1cXFwicHJvamVjdC1jb3JlbWV0YS1mb3JtXFxcIiBjbGFzcz1cXFwiY29yZW1ldGEtZm9ybS10b2dnbGUgY29yZW1ldGEtYWRtaW5cXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTEyXFxcIj5cXG4gICAgICA8Zm9ybSByb2xlPVxcXCJmb3JtXFxcIj5cXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImFsZXJ0IGFsZXJ0LXN1Y2Nlc3NcXFwiIGlkPVxcXCJwcm9qZWN0LWNvcmVtZXRhLXN1Y2Nlc3NcXFwiIHN0eWxlPVxcXCJkaXNwbGF5OiBub25lO1xcXCI+XFxuICAgICAgICAgIFlvdXIgPHNwYW4gZGF0YS1pMThuPVxcXCJwcm9qZWN0XFxcIj5wcm9qZWN0PC9zcGFuPiBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgdXBkYXRlZCFcXG4gICAgICAgICAgPGEgY2xhc3M9XFxcImNsb3NlXFxcIiBkYXRhLWRpc21pc3M9XFxcImFsZXJ0XFxcIiBocmVmPVxcXCIjXFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+JnRpbWVzOzwvYT5cXG4gICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgPCEtLSBSSUdIVCBNQUlOIEJBUiAtLT5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICAgICAgICA8aDIgY2xhc3M9XFxcImJveC1wYWQtdFxcXCI+PHNwYW4gZGF0YS1pMThuPVxcXCJQcm9qZWN0XFxcIj5Qcm9qZWN0PC9zcGFuPiBUaXRsZTwvaDI+XFxuICAgICAgICAgIDxpbnB1dCBpZD1cXFwicHJvamVjdC1lZGl0LWZvcm0tdGl0bGVcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2wgaW5wdXQtbGdcXFwiIHZhbHVlPVxcXCI8JT0gZGF0YS50aXRsZSAlPlxcXCIgdHlwZT1cXFwidGV4dFxcXCIgZGF0YS12YWxpZGF0ZT1cXFwiZW1wdHksY291bnQxMDBcXFwiIHRpdGxlPVxcXCJUaXRsZVxcXCIvPlxcbiAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaGVscC1ibG9jayBlcnJvci1lbXB0eVxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPllvdSBtdXN0IGVudGVyIGEgPHNwYW4gZGF0YS1pMThuPVxcXCJwcm9qZWN0XFxcIj5wcm9qZWN0PC9zcGFuPiB0aXRsZS48L3NwYW4+XFxuICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJoZWxwLWJsb2NrIGVycm9yLWNvdW50MTAwXFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI+WW91ciB0aXRsZSBtdXN0IGJlIGxlc3MgdGhhbiAxMDAgY2hhcmFjdGVycy48L3NwYW4+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICAgICAgICA8aDIgY2xhc3M9XFxcImJveC1wYWQtdFxcXCI+PHNwYW4gZGF0YS1pMThuPVxcXCJQcm9qZWN0XFxcIj5Qcm9qZWN0PC9zcGFuPiBEZXNjcmlwdGlvbjwvaDI+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm1hcmtkb3duLWVkaXRcXFwiPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImhlbHAtYmxvY2sgZXJyb3ItZW1wdHlcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIj5Zb3UgbXVzdCBlbnRlciBhIDxzcGFuIGRhdGEtaTE4bj1cXFwicHJvamVjdFxcXCI+cHJvamVjdDwvc3Bhbj4gZGVzY3JpcHRpb24uPC9zcGFuPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9mb3JtPlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTEyIGZvcm0tZ3JvdXBcXFwiPlxcblxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInB1bGwtcmlnaHQgY29yZW1ldGEtYWRtaW5cXFwiIGlkPVxcXCJwcm9qZWN0LWNvcmVtZXRhLWJ1dHRvbnNcXFwiPlxcbiAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidG4gYnRuLWMwXFxcIiBpZD1cXFwiY29yZW1ldGEtdmlld1xcXCI+RGlzY2FyZCBDaGFuZ2VzPC9idXR0b24+XFxuICAgICAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ0biBidG4tYzJcXFwiIGlkPVxcXCJjb3JlbWV0YS1zYXZlXFxcIj5TYXZlIDxzcGFuIGRhdGEtaTE4bj1cXFwiUHJvamVjdFxcXCI+UHJvamVjdDwvc3Bhbj48L2J1dHRvbj5cXG4gICAgICA8L2Rpdj5cXG5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG48L2Rpdj5cXG5cIjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8IS0tIEFMRVJUUyAtLT5cXG48ZGl2IGNsYXNzPVxcXCJhbGVydCBhbGVydC1kYW5nZXJcXFwiIGlkPVxcXCJhbGVydC1jbG9zZWRcXFwiIHN0eWxlPVxcXCI8JSBpZiAoZGF0YS5zdGF0ZSAhPSAnY2xvc2VkJykgeyAlPmRpc3BsYXk6IG5vbmU7PCUgfSAlPlxcXCI+VGhpcyA8c3BhbiBkYXRhLWkxOG49XFxcInByb2plY3RcXFwiPnByb2plY3Q8L3NwYW4+IGlzIDxzdHJvbmc+Y2xvc2VkPC9zdHJvbmc+LiAgSXQgaXMgbm8gbG9uZ2VyIGFjdGl2ZSwgYW5kIG5vIG1vcmUgbW9kaWZpY2F0aW9ucyBtYXkgYmUgbWFkZS48L2Rpdj5cXG5cXG48ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiY29sLXNtLTQgY29sLW1kLTQgY29sLWxnLTQgcHJvamVjdC1zaWRlYmFyIG1kLW5vcGFkZGluZy1yaWdodCBzbS1ub3BhZGRpbmdcXFwiPlxcbiAgICA8IS0tIExFRlQgU0lERUJBUiAtLT5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMTIgYm94IHByb2plY3QtaGVhZGVyLXdyYXBwZXJcXFwiPlxcbiAgICAgICAgPCUgaWYgKGRhdGEuY292ZXJJZCkgeyAlPlxcbiAgICAgICAgPGRpdiBpZD1cXFwicHJvamVjdC1oZWFkZXJcXFwiIHN0eWxlPVxcXCJiYWNrZ3JvdW5kLWltYWdlOnVybCgnL2FwaS9maWxlL2dldC88JT0gZGF0YS5jb3ZlcklkICU+Jyk7XFxcIj5cXG4gICAgICAgIDwlIH0gZWxzZSB7ICU+XFxuICAgICAgICA8ZGl2IGlkPVxcXCJwcm9qZWN0LWhlYWRlclxcXCIgc3R5bGU9XFxcImJhY2tncm91bmQtaW1hZ2U6dXJsKCcvaW1hZ2VzL3Byb2plY3RfZGVmYXVsdC5wbmcnKTtcXFwiPlxcbiAgICAgICAgPCUgfSAlPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJidG4gYnRuLWMyIGZpbGVpbnB1dC1idXR0b25cXFwiIDwlIGlmICghKGRhdGEuaXNPd25lciB8fCB1c2VyLmlzQWRtaW4pIHx8ICFlZGl0KSB7ICU+c3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPCUgfSAlPj5cXG4gICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtY2FtZXJhIGZhLWxnXFxcIiB0aXRsZT1cXFwiQ2hhbmdlIENvdmVyIFBob3RvXFxcIiBpZD1cXFwiZmlsZXVwbG9hZC1pY29uXFxcIj48L2k+XFxuICAgICAgICAgICAgPGlucHV0IGlkPVxcXCJmaWxldXBsb2FkXFxcIiB0eXBlPVxcXCJmaWxlXFxcIiBuYW1lPVxcXCJmaWxlc1tdXFxcIiB0aXRsZT1cXFwiQ2hhbmdlIENvdmVyIFBob3RvXFxcIj5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgaWQ9XFxcImZpbGUtdXBsb2FkLXByb2dyZXNzLWNvbnRhaW5lclxcXCIgc3R5bGU9XFxcImRpc3BsYXk6IG5vbmU7XFxcIiBjbGFzcz1cXFwicHJvZ3Jlc3MgcHJvZ3Jlc3Mtc3RyaXBlZCBhY3RpdmVcXFwiPlxcbiAgICAgICAgICA8ZGl2IGlkPVxcXCJmaWxlLXVwbG9hZC1wcm9ncmVzc1xcXCIgY2xhc3M9XFxcInByb2dyZXNzLWJhclxcXCIgc3R5bGU9XFxcIndpZHRoOiAwXFxcIj48L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiZmlsZS11cGxvYWQtYWxlcnQgYWxlcnQgYWxlcnQtd2FybmluZ1xcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcblxcbiAgPC9kaXY+XFxuXFxuICA8ZGl2IGNsYXNzPVxcXCJjb2wtc20tOCBjb2wtbWQtOCBjb2wtbGctOCBtZC1ub3BhZGRpbmcgc20tbm9wYWRkaW5nXFxcIj5cXG5cXG4gICAgPCEtLSBSSUdIVCBNQUlOIEJBUiAtLT5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtc20tOCBjb2wtbWQtOSBzbS1ub3BhZGRpbmdcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwibWFpbi1zZWN0aW9uXFxcIj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiYm94IGJveC1tYWluXFxcIiBpZD1cXFwicHJvamVjdC1jb3JlbWV0YS13cmFwcGVyXFxcIj5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtc20tNCBjb2wtbWQtMyBwYWRkaW5nLWxlZnQtbm9uZSBzbS1ub3BhZGRpbmdcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiYm94IHBhZGRpbmctbm9uZVxcXCI+XFxuXFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm5hdmJhci1zaWRlIGxpa2Utcm93IGJvcmRlci1ib3R0b21cXFwiPlxcbiAgICAgICAgICAgIDwlIGlmICh1c2VyKSB7ICU+XFxuICAgICAgICAgICAgPGJ1dHRvbiBpZD1cXFwibGlrZS1idXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWxpbmsgbGlrZS1idXR0b25cXFwiIHRpdGxlPVxcXCJDbGljayB0byBMaWtlIG9yIFVubGlrZVxcXCI+XFxuICAgICAgICAgICAgPCUgfSBlbHNlIHsgJT5cXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwibGlrZS1idXR0b25cXFwiPlxcbiAgICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgICAgIDxpIGlkPVxcXCJsaWtlLWJ1dHRvbi1pY29uXFxcIiBjbGFzcz1cXFwiZmEgZmEtc3Rhci1vIGZhLWxnIGdvbGRcXFwiPjwvaT5cXG4gICAgICAgICAgICA8JSBpZiAodXNlcikgeyAlPlxcbiAgICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICAgIDwlIH0gZWxzZSB7ICU+XFxuICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwibGlrZS1udW1iZXJcXFwiIGlkPVxcXCJsaWtlLW51bWJlclxcXCI+PCUtIGRhdGEubGlrZUNvdW50ICU+PC9zcGFuPlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJsaWtlLXBsdXJhbFxcXCIgaWQ9XFxcImxpa2UtdGV4dFxcXCIgZGF0YS1wbHVyYWw9XFxcImxpa2VzXFxcIiBkYXRhLXNpbmd1bGFyPVxcXCJsaWtlXFxcIj5saWtlczwvc3Bhbj5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm5hdmJhci1zaWRlIDwlIGlmIChkYXRhLmlzT3duZXIgfHwgdXNlci5pc0FkbWluKSB7ICU+Ym9yZGVyLWJvdHRvbTwlIH0gJT5cXFwiPlxcbiAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwibmF2IG5hdi1waWxscyBuYXYtc3RhY2tlZFxcXCI+XFxuICAgICAgICAgICAgICA8bGk+XFxuICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGlkPVxcXCJlbWFpbFxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLWVudmVsb3BlLW9cXFwiPjwvaT4gPHNwYW4gY2xhc3M9XFxcImJveC1pY29uLXRleHRcXFwiPlNoYXJlPC9zcGFuPjwvYT5cXG4gICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgICA8bGk+XFxuICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIndlYmNhbDovLzwlLSBob3N0bmFtZSAlPi9hcGkvZXZlbnQvaWNhbC88JS0gZGF0YS5pZCAlPlxcXCI+PHNwYW4gY2xhc3M9XFxcImZhIGZhLWNhbGVuZGFyXFxcIj48L3NwYW4+IDxzcGFuIGNsYXNzPVxcXCJib3gtaWNvbi10ZXh0XFxcIj5DYWxlbmRhcjwvc3Bhbj48L2E+XFxuICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgIDwvdWw+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8JSBpZiAoZGF0YS5pc093bmVyIHx8IHVzZXIuaXNBZG1pbikgeyAlPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJuYXZiYXItc2lkZVxcXCI+XFxuICAgICAgICAgICAgPGRpdiBpZD1cXFwibW9kYWwtY2xvc2VcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwibmF2IG5hdi1waWxscyBuYXYtc3RhY2tlZFxcXCI+XFxuICAgICAgICAgICAgICA8bGk+XFxuICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGlkPVxcXCJlZGl0UHJvamVjdFxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXBlbmNpbFxcXCI+PC9pPiA8c3BhbiBjbGFzcz1cXFwiYm94LWljb24tdGV4dFxcXCI+RWRpdCA8c3BhbiBkYXRhLWkxOG49XFxcIlByb2plY3RcXFwiPlByb2plY3Q8L3NwYW4+PC9zcGFuPjwvYT5cXG4gICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgICA8JSBpZiAoICFlZGl0ICkgeyAlPlxcbiAgICAgICAgICAgICAgPGxpIGlkPVxcXCJsaS1wcm9qZWN0LWNsb3NlXFxcIiBzdHlsZT1cXFwiPCUgaWYgKGRhdGEuc3RhdGUgPT0gJ2Nsb3NlZCcpIHsgJT5kaXNwbGF5OiBub25lOzwlIH0gJT5cXFwiPlxcbiAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCIjXFxcIiBpZD1cXFwicHJvamVjdC1jbG9zZVxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXRpbWVzLWNpcmNsZVxcXCI+PC9pPiA8c3BhbiBjbGFzcz1cXFwiYm94LWljb24tdGV4dFxcXCI+Q2xvc2UgPHNwYW4gZGF0YS1pMThuPVxcXCJQcm9qZWN0XFxcIj5Qcm9qZWN0PC9zcGFuPjwvc3Bhbj48L2E+XFxuICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgPGxpIGlkPVxcXCJsaS1wcm9qZWN0LXJlb3BlblxcXCIgc3R5bGU9XFxcIjwlIGlmIChkYXRhLnN0YXRlICE9ICdjbG9zZWQnKSB7ICU+ZGlzcGxheTogbm9uZTs8JSB9ICU+XFxcIj5cXG4gICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgaWQ9XFxcInByb2plY3QtcmVvcGVuXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtc2hhcmVcXFwiPjwvaT4gPHNwYW4gY2xhc3M9XFxcImJveC1pY29uLXRleHRcXFwiPlJlb3BlbiA8c3BhbiBkYXRhLWkxOG49XFxcIlByb2plY3RcXFwiPlByb2plY3Q8L3NwYW4+PC9zcGFuPjwvYT5cXG4gICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgICA8JSB9ICU+XFxuICAgICAgICAgICAgICA8IS0tXFxuICAgICAgICAgICAgICA8bGk+XFxuICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGlkPVxcXCJwcm9qZWN0LWRlbGV0ZVxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXRyYXNoLW9cXFwiPjwvaT4gPHNwYW4gY2xhc3M9XFxcImJveC1pY29uLXRleHRcXFwiPkRlbGV0ZSA8c3BhbiBkYXRhLWkxOG49XFxcIlByb2plY3RcXFwiPlByb2plY3Q8L3NwYW4+PC9zcGFuPjwvYT5cXG4gICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgICAtLT5cXG4gICAgICAgICAgICA8L3VsPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPCUgfSAlPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcblxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG5cXG4gIDxkaXYgY2xhc3M9XFxcImNvbC1zbS01IGNvbC1tZC00IG1kLW5vcGFkZGluZy1yaWdodCBzbS1ub3BhZGRpbmdcXFwiPlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0xMiBib3hcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiYm94LW1haW4gdGFnLXdyYXBwZXJcXFwiPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8JSBpZiAoIShkYXRhLmlzT3duZXIgfHwgdXNlci5pc0FkbWluKSB8fCAhZWRpdCkgeyAlPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0xMiBib3hcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiYXR0YWNobWVudC13cmFwcGVyXFxcIj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPCUgfSAlPlxcblxcbiAgPC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJjb2wtc20tNyBjb2wtbWQtOCBtZC1ub3BhZGRpbmctcmlnaHQgc20tbm9wYWRkaW5nXFxcIj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMTIgc20tbm9wYWRkaW5nIG1kLW5vcGFkZGluZ1xcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJib3hcXFwiIGlkPVxcXCJwcm9qZWN0b3duZXItd3JhcHBlclxcXCI+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDwlIGlmICghKGRhdGEuaXNPd25lciB8fCB1c2VyLmlzQWRtaW4pIHx8ICFlZGl0KSB7ICU+XFxuICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTEyIHNtLW5vcGFkZGluZyBtZC1ub3BhZGRpbmdcXFwiPlxcbiAgICAgICAgPCEtLSBCRUdJTiBFVkVOVFMgLS0+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJib3hcXFwiIGlkPVxcXCJldmVudC1saXN0LXdyYXBwZXJcXFwiPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8IS0tIEVORCBFVkVOVFMgLS0+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0xMiBzbS1ub3BhZGRpbmcgbWQtbm9wYWRkaW5nXFxcIj5cXG4gICAgICAgIDwhLS0gQkVHSU4gVEFTS1MgLS0+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ3cmFwcGVyLWFkZFRhc2tcXFwiPjwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiYm94XFxcIiBpZD1cXFwidGFzay1saXN0LXdyYXBwZXJcXFwiIGRhdGEtcHJvamVjdC1pZD1cXFwiPCU9IGRhdGEuaWQgJT5cXFwiPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8IS0tIEVORCBUQVNLUyAtLT5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTEyIHNtLW5vcGFkZGluZyBtZC1ub3BhZGRpbmdcXFwiPlxcblxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiYm94IGNvbW1lbnQtbGlzdC13cmFwcGVyXFxcIiBzdHlsZT1cXFwiY2xlYXI6IGJvdGg7XFxcIj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPCUgfSAlPiA8IS0tIGVuZCBvZiBjaGVjayBmb3IgZWRpdCBtb2RlIC0tPlxcblxcbiAgICA8IS0tIGFkZCBhIHNwYWNlIGF0IHRoZSBib3R0b20gb2YgdGhlIHBhZ2UgdW50aWwgd2UgZmlndXJlIG91dCB3aGF0IGdvZXMgaGVyZSAtLT5cXG4gICAgPGRpdiBzdHlsZT1cXFwiaGVpZ2h0OiA1MHB4O1xcXCI+XFxuICAgIDwvZGl2PlxcblxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdj5cXG4gIDxwPlRoaXMgPHNwYW4gZGF0YS1pMThuPVxcXCJwcm9qZWN0XFxcIj5wcm9qZWN0PC9zcGFuPiBoYXMgPHN0cm9uZz48JS0gY291bnQgJT48L3N0cm9uZz4gb3Blbiwgb3IgaW4gcHJvZ3Jlc3MsIG9wcG9ydHVuaXRpZXMuIENsb3NpbmcgdGhpcyA8c3BhbiBkYXRhLWkxOG49XFxcInByb2plY3RcXFwiPnByb2plY3Q8L3NwYW4+IHdpbGwgY2F1c2UgYW55IHN1Y2ggb3Bwb3J0dW5pdGllcyB0byBiZSBvcnBoYW5lZCAobm8gbG9uZ2VyIGFzc29jaWF0ZWQgd2l0aCBhbnkgPHNwYW4gZGF0YS1pMThuPVxcXCJwcm9qZWN0XFxcIj5wcm9qZWN0PC9zcGFuPikuPC9wPlxcblxcbiAgPHA+QXJlIHlvdSBzdXJlIHlvdSB3aXNoIHRvIHByb2NlZWQ/PC9wPlxcblxcbjwvZGl2PlxcblwiO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgYXN5bmMgPSByZXF1aXJlKCdhc3luYycpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL21peGlucy91dGlsaXRpZXMnKTtcbnZhciBtYXJrZWQgPSByZXF1aXJlKCdtYXJrZWQnKTtcbnZhciBNYXJrZG93bkVkaXRvciA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2NvbXBvbmVudHMvbWFya2Rvd25fZWRpdG9yJyk7XG52YXIgUG9wb3ZlcnMgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9taXhpbnMvcG9wb3ZlcnMnKTtcbnZhciBNb2RhbENvbXBvbmVudCA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2NvbXBvbmVudHMvbW9kYWwnKTtcbnZhciBQcm9qZWN0SXRlbUNvcmVNZXRhVGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvcHJvamVjdF9pdGVtX2NvcmVtZXRhX3RlbXBsYXRlLmh0bWwnKTtcblxuXG4vL2lmKF8uaXNVbmRlZmluZWQocG9wb3ZlcnMpKXt2YXIgcG9wb3ZlcnMgPSBuZXcgUG9wb3ZlcnMoKTt9XG5cbnZhciBQcm9qZWN0SXRlbUNvcmVNZXRhVmlldyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcblxuICBlbDogXCIjcHJvamVjdC1jb3JlbWV0YS13cmFwcGVyXCIsXG4gIG1vZGVsIDogbnVsbCxcblxuICAvLyBTZXQgdGhlIG1vZGVsIHRvIG51bGwsIGJlZm9yZSBpdCBpcyBmZXRjaGVkIGZyb20gdGhlIHNlcnZlci5cbiAgLy8gVGhpcyBhbGxvd3MgdXMgdG8gY2xlYXIgb3V0IHRoZSBwcmV2aW91cyBkYXRhIGZyb20gdGhlIGxpc3RfdmlldyxcbiAgLy8gYW5kIGdldCByZWFkeSBmb3IgdGhlIG5ldyBkYXRhIGZvciB0aGUgcHJvamVjdCBzaG93IHZpZXcuXG4gIC8vIG1vZGVsOiBudWxsLFxuXG4gIGV2ZW50czoge1xuICAgIFwiYmx1ciAjcHJvamVjdC1lZGl0LWZvcm0tdGl0bGVcIiAgICAgICAgICAgIDogXCJ2XCIsXG4gICAgXCJibHVyICNwcm9qZWN0LWVkaXQtZm9ybS1kZXNjcmlwdGlvblwiICAgICAgOiBcInZcIixcbiAgICBcImNsaWNrICNjb3JlbWV0YS1zYXZlXCIgICAgICAgICAgICAgICAgICAgICA6IFwic2F2ZUNvcmVNZXRhXCIsXG4gICAgXCJjbGljayAjY29yZW1ldGEtdmlld1wiICAgICAgICAgICAgICAgICAgICAgOiBcInZpZXdQcm9qZWN0XCJcbiAgfSxcblxuICAvLyBUaGUgaW5pdGlhbGl6ZSBtZXRob2QgaXMgbWFpbmx5IHVzZWQgZm9yIGV2ZW50IGJpbmRpbmdzIChmb3IgZWZmZWNpZW5jeSlcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmRhdGEgPSBvcHRpb25zLmRhdGE7XG4gICAgdGhpcy5hY3Rpb24gPSBvcHRpb25zLmFjdGlvbjtcbiAgICB0aGlzLnVzZXIgPSB3aW5kb3cuY2FjaGUuY3VycmVudFVzZXIgfHwge307XG4gICAgdGhpcy5lZGl0ID0gZmFsc2U7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hY3Rpb24pIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWN0aW9uID09ICdlZGl0Jykge1xuICAgICAgICB0aGlzLmVkaXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubW9kZWwub24oXCJwcm9qZWN0OmNvcmVtZXRhOnNob3c6cmVuZGVyZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5pbml0aWFsaXplVGV4dEFyZWEoKTtcbiAgICAgIHNlbGYuaW5pdGlhbGl6ZVRvZ2dsZWRFbGVtZW50cygpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5tb2RlbC5vbihcInByb2plY3Q6c2F2ZTpzdWNjZXNzXCIsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBzZWxmLnJlbmRlcigpO1xuICAgICAgJCgnI3Byb2plY3QtY29yZW1ldGEtc3VjY2VzcycpLnNob3coKTtcbiAgICAgIHNlbGYudmlld1Byb2plY3Qoe30pO1xuICAgIH0pO1xuXG4gICAgdGhpcy5tb2RlbC5vbihcInByb2plY3Q6dGFnczpzYXZlOnN1Y2Nlc3NcIiwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHNlbGYucmVuZGVyKCk7XG4gICAgICAkKCcjcHJvamVjdC1jb3JlbWV0YS1zdWNjZXNzJykuc2hvdygpO1xuICAgICAgc2VsZi52aWV3UHJvamVjdCh7fSk7XG4gICAgfSk7XG5cbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIGRhdGE6IHRoaXMubW9kZWwudG9KU09OKClcbiAgICB9O1xuICAgIC8vIGNvbnZlcnQgZGVzY3JpcHRpb24gdG8gaHRtbCB1c2luZyBtYXJrZG93biBzeW50YXhcbiAgICBkYXRhLmRhdGEuZGVzY3JpcHRpb25IdG1sID0gbWFya2VkKGRhdGEuZGF0YS5kZXNjcmlwdGlvbiB8fCAnJyk7XG4gICAgdmFyIGNvbXBpbGVkVGVtcGxhdGUgPSBfLnRlbXBsYXRlKFByb2plY3RJdGVtQ29yZU1ldGFUZW1wbGF0ZSkoZGF0YSk7XG4gICAgdGhpcy4kZWwuaHRtbChjb21waWxlZFRlbXBsYXRlKTtcbiAgICB0aGlzLiRlbC5pMThuKCk7XG4gICAgdGhpcy5tb2RlbC50cmlnZ2VyKFwicHJvamVjdDpjb3JlbWV0YTpzaG93OnJlbmRlcmVkXCIsIGRhdGEpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZVRleHRBcmVhOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMubWQpIHsgdGhpcy5tZC5jbGVhbnVwKCk7IH1cbiAgICB0aGlzLm1kID0gbmV3IE1hcmtkb3duRWRpdG9yKHtcbiAgICAgIGRhdGE6IHRoaXMubW9kZWwudG9KU09OKCkuZGVzY3JpcHRpb24sXG4gICAgICBlbDogXCIubWFya2Rvd24tZWRpdFwiLFxuICAgICAgaWQ6ICdwcm9qZWN0LWVkaXQtZm9ybS1kZXNjcmlwdGlvbicsXG4gICAgICB0aXRsZTogJ1Byb2plY3QgRGVzY3JpcHRpb24nLFxuICAgICAgcm93czogNixcbiAgICAgIHZhbGlkYXRlOiBbJ2VtcHR5J11cbiAgICB9KS5yZW5kZXIoKTtcbiAgfSxcblxuICBpbml0aWFsaXplVG9nZ2xlZEVsZW1lbnRzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCh0aGlzLm1vZGVsLmF0dHJpYnV0ZXMuaXNPd25lciB8fCB0aGlzLnVzZXIuaXNBZG1pbikgJiYgdGhpcy5lZGl0KXtcbiAgICAgIHNlbGYuJCgnI3Byb2plY3QtY29yZW1ldGEtZm9ybScpLnNob3coKTtcbiAgICAgIHNlbGYuJCgnI3Byb2plY3QtY29yZW1ldGEtc2hvdycpLmhpZGUoKTtcbiAgICB9XG4gICAgZWxzZXtcbiAgICAgIHNlbGYuJCgnLmNvcmVtZXRhLWFkbWluJykuaGlkZSgpO1xuICAgIH1cbiAgfSxcblxuICB2OiBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlKGUpO1xuICB9LFxuXG4gIHNhdmVDb3JlTWV0YTogZnVuY3Rpb24gKGUpe1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKCEodGhpcy5tb2RlbC5hdHRyaWJ1dGVzLmlzT3duZXIgfHwgdGhpcy51c2VyLmlzQWRtaW4pICYmIHRoaXMuZWRpdCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gdmFsaWRhdGUgdGhlIGZvcm0gZmllbGRzXG4gICAgdmFyIHZhbGlkYXRlSWRzID0gWycjcHJvamVjdC1lZGl0LWZvcm0tdGl0bGUnLCAnI3Byb2plY3QtZWRpdC1mb3JtLWRlc2NyaXB0aW9uJ107XG4gICAgdmFyIGFib3J0ID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSBpbiB2YWxpZGF0ZUlkcykge1xuICAgICAgdmFyIGlBYm9ydCA9IHZhbGlkYXRlKHsgY3VycmVudFRhcmdldDogdmFsaWRhdGVJZHNbaV0gfSk7XG4gICAgICBhYm9ydCA9IGFib3J0IHx8IGlBYm9ydDtcbiAgICB9XG4gICAgaWYgKGFib3J0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gcHJvY2VzcyBhbmQgdXBkYXRlIHRoZSBkYXRhIG1vZGVsIGZvciB0aGUgcHJvamVjdFxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcElkID0gc2VsZi5tb2RlbC5hdHRyaWJ1dGVzLmlkO1xuICAgIHZhciB0aXRsZSA9IHNlbGYuJCgnI3Byb2plY3QtZWRpdC1mb3JtLXRpdGxlJykudmFsKCk7XG4gICAgdmFyIGRlc2NyaXB0aW9uID0gc2VsZi4kKCcjcHJvamVjdC1lZGl0LWZvcm0tZGVzY3JpcHRpb24nKS52YWwoKTtcbiAgICB2YXIgcGFyYW1zID0geyB0aXRsZSA6dGl0bGUsIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiB9O1xuXG4gICAgc2VsZi5tb2RlbC50cmlnZ2VyKFwicHJvamVjdDp0YWc6dXBkYXRlOnN0YXJ0XCIpO1xuICAgIHNlbGYubW9kZWwudHJpZ2dlcihcInByb2plY3Q6bW9kZWw6dXBkYXRlXCIsIHBhcmFtcyk7XG4gIH0sXG5cbiAgdmlld1Byb2plY3Q6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBCYWNrYm9uZS5oaXN0b3J5Lm5hdmlnYXRlKCdwcm9qZWN0cy8nICsgdGhpcy5tb2RlbC5hdHRyaWJ1dGVzLmlkLCB7IHRyaWdnZXI6IHRydWUgfSk7XG4gIH0sXG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vPSBVdGlsaXR5IE1ldGhvZHNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGNsZWFudXA6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm1kKSB7IHRoaXMubWQuY2xlYW51cCgpOyB9XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9qZWN0SXRlbUNvcmVNZXRhVmlldztcbiIsInZhciBqcUlmcmFtZSA9IHJlcXVpcmUoJ2JsdWVpbXAtZmlsZS11cGxvYWQvanMvanF1ZXJ5LmlmcmFtZS10cmFuc3BvcnQnKTtcbnZhciBqcUZVID0gcmVxdWlyZSgnYmx1ZWltcC1maWxlLXVwbG9hZC9qcy9qcXVlcnkuZmlsZXVwbG9hZC5qcycpO1xudmFyIHNlbGVjdDIgPSByZXF1aXJlKCdzZWxlY3QyJyk7XG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgYXN5bmMgPSByZXF1aXJlKCdhc3luYycpO1xudmFyIFByb2plY3RTaG93VGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvcHJvamVjdF9pdGVtX3ZpZXdfdGVtcGxhdGUuaHRtbCcpO1xudmFyIFRhZ1Nob3dWaWV3ID0gcmVxdWlyZSgnLi4vLi4vLi4vdGFnL3Nob3cvdmlld3MvdGFnX3Nob3dfdmlldycpO1xudmFyIFRhZ0ZhY3RvcnkgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb21wb25lbnRzL3RhZ19mYWN0b3J5Jyk7XG5cblxudmFyIFByb2plY3RTaG93VmlldyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcblxuICBlbDogXCIjY29udGFpbmVyXCIsXG5cbiAgZXZlbnRzOiB7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuZGF0YSA9IG9wdGlvbnMuZGF0YTtcbiAgICB0aGlzLmFjdGlvbiA9IG9wdGlvbnMuYWN0aW9uO1xuICAgIHRoaXMuZWRpdCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYWN0aW9uKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFjdGlvbiA9PSAnZWRpdCcpIHtcbiAgICAgICAgdGhpcy5lZGl0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy50YWdGYWN0b3J5ID0gbmV3IFRhZ0ZhY3RvcnkoKTtcbiAgICB0aGlzLmRhdGEubmV3SXRlbVRhZ3MgPSBbXTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29tcGlsZWRUZW1wbGF0ZTtcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIGhvc3RuYW1lOiB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUsXG4gICAgICBkYXRhOiB0aGlzLm1vZGVsLnRvSlNPTigpLFxuICAgICAgdXNlcjogd2luZG93LmNhY2hlLmN1cnJlbnRVc2VyIHx8IHt9LFxuICAgICAgZWRpdDogdGhpcy5lZGl0XG4gICAgfTtcblxuICAgIGNvbXBpbGVkVGVtcGxhdGUgPSBfLnRlbXBsYXRlKFByb2plY3RTaG93VGVtcGxhdGUpKGRhdGEpO1xuICAgIHRoaXMuJGVsLmh0bWwoY29tcGlsZWRUZW1wbGF0ZSk7XG4gICAgdGhpcy4kZWwuaTE4bigpO1xuXG4gICAgdGhpcy5pbml0aWFsaXplVG9nZ2xlKCk7XG4gICAgdGhpcy5pbml0aWFsaXplVGFnRmFjdG9yeSgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZUZpbGVVcGxvYWQoKTtcbiAgICB0aGlzLmluaXRpYWxpemVUYWdzKCk7XG4gICAgdGhpcy51cGRhdGVQaG90bygpO1xuICAgIHRoaXMudXBkYXRlUHJvamVjdEVtYWlsKCk7XG4gICAgdGhpcy5tb2RlbC50cmlnZ2VyKFwicHJvamVjdDpzaG93OnJlbmRlcmVkXCIpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgdXBkYXRlUGhvdG86IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsIFwicHJvamVjdDp1cGRhdGVkOnBob3RvOnN1Y2Nlc3NcIiwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHZhciBtb2RlbCA9IGRhdGEudG9KU09OKCksIHVybDtcbiAgICAgIGlmIChtb2RlbC5jb3ZlcklkKSB7XG4gICAgICAgIHVybCA9ICcvYXBpL2ZpbGUvZ2V0LycgKyBtb2RlbC5jb3ZlcklkO1xuICAgICAgICAkKFwiI3Byb2plY3QtaGVhZGVyXCIpLmNzcygnYmFja2dyb3VuZC1pbWFnZScsIFwidXJsKFwiICsgdXJsICsgXCIpXCIpO1xuICAgICAgfVxuICAgICAgJCgnI2ZpbGUtdXBsb2FkLXByb2dyZXNzLWNvbnRhaW5lcicpLmhpZGUoKTtcbiAgICB9KTtcbiAgfSxcblxuICB1cGRhdGVQcm9qZWN0RW1haWw6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAkLmFqYXgoe1xuICAgICAgdXJsOiBlbmNvZGVVUkkoJy9hcGkvZW1haWwvbWFrZVVSTD9lbWFpbD1jb250YWN0VXNlckFib3V0UHJvamVjdCZzdWJqZWN0PUNoZWNrIE91dCBcIicrIHNlbGYubW9kZWwuYXR0cmlidXRlcy50aXRsZSArICdcIicgK1xuICAgICAgJyZwcm9qZWN0VGl0bGU9JyArIHNlbGYubW9kZWwuYXR0cmlidXRlcy50aXRsZSArXG4gICAgICAnJnByb2plY3RMaW5rPScgKyB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyB3aW5kb3cubG9jYXRpb24uaG9zdCArIFwiXCIgKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgK1xuICAgICAgJyZwcm9qZWN0RGVzY3JpcHRpb249JyArIChzZWxmLm1vZGVsLmF0dHJpYnV0ZXMuZGVzY3JpcHRpb24gfHwgJycpKSxcbiAgICAgIHR5cGU6ICdHRVQnXG4gICAgfSkuZG9uZSggZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHNlbGYuJCgnI2VtYWlsJykuYXR0cignaHJlZicsIGRhdGEpO1xuICAgIH0pO1xuXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZVRhZ0ZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMubGlzdGVuVG8oc2VsZi5tb2RlbCwgXCJwcm9qZWN0OnRhZzp1cGRhdGU6c3RhcnRcIiwgZnVuY3Rpb24gKHRhZ3MpIHtcblxuICAgICAgdmFyIG5ld1RhZ3MgPSBbXTtcbiAgICAgIG5ld1RhZ3MgPSBuZXdUYWdzLmNvbmNhdChzZWxmLiQoXCIjdGFnX3RvcGljXCIpLnNlbGVjdDIoJ2RhdGEnKSxzZWxmLiQoXCIjdGFnX3NraWxsXCIpLnNlbGVjdDIoJ2RhdGEnKSxzZWxmLiQoXCIjdGFnX2xvY2F0aW9uXCIpLnNlbGVjdDIoJ2RhdGEnKSxzZWxmLiQoXCIjdGFnX2FnZW5jeVwiKS5zZWxlY3QyKCdkYXRhJykpO1xuXG4gICAgICBhc3luYy5mb3JFYWNoKFxuICAgICAgICBuZXdUYWdzLFxuICAgICAgICBmdW5jdGlvbihuZXdUYWcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYudGFnRmFjdG9yeS5hZGRUYWdFbnRpdGllcyhuZXdUYWcsc2VsZixjYWxsYmFjayk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIGlmIChlcnIpIHJldHVybiBuZXh0KGVycik7XG4gICAgICAgICAgc2VsZi50cmlnZ2VyKFwibmV3VGFnU2F2ZURvbmVcIik7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBzZWxmLm9uKCduZXdUYWdTYXZlRG9uZScsZnVuY3Rpb24gKCl7XG5cbiAgICAgIHRhZ3MgICAgICAgICA9IFtdO1xuICAgICAgdmFyIHRlbXBUYWdzID0gW107XG5cbiAgICAgIC8vZ2V0IG5ld2x5IGNyZWF0ZWQgdGFncyBmcm9tIGJpZyB0aHJlZSB0eXBlc1xuICAgICAgXy5lYWNoKHNlbGYuZGF0YS5uZXdJdGVtVGFncywgZnVuY3Rpb24obmV3SXRlbVRhZyl7XG4gICAgICAgIHRhZ3MucHVzaChuZXdJdGVtVGFnKTtcbiAgICAgIH0pO1xuXG4gICAgICB0ZW1wVGFncy5wdXNoLmFwcGx5KHRlbXBUYWdzLHNlbGYuJChcIiN0YWdfdG9waWNcIikuc2VsZWN0MignZGF0YScpKTtcbiAgICAgIHRlbXBUYWdzLnB1c2guYXBwbHkodGVtcFRhZ3Msc2VsZi4kKFwiI3RhZ19za2lsbFwiKS5zZWxlY3QyKCdkYXRhJykpO1xuICAgICAgdGVtcFRhZ3MucHVzaC5hcHBseSh0ZW1wVGFncyxzZWxmLiQoXCIjdGFnX2xvY2F0aW9uXCIpLnNlbGVjdDIoJ2RhdGEnKSk7XG4gICAgICB0ZW1wVGFncy5wdXNoLmFwcGx5KHRlbXBUYWdzLHNlbGYuJChcIiN0YWdfYWdlbmN5XCIpLnNlbGVjdDIoJ2RhdGEnKSk7XG5cbiAgICAgIC8vc2VlIGlmIHRoZXJlIGFyZSBhbnkgcHJldmlvdXNseSBjcmVhdGVkIGJpZyB0aHJlZSB0YWdzIGFuZCBhZGQgdGhlbSB0byB0aGUgdGFnIGFycmF5XG4gICAgICBfLmVhY2godGVtcFRhZ3MsZnVuY3Rpb24odGVtcFRhZyl7XG4gICAgICAgICAgaWYgKCB0ZW1wVGFnLmlkICE9PSB0ZW1wVGFnLm5hbWUgKXtcbiAgICAgICAgICB0YWdzLnB1c2godGVtcFRhZyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB2YXIgdGFnTWFwID0ge307XG4gICAgICB2YXIgcHJvamVjdElkID0gc2VsZi5tb2RlbC5hdHRyaWJ1dGVzLmlkO1xuXG4gICAgICBhc3luYy5mb3JFYWNoKFxuICAgICAgICB0YWdzLFxuICAgICAgICBmdW5jdGlvbih0YWcsIGNhbGxiYWNrKXtcbiAgICAgICAgICByZXR1cm4gc2VsZi50YWdGYWN0b3J5LmFkZFRhZyh0YWcscHJvamVjdElkLFwicHJvamVjdElkXCIsY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbihlcnIpe1xuICAgICAgICAgIHNlbGYubW9kZWwudHJpZ2dlcihcInByb2plY3Q6dGFnczpzYXZlOnN1Y2Nlc3NcIiwgZXJyKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSxcblxuICBpbml0aWFsaXplVG9nZ2xlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYodGhpcy5lZGl0KXtcbiAgICAgIHRoaXMuJCgnI2VkaXRQcm9qZWN0JykuZmluZCgnLmJveC1pY29uLXRleHQnKS5odG1sKCdWaWV3ICcgKyBpMThuLnQoJ1Byb2plY3QnKSk7XG4gICAgfVxuICAgIGVsc2V7XG4gICAgICB0aGlzLiQoJyNlZGl0UHJvamVjdCcpLmZpbmQoJy5ib3gtaWNvbi10ZXh0JykuaHRtbCgnRWRpdCAnICsgaTE4bi50KCdQcm9qZWN0JykpO1xuICAgIH1cbiAgfSxcblxuICBpbml0aWFsaXplVGFnczogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudGFnVmlldyA9IG5ldyBUYWdTaG93Vmlldyh7XG4gICAgICBtb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgIGVsOiAnLnRhZy13cmFwcGVyJyxcbiAgICAgIHRhcmdldDogJ3Byb2plY3QnLFxuICAgICAgdGFyZ2V0SWQ6ICdwcm9qZWN0SWQnLFxuICAgICAgZWRpdDogdGhpcy5lZGl0LFxuICAgICAgdXJsOiAnL2FwaS90YWcvZmluZEFsbEJ5UHJvamVjdElkLydcbiAgICB9KTtcbiAgICB0aGlzLnRhZ1ZpZXcucmVuZGVyKCk7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZUZpbGVVcGxvYWQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAkKCcjZmlsZXVwbG9hZCcpLmZpbGV1cGxvYWQoe1xuICAgICAgICB1cmw6IFwiL2FwaS9maWxlL2NyZWF0ZVwiLFxuICAgICAgICBkYXRhVHlwZTogJ3RleHQnLFxuICAgICAgICBhY2NlcHRGaWxlVHlwZXM6IC8oXFwufFxcLykoZ2lmfGpwZT9nfHBuZykkL2ksXG4gICAgICAgIGZvcm1EYXRhOiB7ICd0eXBlJzogJ2ltYWdlJyB9LFxuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChlLCBkYXRhKSB7XG4gICAgICAgICAgc2VsZi4kKCcjZmlsZS11cGxvYWQtcHJvZ3Jlc3MtY29udGFpbmVyJykuc2hvdygpO1xuICAgICAgICAgIGRhdGEuc3VibWl0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHByb2dyZXNzYWxsOiBmdW5jdGlvbiAoZSwgZGF0YSkge1xuICAgICAgICAgIHZhciBwcm9ncmVzcyA9IHBhcnNlSW50KGRhdGEubG9hZGVkIC8gZGF0YS50b3RhbCAqIDEwMCwgMTApO1xuICAgICAgICAgIHNlbGYuJCgnI2ZpbGUtdXBsb2FkLXByb2dyZXNzJykuY3NzKFxuICAgICAgICAgICAgJ3dpZHRoJyxcbiAgICAgICAgICAgIHByb2dyZXNzICsgJyUnXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgZG9uZTogZnVuY3Rpb24gKGUsIGRhdGEpIHtcbiAgICAgICAgICAvLyBmb3IgSUU4LzkgdGhhdCB1c2UgaWZyYW1lXG4gICAgICAgICAgaWYgKGRhdGEuZGF0YVR5cGUgPT0gJ2lmcmFtZSB0ZXh0Jykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IEpTT04ucGFyc2UoZGF0YS5yZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBmb3IgbW9kZXJuIFhIUiBicm93c2Vyc1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IEpTT04ucGFyc2UoJChkYXRhLnJlc3VsdCkudGV4dCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5tb2RlbC50cmlnZ2VyKFwicHJvamVjdDp1cGRhdGU6cGhvdG9JZFwiLCByZXN1bHRbMF0pO1xuICAgICAgICB9LFxuICAgICAgICBmYWlsOiBmdW5jdGlvbiAoZSwgZGF0YSkge1xuICAgICAgICAgIC8vIG5vdGlmeSB0aGUgdXNlciB0aGF0IHRoZSB1cGxvYWQgZmFpbGVkXG4gICAgICAgICAgdmFyIG1lc3NhZ2UgPSBkYXRhLmVycm9yVGhyb3duO1xuICAgICAgICAgIHNlbGYuJCgnI2ZpbGUtdXBsb2FkLXByb2dyZXNzLWNvbnRhaW5lcicpLmhpZGUoKTtcbiAgICAgICAgICBpZiAoZGF0YS5qcVhIUi5zdGF0dXMgPT0gNDEzKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJUaGUgdXBsb2FkZWQgZmlsZSBleGNlZWRzIHRoZSBtYXhpbXVtIGZpbGUgc2l6ZS5cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi4kKFwiLmZpbGUtdXBsb2FkLWFsZXJ0XCIpLmh0bWwobWVzc2FnZSlcbiAgICAgICAgICBzZWxmLiQoXCIuZmlsZS11cGxvYWQtYWxlcnRcIikuc2hvdygpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgfSxcblxuICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMudGFnVmlldykgeyB0aGlzLnRhZ1ZpZXcuY2xlYW51cCgpOyB9XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfSxcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb2plY3RTaG93VmlldztcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJib3gtcGFkLWxyIGJvcmRlci1ib3R0b21cXFwiPlxcbiAgPGgyPjxzcGFuIGRhdGEtaTE4bj1cXFwiUHJvamVjdE93bmVyUGx1cmFsXFxcIj5Qcm9qZWN0IE93bmVyczwvc3Bhbj5cXG4gICAgPGJ1dHRvbiBpZD1cXFwib3duZXItZWRpdFxcXCIgbmFtZT1cXFwib3duZXItZWRpdFxcXCIgY2xhc3M9XFxcImJ0biBidG4tYzAgYnRuLXNtIGZpbGUtYWRkIG93bmVyLWZvcm0tdG9nZ2xlXFxcIj5BZGQgT3duZXJzPC9idXR0b24+XFxuICAgIDxidXR0b24gaWQ9XFxcIm93bmVyLWNhbmNlbFxcXCIgbmFtZT1cXFwib3duZXItY2FuY2VsXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1jMCBidG4tc20gZmlsZS1hZGQgb3duZXItZm9ybS10b2dnbGVcXFwiPkNhbmNlbDwvYnV0dG9uPlxcbiAgICA8YnV0dG9uIGlkPVxcXCJvd25lci1zYXZlXFxcIiBuYW1lPVxcXCJvd25lci1zYXZlXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1jMiBidG4tc20gZmlsZS1hZGQgb3duZXItZm9ybS10b2dnbGVcXFwiPlN1Ym1pdDwvYnV0dG9uPlxcbiAgPC9oMj5cXG48L2Rpdj5cXG5cXG48ZGl2IGlkPVxcXCJwcm9qZWN0LW93bmVycy1mb3JtXFxcIiBjbGFzcz1cXFwiYm94LXBhZC1sciBib3gtcGFkLXQgb3duZXItZm9ybS10b2dnbGVcXFwiPlxcbiAgPGZvcm0gY2xhc3M9XFxcIlxcXCIgcm9sZT1cXFwiZm9ybVxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICAgIDxpbnB1dCBzdHlsZT1cXFwid2lkdGg6IDEwMCVcXFwiIGlkPVxcXCJvd25lcnNcXFwiIG5hbWU9XFxcIm93bmVyc1xcXCIgdHlwZT1cXFwiaGlkZGVuXFxcIiB2YWx1ZT1cXFwiQWRkIE93bmVyXFxcIi8+XFxuICAgIDwvZGl2PlxcbiAgPC9mb3JtPlxcbjwvZGl2PlxcblxcbjxkaXYgaWQ9XFxcInByb2plY3Qtb3duZXJzLXNob3dcXFwiIGNsYXNzPVxcXCJib3gtcGFkLWxyIGJveC1wYWQtdCBvd25lci1mb3JtLXRvZ2dsZVxcXCI+XFxuICA8JSBpZiAoZGF0YS5vd25lcnMpIHsgJT5cXG4gICAgPCUgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLm93bmVycy5sZW5ndGg7IGkrKykgeyAlPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJwcm9qZWN0LXBlb3BsZS1kaXZcXFwiIGRhdGEtdXNlcmlkPVxcXCI8JT0gZGF0YS5vd25lcnNbaV0udXNlcklkICU+XFxcIj5cXG4gICAgICA8aW1nIHNyYz1cXFwiL2FwaS91c2VyL3Bob3RvLzwlPSBkYXRhLm93bmVyc1tpXS51c2VySWQgJT5cXFwiIGNsYXNzPVxcXCJwcm9qZWN0LXBlb3BsZVxcXCIgYWx0PVxcXCI8JT0gZGF0YS5vd25lcnNbaV0ubmFtZSAlPlxcXCIvPlxcbiAgICAgIDwlIGlmICgoZGF0YS5pc093bmVyIHx8IHVzZXIuaXNBZG1pbikgJiYgKGRhdGEub3duZXJzW2ldLnVzZXJJZCAhPSBjYWNoZS5jdXJyZW50VXNlci5pZCkgJiYgZGF0YS5lZGl0KSB7ICU+XFxuICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgY2xhc3M9XFxcImRlbGV0ZS1wcm9qZWN0b3duZXIgcHJvamVjdC1vd25lci1kZWxldGUgZmEgZmEtdGltZXNcXFwiICBpZD1cXFwiZGVsZXRlLXByb2plY3Rvd25lci08JT0gZGF0YS5vd25lcnNbaV0uaWQgJT5cXFwiIGRhdGEtdWlkPVxcXCI8JT0gZGF0YS5vd25lcnNbaV0udXNlcklkICU+XFxcIiBkYXRhLXBvaWQ9XFxcIjwlPSBkYXRhLm93bmVyc1tpXS5pZCAlPlxcXCI+XFxuICAgICAgPC9hPlxcbiAgICAgIDwlIH0gJT5cXG4gICAgPC9kaXY+XFxuICAgIDwlIH0gJT5cXG4gIDwlIH0gJT5cXG48L2Rpdj5cXG5cIjtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL21peGlucy91dGlsaXRpZXMnKTtcbnZhciBhc3luYyA9IHJlcXVpcmUoJ2FzeW5jJyk7XG52YXIgUG9wb3ZlcnMgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9taXhpbnMvcG9wb3ZlcnMnKTtcbnZhciBNb2RhbENvbXBvbmVudCA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2NvbXBvbmVudHMvbW9kYWwnKTtcbnZhciBQcm9qZWN0b3duZXJTaG93VGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvcHJvamVjdG93bmVyX3Nob3dfdGVtcGxhdGUuaHRtbCcpO1xuXG5cbnZhciBQcm9qZWN0b3duZXJTaG93VmlldyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcblxuICBlbDogXCIjcHJvamVjdG93bmVyLXdyYXBwZXJcIixcbiAgbW9kZWwgOiBudWxsLFxuXG4gIC8vIFNldCB0aGUgbW9kZWwgdG8gbnVsbCwgYmVmb3JlIGl0IGlzIGZldGNoZWQgZnJvbSB0aGUgc2VydmVyLlxuICAvLyBUaGlzIGFsbG93cyB1cyB0byBjbGVhciBvdXQgdGhlIHByZXZpb3VzIGRhdGEgZnJvbSB0aGUgbGlzdF92aWV3LFxuICAvLyBhbmQgZ2V0IHJlYWR5IGZvciB0aGUgbmV3IGRhdGEgZm9yIHRoZSBwcm9qZWN0IHNob3cgdmlldy5cbiAgLy8gbW9kZWw6IG51bGwsXG5cbiAgZXZlbnRzOiB7XG4gICAgXCJjbGljayBidXR0b24ub3duZXItZm9ybS10b2dnbGVcIiAgICAgIDogXCJ0b2dnbGVPd25lcnNcIixcbiAgICBcImNsaWNrICNvd25lci1zYXZlXCIgICAgICAgICAgICAgICAgICAgOiBcInNhdmVPd25lcnNcIixcbiAgICBcImNsaWNrICNvd25lci1jYW5jZWxcIiAgICAgICAgICAgICAgICAgOiBcImluaXRpYWxpemVPd25lclNlbGVjdDJcIixcbiAgICBcImNsaWNrIC5kZWxldGUtcHJvamVjdG93bmVyXCIgICAgICAgICAgOiBcInJlbW92ZU93bmVyXCJcbiAgfSxcblxuICAvLyBUaGUgaW5pdGlhbGl6ZSBtZXRob2QgaXMgbWFpbmx5IHVzZWQgZm9yIGV2ZW50IGJpbmRpbmdzIChmb3IgZWZmZWNpZW5jeSlcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmRhdGEgPSBvcHRpb25zLmRhdGE7XG4gICAgdGhpcy5hY3Rpb24gPSBvcHRpb25zLmFjdGlvbjtcbiAgICB0aGlzLnVzZXIgPSB3aW5kb3cuY2FjaGUuY3VycmVudFVzZXIgfHwge307XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hY3Rpb24pIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWN0aW9uID09ICdlZGl0Jykge1xuICAgICAgICB0aGlzLmVkaXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubW9kZWwub24oXCJwcm9qZWN0b3duZXI6c2hvdzpyZW5kZXJlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLmluaXRpYWxpemVPd25lclNlbGVjdDIoKTtcbiAgICB9KTtcbiAgICAvL3doZW4gb3duZXIgc2V0IGlzIHVwZGF0ZWQsIHJlLXJlbmRlciBhbmQgcmUtaW5pdCBwb3BvdmVyc1xuICAgIHRoaXMubW9kZWwub24oXCJwcm9qZWN0OnVwZGF0ZTpvd25lcnM6c3VjY2Vzc1wiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgc2VsZi5yZW5kZXIoKTtcbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHBvcG92ZXJzKSkge1xuICAgICAgICB2YXIgcG9wb3ZlcnMgPSBuZXcgUG9wb3ZlcnMoKTtcbiAgICAgICAgcG9wb3ZlcnMucG9wb3ZlclBlb3BsZUluaXQoXCIucHJvamVjdC1wZW9wbGUtZGl2XCIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbXBpbGVkVGVtcGxhdGU7XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBkYXRhOiB0aGlzLm1vZGVsLnRvSlNPTigpLFxuICAgICAgdXNlcjogdGhpcy51c2VyXG4gICAgfTtcbiAgICBkYXRhLmRhdGEuZWRpdCA9IHRoaXMuZWRpdDtcbiAgICBjb21waWxlZFRlbXBsYXRlID0gXy50ZW1wbGF0ZShQcm9qZWN0b3duZXJTaG93VGVtcGxhdGUpKGRhdGEpO1xuICAgIHRoaXMuJGVsLmh0bWwoY29tcGlsZWRUZW1wbGF0ZSk7XG4gICAgdGhpcy4kZWwuaTE4bigpO1xuXG4gICAgdGhpcy5tb2RlbC50cmlnZ2VyKFwicHJvamVjdG93bmVyOnNob3c6cmVuZGVyZWRcIiwgZGF0YSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZU93bmVyU2VsZWN0MjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoKHRoaXMubW9kZWwuYXR0cmlidXRlcy5pc093bmVyIHx8IHRoaXMudXNlci5pc0FkbWluKSAmJiB0aGlzLmVkaXQpe1xuICAgICAgdmFyIGZvcm1hdFJlc3VsdCA9IGZ1bmN0aW9uIChvYmplY3QsIGNvbnRhaW5lciwgcXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdC5uYW1lO1xuICAgICAgfTtcbiAgICAgIHZhciBvbGRPd25lcnMgPSB0aGlzLm1vZGVsLmF0dHJpYnV0ZXMub3duZXJzIHx8IFtdO1xuICAgICAgdmFyIG9sZE93bmVySWRzID0gXy5tYXAob2xkT3duZXJzLCBmdW5jdGlvbihvd25lcil7IHJldHVybiBvd25lci51c2VySWQgfSkgfHwgW107XG5cbiAgICAgIHNlbGYuJChcIiNvd25lcnNcIikuc2VsZWN0Mih7XG4gICAgICAgIHBsYWNlaG9sZGVyOiAnQWRkICcgKyBpMThuLnQoJ1Byb2plY3QnKSArICcgT3duZXJzJyxcbiAgICAgICAgbXVsdGlwbGU6IHRydWUsXG4gICAgICAgIGZvcm1hdFJlc3VsdDogZm9ybWF0UmVzdWx0LFxuICAgICAgICBmb3JtYXRTZWxlY3Rpb246IGZvcm1hdFJlc3VsdCxcbiAgICAgICAgbWluaW11bUlucHV0TGVuZ3RoOiAxLFxuICAgICAgICBhamF4OiB7XG4gICAgICAgICAgICB1cmw6ICcvYXBpL2FjL3VzZXInLFxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgICAgIGRhdGE6IGZ1bmN0aW9uICh0ZXJtKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcTogdGVybVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc3VsdHM6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdHM6IF8uZmlsdGVyKGRhdGEsIGZ1bmN0aW9uKHVzZXIpeyAgcmV0dXJuIF8uaW5kZXhPZiggb2xkT3duZXJJZHMsIHVzZXIuaWQpID49IDAgPyBmYWxzZSA6IHRydWU7IH0sIHNlbGYgKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHNlbGYuJCgnI293bmVyLWVkaXQnKS5zaG93KCk7XG5cbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgIHNlbGYuJCgnI293bmVyLWVkaXQnKS5oaWRlKCk7XG4gICAgfVxuXG4gICAgc2VsZi4kKCcjcHJvamVjdC1vd25lcnMtZm9ybScpLmhpZGUoKTtcbiAgICBzZWxmLiQoJyNwcm9qZWN0LW93bmVycy1zaG93Jykuc2hvdygpO1xuICAgIHNlbGYuJCgnI293bmVyLXNhdmUnKS5oaWRlKCk7XG4gICAgc2VsZi4kKCcjb3duZXItY2FuY2VsJykuaGlkZSgpO1xuXG4gIH0sXG5cbiAgdG9nZ2xlT3duZXJzIDogZnVuY3Rpb24oZSl7XG4gICAgaWYgKCEodGhpcy5tb2RlbC5hdHRyaWJ1dGVzLmlzT3duZXIgfHwgdGhpcy51c2VyLmlzQWRtaW4pICYmIHRoaXMuZWRpdCkgcmV0dXJuIGZhbHNlO1xuICAgICQoJy5vd25lci1mb3JtLXRvZ2dsZScpLnRvZ2dsZSg0MDApO1xuICB9LFxuXG4gIHNhdmVPd25lcnMgOiBmdW5jdGlvbihlKXtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICghKHRoaXMubW9kZWwuYXR0cmlidXRlcy5pc093bmVyIHx8IHRoaXMudXNlci5pc0FkbWluKSAmJiB0aGlzLmVkaXQpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgcElkID0gc2VsZi5tb2RlbC5hdHRyaWJ1dGVzLmlkO1xuXG4gICAgdmFyIG9sZE93bmVycyA9IHRoaXMubW9kZWwuYXR0cmlidXRlcy5vd25lcnMgfHwgW107XG4gICAgdmFyIHMyZGF0YSA9ICQoXCIjb3duZXJzXCIpLnNlbGVjdDIoXCJkYXRhXCIpICB8fCBbXTtcbiAgICB2YXIgczJPd25lcklkcyA9IF8ubWFwKHMyZGF0YSwgZnVuY3Rpb24ob3duZXIpeyByZXR1cm4gb3duZXIuaWQgfSkgfHwgW107XG5cbiAgICBhc3luYy5lYWNoKHMyT3duZXJJZHMsIGNyZWF0ZU93bmVyLCBmdW5jdGlvbigpeyBzZWxmLm1vZGVsLnRyaWdnZXIoXCJwcm9qZWN0b3duZXI6c2hvdzpjaGFuZ2VkXCIsIG9sZE93bmVycyk7IH0pO1xuXG4gICAgJChcIiNvd25lcnNcIikuc2VsZWN0MihcImRhdGFcIiwgW10pO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlT3duZXIob3duZXJJRCwgZG9uZSl7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAkLmFqYXgoe1xuICAgICAgICAgIHVybDogJy9hcGkvcHJvamVjdG93bmVyLycsXG4gICAgICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHByb2plY3RJZDogcElkLFxuICAgICAgICAgICAgdXNlcklkOiBvd25lcklEXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdWNjZXNzIDogZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICB2YXIgUE9JZCA9IGRhdGEuaWQ7XG4gICAgICAgICAgICBvbGRPd25lcnMucHVzaCh7IGlkOlBPSWQsIHVzZXJJZDogb3duZXJJRH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICB9KS5kb25lKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gIH0sXG5cbiAgcmVtb3ZlT3duZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoZS5zdG9wUHJvcGFnYXRpb24oKSkgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICQoZS5jdXJyZW50VGFyZ2V0KS5vZmYoXCJtb3VzZWVudGVyXCIpO1xuICAgICQoJy5wb3BvdmVyJykucmVtb3ZlKCk7XG5cbiAgICB2YXIgcE9JZCA9ICQoZS5jdXJyZW50VGFyZ2V0KS5kYXRhKCdwb2lkJyk7XG4gICAgdmFyIHVJZCA9ICQoZS5jdXJyZW50VGFyZ2V0KS5kYXRhKCd1aWQnKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAodHlwZW9mIGNhY2hlICE9PSBcInVuZGVmaW5lZFwiICYmIHVJZCAhPT0gY2FjaGUuY3VycmVudFVzZXIuaWQpXG4gICAge1xuICAgICAgJC5hamF4KHtcbiAgICAgICAgdXJsOiAnL2FwaS9wcm9qZWN0b3duZXIvJyArIHBPSWQsXG4gICAgICAgIHR5cGU6ICdERUxFVEUnLFxuICAgICAgfSkuZG9uZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIC8vIGRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBvbGRPd25lcnMgPSB0aGlzLm1vZGVsLmF0dHJpYnV0ZXMub3duZXJzIHx8IFtdO1xuICAgIHZhciB1bmNoYW5nZWRPd25lcnMgPSBfLmZpbHRlcihvbGRPd25lcnMsIGZ1bmN0aW9uKG93bmVyKXsgcmV0dXJuICggb3duZXIuaWQgIT09IHBPSWQgKTsgfSAsIHRoaXMpICB8fCBbXTtcbiAgICBzZWxmLm1vZGVsLnRyaWdnZXIoXCJwcm9qZWN0b3duZXI6c2hvdzpjaGFuZ2VkXCIsIHVuY2hhbmdlZE93bmVycyk7XG4gIH0sXG5cblxuXG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vPSBVdGlsaXR5IE1ldGhvZHNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGNsZWFudXA6IGZ1bmN0aW9uKCkge1xuICAgIHJlbW92ZVZpZXcodGhpcyk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvamVjdG93bmVyU2hvd1ZpZXc7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGZvcm0gcm9sZT1cXFwiZm9ybVxcXCIgYWN0aW9uPVxcXCJcXFwiIGlkPVxcXCJ0YWctZm9ybVxcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1ib2R5XFxcIj5cXG4gICAgPGZpZWxkc2V0PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwidGFnLWZvcm0tdHlwZVxcXCI+VGFnIFR5cGU8L2xhYmVsPlxcbiAgICAgICAgPHNlbGVjdCBpZD1cXFwidGFnLWZvcm0tdHlwZVxcXCIgbmFtZT1cXFwidGFnLWZvcm0tdHlwZVxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCI+XFxuICAgICAgICAgIDwlIGZvciAodmFyIGkgPSAwOyBpIDwgdGFncy5sZW5ndGg7IGkrKykgeyAlPlxcbiAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCI8JS0gdGFnc1tpXS50eXBlICU+XFxcIj48JS0gdGFnc1tpXS5uYW1lICU+PC9vcHRpb24+XFxuICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgIDwvc2VsZWN0PlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwidGFnLWZvcm0tbmFtZVxcXCI+XFxuICAgICAgICAgIFRhZyBOYW1lXFxuICAgICAgICA8L2xhYmVsPlxcbiAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIGlkPVxcXCJ0YWctZm9ybS1uYW1lXFxcIiBuYW1lPVxcXCJ0YWctZm9ybS1uYW1lXFxcIiBwbGFjZWhvbGRlcj1cXFwiVGFnIE5hbWVcXFwiIGRhdGEtdmFsaWRhdGU9XFxcImVtcHR5LGNvdW50MTAwXFxcIi8+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaGVscC1ibG9jayBlcnJvci1lbXB0eVxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPllvdSBtdXN0IGVudGVyIGEgdGFnIG5hbWUuPC9zcGFuPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcImhlbHAtYmxvY2sgZXJyb3ItY291bnQxMDBcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIj5UYWdzIG11c3QgYmUgbGVzcyB0aGFuIDEwMCBjaGFyYWN0ZXJzIGluIGxlbmd0aC48L3NwYW4+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZmllbGRzZXQ+XFxuICA8L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWZvb3RlclxcXCI+XFxuICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1jMFxcXCIgZGF0YS1kaXNtaXNzPVxcXCJtb2RhbFxcXCI+Q2FuY2VsPC9idXR0b24+XFxuICAgIDxpbnB1dCB0eXBlPVxcXCJzdWJtaXRcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWMyXFxcIiBpZD1cXFwic3VibWl0XFxcIiB2YWx1ZT1cXFwiQ3JlYXRlIFRhZ1xcXCIvPlxcbiAgPC9kaXY+XFxuPC9mb3JtPlxcblwiO1xuIiwiXG52YXIgQm9vdHN0cmFwID0gcmVxdWlyZSgnYm9vdHN0cmFwJyk7XG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgVGFnRm9ybVRlbXBsYXRlID0gcmVxdWlyZSgnLi4vdGVtcGxhdGVzL3RhZ19uZXdfZm9ybV90ZW1wbGF0ZS5odG1sJyk7XG5cblxudmFyIFRhZ0Zvcm1WaWV3ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuXG4gIGV2ZW50czoge1xuICAgIFwiYmx1ciAjdGFnLWZvcm0tbmFtZVwiIDogXCJ2XCIsXG4gICAgXCJzdWJtaXQgI3RhZy1mb3JtXCIgICAgOiBcInBvc3RcIlxuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy50YWdzID0gb3B0aW9ucy50YWdzO1xuICAgIHRoaXMudGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQ7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIHRhZ3M6IHRoaXMudGFnc1xuICAgIH07XG4gICAgdmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZShUYWdGb3JtVGVtcGxhdGUpKGRhdGEpO1xuICAgIHRoaXMuJGVsLmh0bWwodGVtcGxhdGUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHY6IGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlKGUpO1xuICB9LFxuXG4gIHBvc3Q6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIC8vIHBlcmZvcm0gZmllbGQgdmFsaWRhdGlvblxuICAgIHZhciB2YWxpZGF0ZUlkcyA9IFsnI3RhZy1mb3JtLW5hbWUnXTtcbiAgICB2YXIgYWJvcnQgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpIGluIHZhbGlkYXRlSWRzKSB7XG4gICAgICB2YXIgaUFib3J0ID0gdmFsaWRhdGUoeyBjdXJyZW50VGFyZ2V0OiB2YWxpZGF0ZUlkc1tpXSB9KTtcbiAgICAgIGFib3J0ID0gYWJvcnQgfHwgaUFib3J0O1xuICAgIH1cbiAgICBpZiAoYWJvcnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBhc3NlbWJsZSBmb3JtIGFuZCBzdWJtaXRcbiAgICB2YXIgZGF0YTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBkYXRhID0ge1xuICAgICAgdHlwZTogJChlLmN1cnJlbnRUYXJnZXQpLmZpbmQoXCIjdGFnLWZvcm0tdHlwZVwiKS52YWwoKSxcbiAgICAgIG5hbWU6ICQoZS5jdXJyZW50VGFyZ2V0KS5maW5kKFwiI3RhZy1mb3JtLW5hbWVcIikudmFsKClcbiAgICB9XG5cbiAgICAkLmFqYXgoe1xuICAgICAgdXJsOiAnL2FwaS90YWcvYWRkJyxcbiAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KS5kb25lKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgIC8vIFBhc3MgdGhlIHRhZyBiYWNrXG4gICAgICBzZWxmLm9wdGlvbnMubW9kZWwudHJpZ2dlcihzZWxmLnRhcmdldCArIFwiOnRhZzpuZXdcIiwgcmVzdWx0KTtcbiAgICB9KTtcblxuICB9LFxuXG4gIGNsZWFudXA6IGZ1bmN0aW9uICgpIHtcbiAgICByZW1vdmVWaWV3KHRoaXMpO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRhZ0Zvcm1WaWV3O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxsaT48JS0gdGFnLnRhZy5uYW1lICU+XFxuPCUgaWYgKChkYXRhLmlzT3duZXIgfHwgdXNlci5pc0FkbWluKSAmJiBlZGl0KSB7ICU+XFxuPHNwYW4gY2xhc3M9XFxcInRhZy1kZWxldGUgZmEgZmEtdGltZXNcXFwiIGRhdGEtaWQ9XFxcIjwlLSB0YWcuaWQgJT5cXFwiPjwvc3Bhbj5cXG48JSB9ICU+XFxuPC9saT5cXG5cIjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8JSBmb3IgKHZhciBpID0gMDsgaSA8IHRhZ3MubGVuZ3RoOyBpKyspIHsgJT5cXG48ZGl2IGNsYXNzPVxcXCJ0YWctdGl0bGUgPCUtIHRhZ3NbaV1bJ2NsYXNzJ10gJT5cXFwiIGlkPVxcXCI8JS0gdGFnc1tpXS5pZCAlPlxcXCI+XFxuICA8aDI+PGkgY2xhc3M9XFxcIjwlLSB0YWdzW2ldLmljb24gJT5cXFwiPjwvaT4gPHNwYW4gY2xhc3M9XFxcImJveC1pY29uLXRleHRcXFwiPjwlLSB0YWdzW2ldLnBsdXJhbCAlPjwvc3Bhbj48L2gyPlxcbiAgPCUgaWYgKChkYXRhLmlzT3duZXIgfHwgdXNlci5pc0FkbWluKSAmJiBlZGl0KSB7ICU+XFxuICA8ZGl2IHN0eWxlPSdtYXJnaW4tYm90dG9tOiA1cHgnPlxcbiAgICA8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgaWQ9XFxcInRhZ188JS0gdGFnc1tpXS5pZC50b0xvd2VyQ2FzZSgpICU+XFxcIiBjbGFzcz1cXFwiZnVsbHdpZHRoXFxcIiBuYW1lPVxcXCJ0YWdfPCUtIHRhZ3NbaV0ubmFtZS50b0xvd2VyQ2FzZSgpICU+XFxcIi8+XFxuICA8L2Rpdj5cXG4gIDwlIH0gJT5cXG4gIDx1bCBjbGFzcz1cXFwidGFnc1xcXCI+XFxuICAgIDxsaSBjbGFzcz1cXFwidGFnLWVtcHR5XFxcIiBpZD1cXFwiPCUtIHRhZ3NbaV1bJ2NsYXNzJ10gJT4tZW1wdHlcXFwiPlxcbiAgICAgIDwlIGlmICh0YWdzW2ldWydjbGFzcyddID09PSAnbG9jYXRpb24nKSB7ICU+QW55d2hlcmU8JSB9IGVsc2UgeyAlPk5vbmU8JSB9ICU+XFxuICAgIDwvbGk+XFxuICA8L3VsPlxcbjwvZGl2PlxcbjwlIH0gJT5cXG48JSBpZiAoZGF0YS51c2VySWQpIHtcXG4lPlxcbjxkaXYgY2xhc3M9XFxcInRhZy10aXRsZVxcXCI+XFxuICA8aDI+PGkgY2xhc3M9XFxcImZhIGZhLWNoaWxkIFxcXCI+PC9pPiA8c3BhbiBjbGFzcz1cXFwiYm94LWljb24tdGV4dFxcXCI+UHJvZ3Jlc3M8L3NwYW4+PC9oMj5cXG4gIDx1bCBjbGFzcz1cXFwidGFnc1xcXCI+XFxuICAgIDxsaSBjbGFzcz1cXFwidGFnLWVtcHR5XFxcIiBpZD1cXFwidGFzay1sZW5ndGgtZW1wdHlcXFwiIHN0eWxlPVxcXCJkaXNwbGF5OiBub25lO1xcXCI+Tm9uZTwvbGk+XFxuICAgIDxsaT5QdWJsaXNoZWQ6IDwlLSBkYXRhLnB1Ymxpc2hlZEF0ID8gbW9tZW50KGRhdGEucHVibGlzaGVkQXQpLmZvcm1hdCgnZGRkLCBNTU0gRCwgWVlZWScpIDogJy0tJyAlPjwvbGk+PGJyPlxcbiAgICA8bGk+QXNzaWduZWQ6IDwlLSBkYXRhLmFzc2lnbmVkQXQgPyBtb21lbnQoZGF0YS5hc3NpZ25lZEF0KS5mb3JtYXQoJ2RkZCwgTU1NIEQsIFlZWVknKSA6ICctLScgJT48L2xpPjxicj5cXG4gICAgPGxpPkNvbXBsZXRlZDogPCUtIGRhdGEuY29tcGxldGVkQXQgPyBtb21lbnQoZGF0YS5jb21wbGV0ZWRBdCkuZm9ybWF0KCdkZGQsIE1NTSBELCBZWVlZJykgOiAnLS0nICU+PC9saT5cXG4gIDwvdWw+XFxuPC9kaXY+XFxuPCUgfSAlPlxcblwiO1xuIiwiXG52YXIgQm9vdHN0cmFwID0gcmVxdWlyZSgnYm9vdHN0cmFwJyk7XG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgYXN5bmMgPSByZXF1aXJlKCdhc3luYycpO1xudmFyIE1vZGFsQ29tcG9uZW50ID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29tcG9uZW50cy9tb2RhbCcpO1xudmFyIFRhZ0NvbmZpZyA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2NvbmZpZy90YWcnKTtcbnZhciBUYWdGb3JtVmlldyA9IHJlcXVpcmUoJy4uLy4uL25ldy92aWV3cy90YWdfbmV3X2Zvcm1fdmlldycpO1xudmFyIFRhZ1RlbXBsYXRlID0gcmVxdWlyZSgnLi4vdGVtcGxhdGVzL3RhZ19pdGVtX3RlbXBsYXRlLmh0bWwnKTtcbnZhciBUYWdTaG93VGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvdGFnX3Nob3dfdGVtcGxhdGUuaHRtbCcpO1xudmFyIFRhZ0ZhY3RvcnkgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb21wb25lbnRzL3RhZ19mYWN0b3J5Jyk7XG5cblxudmFyIFRhZ1Nob3dWaWV3ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuXG4gIGV2ZW50czoge1xuICAgIFwiY2xpY2sgI3RhZy1jcmVhdGVcIiAgICAgOiBcImNyZWF0ZVRhZ1wiLFxuICAgIFwiY2xpY2sgI3RhZy1zYXZlXCIgICAgICAgOiBcInNhdmVUYWdcIixcbiAgICBcImNsaWNrIC50YWctZGVsZXRlXCIgICAgIDogXCJkZWxldGVUYWdcIlxuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLm1vZGVsID0gb3B0aW9ucy5tb2RlbDtcbiAgICB0aGlzLnRhcmdldCA9IG9wdGlvbnMudGFyZ2V0O1xuICAgIHRoaXMudGFyZ2V0SWQgPSBvcHRpb25zLnRhcmdldElkO1xuICAgIHRoaXMuZWRpdCA9IG9wdGlvbnMuZWRpdDtcbiAgICB0aGlzLnRhZ0ZhY3RvcnkgPSBuZXcgVGFnRmFjdG9yeSgpO1xuICAgIHRoaXMudGFncyA9IFtdO1xuICAgIC8vIEZpZ3VyZSBvdXQgd2hpY2ggdGFncyBhcHBseVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgVGFnQ29uZmlnW3RoaXMudGFyZ2V0XS5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy50YWdzLnB1c2goVGFnQ29uZmlnLnRhZ3NbVGFnQ29uZmlnW3RoaXMudGFyZ2V0XVtpXV0pO1xuICAgIH1cbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIGRhdGE6IHRoaXMubW9kZWwudG9KU09OKCksXG4gICAgICB0YWdzOiB0aGlzLnRhZ3MsXG4gICAgICBlZGl0OiB0aGlzLmVkaXQsXG4gICAgICB1c2VyOiB3aW5kb3cuY2FjaGUuY3VycmVudFVzZXIgfHwge31cbiAgICB9O1xuICAgIHZhciB0ZW1wbGF0ZSA9IF8udGVtcGxhdGUoVGFnU2hvd1RlbXBsYXRlKShkYXRhKTtcbiAgICB0aGlzLiRlbC5odG1sKHRlbXBsYXRlKTtcbiAgICB0aGlzLmluaXRpYWxpemVTZWxlY3QyKCk7XG4gICAgdGhpcy5pbml0aWFsaXplVGFncygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGluaXRpYWxpemVTZWxlY3QyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgc2VsZi50YWdGYWN0b3J5LmNyZWF0ZVRhZ0Ryb3BEb3duKHtcbiAgICAgIHR5cGU6XCJza2lsbFwiLHNlbGVjdG9yOlwiI3RhZ19za2lsbFwiLHdpZHRoOiBcIjEwMCVcIix0b2tlblNlcGFyYXRvcnM6IFtcIixcIl1cbiAgICB9KTtcblxuICAgIHNlbGYudGFnRmFjdG9yeS5jcmVhdGVUYWdEcm9wRG93bih7XG4gICAgICB0eXBlOlwidG9waWNcIixzZWxlY3RvcjpcIiN0YWdfdG9waWNcIix3aWR0aDogXCIxMDAlXCIsdG9rZW5TZXBhcmF0b3JzOiBbXCIsXCJdXG4gICAgfSk7XG5cbiAgICBzZWxmLnRhZ0ZhY3RvcnkuY3JlYXRlVGFnRHJvcERvd24oe3R5cGU6XCJsb2NhdGlvblwiLHNlbGVjdG9yOlwiI3RhZ19sb2NhdGlvblwiLHdpZHRoOiBcIjEwMCVcIn0pO1xuICAgIHNlbGYudGFnRmFjdG9yeS5jcmVhdGVUYWdEcm9wRG93bih7dHlwZTpcImFnZW5jeVwiLHNlbGVjdG9yOlwiI3RhZ19hZ2VuY3lcIix3aWR0aDogXCIxMDAlXCJ9KTtcbiAgICBzZWxmLm1vZGVsLnRyaWdnZXIoXCJwcm9maWxlOmlucHV0OmNoYW5nZWRcIik7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZVRhZ3M6IGZ1bmN0aW9uKCkge1xuICAgIC8vIExvYWQgdGFncyBmb3IgdGhlIHZpZXdcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgdGFnSWNvbiA9IHt9O1xuICAgIHZhciB0YWdDbGFzcyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50YWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0YWdJY29uW3RoaXMudGFnc1tpXS50eXBlXSA9IHRoaXMudGFnc1tpXS5pY29uO1xuICAgICAgdGFnQ2xhc3NbdGhpcy50YWdzW2ldLnR5cGVdID0gdGhpcy50YWdzW2ldWydjbGFzcyddO1xuICAgIH1cblxuICAgIHZhciByZW5kZXJUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gICAgICB2YXIgdGVtcGxEYXRhID0ge1xuICAgICAgICBkYXRhOiBzZWxmLm1vZGVsLnRvSlNPTigpLFxuICAgICAgICB0YWdzOiBzZWxmLnRhZ3MsXG4gICAgICAgIHRhZzogdGFnLFxuICAgICAgICBlZGl0OiBzZWxmLmVkaXQsXG4gICAgICAgIHVzZXI6IHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlciB8fCB7fVxuICAgICAgfTtcbiAgICAgIHZhciBjb21waWxlZFRlbXBsYXRlID0gXy50ZW1wbGF0ZShUYWdUZW1wbGF0ZSkodGVtcGxEYXRhKTtcbiAgICAgIHZhciB0YWdEb20gPSAkKFwiLlwiICsgdGFnLnRhZy50eXBlKS5jaGlsZHJlbihcIi50YWdzXCIpO1xuICAgICAgdGFnRG9tLmFwcGVuZChjb21waWxlZFRlbXBsYXRlKTtcbiAgICAgICQoJyMnICsgdGFnQ2xhc3NbdGFnLnRhZy50eXBlXSArICctZW1wdHknKS5oaWRlKCk7XG4gICAgfTtcblxuICAgICQuYWpheCh7XG4gICAgICB1cmw6IHRoaXMub3B0aW9ucy51cmwgKyB0aGlzLm1vZGVsLmlkXG4gICAgfSkuZG9uZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIFJlbmRlciB0YWdzIG9udG8gcGFnZVxuICAgICAgICByZW5kZXJUYWcoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBJbml0aWFsaXplIFNlbGVjdDIgZm9yIEFkbWluaXN0cmF0aXZlIEZ1bmN0aW9uc1xuICAgIHZhciBmb3JtYXRSZXN1bHQgPSBmdW5jdGlvbiAob2JqZWN0LCBjb250YWluZXIsIHF1ZXJ5KSB7XG4gICAgICByZXR1cm4gJzxpIGNsYXNzPVwiJyArIHRhZ0ljb25bb2JqZWN0LnR5cGVdICsgJ1wiPjwvaT4gJyArIG9iamVjdC5uYW1lO1xuICAgIH07XG5cbiAgICAkKFwiI2lucHV0LXRhZ3NcIikuc2VsZWN0Mih7XG4gICAgICBwbGFjZWhvbGRlcjogJ0FkZCB0YWdzJyxcbiAgICAgIG11bHRpcGxlOiB0cnVlLFxuICAgICAgZm9ybWF0UmVzdWx0OiBmb3JtYXRSZXN1bHQsXG4gICAgICBmb3JtYXRTZWxlY3Rpb246IGZvcm1hdFJlc3VsdCxcbiAgICAgIGFqYXg6IHtcbiAgICAgICAgdXJsOiAnL2FwaS9hYy90YWcnLFxuICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICBkYXRhOiBmdW5jdGlvbiAodGVybSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBUYWdDb25maWdbc2VsZi50YXJnZXRdLmpvaW4oKSxcbiAgICAgICAgICAgIHE6IHRlcm1cbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICByZXN1bHRzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIHJldHVybiB7IHJlc3VsdHM6IGRhdGEgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTmV3IHRhZ3MgYWRkZWQgaW4gdG8gdGhlIERCIHZpYSB0aGUgbW9kYWxcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsIHRoaXMudGFyZ2V0ICsgXCI6dGFnOm5ld1wiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgLy8gRGVzdG9yeSBtb2RhbFxuICAgICAgJChcIi5tb2RhbFwiKS5tb2RhbCgnaGlkZScpO1xuICAgICAgLy8gQWRkIHRhZyBpbnRvIHRoZSBkYXRhIGxpc3RcbiAgICAgIHZhciBzMmRhdGEgPSAkKFwiI2lucHV0LXRhZ3NcIikuc2VsZWN0MihcImRhdGFcIik7XG4gICAgICBzMmRhdGEucHVzaChkYXRhKTtcbiAgICAgICQoXCIjaW5wdXQtdGFnc1wiKS5zZWxlY3QyKFwiZGF0YVwiLCBzMmRhdGEpO1xuICAgIH0pO1xuXG4gICAgLy8gVGFncyBzYXZlZCB1c2luZyB0aGUgc2VsZWN0MiBkaWFsb2dcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsIHRoaXMudGFyZ2V0ICsgXCI6dGFnOnNhdmVcIiwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWRhdGFbaV0uZXhpc3RpbmcpIHtcbiAgICAgICAgICByZW5kZXJUYWcoZGF0YVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgICQoXCIjaW5wdXQtdGFnc1wiKS5zZWxlY3QyKFwidmFsXCIsIFwiXCIpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCB0aGlzLnRhcmdldCArIFwiOnRhZzpkZWxldGVcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICgkKGUuY3VycmVudFRhcmdldCkucGFyZW50KCdsaScpLnNpYmxpbmdzKCkubGVuZ3RoID09IDEpIHtcbiAgICAgICAgJChlLmN1cnJlbnRUYXJnZXQpLnBhcmVudCgnbGknKS5zaWJsaW5ncygnLnRhZy1lbXB0eScpLnNob3coKTtcbiAgICAgIH1cbiAgICAgICQoZS5jdXJyZW50VGFyZ2V0KS5wYXJlbnQoJ2xpJykucmVtb3ZlKCk7XG4gICAgfSk7XG4gIH0sXG5cbiAgY3JlYXRlVGFnOiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gUG9wIHVwIGRpYWxvZyBib3ggdG8gY3JlYXRlIHRhZyxcbiAgICAvLyB0aGVuIHB1dCB0YWcgaW50byB0aGUgc2VsZWN0IGJveFxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHRoaXMubW9kYWxDb21wb25lbnQpKSB7XG4gICAgICB0aGlzLm1vZGFsQ29tcG9uZW50ID0gbmV3IE1vZGFsQ29tcG9uZW50KHtcbiAgICAgICAgZWw6IFwiI2NvbnRhaW5lclwiLFxuICAgICAgICBpZDogXCJjcmVhdGVUYWdcIixcbiAgICAgICAgbW9kYWxUaXRsZTogXCJDcmVhdGUgVGFnXCJcbiAgICAgIH0pLnJlbmRlcigpO1xuICAgIH1cblxuICAgIGlmICghXy5pc1VuZGVmaW5lZCh0aGlzLm1vZGFsQ29tcG9uZW50KSkge1xuICAgICAgaWYgKHRoaXMudGFnRm9ybVZpZXcpIHtcbiAgICAgICAgdGhpcy50YWdGb3JtVmlldy5jbGVhbnVwKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnRhZ0Zvcm1WaWV3ID0gbmV3IFRhZ0Zvcm1WaWV3KHtcbiAgICAgICAgZWw6IFwiI2NyZWF0ZVRhZyAubW9kYWwtdGVtcGxhdGVcIixcbiAgICAgICAgbW9kZWw6IHNlbGYubW9kZWwsXG4gICAgICAgIHRhZ3M6IHNlbGYudGFncyxcbiAgICAgICAgdGFyZ2V0OiBzZWxmLnRhcmdldFxuICAgICAgfSk7XG4gICAgICB0aGlzLnRhZ0Zvcm1WaWV3LnJlbmRlcigpO1xuICAgIH1cbiAgfSxcblxuICBzYXZlVGFnOiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIC8vIEN5Y2xlIHRocm91Z2ggdGFncyBpbiBzZWxlY3QgYm94XG4gICAgLy8gYW5kIGNhbGwgY3JlYXRlIG9uIGVhY2ggb25lLCB0aGVuXG4gICAgLy8gcmVuZGVyXG4gICAgJChcIiN0YWctc2F2ZVwiKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcbiAgICB2YXIgZGF0YSA9ICQoXCIjaW5wdXQtdGFnc1wiKS5zZWxlY3QyKCdkYXRhJyk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgdmFyIHByb2Nlc3NUYWcgPSBmdW5jdGlvbih0YWcsIGRvbmUpIHtcbiAgICAgIHZhciB0YWdNYXAgPSB7XG4gICAgICAgIHRhZ0lkOiB0YWcuaWRcbiAgICAgIH07XG4gICAgICBpZiAoc2VsZi50YXJnZXRJZCkge1xuICAgICAgICB0YWdNYXBbc2VsZi50YXJnZXRJZF0gPSBzZWxmLm1vZGVsLmlkO1xuICAgICAgfVxuICAgICAgJC5hamF4KHtcbiAgICAgICAgdXJsOiAnL2FwaS90YWcnLFxuICAgICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICAgIGRhdGE6IHRhZ01hcFxuICAgICAgfSkuZG9uZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXN1bHQucHVzaChkYXRhKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGFzeW5jLmVhY2goZGF0YSwgcHJvY2Vzc1RhZywgZnVuY3Rpb24gKGVycikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkYXRhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdFtpXS50YWdJZCA9PSBkYXRhW2pdLmlkKSB7XG4gICAgICAgICAgICByZXN1bHRbaV0udGFnID0gZGF0YVtqXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgJChcIiN0YWctc2F2ZVwiKS5yZW1vdmVDbGFzcygnZGlzYWJsZWQnKTtcbiAgICAgIHNlbGYubW9kZWwudHJpZ2dlcihzZWxmLm9wdGlvbnMudGFyZ2V0ICsgXCI6dGFnOnNhdmVcIiwgcmVzdWx0KTtcbiAgICB9KTtcblxuICB9LFxuXG4gIGRlbGV0ZVRhZzogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAvLyBHZXQgdGhlIGRhdGEtaWQgb2YgdGhlIGN1cnJlbnRUYXJnZXRcbiAgICAvLyBhbmQgdGhlbiBjYWxsIEhUVFAgREVMRVRFIG9uIHRoYXQgdGFnIGlkXG4gICAgJC5hamF4KHtcbiAgICAgIHVybDogJy9hcGkvdGFnLycgKyAkKGUuY3VycmVudFRhcmdldCkuZGF0YSgnaWQnKSxcbiAgICAgIHR5cGU6ICdERUxFVEUnLFxuICAgIH0pLmRvbmUoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHNlbGYubW9kZWwudHJpZ2dlcihzZWxmLm9wdGlvbnMudGFyZ2V0ICsgXCI6dGFnOmRlbGV0ZVwiLCBlKTtcbiAgICB9KTtcbiAgfSxcblxuICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMudGFnRm9ybVZpZXcpIHsgdGhpcy50YWdGb3JtVmlldy5jbGVhbnVwKCk7IH1cbiAgICByZW1vdmVWaWV3KHRoaXMpO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRhZ1Nob3dWaWV3O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxmb3JtIGFjdGlvbj1cXFwiXFxcIiBpZD1cXFwidGFzay1lZGl0LWZvcm1cXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuICAgIDxoMiBjbGFzcz1cXFwiYm94LXBhZC10XFxcIj5cXG4gICAgICA8c3BhbiBkYXRhLWkxOG49XFxcIlRhc2tcXFwiPk9wcG9ydHVuaXR5PC9zcGFuPiBUaXRsZVxcbiAgICA8L2gyPlxcbiAgICA8aW5wdXQgaWQ9XFxcInRhc2stdGl0bGVcXFwiIHR5cGU9XFxcInRleHRcXFwiIHBsYWNlaG9sZGVyPVxcXCJBIHNob3J0IGRlc2NyaXB0aW9uIG9mIHRoZSBwcm9ibGVtLlxcXCIgdmFsdWU9XFxcIjwlLSBkYXRhLnRpdGxlICU+XFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sIGlucHV0LWxnIHZhbGlkYXRlXFxcIiBkYXRhLXZhbGlkYXRlPVxcXCJlbXB0eSxjb3VudDEwMFxcXCIvPlxcbiAgICA8c3BhbiBjbGFzcz1cXFwiaGVscC1ibG9jayBlcnJvci1lbXB0eVxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPllvdSBtdXN0IGVudGVyIGEgdGl0bGUgZm9yIHRoaXMgPHNwYW4gZGF0YS1pMThuPVxcXCJ0YXNrXFxcIj5vcHBvcnR1bml0eTwvc3Bhbj48L3NwYW4+XFxuICAgIDxzcGFuIGNsYXNzPVxcXCJoZWxwLWJsb2NrIGVycm9yLWNvdW50MTAwXFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI+VGhlIHNob3J0IGRlc2NyaXB0aW9uIG9mIHRoZSBwcm9ibGVtIG11c3QgYmUgbGVzcyB0aGFuIDEwMCBjaGFyYWN0ZXJzLjwvc3Bhbj5cXG4gIDwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuICAgIDxoMiBjbGFzcz1cXFwiYm94LXBhZC10XFxcIj5cXG4gICAgICA8c3BhbiBkYXRhLWkxOG49XFxcIlRhc2tcXFwiPk9wcG9ydHVuaXR5PC9zcGFuPiBEZXNjcmlwdGlvblxcbiAgICA8L2gyPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJtYXJrZG93bi1lZGl0XFxcIj48L2Rpdj5cXG4gICAgPHNwYW4gY2xhc3M9XFxcImhlbHAtYmxvY2sgZXJyb3ItZW1wdHlcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIj5Zb3UgbXVzdCBlbnRlciBhIGRlc2NyaXB0aW9uIGZvciB0aGlzIDxzcGFuIGRhdGEtaTE4bj1cXFwidGFza1xcXCI+b3Bwb3J0dW5pdHk8L3NwYW4+PC9zcGFuPlxcbiAgPC9kaXY+XFxuICA8aHIgLz5cXG5cXG4gIDwlIGlmICh1aS5wcm9qZWN0LnNob3cpIHsgJT5cXG4gIFRoaXMgPHNwYW4gZGF0YS1pMThuPVxcXCJ0YXNrXFxcIj5vcHBvcnR1bml0eTwvc3Bhbj4gYmVsb25ncyB0byB0aGUgPHNwYW4gZGF0YS1pMThuPVxcXCJwcm9qZWN0XFxcIj5wcm9qZWN0PC9zcGFuPjpcXG4gIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0xMlxcXCI+XFxuICAgICAgPGlucHV0IHR5cGU9XFxcImhpZGRlblxcXCIgaWQ9XFxcInByb2plY3RJZFxcXCIgY2xhc3M9XFxcInRhc2stc2tpbGxzIGZ1bGx3aWR0aFxcXCIgLz5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG4gIDwlIH0gJT5cXG5cXG4gIDxoci8+XFxuXFxuICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMTJcXFwiPlxcbiAgICAgICAgPHNwYW4gZGF0YS1pMThuPVxcXCJUYXNrT3duZXJcXFwiPlRhc2sgT3duZXI8L3NwYW4+XFxuICAgICAgICA8aW5wdXQgc3R5bGU9XFxcIndpZHRoOiAxMDAlXFxcIiBpZD1cXFwib3duZXJcXFwiIG5hbWU9XFxcIm93bmVyXFxcIiB0eXBlPVxcXCJoaWRkZW5cXFwiIHZhbHVlPVxcXCJFZGl0IE93bmVyXFxcIi8+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuXFxuICA8aHIvPlxcblxcbiAgPGRpdiBjbGFzcz1cXFwidGFzay1lZGl0LWRlc2NyaXB0aW9uXFxcIj5cXG4gICAgV2UgbmVlZFxcbiAgICA8c2VsZWN0IGlkPVxcXCJwZW9wbGVcXFwiIGNsYXNzPVxcXCJkcm9wZG93blxcXCI+XFxuICAgICAgPCUgXy5lYWNoKHRhZ1R5cGVzWyd0YXNrLXBlb3BsZSddLCBmdW5jdGlvbiAodCkgeyAlPlxcbiAgICAgIDxvcHRpb24gdmFsdWU9PCU9IHQuaWQgJT4gPCUgaWYgKG1hZGxpYlRhZ3NbJ3Rhc2stcGVvcGxlJ10gJiYgKG1hZGxpYlRhZ3NbJ3Rhc2stcGVvcGxlJ11bMF0uaWQgPT0gdC5pZCkpIHsgJT5zZWxlY3RlZDwlIH0gJT4+PCU9IHQubmFtZSAlPjwvb3B0aW9uPlxcbiAgICAgIDwlIH0pOyAlPlxcbiAgICA8L3NlbGVjdD5cXG5cXG4gICAgdG8gd29yayBvbiBhbiA8c3BhbiBkYXRhLWkxOG49XFxcInRhc2tcXFwiPm9wcG9ydHVuaXR5PC9zcGFuPiBhYm91dDpcXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMTJcXFwiPlxcbiAgICAgICAgPGlucHV0IHR5cGU9XFxcImhpZGRlblxcXCIgaWQ9XFxcInRhc2tfdGFnX3RvcGljc1xcXCIgY2xhc3M9XFxcInRhc2stc2tpbGxzIGZ1bGx3aWR0aFxcXCIgLz5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxociAvPlxcblxcbiAgICBUaGUgZm9sbG93aW5nIHNraWxscyBhcmUgdXNlZnVsIGFuZFxcbiAgICA8c2VsZWN0IGlkPVxcXCJza2lsbHMtcmVxdWlyZWRcXFwiIGNsYXNzPVxcXCJkcm9wZG93blxcXCI+XFxuICAgICAgPCUgXy5lYWNoKHRhZ1R5cGVzWyd0YXNrLXNraWxscy1yZXF1aXJlZCddLCBmdW5jdGlvbiAodCkgeyAlPlxcbiAgICAgIDxvcHRpb24gdmFsdWU9PCU9IHQuaWQgJT4gPCUgaWYgKG1hZGxpYlRhZ3NbJ3Rhc2stc2tpbGxzLXJlcXVpcmVkJ10gJiYgKG1hZGxpYlRhZ3NbJ3Rhc2stc2tpbGxzLXJlcXVpcmVkJ11bMF0uaWQgPT0gdC5pZCkpIHsgJT5zZWxlY3RlZDwlIH0gJT4+PCU9IHQubmFtZSAlPjwvb3B0aW9uPlxcbiAgICAgIDwlIH0pOyAlPlxcbiAgICA8L3NlbGVjdD5cXG5cXG4gICAgdG8gY29tcGxldGUgdGhpcyA8c3BhbiBkYXRhLWkxOG49XFxcInRhc2tcXFwiPm9wcG9ydHVuaXR5PC9zcGFuPiB5b3Ugc2hvdWxkXFxuICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTEyXFxcIj5cXG4gICAgICAgIDxpbnB1dCB0eXBlPVxcXCJoaWRkZW5cXFwiIGlkPVxcXCJ0YXNrX3RhZ19za2lsbHNcXFwiIGNsYXNzPVxcXCJ0YXNrLXNraWxscyBmdWxsd2lkdGhcXFwiLz5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxociAvPlxcblxcbiAgICBUaGUgPHNwYW4gZGF0YS1pMThuPVxcXCJ0YXNrXFxcIj5vcHBvcnR1bml0eTwvc3Bhbj4gd2lsbCByZXF1aXJlXFxuICAgIDxzZWxlY3QgaWQ9XFxcInRpbWUtZXN0aW1hdGVcXFwiIGNsYXNzPVxcXCJkcm9wZG93blxcXCI+XFxuICAgICAgPCUgXy5lYWNoKHRhZ1R5cGVzWyd0YXNrLXRpbWUtZXN0aW1hdGUnXSwgZnVuY3Rpb24gKHQpIHsgJT5cXG4gICAgICA8b3B0aW9uIHZhbHVlPTwlPSB0LmlkICU+IDwlIGlmIChtYWRsaWJUYWdzWyd0YXNrLXRpbWUtZXN0aW1hdGUnXSAmJiAobWFkbGliVGFnc1sndGFzay10aW1lLWVzdGltYXRlJ11bMF0uaWQgPT0gdC5pZCkpIHsgJT5zZWxlY3RlZDwlIH0gJT4+PCU9IHQubmFtZSAlPjwvb3B0aW9uPlxcbiAgICAgIDwlIH0pOyAlPlxcbiAgICA8L3NlbGVjdD5cXG5cXG4gICAgb2ZcXG4gICAgPHNlbGVjdCBpZD1cXFwidGltZS1yZXF1aXJlZFxcXCIgY2xhc3M9XFxcImRyb3Bkb3duXFxcIj5cXG4gICAgICA8JSBfLmVhY2godGFnVHlwZXNbJ3Rhc2stdGltZS1yZXF1aXJlZCddLCBmdW5jdGlvbiAodCkgeyAlPlxcbiAgICAgIDxvcHRpb24gdmFsdWU9PCU9IHQuaWQgJT4gPCUgaWYgKG1hZGxpYlRhZ3NbJ3Rhc2stdGltZS1yZXF1aXJlZCddICYmIChtYWRsaWJUYWdzWyd0YXNrLXRpbWUtcmVxdWlyZWQnXVswXS5pZCA9PSB0LmlkKSkgeyAlPnNlbGVjdGVkPCUgfSAlPj48JT0gdC5uYW1lICU+PC9vcHRpb24+XFxuICAgICAgPCUgfSk7ICU+XFxuICAgIDwvc2VsZWN0PlxcblxcbiAgICB3b3JrLCBhbmQgbXVzdCBiZSBjb21wbGV0ZWQgd2l0aGluXFxuICAgIDxzZWxlY3QgaWQ9XFxcImxlbmd0aFxcXCIgY2xhc3M9XFxcImRyb3Bkb3duXFxcIj5cXG4gICAgICA8JSBfLmVhY2godGFnVHlwZXNbJ3Rhc2stbGVuZ3RoJ10sIGZ1bmN0aW9uICh0KSB7ICU+XFxuICAgICAgPG9wdGlvbiB2YWx1ZT08JT0gdC5pZCAlPiA8JSBpZiAobWFkbGliVGFnc1sndGFzay1sZW5ndGgnXSAmJiAobWFkbGliVGFnc1sndGFzay1sZW5ndGgnXVswXS5pZCA9PSB0LmlkKSkgeyAlPnNlbGVjdGVkPCUgfSAlPj48JT0gdC5uYW1lICU+PC9vcHRpb24+XFxuICAgICAgPCUgfSk7ICU+XFxuICAgIDwvc2VsZWN0PlxcblxcbiAgICA8aHIgLz5cXG5cXG4gICAgUGFydGljaXBhbnRzIG11c3QgYmUgbG9jYXRlZCBhdDo8YnIvPlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0xMlxcXCI+XFxuICAgICAgICA8aW5wdXQgdHlwZT1cXFwiaGlkZGVuXFxcIiBpZD1cXFwidGFza190YWdfbG9jYXRpb25cXFwiIGNsYXNzPVxcXCJ0YXNrLXNraWxscyBmdWxsd2lkdGhcXFwiLz5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxzbWFsbD5MZWF2ZSBlbXB0eSBpZiBwZW9wbGUgY2FuIHBhcnRpY2lwYXRlIGZyb20gYW55d2hlcmU8L3NtYWxsPlxcblxcbiAgICA8aHIvPlxcblxcbiAgICBQdWJpc2hlZCBkYXRlOjxicj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTEyIHBhZGRpbmctbm9uZVxcXCIgaWQ9XFxcImRpdi1wdWJsaXNoZWRBdFxcXCI+XFxuICAgICAgPGlucHV0IGlkPVxcXCJwdWJsaXNoZWRBdFxcXCIgbmFtZT1cXFwicHVibGlzaGVkQXRcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2wgdGltZXBpY2tlclxcXCIgdHlwZT1cXFwidGV4dFxcXCI+XFxuICAgIDwvZGl2PlxcbiAgICBBc3NpZ25lZCBkYXRlOjxicj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTEyIHBhZGRpbmctbm9uZVxcXCIgaWQ9XFxcImRpdi1hc3NpZ25lZEF0XFxcIj5cXG4gICAgICA8aW5wdXQgaWQ9XFxcImFzc2lnbmVkQXRcXFwiIG5hbWU9XFxcImFzc2lnbmVkQXRcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2wgdGltZXBpY2tlclxcXCIgdHlwZT1cXFwidGV4dFxcXCI+XFxuICAgIDwvZGl2PlxcbiAgICBDb21wbGV0ZWQgZGF0ZTo8YnI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0xMiBwYWRkaW5nLW5vbmVcXFwiIGlkPVxcXCJkaXYtY29tcGxldGVkQXRcXFwiPlxcbiAgICAgIDxpbnB1dCBpZD1cXFwiY29tcGxldGVkQXRcXFwiIG5hbWU9XFxcImNvbXBsZXRlZEF0XFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sIHRpbWVwaWNrZXJcXFwiIHR5cGU9XFxcInRleHRcXFwiPlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY2xlYXJmaXhcXFwiPlxcbiAgICAgIDxocj5cXG4gICAgPC9kaXY+XFxuXFxuICA8L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImNvbC1sZy0xMlxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwicHVsbC1yaWdodCBib3gtcGFkLWJcXFwiPlxcbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnRuIGJ0bi1jMFxcXCIgaWQ9XFxcInRhc2stdmlld1xcXCI+RGlzY2FyZCBDaGFuZ2VzPC9idXR0b24+XFxuICAgICAgICA8aW5wdXQgdHlwZT1cXFwic3VibWl0XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1jMlxcXCIgZGF0YS1pMThuPVxcXCJbdmFsdWVdU2F2ZVRhc2tcXFwiIHZhbHVlPVxcXCJTYXZlIE9wcG9ydHVuaXR5XFxcIi8+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC9mb3JtPlxcblwiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcInByb2plY3QtcGVvcGxlLWRpdlxcXCIgZGF0YS11c2VyaWQ9XFxcIjwlPSBkYXRhLnVzZXJJZCAlPlxcXCI+XFxuICA8aW1nIHNyYz1cXFwiL2FwaS91c2VyL3Bob3RvLzwlPSBkYXRhLnVzZXJJZCAlPlxcXCIgY2xhc3M9XFxcInByb2plY3QtcGVvcGxlXFxcIiBhbHQ9XFxcIjwlPSBkYXRhLm93bmVyLm5hbWUgJT5cXFwiLz5cXG48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJwcm9qZWN0LXBlb3BsZS1zcGFjZVxcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJiYXJcXFwiPjwvZGl2PlxcbjwvZGl2PlxcbjwlIF8uZWFjaChkYXRhLnZvbHVudGVlcnMsIGZ1bmN0aW9uICh2KSB7ICU+XFxuICA8ZGl2IGNsYXNzPVxcXCJwcm9qZWN0LXBlb3BsZS1kaXZcXFwiIGRhdGEtdXNlcmlkPVxcXCI8JT0gdi51c2VySWQgJT5cXFwiIGRhdGEtdm9sdXNlcmlkPVxcXCI8JT0gdi51c2VySWQgJT5cXFwiPlxcbiAgICA8aW1nIHNyYz1cXFwiL2FwaS91c2VyL3Bob3RvLzwlPSB2LnVzZXJJZCAlPlxcXCIgY2xhc3M9XFxcInByb2plY3QtcGVvcGxlXFxcIiBhbHQ9XFxcIjwlPSB2Lm5hbWUgJT5cXFwiLz5cXG4gICAgPGEgaHJlZj1cXFwiI1xcXCIgY2xhc3M9XFxcImRlbGV0ZS12b2x1bnRlZXIgdm9sdW50ZWVyLWRlbGV0ZSBmYSBmYS10aW1lc1xcXCIgIGlkPVxcXCJkZWxldGUtdm9sdW50ZWVyLTwlPSB2LmlkICU+XFxcIiBkYXRhLXVpZD1cXFwiPCU9IHYudXNlcklkICU+XFxcIiBkYXRhLXZpZD1cXFwiPCU9IHYuaWQgJT5cXFwiPjwvYT5cXG4gIDwvZGl2PlxcbjwlIH0pOyAlPlxcblwiO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIHV0aWxpdGllcyA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL21peGlucy91dGlsaXRpZXMnKTtcbnZhciBVSUNvbmZpZyA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2NvbmZpZy91aS5qc29uJyk7XG52YXIgYXN5bmMgPSByZXF1aXJlKCdhc3luYycpO1xudmFyIG1hcmtlZCA9IHJlcXVpcmUoJ21hcmtlZCcpO1xudmFyIE1hcmtkb3duRWRpdG9yID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29tcG9uZW50cy9tYXJrZG93bl9lZGl0b3InKTtcbnZhciBUYXNrRWRpdEZvcm1UZW1wbGF0ZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy90YXNrX2VkaXRfZm9ybV90ZW1wbGF0ZS5odG1sJyk7XG52YXIgVm9sdW50ZWVyRWRpdEZvcm1UZW1wbGF0ZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy92b2x1bnRlZXJfZWRpdF9mb3JtX3RlbXBsYXRlLmh0bWwnKTtcbnZhciBUYWdGYWN0b3J5ID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29tcG9uZW50cy90YWdfZmFjdG9yeScpO1xuXG5cbnZhciBUYXNrRWRpdEZvcm1WaWV3ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuXG4gIGV2ZW50czoge1xuICAgICdibHVyIC52YWxpZGF0ZScgICAgICAgICA6ICd2JyxcbiAgICAnY2xpY2sgI3Rhc2stdmlldycgICAgICAgOiAndmlldycsXG4gICAgJ3N1Ym1pdCAjdGFzay1lZGl0LWZvcm0nIDogJ3N1Ym1pdCdcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy50YWdGYWN0b3J5ID0gbmV3IFRhZ0ZhY3RvcnkoKTtcbiAgICB0aGlzLmRhdGEgPSB7fTtcbiAgICB0aGlzLmRhdGEubmV3VGFnID0ge307XG4gICAgdGhpcy5pbml0aWFsaXplTGlzdGVuZXJzKCk7XG4gICAgLy8gUmVnaXN0ZXIgbGlzdGVuZXIgdG8gdGFzayB1cGRhdGUsIHRoZSBsYXN0IHN0ZXAgb2Ygc2F2aW5nXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm9wdGlvbnMubW9kZWwsIFwidGFzazp1cGRhdGU6c3VjY2Vzc1wiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgQmFja2JvbmUuaGlzdG9yeS5uYXZpZ2F0ZSgndGFza3MvJyArIGRhdGEuYXR0cmlidXRlcy5pZCwgeyB0cmlnZ2VyOiB0cnVlIH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIHZpZXc6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBCYWNrYm9uZS5oaXN0b3J5Lm5hdmlnYXRlKCd0YXNrcy8nICsgdGhpcy5tb2RlbC5hdHRyaWJ1dGVzLmlkLCB7IHRyaWdnZXI6IHRydWUgfSk7XG4gIH0sXG5cbiAgdjogZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gdmFsaWRhdGUoZSk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbXBpbGVkVGVtcGxhdGUsIHZvbHVudGVlclRlbXBsYXRlO1xuXG4gICAgdGhpcy5kYXRhID0ge1xuICAgICAgZGF0YTogdGhpcy5tb2RlbC50b0pTT04oKSxcbiAgICAgIHRhZ1R5cGVzOiB0aGlzLm9wdGlvbnMudGFnVHlwZXMsXG4gICAgICBuZXdUYWdzOiBbXSxcbiAgICAgIG5ld0l0ZW1UYWdzOiBbXSxcbiAgICAgIHRhZ3M6IHRoaXMub3B0aW9ucy50YWdzLFxuICAgICAgbWFkbGliVGFnczogdGhpcy5vcHRpb25zLm1hZGxpYlRhZ3MsXG4gICAgICB1aTogVUlDb25maWdcbiAgICB9O1xuXG4gICAgdm9sdW50ZWVyVGVtcGxhdGUgPSBfLnRlbXBsYXRlKFZvbHVudGVlckVkaXRGb3JtVGVtcGxhdGUpKHRoaXMuZGF0YSk7XG4gICAgLy8kKHRoaXMub3B0aW9ucy5lbFZvbHVudGVlcikucmVtb3ZlKCk7XG4gICAgJCh0aGlzLm9wdGlvbnMuZWxWb2x1bnRlZXIpLmh0bWwodm9sdW50ZWVyVGVtcGxhdGUpO1xuICAgICQodGhpcy5vcHRpb25zLmVsVm9sdW50ZWVyKS5pMThuKCk7XG5cbiAgICBjb21waWxlZFRlbXBsYXRlID0gXy50ZW1wbGF0ZShUYXNrRWRpdEZvcm1UZW1wbGF0ZSkodGhpcy5kYXRhKTtcbiAgICB0aGlzLiRlbC5odG1sKGNvbXBpbGVkVGVtcGxhdGUpO1xuICAgIHRoaXMuJGVsLmkxOG4oKTtcblxuICAgIC8vIERPTSBub3cgZXhpc3RzLCBiZWdpbiBzZWxlY3QyIGluaXRcbiAgICB0aGlzLmluaXRpYWxpemVTZWxlY3QyKCk7XG4gICAgdGhpcy5pbml0aWFsaXplVGV4dEFyZWEoKTtcblxuICAgIC8vIFNldCB1cCB0aW1lIHBpY2tlcnNcbiAgICAkKCcjcHVibGlzaGVkQXQnKS5kYXRldGltZXBpY2tlcih7XG4gICAgICBkZWZhdWx0RGF0ZTogdGhpcy5kYXRhLmRhdGEucHVibGlzaGVkQXRcbiAgICB9KTtcbiAgICAkKCcjYXNzaWduZWRBdCcpLmRhdGV0aW1lcGlja2VyKHtcbiAgICAgIGRlZmF1bHREYXRlOiB0aGlzLmRhdGEuZGF0YS5hc3NpZ25lZEF0XG4gICAgfSk7XG4gICAgJCgnI2NvbXBsZXRlZEF0JykuZGF0ZXRpbWVwaWNrZXIoe1xuICAgICAgZGVmYXVsdERhdGU6IHRoaXMuZGF0YS5kYXRhLmNvbXBsZXRlZEF0XG4gICAgfSk7XG5cbiAgfSxcblxuICBpbml0aWFsaXplU2VsZWN0MjogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGZvcm1hdFJlc3VsdCA9IGZ1bmN0aW9uIChvYmplY3QsIGNvbnRhaW5lciwgcXVlcnkpIHtcbiAgICAgIHZhciBmb3JtYXR0ZWQgPSAnPGRpdiBjbGFzcz1cInNlbGVjdDItcmVzdWx0LXRpdGxlXCI+JztcbiAgICAgIGZvcm1hdHRlZCArPSBvYmplY3QubmFtZSB8fCBvYmplY3QudGl0bGU7XG4gICAgICBmb3JtYXR0ZWQgKz0gJzwvZGl2Pic7XG4gICAgICBpZiAoIV8uaXNVbmRlZmluZWQob2JqZWN0LmRlc2NyaXB0aW9uKSkge1xuICAgICAgICBmb3JtYXR0ZWQgKz0gJzxkaXYgY2xhc3M9XCJzZWxlY3QyLXJlc3VsdC1kZXNjcmlwdGlvblwiPicgKyBtYXJrZWQob2JqZWN0LmRlc2NyaXB0aW9uKSArICc8L2Rpdj4nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZvcm1hdHRlZDtcbiAgICB9O1xuXG4gICAgdGhpcy4kKFwiI3Byb2plY3RJZFwiKS5zZWxlY3QyKHtcbiAgICAgIHBsYWNlaG9sZGVyOiBcIlNlbGVjdCBhIHByb2plY3QgdG8gYXNzb2NpYXRlXCIsXG4gICAgICBtdWx0aXBsZTogZmFsc2UsXG4gICAgICBmb3JtYXRSZXN1bHQ6IGZvcm1hdFJlc3VsdCxcbiAgICAgIGZvcm1hdFNlbGVjdGlvbjogZm9ybWF0UmVzdWx0LFxuICAgICAgYWxsb3dDbGVhcjogdHJ1ZSxcbiAgICAgIGFqYXg6IHtcbiAgICAgICAgdXJsOiAnL2FwaS9hYy9wcm9qZWN0JyxcbiAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgZGF0YTogZnVuY3Rpb24gKHRlcm0pIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcTogdGVybVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHJlc3VsdHM6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIHsgcmVzdWx0czogZGF0YSB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuZGF0YS5kYXRhLnByb2plY3QpIHtcbiAgICAgIHRoaXMuJChcIiNwcm9qZWN0SWRcIikuc2VsZWN0MignZGF0YScsIHRoaXMuZGF0YS5kYXRhLnByb2plY3QpO1xuICAgIH1cblxuICAgIHRoaXMuJChcIiNvd25lclwiKS5zZWxlY3QyKHtcbiAgICAgIHBsYWNlaG9sZGVyOiBcInRhc2sgb3duZXJcIixcbiAgICAgIG11bHRpcGxlOiBmYWxzZSxcbiAgICAgIGZvcm1hdFJlc3VsdDogZm9ybWF0UmVzdWx0LFxuICAgICAgZm9ybWF0U2VsZWN0aW9uOiBmb3JtYXRSZXN1bHQsXG4gICAgICBhbGxvd0NsZWFyOiBmYWxzZSxcbiAgICAgIGFqYXg6IHtcbiAgICAgICAgdXJsOiAnL2FwaS9hYy91c2VyJyxcbiAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgZGF0YTogZnVuY3Rpb24gKHRlcm0pIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcTogdGVybVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHJlc3VsdHM6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIHsgcmVzdWx0czogZGF0YSB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuZGF0YS5kYXRhLm93bmVyKSB7XG4gICAgICB0aGlzLiQoXCIjb3duZXJcIikuc2VsZWN0MignZGF0YScsIHRoaXMuZGF0YS5kYXRhLm93bmVyKTtcbiAgICB9XG5cbiAgICB0aGlzLnRhZ0ZhY3RvcnkuY3JlYXRlVGFnRHJvcERvd24oe1xuICAgICAgdHlwZTpcInNraWxsXCIsc2VsZWN0b3I6XCIjdGFza190YWdfc2tpbGxzXCIsd2lkdGg6IFwiMTAwJVwiLCB0b2tlblNlcGFyYXRvcnM6IFtcIixcIl1cbiAgICB9KTtcbiAgICBpZiAodGhpcy5kYXRhWydtYWRsaWJUYWdzJ10uc2tpbGwpIHtcbiAgICAgIHRoaXMuJChcIiN0YXNrX3RhZ19za2lsbHNcIikuc2VsZWN0MignZGF0YScsIHRoaXMuZGF0YVsnbWFkbGliVGFncyddLnNraWxsKTtcbiAgICB9XG5cbiAgICB0aGlzLnRhZ0ZhY3RvcnkuY3JlYXRlVGFnRHJvcERvd24oe1xuICAgICAgdHlwZTpcInRvcGljXCIsIHNlbGVjdG9yOiBcIiN0YXNrX3RhZ190b3BpY3NcIiwgd2lkdGg6IFwiMTAwJVwiLCB0b2tlblNlcGFyYXRvcnM6IFtcIixcIl1cbiAgICB9KTtcbiAgICBpZiAodGhpcy5kYXRhWydtYWRsaWJUYWdzJ10udG9waWMpIHtcbiAgICAgIHRoaXMuJChcIiN0YXNrX3RhZ190b3BpY3NcIikuc2VsZWN0MignZGF0YScsIHRoaXMuZGF0YVsnbWFkbGliVGFncyddLnRvcGljKTtcbiAgICB9XG5cbiAgICB0aGlzLnRhZ0ZhY3RvcnkuY3JlYXRlVGFnRHJvcERvd24oe3R5cGU6XCJsb2NhdGlvblwiLHNlbGVjdG9yOlwiI3Rhc2tfdGFnX2xvY2F0aW9uXCIsd2lkdGg6IFwiMTAwJVwifSk7XG4gICAgaWYgKHRoaXMuZGF0YVsnbWFkbGliVGFncyddLmxvY2F0aW9uKSB7XG4gICAgICB0aGlzLiQoXCIjdGFza190YWdfbG9jYXRpb25cIikuc2VsZWN0MignZGF0YScsIHRoaXMuZGF0YVsnbWFkbGliVGFncyddLmxvY2F0aW9uKTtcbiAgICB9XG5cbiAgICAkKFwiI3NraWxscy1yZXF1aXJlZFwiKS5zZWxlY3QyKHtcbiAgICAgIHBsYWNlaG9sZGVyOiBcInJlcXVpcmVkL25vdC1yZXF1aXJlZFwiLFxuICAgICAgd2lkdGg6ICcyMDBweCdcbiAgICB9KTtcblxuICAgICQoXCIjdGltZS1yZXF1aXJlZFwiKS5zZWxlY3QyKHtcbiAgICAgIHBsYWNlaG9sZGVyOiAndGltZS1yZXF1aXJlZCcsXG4gICAgICB3aWR0aDogJzEzMHB4J1xuICAgIH0pO1xuXG4gICAgJChcIiNwZW9wbGVcIikuc2VsZWN0Mih7XG4gICAgICBwbGFjZWhvbGRlcjogJ3Blb3BsZScsXG4gICAgICB3aWR0aDogJzE1MHB4J1xuICAgIH0pO1xuXG4gICAgJChcIiNsZW5ndGhcIikuc2VsZWN0Mih7XG4gICAgICBwbGFjZWhvbGRlcjogJ2xlbmd0aCcsXG4gICAgICB3aWR0aDogJzEzMHB4J1xuICAgIH0pO1xuXG4gICAgJChcIiN0aW1lLWVzdGltYXRlXCIpLnNlbGVjdDIoe1xuICAgICAgcGxhY2Vob2xkZXI6ICd0aW1lLWVzdGltYXRlJyxcbiAgICAgIHdpZHRoOiAnMjAwcHgnXG4gICAgfSk7XG5cbiAgICAkKFwiI3Rhc2stbG9jYXRpb25cIikuc2VsZWN0Mih7XG4gICAgICBwbGFjZWhvbGRlcjogJ2xvY2F0aW9uJyxcbiAgICAgIHdpZHRoOiAnMTMwcHgnXG4gICAgfSk7XG5cbiAgfSxcblxuICBpbml0aWFsaXplVGV4dEFyZWE6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5tZCkgeyB0aGlzLm1kLmNsZWFudXAoKTsgfVxuICAgIHRoaXMubWQgPSBuZXcgTWFya2Rvd25FZGl0b3Ioe1xuICAgICAgZGF0YTogdGhpcy5tb2RlbC50b0pTT04oKS5kZXNjcmlwdGlvbixcbiAgICAgIGVsOiBcIi5tYXJrZG93bi1lZGl0XCIsXG4gICAgICBpZDogJ3Rhc2stZGVzY3JpcHRpb24nLFxuICAgICAgcGxhY2Vob2xkZXI6ICdEZXNjcmlwdGlvbiBvZiBvcHBvcnR1bml0eSBpbmNsdWRpbmcgZ29hbHMsIGV4cGVjdGVkIG91dGNvbWVzIGFuZCBkZWxpdmVyYWJsZXMuJyxcbiAgICAgIHRpdGxlOiAnT3Bwb3J0dW5pdHkgRGVzY3JpcHRpb24nLFxuICAgICAgcm93czogNixcbiAgICAgIHZhbGlkYXRlOiBbJ2VtcHR5J11cbiAgICB9KS5yZW5kZXIoKTtcbiAgfSxcblxuICBpbml0aWFsaXplTGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBzZWxmLm9uKFwidGFzazp0YWdzOnNhdmU6ZG9uZVwiLCBmdW5jdGlvbiAoKXtcblxuICAgICAgdmFyIG1vZGVsRGF0YSA9IHtcbiAgICAgICAgdGl0bGU6IHRoaXMuJChcIiN0YXNrLXRpdGxlXCIpLnZhbCgpLFxuICAgICAgICBkZXNjcmlwdGlvbjogdGhpcy4kKFwiI3Rhc2stZGVzY3JpcHRpb25cIikudmFsKCksXG4gICAgICAgIHB1Ymxpc2hlZEF0OiB0aGlzLiQoXCIjcHVibGlzaGVkQXRcIikudmFsKCkgfHwgdW5kZWZpbmVkLFxuICAgICAgICBhc3NpZ25lZEF0OiB0aGlzLiQoXCIjYXNzaWduZWRBdFwiKS52YWwoKSB8fCB1bmRlZmluZWQsXG4gICAgICAgIGNvbXBsZXRlZEF0OiB0aGlzLiQoXCIjY29tcGxldGVkQXRcIikudmFsKCkgfHwgdW5kZWZpbmVkXG4gICAgICB9O1xuXG4gICAgICB2YXIgcHJvamVjdCA9IHRoaXMuJChcIiNwcm9qZWN0SWRcIikuc2VsZWN0MignZGF0YScpO1xuICAgICAgaWYgKHByb2plY3QpIHtcbiAgICAgICAgbW9kZWxEYXRhLnByb2plY3RJZCA9IHByb2plY3QuaWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb2RlbERhdGEucHJvamVjdElkID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIG93bmVyID0gdGhpcy4kKFwiI293bmVyXCIpLnNlbGVjdDIoJ2RhdGEnKTtcbiAgICAgIGlmIChvd25lcikge1xuICAgICAgICBtb2RlbERhdGEudXNlcklkID0gb3duZXIuaWQ7XG4gICAgICB9XG5cbiAgICAgIG9sZFRhZ3MgPSB0aGlzLmdldE9sZFRhZ3MoKTtcbiAgICAgIHRhZ3MgICAgPSB0aGlzLmdldFRhZ3NGcm9tUGFnZSgpO1xuICAgICAgZGlmZiAgICA9IHRoaXMudGFnRmFjdG9yeS5jcmVhdGVEaWZmKG9sZFRhZ3MsIHRhZ3MpO1xuXG4gICAgICBfLmVhY2goc2VsZi5kYXRhLm5ld0l0ZW1UYWdzLCBmdW5jdGlvbihuZXdJdGVtVGFnKXtcbiAgICAgICAgZGlmZi5hZGQucHVzaChuZXdJdGVtVGFnLmlkKTtcbiAgICAgIH0pO1xuXG4gICAgICBhc3luYy5mb3JFYWNoKFxuICAgICAgICBkaWZmLmFkZCxcbiAgICAgICAgZnVuY3Rpb24oZGlmZkFkZCwgY2FsbGJhY2spe1xuICAgICAgICAgIGlmICggIV8uaXNGaW5pdGUoZGlmZkFkZCkgJiYgZGlmZkFkZC5uYW1lID09IGRpZmZBZGQuaWQgKSB7IHJldHVybiBjYWxsYmFjaygpOyB9XG4gICAgICAgICAgc2VsZi50YWdGYWN0b3J5LmFkZFRhZyhkaWZmQWRkLHNlbGYubW9kZWwuYXR0cmlidXRlcy5pZCxcInRhc2tJZFwiLGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24oZXJyKXtcbiAgICAgICAgICBzZWxmLm9wdGlvbnMubW9kZWwudHJpZ2dlcihcInRhc2s6dXBkYXRlXCIsIG1vZGVsRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICB9KTtcbiAgfSxcblxuICBzdWJtaXQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgLy92YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgdGFncyA9IFtdO1xuICAgIHZhciBvbGRUYWdzID0gW107XG4gICAgdmFyIGRpZmYgPSBbXTtcblxuICAgIF8uZXh0ZW5kKHRoaXMsIEJhY2tib25lLkV2ZW50cyk7XG5cbiAgICAvLyBjaGVjayBhbGwgb2YgdGhlIGZpZWxkIHZhbGlkYXRpb24gYmVmb3JlIHN1Ym1pdHRpbmdcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRlbC5maW5kKCcudmFsaWRhdGUnKTtcbiAgICB2YXIgYWJvcnQgPSBmYWxzZTtcbiAgICBfLmVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgdmFyIGlBYm9ydCA9IHZhbGlkYXRlKHsgY3VycmVudFRhcmdldDogY2hpbGQgfSk7XG4gICAgICBhYm9ydCA9IGFib3J0IHx8IGlBYm9ydDtcbiAgICB9KTtcbiAgICBpZiAoYWJvcnQgPT09IHRydWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvL3ZhciB0eXBlcyA9IFtcInRhc2stc2tpbGxzLXJlcXVpcmVkXCIsIFwidGFzay10aW1lLXJlcXVpcmVkXCIsIFwidGFzay1wZW9wbGVcIiwgXCJ0YXNrLWxlbmd0aFwiLCBcInRhc2stdGltZS1lc3RpbWF0ZVwiLCBcInNraWxsXCIsIFwidG9waWNcIiwgXCJsb2NhdGlvblwiXTtcbiAgICB0YWdzID0gdGhpcy5nZXRUYWdzRnJvbVBhZ2UoKTtcbiAgICBvbGRUYWdzID0gdGhpcy5nZXRPbGRUYWdzKCk7XG5cbiAgICBuZXdUYWdzID0gW107XG4gICAgbmV3VGFncyA9IG5ld1RhZ3MuY29uY2F0KHNlbGYuJChcIiN0YXNrX3RhZ190b3BpY3NcIikuc2VsZWN0MignZGF0YScpLHNlbGYuJChcIiN0YXNrX3RhZ19za2lsbHNcIikuc2VsZWN0MignZGF0YScpLHNlbGYuJChcIiN0YXNrX3RhZ19sb2NhdGlvblwiKS5zZWxlY3QyKCdkYXRhJykpO1xuXG4gICAgICBhc3luYy5mb3JFYWNoKFxuICAgICAgICBuZXdUYWdzLFxuICAgICAgICBmdW5jdGlvbihuZXdUYWcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgc2VsZi50YWdGYWN0b3J5LmFkZFRhZ0VudGl0aWVzKG5ld1RhZyxzZWxmLGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIG5leHQoZXJyKTtcbiAgICAgICAgICBzZWxmLnRyaWdnZXIoXCJ0YXNrOnRhZ3M6c2F2ZTpkb25lXCIpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIGRpZmYgPSB0aGlzLnRhZ0ZhY3RvcnkuY3JlYXRlRGlmZihvbGRUYWdzLCB0YWdzKTtcblxuICAgIGlmICggZGlmZi5yZW1vdmUubGVuZ3RoID4gMCApIHtcbiAgICAgIGFzeW5jLmVhY2goZGlmZi5yZW1vdmUsIHNlbGYudGFnRmFjdG9yeS5yZW1vdmVUYWcsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgLy8gZG8gbm90aGluZyBmb3Igbm93XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0VGFnc0Zyb21QYWdlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBHYXRoZXIgdGFncyBmb3Igc3VibWlzc2lvbiBhZnRlciB0aGUgdGFzayBpcyBjcmVhdGVkXG4gICAgdmFyIHRhZ3MgPSBbXTtcbiAgICB0YWdzLnB1c2guYXBwbHkodGFncyx0aGlzLiQoXCIjdGFza190YWdfdG9waWNzXCIpLnNlbGVjdDIoJ2RhdGEnKSk7XG4gICAgdGFncy5wdXNoLmFwcGx5KHRhZ3MsdGhpcy4kKFwiI3Rhc2tfdGFnX3NraWxsc1wiKS5zZWxlY3QyKCdkYXRhJykpO1xuICAgIHRhZ3MucHVzaC5hcHBseSh0YWdzLHRoaXMuJChcIiN0YXNrX3RhZ19sb2NhdGlvblwiKS5zZWxlY3QyKCdkYXRhJykpO1xuICAgIHRhZ3MucHVzaC5hcHBseSh0YWdzLFt0aGlzLiQoXCIjc2tpbGxzLXJlcXVpcmVkXCIpLnNlbGVjdDIoJ2RhdGEnKV0pO1xuICAgIHRhZ3MucHVzaC5hcHBseSh0YWdzLFt0aGlzLiQoXCIjcGVvcGxlXCIpLnNlbGVjdDIoJ2RhdGEnKV0pO1xuICAgIHRhZ3MucHVzaC5hcHBseSh0YWdzLFt0aGlzLiQoXCIjdGltZS1yZXF1aXJlZFwiKS5zZWxlY3QyKCdkYXRhJyldKTtcbiAgICB0YWdzLnB1c2guYXBwbHkodGFncyxbdGhpcy4kKFwiI3RpbWUtZXN0aW1hdGVcIikuc2VsZWN0MignZGF0YScpXSk7XG4gICAgdGFncy5wdXNoLmFwcGx5KHRhZ3MsW3RoaXMuJChcIiNsZW5ndGhcIikuc2VsZWN0MignZGF0YScpXSk7XG5cbiAgICByZXR1cm4gdGFncztcbiAgfSxcblxuICBnZXRPbGRUYWdzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgb2xkVGFncyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLm9wdGlvbnMudGFncykge1xuICAgICAgICBvbGRUYWdzLnB1c2goe1xuICAgICAgICAgIGlkOiBwYXJzZUludCh0aGlzLm9wdGlvbnMudGFnc1tpXS5pZCksXG4gICAgICAgICAgdGFnSWQ6IHBhcnNlSW50KHRoaXMub3B0aW9ucy50YWdzW2ldLnRhZy5pZCksXG4gICAgICAgICAgdHlwZTogdGhpcy5vcHRpb25zLnRhZ3NbaV0udGFnLnR5cGVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICByZXR1cm4gb2xkVGFncztcbiAgfSxcblxuICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMubWQpIHsgdGhpcy5tZC5jbGVhbnVwKCk7IH1cbiAgICByZW1vdmVWaWV3KHRoaXMpO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRhc2tFZGl0Rm9ybVZpZXc7XG4iLCJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciBVdGlsaXRpZXMgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgQm9vdHN0cmFwID0gcmVxdWlyZSgnYm9vdHN0cmFwJyk7XG52YXIgVGFza3NDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vZW50aXRpZXMvdGFza3MvdGFza3NfY29sbGVjdGlvbicpO1xudmFyIFRhc2tDb2xsZWN0aW9uVmlldyA9IHJlcXVpcmUoJy4uL3ZpZXdzL3Rhc2tfY29sbGVjdGlvbl92aWV3Jyk7XG52YXIgVGFza0Zvcm1WaWV3ID0gcmVxdWlyZSgnLi4vLi4vbmV3L3ZpZXdzL3Rhc2tfZm9ybV92aWV3Jyk7XG52YXIgTW9kYWxXaXphcmRDb21wb25lbnQgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb21wb25lbnRzL21vZGFsX3dpemFyZCcpO1xudmFyIFRhc2tNb2RlbCA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2VudGl0aWVzL3Rhc2tzL3Rhc2tfbW9kZWwnKTtcblxuVGFza0xpc3QgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG5cbiAgZWw6IFwiI3Rhc2stbGlzdC13cmFwcGVyXCIsXG5cbiAgZXZlbnRzOiB7XG4gICAgJ2NsaWNrIC5hZGQtdGFzaycgOiAnYWRkJyxcbiAgICAnY2xpY2sgLnNob3ctdGFzayc6ICdzaG93JyxcbiAgICAnY2xpY2sgLnRhc2snICAgICA6ICdzaG93JyxcbiAgICAnY2xpY2sgLndpemFyZCcgICA6ICd3aXphcmQnXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKHNldHRpbmdzKSB7XG4gICAgdGhpcy5vcHRpb25zID0gXy5leHRlbmQoc2V0dGluZ3MsIHRoaXMuZGVmYXVsdHMpO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuaW5pdGlhbGl6ZVRhc2tDb2xsZWN0aW9uSW5zdGFuY2UoKTtcbiAgICB0aGlzLmluaXRpYWxpemVUYXNrTW9kZWxJbnN0YW5jZSgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZUxpc3RlbmVycygpO1xuICAgIHRoaXMucmVxdWVzdFRhc2tzQ29sbGVjdGlvbkRhdGEoKTtcblxuICAgIHRoaXMuY29sbGVjdGlvbi5vbihcInRhc2tzOnJlbmRlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLnJlcXVlc3RUYXNrc0NvbGxlY3Rpb25EYXRhKClcbiAgICB9KVxuICB9LFxuXG4gIGluaXRpYWxpemVMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMudGFza01vZGVsLCAndGFzazp0YWdzOnNhdmU6c3VjY2VzcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuaW5pdGlhbGl6ZVRhc2tNb2RlbEluc3RhbmNlKCk7XG4gICAgICBzZWxmLnJlcXVlc3RUYXNrc0NvbGxlY3Rpb25EYXRhKCk7XG4gICAgfSk7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZVRhc2tNb2RlbEluc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50YXNrTW9kZWwgPSBuZXcgVGFza01vZGVsKCk7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZVRhc2tDb2xsZWN0aW9uSW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5jb2xsZWN0aW9uKSB7XG4gICAgICB0aGlzLmNvbGxlY3Rpb24uaW5pdGlhbGl6ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbGxlY3Rpb24gPSBuZXcgVGFza3NDb2xsZWN0aW9uKCk7XG4gICAgfVxuICB9LFxuXG4gIHJlcXVlc3RUYXNrc0NvbGxlY3Rpb25EYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5jb2xsZWN0aW9uLmZldGNoKHtcbiAgICAgIHVybDogJy9hcGkvdGFzay9maW5kQWxsQnlQcm9qZWN0SWQvJyArIHBhcnNlSW50KHRoaXMub3B0aW9ucy5wcm9qZWN0SWQpLFxuICAgICAgc3VjY2VzczogZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgc2VsZi50YXNrcyA9IGNvbGxlY3Rpb247XG4gICAgICAgIHNlbGYucmVuZGVyVGFza0NvbGxlY3Rpb25WaWV3KClcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICByZW5kZXJUYXNrQ29sbGVjdGlvblZpZXc6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy50YXNrQ29sbGVjdGlvblZpZXcpIHRoaXMudGFza0NvbGxlY3Rpb25WaWV3LmNsZWFudXAoKTtcbiAgICB0aGlzLnRhc2tDb2xsZWN0aW9uVmlldyA9IG5ldyBUYXNrQ29sbGVjdGlvblZpZXcoe1xuICAgICAgZWw6IFwiI3Rhc2stbGlzdC13cmFwcGVyXCIsXG4gICAgICBvblJlbmRlcjogdHJ1ZSxcbiAgICAgIGNvbGxlY3Rpb246IHNlbGYudGFza3NcbiAgICB9KTtcbiAgfSxcblxuICBhZGQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy50YXNrRm9ybVZpZXcpIHRoaXMudGFza0Zvcm1WaWV3LmNsZWFudXAoKTtcbiAgICBpZiAodGhpcy5tb2RhbFdpemFyZENvbXBvbmVudCkgdGhpcy5tb2RhbFdpemFyZENvbXBvbmVudC5jbGVhbnVwKCk7XG4gICAgdGhpcy5tb2RhbFdpemFyZENvbXBvbmVudCA9IG5ldyBNb2RhbFdpemFyZENvbXBvbmVudCh7XG4gICAgICBlbDogXCIud3JhcHBlci1hZGRUYXNrXCIsXG4gICAgICBpZDogXCJhZGRUYXNrXCIsXG4gICAgICBtb2RhbFRpdGxlOiAnTmV3IE9wcG9ydHVuaXR5JyxcbiAgICAgIG1vZGVsOiBzZWxmLnRhc2tNb2RlbCxcbiAgICAgIGNvbGxlY3Rpb246IHNlbGYudGFza3MsXG4gICAgICBtb2RlbE5hbWU6ICd0YXNrJyxcbiAgICAgIGRhdGE6IGZ1bmN0aW9uIChwYXJlbnQpIHsgcmV0dXJuIHtcbiAgICAgICAgdGl0bGU6IHBhcmVudC4kKFwiI3Rhc2stdGl0bGVcIikudmFsKCksXG4gICAgICAgIGRlc2NyaXB0aW9uOiBwYXJlbnQuJChcIiN0YXNrLWRlc2NyaXB0aW9uXCIpLnZhbCgpLFxuICAgICAgICBwcm9qZWN0SWQ6IHNlbGYub3B0aW9ucy5wcm9qZWN0SWRcbiAgICAgIH0gfVxuICAgIH0pLnJlbmRlcigpO1xuXG4gICAgdGhpcy50YXNrRm9ybVZpZXcgPSBuZXcgVGFza0Zvcm1WaWV3KHtcbiAgICAgIGVsOiBcIi5tb2RhbC1ib2R5XCIsXG4gICAgICBwcm9qZWN0SWQ6IHRoaXMub3B0aW9ucy5wcm9qZWN0SWQsXG4gICAgICBtb2RlbDogc2VsZi50YXNrTW9kZWwsXG4gICAgICB0YXNrczogc2VsZi50YXNrc1xuICAgIH0pLnJlbmRlcigpO1xuICAgIHRoaXMubW9kYWxXaXphcmRDb21wb25lbnQuc2V0Q2hpbGRWaWV3KHRoaXMudGFza0Zvcm1WaWV3KTtcbiAgICB0aGlzLm1vZGFsV2l6YXJkQ29tcG9uZW50LnNldE5leHQodGhpcy50YXNrRm9ybVZpZXcuY2hpbGROZXh0KTtcbiAgICB0aGlzLm1vZGFsV2l6YXJkQ29tcG9uZW50LnNldFN1Ym1pdCh0aGlzLnRhc2tGb3JtVmlldy5jaGlsZE5leHQpO1xuICB9LFxuXG4gIHNob3c6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB2YXIgcHJvamVjdElkID0gJChlLmN1cnJlbnRUYXJnZXQpLmRhdGEoJ3Byb2plY3RpZCcpLFxuICAgICAgICB0YXNrSWQgICAgPSAkKGUuY3VycmVudFRhcmdldCkuZGF0YSgnaWQnKTtcblxuICAgIGlmICh0YXNrSWQgPT0gJ251bGwnKSB7IHJldHVybjsgfVxuXG4gICAgQmFja2JvbmUuaGlzdG9yeS5uYXZpZ2F0ZSgndGFza3MvJyArIHRhc2tJZCwgeyB0cmlnZ2VyOiB0cnVlIH0sIHRhc2tJZCk7XG4gIH0sXG5cbiAgY2xlYW51cDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnRhc2tGb3JtVmlldykgdGhpcy50YXNrRm9ybVZpZXcuY2xlYW51cCgpO1xuICAgIGlmICh0aGlzLm1vZGFsV2l6YXJkQ29tcG9uZW50KSB0aGlzLm1vZGFsV2l6YXJkQ29tcG9uZW50LmNsZWFudXAoKTtcbiAgICBpZiAodGhpcy50YXNrQ29sbGVjdGlvblZpZXcpIHRoaXMudGFza0NvbGxlY3Rpb25WaWV3LmNsZWFudXAoKTtcbiAgICByZW1vdmVWaWV3KHRoaXMpO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRhc2tMaXN0O1xuXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwiYm94LXBhZC1sciBib3JkZXItYm90dG9tXFxcIj5cXG4gIDxoMj5cXG4gICAgQXZhaWxhYmxlIE9wcG9ydHVuaXRpZXNcXG4gICAgPCUgaWYgKHVzZXIpIHsgJT5cXG4gICAgPGEgaHJlZj1cXFwiI2FkZFRhc2tcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWMwIGJ0bi1zbSBmaWxlLWFkZCBhZGQtdGFza1xcXCIgZGF0YS10b2dnbGU9XFxcIm1vZGFsXFxcIiBkYXRhLWJhY2tkcm9wPVxcXCJzdGF0aWNcXFwiPkFkZCBPcHBvcnR1bml0eTwvYT5cXG4gICAgPCUgfSAlPlxcbiAgPC9oMj5cXG48L2Rpdj5cXG5cXG48ZGl2IGNsYXNzPVxcXCJ0YXNrLXNjcm9sbFxcXCI+XFxuICA8JSBpZiAodGFza3MubGVuZ3RoID09IDApIHsgJT5cXG4gIDxkaXYgY2xhc3M9XFxcInRhc2sgYm9yZGVyLWxlZnRcXFwiIGRhdGEtaWQ9XFxcIm51bGxcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ0YXNrLXRpdGxlXFxcIj5cXG4gICAgICBObyBjdXJyZW50IG9wcG9ydHVuaXRpZXMuXFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuICA8JSB9ICU+XFxuICA8JSBfLmVhY2godGFza3MsIGZ1bmN0aW9uKHRhc2spIHsgJT5cXG4gIDxkaXYgY2xhc3M9XFxcInRhc2sgYm9yZGVyLWxlZnRcXFwiIGRhdGEtcHJvamVjdGlkPVxcXCI8JT0gdGFzay5wcm9qZWN0SWQgJT5cXFwiIGRhdGEtaWQ9XFxcIjwlPSB0YXNrLmlkICU+XFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwicHVsbC1yaWdodFxcXCI+XFxuICAgICAgPHN0cm9uZz48JT0gdGFzay5zdGF0ZSAlPjwvc3Ryb25nPlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwidGFzay10aXRsZVxcXCI+XFxuICAgICAgPGEgaHJlZj1cXFwiL3Rhc2tzLzwlLSB0YXNrLmlkICU+XFxcIiBjbGFzcz1cXFwic2hvdy10YXNrXFxcIiBkYXRhLXByb2plY3RpZD1cXFwiPCU9IHRhc2sucHJvamVjdElkICU+XFxcIiBkYXRhLWlkPVxcXCI8JT0gdGFzay5pZCAlPlxcXCI+PCUtIHRhc2sudGl0bGUgJT48L2E+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ0YXNrLWRlc2NyaXB0aW9uXFxcIj5cXG4gICAgICA8JT0gdGFzay5kZXNjcmlwdGlvbiAlPlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwidGFzay10YWdzLXJvd1xcXCI+XFxuICAgICAgPHVsIGNsYXNzPVxcXCJ0YWdzIHRhc2stdGFnc1xcXCI+XFxuICAgICAgICA8JSBfLmVhY2godGFzay50YWdzLCBmdW5jdGlvbiAodGFnKSB7ICU+XFxuICAgICAgICAgIDxsaT48JT0gdGFnLnRhZy5uYW1lICU+PC9saT5cXG4gICAgICAgIDwlIH0pOyAlPlxcbiAgICAgIDwvdWw+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuICA8JSB9KSAlPlxcbjwvZGl2PlxcblwiO1xuIiwiXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgYXN5bmMgPSByZXF1aXJlKCdhc3luYycpO1xudmFyIG1hcmtlZCA9IHJlcXVpcmUoJ21hcmtlZCcpO1xudmFyIFRhc2tMaXN0VGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvdGFza19jb2xsZWN0aW9uX3ZpZXdfdGVtcGxhdGUuaHRtbCcpO1xuXG5cblx0dmFyIFRhc2tzQ29sbGVjdGlvblZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG5cblx0XHRlbDogXCIjdGFzay1saXN0LXdyYXBwZXJcIixcblxuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdFx0dGhpcy5yZXF1ZXN0VGFnRGF0YSgpO1xuXHRcdH0sXG5cblx0XHRyZXF1ZXN0VGFnRGF0YTogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0XHR0aGlzLnRhc2tzSnNvbiA9IHtcblx0XHRcdFx0dGFza3M6IHRoaXMub3B0aW9ucy5jb2xsZWN0aW9uLnRvSlNPTigpLFxuXHRcdFx0XHR1c2VyOiB3aW5kb3cuY2FjaGUuY3VycmVudFVzZXJcblx0XHRcdH07XG5cblx0XHRcdHZhciByZXF1ZXN0VGFnRGF0YSA9IGZ1bmN0aW9uICh0YXNrLCBkb25lKSB7XG5cdFx0XHRcdCQuYWpheCh7XG5cdFx0XHRcdFx0dXJsOiAnL2FwaS90YWcvZmluZEFsbEJ5VGFza0lkLycgKyB0YXNrLmlkLFxuXHRcdFx0XHRcdGFzeW5jOiBmYWxzZSxcblx0XHRcdFx0XHRzdWNjZXNzOiBmdW5jdGlvbiAodGFncykge1xuXHRcdFx0XHRcdFx0dGFza1sndGFncyddID0gdGFncztcblx0XHRcdFx0XHRcdGRvbmUoKTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGVycm9yOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHR0YXNrWyd0YWdzJ10gPSBbXTtcblx0XHRcdFx0XHRcdGRvbmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRhc3luYy5lYWNoKHRoaXMudGFza3NKc29uLnRhc2tzLCByZXF1ZXN0VGFnRGF0YSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRzZWxmLnJlbmRlcigpO1xuXHRcdFx0fSk7XG5cblx0XHR9LFxuXG5cdFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRfLmVhY2godGhpcy50YXNrc0pzb24udGFza3MsIGZ1bmN0aW9uKHRhc2spIHtcblx0XHRcdFx0dGFzay5kZXNjcmlwdGlvbiA9IG1hcmtlZCh0YXNrLmRlc2NyaXB0aW9uKTtcblx0XHRcdH0pO1xuXHRcdFx0dGhpcy5jb21waWxlZFRlbXBsYXRlID0gXy50ZW1wbGF0ZShUYXNrTGlzdFRlbXBsYXRlKSh0aGlzLnRhc2tzSnNvbik7XG5cdFx0XHR0aGlzLiRlbC5odG1sKHRoaXMuY29tcGlsZWRUZW1wbGF0ZSk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHRjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVWaWV3KHRoaXMpO1xuXHRcdH1cblxuXHR9KTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IFRhc2tzQ29sbGVjdGlvblZpZXc7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGZvcm0gaWQ9XFxcInRhc2stZm9ybVxcXCIgY2xhc3M9XFxcImZvcm0taW5saW5lXFxcIiBhY3Rpb249XFxcIi9hcGkvdGFza1xcXCI+XFxuXFxuICA8c2VjdGlvbiBpZD1cXFwic2VjdGlvbi0xXFxcIiBjbGFzcz1cXFwiY3VycmVudFxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXAgZnVsbHdpZHRoXFxcIj5cXG4gICAgICA8bGFiZWwgZm9yPVxcXCJ0YXNrLXRpdGxlXFxcIj5cXG4gICAgICAgIFdoYXQgcHJvYmxlbSBhcmUgeW91IHRyeWluZyB0byBzb2x2ZT9cXG4gICAgICA8L2xhYmVsPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMTJcXFwiPlxcbiAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgaWQ9XFxcInRhc2stdGl0bGVcXFwiIGNsYXNzPVxcXCJmdWxsd2lkdGggZm9ybS1jb250cm9sIHZhbGlkYXRlXFxcIiBwbGFjZWhvbGRlcj1cXFwiQSBzaG9ydCBkZXNjcmlwdGlvbiBvZiB0aGUgcHJvYmxlbS5cXFwiIGRhdGEtdmFsaWRhdGU9XFxcImVtcHR5LGNvdW50MTAwXFxcIi8+XFxuICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJoZWxwLWJsb2NrIGVycm9yLWVtcHR5XFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI+WW91IG11c3QgZW50ZXIgYSB0aXRsZSBmb3IgdGhpcyA8c3BhbiBkYXRhLWkxOG49XFxcInRhc2tcXFwiPm9wcG9ydHVuaXR5PC9zcGFuPjwvc3Bhbj5cXG4gICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImhlbHAtYmxvY2sgZXJyb3ItY291bnQxMDBcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIj5UaGUgc2hvcnQgZGVzY3JpcHRpb24gb2YgdGhlIHByb2JsZW0gbXVzdCBiZSBsZXNzIHRoYW4gMTAwIGNoYXJhY3RlcnMuPC9zcGFuPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9zZWN0aW9uPlxcblxcbiAgPHNlY3Rpb24gaWQ9XFxcInNlY3Rpb24tMlxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXAgZnVsbHdpZHRoXFxcIj5cXG4gICAgICA8bGFiZWwgZm9yPVxcXCJwZW9wbGVcXFwiPlxcbiAgICAgICAgV2UgbmVlZFxcbiAgICAgIDwvbGFiZWw+XFxuICAgICAgPHNlbGVjdCBpZD1cXFwicGVvcGxlXFxcIiBjbGFzcz1cXFwiZHJvcGRvd25cXFwiPlxcbiAgICAgICAgPCUgXy5lYWNoKHRhZ3NbJ3Rhc2stcGVvcGxlJ10sIGZ1bmN0aW9uIChwZXJzb24pIHsgJT5cXG4gICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiPCU9IHBlcnNvbi5pZCAlPlxcXCI+PCU9IHBlcnNvbi5uYW1lICU+PC9vcHRpb24+XFxuICAgICAgICA8JSB9KTsgJT5cXG4gICAgICA8L3NlbGVjdD5cXG5cXG4gICAgICA8bGFiZWwgZm9yPVxcXCJ0b3BpY3NcXFwiPlxcbiAgICAgICAgdG8gd29yayBvbiBhbiA8c3BhbiBkYXRhLWkxOG49XFxcInRhc2tcXFwiPm9wcG9ydHVuaXR5PC9zcGFuPiBhYm91dCB0aGVzZSB0b3BpY3M6XFxuICAgICAgPC9sYWJlbD5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTEyXFxcIj5cXG4gICAgICAgICAgPGlucHV0IHR5cGU9XFxcImhpZGRlblxcXCIgaWQ9XFxcInRhc2tfdGFnX3RvcGljc1xcXCIgY2xhc3M9XFxcImZ1bGx3aWR0aFxcXCIgbmFtZT1cXFwidG9waWNcXFwiIC8+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxoci8+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXAgZnVsbHdpZHRoXFxcIj5cXG4gICAgICA8bGFiZWwgZm9yPVxcXCJza2lsbHMtcmVxdWlyZWRcXFwiPlxcbiAgICAgICAgVGhlIGZvbGxvd2luZyBza2lsbHMgYXJlIHVzZWZ1bCBhbmRcXG4gICAgICA8L2xhYmVsPlxcbiAgICAgIDxzZWxlY3QgaWQ9XFxcInNraWxscy1yZXF1aXJlZFxcXCIgbmFtZT1cXFwic2tpbGxzLXJlcXVpcmVkXFxcIiBjbGFzcz1cXFwiZHJvcGRvd25cXFwiPlxcbiAgICAgICAgPCUgXy5lYWNoKHRhZ3NbJ3Rhc2stc2tpbGxzLXJlcXVpcmVkJ10sIGZ1bmN0aW9uKHJlcXVpcmVtZW50KSB7ICU+XFxuICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIjwlPSByZXF1aXJlbWVudC5pZCAlPlxcXCI+PCU9IHJlcXVpcmVtZW50Lm5hbWUgJT48L29wdGlvbj5cXG4gICAgICAgIDwlIH0pOyAlPlxcbiAgICAgIDwvc2VsZWN0PlxcbiAgICAgIDxsYWJlbCBmb3I9XFxcInNraWxsc1xcXCI+XFxuICAgICAgICB0byBjb21wbGV0ZSB0aGlzIDxzcGFuIGRhdGEtaTE4bj1cXFwidGFza1xcXCI+b3Bwb3J0dW5pdHk8L3NwYW4+OlxcbiAgICAgIDwvbGFiZWw+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0xMlxcXCI+XFxuICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJoaWRkZW5cXFwiIGlkPVxcXCJ0YXNrX3RhZ19za2lsbHNcXFwiIG5hbWU9XFxcInNraWxsc1xcXCIgY2xhc3M9XFxcImZ1bGx3aWR0aFxcXCIgLz5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gIDwvc2VjdGlvbj5cXG5cXG4gIDxzZWN0aW9uIGlkPVxcXCJzZWN0aW9uLTNcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwIGZ1bGx3aWR0aFxcXCI+XFxuICAgICAgPGxhYmVsIGZvcj1cXFwidGltZS1lc3RpbWF0ZVxcXCI+XFxuICAgICAgICBUaGUgPHNwYW4gZGF0YS1pMThuPVxcXCJ0YXNrXFxcIj5vcHBvcnR1bml0eTwvc3Bhbj4gd2lsbCByZXF1aXJlXFxuICAgICAgPC9sYWJlbD5cXG4gICAgICA8c2VsZWN0IGlkPVxcXCJ0aW1lLWVzdGltYXRlXFxcIiBjbGFzcz1cXFwiZHJvcGRvd25cXFwiPlxcbiAgICAgICAgPCUgXy5lYWNoKHRhZ3NbJ3Rhc2stdGltZS1lc3RpbWF0ZSddLCBmdW5jdGlvbiAodGltZUVzdGltYXRlKSB7ICU+XFxuICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIjwlPSB0aW1lRXN0aW1hdGUuaWQgJT5cXFwiPjwlPSB0aW1lRXN0aW1hdGUubmFtZSAlPjwvb3B0aW9uPlxcbiAgICAgICAgPCUgfSk7ICU+XFxuICAgICAgPC9zZWxlY3Q+XFxuXFxuICAgICAgPGxhYmVsIGZvcj1cXFwidGltZS1yZXF1aXJlZFxcXCI+XFxuICAgICAgICBvZlxcbiAgICAgIDwvbGFiZWw+XFxuICAgICAgPHNlbGVjdCBpZD1cXFwidGltZS1yZXF1aXJlZFxcXCIgY2xhc3M9XFxcImRyb3Bkb3duXFxcIj5cXG4gICAgICAgIDwlIF8uZWFjaCh0YWdzWyd0YXNrLXRpbWUtcmVxdWlyZWQnXSwgZnVuY3Rpb24gKHRpbWUpIHsgJT5cXG4gICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiPCU9IHRpbWUuaWQgJT5cXFwiPjwlPSB0aW1lLm5hbWUgJT48L29wdGlvbj5cXG4gICAgICAgIDwlIH0pOyAlPlxcbiAgICAgIDwvc2VsZWN0PlxcblxcbiAgICAgIDxsYWJlbCBmb3I9XFxcImxlbmd0aFxcXCI+XFxuICAgICAgICB3b3JrLCBhbmQgbXVzdCBiZSBjb21wbGV0ZWQgd2l0aGluXFxuICAgICAgPC9sYWJlbD5cXG4gICAgICA8c2VsZWN0IGlkPVxcXCJsZW5ndGhcXFwiIGNsYXNzPVxcXCJkcm9wZG93blxcXCI+XFxuICAgICAgICA8JSBfLmVhY2godGFnc1sndGFzay1sZW5ndGgnXSwgZnVuY3Rpb24gKGl0ZW0pIHsgJT5cXG4gICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiPCU9IGl0ZW0uaWQgJT5cXFwiPjwlPSBpdGVtLm5hbWUgJT48L29wdGlvbj5cXG4gICAgICAgIDwlIH0pICU+XFxuICAgICAgPC9zZWxlY3Q+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8aHIvPlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwIGZ1bGx3aWR0aFxcXCI+XFxuICAgICAgPGxhYmVsIGZvcj1cXFwidGFzay1sb2NhdGlvblxcXCI+XFxuICAgICAgICBUaGUgdm9sdW50ZWVyKHMpIG11c3QgYmUgbG9jYXRlZFxcbiAgICAgIDwvbGFiZWw+XFxuICAgICAgPHNlbGVjdCBpZD1cXFwidGFzay1sb2NhdGlvblxcXCIgY2xhc3M9XFxcImRyb3Bkb3duXFxcIj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcImZhbHNlXFxcIj5hbnl3aGVyZTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwidHJ1ZVxcXCI+YXQgc3BlY2lmaWMgbG9jYXRpb24ocyk8L29wdGlvbj5cXG4gICAgICA8L3NlbGVjdD4gdG8gY29tcGxldGUgdGhpcyB0YXNrLlxcblxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInJvdyBlbC1zcGVjaWZpYy1sb2NhdGlvblxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMTJcXFwiPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwIHRhc2stc2tpbGxzIGZ1bGx3aWR0aFxcXCI+XFxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cXFwibG9jYXRpb25cXFwiPlxcbiAgICAgICAgICAgICAgVGhlIHNwZWNpZmljIGxvY2F0aW9uKHMpIGFyZTpcXG4gICAgICAgICAgICA8L2xhYmVsPlxcbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJoaWRkZW5cXFwiIGlkPVxcXCJ0YXNrX3RhZ19sb2NhdGlvblxcXCIgbmFtZT1cXFwibG9jYXRpb25cXFwiIGNsYXNzPVxcXCJmdWxsd2lkdGhcXFwiLz5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICA8L3NlY3Rpb24+XFxuXFxuICA8c2VjdGlvbiBpZD1cXFwic2VjdGlvbi00XFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cCBmdWxsd2lkdGhcXFwiPlxcbiAgICAgIDxsYWJlbCBmb3I9XFxcInRhc2stZGVzY3JpcHRpb25cXFwiPlxcbiAgICAgICAgRGVzY3JpYmUgdGhlIDxzcGFuIGRhdGEtaTE4bj1cXFwidGFza1xcXCI+b3Bwb3J0dW5pdHk8L3NwYW4+IGRldGFpbHMsIGluY2x1ZGluZyBnb2FscywgZXhwZWN0ZWQgb3V0Y29tZXMgYW5kIGRlbGl2ZXJhYmxlcy5cXG4gICAgICA8L2xhYmVsPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMTJcXFwiPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtYXJrZG93bi1lZGl0XFxcIj48L2Rpdj5cXG4gICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImhlbHAtYmxvY2sgZXJyb3ItZW1wdHlcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIj5Zb3UgbXVzdCBlbnRlciBhIGRlc2NyaXB0aW9uIGZvciB0aGlzIDxzcGFuIGRhdGEtaTE4bj1cXFwidGFza1xcXCI+b3Bwb3J0dW5pdHk8L3NwYW4+PC9zcGFuPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9zZWN0aW9uPlxcblxcbjwvZm9ybT5cXG5cIjtcbiIsInZhciBCb290c3RyYXAgPSByZXF1aXJlKCdib290c3RyYXAnKTtcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciBhc3luYyA9IHJlcXVpcmUoJ2FzeW5jJyk7XG52YXIgdXRpbGl0aWVzID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vbWl4aW5zL3V0aWxpdGllcycpO1xudmFyIE1hcmtkb3duRWRpdG9yID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29tcG9uZW50cy9tYXJrZG93bl9lZGl0b3InKTtcbnZhciBUYXNrc0NvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9lbnRpdGllcy90YXNrcy90YXNrc19jb2xsZWN0aW9uJyk7XG52YXIgVGFza0Zvcm1UZW1wbGF0ZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy90YXNrX2Zvcm1fdGVtcGxhdGUuaHRtbCcpO1xudmFyIFRhZ0ZhY3RvcnkgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb21wb25lbnRzL3RhZ19mYWN0b3J5Jyk7XG5cblxudmFyIFRhc2tGb3JtVmlldyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcblxuICBlbDogXCIjdGFzay1saXN0LXdyYXBwZXJcIixcblxuICBldmVudHM6IHtcbiAgICBcImNoYW5nZSAudmFsaWRhdGVcIiAgICAgICAgOiBcInZcIixcbiAgICBcImNoYW5nZSAjdGFzay1sb2NhdGlvblwiIDogXCJsb2NhdGlvbkNoYW5nZVwiXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBfLmV4dGVuZChvcHRpb25zLCB0aGlzLmRlZmF1bHRzKTtcbiAgICB0aGlzLnRhc2tzID0gdGhpcy5vcHRpb25zLnRhc2tzO1xuICAgIHRoaXMudGFnRmFjdG9yeSA9IG5ldyBUYWdGYWN0b3J5KCk7XG4gICAgdGhpcy5kYXRhID0ge307XG4gICAgdGhpcy5kYXRhLm5ld1RhZyA9IHt9O1xuICAgIHRoaXMuZGF0YS5uZXdJdGVtVGFncyA9IFtdO1xuICAgIHRoaXMuZGF0YS5leGlzdGluZ1RhZ3MgPSBbXTtcbiAgICB0aGlzLmluaXRpYWxpemVTZWxlY3QyRGF0YSgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZUxpc3RlbmVycygpO1xuICB9LFxuXG4gIGluaXRpYWxpemVTZWxlY3QyRGF0YTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdHlwZXMgPSBbXCJ0YXNrLXNraWxscy1yZXF1aXJlZFwiLCBcInRhc2stdGltZS1yZXF1aXJlZFwiLCBcInRhc2stcGVvcGxlXCIsIFwidGFzay1sZW5ndGhcIiwgXCJ0YXNrLXRpbWUtZXN0aW1hdGVcIl07XG5cbiAgICB0aGlzLnRhZ1NvdXJjZXMgPSB7fTtcblxuICAgIHZhciByZXF1ZXN0QWxsVGFnc0J5VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAkLmFqYXgoe1xuICAgICAgICB1cmw6ICcvYXBpL2FjL3RhZz90eXBlPScgKyB0eXBlICsgJyZsaXN0JyxcbiAgICAgICAgdHlwZTogJ0dFVCcsXG4gICAgICAgIGFzeW5jOiBmYWxzZSxcbiAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICBzZWxmLnRhZ1NvdXJjZXNbdHlwZV0gPSBkYXRhO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYy5lYWNoKHR5cGVzLCByZXF1ZXN0QWxsVGFnc0J5VHlwZSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgc2VsZi5yZW5kZXIoKTtcbiAgICB9KTtcbiAgfSxcblxuICBpbml0aWFsaXplTGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBfLmV4dGVuZCh0aGlzLCBCYWNrYm9uZS5FdmVudHMpO1xuXG4gICAgc2VsZi5vbignbmV3VGFnU2F2ZURvbmUnLGZ1bmN0aW9uICgpe1xuXG4gICAgICB0YWdzICAgICAgICAgPSBbXTtcbiAgICAgIHZhciB0ZW1wVGFncyA9IFtdO1xuXG4gICAgICAvL2dldCBuZXdseSBjcmVhdGVkIHRhZ3MgZnJvbSBiaWcgdGhyZWUgdHlwZXNcbiAgICAgIF8uZWFjaChzZWxmLmRhdGEubmV3SXRlbVRhZ3MsIGZ1bmN0aW9uKG5ld0l0ZW1UYWcpe1xuICAgICAgICB0YWdzLnB1c2gobmV3SXRlbVRhZyk7XG4gICAgICB9KTtcblxuICAgICAgdGVtcFRhZ3MucHVzaC5hcHBseSh0ZW1wVGFncyxzZWxmLiQoXCIjdGFza190YWdfdG9waWNzXCIpLnNlbGVjdDIoJ2RhdGEnKSk7XG4gICAgICB0ZW1wVGFncy5wdXNoLmFwcGx5KHRlbXBUYWdzLHNlbGYuJChcIiN0YXNrX3RhZ19za2lsbHNcIikuc2VsZWN0MignZGF0YScpKTtcbiAgICAgIGlmIChzZWxmLiQoXCIjdGFzay1sb2NhdGlvblwiKS5zZWxlY3QyKCdkYXRhJykuaWQgPT0gJ3RydWUnKSB7XG4gICAgICAgIHRlbXBUYWdzLnB1c2guYXBwbHkodGVtcFRhZ3Msc2VsZi4kKFwiI3Rhc2tfdGFnX2xvY2F0aW9uXCIpLnNlbGVjdDIoJ2RhdGEnKSk7XG4gICAgICB9XG5cbiAgICAgIC8vc2VlIGlmIHRoZXJlIGFyZSBhbnkgcHJldmlvdXNseSBjcmVhdGVkIGJpZyB0aHJlZSB0YWdzIGFuZCBhZGQgdGhlbSB0byB0aGUgdGFnIGFycmF5XG4gICAgICBfLmVhY2godGVtcFRhZ3MsZnVuY3Rpb24odGVtcFRhZyl7XG4gICAgICAgICAgaWYgKCB0ZW1wVGFnLmlkICE9PSB0ZW1wVGFnLm5hbWUgKXtcbiAgICAgICAgICB0YWdzLnB1c2godGVtcFRhZyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBfLmVhY2godGhpcy5kYXRhLmV4aXN0aW5nVGFncywgZnVuY3Rpb24odGVtcFRhZykge1xuICAgICAgICAgIHRhZ3MucHVzaCh0ZW1wVGFnKTtcbiAgICAgIH0pO1xuXG4gICAgICBhc3luYy5mb3JFYWNoKFxuICAgICAgICB0YWdzLFxuICAgICAgICBmdW5jdGlvbih0YWcsIGNhbGxiYWNrKXtcbiAgICAgICAgICAvL2RpZmZBZGQsc2VsZi5tb2RlbC5hdHRyaWJ1dGVzLmlkLFwidGFza0lkXCIsY2FsbGJhY2tcbiAgICAgICAgICByZXR1cm4gc2VsZi50YWdGYWN0b3J5LmFkZFRhZyh0YWcsc2VsZi50ZW1wVGFza0lkLFwidGFza0lkXCIsY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbihlcnIpe1xuICAgICAgICAgIHNlbGYubW9kZWwudHJpZ2dlcihcInRhc2s6bW9kYWw6aGlkZVwiKTtcbiAgICAgICAgICBzZWxmLm1vZGVsLnRyaWdnZXIoXCJ0YXNrOnRhZ3M6c2F2ZTpzdWNjZXNzXCIsIGVycik7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmxpc3RlblRvKHRoaXMudGFza3MsXCJ0YXNrOnNhdmU6c3VjY2Vzc1wiLCBmdW5jdGlvbiAodGFza0lkKXtcbiAgICAgIC8vdGhlIG9ubHkgY29uY2VybiBoZXJlIGlzIHRvIGFkZCBuZXdseSBjcmVhdGVkIHRhZ3Mgd2hpY2ggaXMgb25seSBhdmFpbGFibGUgaW4gdGhlIHRocmVlIGl0ZW1zIGJlbG93XG4gICAgICAvL1xuXG4gICAgICBzZWxmLnRlbXBUYXNrSWQgPSB0YXNrSWQ7XG5cbiAgICAgIC8vIHNhdmUgdGhlIHRhZ3MgZnJvbSB0aGUgZHJvcCBkb3duc1xuICAgICAgdGhpcy5kYXRhLmV4aXN0aW5nVGFncy5wdXNoKHNlbGYuJChcIiNza2lsbHMtcmVxdWlyZWRcIikuc2VsZWN0MignZGF0YScpKTtcbiAgICAgIHRoaXMuZGF0YS5leGlzdGluZ1RhZ3MucHVzaChzZWxmLiQoXCIjcGVvcGxlXCIpLnNlbGVjdDIoJ2RhdGEnKSk7XG4gICAgICB0aGlzLmRhdGEuZXhpc3RpbmdUYWdzLnB1c2goc2VsZi4kKFwiI3RpbWUtcmVxdWlyZWRcIikuc2VsZWN0MignZGF0YScpKTtcbiAgICAgIHRoaXMuZGF0YS5leGlzdGluZ1RhZ3MucHVzaChzZWxmLiQoXCIjdGltZS1lc3RpbWF0ZVwiKS5zZWxlY3QyKCdkYXRhJykpO1xuICAgICAgdGhpcy5kYXRhLmV4aXN0aW5nVGFncy5wdXNoKHNlbGYuJChcIiNsZW5ndGhcIikuc2VsZWN0MignZGF0YScpKTtcblxuICAgICAgdmFyIG5ld1RhZ3MgPSBbXTtcblxuICAgICAgbmV3VGFncyA9IG5ld1RhZ3MuY29uY2F0KHNlbGYuJChcIiN0YXNrX3RhZ190b3BpY3NcIikuc2VsZWN0MignZGF0YScpLHNlbGYuJChcIiN0YXNrX3RhZ19za2lsbHNcIikuc2VsZWN0MignZGF0YScpLHNlbGYuJChcIiN0YXNrX3RhZ19sb2NhdGlvblwiKS5zZWxlY3QyKCdkYXRhJykpO1xuXG4gICAgICBhc3luYy5mb3JFYWNoKFxuICAgICAgICBuZXdUYWdzLFxuICAgICAgICBmdW5jdGlvbihuZXdUYWcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYudGFnRmFjdG9yeS5hZGRUYWdFbnRpdGllcyhuZXdUYWcsc2VsZixjYWxsYmFjayk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIGlmIChlcnIpIHJldHVybiBuZXh0KGVycik7XG4gICAgICAgICAgc2VsZi50cmlnZ2VyKFwibmV3VGFnU2F2ZURvbmVcIik7XG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICB9KTtcbiAgfSxcblxuICBnZXRUYWdzRnJvbVBhZ2U6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIEdhdGhlciB0YWdzIGZvciBzdWJtaXNzaW9uIGFmdGVyIHRoZSB0YXNrIGlzIGNyZWF0ZWRcbiAgICB0YWdzID0ge1xuICAgICAgdG9waWM6IHRoaXMuJChcIiN0YXNrX3RhZ190b3BpY3NcIikuc2VsZWN0MignZGF0YScpLFxuICAgICAgc2tpbGw6IHRoaXMuJChcIiN0YXNrX3RhZ3NraWxsc1wiKS5zZWxlY3QyKCdkYXRhJyksXG4gICAgICBsb2NhdGlvbjogdGhpcy4kKFwiI3Rhc2tfdGFnX2xvY2F0aW9uXCIpLnNlbGVjdDIoJ2RhdGEnKSxcbiAgICAgICd0YXNrLXNraWxscy1yZXF1aXJlZCc6IFsgdGhpcy4kKFwiI3NraWxscy1yZXF1aXJlZFwiKS5zZWxlY3QyKCdkYXRhJykgXSxcbiAgICAgICd0YXNrLXBlb3BsZSc6IFsgdGhpcy4kKFwiI3Blb3BsZVwiKS5zZWxlY3QyKCdkYXRhJykgXSxcbiAgICAgICd0YXNrLXRpbWUtcmVxdWlyZWQnOiBbIHRoaXMuJChcIiN0aW1lLXJlcXVpcmVkXCIpLnNlbGVjdDIoJ2RhdGEnKSBdLFxuICAgICAgJ3Rhc2stdGltZS1lc3RpbWF0ZSc6IFsgdGhpcy4kKFwiI3RpbWUtZXN0aW1hdGVcIikuc2VsZWN0MignZGF0YScpIF0sXG4gICAgICAndGFzay1sZW5ndGgnOiBbIHRoaXMuJChcIiNsZW5ndGhcIikuc2VsZWN0MignZGF0YScpIF1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHRhZ3M7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZShUYXNrRm9ybVRlbXBsYXRlKSh7IHRhZ3M6IHRoaXMudGFnU291cmNlcyB9KVxuICAgIHRoaXMuJGVsLmh0bWwodGVtcGxhdGUpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZVNlbGVjdDIoKTtcbiAgICB0aGlzLmluaXRpYWxpemVUZXh0QXJlYSgpO1xuXG4gICAgLy8gSW1wb3J0YW50OiBIaWRlIGFsbCBub24tY3VycmVudGx5IG9wZW5lZCBzZWN0aW9ucyBvZiB3aXphcmQuXG4gICAgdGhpcy4kKFwic2VjdGlvbjpub3QoLmN1cnJlbnQpXCIpLmhpZGUoKTtcbiAgICB0aGlzLiRlbC5pMThuKCk7XG5cbiAgICAvLyBSZXR1cm4gdGhpcyBmb3IgY2hhaW5pbmcuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgdjogZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gdmFsaWRhdGUoZSk7XG4gIH0sXG5cbiAgY2hpbGROZXh0OiBmdW5jdGlvbiAoZSwgY3VycmVudCkge1xuICAgIC8vIGZpbmQgYWxsIHRoZSB2YWxpZGF0aW9uIGVsZW1lbnRzXG4gICAgdmFyIGNoaWxkcmVuID0gY3VycmVudC5maW5kKCcudmFsaWRhdGUnKTtcbiAgICB2YXIgYWJvcnQgPSBmYWxzZTtcbiAgICBfLmVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgdmFyIGlBYm9ydCA9IHZhbGlkYXRlKHsgY3VycmVudFRhcmdldDogY2hpbGQgfSk7XG4gICAgICBhYm9ydCA9IGFib3J0IHx8IGlBYm9ydDtcbiAgICB9KTtcbiAgICByZXR1cm4gYWJvcnQ7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZVNlbGVjdDI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBzZWxmLnRhZ0ZhY3RvcnkuY3JlYXRlVGFnRHJvcERvd24oe3R5cGU6XCJza2lsbFwiLHNlbGVjdG9yOlwiI3Rhc2tfdGFnX3NraWxsc1wiLHdpZHRoOiBcIjEwMCVcIix0b2tlblNlcGFyYXRvcnM6IFtcIixcIl19KTtcbiAgICBzZWxmLnRhZ0ZhY3RvcnkuY3JlYXRlVGFnRHJvcERvd24oe3R5cGU6XCJ0b3BpY1wiLHNlbGVjdG9yOlwiI3Rhc2tfdGFnX3RvcGljc1wiLHdpZHRoOiBcIjEwMCVcIix0b2tlblNlcGFyYXRvcnM6IFtcIixcIl19KTtcbiAgICBzZWxmLnRhZ0ZhY3RvcnkuY3JlYXRlVGFnRHJvcERvd24oe3R5cGU6XCJsb2NhdGlvblwiLHNlbGVjdG9yOlwiI3Rhc2tfdGFnX2xvY2F0aW9uXCIsd2lkdGg6IFwiMTAwJVwiLHRva2VuU2VwYXJhdG9yczogW1wiLFwiXX0pO1xuXG4gICAgc2VsZi4kKFwiLmVsLXNwZWNpZmljLWxvY2F0aW9uXCIpLmhpZGUoKTtcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuICAgIC8vIFBSRS1ERUZJTkVEIFNFTEVDVCBNRU5VUyBCRUxPVyAvL1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuICAgIHNlbGYuJChcIiNza2lsbHMtcmVxdWlyZWRcIikuc2VsZWN0Mih7XG4gICAgICBwbGFjZWhvbGRlcjogXCJSZXF1aXJlZC9Ob3QgUmVxdWlyZWRcIixcbiAgICAgIHdpZHRoOiAncmVzb2x2ZSdcbiAgICB9KTtcblxuICAgIHNlbGYuJChcIiN0aW1lLXJlcXVpcmVkXCIpLnNlbGVjdDIoe1xuICAgICAgcGxhY2Vob2xkZXI6ICdUaW1lIENvbW1pdG1lbnQnLFxuICAgICAgd2lkdGg6ICdyZXNvbHZlJ1xuICAgIH0pO1xuXG4gICAgc2VsZi4kKFwiI3Blb3BsZVwiKS5zZWxlY3QyKHtcbiAgICAgIHBsYWNlaG9sZGVyOiAnUGVyc29ubmVsIE5lZWRlZCcsXG4gICAgICB3aWR0aDogJ3Jlc29sdmUnXG4gICAgfSk7XG5cbiAgICBzZWxmLiQoXCIjbGVuZ3RoXCIpLnNlbGVjdDIoe1xuICAgICAgcGxhY2Vob2xkZXI6ICdEZWFkbGluZScsXG4gICAgICB3aWR0aDogJ3Jlc29sdmUnXG4gICAgfSk7XG5cbiAgICBzZWxmLiQoXCIjdGltZS1lc3RpbWF0ZVwiKS5zZWxlY3QyKHtcbiAgICAgIHBsYWNlaG9sZGVyOiAnRXN0aW1hdGVkIFRpbWUgUmVxdWlyZWQnLFxuICAgICAgd2lkdGg6ICdyZXNvbHZlJ1xuICAgIH0pO1xuXG4gICAgc2VsZi4kKFwiI3Rhc2stbG9jYXRpb25cIikuc2VsZWN0Mih7XG4gICAgICBwbGFjZWhvbGRlcjogJ1dvcmsgTG9jYXRpb24nLFxuICAgICAgd2lkdGg6ICdyZXNvbHZlJ1xuICAgIH0pO1xuXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZVRleHRBcmVhOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMubWQpIHsgdGhpcy5tZC5jbGVhbnVwKCk7IH1cbiAgICB0aGlzLm1kID0gbmV3IE1hcmtkb3duRWRpdG9yKHtcbiAgICAgIGRhdGE6ICcnLFxuICAgICAgZWw6IFwiLm1hcmtkb3duLWVkaXRcIixcbiAgICAgIGlkOiAndGFzay1kZXNjcmlwdGlvbicsXG4gICAgICBwbGFjZWhvbGRlcjogJ0Rlc2NyaXB0aW9uIG9mICcgKyBpMThuLnQoJ3Rhc2snKSArICcgaW5jbHVkaW5nIGdvYWxzLCBleHBlY3RlZCBvdXRjb21lcyBhbmQgZGVsaXZlcmFibGVzLicsXG4gICAgICB0aXRsZTogaTE4bi50KCdUYXNrJykgKyAnIERlc2NyaXB0aW9uJyxcbiAgICAgIHJvd3M6IDYsXG4gICAgICB2YWxpZGF0ZTogWydlbXB0eSddXG4gICAgfSkucmVuZGVyKCk7XG4gIH0sXG5cbiAgbG9jYXRpb25DaGFuZ2U6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKF8uaXNFcXVhbChlLmN1cnJlbnRUYXJnZXQudmFsdWUsIFwidHJ1ZVwiKSkge1xuICAgICAgdGhpcy4kKFwiLmVsLXNwZWNpZmljLWxvY2F0aW9uXCIpLnNob3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4kKFwiLmVsLXNwZWNpZmljLWxvY2F0aW9uXCIpLmhpZGUoKTtcbiAgICB9XG4gIH0sXG5cbiAgY2xlYW51cDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm1kKSB7IHRoaXMubWQuY2xlYW51cCgpOyB9XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUYXNrRm9ybVZpZXc7XG4iLCJ2YXIgQm9vdHN0cmFwID0gcmVxdWlyZSgnYm9vdHN0cmFwJyk7XG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgUG9wb3ZlcnMgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9taXhpbnMvcG9wb3ZlcnMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL21peGlucy91dGlsaXRpZXMnKTtcbnZhciBCYXNlVmlldyA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2Jhc2UvYmFzZV92aWV3Jyk7XG52YXIgQ29tbWVudExpc3RDb250cm9sbGVyID0gcmVxdWlyZSgnLi4vLi4vLi4vY29tbWVudHMvbGlzdC9jb250cm9sbGVycy9jb21tZW50X2xpc3RfY29udHJvbGxlcicpO1xudmFyIEF0dGFjaG1lbnRWaWV3ID0gcmVxdWlyZSgnLi4vLi4vLi4vYXR0YWNobWVudC92aWV3cy9hdHRhY2htZW50X3Nob3dfdmlldycpO1xudmFyIFRhc2tJdGVtVmlldyA9IHJlcXVpcmUoJy4uL3ZpZXdzL3Rhc2tfaXRlbV92aWV3Jyk7XG52YXIgVGFnU2hvd1ZpZXcgPSByZXF1aXJlKCcuLi8uLi8uLi90YWcvc2hvdy92aWV3cy90YWdfc2hvd192aWV3Jyk7XG52YXIgTW9kYWxDb21wb25lbnQgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb21wb25lbnRzL21vZGFsJyk7XG52YXIgTW9kYWxBbGVydCA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2NvbXBvbmVudHMvbW9kYWxfYWxlcnQnKTtcbnZhciBUYXNrRWRpdEZvcm1WaWV3ID0gcmVxdWlyZSgnLi4vLi4vZWRpdC92aWV3cy90YXNrX2VkaXRfZm9ybV92aWV3Jyk7XG52YXIgVUlDb25maWcgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb25maWcvdWkuanNvbicpO1xudmFyIFZvbHVudGVlclN1cGVydmlzb3JOb3RpZnlUZW1wbGF0ZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy92b2x1bnRlZXJfc3VwZXJ2aXNvcl9ub3RpZnlfdGVtcGxhdGUuaHRtbCcpO1xudmFyIFZvbHVudGVlclRleHRUZW1wbGF0ZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy92b2x1bnRlZXJfdGV4dF90ZW1wbGF0ZS5odG1sJyk7XG52YXIgQ2hhbmdlU3RhdGVUZW1wbGF0ZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy9jaGFuZ2Vfc3RhdGVfdGVtcGxhdGUuaHRtbCcpO1xudmFyIFVwZGF0ZU5hbWVUZW1wbGF0ZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy91cGRhdGVfbmFtZV90ZW1wbGF0ZS5odG1sJyk7XG5cblxudmFyIHBvcG92ZXJzID0gbmV3IFBvcG92ZXJzKCk7XG5cbnZhciBUYXNrU2hvd0NvbnRyb2xsZXIgPSBCYXNlVmlldy5leHRlbmQoe1xuXG4gIGVsOiBcIiNjb250YWluZXJcIixcblxuICBldmVudHM6IHtcbiAgICAnY2hhbmdlIC52YWxpZGF0ZScgICAgICAgICAgICAgICAgOiAndicsXG4gICAgJ2tleXVwIC52YWxpZGF0ZScgICAgICAgICAgICAgICAgIDogJ3YnLFxuICAgICdjbGljayAjdGFzay1lZGl0JyAgICAgICAgICAgICAgICA6ICdlZGl0JyxcbiAgICAnY2xpY2sgI3Rhc2stdmlldycgICAgICAgICAgICAgICAgOiAndmlldycsXG4gICAgXCJjbGljayAjbGlrZS1idXR0b25cIiAgICAgICAgICAgICAgOiAnbGlrZScsXG4gICAgJ2NsaWNrICN2b2x1bnRlZXInICAgICAgICAgICAgICAgIDogJ3ZvbHVudGVlcicsXG4gICAgJ2NsaWNrICN2b2x1bnRlZXJlZCcgICAgICAgICAgICAgIDogJ3ZvbHVudGVlcmVkJyxcbiAgICBcImNsaWNrICN0YXNrLWNsb3NlXCIgICAgICAgICAgICAgICA6IFwic3RhdGVDaGFuZ2VcIixcbiAgICBcImNsaWNrICN0YXNrLXJlb3BlblwiICAgICAgICAgICAgICA6IFwic3RhdGVSZW9wZW5cIixcbiAgICBcImNsaWNrIC5saW5rLWJhY2tib25lXCIgICAgICAgICAgICA6IGxpbmtCYWNrYm9uZSxcbiAgICBcImNsaWNrIC5kZWxldGUtdm9sdW50ZWVyXCIgICAgICAgICA6ICdyZW1vdmVWb2x1bnRlZXInLFxuICAgIFwibW91c2VlbnRlciAucHJvamVjdC1wZW9wbGUtZGl2XCIgIDogcG9wb3ZlcnMucG9wb3ZlclBlb3BsZU9uLFxuICAgIFwiY2xpY2sgLnByb2plY3QtcGVvcGxlLWRpdlwiICAgICAgIDogcG9wb3ZlcnMucG9wb3ZlckNsaWNrXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgdGhpcy5pbml0aWFsaXplVGFza0l0ZW1WaWV3KCk7XG4gICAgdGhpcy5pbml0aWFsaXplQ2hpbGRyZW4oKTtcblxuICAgIC8vbG9hZCB1c2VyIHNldHRpbmdzIHNvIHRoZXkgYXJlIGF2YWlsYWJsZSBhcyBuZWVkZWRcbiAgICB0aGlzLmdldFVzZXJTZXR0aW5ncyh3aW5kb3cuY2FjaGUuY3VycmVudFVzZXIpO1xuXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZUVkaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsLnRvSlNPTigpO1xuICAgIC8vIGNoZWNrIGlmIHRoZSB1c2VyIG93bnMgdGhlIHRhc2tcbiAgICB2YXIgb3duZXIgPSBtb2RlbC5pc093bmVyO1xuICAgIGlmIChvd25lciAhPT0gdHJ1ZSkge1xuICAgICAgLy8gaWYgdGhleSBkb24ndCBvd24gdGhlIHRhc2ssIGRvIHRoZXkgb3duIHRoZSBwcm9qZWN0P1xuICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKG1vZGVsLnByb2plY3QpKSB7XG4gICAgICAgIGlmIChtb2RlbC5wcm9qZWN0LmlzT3duZXIgPT09IHRydWUpIHtcbiAgICAgICAgICBvd25lciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGlmIG5vbmUgb2YgdGhlc2UgYXBwbHksIGFyZSB0aGV5IGFuIGFkbWluP1xuICAgICAgaWYgKHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlcikge1xuICAgICAgICBpZiAod2luZG93LmNhY2hlLmN1cnJlbnRVc2VyLmlzQWRtaW4gPT09IHRydWUpIHtcbiAgICAgICAgICBvd25lciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgbm90IHRoZSBvd25lciwgdHJpZ2dlciB0aGUgbG9naW4gZGlhbG9nLlxuICAgIGlmIChvd25lciAhPT0gdHJ1ZSkge1xuICAgICAgd2luZG93LmNhY2hlLnVzZXJFdmVudHMudHJpZ2dlcihcInVzZXI6cmVxdWVzdDpsb2dpblwiLCB7XG4gICAgICAgIG1lc3NhZ2U6IFwiWW91IGFyZSBub3QgdGhlIG93bmVyIG9mIHRoaXMgb3Bwb3J0dW5pdHkuIDxhIGNsYXNzPSdsaW5rLWJhY2tib25lJyBocmVmPScvdGFza3MvXCIgKyBtb2RlbC5pZCArIFwiJz5WaWV3IHRoZSBvcHBvcnR1bml0eSBpbnN0ZWFkLjwvYT5cIixcbiAgICAgICAgZGlzYWJsZUNsb3NlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50YXNrRWRpdEZvcm1WaWV3KSB0aGlzLnRhc2tFZGl0Rm9ybVZpZXcuY2xlYW51cCgpO1xuICAgIHRoaXMudGFza0VkaXRGb3JtVmlldyA9IG5ldyBUYXNrRWRpdEZvcm1WaWV3KHtcbiAgICAgIGVsOiAnLmVkaXQtdGFzay1zZWN0aW9uJyxcbiAgICAgIGVsVm9sdW50ZWVyOiAnI3Rhc2stdm9sdW50ZWVycycsXG4gICAgICBlZGl0OiB0cnVlLFxuICAgICAgdGFza0lkOiB0aGlzLm1vZGVsLmF0dHJpYnV0ZXMuaWQsXG4gICAgICBtb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgIHRhZ3M6IHRoaXMudGFncyxcbiAgICAgIG1hZGxpYlRhZ3M6IHRoaXMubWFkbGliVGFncyxcbiAgICAgIHRhZ1R5cGVzOiB0aGlzLnRhZ1R5cGVzXG4gICAgfSkucmVuZGVyKCk7XG4gICAgdGhpcy4kKFwiLnRhc2stc2hvdy1tYWRsaWJcIikuaGlkZSgpO1xuICAgIHRoaXMuJChcIi5saS10YXNrLXZpZXdcIikuc2hvdygpO1xuICAgIHRoaXMuJChcIi5saS10YXNrLWVkaXRcIikuaGlkZSgpO1xuICAgIHRoaXMuJChcIi50YXNrLXZpZXdcIikuaGlkZSgpO1xuICB9LFxuXG4gIGluaXRpYWxpemVDaGlsZHJlbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbCwgJ3Rhc2s6c2hvdzpyZW5kZXI6ZG9uZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuaW5pdGlhbGl6ZUhhbmRsZXJzKCk7XG4gICAgICBzZWxmLmluaXRpYWxpemVMaWtlcygpO1xuXG4gICAgICBpZiAod2luZG93LmNhY2hlLmN1cnJlbnRVc2VyKSB7XG4gICAgICAgIHNlbGYuaW5pdGlhbGl6ZVZvbHVudGVlcnMoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYub3B0aW9ucy5hY3Rpb24gPT0gJ2VkaXQnKSB7XG4gICAgICAgIHNlbGYuaW5pdGlhbGl6ZUVkaXQoKTtcbiAgICAgICAgcG9wb3ZlcnMucG9wb3ZlclBlb3BsZUluaXQoXCIucHJvamVjdC1wZW9wbGUtZGl2XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9wb3ZlcnMucG9wb3ZlclBlb3BsZUluaXQoXCIucHJvamVjdC1wZW9wbGUtZGl2XCIpO1xuICAgICAgICBpZiAoc2VsZi5jb21tZW50TGlzdENvbnRyb2xsZXIpIHNlbGYuY29tbWVudExpc3RDb250cm9sbGVyLmNsZWFudXAoKTtcbiAgICAgICAgc2VsZi5jb21tZW50TGlzdENvbnRyb2xsZXIgPSBuZXcgQ29tbWVudExpc3RDb250cm9sbGVyKHtcbiAgICAgICAgICB0YXJnZXQ6ICd0YXNrJyxcbiAgICAgICAgICBpZDogc2VsZi5tb2RlbC5hdHRyaWJ1dGVzLmlkXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc2VsZi5hdHRhY2htZW50Vmlldykgc2VsZi5hdHRhY2htZW50Vmlldy5jbGVhbnVwKCk7XG4gICAgICAgIHNlbGYuYXR0YWNobWVudFZpZXcgPSBuZXcgQXR0YWNobWVudFZpZXcoe1xuICAgICAgICAgIHRhcmdldDogJ3Rhc2snLFxuICAgICAgICAgIGlkOiB0aGlzLm1vZGVsLmF0dHJpYnV0ZXMuaWQsXG4gICAgICAgICAgb3duZXI6IHRoaXMubW9kZWwuYXR0cmlidXRlcy5pc093bmVyLFxuICAgICAgICAgIGVsOiAnLmF0dGFjaG1lbnQtd3JhcHBlcidcbiAgICAgICAgfSkucmVuZGVyKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLnRhZ1ZpZXcpIHNlbGYudGFnVmlldy5jbGVhbnVwKCk7XG4gICAgICBzZWxmLnRhZ1ZpZXcgPSBuZXcgVGFnU2hvd1ZpZXcoe1xuICAgICAgICBtb2RlbDogc2VsZi5tb2RlbCxcbiAgICAgICAgZWw6ICcudGFnLXdyYXBwZXInLFxuICAgICAgICB0YXJnZXQ6ICd0YXNrJyxcbiAgICAgICAgdGFyZ2V0SWQ6ICd0YXNrSWQnLFxuICAgICAgICBlZGl0OiBmYWxzZSxcbiAgICAgICAgdXJsOiAnL2FwaS90YWcvZmluZEFsbEJ5VGFza0lkLydcbiAgICAgIH0pLnJlbmRlcigpO1xuXG4gICAgfSk7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZUxpa2VzOiBmdW5jdGlvbiAoKSB7XG4gICAgJChcIiNsaWtlLW51bWJlclwiKS50ZXh0KHRoaXMubW9kZWwuYXR0cmlidXRlcy5saWtlQ291bnQpO1xuICAgIGlmIChwYXJzZUludCh0aGlzLm1vZGVsLmF0dHJpYnV0ZXMubGlrZUNvdW50KSA9PT0gMSkge1xuICAgICAgJChcIiNsaWtlLXRleHRcIikudGV4dCgkKFwiI2xpa2UtdGV4dFwiKS5kYXRhKCdzaW5ndWxhcicpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJChcIiNsaWtlLXRleHRcIikudGV4dCgkKFwiI2xpa2UtdGV4dFwiKS5kYXRhKCdwbHVyYWwnKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1vZGVsLmF0dHJpYnV0ZXMubGlrZSkge1xuICAgICAgJChcIiNsaWtlLWJ1dHRvbi1pY29uXCIpLnJlbW92ZUNsYXNzKCdmYSBmYS1zdGFyLW8nKTtcbiAgICAgICQoXCIjbGlrZS1idXR0b24taWNvblwiKS5hZGRDbGFzcygnZmEgZmEtc3RhcicpO1xuICAgIH1cbiAgfSxcblxuICBpbml0aWFsaXplVm9sdW50ZWVyczogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm1vZGVsLmF0dHJpYnV0ZXMudm9sdW50ZWVyKSB7XG4gICAgICAkKCcudm9sdW50ZWVyLXRydWUnKS5zaG93KCk7XG4gICAgICAkKCcudm9sdW50ZWVyLWZhbHNlJykuaGlkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkKCcudm9sdW50ZWVyLXRydWUnKS5oaWRlKCk7XG4gICAgICAkKCcudm9sdW50ZWVyLWZhbHNlJykuc2hvdygpO1xuICAgIH1cbiAgfSxcblxuICBpbml0aWFsaXplSGFuZGxlcnM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbCwgXCJ0YXNrOnVwZGF0ZTpzdGF0ZTpzdWNjZXNzXCIsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBpZiAoZGF0YS5hdHRyaWJ1dGVzLnN0YXRlID09ICdjbG9zZWQnKSB7XG4gICAgICAgICQoXCIjbGktdGFzay1jbG9zZVwiKS5oaWRlKCk7XG4gICAgICAgICQoXCIjbGktdGFzay1yZW9wZW5cIikuc2hvdygpO1xuICAgICAgICAkKFwiI2FsZXJ0LWNsb3NlZFwiKS5zaG93KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkKFwiI2xpLXRhc2stY2xvc2VcIikuc2hvdygpO1xuICAgICAgICAkKFwiI2xpLXRhc2stcmVvcGVuXCIpLmhpZGUoKTtcbiAgICAgICAgJChcIiNhbGVydC1jbG9zZWRcIikuaGlkZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBpbml0aWFsaXplVGFza0l0ZW1WaWV3OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIC8vIEdldCB0aGUgdGFnIHR5cGUgaW5mbyBmcm9tIHRoZSB2aWV3IHNvIHdlIGRvbid0IGhhdmUgdG8gcmVmZXRjaFxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbCwgJ3Rhc2s6dGFnOnR5cGVzJywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHNlbGYudGFnVHlwZXMgPSBkYXRhO1xuICAgIH0pO1xuICAgIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbCwgJ3Rhc2s6dGFnOmRhdGEnLCBmdW5jdGlvbiAodGFncywgbWFkbGliVGFncykge1xuICAgICAgc2VsZi50YWdzID0gdGFncztcbiAgICAgIHNlbGYubWFkbGliVGFncyA9IG1hZGxpYlRhZ3M7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMudGFza0l0ZW1WaWV3KSB0aGlzLnRhc2tJdGVtVmlldy5jbGVhbnVwKCk7XG4gICAgdGhpcy50YXNrSXRlbVZpZXcgPSBuZXcgVGFza0l0ZW1WaWV3KHtcbiAgICAgIG1vZGVsOiB0aGlzLm9wdGlvbnMubW9kZWwsXG4gICAgICByb3V0ZXI6IHRoaXMub3B0aW9ucy5yb3V0ZXIsXG4gICAgICBpZDogdGhpcy5vcHRpb25zLmlkLFxuICAgICAgZWw6IHRoaXMuZWxcbiAgICB9KTtcbiAgfSxcblxuICB2OiBmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiB2YWxpZGF0ZShlKTtcbiAgfSxcblxuICBlZGl0OiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5pbml0aWFsaXplRWRpdCgpO1xuICAgIHBvcG92ZXJzLnBvcG92ZXJQZW9wbGVJbml0KFwiLnByb2plY3QtcGVvcGxlLWRpdlwiKTtcbiAgICBCYWNrYm9uZS5oaXN0b3J5Lm5hdmlnYXRlKCd0YXNrcy8nICsgdGhpcy5tb2RlbC5pZCArICcvZWRpdCcpO1xuICB9LFxuXG4gIHZpZXc6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBCYWNrYm9uZS5oaXN0b3J5Lm5hdmlnYXRlKCd0YXNrcy8nICsgdGhpcy5tb2RlbC5pZCwgeyB0cmlnZ2VyOiB0cnVlIH0pO1xuICB9LFxuXG4gIGxpa2U6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNoaWxkID0gJChlLmN1cnJlbnRUYXJnZXQpLmNoaWxkcmVuKFwiI2xpa2UtYnV0dG9uLWljb25cIik7XG4gICAgdmFyIGxpa2VudW1iZXIgPSAkKFwiI2xpa2UtbnVtYmVyXCIpO1xuICAgIC8vIE5vdCB5ZXQgbGlrZWQsIGluaXRpYXRlIGxpa2VcbiAgICBpZiAoY2hpbGQuaGFzQ2xhc3MoJ2ZhLXN0YXItbycpKSB7XG4gICAgICBjaGlsZC5yZW1vdmVDbGFzcygnZmEtc3Rhci1vJyk7XG4gICAgICBjaGlsZC5hZGRDbGFzcygnZmEtc3RhcicpO1xuICAgICAgbGlrZW51bWJlci50ZXh0KHBhcnNlSW50KGxpa2VudW1iZXIudGV4dCgpKSArIDEpO1xuICAgICAgaWYgKHBhcnNlSW50KGxpa2VudW1iZXIudGV4dCgpKSA9PT0gMSkge1xuICAgICAgICAkKFwiI2xpa2UtdGV4dFwiKS50ZXh0KCQoXCIjbGlrZS10ZXh0XCIpLmRhdGEoJ3Npbmd1bGFyJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJChcIiNsaWtlLXRleHRcIikudGV4dCgkKFwiI2xpa2UtdGV4dFwiKS5kYXRhKCdwbHVyYWwnKSk7XG4gICAgICB9XG4gICAgICAkLmFqYXgoe1xuICAgICAgICB1cmw6ICcvYXBpL2xpa2UvbGlrZXQvJyArIHRoaXMubW9kZWwuYXR0cmlidXRlcy5pZFxuICAgICAgfSkuZG9uZSggZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgLy8gbGlrZWQhXG4gICAgICAgIC8vIHJlc3BvbnNlIHNob3VsZCBiZSB0aGUgbGlrZSBvYmplY3RcbiAgICAgICAgLy8gY29uc29sZS5sb2coZGF0YS5pZCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gTGlrZWQsIGluaXRpYXRlIHVubGlrZVxuICAgIGVsc2Uge1xuICAgICAgY2hpbGQucmVtb3ZlQ2xhc3MoJ2ZhLXN0YXInKTtcbiAgICAgIGNoaWxkLmFkZENsYXNzKCdmYS1zdGFyLWVtcHR5Jyk7XG4gICAgICBsaWtlbnVtYmVyLnRleHQocGFyc2VJbnQobGlrZW51bWJlci50ZXh0KCkpIC0gMSk7XG4gICAgICBpZiAocGFyc2VJbnQobGlrZW51bWJlci50ZXh0KCkpID09PSAxKSB7XG4gICAgICAgICQoXCIjbGlrZS10ZXh0XCIpLnRleHQoJChcIiNsaWtlLXRleHRcIikuZGF0YSgnc2luZ3VsYXInKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkKFwiI2xpa2UtdGV4dFwiKS50ZXh0KCQoXCIjbGlrZS10ZXh0XCIpLmRhdGEoJ3BsdXJhbCcpKTtcbiAgICAgIH1cbiAgICAgICQuYWpheCh7XG4gICAgICAgIHVybDogJy9hcGkvbGlrZS91bmxpa2V0LycgKyB0aGlzLm1vZGVsLmF0dHJpYnV0ZXMuaWRcbiAgICAgIH0pLmRvbmUoIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIC8vIHVuLWxpa2VkIVxuICAgICAgICAvLyByZXNwb25zZSBzaG91bGQgYmUgbnVsbCAoZW1wdHkpXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIGdldFVzZXJTZXR0aW5nczogZnVuY3Rpb24gKHVzZXJJZCkge1xuICAgIC8vZG9lcyB0aGlzIGJlbG9uZyBzb21ld2hlcmUgZWxzZT9cbiAgICBpZiAoIF8uaXNOdWxsKHVzZXJJZCkgKXsgcmV0dXJuIG51bGw7IH1cbiAgICAkLmFqYXgoe1xuICAgICAgdXJsOiAnL2FwaS91c2Vyc2V0dGluZy8nK3VzZXJJZC5pZCxcbiAgICAgIHR5cGU6ICdHRVQnLFxuICAgICAgZGF0YVR5cGU6ICdqc29uJ1xuICAgIH0pXG4gICAgLnN1Y2Nlc3MoZnVuY3Rpb24oZGF0YSl7XG4gICAgICBfLmVhY2goZGF0YSxmdW5jdGlvbihzZXR0aW5nKXtcbiAgICAgICAgLy9zYXZlIGFjdGl2ZSBzZXR0aW5ncyB0byB0aGUgY3VycmVudCB1c2VyIG9iamVjdFxuICAgICAgICBpZiAoIHNldHRpbmcuaXNBY3RpdmUgKXtcbiAgICAgICAgICB3aW5kb3cuY2FjaGUuY3VycmVudFVzZXJbc2V0dGluZy5rZXldPXNldHRpbmc7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIGRlbGV0ZVVzZXJTZXR0aW5nQnlLZXk6IGZ1bmN0aW9uKHNldHRpbmdLZXkpIHtcbiAgICAvL3RoaXMgZnVuY3Rpb24gZXhwZWN0cyB0aGUgZW50aXJlIHJvdyBmcm9tIHVzZXJzZXR0aW5nIGluIHRoZSBmb3JtXG4gICAgLy8gICAgIHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlcltzZXR0aW5nS2V5XSA9IHt9XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy9pZiBub3Qgc2V0IHNraXBcbiAgICB2YXIgdGFyZ2V0SWQgPSAgKCB3aW5kb3cuY2FjaGUuY3VycmVudFVzZXJbc2V0dGluZ0tleV0gKSA/IHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlcltzZXR0aW5nS2V5XS5pZCA6IG51bGwgO1xuXG4gICAgaWYgKCB0YXJnZXRJZCApe1xuICAgICAgJC5hamF4KHtcbiAgICAgICAgdXJsOiAnL2FwaS91c2Vyc2V0dGluZy8nK3RhcmdldElkLFxuICAgICAgICB0eXBlOiAnREVMRVRFJyxcbiAgICAgICAgZGF0YVR5cGU6ICdqc29uJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgfSxcblxuICBzYXZlVXNlclNldHRpbmdCeUtleTogZnVuY3Rpb24odXNlcklkLCBvcHRpb25zKSB7XG4gICAgLy90aGlzIGZ1bmN0aW9uIGV4cGVjdHMgdGhlIGVudGlyZSByb3cgZnJvbSB1c2Vyc2V0dGluZyBpbiB0aGUgZm9ybVxuICAgIC8vICAgICB3aW5kb3cuY2FjaGUuY3VycmVudFVzZXJbc2V0dGluZ0tleV0gPSB7fVxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vYXJlIHZhbHVlcyB0aGUgc2FtZSwgc3RvcFxuICAgIGlmICggb3B0aW9ucy5uZXdWYWx1ZSA9PSBvcHRpb25zLm9sZFZhbHVlICkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gICAgLy9pZiBkZWxldGUgb2xkIGlzIHNldCwgZGVsZXRlIGV4aXNpdG5nIHZhbHVlXG4gICAgLy8gICBkZWZhdWx0IGlzIGRlbGV0ZVxuICAgIGlmICggIW9wdGlvbnMuZGVsZXRlT2xkICl7XG4gICAgICBzZWxmLmRlbGV0ZVVzZXJTZXR0aW5nQnlLZXkob3B0aW9ucy5zZXR0aW5nS2V5KTtcbiAgICB9XG5cbiAgICAkLmFqYXgoe1xuICAgICAgICB1cmw6ICcvYXBpL3VzZXJzZXR0aW5nLycsXG4gICAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHVzZXJJZDogdXNlcklkLFxuICAgICAgICAgIGtleTogb3B0aW9ucy5zZXR0aW5nS2V5LFxuICAgICAgICAgIHZhbHVlOiBvcHRpb25zLm5ld1ZhbHVlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9LFxuXG4gIHZvbHVudGVlcjogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICghd2luZG93LmNhY2hlLmN1cnJlbnRVc2VyKSB7XG4gICAgICB3aW5kb3cuY2FjaGUudXNlckV2ZW50cy50cmlnZ2VyKFwidXNlcjpyZXF1ZXN0OmxvZ2luXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgY2hpbGQgPSAkKGUuY3VycmVudFRhcmdldCkuY2hpbGRyZW4oXCIjbGlrZS1idXR0b24taWNvblwiKTtcbiAgICAgIHZhciBvcmlnaW5hbEV2ZW50ID0gZTtcblxuICAgICAgaWYgKHRoaXMubW9kYWxBbGVydCkgeyB0aGlzLm1vZGFsQWxlcnQuY2xlYW51cCgpOyB9XG4gICAgICBpZiAodGhpcy5tb2RhbENvbXBvbmVudCkgeyB0aGlzLm1vZGFsQ29tcG9uZW50LmNsZWFudXAoKTsgfVxuXG4gICAgICAvLyBJZiB1c2VyJ3MgcHJvZmlsZSBoYXMgbm8gbmFtZSwgYXNrIHRoZW0gdG8gZW50ZXIgb25lXG4gICAgICBpZiAoIXdpbmRvdy5jYWNoZS5jdXJyZW50VXNlci5uYW1lKSB7XG4gICAgICAgIHZhciBtb2RhbENvbnRlbnQgPSBfLnRlbXBsYXRlKFVwZGF0ZU5hbWVUZW1wbGF0ZSkoe30pO1xuICAgICAgICB0aGlzLm1vZGFsQ29tcG9uZW50ID0gbmV3IE1vZGFsQ29tcG9uZW50KHtcbiAgICAgICAgICBlbDogXCIjbW9kYWwtdm9sdW50ZWVyXCIsXG4gICAgICAgICAgaWQ6IFwidXBkYXRlLW5hbWVcIixcbiAgICAgICAgICBtb2RhbFRpdGxlOiBcIldoYXQncyB5b3VyIG5hbWU/XCJcbiAgICAgICAgfSkucmVuZGVyKCk7XG4gICAgICAgIHRoaXMubW9kYWxBbGVydCA9IG5ldyBNb2RhbEFsZXJ0KHtcbiAgICAgICAgICBlbDogXCIjdXBkYXRlLW5hbWUgLm1vZGFsLXRlbXBsYXRlXCIsXG4gICAgICAgICAgbW9kYWxEaXY6ICcjdXBkYXRlLW5hbWUnLFxuICAgICAgICAgIGNvbnRlbnQ6IG1vZGFsQ29udGVudCxcbiAgICAgICAgICB2YWxpZGF0ZUJlZm9yZVN1Ym1pdDogdHJ1ZSxcbiAgICAgICAgICBjYW5jZWw6IGkxOG4udCgndm9sdW50ZWVyTW9kYWwuY2FuY2VsJyksXG4gICAgICAgICAgc3VibWl0OiBpMThuLnQoJ3ZvbHVudGVlck1vZGFsLm9rJyksXG4gICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gJCgnI3VwZGF0ZS1uYW1lLWZpZWxkJykudmFsKCk7XG4gICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICB1cmw6ICcvYXBpL3VzZXIvJyArIHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlci5pZCxcbiAgICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgICAgZGF0YTogeyBuYW1lOiBuYW1lIH1cbiAgICAgICAgICAgIH0pLmRvbmUoZnVuY3Rpb24odXNlcikge1xuICAgICAgICAgICAgICB3aW5kb3cuY2FjaGUuY3VycmVudFVzZXIubmFtZSA9IHVzZXIubmFtZTtcbiAgICAgICAgICAgICAgc2VsZi52b2x1bnRlZXIob3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLnJlbmRlcigpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMubW9kYWxDb21wb25lbnQgPSBuZXcgTW9kYWxDb21wb25lbnQoe1xuICAgICAgICBlbDogXCIjbW9kYWwtdm9sdW50ZWVyXCIsXG4gICAgICAgIGlkOiBcImNoZWNrLXZvbHVudGVlclwiLFxuICAgICAgICBtb2RhbFRpdGxlOiBpMThuLnQoXCJ2b2x1bnRlZXJNb2RhbC50aXRsZVwiKVxuICAgICAgfSkucmVuZGVyKCk7XG5cbiAgICAgIGlmICggVUlDb25maWcuc3VwZXJ2aXNvckVtYWlsLnVzZVN1cGVydmlzb3JFbWFpbCApIHtcbiAgICAgICAgLy9ub3QgYXNzaWduaW5nIGFzIG51bGwgYmVjYXVzZSBudWxsIGluamVjdGVkIGludG8gdGhlIG1vZGFsQ29udGVudCB2YXIgc2hvd3MgYXMgYSBsaXRlcmFsIHZhbHVlXG4gICAgICAgIC8vICAgIHdoZW4gd2hhdCB3ZSB3YW50IGlzIG5vdGhpbmcgaWYgdmFsdWUgaXMgbnVsbFxuICAgICAgICB2YXIgc3VwZXJ2aXNvckVtYWlsID0gKCB3aW5kb3cuY2FjaGUuY3VycmVudFVzZXIuc3VwZXJ2aXNvckVtYWlsICkgPyB3aW5kb3cuY2FjaGUuY3VycmVudFVzZXIuc3VwZXJ2aXNvckVtYWlsLnZhbHVlICA6IFwiXCI7XG4gICAgICAgIHZhciBzdXBlcnZpc29yTmFtZSA9ICggd2luZG93LmNhY2hlLmN1cnJlbnRVc2VyLnN1cGVydmlzb3JOYW1lICkgPyB3aW5kb3cuY2FjaGUuY3VycmVudFVzZXIuc3VwZXJ2aXNvck5hbWUudmFsdWUgOiBcIlwiO1xuICAgICAgICB2YXIgdmFsaWRhdGVCZWZvcmVTdWJtaXQgPSB0cnVlO1xuICAgICAgICB2YXIgbW9kYWxDb250ZW50ID0gXy50ZW1wbGF0ZShWb2x1bnRlZXJTdXBlcnZpc29yTm90aWZ5VGVtcGxhdGUpKHtzdXBlcnZpc29yRW1haWw6IHN1cGVydmlzb3JFbWFpbCxzdXBlcnZpc29yTmFtZTogc3VwZXJ2aXNvck5hbWV9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbGlkYXRlQmVmb3JlU3VibWl0ID0gZmFsc2U7XG4gICAgICAgIHZhciBtb2RhbENvbnRlbnQgPSBfLnRlbXBsYXRlKFZvbHVudGVlclRleHRUZW1wbGF0ZSkoe30pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1vZGFsQWxlcnQgPSBuZXcgTW9kYWxBbGVydCh7XG4gICAgICAgIGVsOiBcIiNjaGVjay12b2x1bnRlZXIgLm1vZGFsLXRlbXBsYXRlXCIsXG4gICAgICAgIG1vZGFsRGl2OiAnI2NoZWNrLXZvbHVudGVlcicsXG4gICAgICAgIGNvbnRlbnQ6IG1vZGFsQ29udGVudCxcbiAgICAgICAgY2FuY2VsOiBpMThuLnQoJ3ZvbHVudGVlck1vZGFsLmNhbmNlbCcpLFxuICAgICAgICBzdWJtaXQ6IGkxOG4udCgndm9sdW50ZWVyTW9kYWwub2snKSxcbiAgICAgICAgdmFsaWRhdGVCZWZvcmVTdWJtaXQ6IHZhbGlkYXRlQmVmb3JlU3VibWl0LFxuICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBpZiAoIFVJQ29uZmlnLnN1cGVydmlzb3JFbWFpbC51c2VTdXBlcnZpc29yRW1haWwgKSB7XG4gICAgICAgICAgICBzZWxmLnNhdmVVc2VyU2V0dGluZ0J5S2V5KHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlci5pZCx7c2V0dGluZ0tleTpcInN1cGVydmlzb3JFbWFpbFwiLG5ld1ZhbHVlOiAkKCcjdXNlclN1cGVyVmlzb3JFbWFpbCcpLnZhbCgpLG9sZFZhbHVlOiBzdXBlcnZpc29yRW1haWx9KTtcbiAgICAgICAgICAgIHNlbGYuc2F2ZVVzZXJTZXR0aW5nQnlLZXkod2luZG93LmNhY2hlLmN1cnJlbnRVc2VyLmlkLHtzZXR0aW5nS2V5Olwic3VwZXJ2aXNvck5hbWVcIixuZXdWYWx1ZTogJCgnI3VzZXJTdXBlclZpc29yTmFtZScpLnZhbCgpLG9sZFZhbHVlOiBzdXBlcnZpc29yTmFtZX0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB1c2VyIGNsaWNrZWQgdGhlIHN1Ym1pdCBidXR0b25cbiAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgdXJsOiAnL2FwaS92b2x1bnRlZXIvJyxcbiAgICAgICAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgdGFza0lkOiBzZWxmLm1vZGVsLmF0dHJpYnV0ZXMuaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KS5kb25lKCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgJCgnLnZvbHVudGVlci10cnVlJykuc2hvdygpO1xuICAgICAgICAgICAgJCgnLnZvbHVudGVlci1mYWxzZScpLmhpZGUoKTtcbiAgICAgICAgICAgIHZhciBodG1sID0gJzxkaXYgY2xhc3M9XCJwcm9qZWN0LXBlb3BsZS1kaXZcIiBkYXRhLXVzZXJpZD1cIicgKyBkYXRhLnVzZXJJZCArICdcIiBkYXRhLXZvbHVzZXJpZD1cIicgKyBkYXRhLnVzZXJJZCArICdcIj48aW1nIHNyYz1cIi9hcGkvdXNlci9waG90by8nICsgZGF0YS51c2VySWQgKyAnXCIgY2xhc3M9XCJwcm9qZWN0LXBlb3BsZVwiLz4nO1xuICAgICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5hY3Rpb24gPT09IFwiZWRpdFwiKSB7XG4gICAgICAgICAgICAgIGh0bWwgKz0gJzxhIGhyZWY9XCIjXCIgY2xhc3M9XCJkZWxldGUtdm9sdW50ZWVyIHZvbHVudGVlci1kZWxldGUgZmEgZmEtdGltZXNcIiAgaWQ9XCJkZWxldGUtdm9sdW50ZWVyLScgKyBkYXRhLmlkICsgJ1wiIGRhdGEtdWlkPVwiJyArIGRhdGEudXNlcklkICsgJ1wiIGRhdGEtdmlkPVwiJyArICBkYXRhLmlkICsgJ1wiPjwvYT4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaHRtbCArPSAnPC9kaXY+JztcbiAgICAgICAgICAgICQoJyN0YXNrLXZvbHVudGVlcnMnKS5hcHBlbmQoaHRtbCk7XG4gICAgICAgICAgICBwb3BvdmVycy5wb3BvdmVyUGVvcGxlSW5pdChcIi5wcm9qZWN0LXBlb3BsZS1kaXZcIik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pLnJlbmRlcigpO1xuICAgIH1cbiAgfSxcblxuICB2b2x1bnRlZXJlZDogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIC8vIE5vdCBhYmxlIHRvIHVuLXZvbHVudGVlciwgc28gZG8gbm90aGluZ1xuICB9LFxuXG4gIHJlbW92ZVZvbHVudGVlcjogZnVuY3Rpb24oZSkge1xuICAgIGlmIChlLnN0b3BQcm9wYWdhdGlvbigpKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgJChlLmN1cnJlbnRUYXJnZXQpLm9mZihcIm1vdXNlZW50ZXJcIik7XG4gICAgJCgnLnBvcG92ZXInKS5yZW1vdmUoKTtcblxuICAgIHZhciB2SWQgPSAkKGUuY3VycmVudFRhcmdldCkuZGF0YSgndmlkJyk7XG4gICAgdmFyIHVJZCA9ICQoZS5jdXJyZW50VGFyZ2V0KS5kYXRhKCd1aWQnKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAodHlwZW9mIGNhY2hlICE9PSBcInVuZGVmaW5lZFwiKVxuICAgIHtcbiAgICAgICQuYWpheCh7XG4gICAgICAgIHVybDogJy9hcGkvdm9sdW50ZWVyLycgKyB2SWQsXG4gICAgICAgIHR5cGU6ICdERUxFVEUnLFxuICAgICAgfSkuZG9uZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIC8vIGRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBvbGRWb2xzID0gdGhpcy5tb2RlbC5hdHRyaWJ1dGVzLnZvbHVudGVlcnMgfHwgW107XG4gICAgdmFyIHVuY2hhbmdlZFZvbHMgPSBfLmZpbHRlcihvbGRWb2xzLCBmdW5jdGlvbih2b2wpeyByZXR1cm4gKCB2b2wuaWQgIT09IHZJZCApOyB9ICwgdGhpcykgIHx8IFtdO1xuICAgIHRoaXMubW9kZWwuYXR0cmlidXRlcy52b2x1bnRlZXJzID0gdW5jaGFuZ2VkVm9scztcbiAgICAkKCdbZGF0YS12b2x1c2VyaWQ9XCInICsgdUlkICsgJ1wiXScpLnJlbW92ZSgpO1xuICAgIGlmICh3aW5kb3cuY2FjaGUuY3VycmVudFVzZXIuaWQgPT09IHVJZCkge1xuICAgICAgJCgnLnZvbHVudGVlci1mYWxzZScpLnNob3coKTtcbiAgICAgICQoJy52b2x1bnRlZXItdHJ1ZScpLmhpZGUoKTtcbiAgICB9XG4gIH0sXG5cbiAgc3RhdGVDaGFuZ2U6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5tb2RhbEFsZXJ0KSB7IHRoaXMubW9kYWxBbGVydC5jbGVhbnVwKCk7IH1cbiAgICBpZiAodGhpcy5tb2RhbENvbXBvbmVudCkgeyB0aGlzLm1vZGFsQ29tcG9uZW50LmNsZWFudXAoKTsgfVxuICAgIHZhciBzdGF0ZXMgPSBVSUNvbmZpZy5zdGF0ZXM7XG4gICAgaWYgKGRyYWZ0QWRtaW5Pbmx5ICYmICF3aW5kb3cuY2FjaGUuY3VycmVudFVzZXIuaXNBZG1pbikge1xuICAgICAgc3RhdGVzID0gXyhzdGF0ZXMpLnJlamVjdChmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICByZXR1cm4gc3RhdGUudmFsdWUgPT09ICdkcmFmdCc7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgbW9kYWxDb250ZW50ID0gXy50ZW1wbGF0ZShDaGFuZ2VTdGF0ZVRlbXBsYXRlKSh7bW9kZWw6c2VsZi5tb2RlbCxzdGF0ZXM6IHN0YXRlc30pO1xuICAgIHRoaXMubW9kYWxDb21wb25lbnQgPSBuZXcgTW9kYWxDb21wb25lbnQoe1xuICAgICAgZWw6IFwiI21vZGFsLWNsb3NlXCIsXG4gICAgICBpZDogXCJjaGVjay1jbG9zZVwiLFxuICAgICAgbW9kYWxUaXRsZTogXCJDaGFuZ2UgXCIraTE4bi50KFwiVGFza1wiKStcIiBTdGF0ZVwiXG4gICAgfSkucmVuZGVyKCk7XG5cbiAgICB0aGlzLm1vZGFsQWxlcnQgPSBuZXcgTW9kYWxBbGVydCh7XG4gICAgICBlbDogXCIjY2hlY2stY2xvc2UgLm1vZGFsLXRlbXBsYXRlXCIsXG4gICAgICBtb2RhbERpdjogJyNjaGVjay1jbG9zZScsXG4gICAgICBjb250ZW50OiBtb2RhbENvbnRlbnQsXG4gICAgICBjYW5jZWw6ICdDYW5jZWwnLFxuICAgICAgc3VibWl0OiAnQ2hhbmdlICcraTE4bi50KFwiVGFza1wiKSsnIFN0YXRlJyxcbiAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAvLyB1c2VyIGNsaWNrZWQgdGhlIHN1Ym1pdCBidXR0b25cbiAgICAgICAgc2VsZi5tb2RlbC50cmlnZ2VyKFwidGFzazp1cGRhdGU6c3RhdGVcIiwgJCgnaW5wdXRbbmFtZT1vcHBvcnR1bml0eVN0YXRlXTpjaGVja2VkJykudmFsKCkpO1xuICAgICAgfVxuICAgIH0pLnJlbmRlcigpO1xuICB9LFxuXG4gIHN0YXRlUmVvcGVuOiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5tb2RlbC50cmlnZ2VyKFwidGFzazp1cGRhdGU6c3RhdGVcIiwgJ29wZW4nKTtcbiAgfSxcblxuICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMudGFza0VkaXRGb3JtVmlldykgdGhpcy50YXNrRWRpdEZvcm1WaWV3LmNsZWFudXAoKTtcbiAgICBpZiAodGhpcy50YWdWaWV3KSB7IHRoaXMudGFnVmlldy5jbGVhbnVwKCk7IH1cbiAgICBpZiAodGhpcy5hdHRhY2htZW50VmlldykgeyB0aGlzLmF0dGFjaG1lbnRWaWV3LmNsZWFudXAoKTsgfVxuICAgIGlmICh0aGlzLmNvbW1lbnRMaXN0Q29udHJvbGxlcikgeyB0aGlzLmNvbW1lbnRMaXN0Q29udHJvbGxlci5jbGVhbnVwKCk7IH1cbiAgICBpZiAodGhpcy50YXNrSXRlbVZpZXcpIHsgdGhpcy50YXNrSXRlbVZpZXcuY2xlYW51cCgpOyB9XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUYXNrU2hvd0NvbnRyb2xsZXI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuXFx0PHA+UGxlYXNlIHNlbGVjdCB0aGUgbmV3IHN0YXRlIGZvciB0aGUgb3Bwb3J0dW5pdHkuIFRoZSBjdXJyZW50IHN0YXRlIGlzIGNoZWNrZWQgYW5kIHRoZSBhdmFpbGFibGUgc3RhdGVzIGFyZTpcXG5cXHRcXHQ8dWwgc3R5bGU9J2xpc3Qtc3R5bGUtdHlwZTpub25lJz5cXG5cXHRcXHRcXHQ8JSBfLmVhY2goc3RhdGVzLCBmdW5jdGlvbiAodCkgeyAlPlxcblxcdFxcdFxcdFxcdDxsaT48aW5wdXQgdHlwZT0ncmFkaW8nIG5hbWU9J29wcG9ydHVuaXR5U3RhdGUnIHZhbHVlPSc8JS0gdC52YWx1ZSAlPidcXG5cXHRcXHRcXHRcXHRcXHQ8JSBpZiAoIHQudmFsdWUgPT0gbW9kZWwuYXR0cmlidXRlcy5zdGF0ZSApIHslPlxcblxcdFxcdFxcdFxcdFxcdFxcdDwlLSBjaGVja2VkPVxcXCJjaGVja2VkXFxcIiAlPlxcblxcdFxcdFxcdFxcdFxcdDwlIH0gJT5cXG5cXHRcXHRcXHRcXHRcXHRcXHQ+IDwlLSB0LmxhYmVsICU+IDwvbGk+XFxuXFx0XFx0XFx0XFx0XFx0PCUgfSk7ICU+XFxuXFx0XFx0PC91bD5cXG5cXHQ8L3A+XFxuPC9kaXY+XFxuXCI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPCEtLSBBTEVSVFMgLS0+XFxuPGRpdiBjbGFzcz1cXFwiYWxlcnQgYWxlcnQtZGFuZ2VyXFxcIiBpZD1cXFwiYWxlcnQtY2xvc2VkXFxcIiBzdHlsZT1cXFwiPCUgaWYgKG1vZGVsLnN0YXRlICE9ICdjbG9zZWQnKSB7ICU+ZGlzcGxheTogbm9uZTs8JSB9ICU+XFxcIj5UaGlzIDxzcGFuIGRhdGEtaTE4bj1cXFwidGFza1xcXCI+b3Bwb3J0dW5pdHk8L3NwYW4+IGlzIDxzdHJvbmc+Y2xvc2VkPC9zdHJvbmc+LiAgSXQgaXMgbm8gbG9uZ2VyIGFjdGl2ZSwgYW5kIG5vIG1vcmUgbW9kaWZpY2F0aW9ucyBtYXkgYmUgbWFkZS48L2Rpdj5cXG5cXG48ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcblxcbiAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLXB1c2gtNCBjb2wtc20tcHVzaC00IGNvbC1zbS04IGNvbC1tZC04IG1kLW5vcGFkZGluZy1yaWdodFxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTkgc20tbm9wYWRkaW5nIG1kLW5vcGFkZGluZ1xcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJib3ggYm94LW1haW5cXFwiPlxcblxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtYWluLXNlY3Rpb25cXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImVkaXQtdGFzay1zZWN0aW9uXFxcIj5cXG5cXG4gICAgICAgICAgICAgIDxoMT48JS0gbW9kZWwudGl0bGUgJT48L2gxPlxcbiAgICAgICAgICAgICAgPCUgaWYgKCFfLmlzVW5kZWZpbmVkKG1vZGVsLnByb2plY3QpICYmIHVpLnByb2plY3Quc2hvdykgeyAlPlxcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidGFzay1wcm9qZWN0XFxcIj5cXG4gICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiL3Byb2plY3RzLzwlLSBtb2RlbC5wcm9qZWN0SWQgJT5cXFwiIGNsYXNzPVxcXCJsaW5rLWJhY2tib25lXFxcIj5cXG4gICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtZm9sZGVyLW9cXFwiPjwvaT5cXG4gICAgICAgICAgICAgICAgICA8JS0gbW9kZWwucHJvamVjdC50aXRsZSAlPlxcbiAgICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgIDwlIH0gJT5cXG5cXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInRhc2stc2hvdy1kZXNjcmlwdGlvblxcXCI+XFxuICAgICAgICAgICAgICAgIDwlPSBtb2RlbC5kZXNjcmlwdGlvbkh0bWwgJT5cXG4gICAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidGFzay1zaG93LWNyZWF0aW9uXFxcIj5cXG4gICAgICAgICAgICAgICAgPHNwYW4gZGF0YS1pMThuPVxcXCJUYXNrXFxcIj5PcHBvcnR1bml0eTwvc3Bhbj4gY3JlYXRlZCA8dGltZSBjbGFzcz1cXFwidGltZWFnb1xcXCIgZGF0ZXRpbWU9XFxcIjwlLSBtb2RlbC5jcmVhdGVkQXQgJT5cXFwiPjwlLSBtb2RlbC5jcmVhdGVkQXQgJT48L3RpbWU+XFxuICAgICAgICAgICAgICAgIDwlIGlmIChtb2RlbC5jcmVhdGVkQXQgIT0gbW9kZWwudXBkYXRlZEF0KSB7ICU+XFxuICAgICAgICAgICAgICAgIGFuZCB1cGRhdGVkIDx0aW1lIGNsYXNzPVxcXCJ0aW1lYWdvXFxcIiBkYXRldGltZT1cXFwiPCUtIG1vZGVsLnVwZGF0ZWRBdCAlPlxcXCI+PCUtIG1vZGVsLnVwZGF0ZWRBdCAlPjwvdGltZT5cXG4gICAgICAgICAgICAgICAgPCUgfSAlPlxcbiAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTMgcGFkZGluZy1sZWZ0LW5vbmUgc20tbm9wYWRkaW5nIG1kLW5vcGFkZGluZ1xcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJib3ggcGFkZGluZy1ub25lXFxcIj5cXG5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwibmF2YmFyLXNpZGUgbGlrZS1yb3cgYm9yZGVyLWJvdHRvbVxcXCI+XFxuICAgICAgICAgICAgPCUgaWYgKHVzZXIpIHsgJT5cXG4gICAgICAgICAgICA8YSBocmVmPVxcXCIjXFxcIiBpZD1cXFwibGlrZS1idXR0b25cXFwiIGNsYXNzPVxcXCJsaWtlLWJ1dHRvblxcXCI+XFxuICAgICAgICAgICAgPCUgfSBlbHNlIHsgJT5cXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwibGlrZS1idXR0b25cXFwiPlxcbiAgICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgICAgIDxpIGlkPVxcXCJsaWtlLWJ1dHRvbi1pY29uXFxcIiBjbGFzcz1cXFwiZmEgZmEtc3Rhci1vIGZhLWxnIGdvbGRcXFwiPjwvaT5cXG4gICAgICAgICAgICA8JSBpZiAodXNlcikgeyAlPlxcbiAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICA8JSB9IGVsc2UgeyAlPlxcbiAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgICA8JSB9ICU+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImxpa2UtbnVtYmVyXFxcIiBpZD1cXFwibGlrZS1udW1iZXJcXFwiPjwlLSBtb2RlbC5saWtlQ291bnQgJT48L3NwYW4+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImxpa2UtcGx1cmFsXFxcIiBpZD1cXFwibGlrZS10ZXh0XFxcIiBkYXRhLXBsdXJhbD1cXFwibGlrZXNcXFwiIGRhdGEtc2luZ3VsYXI9XFxcImxpa2VcXFwiPmxpa2VzPC9zcGFuPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwibmF2YmFyLXNpZGUgYm9yZGVyLWJvdHRvbVxcXCI+XFxuICAgICAgICAgICAgPHVsIGNsYXNzPVxcXCJuYXYgbmF2LXBpbGxzIG5hdi1zdGFja2VkXFxcIj5cXG4gICAgICAgICAgICAgIDxsaT5cXG4gICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgaWQ9XFxcImVtYWlsXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtZW52ZWxvcGUtb1xcXCI+PC9pPiA8c3BhbiBjbGFzcz1cXFwiYm94LWljb24tdGV4dFxcXCI+U2hhcmU8L3NwYW4+PC9hPlxcbiAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICA8L3VsPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPCUgaWYgKG1vZGVsLmlzT3duZXIgfHwgKHVzZXIgJiYgdXNlci5pc0FkbWluKSkgeyAlPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJuYXZiYXItc2lkZSA8JSBpZiAodXNlcikgeyAlPmJvcmRlci1ib3R0b208JSB9ICU+XFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGlkPVxcXCJtb2RhbC1jbG9zZVxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgPHVsIGNsYXNzPVxcXCJuYXYgbmF2LXBpbGxzIG5hdi1zdGFja2VkXFxcIj5cXG4gICAgICAgICAgICAgIDxsaSBjbGFzcz1cXFwibGktdGFzay1lZGl0XFxcIj5cXG4gICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgaWQ9XFxcInRhc2stZWRpdFxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXBlbmNpbFxcXCI+PC9pPiA8c3BhbiBjbGFzcz1cXFwiYm94LWljb24tdGV4dFxcXCI+RWRpdCA8c3BhbiBkYXRhLWkxOG49XFxcIlRhc2tcXFwiPk9wcG9ydHVuaXR5PC9zcGFuPjwvc3Bhbj48L2E+XFxuICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgPGxpIGNsYXNzPVxcXCJsaS10YXNrLXZpZXdcXFwiIHN0eWxlPVxcXCJkaXNwbGF5OiBub25lO1xcXCI+XFxuICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGlkPVxcXCJ0YXNrLXZpZXdcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1wZW5jaWxcXFwiPjwvaT4gPHNwYW4gY2xhc3M9XFxcImJveC1pY29uLXRleHRcXFwiPlZpZXcgPHNwYW4gZGF0YS1pMThuPVxcXCJUYXNrXFxcIj5PcHBvcnR1bml0eTwvc3Bhbj48L3NwYW4+PC9hPlxcbiAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICAgIDwlIGlmICghZHJhZnRBZG1pbk9ubHkgfHwgbW9kZWwuc3RhdGUgIT09ICdkcmFmdCcgfHwgKHVzZXIgJiYgdXNlci5pc0FkbWluKSkgeyAlPlxcbiAgICAgICAgICAgICAgPGxpIGlkPVxcXCJsaS10YXNrLWNsb3NlXFxcIiBzdHlsZT1cXFwiPCUgaWYgKG1vZGVsLnN0YXRlID09ICdjbG9zZWQnKSB7ICU+ZGlzcGxheTogbm9uZTs8JSB9ICU+XFxcIj5cXG4gICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgaWQ9XFxcInRhc2stY2xvc2VcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS10aW1lcy1jaXJjbGVcXFwiPjwvaT4gPHNwYW4gY2xhc3M9XFxcImJveC1pY29uLXRleHRcXFwiPkNoYW5nZSA8c3BhbiBkYXRhLWkxOG49XFxcIlRhc2tcXFwiPk9wcG9ydHVuaXR5PC9zcGFuPiBTdGF0ZTwvc3Bhbj48L2E+XFxuICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgPCUgfSBlbHNlIHslPlxcbiAgICAgICAgICAgICAgICA8bGk+PHNwYW4gY2xhc3M9XFxcIm5vLWxpbmtcXFwiPlRoaXMgZHJhZnQgPHNwYW4gZGF0YS1pMThuPVxcXCJ0YXNrXFxcIj5vcHBvcnR1bml0eTwvc3Bhbj4gaXMgYXdhaXRpbmcgYXBwcm92YWwgZnJvbSBhbiBhZG1pbmlzdHJhdG9yLjwvc3Bhbj48L2xpPlxcbiAgICAgICAgICAgICAgPCUgfSAlPlxcbiAgICAgICAgICAgICAgPGxpIGlkPVxcXCJsaS10YXNrLXJlb3BlblxcXCIgc3R5bGU9XFxcIjwlIGlmIChtb2RlbC5zdGF0ZSAhPSAnY2xvc2VkJykgeyAlPmRpc3BsYXk6IG5vbmU7PCUgfSAlPlxcXCI+XFxuICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGlkPVxcXCJ0YXNrLXJlb3BlblxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXNoYXJlXFxcIj48L2k+IDxzcGFuIGNsYXNzPVxcXCJib3gtaWNvbi10ZXh0XFxcIj5SZW9wZW48L3NwYW4+PC9hPlxcbiAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICAgIDwhLS1cXG4gICAgICAgICAgICAgIDxsaT5cXG4gICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgaWQ9XFxcInRhc2stZGVsZXRlXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtdHJhc2gtb1xcXCI+PC9pPiA8c3BhbiBjbGFzcz1cXFwiYm94LWljb24tdGV4dFxcXCI+RGVsZXRlIDxzcGFuIGRhdGEtaTE4bj1cXFwiVGFza1xcXCI+T3Bwb3J0dW5pdHk8L3NwYW4+PC9zcGFuPjwvYT5cXG4gICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgICAtLT5cXG4gICAgICAgICAgICA8L3VsPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPCUgfSAlPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJuYXZiYXItc2lkZSBib3JkZXItYm90dG9tXFxcIiA8JSBpZiAoIXZvbCkgeyU+c3R5bGU9XFxcImRpc3BsYXk6IG5vbmU7XFxcIjwlfSU+PlxcbiAgICAgICAgICAgIDxkaXYgaWQ9XFxcIm1vZGFsLXZvbHVudGVlclxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgPHVsIGNsYXNzPVxcXCJuYXYgbmF2LXBpbGxzIG5hdi1zdGFja2VkXFxcIj5cXG4gICAgICAgICAgICAgIDxsaSBjbGFzcz1cXFwidm9sdW50ZWVyLXRydWVcXFwiIHN0eWxlPVxcXCJkaXNwbGF5OiBub25lO1xcXCI+XFxuICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGlkPVxcXCJ2b2x1bnRlZXJlZFxcXCIgY2xhc3M9XFxcImJ0biBidG4tYzFcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS10aHVtYnMtdXBcXFwiPjwvaT4gPHNwYW4gY2xhc3M9XFxcImJveC1pY29uLXRleHRcXFwiIGRhdGEtaTE4bj1cXFwidGFza1BhZ2Uudm9sdW50ZWVyZWRCdXR0b25cXFwiPlZvbHVudGVlcmVkITwvc3Bhbj48L2E+XFxuXFxuICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgPGxpIGNsYXNzPVxcXCJ2b2x1bnRlZXItZmFsc2VcXFwiPlxcbiAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCIjXFxcIiBpZD1cXFwidm9sdW50ZWVyXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1jMlxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXRodW1icy1vLXVwXFxcIj48L2k+IDxzcGFuIGNsYXNzPVxcXCJib3gtaWNvbi10ZXh0XFxcIiBkYXRhLWkxOG49XFxcInRhc2tQYWdlLnZvbHVudGVlckJ1dHRvblxcXCI+Vm9sdW50ZWVyPC9zcGFuPjwvYT5cXG4gICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgPC91bD5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTEyIHNtLW5vcGFkZGluZyBtZC1ub3BhZGRpbmdcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiYm94IGJveC1tYWluIHRhc2stdmlld1xcXCI+XFxuICAgICAgICAgIDxkaXYgaWQ9XFxcInRhc2stc2hvdy1tYWRsaWItZGVzY3JpcHRpb25cXFwiIGNsYXNzPVxcXCJ0YXNrLXNob3ctZGVzY3JpcHRpb25cXFwiPlxcbiAgICAgICAgICAgIFdlIG5lZWRcXG4gICAgICAgICAgICAgIDxzdHJvbmc+XFxuICAgICAgICAgICAgICAgIDwlIGlmIChtYWRsaWJUYWdzWyd0YXNrLXBlb3BsZSddKSB7ICU+XFxuICAgICAgICAgICAgICAgICAgPCU9IG1hZGxpYlRhZ3NbJ3Rhc2stcGVvcGxlJ11bMF0ubmFtZSAlPlxcbiAgICAgICAgICAgICAgICA8JSB9IGVsc2UgeyAlPlxcbiAgICAgICAgICAgICAgICAgICdubyBwZW9wbGUgeWV0IGFzc2lnbmVkJ1xcbiAgICAgICAgICAgICAgICA8JSB9ICU+XFxuICAgICAgICAgICAgICA8L3N0cm9uZz5cXG5cXG4gICAgICAgICAgICA8JSBpZiAobWFkbGliVGFncy50b3BpYykgeyAlPlxcbiAgICAgICAgICAgIHRvIHdvcmsgb24gYW4gPHNwYW4gZGF0YS1pMThuPVxcXCJ0YXNrXFxcIj5vcHBvcnR1bml0eTwvc3Bhbj4gYWJvdXQ6XFxuICAgICAgICAgICAgICA8c3Ryb25nPlxcbiAgICAgICAgICAgICAgICAgICAgPCUgXy5lYWNoKG1hZGxpYlRhZ3MudG9waWMsIGZ1bmN0aW9uICh0LCBpKSB7ICU+XFxuICAgICAgICAgICAgICAgICAgICA8JSBpZiAoaSA+IDApIHsgJT5cXG4gICAgICAgICAgICAgICAgICAgICxcXG4gICAgICAgICAgICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgICAgICAgICAgIDwlPSB0Lm5hbWUgJT5cXG4gICAgICAgICAgICAgICAgICAgIDwlIH0pICU+XFxuICAgICAgICAgICAgICA8L3N0cm9uZz4uXFxuICAgICAgICAgICAgPCUgfSAlPlxcblxcbiAgICAgICAgICAgIDxiciAvPlxcblxcbiAgICAgICAgICAgIFRoZSBmb2xsb3dpbmcgc2tpbGxzIGFyZSB1c2VmdWwgYW5kXFxuICAgICAgICAgICAgICA8c3Ryb25nPlxcbiAgICAgICAgICAgICAgICA8JSBpZiAobWFkbGliVGFnc1sndGFzay1za2lsbHMtcmVxdWlyZWQnXSkgeyAlPlxcbiAgICAgICAgICAgICAgICAgIDwlPSBtYWRsaWJUYWdzWyd0YXNrLXNraWxscy1yZXF1aXJlZCddWzBdLm5hbWUgJT5cXG4gICAgICAgICAgICAgICAgPCUgfSBlbHNlIHsgJT5cXG4gICAgICAgICAgICAgICAgICBub3QgcmVxdWlyZWRcXG4gICAgICAgICAgICAgICAgPCUgfSAlPlxcbiAgICAgICAgICAgICAgPC9zdHJvbmc+XFxuXFxuICAgICAgICAgICAgdG8gY29tcGxldGUgdGhpcyA8c3BhbiBkYXRhLWkxOG49XFxcInRhc2tcXFwiPm9wcG9ydHVuaXR5PC9zcGFuPjpcXG4gICAgICAgICAgICAgIDxzdHJvbmc+XFxuICAgICAgICAgICAgICAgIDwlIGlmIChtYWRsaWJUYWdzLnNraWxsKSB7ICU+XFxuICAgICAgICAgICAgICAgICAgPCUgXy5lYWNoKG1hZGxpYlRhZ3Muc2tpbGwsIGZ1bmN0aW9uIChzLCBpKSB7ICU+XFxuICAgICAgICAgICAgICAgICAgPCUgaWYgKGkgPiAwKSB7ICU+XFxuICAgICAgICAgICAgICAgICAgLFxcbiAgICAgICAgICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgICAgICAgICA8JT0gcy5uYW1lICU+XFxuICAgICAgICAgICAgICAgICAgPCUgfSkgJT5cXG4gICAgICAgICAgICAgICAgPCUgfSBlbHNlIHsgJT5cXG4gICAgICAgICAgICAgICAgICBubyBzcGVjaWFsIHNraWxscyByZXF1aXJlZFxcbiAgICAgICAgICAgICAgICA8JSB9ICU+XFxuICAgICAgICAgICAgICA8L3N0cm9uZz4uXFxuXFxuXFxuICAgICAgICAgICAgVGhlIDxzcGFuIGRhdGEtaTE4bj1cXFwidGFza1xcXCI+b3Bwb3J0dW5pdHk8L3NwYW4+IHdpbGwgcmVxdWlyZVxcbiAgICAgICAgICAgICAgPHN0cm9uZz5cXG4gICAgICAgICAgICAgICAgPCUgaWYgKG1hZGxpYlRhZ3NbJ3Rhc2stdGltZS1lc3RpbWF0ZSddKSB7ICU+XFxuICAgICAgICAgICAgICAgICAgPCU9IG1hZGxpYlRhZ3NbJ3Rhc2stdGltZS1lc3RpbWF0ZSddWzBdLm5hbWUgJT5cXG4gICAgICAgICAgICAgICAgPCUgfSBlbHNlIHsgJT5cXG4gICAgICAgICAgICAgICAgICBhbiB1bnNwZWNpZmllZCBhbW91bnQgb2YgdGltZVxcbiAgICAgICAgICAgICAgICA8JSB9ICU+XFxuICAgICAgICAgICAgICA8L3N0cm9uZz5cXG5cXG4gICAgICAgICAgICBvZlxcbiAgICAgICAgICAgICAgPHN0cm9uZz5cXG4gICAgICAgICAgICAgICAgPCUgaWYgKG1hZGxpYlRhZ3NbJ3Rhc2stdGltZS1yZXF1aXJlZCddKSB7ICU+XFxuICAgICAgICAgICAgICAgICAgPCU9IG1hZGxpYlRhZ3NbJ3Rhc2stdGltZS1yZXF1aXJlZCddWzBdLm5hbWUgJT5cXG4gICAgICAgICAgICAgICAgPCUgfSBlbHNlIHsgJT5cXG4gICAgICAgICAgICAgICAgICB1bnN0cnVjdHVyZWRcXG4gICAgICAgICAgICAgICAgPCUgfSAlPlxcbiAgICAgICAgICAgICAgPC9zdHJvbmc+XFxuXFxuICAgICAgICAgICAgd29yaywgYW5kXFxuICAgICAgICAgICAgPCUgaWYgKG1hZGxpYlRhZ3NbJ3Rhc2stbGVuZ3RoJ10pIHsgJT5cXG4gICAgICAgICAgICBtdXN0IGJlIGNvbXBsZXRlZCB3aXRoaW5cXG4gICAgICAgICAgICAgIDxzdHJvbmc+XFxuICAgICAgICAgICAgICAgIDwlPSBtYWRsaWJUYWdzWyd0YXNrLWxlbmd0aCddWzBdLm5hbWUgJT48L3N0cm9uZz4uXFxuICAgICAgICAgICAgPCUgfSBlbHNlIHsgJT5cXG4gICAgICAgICAgICAgIDxzdHJvbmc+XFxuICAgICAgICAgICAgICAgIGhhcyBubyBkZWFkbGluZS5cXG4gICAgICAgICAgICAgIDwvc3Ryb25nPlxcbiAgICAgICAgICAgIDwlIH0gJT5cXG5cXG4gICAgICAgICAgICA8JSBpZiAobWFkbGliVGFncy5sb2NhdGlvbikgeyAlPlxcbiAgICAgICAgICAgIFRoZSBwYXJ0aWNpcGFudChzKSBtdXN0IGJlIGxvY2F0ZWQgYXRcXG4gICAgICAgICAgICA8c3Ryb25nPlxcbiAgICAgICAgICAgICAgPCUgXy5lYWNoKG1hZGxpYlRhZ3MubG9jYXRpb24sIGZ1bmN0aW9uIChzLCBpKSB7ICU+XFxuICAgICAgICAgICAgICA8JSBpZiAoaSA+IDApIHsgJT5cXG4gICAgICAgICAgICAgICxcXG4gICAgICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgICAgIDwlPSBzLm5hbWUgJT5cXG4gICAgICAgICAgICAgIDwlIH0pICU+XFxuICAgICAgICAgICAgPC9zdHJvbmc+XFxuICAgICAgICAgICAgdG8gY29tcGxldGUgdGhpcyA8c3BhbiBkYXRhLWkxOG49XFxcInRhc2tcXFwiPm9wcG9ydHVuaXR5PC9zcGFuPi5cXG4gICAgICAgICAgICA8JSB9IGVsc2UgeyAlPlxcbiAgICAgICAgICAgIFRoZSBwYXJ0aWNpcGFudChzKSBjYW4gYmUgbG9jYXRlZCBhbnl3aGVyZS5cXG4gICAgICAgICAgICA8JSB9ICU+XFxuICAgICAgICAgICAgPC9zdHJvbmc+XFxuXFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0xMiBzbS1ub3BhZGRpbmcgbWQtbm9wYWRkaW5nXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImJveCB0YXNrLWJvdGhcXFwiPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJib3gtcGFkLWxyIGJvcmRlci1ib3R0b21cXFwiPlxcbiAgICAgICAgICAgIDxoMj5SZXF1ZXN0b3IgYW5kIFBhcnRpY2lwYW50c1xcbiAgICAgICAgICAgIDwvaDI+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJib3gtbWFpblxcXCIgaWQ9XFxcInRhc2stdm9sdW50ZWVyc1xcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicHJvamVjdC1wZW9wbGUtZGl2XFxcIiBkYXRhLXVzZXJpZD1cXFwiPCU9IG1vZGVsLnVzZXJJZCAlPlxcXCI+XFxuICAgICAgICAgICAgICA8aW1nIHNyYz1cXFwiL2FwaS91c2VyL3Bob3RvLzwlPSBtb2RlbC51c2VySWQgJT5cXFwiIGNsYXNzPVxcXCJwcm9qZWN0LXBlb3BsZVxcXCIgYWx0PVxcXCI8JT0gbW9kZWwub3duZXIubmFtZSAlPlxcXCIvPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInByb2plY3QtcGVvcGxlLXNwYWNlXFxcIj5cXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImJhclxcXCI+XFxuICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8JSBfLmVhY2gobW9kZWwudm9sdW50ZWVycywgZnVuY3Rpb24gKHYpIHsgJT5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwcm9qZWN0LXBlb3BsZS1kaXZcXFwiIGRhdGEtdXNlcmlkPVxcXCI8JT0gdi51c2VySWQgJT5cXFwiIGRhdGEtdm9sdXNlcmlkPVxcXCI8JT0gdi51c2VySWQgJT5cXFwiPlxcbiAgICAgICAgICAgICAgPGltZyBzcmM9XFxcIi9hcGkvdXNlci9waG90by88JT0gdi51c2VySWQgJT5cXFwiIGNsYXNzPVxcXCJwcm9qZWN0LXBlb3BsZVxcXCIgYWx0PVxcXCI8JT0gdi5uYW1lICU+XFxcIi8+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPCUgfSk7ICU+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0xMiB0YXNrLXZpZXcgc20tbm9wYWRkaW5nIG1kLW5vcGFkZGluZ1xcXCI+XFxuXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJib3ggY29tbWVudC1saXN0LXdyYXBwZXJcXFwiIHN0eWxlPVxcXCJjbGVhcjogYm90aDtcXFwiPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJib3gtcGFkLWxyIGJvcmRlci1ib3R0b21cXFwiPlxcbiAgICAgICAgICAgIDxoMj5EaXNjdXNzaW9uXFxuICAgICAgICAgICAgPCUgaWYgKHVzZXIpIHsgJT5cXG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidG4gYnRuLWMwIGJ0bi1zbSBmaWxlLWFkZCBuZXctdG9waWNcXFwiIGlkPVxcXCJwcm9qZWN0LXRvcGljLW5ld1xcXCI+TmV3IFRvcGljPC9idXR0b24+XFxuICAgICAgICAgICAgPCUgfSAlPlxcbiAgICAgICAgICAgIDwvaDI+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImJveC1wYWQtbHIgYm94LXBhZC10IHRvcGljLWZvcm0td3JhcHBlclxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgPHVsIGlkPVxcXCJjb21tZW50LWxpc3QtbnVsbFxcXCI+XFxuICAgICAgICAgICAgPC91bD5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICA8L2Rpdj5cXG5cXG4gIDxkaXYgY2xhc3M9XFxcImNvbC1tZC1wdWxsLTggY29sLXNtLXB1bGwtOCBjb2wtc20tNCBjb2wtbWQtNCBwcm9qZWN0LXNpZGViYXIgbWQtbm9wYWRkaW5nLXJpZ2h0XFxcIj5cXG4gICAgPCEtLSBMRUZUIFNJREVCQVIgLS0+XFxuICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTEyIGJveCBzbS1ub3BhZGRpbmdcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiYm94LW1haW4gdGFnLXdyYXBwZXJcXFwiPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0xMiBib3ggdGFzay12aWV3IHNtLW5vcGFkZGluZ1xcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJhdHRhY2htZW50LXdyYXBwZXJcXFwiPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHA+SW4gb3JkZXIgdG8gaW50cm9kdWNlIHlvdSBhcyBwYXJ0IG9mIHRoZSBzaWduIHVwIHByb2Nlc3MsIHdlIHdvdWxkIGxpa2UgdG8gZmlsbCBpbiB5b3VyIHByb2ZpbGUuIFBsZWFzZSBlbnRlciB5b3VyIG5hbWU6PC9wPlxcbjxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2wgdmFsaWRhdGVcXFwiIGlkPVxcXCJ1cGRhdGUtbmFtZS1maWVsZFxcXCIgbmFtZT1cXFwidXBkYXRlLW5hbWUtZmllbGRcXFwiIHBsYWNlaG9sZGVyPVxcXCJGdWxsIE5hbWVcXFwiIGRhdGEtdmFsaWRhdGU9XFxcImVtcHR5XFxcIj5cXG4gIDxzcGFuIGNsYXNzPVxcXCJoZWxwLWJsb2NrIGVycm9yLWVtcHR5XFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI+UGxlYXNlIGVudGVyIHlvdXIgZnVsbCBuYW1lLjwvc3Bhbj5cXG48L2Rpdj5cXG5cIjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG5cXHQ8cD5UaGFuayB5b3UgZm9yIHZvbHVudGVlcmluZy4gUGxlYXNlIGJlIHN1cmUgeW91IGhhdmUgdGhlIGF2YWlsYWJpbGl0eSBhbmQgZXhwZXJ0aXNlIHRvIHN1cHBvcnQgdGhpcyBvcHBvcnR1bml0eSB0byBjb21wbGV0aW9uLiBXZSB3aWxsIG5vdGlmeSB5b3VyIHN1cGVydmlzb3Igb2YgeW91ciBpbnRlcmVzdCBpbiB0aGlzIHByb2plY3Qgc28gdGhhdCBoZSBvciBzaGUgaXMgYXdhcmUgdGhhdCB5b3UgcGxhbiB0byBpbmNsdWRlIHRoaXMgd29yayBkdXJpbmcgeW91ciByZWd1bGFybHkgc2NoZWR1bGVkIHdvcmsgd2VlayB0byBzdXBwb3J0IERlcGFydG1lbnQgY29sbGVhZ3VlcyBhbmQgcHJvamVjdHMuIEt1ZG9zIHRvIHlvdSE8L3A+XFxuXFx0PHA+UGxlYXNlIGVudGVyICB0aGUgbmFtZSBhbmQgZW1haWwgYWRkcmVzcyBvZiB5b3VyIHN1cGVydmlzb3IgYmVsb3cuIElmIHlvdeKAmXZlIHByZXZpb3VzbHkgdm9sdW50ZWVyZWQsIHRoZSBsYXN0IHN1cGVydmlzb3IgZW1haWwgeW91IHByb3ZpZGVkIGlzIHNob3duLiBQbGVhc2UgdXBkYXRlIGl0IGlmIG5lY2Vzc2FyeS48L3A+XFxuXFx0PHNwYW4gY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcblxcdFxcdDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBpZD1cXFwidXNlclN1cGVyVmlzb3JOYW1lXFxcIiBwbGFjZWhvbGRlcj1cXFwiU3VwZXJ2aXNvciBOYW1lXFxcIiBjbGFzcz1cXFwidmFsaWRhdGVcXFwiIGRhdGEtdmFsaWRhdGU9XFxcImVtcHR5XFxcIiB2YWx1ZT1cXFwiPCU9IHN1cGVydmlzb3JOYW1lICU+XFxcIi8+XFxuXFx0XFx0PGlucHV0IHR5cGU9XFxcInRleHRcXFwiIGlkPVxcXCJ1c2VyU3VwZXJWaXNvckVtYWlsXFxcIiBwbGFjZWhvbGRlcj1cXFwiU3VwZXJ2aXNvciBlbWFpbCBhZGRyZXNzXFxcIiBjbGFzcz1cXFwidmFsaWRhdGVcXFwiIGRhdGEtdmFsaWRhdGU9XFxcImVtcHR5LGVtYWlsLGVtYWlsZG9tYWluXFxcIiBkYXRhLWVtYWlsZG9tYWluPVxcXCJzdGF0ZS5nb3ZcXFwiIHZhbHVlPVxcXCI8JT0gc3VwZXJ2aXNvckVtYWlsICU+XFxcIi8+XFxuXFx0XFx0PHNwYW4gY2xhc3M9XFxcImhlbHAtYmxvY2sgZXJyb3ItZW1haWwgZXJyb3ItZW1wdHkgZXJyb3ItZW1haWxkb21haW5cXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIj5Zb3UgbXVzdCBlbnRlciBhIG5hbWUgYW5kIGEgdmFsaWQgU3RhdGUgRGVwYXJ0bWVudCBlbWFpbCBhZGRyZXNzIHRvIHByb2NlZWQuPC9zcGFuPlxcblxcdDwvc3Bhbj5cXG48L2Rpdj5cXG5cIjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8cCBkYXRhLWkxOG49XFxcInZvbHVudGVlck1vZGFsLm5vdGlmeVN1cGVydmlzb3JcXFwiPkkgdW5kZXJzdGFuZCBpdCBpcyBteSByZXNwb25zaWJpbGl0eSB0byBjb25maXJtIHN1cGVydmlzb3IgYXBwcm92YWwgcHJpb3IgdG8gY29tbWl0dGluZyB0byBhbiBvcHBvcnR1bml0eS48L3A+XFxuPHAgZGF0YS1pMThuPVxcXCJ2b2x1bnRlZXJNb2RhbC5jYW50Q2FuY2VsXFxcIj5PbmNlIHlvdSB2b2x1bnRlZXIgZm9yIGFuIG9wcG9ydHVuaXR5LCB5b3Ugd2lsbCBub3QgYmUgYWJsZSB0byBjYW5jZWwgeW91ciBjb21taXRtZW50IHRvIHZvbHVudGVlci48L3A+XFxuXCI7XG4iLCJ2YXIgQm9vdHN0cmFwID0gcmVxdWlyZSgnYm9vdHN0cmFwJyk7XG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgVUlDb25maWcgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb25maWcvdWkuanNvbicpO1xudmFyIGFzeW5jID0gcmVxdWlyZSgnYXN5bmMnKTtcbnZhciBtYXJrZWQgPSByZXF1aXJlKCdtYXJrZWQnKTtcbnZhciBUaW1lQWdvID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vLi4vdmVuZG9yL2pxdWVyeS50aW1lYWdvJyk7XG52YXIgQmFzZVZpZXcgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9iYXNlL2Jhc2VfdmlldycpO1xudmFyIFRhc2tTaG93VGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvdGFza19zaG93X2l0ZW1fdGVtcGxhdGUuaHRtbCcpO1xuXG5cbnZhciBUYXNrSXRlbVZpZXcgPSBCYXNlVmlldy5leHRlbmQoe1xuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5tb2RlbC50cmlnZ2VyKFwidGFzazptb2RlbDpmZXRjaFwiLCBvcHRpb25zLmlkKTtcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsIFwidGFzazptb2RlbDpmZXRjaDpzdWNjZXNzXCIsIGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgc2VsZi5tb2RlbCA9IG1vZGVsO1xuICAgICAgc2VsZi5pbml0aWFsaXplVGFncyhzZWxmKTtcbiAgICB9KTtcbiAgfSxcblxuICBnZXRUYWdEYXRhOiBmdW5jdGlvbiAoc2VsZiwgY2IpIHtcbiAgICAkLmFqYXgoe1xuICAgICAgdXJsOiAnL2FwaS90YWcvZmluZEFsbEJ5VGFza0lkLycgKyBzZWxmLm9wdGlvbnMuaWQsXG4gICAgICBhc3luYzogZmFsc2UsXG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBzZWxmLnRhZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgc2VsZi50YWdzLnB1c2goZGF0YVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQnVpbGQgb2JqZWN0IGZvciByZW5kZXJcbiAgICAgICAgc2VsZi5kYXRhID0ge1xuICAgICAgICAgIHVzZXI6IHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlcixcbiAgICAgICAgICBtb2RlbDogc2VsZi5tb2RlbC50b0pTT04oKSxcbiAgICAgICAgICB0YWdzOiBzZWxmLnRhZ3NcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5kYXRhWydtYWRsaWJUYWdzJ10gPSBvcmdhbml6ZVRhZ3Moc2VsZi50YWdzKTtcbiAgICAgICAgLy8gY29udmVydCBkZXNjcmlwdGlvbiBmcm9tIG1hcmtkb3duIHRvIGh0bWxcbiAgICAgICAgc2VsZi5kYXRhLm1vZGVsLmRlc2NyaXB0aW9uSHRtbCA9IG1hcmtlZChzZWxmLmRhdGEubW9kZWwuZGVzY3JpcHRpb24pO1xuICAgICAgICBzZWxmLm1vZGVsLnRyaWdnZXIoJ3Rhc2s6dGFnOmRhdGEnLCBzZWxmLnRhZ3MsIHNlbGYuZGF0YVsnbWFkbGliVGFncyddKTtcbiAgICAgICAgcmV0dXJuIGNiKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIChzZWxmKSB7XG4gICAgc2VsZi5nZXRUYWdEYXRhKHNlbGYsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkID0gc2VsZi5kYXRhLFxuICAgICAgICAgIHZvbCA9ICgoIWQudXNlciB8fCBkLnVzZXIuaWQgIT09IGQubW9kZWwudXNlcklkKSAmJiBkLm1vZGVsLnN0YXRlICE9PSAnZHJhZnQnKTtcbiAgICAgIHNlbGYuZGF0YS51aSA9IFVJQ29uZmlnO1xuICAgICAgc2VsZi5kYXRhLnZvbCA9IHZvbDtcbiAgICAgIHZhciBjb21waWxlZFRlbXBsYXRlID0gXy50ZW1wbGF0ZShUYXNrU2hvd1RlbXBsYXRlKShzZWxmLmRhdGEpO1xuICAgICAgc2VsZi4kZWwuaHRtbChjb21waWxlZFRlbXBsYXRlKTtcbiAgICAgIHNlbGYuJGVsLmkxOG4oKTtcbiAgICAgICQoXCJ0aW1lLnRpbWVhZ29cIikudGltZWFnbygpO1xuICAgICAgc2VsZi51cGRhdGVUYXNrRW1haWwoKTtcbiAgICAgIHNlbGYubW9kZWwudHJpZ2dlcigndGFzazpzaG93OnJlbmRlcjpkb25lJyk7XG4gICAgfSk7XG4gIH0sXG5cbiAgdXBkYXRlVGFza0VtYWlsOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgJC5hamF4KHtcbiAgICAgIHVybDogZW5jb2RlVVJJKCcvYXBpL2VtYWlsL21ha2VVUkw/ZW1haWw9Y29udGFjdFVzZXJBYm91dFRhc2smc3ViamVjdD1DaGVjayBPdXQgXCInKyBzZWxmLm1vZGVsLmF0dHJpYnV0ZXMudGl0bGUgKyAnXCInICtcbiAgICAgICcmb3Bwb3J0dW5pdHlUaXRsZT0nICsgc2VsZi5tb2RlbC5hdHRyaWJ1dGVzLnRpdGxlICtcbiAgICAgICcmb3Bwb3J0dW5pdHlMaW5rPScgKyB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyB3aW5kb3cubG9jYXRpb24uaG9zdCArIFwiXCIgKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgK1xuICAgICAgJyZvcHBvcnR1bml0eURlc2NyaXB0aW9uPScgKyAoc2VsZi5tb2RlbC5hdHRyaWJ1dGVzLmRlc2NyaXB0aW9uIHx8ICcnKSArXG4gICAgICAnJm9wcG9ydHVuaXR5TWFkbGlicz0nICsgJCgnPGRpdiAvPicsIHsgaHRtbDogc2VsZi4kKCcjdGFzay1zaG93LW1hZGxpYi1kZXNjcmlwdGlvbicpLmh0bWwoKSB9KS50ZXh0KCkucmVwbGFjZSgvXFxzKy9nLCBcIiBcIikpLFxuICAgICAgdHlwZTogJ0dFVCdcbiAgICB9KS5kb25lKCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgc2VsZi4kKCcjZW1haWwnKS5hdHRyKCdocmVmJywgZGF0YSk7XG4gICAgfSk7XG5cbiAgfSxcblxuICBpbml0aWFsaXplVGFnczogZnVuY3Rpb24gKHNlbGYpIHtcbiAgICB2YXIgdHlwZXMgPSBbXCJ0YXNrLXNraWxscy1yZXF1aXJlZFwiLCBcInRhc2stdGltZS1yZXF1aXJlZFwiLCBcInRhc2stcGVvcGxlXCIsIFwidGFzay1sZW5ndGhcIiwgXCJ0YXNrLXRpbWUtZXN0aW1hdGVcIl07XG5cbiAgICBzZWxmLnRhZ1NvdXJjZXMgPSB7fTtcblxuICAgIHZhciByZXF1ZXN0QWxsVGFnc0J5VHlwZSA9IGZ1bmN0aW9uICh0eXBlLCBjYikge1xuICAgICAgJC5hamF4KHtcbiAgICAgICAgdXJsOiAnL2FwaS9hYy90YWc/dHlwZT0nICsgdHlwZSArICcmbGlzdCcsXG4gICAgICAgIHR5cGU6ICdHRVQnLFxuICAgICAgICBhc3luYzogZmFsc2UsXG4gICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgLy8gRHluYW1pY2FsbHkgY3JlYXRlIGFuIGFzc29jaWF0aXZlXG4gICAgICAgICAgLy8gYXJyYXkgYmFzZWQgb24gdGhhdCBmb3IgdGhlIHBvaW50ZXIgdG8gdGhlIGxpc3QgaXRzZWxmIHRvIGJlIGl0ZXJhdGVkIHRocm91Z2hcbiAgICAgICAgICAvLyBvbiB0aGUgZnJvbnQtZW5kLlxuICAgICAgICAgIHNlbGYudGFnU291cmNlc1t0eXBlXSA9IGRhdGE7XG4gICAgICAgICAgcmV0dXJuIGNiKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jLmVhY2godHlwZXMsIHJlcXVlc3RBbGxUYWdzQnlUeXBlLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBzZWxmLm1vZGVsLnRyaWdnZXIoJ3Rhc2s6dGFnOnR5cGVzJywgc2VsZi50YWdTb3VyY2VzKTtcbiAgICAgIHNlbGYucmVuZGVyKHNlbGYpO1xuICAgIH0pO1xuICB9LFxuXG4gIGNsZWFudXA6IGZ1bmN0aW9uKCkge1xuICAgIHJlbW92ZVZpZXcodGhpcyk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRhc2tJdGVtVmlldztcbiIsIlxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xuXG5cblx0QmFzZUNvbXBvbmVudCA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcblxuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHt9XG5cblx0fSk7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBCYXNlQ29tcG9uZW50O1xuIiwiLy8gQmFzZSBDb250cm9sbGVyXG5cblxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xuXG5cblx0QmFzZUNvbnRyb2xsZXIgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG5cdFx0XG5cdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge30sXG5cblx0XHQvLyAtLS0tLS0tLS0tLS1cblx0XHQvLz0gQ2xhc3MgTWV0aG9kcyBhdmFpbGFibGUgZm9yIG90aGVyIHZpZXdzIFxuXHRcdC8vIC0tLS0tLS0tLS0tLVxuXG5cdFx0aW5pdGlhbGl6ZVZpZXdTYWZlbHk6IGZ1bmN0aW9uICh2aWV3TmFtZSkge1xuXHRcdFx0aWYgKHRoaXMudmlldykge1xuXHRcdFx0XHR0aGlzLnZpZXcuaW5pdGlhbGl6ZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy52aWV3ID0gbmV3IHZpZXdOYW1lKCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGNsZWFudXA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdCQodGhpcykucmVtb3ZlKCk7XG5cdFx0fVxuXG5cdH0pO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gQmFzZUNvbnRyb2xsZXI7XG5cbiIsIi8vIFRoaXMgY2xhc3MgaW1wbGVtZW50cyBhIHBhcmFkaWdtIHdoZXJlaW4gaXQgcmVuZGVycyBpdHMgb3duIGNoaWxkIGNsYXNzLlxuLy8gRG9pbmcgdGhpcyBhbGxvd3MgdXMgdG8gcGVyZm9ybSBsb2dpYyBhZ2FpbnN0IGl0LlxuXG4vLyBOT1RFUzpcbi8vICd0aGlzJyByZWZlcnMgdG8gdGhlIHByb3RvdHlwZSBjbGFzcywgbm90IHRoZSBjb25zdHJ1Y3RvciAobG9naWNhbCB0aGlzKS5cbi8vIFRoaXMgaXMgdmVyeSB1c2VmdWwgZm9yIHNtYWxsZXIgZWwgcmVnaW9ucywgc3VjaCBhcyBhIHRhc2sgbGlzdFxuLy8gb3IgYW55dGhpbmcgdGhhdCByZXF1aXJlcyBhIHNtYWxsIHNwaW5uZXIuICBDdXJyZW50bHkgdG8gYWRkIGEgYmlnZ2VyIHNwaW5uZXJcbi8vIEknZCBoYXZlIHRvIGV4Y2hhbmdlIHRoZSBnaWYgY3VycmVudGx5IHByb3ZpZGVkIGJ5IGZvbnQtYXdlc29tZS5cblxuXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgdXRpbGl0aWVzID0gcmVxdWlyZSgnLi4vbWl4aW5zL3V0aWxpdGllcycpO1xuXG5cbnZhciBCYXNlVmlldyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gIH0sXG5cbiAgY2xlYW51cDogZnVuY3Rpb24gKCkge1xuICAgIHJlbW92ZVZpZXcodGhpcyk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZVZpZXc7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwiYWxlcnQgPCUgaWYgKGFsZXJ0LnR5cGUpIHsgJT48JT0gYWxlcnQudHlwZSAlPjwlIH0gZWxzZSB7ICU+YWxlcnQtZGFuZ2VyPCUgfSAlPlxcXCIgaWQ9XFxcImFsZXJ0LW1haW5cXFwiPlxcbiAgPCUgaWYgKGFsZXJ0LmRpc21pc3MpIHsgJT5cXG4gIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiY2xvc2VcXFwiIGRhdGEtZGlzbWlzcz1cXFwiYWxlcnRcXFwiIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIj4mdGltZXM7PC9idXR0b24+XFxuICA8JSB9ICU+XFxuICA8JT0gYWxlcnQubWVzc2FnZSAlPlxcbjwvZGl2PlxcblwiO1xuIiwiLyoqXG4gKiBUaGlzIGNvbXBvbmVudCBpbXBsZW1lbnRzIGEgTWFya2Rvd24gVGV4dEVkaXRvciB0aGF0IGNhbiBiZVxuICogZHJvcHBlZCBpbnRvIGFueXdoZXJlIG9uIGFuIGV4aXN0aW5nIGZvcm0uXG4gKiBJbml0aWFsaXplIHRoZSBNYXJrZG93bkVkaXRvciB3aXRoIGFuIGVsZW1lbnQgYGVsYCxcbiAqIGFuZCB0aGUgYGlkYCBvZiB0aGUgdGV4dGFyZWEgKHNvIHlvdSBjYW4gcmV0cmVpdmUgaXRzXG4gKiB2YWx1ZSB3aGVuIHRoZSB1c2VyIHN1Ym1pdHMgdGhlIGZvcm0uKVxuICpcbiAqIE9wdGlvbnM6XG4gKiAgIGVsOiBIVE1MIGVsZW1lbnQgdG8gZmlsbCAtIHJlcXVpcmVkXG4gKiAgIGlkOiBIVE1MIElEIGZvciB0aGUgPHRleHRhcmVhPiBlbGVtZW50IC0gcmVxdWlyZWRcbiAqICAgZGF0YTogRGVmYXVsdCBkYXRhIGZvciB0aGUgdGV4dGFyZWEgLSByZXF1aXJlZFxuICogICBwbGFjZWhvbGRlcjogVGV4dGFyZWEgcGxhY2Vob2xkZXIgdmFsdWUgLSBvcHRpb25hbFxuICogICBtYXhsZW5ndGg6IE1heGltdW0gY2hhcmFjdGVycyBmb3IgdGhlIHRleHQgYXJlYSAtIG9wdGlvbmFsXG4gKiAgIHJvd3M6IE51bWJlciBvZiByb3dzIGluIHRoZSB0ZXh0YXJlYSAtIG9wdGlvbmFsXG4gKiAgIHZhbGlkYXRlOiBMaXN0IG9mIHN0cmluZ3MgZm9yIHRoZSBkYXRhLXZhbGlkYXRlIGF0dHJpYnV0ZSAtIG9wdGlvbmFsXG4gKiAgICAgZXhhbXBsZTogWydlbXB0eScsICdjb3VudDQwMCddXG4gKi9cblxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vbWl4aW5zL3V0aWxpdGllcycpO1xudmFyIG1hcmtlZCA9IHJlcXVpcmUoJ21hcmtlZCcpO1xudmFyIEJhc2VDb21wb25lbnQgPSByZXF1aXJlKCcuLi9iYXNlL2Jhc2VfY29tcG9uZW50Jyk7XG52YXIganFTZWxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi92ZW5kb3IvanF1ZXJ5LnNlbGVjdGlvbicpO1xudmFyIEVkaXRvclRlbXBsYXRlID0gcmVxdWlyZSgnLi9tYXJrZG93bl9lZGl0b3JfdGVtcGxhdGUuaHRtbCcpO1xuXG5cbk1hcmtkb3duRWRpdG9yID0gQmFzZUNvbXBvbmVudC5leHRlbmQoe1xuXG4gIGV2ZW50czoge1xuICAgIFwiY2xpY2sgLmJ0blwiICAgICAgICAgICAgICAgICA6IFwiY2xpY2tCdXR0b25cIlxuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmFjdGlvbnMgPSB7XG4gICAgICAnYm9sZCc6IHtcbiAgICAgICAgYmVmb3JlOiAnKionLFxuICAgICAgICB0ZXh0OiAndGV4dCcsXG4gICAgICAgIGFmdGVyOiAnKionXG4gICAgICB9LFxuICAgICAgJ2l0YWxpYyc6IHtcbiAgICAgICAgYmVmb3JlOiAnXycsXG4gICAgICAgIHRleHQ6ICd0ZXh0JyxcbiAgICAgICAgYWZ0ZXI6ICdfJ1xuICAgICAgfSxcbiAgICAgICdzdHJpa2V0aHJvdWdoJzoge1xuICAgICAgICBiZWZvcmU6ICd+ficsXG4gICAgICAgIHRleHQ6ICd0ZXh0JyxcbiAgICAgICAgYWZ0ZXI6ICd+fidcbiAgICAgIH0sXG4gICAgICAnY29kZSc6IHtcbiAgICAgICAgYmVmb3JlOiAnYCcsXG4gICAgICAgIHRleHQ6ICdjb2RlJyxcbiAgICAgICAgYWZ0ZXI6ICdgJ1xuICAgICAgfSxcbiAgICAgICdsaW5rJzoge1xuICAgICAgICBiZWZvcmU6ICdbTGluayBUaXRsZV0oJyxcbiAgICAgICAgdGV4dDogJ2h0dHA6Ly8nLFxuICAgICAgICBhZnRlcjogJyknXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhID0ge1xuICAgICAgaWQ6IHRoaXMub3B0aW9ucy5pZCxcbiAgICAgIHZhbGlkYXRlOiB0aGlzLm9wdGlvbnMudmFsaWRhdGUsXG4gICAgICByb3dzOiB0aGlzLm9wdGlvbnMucm93cyxcbiAgICAgIG1heGxlbmd0aDogdGhpcy5vcHRpb25zLm1heGxlbmd0aCxcbiAgICAgIHBsYWNlaG9sZGVyOiB0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXIsXG4gICAgICB0aXRsZTogdGhpcy5vcHRpb25zLnRpdGxlLFxuICAgICAgZGF0YTogdGhpcy5vcHRpb25zLmRhdGFcbiAgICB9O1xuICAgIHZhciB0ZW1wbGF0ZSA9IF8udGVtcGxhdGUoRWRpdG9yVGVtcGxhdGUpKGRhdGEpO1xuICAgIHRoaXMuJGVsLmh0bWwodGVtcGxhdGUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGNsaWNrQnV0dG9uOiBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHZhciB0ID0gJChlLmN1cnJlbnRUYXJnZXQpO1xuICAgIHZhciBzZWxUZXh0ID0gdGhpcy4kKFwiI1wiICsgdGhpcy5vcHRpb25zLmlkKS5zZWxlY3Rpb24oKTtcbiAgICB2YXIgZWRpdERhdGEgPSB0LmRhdGEoJ2VkaXQnKTtcbiAgICBpZiAoKGVkaXREYXRhICE9ICdwcmV2aWV3JykgJiZcbiAgICAgICAgKGVkaXREYXRhICE9ICdlZGl0JykgJiZcbiAgICAgICAgKGVkaXREYXRhICE9ICdoZWxwJykpIHtcbiAgICAgIC8vIGdldCB0aGUgY3VycmVudCBzZWxlY3RlZCBwb3NpdGlvbnNcbiAgICAgIHZhciBwb3MgPSB0aGlzLiQoXCIjXCIgKyB0aGlzLm9wdGlvbnMuaWQpLnNlbGVjdGlvbignZ2V0UG9zJyk7XG4gICAgICB2YXIgdGV4dCA9IHRoaXMuJChcIiNcIiArIHRoaXMub3B0aW9ucy5pZCkudmFsKCk7XG4gICAgICAvLyBjaGVjayBpZiB0aGlzIG1vZGlmaWVyIGhhcyBhbHJlYWR5IGJlZW4gaW5zZXJ0ZWRcbiAgICAgIHZhciBvcmlnQmVmb3JlID0gdGV4dC5zdWJzdHJpbmcocG9zLnN0YXJ0LXRoaXMuYWN0aW9uc1tlZGl0RGF0YV0uYmVmb3JlLmxlbmd0aCxwb3Muc3RhcnQpO1xuICAgICAgdmFyIG9yaWdBZnRlciA9IHRleHQuc3Vic3RyaW5nKHBvcy5lbmQscG9zLmVuZCt0aGlzLmFjdGlvbnNbZWRpdERhdGFdLmFmdGVyLmxlbmd0aCk7XG4gICAgICB2YXIgYmVmb3JlID0gdGhpcy5hY3Rpb25zW2VkaXREYXRhXS5iZWZvcmU7XG4gICAgICB2YXIgYWZ0ZXIgPSB0aGlzLmFjdGlvbnNbZWRpdERhdGFdLmFmdGVyO1xuICAgICAgLy8gSWYgdGhlIHNlbGVjdGVkIHRleHQgYWxyZWFkeSBoYXMgdGhlIG1hcmtkb3duIHN5bnRheCBiZWZvcmUgYW5kIGFmdGVyXG4gICAgICAvLyBkb24ndCBpbnNlcnQgaXQgYWdhaW4uICBFZywgaWYgdGV4dCBpcyBzZWxlY3RlZCBpbiAqKnRleHQqKiwgZG9uJ3QgYWRkICoqIGFnYWluXG4gICAgICBpZiAoKG9yaWdCZWZvcmUgPT0gYmVmb3JlKSAmJiAob3JpZ0FmdGVyID09IGFmdGVyKSkge1xuICAgICAgICBiZWZvcmUgPSAnJztcbiAgICAgICAgYWZ0ZXIgPSAnJztcbiAgICAgIH1cbiAgICAgIC8vIHNldCBwbGFjZWhvbGRlciB0ZXh0IGlmIG5vIHRleHQgaXMgc2VsZWN0ZWQgYnkgdGhlIHVzZXJcbiAgICAgIGlmIChzZWxUZXh0ID09ICcnKSB7XG4gICAgICAgIHNlbFRleHQgPSB0aGlzLmFjdGlvbnNbZWRpdERhdGFdLnRleHQ7XG4gICAgICB9XG4gICAgICAvLyBpbnNlcnQgbWFya2Rvd24gc3ludGF4XG4gICAgICB0aGlzLiQoXCIjXCIgKyB0aGlzLm9wdGlvbnMuaWQpLnNlbGVjdGlvbignaW5zZXJ0Jywge1xuICAgICAgICB0ZXh0OiBiZWZvcmUsXG4gICAgICAgIG1vZGU6ICdiZWZvcmUnXG4gICAgICB9KVxuICAgICAgLnNlbGVjdGlvbigncmVwbGFjZScsIHtcbiAgICAgICAgdGV4dDogc2VsVGV4dFxuICAgICAgfSlcbiAgICAgIC5zZWxlY3Rpb24oJ2luc2VydCcsIHtcbiAgICAgICAgdGV4dDogYWZ0ZXIsXG4gICAgICAgIG1vZGU6ICdhZnRlcidcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoZWRpdERhdGEgPT0gJ2hlbHAnKSB7XG4gICAgICAvLyBzaG93IGhlbHAgdGV4dCBhbmQgbGlua3MgdG8gbWFya2Rvd24gc3ludGF4XG4gICAgICBpZiAodGhpcy4kKCcuaGVscCcpLmlzKCc6dmlzaWJsZScpKSB7XG4gICAgICAgIHRoaXMuJCgnLmhlbHAnKS5oaWRlKCk7XG4gICAgICAgIHQucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4kKCcuaGVscCcpLnNob3coKTtcbiAgICAgICAgdC5hZGRDbGFzcygnYWN0aXZlJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLiQoJy5wcmV2aWV3JykuaXMoJzp2aXNpYmxlJykpIHtcbiAgICAgICAgLy8gaWYgd2UncmUgaW4gcHJldmlldyBtb2RlLCBzd2l0Y2ggYmFjayB0byBlZGl0IG1vZGVcbiAgICAgICAgdGhpcy4kKCcuYnRuLWVkaXQnKS5oaWRlKCk7XG4gICAgICAgIHRoaXMuJCgnLmJ0bi1wcmV2aWV3Jykuc2hvdygpO1xuICAgICAgICB0aGlzLiQoJy5wcmV2aWV3JykuaGlkZSgpO1xuICAgICAgICB0aGlzLiQoXCIjXCIgKyB0aGlzLm9wdGlvbnMuaWQpLnNob3coKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlbmRlciB0aGUgcHJldmlldyB1c2luZyBtYXJrZWRcbiAgICAgICAgdmFyIGh0bWwgPSBtYXJrZWQodGhpcy4kKFwiI1wiICsgdGhpcy5vcHRpb25zLmlkKS52YWwoKSk7XG4gICAgICAgIHRoaXMuJCgnLmJ0bi1wcmV2aWV3JykuaGlkZSgpO1xuICAgICAgICB0aGlzLiQoJy5idG4tZWRpdCcpLnNob3coKTtcbiAgICAgICAgdGhpcy4kKCcucHJldmlldycpLmh0bWwoaHRtbCk7XG4gICAgICAgIHRoaXMuJChcIiNcIiArIHRoaXMub3B0aW9ucy5pZCkuaGlkZSgpO1xuICAgICAgICB0aGlzLiQoJy5wcmV2aWV3Jykuc2hvdygpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXJrZG93bkVkaXRvcjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJidG4tdG9vbGJhclxcXCIgcm9sZT1cXFwidG9vbGJhclxcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJidG4tZ3JvdXAgYnRuLWdyb3VwLXNtXFxcIj5cXG4gICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWMwXFxcIiBkYXRhLWVkaXQ9XFxcImJvbGRcXFwiIHRpdGxlPVxcXCJCb2xkXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtYm9sZFxcXCIgYWx0PVxcXCJCb2xkXFxcIj48L2k+PC9idXR0b24+XFxuICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1jMFxcXCIgZGF0YS1lZGl0PVxcXCJpdGFsaWNcXFwiIHRpdGxlPVxcXCJJdGFsaWNcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1pdGFsaWNcXFwiIGFsdD1cXFwiSXRhbGljXFxcIj48L2k+PC9idXR0b24+XFxuICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1jMFxcXCIgZGF0YS1lZGl0PVxcXCJzdHJpa2V0aHJvdWdoXFxcIiB0aXRsZT1cXFwiU3RyaWtldGhyb3VnaFxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXN0cmlrZXRocm91Z2hcXFwiIGFsdD1cXFwiU3RyaWtldGhyb3VnaFxcXCI+PC9pPjwvYnV0dG9uPlxcbiAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tYzBcXFwiIGRhdGEtZWRpdD1cXFwiY29kZVxcXCIgdGl0bGU9XFxcIkNvZGVcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1jb2RlXFxcIiBhbHQ9XFxcIkNvZGVcXFwiPjwvaT48L2J1dHRvbj5cXG4gIDwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwiYnRuLWdyb3VwIGJ0bi1ncm91cC1zbVxcXCI+XFxuICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1jMFxcXCIgZGF0YS1lZGl0PVxcXCJsaW5rXFxcIiB0aXRsZT1cXFwiTGlua1xcXCI+PGkgY2xhc3M9XFxcImZhIGZhLWxpbmtcXFwiIGFsdD1cXFwiTGlua1xcXCI+PC9pPjwvYnV0dG9uPlxcbiAgPC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJidG4tZ3JvdXAgYnRuLWdyb3VwLXNtXFxcIj5cXG4gICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWMwXFxcIiBkYXRhLWVkaXQ9XFxcImhlbHBcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1xdWVzdGlvbi1jaXJjbGVcXFwiIGFsdD1cXFwiSGVscFxcXCI+PC9pPiBIZWxwPC9idXR0b24+XFxuICA8L2Rpdj5cXG5cXG4gIDxkaXYgY2xhc3M9XFxcImJ0bi1ncm91cCBidG4tZ3JvdXAtc21cXFwiPlxcbiAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tYzEgYnRuLXByZXZpZXdcXFwiIGRhdGEtZWRpdD1cXFwicHJldmlld1xcXCI+PGkgY2xhc3M9XFxcImZhIGZhLWV5ZVxcXCIgYWx0PVxcXCJPcGVuXFxcIj48L2k+IFByZXZpZXc8L2J1dHRvbj5cXG4gIDwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwiYnRuLWdyb3VwIGJ0bi1ncm91cC1zbVxcXCI+XFxuICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1jMSBidG4tZWRpdFxcXCIgZGF0YS1lZGl0PVxcXCJlZGl0XFxcIiBzdHlsZT1cXFwiZGlzcGxheTogbm9uZTtcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1wZW5jaWxcXFwiIGFsdD1cXFwiRWRpdFxcXCI+PC9pPiBFZGl0PC9idXR0b24+XFxuICA8L2Rpdj5cXG48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJoZWxwXFxcIj5cXG4gIFlvdSBjYW4gdXNlIGFueSA8YSBocmVmPVxcXCJodHRwOi8vZGFyaW5nZmlyZWJhbGwubmV0L3Byb2plY3RzL21hcmtkb3duL3N5bnRheFxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPk1hcmtkb3duPC9hPiBvciA8YSBocmVmPVxcXCJodHRwczovL2hlbHAuZ2l0aHViLmNvbS9hcnRpY2xlcy9naXRodWItZmxhdm9yZWQtbWFya2Rvd25cXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIj5HaXRIdWIgRmxhdm9yZWQgTWFya2Rvd248L2E+IHN5bnRheCBpbiB0aGlzIHRleHQgYm94LlxcbjwvZGl2Plxcbjx0ZXh0YXJlYVxcbiAgPCVpZiAoIV8uaXNVbmRlZmluZWQobWF4bGVuZ3RoKSkgeyAlPm1heGxlbmd0aD1cXFwiPCU9IG1heGxlbmd0aCAlPlxcXCI8JSB9ICU+XFxuICA8JSBpZiAoIV8uaXNVbmRlZmluZWQocm93cykpIHsgJT5yb3dzPVxcXCI8JT0gcm93cyAlPlxcXCI8JSB9ICU+XFxuICBjbGFzcz1cXFwiZm9ybS1jb250cm9sIHZhbGlkYXRlXFxcIlxcbiAgaWQ9XFxcIjwlPSBpZCAlPlxcXCJcXG4gIGRhdGEtdmFsaWRhdGU9XFxcIjwlIGlmICghXy5pc1VuZGVmaW5lZCh2YWxpZGF0ZSkpIHsgJT48JT0gdmFsaWRhdGUuam9pbignLCcpICU+PCUgfSAlPlxcXCJcXG4gIDwlIGlmICghXy5pc1VuZGVmaW5lZChwbGFjZWhvbGRlcikpIHsgJT5wbGFjZWhvbGRlcj1cXFwiPCU9IHBsYWNlaG9sZGVyICU+XFxcIjwlIH0gJT5cXG4gIDwlIGlmICghXy5pc1VuZGVmaW5lZCh0aXRsZSkpIHsgJT50aXRsZT1cXFwiPCU9IHRpdGxlICU+XFxcIjwlIH0gJT5cXG4gID48JT0gZGF0YSAlPjwvdGV4dGFyZWE+XFxuPGRpdiBjbGFzcz1cXFwicHJldmlld1xcXCIgc3R5bGU9XFxcImRpc3BsYXk6IG5vbmU7XFxcIj48L2Rpdj5cXG5cIjtcbiIsIi8qKlxuICogVGhlIE1vZGFsIGNvbXBvbmVudCBuZWVkcyB0byBiZSBzZXQgdG8gdGhlIGVsOiBvZiB0aGUgcGFyZW50IHZpZXdcbiAqIHlvdSBhcmUgdHJ5aW5nIHRvIGluaXQgaXQgd2l0aGluLCB0aGVuIHlvdSB3aWxsIGJlIGFwcGVuZGluZyB0aGUgbW9kYWwtdGVtcGxhdGUgdG8gdGhhdFxuICogdmlldyAodGhpcykuICBUaGVuIHRoZSBmb3JtIHZpZXcgaGFzIGFuIGVsIG9mICQoXCIubW9kYWwtYm9keVwiKSBzbyB0aGF0IHRoZSBmb3JtIHdpbGwgcmVuZGVyXG4gKiB3aXRoaW4gdGhhdCBib2R5IGFyZWEuXG4gKiBUaGVuIGFsbCB5b3UgaGF2ZSB0byBkbyBpcyBzZXQgdGhlIElEIG9mIHRoZSBtb2RhbCB0byB0aGUgSUQgb2YgdGhlIGxpbmsgeW91IGFyZSB0cnlpbmdcbiAqIHRvIHRyaWdnZXIgZnJvbSBhcyBwZXIgYm9vdHN0cmFwIEJQLlxuICovXG5cbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL21peGlucy91dGlsaXRpZXMnKTtcbnZhciBCYXNlQ29tcG9uZW50ID0gcmVxdWlyZSgnLi4vYmFzZS9iYXNlX2NvbXBvbmVudCcpO1xudmFyIE1vZGFsVGVtcGxhdGUgPSByZXF1aXJlKCcuL21vZGFsX3RlbXBsYXRlLmh0bWwnKTtcblxuXG5Nb2RhbCA9IEJhc2VDb21wb25lbnQuZXh0ZW5kKHtcblxuICBldmVudHM6IHtcbiAgICBcImNsaWNrIC5saW5rLWJhY2tib25lXCIgIDogXCJsaW5rXCJcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBpZDogdGhpcy5vcHRpb25zLmlkLFxuICAgICAgbW9kYWxUaXRsZTogdGhpcy5vcHRpb25zLm1vZGFsVGl0bGUsXG4gICAgICBkaXNhYmxlQ2xvc2U6IHRoaXMub3B0aW9ucy5kaXNhYmxlQ2xvc2VcbiAgICB9O1xuXG4gICAgdmFyIGNvbXBpbGVkVGVtcGxhdGUgPSBfLnRlbXBsYXRlKE1vZGFsVGVtcGxhdGUpKGRhdGEpO1xuICAgIHRoaXMuJGVsLmFwcGVuZChjb21waWxlZFRlbXBsYXRlKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGxpbms6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAvLyBoaWRlIHRoZSBtb2RhbCwgd2FpdCBmb3IgaXQgdG8gY2xvc2UsIHRoZW4gbmF2aWdhdGVcbiAgICAkKCcjJyArIHRoaXMub3B0aW9ucy5pZCkuYmluZCgnaGlkZGVuLmJzLm1vZGFsJywgZnVuY3Rpb24oKSB7XG4gICAgICBsaW5rQmFja2JvbmUoZSk7XG4gICAgfSkubW9kYWwoJ2hpZGUnKTtcbiAgfSxcblxuICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBNb2RhbDtcbiIsInZhciBCb290c3RyYXAgPSByZXF1aXJlKCdib290c3RyYXAnKTtcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL21peGlucy91dGlsaXRpZXMnKTtcbnZhciBNb2RhbFRlbXBsYXRlID0gcmVxdWlyZSgnLi9tb2RhbF9hbGVydF90ZW1wbGF0ZS5odG1sJyk7XG5cblxudmFyIE1vZGFsQWxlcnQgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG5cbiAgZXZlbnRzOiB7XG4gICAgXCJzdWJtaXQgI21vZGFsLWZvcm1cIiAgICA6IFwicG9zdFwiXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciB0ZW1wbGF0ZSA9IF8udGVtcGxhdGUoTW9kYWxUZW1wbGF0ZSkodGhpcy5vcHRpb25zKTtcbiAgICB0aGlzLiRlbC5odG1sKHRlbXBsYXRlKTtcbiAgICB0aGlzLiRlbC5pMThuKCk7XG4gICAgJCh0aGlzLm9wdGlvbnMubW9kYWxEaXYpLm1vZGFsKCdzaG93Jyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcG9zdDogZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGhhc0Vycm9yID0gZmFsc2U7XG5cbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgLy9jaGVjayBhbnkgLnZhbGlkYXRlIGVsZW1lbnRzIGFuZCBkb24ndCBzdWJtaXQgaWYgdGhleSBmYWlsXG4gICAgaWYgKCBzZWxmLm9wdGlvbnMudmFsaWRhdGVCZWZvcmVTdWJtaXQgKXtcbiAgICAgICQoXCIudmFsaWRhdGVcIikuZWFjaChmdW5jdGlvbihpbmRleCl7XG4gICAgICAgIGhhc0Vycm9yID0gdmFsaWRhdGUoe2N1cnJlbnRUYXJnZXQ6IHRoaXN9KTtcbiAgICAgICAgaWYgKCBoYXNFcnJvciApeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICggIWhhc0Vycm9yICkge1xuICAgICAgJCh0aGlzLm9wdGlvbnMubW9kYWxEaXYpLmJpbmQoJ2hpZGRlbi5icy5tb2RhbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLm9wdGlvbnMuY2FsbGJhY2soZSk7XG4gICAgICB9KS5tb2RhbCgnaGlkZScpO1xuICAgIH1cbiAgfSxcblxuICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBNb2RhbEFsZXJ0O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxmb3JtIHJvbGU9XFxcImZvcm1cXFwiIGFjdGlvbj1cXFwiXFxcIiBpZD1cXFwibW9kYWwtZm9ybVxcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1ib2R5XFxcIj5cXG4gICAgPCU9IGNvbnRlbnQgJT5cXG4gIDwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwibW9kYWwtZm9vdGVyXFxcIj5cXG4gICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWMwXFxcIiBkYXRhLWRpc21pc3M9XFxcIm1vZGFsXFxcIj48JT0gY2FuY2VsICU+PC9idXR0b24+XFxuICAgIDxpbnB1dCB0eXBlPVxcXCJzdWJtaXRcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWMyXFxcIiBpZD1cXFwic3VibWl0XFxcIiB2YWx1ZT1cXFwiPCU9IHN1Ym1pdCAlPlxcXCIvPlxcbiAgPC9kaXY+XFxuPC9mb3JtPlxcblwiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcIm1vZGFsIGZhZGVcXFwiXFxuICBpZD1cXFwiPCUtIGlkICU+XFxcIlxcbiAgcm9sZT1cXFwiZGlhbG9nXFxcIlxcbiAgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiXFxuICB0YWJpbmRleD1cXFwiLTFcXFwiXFxuICA8JSBpZiAoZGlzYWJsZUNsb3NlID09PSB0cnVlKSB7ICU+XFxuICBkYXRhLWJhY2tkcm9wPVxcXCJzdGF0aWNcXFwiXFxuICBkYXRhLWtleWJvYXJkPVxcXCJmYWxzZVxcXCJcXG4gIDwlIH0gJT5cXG4gID5cXG4gIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWRpYWxvZ1xcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWNvbnRlbnRcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWhlYWRlclxcXCI+XFxuICAgICAgICA8JSBpZiAoZGlzYWJsZUNsb3NlICE9PSB0cnVlKSB7ICU+XFxuICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImNsb3NlXFxcIiBkYXRhLWRpc21pc3M9XFxcIm1vZGFsXFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+JnRpbWVzOzwvYnV0dG9uPlxcbiAgICAgICAgPCUgfSAlPlxcbiAgICAgICAgPGg0IGNsYXNzPVxcXCJtb2RhbC10aXRsZVxcXCI+PCUtIG1vZGFsVGl0bGUgJT48L2g0PlxcbiAgICAgIDwvZGl2PlxcblxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIm1vZGFsLXRlbXBsYXRlXFxcIj5cXG5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+PCEtLSAvLm1vZGFsLWNvbnRlbnQgLS0+XFxuICA8L2Rpdj48IS0tIC8ubW9kYWwtZGlhbG9nIC0tPlxcbjwvZGl2PjwhLS0gLy5tb2RhbCAtLT5cXG5cIjtcbiIsIi8vIFNpbWlsYXIgdG8gTW9kYWwgY29tcG9uZW50IGluIGV2ZXJ5IHdheSBpbiBhbGwgd2F5cyBidXQgdHdvOlxuLy8gMSkgVGhpcyBtb2RhbCBoYXMgYSBuZXh0IGJ1dHRvbiBpbnN0ZWFkIG9mIHNhdmUgYnV0dG9uLlxuLy8gMikgVGhpcyBtb2RhbCBoYXMgc29tZSBleHBlY3RhdGlvbnMgaW5zaWRlIHRoZSBtb2RhbC1ib2R5IGZvcm0uXG4vLyAgICBeIE1vcmUgb24gdGhpcyBiZWxvd1xuLy9cbi8vIFRoaXMgaXMgYWxsIHRoZSBjb21wb25lbnQgZXhwZWN0cyBmb3IgaXQgdG8gd29yazpcbi8vIDxkaXYgY2xhc3M9J21vZGFsLWJvZHknPlxuLy8gIDxzZWN0aW9uIGNsYXNzPVwiY3VycmVudFwiPkZpcnN0IGNvbnRlbnQgc2VjdGlvbjwvc2VjdGlvbj5cbi8vICA8c2VjdGlvbj5TZWNvbmQgY29udGVudCBzZWN0aW9uPC9zZWN0aW9uPlxuLy8gIDxzZWN0aW9uPlRoaXJkIGNvbnRlbnQgc2VjdGlvbjwvc2VjdGlvbj5cbi8vICA8IS0tIGFuZCBzbyBvbiAtLT5cbi8vIDwvZGl2PlxuLy9cbi8vIFJFTUVNQkVSOiBUaGlzIGdvZXMgaW5zaWRlIHlvdXIgZm9ybVRlbXBsYXRlLiAgVGhpc1xuLy8gaXMgdGhlIE1vZGFsV2l6YXJkQ29tcG9uZW50LCB3aGljaCBpcyBzY29wZWQgdG8gbGlzdCBjb250cm9sbGVyLFxuLy8gdGhlbiB0aGUgRm9ybSBpdHNlbGYgZm9yIHRoZSBhZGRpdGlvbiB0byB0aGUgbGlzdCBpcyBzY29wZWQgdG8gdGhlXG4vLyBtb2RhbC1ib2R5IHdpdGhpbiB0aGlzIG1vZGFsLWNvbXBvbmVudCB0ZW1wbGF0ZS5cblxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIHV0aWxpdGllcyA9IHJlcXVpcmUoJy4uL21peGlucy91dGlsaXRpZXMnKTtcbnZhciBCYXNlVmlldyA9IHJlcXVpcmUoJy4uL2Jhc2UvYmFzZV92aWV3Jyk7XG52YXIgTW9kYWxXaXphcmRUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vbW9kYWxfd2l6YXJkX3RlbXBsYXRlLmh0bWwnKTtcblxuXG5Nb2RhbFdpemFyZCA9IEJhc2VWaWV3LmV4dGVuZCh7XG5cbiAgZXZlbnRzOiB7XG4gICAgXCJjbGljayAud2l6YXJkLWZvcndhcmRcIiA6IFwibW92ZVdpemFyZEZvcndhcmRcIixcbiAgICBcImNsaWNrIC53aXphcmQtYmFja3dhcmRcIjogXCJtb3ZlV2l6YXJkQmFja3dhcmRcIixcbiAgICBcImNsaWNrIC53aXphcmQtc3VibWl0XCIgIDogXCJzdWJtaXRcIixcbiAgICBcImNsaWNrIC53aXphcmQtY2FuY2VsXCIgIDogXCJjYW5jZWxcIlxuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmluaXRpYWxpemVMaXN0ZW5lcnMoKTtcbiAgfSxcblxuICBpbml0aWFsaXplTGlzdGVuZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICh0aGlzLm1vZGVsKSB7XG4gICAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsIHRoaXMub3B0aW9ucy5tb2RlbE5hbWUgKyAnOm1vZGFsOmhpZGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICQoJy5tb2RhbC5pbicpLm1vZGFsKCdoaWRlJyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBpZDogdGhpcy5vcHRpb25zLmlkLFxuICAgICAgbW9kYWxUaXRsZTogdGhpcy5vcHRpb25zLm1vZGFsVGl0bGUsXG4gICAgICBkcmFmdDogdGhpcy5vcHRpb25zLmRyYWZ0XG4gICAgfTtcbiAgICB2YXIgY29tcGlsZWRUZW1wbGF0ZSA9IF8udGVtcGxhdGUoTW9kYWxXaXphcmRUZW1wbGF0ZSkoZGF0YSk7XG4gICAgdGhpcy4kZWwuaHRtbChjb21waWxlZFRlbXBsYXRlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogU2V0IHRoZSBjaGlsZCBvZiB0aGlzIHZpZXcsIHNvIHdlIGNhbiByZW1vdmUgaXRcbiAgICogd2hlbiB0aGUgdmlldyBpcyBkZXN0cm95ZWRcbiAgICogQHJldHVybiB0aGlzIGZvciBjaGFpbmluZ1xuICAgKi9cbiAgc2V0Q2hpbGRWaWV3OiBmdW5jdGlvbiAodmlldykge1xuICAgIHRoaXMuY2hpbGRWaWV3ID0gdmlldztcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogU2V0IHRoZSBjYWxsYmFjayBvbiB0aGUgbmV4dCBidXR0b24gb2YgdGhlIG1vZGFsLlxuICAgKiBVc2VmdWwgZm9yIGNhbGxiYWNrc1xuICAgKiBAcmV0dXJuIHRoaXMgZm9yIGNoYWluaW5nXG4gICAqL1xuICBzZXROZXh0OiBmdW5jdGlvbiAoZm4pIHtcbiAgICB0aGlzLmNoaWxkTmV4dCA9IGZuO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNhbGxiYWNrIG9uIHRoZSBzdWJtaXQgYnV0dG9uIG9mIHRoZSBtb2RhbC5cbiAgICogVXNlZnVsIGZvciBjYWxsYmFja3NcbiAgICogQHJldHVybiB0aGlzIGZvciBjaGFpbmluZ1xuICAgKi9cbiAgc2V0U3VibWl0OiBmdW5jdGlvbiAoZm4pIHtcbiAgICB0aGlzLmNoaWxkU3VibWl0ID0gZm47XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLy8gSW4gb3JkZXIgZm9yIHRoZSBNb2RhbFdpemFyZCB0byB3b3JrIGl0IGV4cGVjdHMgYSBzZWN0aW9uXG4gIC8vIGJ5IHNlY3Rpb24gbGF5b3V0IGluc2lkZSB0aGUgbW9kYWwsIHdpdGggYSAnY3VycmVudCcgY2xhc3Mgb25cbiAgLy8gdGhlIGZpcnN0IHlvdSB3YW50IHRvIGFsd2F5cyBzdGFydCBvbiAocmUpcmVuZGVyLlxuICBtb3ZlV2l6YXJkRm9yd2FyZDogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIFN0b3JlICQoXCIuY3VycmVudFwiKSBpbiBjYWNoZSB0byByZWR1Y2UgcXVlcnkgdGltZXMgZm9yIERPTSBsb29rdXBcbiAgICAvLyBvbiBmdXR1cmUgY2hpbGRyZW4gYW5kIGFkamFjZW50IGVsZW1lbnQgdG8gdGhlIGN1cnJlbnQgZWwuXG4gICAgdmFyIGN1cnJlbnQgICA9ICQoXCIuY3VycmVudFwiKSxcbiAgICAgICAgbmV4dCAgICAgID0gY3VycmVudC5uZXh0KCksXG4gICAgICAgIG5leHRIdG1sICA9IG5leHQuaHRtbCgpO1xuXG4gICAgLy8gTm90aWZ5IHRoZSBzdWItdmlldyB0byBzZWUgaWYgaXQgaXMgc2FmZSB0byBwcm9jZWVkXG4gICAgLy8gaWYgbm90LCByZXR1cm4gYW5kIHN0b3AgcHJvY2Vzc2luZy5cbiAgICB2YXIgYWJvcnQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5jaGlsZE5leHQpIHtcbiAgICAgIGFib3J0ID0gdGhpcy5jaGlsZE5leHQoZSwgY3VycmVudCk7XG4gICAgfVxuICAgIGlmIChhYm9ydCA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0V2l6YXJkU3RlcCA9IHtcbiAgICAgIGV4aXN0czogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gIV8uaXNVbmRlZmluZWQobmV4dC5uZXh0KCkuaHRtbCgpKTtcbiAgICAgIH0sXG4gICAgICBkb2VzTm90RXhpc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF8uaXNVbmRlZmluZWQobmV4dC5uZXh0KCkuaHRtbCgpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaGlkZUN1cnJlbnRBbmRJbml0aWFsaXplTmV4dFdpemFyZFN0ZXAoKTtcbiAgICBpZiAobmV4dFdpemFyZFN0ZXAuZG9lc05vdEV4aXN0KCkpIHtcbiAgICAgICQoXCJidXR0b24ud2l6YXJkLWZvcndhcmRcIikuaGlkZSgpO1xuICAgICAgJChcImJ1dHRvbi53aXphcmQtc3VibWl0XCIpLnNob3coKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoaWRlQ3VycmVudEFuZEluaXRpYWxpemVOZXh0V2l6YXJkU3RlcCAoKSB7XG4gICAgICBjdXJyZW50LmhpZGUoKTtcbiAgICAgIGN1cnJlbnQucmVtb3ZlQ2xhc3MoXCJjdXJyZW50XCIpO1xuICAgICAgbmV4dC5hZGRDbGFzcyhcImN1cnJlbnRcIik7XG4gICAgICBuZXh0LnNob3coKTtcbiAgICB9O1xuICB9LFxuXG4gIG1vdmVXaXphcmRCYWNrd2FyZDogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgdmFyIGN1cnJlbnQgICA9ICQoXCIuY3VycmVudFwiKSxcbiAgICAgICAgcHJldiAgICAgID0gY3VycmVudC5wcmV2KCksXG4gICAgICAgIHByZXZIdG1sICA9IHByZXYuaHRtbCgpO1xuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHByZXZIdG1sKSkge1xuICAgICAgY3VycmVudC5oaWRlKCk7XG4gICAgICBjdXJyZW50LnJlbW92ZUNsYXNzKFwiY3VycmVudFwiKTtcbiAgICAgIHByZXYuYWRkQ2xhc3MoXCJjdXJyZW50XCIpO1xuICAgICAgcHJldi5zaG93KCk7XG4gICAgICAkKFwiYnV0dG9uLndpemFyZC1mb3J3YXJkXCIpLnNob3coKTtcbiAgICAgICQoXCJidXR0b24ud2l6YXJkLXN1Ym1pdFwiKS5oaWRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0sXG5cbiAgLy8gRHVtYiBzdWJtaXQuICBFdmVyeXRoaW5nIGlzIGV4cGVjdGVkIHZpYSBhIHByb21pc2UgZnJvbVxuICAvLyBmcm9tIHRoZSBpbnN0YW50aWF0aW9uIG9mIHRoaXMgbW9kYWwgd2l6YXJkLlxuICBzdWJtaXQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIHZhciBkID0gdGhpcy5vcHRpb25zLmRhdGEodGhpcyk7XG4gICAgdmFyIGFib3J0ID0gZmFsc2U7XG4gICAgdmFyIHN0YXRlID0gJChlLmN1cnJlbnRUYXJnZXQpLmRhdGEoJ3N0YXRlJyk7XG5cbiAgICAvLyBwYXNzIHRoZSBkYXRhIHRvIHRoZSB2aWV3XG4gICAgaWYgKHRoaXMuY2hpbGRTdWJtaXQpIHtcbiAgICAgIC8vIGlmIHN1Ym1pdCByZXR1cm5zIHRydWUsIGFib3J0IG1vZGFsIHByb2Nlc3NpbmdcbiAgICAgIGFib3J0ID0gdGhpcy5jaGlsZFN1Ym1pdChlLCB0aGlzLiQoXCIuY3VycmVudFwiKSk7XG4gICAgfVxuXG4gICAgaWYgKGFib3J0ID09PSB0cnVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgJCgnLm1vZGFsLmluJykubW9kYWwoJ2hpZGUnKTtcbiAgICBpZiAoc3RhdGUpIGQuc3RhdGUgPSBzdGF0ZTtcbiAgICB0aGlzLmNvbGxlY3Rpb24udHJpZ2dlcih0aGlzLm9wdGlvbnMubW9kZWxOYW1lICsgXCI6c2F2ZVwiLCBkKTtcbiAgfSxcblxuICBjYW5jZWw6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAkKCcubW9kYWwuaW4nKS5tb2RhbCgnaGlkZScpO1xuICB9LFxuXG4gIGNsZWFudXA6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5jaGlsZFZpZXcpIHsgdGhpcy5jaGlsZFZpZXcuY2xlYW51cCgpOyB9XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTW9kYWxXaXphcmQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwibW9kYWwgZmFkZVxcXCIgaWQ9XFxcIjwlLSBpZCAlPlxcXCIgcm9sZT1cXFwiZGlhbG9nXFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWRpYWxvZ1xcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWNvbnRlbnRcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWhlYWRlclxcXCI+XFxuICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImNsb3NlXFxcIiBkYXRhLWRpc21pc3M9XFxcIm1vZGFsXFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+JnRpbWVzOzwvYnV0dG9uPlxcbiAgICAgICAgPGg0IGNsYXNzPVxcXCJtb2RhbC10aXRsZVxcXCI+PCUtIG1vZGFsVGl0bGUgJT48L2g0PlxcbiAgICAgIDwvZGl2PlxcblxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWJvZHlcXFwiPlxcblxcbiAgICAgIDwvZGl2PlxcblxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWZvb3RlclxcXCI+XFxuICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tYzAgd2l6YXJkLWNhbmNlbFxcXCIgZGF0YS1kaXNtaXNzPVxcXCJtb2RhbFxcXCI+Q2FuY2VsPC9idXR0b24+XFxuICAgICAgICA8JSBpZiAoZHJhZnQpIHsgJT48YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tYzAgd2l6YXJkLXN1Ym1pdFxcXCIgZGF0YS1zdGF0ZT1cXFwiZHJhZnRcXFwiPlNhdmUgRHJhZnQ8L2J1dHRvbj48JSB9ICU+XFxuICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tYzIgd2l6YXJkLWJhY2t3YXJkXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtY2hldnJvbi1sZWZ0XFxcIj48L2k+IEJhY2s8L2J1dHRvbj5cXG4gICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1jMiB3aXphcmQtZm9yd2FyZFxcXCI+TmV4dCA8aSBjbGFzcz1cXFwiZmEgZmEtY2hldnJvbi1yaWdodFxcXCI+PC9pPjwvYnV0dG9uPlxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWMyIHdpemFyZC1zdWJtaXRcXFwiIHN0eWxlPVxcXCJkaXNwbGF5OiBub25lO1xcXCI+Q3JlYXRlPC9idXR0b24+XFxuICAgICAgPC9kaXY+XFxuXFxuICAgIDwvZGl2PjwhLS0gLy5tb2RhbC1jb250ZW50IC0tPlxcbiAgPC9kaXY+PCEtLSAvLm1vZGFsLWRpYWxvZyAtLT5cXG48L2Rpdj5cXG5cIjtcbiIsIi8qKlxuICogVGhpcyBjb21wb25lbnQgaW1wbGVtZW50cyBhIHRhZyB3aWRnZXQsIGFsbG93aW5nIGNyZWF0aW9uIGxvb2t1cCBhbmQgZGVsZXRpb24gb2YgdGFncyBmcm9tIGEgY29tbW9uIHVpIGVsZW1lbnRcbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqL1xuXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgYXN5bmMgPSByZXF1aXJlKCdhc3luYycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vbWl4aW5zL3V0aWxpdGllcycpO1xudmFyIG1hcmtlZCA9IHJlcXVpcmUoJ21hcmtlZCcpO1xudmFyIEJhc2VDb21wb25lbnQgPSByZXF1aXJlKCcuLi9iYXNlL2Jhc2VfY29tcG9uZW50Jyk7XG52YXIganFTZWxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi92ZW5kb3IvanF1ZXJ5LnNlbGVjdGlvbicpO1xuXG5cblRhZ0ZhY3RvcnkgPSBCYXNlQ29tcG9uZW50LmV4dGVuZCh7XG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgYWRkVGFnRW50aXRpZXM6IGZ1bmN0aW9uICh0YWcsIGNvbnRleHQsIGRvbmUpIHtcbiAgXHQvL2Fzc3VtZXNcbiAgXHQvLyAgdGFnIC0tIGFycmF5IG9mIHRhZyBvYmplY3RzIHRvIGFkZFxuICBcdC8vICB0YWdUeXBlIC0tIHN0cmluZyBzcGVjaWZ5aW5nIHR5cGUgZm9yIHRhZ0VudGl0eSB0YWJsZVxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICBcdC8vdGhpcyBpcyBjdXJyZW50IHNvbHV0aW9uIHRvIG1hcmsgYSB0YWcgb2JqZWN0IGFzIG9uIHRoZSBmbHkgYWRkZWRcbiAgICAgIGlmICggIXRhZyB8fCB0eXBlb2YgdGFnLnVubWF0Y2hlZCA9PSAndW5kZWZpbmVkJyB8fCAhdGFnLnVubWF0Y2hlZCApe1xuICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgfVxuICAgIC8vcmVtb3ZlIHRoZSBmbGFnIHRoYXQgbWFya3MgdGhlbSBhcyBuZXdcbiAgICBkZWxldGUgdGFnLnVubWF0Y2hlZDtcblxuICAgICQuYWpheCh7XG4gICAgICB1cmw6ICcvYXBpL3RhZ0VudGl0eScsXG4gICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHR5cGU6IHRhZy50YWdUeXBlLFxuICAgICAgICBuYW1lOiB0YWcuaWQsXG4gICAgICAgIGRhdGE6IHRhZy5kYXRhXG4gICAgICB9LFxuICAgICAgc3VjY2VzczogZnVuY3Rpb24gKGRhdGEpe1xuICAgICAgICBpZiAoY29udGV4dC5kYXRhKSB7XG4gICAgICAgICAgY29udGV4dC5kYXRhLm5ld1RhZyA9IGRhdGE7XG4gICAgICAgICAgY29udGV4dC5kYXRhLm5ld0l0ZW1UYWdzLnB1c2goZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvbmUobnVsbCwgZGF0YSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgcmVtb3ZlVGFnOiBmdW5jdGlvbiAoaWQsIGRvbmUpIHtcbiAgICAkLmFqYXgoe1xuICAgICAgdXJsOiAnL2FwaS90YWcvJyArIGlkLFxuICAgICAgdHlwZTogJ0RFTEVURScsXG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIGFkZFRhZzogZnVuY3Rpb24gKHRhZywgbW9kZWxJZCwgbW9kZWxUeXBlLCBkb25lKSB7XG4gIFx0Ly9hc3N1bWVzXG4gIFx0Ly8gIHRhZyAtLSBhcnJheSBvZiB0YWcgb2JqZWN0cyB0byBhZGRcbiAgXHQvLyAgLS0tIE5ZSSAtLS1cbiAgXHQvLyAgcHJvamVjdCBvciB0YXNrIGlkIC0gc3RyaW5nXG4gICAgLy8gVE9ETzogYWJzdHJhY3QgdGhlIGJlbG93IGlmLWVsc2UgdG8gYSBkaWZmZXJlbnQgZnVuY3Rpb24gc28gdGhpcyBmdW5jaXRvbiBqdXN0IHRha2VzIGFuIGFycmF5IHRhZyBpZHNcblxuICAgIHZhciB0YWdNYXAgPSB7fTtcbiAgICB0YWdNYXBbbW9kZWxUeXBlXSA9IG1vZGVsSWQ7XG5cbiAgICBpZiAoIF8uaXNGaW5pdGUodGFnKSApe1xuICAgICAgICAvLyAtLS0gTllJIC0tLVxuICAgICAgICAvLyBvciBwcm9qZWN0IGlkXG5cbiAgICAgICAgdGFnTWFwLnRhZ0lkID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIC0tLSBOWUkgLS0tXG4gICAgICAgIC8vIG9yIHByb2plY3QgaWRcblxuICAgICAgICB0YWdNYXAudGFnSWQgPSB0YWcuaWQ7XG4gICAgfVxuXG4gICAgJC5hamF4KHtcbiAgICAgIHVybDogJy9hcGkvdGFnJyxcbiAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgIGRhdGE6IHRhZ01hcCxcbiAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICB9LFxuICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUoZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICB9LFxuXG4gIGNyZWF0ZVRhZ0Ryb3BEb3duOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIHNldHRpbmdzID0ge1xuICAgICAgICAgIHBsYWNlaG9sZGVyOiBcIlN0YXJ0IHR5cGluZyB0byBzZWxlY3QgYSBcIitvcHRpb25zLnR5cGUsXG4gICAgICAgICAgbWluaW11bUlucHV0TGVuZ3RoOiAyLFxuICAgICAgICAgIG11bHRpcGxlOiB0cnVlLFxuICAgICAgICAgIHdpZHRoOiBvcHRpb25zLndpZHRoIHx8IFwiNTAwcHhcIixcbiAgICAgICAgICB0b2tlblNlcGFyYXRvcnM6IG9wdGlvbnMudG9rZW5TZXBhcmF0b3JzIHx8IFtdLFxuICAgICAgICAgIGZvcm1hdFJlc3VsdDogZnVuY3Rpb24gKG9iaiwgY29udGFpbmVyLCBxdWVyeSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iai5uYW1lO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZm9ybWF0U2VsZWN0aW9uOiBmdW5jdGlvbiAob2JqLCBjb250YWluZXIsIHF1ZXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLm5hbWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjcmVhdGVTZWFyY2hDaG9pY2U6IGZ1bmN0aW9uICh0ZXJtKSB7XG4gICAgICAgICAgICAvL3VubWF0Y2hlZCA9IHRydWUgaXMgdGhlIGZsYWcgZm9yIHNhdmluZyB0aGVzZSBcIm5ld1wiIHRhZ3MgdG8gdGFnRW50aXR5IHdoZW4gdGhlIG9wcCBpcyBzYXZlZFxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdW5tYXRjaGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0YWdUeXBlOiBvcHRpb25zLnR5cGUsXG4gICAgICAgICAgICAgIGlkOiB0ZXJtLFxuICAgICAgICAgICAgICB2YWx1ZTogdGVybSxcbiAgICAgICAgICAgICAgdGVtcDogdHJ1ZSxcbiAgICAgICAgICAgICAgbmFtZTogXCI8Yj5cIit0ZXJtK1wiPC9iPiA8aT5cIiArICgob3B0aW9ucy50eXBlICE9PSAnbG9jYXRpb24nKSA/XG4gICAgICAgICAgICAgICAgXCJjbGljayB0byBjcmVhdGUgYSBuZXcgdGFnIHdpdGggdGhpcyB2YWx1ZVwiIDpcbiAgICAgICAgICAgICAgICBcInNlYXJjaCBmb3IgdGhpcyBsb2NhdGlvblwiKSArIFwiPC9pPlwiXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYWpheDoge1xuICAgICAgICAgICAgdXJsOiAnL2FwaS9hYy90YWcnLFxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgICAgIGRhdGE6IGZ1bmN0aW9uICh0ZXJtKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogb3B0aW9ucy50eXBlLFxuICAgICAgICAgICAgICAgIHE6IHRlcm1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXN1bHRzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICByZXR1cm4geyByZXN1bHRzOiBkYXRhIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAkc2VsID0gc2VsZi4kKG9wdGlvbnMuc2VsZWN0b3IpO1xuICAgICRzZWwucmVtb3RlID0gdHJ1ZTtcbiAgICAkc2VsLnNlbGVjdDIoc2V0dGluZ3MpLm9uKFwic2VsZWN0Mi1zZWxlY3RpbmdcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChlLmNob2ljZS50YWdUeXBlID09PSAnbG9jYXRpb24nKSB7XG4gICAgICAgIHZhciAkZWwgPSBzZWxmLiQoZS5jdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgaWYgKGUuY2hvaWNlLnRlbXApIHtcbiAgICAgICAgICBlLmNob2ljZS5uYW1lID0gJzxlbT5TZWFyY2hpbmcgZm9yIDxzdHJvbmc+JyArXG4gICAgICAgICAgICBlLmNob2ljZS52YWx1ZSArICc8L3N0cm9uZz48L2VtPic7XG4gICAgICAgICAgdGhpcy50ZW1wID0gdHJ1ZTtcbiAgICAgICAgICAkLmdldCgnL2FwaS9sb2NhdGlvbi9zdWdnZXN0P3E9JyArIGUuY2hvaWNlLnZhbHVlLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBkID0gXyhkKS5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkOiBpdGVtLm5hbWUsXG4gICAgICAgICAgICAgICAgbmFtZTogaXRlbS5uYW1lLFxuICAgICAgICAgICAgICAgIHVubWF0Y2hlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0YWdUeXBlOiAnbG9jYXRpb24nLFxuICAgICAgICAgICAgICAgIGRhdGE6IF8oaXRlbSkub21pdCgnbmFtZScpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBpdGVtcyA9ICRzZWwuc2VsZWN0MignZGF0YScpO1xuICAgICAgICAgICAgdGhpcy5jYWNoZSA9IF8ucmVqZWN0KGl0ZW1zLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgIHJldHVybiAoaXRlbS5uYW1lLmluZGV4T2YoJzxlbT5TZWFyY2hpbmcgZm9yIDxzdHJvbmc+JykgPj0gMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICRzZWwuc2VsZWN0Mih7XG4gICAgICAgICAgICAgIG11bHRpcGxlOiB0cnVlLFxuICAgICAgICAgICAgICBkYXRhOiB7IHJlc3VsdHM6IGQsIHRleHQ6ICduYW1lJyB9XG4gICAgICAgICAgICB9KS5zZWxlY3QyKCdkYXRhJywgdGhpcy5jYWNoZSkuc2VsZWN0Mignb3BlbicpO1xuICAgICAgICAgICAgJHNlbC5yZW1vdGUgPSBmYWxzZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlbG9hZCA9IHRydWU7XG4gICAgICAgICAgZGVsZXRlIHRoaXMudGVtcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCBlLmNob2ljZS5oYXNPd25Qcm9wZXJ0eShcInVubWF0Y2hlZFwiKSAmJiBlLmNob2ljZS51bm1hdGNoZWQgKXtcbiAgICAgICAgICAvL3JlbW92ZSB0aGUgaGludCBiZWZvcmUgYWRkaW5nIGl0IHRvIHRoZSBsaXN0XG4gICAgICAgICAgZS5jaG9pY2UubmFtZSA9IGUudmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkub24oJ3NlbGVjdDItYmx1cicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICghdGhpcy5yZWxvYWQgJiYgdGhpcy50ZW1wKSB7XG4gICAgICAgIHRoaXMucmVsb2FkID0gdHJ1ZTtcbiAgICAgICAgZGVsZXRlIHRoaXMudGVtcDtcbiAgICAgIH1cbiAgICB9KS5vbignc2VsZWN0Mi1vcGVuJywgZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIGVsID0gdGhpcztcbiAgICAgIGlmICh0aGlzLnJlbG9hZCkge1xuICAgICAgICB0aGlzLmNhY2hlID0gJHNlbC5zZWxlY3QyKCdkYXRhJyk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAkc2VsLnNlbGVjdDIoc2V0dGluZ3MpLnNlbGVjdDIoJ2RhdGEnLCBlbC5jYWNoZSkuc2VsZWN0Mignb3BlbicpO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgZGVsZXRlIHRoaXMucmVsb2FkO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIGNyZWF0ZURpZmY6IGZ1bmN0aW9uICggb2xkVGFncywgY3VycmVudFRhZ3Mpe1xuICAgIC8vc29ydCB0YWdzIGludG8gdGhlaXIgbmVlZGVkIGFjdGlvbnNcbiAgICAvL1xuXG4gICAgdmFyIG91dCA9IHtcbiAgICAgIHJlbW92ZTogW10sXG4gICAgICBhZGQ6IFtdLFxuICAgICAgbm9uZTogW11cbiAgICB9O1xuXG4gICAgdmFyIG5vbmUgPSBudWxsO1xuXG4gICAgXy5lYWNoKG9sZFRhZ3MsIGZ1bmN0aW9uIChvVGFnLG9pKXtcblxuICAgICAgbm9uZSA9IG51bGw7XG5cbiAgICAgIF8uZWFjaChjdXJyZW50VGFncywgZnVuY3Rpb24gKGNUYWcsIGNpKXtcbiAgICAgICAgICBpZiAoY1RhZyAmJiBwYXJzZUludChjVGFnLmlkKSA9PSBvVGFnLnRhZ0lkICl7XG4gICAgICAgICAgICBjdXJyZW50VGFncy5zcGxpY2UoY2ksMSk7XG4gICAgICAgICAgICBub25lID0gb2k7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgaWYoIF8uaXNGaW5pdGUobm9uZSkgKXtcbiAgICAgICAgb3V0Lm5vbmUucHVzaChwYXJzZUludChvbGRUYWdzW25vbmVdLnRhZ0lkKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQucmVtb3ZlLnB1c2gocGFyc2VJbnQob1RhZy5pZCkpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgb3V0LmFkZCA9IGN1cnJlbnRUYWdzO1xuXG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUYWdGYWN0b3J5O1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcInJlc0dldFBhdGhcIiAgICAgIDogXCIvbG9jYWxlcy9fX2xuZ19fL19fbnNfXy5qc29uXCIsXG5cbiAgXCJsbmdcIiAgICAgICAgICAgICA6IFwiZW4tVVNcIixcblxuICBcImZhbGxiYWNrTG5nXCIgICAgIDogXCJlblwiLFxuXG4gIFwidXNlTG9jYWxTdG9yYWdlXCIgOiBmYWxzZSxcblxuICBcInNlbmRNaXNzaW5nXCIgICAgIDogZmFsc2UsXG4gIFwic2VuZE1pc3NpbmdUb1wiICAgOiBcImN1cnJlbnRcIlxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcInNpZ25pblwiOiB0cnVlLFxuICBcIm9hdXRoXCI6IFtcbiAgICBcImxpbmtlZGluXCIsXG4gICAgXCJteXVzYVwiXG4gIF0sXG4gIFwiY29uZmlnXCI6IHtcbiAgICBcImxpbmtlZGluXCI6IHtcbiAgICAgIFwibmFtZVwiOiBcIkxpbmtlZEluXCIsXG4gICAgICBcImltYWdlXCI6IFwiL2ltYWdlcy9sb2dpbi9saW5rZWRpbi5wbmdcIixcbiAgICAgIFwiZW5kcG9pbnRcIjogXCIvYXBpL2F1dGgvb2F1dGgvbGlua2VkaW5cIixcbiAgICAgIFwicGFyYW1zXCI6IHtcInNjb3BlXCI6IFtcInJfYmFzaWNwcm9maWxlXCIsIFwicl9mdWxscHJvZmlsZVwiLCBcInJfZW1haWxhZGRyZXNzXCIsIFwicl9uZXR3b3JrXCJdfVxuICAgIH0sXG4gICAgXCJteXVzYVwiOiB7XG4gICAgICBcIm5hbWVcIjogXCJNeVVTQVwiLFxuICAgICAgXCJpbWFnZVwiOiBcIi9pbWFnZXMvbG9naW4vbXl1c2EucG5nXCIsXG4gICAgICBcImVuZHBvaW50XCI6IFwiL2FwaS9hdXRoL29hdXRoL215dXNhXCIsXG4gICAgICBcInBhcmFtc1wiOiB7IFwic2NvcGVcIjogW1wicHJvZmlsZS5lbWFpbFwiLCBcInByb2ZpbGUuZmlyc3RfbmFtZVwiLCBcInByb2ZpbGUubGFzdF9uYW1lXCJdIH1cbiAgICB9XG4gIH0sXG4gIFwibG9jYWxcIjoge1xuICAgIFwiZW5hYmxlZFwiOiB0cnVlLFxuICAgIFwiZXhwYW5kXCI6IHRydWUsXG4gICAgXCJsb2dvdXRcIjogdHJ1ZVxuICB9LFxuICBcInRlcm1zXCI6IHtcbiAgICBcImVuYWJsZWRcIjogZmFsc2UsXG4gICAgXCJuYW1lXCI6IFwiVGVybXMgYW5kIENvbmRpdGlvbnNcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovLzE4Zi5nc2EuZ292L1wiXG4gIH0sXG4gIFwicHJvZmlsZVwiOiB7XG4gICAgXCJlZGl0XCI6IHRydWUsXG4gICAgXCJlZGl0VXJsXCI6IG51bGxcbiAgfVxufVxuIiwiLyoqXG4gKiBUaGlzIGlzIGEgY29uZmlndXJhdGlvbiBmaWxlIHRoYXQgZGVmaW5lcyB0aGUgc3RhbmRhcmRcbiAqIHRhZ3MgZm9yIHRoaXMgaW5zdGFsbGF0aW9uLiAgVGhlIHRhZ3Mgd2lsbCBiZSBkaXNwbGF5ZWRcbiAqIGluIHRoZSBvcmRlciBvZiB0aGUgYXJyYXkuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBUaGlzIGRlZmluZXMgYWxsIG9mIHRoZSB0YWcgZWxlbWVudHMgZm9yIHVzZSBpbiB0aGUgYXBwXG4gIHRhZ3M6IHtcbiAgICAnc2tpbGwnOiB7XG4gICAgICAnaWNvbic6ICdpY29uLWF0b20nLFxuICAgICAgJ2NsYXNzJzogJ3NraWxsJyxcbiAgICAgICdpZCc6ICdza2lsbCcsXG4gICAgICAndHlwZSc6ICdza2lsbCcsXG4gICAgICAnbmFtZSc6ICdTa2lsbCcsXG4gICAgICAncGx1cmFsJzogJ1NraWxscydcbiAgICB9LFxuXG4gICAgJ3RvcGljJzoge1xuICAgICAgJ2ljb24nOiAnZmEgZmEtYnJpZWZjYXNlJyxcbiAgICAgICdjbGFzcyc6ICd0b3BpYycsXG4gICAgICAnaWQnOiAndG9waWMnLFxuICAgICAgJ3R5cGUnOiAndG9waWMnLFxuICAgICAgJ25hbWUnOiAnVG9waWMnLFxuICAgICAgJ3BsdXJhbCc6ICdUb3BpY3MnXG4gICAgfSxcblxuICAgICdhZ2VuY3knOiB7XG4gICAgICAnaWNvbic6ICdpY29uLWxpYnJhcnknLFxuICAgICAgJ2NsYXNzJzogJ2FnZW5jeScsXG4gICAgICAnaWQnOiAnYWdlbmN5JyxcbiAgICAgICd0eXBlJzogJ2FnZW5jeScsXG4gICAgICAnbmFtZSc6ICdBZ2VuY3knLFxuICAgICAgJ3BsdXJhbCc6ICdBZ2VuY2llcydcbiAgICB9LFxuXG4gICAgJ2xvY2F0aW9uJzoge1xuICAgICAgJ2ljb24nOiAnZmEgZmEtbWFwLW1hcmtlcicsXG4gICAgICAnY2xhc3MnOiAnbG9jYXRpb24nLFxuICAgICAgJ2lkJzogJ2xvY2F0aW9uJyxcbiAgICAgICd0eXBlJzogJ2xvY2F0aW9uJyxcbiAgICAgICduYW1lJzogJ1dvcmsgTG9jYXRpb24nLFxuICAgICAgJ3BsdXJhbCc6ICdXb3JrIExvY2F0aW9ucydcbiAgICB9LFxuXG4gICAgLy8gLS0tXG4gICAgLy8gVGFzay1zcGVjaWZpYyB0YWdzXG4gICAgLy8gLS0tXG4gICAgJ3Rhc2stc2tpbGxzLXJlcXVpcmVkJzoge1xuICAgICAgJ2ljb24nOiAnZmEgZmEtbWFwLW1hcmtlcicsXG4gICAgICAnY2xhc3MnOiAndGFzay1za2lsbHMtcmVxdWlyZWQnLFxuICAgICAgJ2lkJzogJ3Rhc2stc2tpbGxzLXJlcXVpcmVkJyxcbiAgICAgICd0eXBlJzogJ3Rhc2stc2tpbGxzLXJlcXVpcmVkJyxcbiAgICAgICduYW1lJzogJ1NraWxsIFJlcXVpcmVkJyxcbiAgICAgICdwbHVyYWwnOiAnU2tpbGxzIFJlcXVpcmVkJ1xuICAgIH0sXG5cbiAgICAndGFzay10aW1lLXJlcXVpcmVkJzoge1xuICAgICAgJ2ljb24nOiAnZmEgZmEtY2FsZW5kYXItbycsXG4gICAgICAnY2xhc3MnOiAndGFzay10aW1lLXJlcXVpcmVkJyxcbiAgICAgICdpZCc6ICd0YXNrLXRpbWUtcmVxdWlyZWQnLFxuICAgICAgJ3R5cGUnOiAndGFzay10aW1lLXJlcXVpcmVkJyxcbiAgICAgICduYW1lJzogJ1RpbWUgQ29tbWl0bWVudCcsXG4gICAgICAncGx1cmFsJzogJ1RpbWUgQ29tbWl0bWVudCdcbiAgICB9LFxuXG4gICAgJ3Rhc2stcGVvcGxlJzoge1xuICAgICAgJ2ljb24nOiAnZmEgZmEtZ3JvdXAnLFxuICAgICAgJ2NsYXNzJzogJ3Rhc2stcGVvcGxlJyxcbiAgICAgICdpZCc6ICd0YXNrLXBlb3BsZScsXG4gICAgICAndHlwZSc6ICd0YXNrLXBlb3BsZScsXG4gICAgICAnbmFtZSc6ICdQZXJzb25uZWwgTmVlZGVkJyxcbiAgICAgICdwbHVyYWwnOiAnUGVyc29ubmVsIE5lZWRlZCdcbiAgICB9LFxuXG4gICAgJ3Rhc2stbGVuZ3RoJzoge1xuICAgICAgJ2ljb24nOiAnZmEgZmEtYnVsbHNleWUnLFxuICAgICAgJ2NsYXNzJzogJ3Rhc2stbGVuZ3RoJyxcbiAgICAgICdpZCc6ICd0YXNrLWxlbmd0aCcsXG4gICAgICAndHlwZSc6ICd0YXNrLWxlbmd0aCcsXG4gICAgICAnbmFtZSc6ICdEZWFkbGluZScsXG4gICAgICAncGx1cmFsJzogJ0RlYWRsaW5lJ1xuICAgIH0sXG5cbiAgICAndGFzay10aW1lLWVzdGltYXRlJzoge1xuICAgICAgJ2ljb24nOiAnZmEgZmEtY29ncycsXG4gICAgICAnY2xhc3MnOiAndGFzay10aW1lLWVzdGltYXRlJyxcbiAgICAgICdpZCc6ICd0YXNrLXRpbWUtZXN0aW1hdGUnLFxuICAgICAgJ3R5cGUnOiAndGFzay10aW1lLWVzdGltYXRlJyxcbiAgICAgICduYW1lJzogJ0VzdGltYXRlZCBUaW1lIFJlcXVpcmVkJyxcbiAgICAgICdwbHVyYWwnOiAnRXN0aW1hdGVkIFRpbWUgUmVxdWlyZWQnXG4gICAgfVxuXG4gIH0sXG5cbiAgLy8gVGhpcyBkZWZpbmVzIHRoZSBwYXJ0IG9mIHRoZSBhcHAgYW5kIHdoaWNoIHRhZ3MgYXBwbHlcbiAgLy8gcGx1cmFsIG5hbWVzIGFyZSBmb3Igc2VhcmNoaW5nIHRoZSBjb2xsZWN0aW9uXG4gIC8vIHNpbmd1bGFyIG5hbWVzIGFyZSBmb3IgdGhlIGluZGl2aWR1YWwgc2hvdyB2aWV3cy5cbiAgcHJvamVjdCAgIDogWydza2lsbCcsICd0b3BpYycsICdhZ2VuY3knLCAnbG9jYXRpb24nXSxcbiAgcHJvamVjdHMgIDogWydza2lsbCcsICd0b3BpYycsICdhZ2VuY3knLCAnbG9jYXRpb24nXSxcblxuICBwcm9maWxlICAgOiBbJ3NraWxsJywgJ3RvcGljJ10sXG4gIHByb2ZpbGVzICA6IFsnc2tpbGwnLCAndG9waWMnLCAnYWdlbmN5JywgJ2xvY2F0aW9uJ10sXG5cbiAgdGFzayAgICAgIDogWydza2lsbCcsICd0b3BpYycsICdsb2NhdGlvbicsICd0YXNrLXBlb3BsZScsICd0YXNrLXRpbWUtZXN0aW1hdGUnLCAndGFzay10aW1lLXJlcXVpcmVkJywgJ3Rhc2stbGVuZ3RoJ10sXG4gIHRhc2tzICAgICA6IFsnc2tpbGwnLCAndG9waWMnLCAnYWdlbmN5JywgJ2xvY2F0aW9uJywgJ3Rhc2stc2tpbGxzLXJlcXVpcmVkJywgJ3Rhc2stdGltZS1yZXF1aXJlZCcsICd0YXNrLXBlb3BsZScsICd0YXNrLWxlbmd0aCcsICd0YXNrLXRpbWUtZXN0aW1hdGUnXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJwcm9qZWN0XCI6IHtcbiAgICBcInNob3dcIjogdHJ1ZVxuICB9LFxuICBcInN1cGVydmlzb3JFbWFpbFwiOiB7XG5cdCAgXCJ1c2VTdXBlcnZpc29yRW1haWxcIjogZmFsc2VcbiAgfSxcbiAgXCJob21lXCI6IHtcbiAgICBcImxvZ2dlZF9pbl9wYXRoXCI6IFwiL3Byb2plY3RzXCJcbiAgfSxcbiAgXCJmYXFcIiA6IHtcbiAgICBcInNob3dcIiA6IGZhbHNlLFxuICAgIFwidXJsXCIgIDogXCIvZmFxXCJcbiAgfSxcbiAgXCJzeXN0ZW1FbWFpbFwiIDogXCJ0ZXN0QG1pZGFzLmNvbVwiLFxuICBcImJyb3dzZVwiOiB7XG4gICAgXCJwYWdlU2l6ZVwiIDogMjcsXG4gICAgXCJ1c2VJbmZpbml0ZVNjcm9sbFwiIDogZmFsc2VcbiAgfSxcbiAgXCJzdGF0ZXNcIiA6IFt7XCJ2YWx1ZVwiOiBcImRyYWZ0XCIsXCJsYWJlbFwiOlwiRHJhZnRcIn0se1widmFsdWVcIjogXCJvcGVuXCIsXCJsYWJlbFwiOlwiT3BlblwifSx7XCJ2YWx1ZVwiOlwiYXNzaWduZWRcIixcImxhYmVsXCI6XCJBc3NpZ25lZFwifSx7XCJ2YWx1ZVwiOiBcImNvbXBsZXRlZFwiLFwibGFiZWxcIjpcIkNvbXBsZXRlZFwifSx7XCJ2YWx1ZVwiOlwiYXJjaGl2ZWRcIixcImxhYmVsXCI6XCJBcmNoaXZlZFwifV1cbn1cbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciBDb21tZW50TW9kZWwgPSByZXF1aXJlKCcuL2NvbW1lbnRfbW9kZWwnKTtcbnZhciBDb21tZW50TGlzdENvbnRyb2xsZXIgPSByZXF1aXJlKCcuLi8uLi9hcHBzL2NvbW1lbnRzL2xpc3QvY29udHJvbGxlcnMvY29tbWVudF9saXN0X2NvbnRyb2xsZXInKTtcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ29tbWVudENvbGxlY3Rpb24gPSBCYWNrYm9uZS5Db2xsZWN0aW9uLmV4dGVuZCh7XG5cbiAgdXJsUm9vdDogJy9hcGkvY29tbWVudCcsXG5cbiAgbW9kZWw6IENvbW1lbnRNb2RlbCxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLCBcImNvbW1lbnQ6c2F2ZVwiLCBmdW5jdGlvbiAoZGF0YSwgY3VycmVudFRhcmdldCkge1xuICAgICAgc2VsZi5hZGRBbmRTYXZlKGRhdGEsIGN1cnJlbnRUYXJnZXQpO1xuICAgIH0pO1xuXG4gIH0sXG5cbiAgYWRkQW5kU2F2ZTogZnVuY3Rpb24gKGRhdGEsIGN1cnJlbnRUYXJnZXQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsIGNvbW1lbnQ7XG5cbiAgICBjb21tZW50ID0gbmV3IENvbW1lbnRNb2RlbCh7XG4gICAgICBwYXJlbnRJZCAgOiBkYXRhWydwYXJlbnRJZCddLFxuICAgICAgdmFsdWUgICAgIDogZGF0YVsnY29tbWVudCddLFxuICAgICAgdGFza0lkICAgIDogZGF0YVsndGFza0lkJ10sXG4gICAgICBwcm9qZWN0SWQgOiBkYXRhWydwcm9qZWN0SWQnXSxcbiAgICAgIHRvcGljICAgICA6IGRhdGFbJ3RvcGljJ11cbiAgICB9KVxuXG4gICAgc2VsZi5hZGQoY29tbWVudCk7XG5cbiAgICBzZWxmLm1vZGVscy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgaWYgKG1vZGVsLmF0dHJpYnV0ZXMudmFsdWUgPT09IGRhdGFbJ2NvbW1lbnQnXSkge1xuICAgICAgICBtb2RlbC5zYXZlKG51bGwsIHtcbiAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAobW9kZWxJbnN0YW5jZSwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcihcImNvbW1lbnQ6c2F2ZTpzdWNjZXNzXCIsIG1vZGVsSW5zdGFuY2UsIHJlc3BvbnNlLCBjdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbW1lbnRDb2xsZWN0aW9uO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xuXG5cbnZhciBDb21tZW50TW9kZWwgPSBCYWNrYm9uZS5Nb2RlbC5leHRlbmQoe1xuXG4gIHVybFJvb3Q6ICcvYXBpL2NvbW1lbnQnLFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNhdmVDb21tZW50KCk7XG4gIH0sXG5cbiAgc2F2ZUNvbW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLmxpc3RlblRvKHRoaXMsICdjb21tZW50OnNhdmUnLCBmdW5jdGlvbiAocGFyZW50SWQsIGNvbW1lbnQsIHByb2plY3RJZCkge1xuICAgICAgc2VsZi5zYXZlKHtcbiAgICAgICAgcGFyZW50SWQgIDogcGFyZW50SWQsXG4gICAgICAgIHZhbHVlICAgICA6IGNvbW1lbnQsXG4gICAgICAgIHByb2plY3RJZCA6IHByb2plY3RJZFxuICAgICAgfSwge1xuICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIHNlbGYudHJpZ2dlcihcImNvbW1lbnQ6c2F2ZTpzdWNjZXNzXCIpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tbWVudE1vZGVsO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xuXG5cbnZhciBFdmVudE1vZGVsID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHtcblxuICB1cmxSb290OiAnL2FwaS9ldmVudCdcblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRNb2RlbDtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciBFdmVudE1vZGVsID0gcmVxdWlyZSgnLi9ldmVudF9tb2RlbCcpO1xuXG5cbnZhciBFdmVudENvbGxlY3Rpb24gPSBCYWNrYm9uZS5Db2xsZWN0aW9uLmV4dGVuZCh7XG4gIFxuICBtb2RlbDogRXZlbnRNb2RlbCxcbiAgXG4gIHBhcnNlOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiByZXNwb25zZS5ldmVudHM7XG4gICAgfVxuICB9LFxuXG4gIHVybDogJy9hcGkvZXZlbnQnLFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFkZEFuZFNhdmUoKTtcbiAgfSxcblxuICBhZGRBbmRTYXZlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLCBcImV2ZW50OnNhdmVcIiwgZnVuY3Rpb24gKGRhdGEpIHtcblxuICAgICAgc2VsZi5ldiA9IG5ldyBFdmVudE1vZGVsKHtcbiAgICAgICAgdGl0bGUgICAgICAgOiBkYXRhWyd0aXRsZSddLCBcbiAgICAgICAgZGVzY3JpcHRpb24gOiBkYXRhWydkZXNjcmlwdGlvbiddLCBcbiAgICAgICAgc3RhcnQgICAgICAgOiBkYXRhWydzdGFydCddLFxuICAgICAgICBlbmQgICAgICAgICA6IGRhdGFbJ2VuZCddLFxuICAgICAgICBsb2NhdGlvbiAgICA6IGRhdGFbJ2xvY2F0aW9uJ10sXG4gICAgICAgIHByb2plY3RJZCAgIDogZGF0YVsncHJvamVjdElkJ10gXG4gICAgICB9KTtcblxuICAgICAgc2VsZi5hZGQoc2VsZi5ldmVudCk7XG5cbiAgICAgIHNlbGYuZXYuc2F2ZSh7fSwge1xuICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAobW9kZWxJbnN0YW5jZSwgcmVzcG9uc2UpIHtcbiAgICAgICAgICBzZWxmLnRyaWdnZXIoXCJldmVudDpzYXZlOnN1Y2Nlc3NcIiwgbW9kZWxJbnN0YW5jZSwgcmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudENvbGxlY3Rpb247XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG5cblxuXHR2YXIgUHJvZmlsZU1vZGVsID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHtcblxuXHRcdHVybFJvb3Q6ICcvYXBpL3VzZXInLFxuXG5cdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5pbml0aWFsaXplUHJvZmlsZVNhdmUoKTtcblx0XHRcdHRoaXMuaW5pdGlhbGl6ZVByb2ZpbGVHZXQoKTtcblx0XHR9LFxuXG5cdFx0cGFyc2U6IGZ1bmN0aW9uKHJlcywgb3B0aW9ucykge1xuXHRcdFx0Ly8gUmVtb3ZlIGZhbHN5IHZhbHVlcyAoZGIgcmV0dXJucyBudWxsIGluc3RlYWQgb2YgdW5kZWZpbmVkKVxuXHRcdFx0XyhyZXMpLmVhY2goZnVuY3Rpb24odiwgaywgbykgeyBpZiAoIXYpIGRlbGV0ZSBvW2tdOyB9KTtcblx0XHRcdHJldHVybiByZXM7XG5cdFx0fSxcblxuXHRcdGluaXRpYWxpemVQcm9maWxlR2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHRcdHRoaXMubGlzdGVuVG8odGhpcywgXCJwcm9maWxlOmZldGNoXCIsIGZ1bmN0aW9uIChpZCkge1xuXHRcdFx0XHRzZWxmLnJlbW90ZUdldChpZCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG4gIHJlbW90ZUdldDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmIChpZCkge1xuXHQgICAgICB0aGlzLnNldCh7IGlkOiBpZCB9KTtcbiAgICB9XG4gICAgdGhpcy5mZXRjaCh7XG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbiAobW9kZWwsIHJlc3BvbnNlLCBvcHRpb25zKSB7XG4gICAgICAgIHNlbGYudHJpZ2dlcihcInByb2ZpbGU6ZmV0Y2g6c3VjY2Vzc1wiLCBtb2RlbCk7XG4gICAgICB9LFxuICAgICAgZXJyb3I6IGZ1bmN0aW9uIChtb2RlbCwgcmVzcG9uc2UsIG9wdGlvbnMpIHtcbiAgICAgICAgc2VsZi50cmlnZ2VyKFwicHJvZmlsZTpmZXRjaDplcnJvclwiLCBtb2RlbCwgcmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG5cdFx0aW5pdGlhbGl6ZVByb2ZpbGVTYXZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG5cdFx0XHR0aGlzLmxpc3RlblRvKHRoaXMsIFwicHJvZmlsZTp1cGRhdGVXaXRoUGhvdG9JZFwiLCBmdW5jdGlvbihmaWxlKSB7XG5cdFx0XHRcdHZhciBfc2VsZiA9IHRoaXM7XG5cdFx0XHRcdF90aGlzLnNhdmUoe1xuXHRcdFx0XHRcdHBob3RvSWQ6IGZpbGVbJ2lkJ11cblx0XHRcdFx0fSwge1xuXHRcdFx0XHRzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xuXHRcdFx0XHRcdF90aGlzLnRyaWdnZXIoXCJwcm9maWxlOnVwZGF0ZWRQaG90b1wiLCBkYXRhKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0ZXJyb3I6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdFx0XHRcdFx0Ly8gYW4gZXJyb3Igb2NjdXJyZWRcblx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLmxpc3RlblRvKHRoaXMsIFwicHJvZmlsZTpzYXZlXCIsIGZ1bmN0aW9uIChmb3JtKSB7XG5cdFx0XHRcdF90aGlzLnNhdmUoe1xuXHRcdFx0XHRcdG5hbWU6IGZvcm1bJ25hbWUnXSxcblx0XHRcdFx0XHR1c2VybmFtZTogZm9ybVsndXNlcm5hbWUnXSxcblx0XHRcdFx0XHR0aXRsZTogZm9ybVsndGl0bGUnXSxcblx0XHRcdFx0XHRiaW86IGZvcm1bJ2JpbyddXG5cdFx0XHRcdH0sIHtcblx0XHRcdFx0c3VjY2VzczogZnVuY3Rpb24gKGRhdGEpIHtcblx0XHRcdFx0XHRfdGhpcy50cmlnZ2VyKFwicHJvZmlsZTpzYXZlOnN1Y2Nlc3NcIiwgZGF0YSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGVycm9yOiBmdW5jdGlvbiAoZGF0YSkge1xuXHRcdFx0XHRcdF90aGlzLnRyaWdnZXIoXCJwcm9maWxlOnNhdmU6ZmFpbFwiLCBkYXRhKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLmxpc3RlblRvKHRoaXMsIFwicHJvZmlsZTpyZW1vdmVBdXRoXCIsIGZ1bmN0aW9uKGlkKSB7XG5cdFx0XHRcdHZhciBhdXRocyA9IHRoaXMuZ2V0KFwiYXV0aHNcIik7XG5cdFx0XHRcdGF1dGhzLnNwbGljZShhdXRocy5pbmRleE9mKGlkKSwgMSk7XG5cdFx0XHRcdF90aGlzLnNhdmUoe1xuXHRcdFx0XHRcdGF1dGhzOiBhdXRoc1xuXHRcdFx0XHR9LCB7XG5cdFx0XHRcdHN1Y2Nlc3M6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdFx0XHRcdFx0X3RoaXMudHJpZ2dlcihcInByb2ZpbGU6cmVtb3ZlQXV0aDpzdWNjZXNzXCIsIGRhdGEsIGlkKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0ZXJyb3I6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdFx0XHRcdFx0X3RoaXMudHJpZ2dlcihcInByb2ZpbGU6cmVtb3ZlQXV0aDpmYWlsXCIsIGRhdGEsIGlkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXG5cdFx0fVxuXG5cdH0pO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gUHJvZmlsZU1vZGVsO1xuXG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG5cblxudmFyIFByb2plY3RNb2RlbCA9IEJhY2tib25lLk1vZGVsLmV4dGVuZCh7XG5cbiAgZGVmYXVsdHM6IHtcbiAgICB0aXRsZSAgICAgICA6IG51bGwsXG4gICAgZGVzY3JpcHRpb24gOiBudWxsLFxuICAgIGFyY2hpdmVkICAgIDogZmFsc2VcbiAgfSxcblxuICAvLyBJbml0aWFsaXplIGNvbnRhaW5zIG9ubHkgZXZlbnQgYmluZGluZ3MgYW5kIGlmL3RoZW4gcmVzcG9uc2VcbiAgLy8gZnVuY3Rpb25zIChjbGFzcyBtZXRob2RzKS5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMubGlzdGVuVG8odGhpcywgXCJwcm9qZWN0Om1vZGVsOmZldGNoXCIsIGZ1bmN0aW9uIChpZCkge1xuICAgICAgc2VsZi5yZW1vdGVHZXQoaWQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLCBcInByb2plY3Q6bW9kZWw6dXBkYXRlXCIsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBzZWxmLnVwZGF0ZShkYXRhKTtcbiAgICB9KTtcblxuICAgIHRoaXMubGlzdGVuVG8odGhpcywgXCJwcm9qZWN0OnVwZGF0ZTpwaG90b0lkXCIsIGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICBzZWxmLnVwZGF0ZVBob3RvKGZpbGUpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLCBcInByb2plY3Q6dXBkYXRlOnN0YXRlXCIsIGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgc2VsZi51cGRhdGVTdGF0ZShzdGF0ZSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmxpc3RlblRvKHRoaXMsIFwicHJvamVjdG93bmVyOnNob3c6Y2hhbmdlZFwiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgc2VsZi51cGRhdGVPd25lcnMoZGF0YSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmxpc3RlblRvKHRoaXMsIFwicHJvamVjdDp1cGRhdGU6dGFza3M6b3JwaGFuXCIsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBzZWxmLm9ycGhhbihkYXRhKTtcbiAgICB9KTtcblxuICB9LFxuXG4gIHVybFJvb3Q6ICcvYXBpL3Byb2plY3QnLFxuXG4gIHJlbW90ZUdldDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuc2V0KHsgaWQ6IGlkIH0pO1xuICAgIHRoaXMuZmV0Y2goe1xuICAgICAgc3VjY2VzczogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgc2VsZi50cmlnZ2VyKFwicHJvamVjdDptb2RlbDpmZXRjaDpzdWNjZXNzXCIsIGRhdGEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLnNhdmUoe1xuICAgICAgdGl0bGU6IGRhdGFbJ3RpdGxlJ10sXG4gICAgICBkZXNjcmlwdGlvbjogZGF0YVsnZGVzY3JpcHRpb24nXVxuICAgIH0sIHsgc3VjY2VzczogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgc2VsZi50cmlnZ2VyKFwicHJvamVjdDpzYXZlOnN1Y2Nlc3NcIiwgZGF0YSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLy8gVE9ETzogVXBkYXRlIHRoaXMgbWV0aG9kIGFuZCBtb3ZlIGl0IGludG8gdGhlIGdsb2JhbCB1cGRhdGUgbWV0aG9kLlxuICB1cGRhdGVQaG90bzogZnVuY3Rpb24gKGZpbGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLnNhdmUoe1xuICAgICAgY292ZXJJZDogZmlsZVsnaWQnXVxuICAgIH0sIHtcbiAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHNlbGYudHJpZ2dlcihcInByb2plY3Q6dXBkYXRlZDpwaG90bzpzdWNjZXNzXCIsIGRhdGEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIHVwZGF0ZVN0YXRlOiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLnNhdmUoe1xuICAgICAgc3RhdGU6IHN0YXRlXG4gICAgfSwge1xuICAgICAgc3VjY2VzczogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBzZWxmLnRyaWdnZXIoXCJwcm9qZWN0OnVwZGF0ZTpzdGF0ZTpzdWNjZXNzXCIsIGRhdGEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIHVwZGF0ZU93bmVyczogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgLy8gY29uc29sZS5sb2coZGF0YSk7XG4gICAgdGhpcy5zYXZlKHtcbiAgICAgIG93bmVyczogZGF0YVxuICAgIH0sIHtcbiAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgc2VsZi50cmlnZ2VyKFwicHJvamVjdDp1cGRhdGU6b3duZXJzOnN1Y2Nlc3NcIiwgZGF0YSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgaGFzT3BlblRhc2tzOiBmdW5jdGlvbih0YXNrcyl7XG4gICAgLy90YWtlcyBhIHRhc2sgY29sbGVjdGlvbiBvYmplY3RcbiAgICB2YXIgaGFzT3BlblRhc2tzID0gZmFsc2U7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjb3VudCA9IDA7XG5cbiAgICBfLmVhY2godGFza3MubW9kZWxzLGZ1bmN0aW9uKHRhc2spe1xuICAgICAgaWYgKCBfLmluZGV4T2YoWydvcGVuJywnYXNzaWduZWQnXSx0YXNrLmF0dHJpYnV0ZXMuc3RhdGUpICE9IC0xICl7XG4gICAgICAgIGhhc09wZW5UYXNrcyA9IHRydWU7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge2hhc09wZW5UYXNrczpoYXNPcGVuVGFza3MsY291bnQ6Y291bnR9O1xuICB9LFxuXG4gIG9ycGhhbjogZnVuY3Rpb24odGFza3MpIHtcbiAgICAvL29ycGhhbnMgYXNzb2NpYXRlZCB0YXNrcyBmb3IgYSBzdGF0ZSBjaGFuZ2VcbiAgICB0YXNrcy5lYWNoKGZ1bmN0aW9uKG1vZGVsKXtcbiAgICAgIG1vZGVsLnRyaWdnZXIoXCJ0YXNrOnVwZGF0ZTpvcnBoYW5cIix7fSk7XG4gICAgfSk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvamVjdE1vZGVsO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIFByb2plY3RNb2RlbCA9IHJlcXVpcmUoJy4vcHJvamVjdF9tb2RlbCcpO1xuXG5cbnZhciBQcm9qZWN0c0NvbGxlY3Rpb24gPSBCYWNrYm9uZS5Db2xsZWN0aW9uLmV4dGVuZCh7XG5cbiAgbW9kZWw6IFByb2plY3RNb2RlbCxcblxuICB1cmw6ICcvYXBpL3Byb2plY3QvZmluZEFsbCcsXG5cbiAgcGFyc2U6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgIHJldHVybiByZXNwb25zZS5wcm9qZWN0cztcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLCBcInByb2plY3Q6c2F2ZVwiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgc2VsZi5hZGRBbmRTYXZlKGRhdGEpO1xuICAgIH0pO1xuICB9LFxuXG4gIGFkZEFuZFNhdmU6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHByb2plY3QsIHNlbGYgPSB0aGlzO1xuXG4gICAgcHJvamVjdCA9IG5ldyBQcm9qZWN0TW9kZWwoe1xuICAgICAgdGl0bGU6IGRhdGFbJ3RpdGxlJ10sXG4gICAgICBkZXNjcmlwdGlvbjogZGF0YVsnZGVzY3JpcHRpb24nXVxuICAgIH0pO1xuXG4gICAgcHJvamVjdC5zYXZlKHt9LCB7XG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBzZWxmLmFkZChwcm9qZWN0KTtcbiAgICAgICAgc2VsZi50cmlnZ2VyKFwicHJvamVjdDpzYXZlOnN1Y2Nlc3NcIiwgZGF0YSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvamVjdHNDb2xsZWN0aW9uO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBUYXNrTW9kZWwgPSBCYWNrYm9uZS5Nb2RlbC5leHRlbmQoe1xuXG4gIGRlZmF1bHRzOiB7XG4gICAgbmFtZSAgICAgICAgOiBudWxsLFxuICAgIGRlc2NyaXB0aW9uIDogbnVsbFxuICB9LFxuXG4gIHVybFJvb3Q6ICcvYXBpL3Rhc2snLFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMsIFwidGFzazpzYXZlXCIsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICB0aGlzLnNhdmUoZGF0YSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmxpc3RlblRvKHRoaXMsIFwidGFzazptb2RlbDpmZXRjaFwiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgdGhpcy5yZW1vdGVHZXQoZGF0YSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmxpc3RlblRvKHRoaXMsIFwidGFzazp1cGRhdGVcIiwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHRoaXMudXBkYXRlKGRhdGEpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLCBcInRhc2s6dXBkYXRlOnN0YXRlXCIsIGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgdGhpcy51cGRhdGVTdGF0ZShzdGF0ZSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmxpc3RlblRvKHRoaXMsIFwidGFzazp1cGRhdGU6b3JwaGFuXCIsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICB0aGlzLm9ycGhhbihkYXRhKTtcbiAgICB9KTtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5zYXZlKGRhdGEsIHtcbiAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHNlbGYudHJpZ2dlcihcInRhc2s6dXBkYXRlOnN1Y2Nlc3NcIiwgZGF0YSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgdXBkYXRlU3RhdGU6IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuc2F2ZSh7XG4gICAgICBzdGF0ZTogc3RhdGVcbiAgICB9LCB7XG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHNlbGYudHJpZ2dlcihcInRhc2s6dXBkYXRlOnN0YXRlOnN1Y2Nlc3NcIiwgZGF0YSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgb3JwaGFuOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5zYXZlKHtcbiAgICAgIHByb2plY3RJZDogbnVsbFxuICAgIH0sIHtcbiAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgc2VsZi50cmlnZ2VyKFwidGFzazp1cGRhdGU6b3JwaGFuOnN1Y2Nlc3NcIiwgZGF0YSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgfSxcblxuICByZW1vdGVHZXQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLnNldCh7IGlkOiBpZCB9KTtcbiAgICB0aGlzLmZldGNoKHtcbiAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHNlbGYudHJpZ2dlcihcInRhc2s6bW9kZWw6ZmV0Y2g6c3VjY2Vzc1wiLCBkYXRhKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxufSk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBUYXNrTW9kZWw7XG5cbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciBUYXNrTW9kZWwgPSByZXF1aXJlKCcuL3Rhc2tfbW9kZWwnKTtcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVGFza3NDb2xsZWN0aW9uID0gQmFja2JvbmUuQ29sbGVjdGlvbi5leHRlbmQoe1xuXG4gIG1vZGVsOiBUYXNrTW9kZWwsXG5cbiAgcGFyc2U6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgaWYgKHJlc3BvbnNlLnRhc2tzKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS50YXNrcztcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9LFxuXG4gIHVybDogJy9hcGkvdGFzaycsXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMubGlzdGVuVG8odGhpcywgXCJ0YXNrOnNhdmVcIiwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHNlbGYuYWRkQW5kU2F2ZShkYXRhKTtcbiAgICB9KVxuICB9LFxuXG4gIGFkZEFuZFNhdmU6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgc2VsZi50YXNrID0gbmV3IFRhc2tNb2RlbChkYXRhKTtcblxuICAgIHNlbGYudGFzay5zYXZlKG51bGwse1xuICAgICAgc3VjY2VzczogZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgIHNlbGYudHJpZ2dlcihcInRhc2s6c2F2ZTpzdWNjZXNzXCIsIHNlbGYudGFzay5pZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVGFza3NDb2xsZWN0aW9uO1xuXG4iLCJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciBCYXNlQ29tcG9uZW50ID0gcmVxdWlyZSgnLi4vYmFzZS9iYXNlX2NvbXBvbmVudCcpO1xudmFyIEJvb3RzdHJhcCA9IHJlcXVpcmUoJ2Jvb3RzdHJhcCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlsaXRpZXMnKTtcbnZhciBQb3BvdmVyUHJvZmlsZSA9IHJlcXVpcmUoJy4vdGVtcGxhdGVzL3BvcG92ZXJfcHJvZmlsZS5odG1sJyk7XG5cblxuUG9wb3ZlcnMgPSBCYXNlQ29tcG9uZW50LmV4dGVuZCh7XG5cbiAgcG9wb3ZlclBlb3BsZUluaXQ6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAkKHRhcmdldCkucG9wb3ZlcihcbiAgICAgIHtcbiAgICAgICAgcGxhY2VtZW50OiAnYXV0byB0b3AnLFxuICAgICAgICB0cmlnZ2VyOiAnbWFudWFsJyxcbiAgICAgICAgaHRtbDogJ3RydWUnLFxuICAgICAgICB0aXRsZTogJ2xvYWQnLFxuICAgICAgICBjb250YWluZXI6ICdib2R5JyxcbiAgICAgICAgY29udGVudDogJzxkaXYgY2xhc3M9XCJwb3BvdmVyLXNwaW5uZXJcIj48ZGl2IGNsYXNzPVwibG9hZGluZ1wiPkZldGNoaW5nIEluZm9ybWF0aW9uPC9kaXY+PGkgY2xhc3M9XCJmYSBmYS1zcGlubmVyIGZhLXNwaW5cIj48L2k+PC9kaXY+JyxcbiAgICAgICAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwicG9wb3ZlclwiPjxkaXYgY2xhc3M9XCJhcnJvd1wiPjwvZGl2PjxoMyBjbGFzcz1cInBvcG92ZXItdGl0bGVcIiBzdHlsZT1cImRpc3BsYXk6bm9uZTsgdmlzaWJpbGl0eTpoaWRkZW5cIj48L2gzPjxkaXYgY2xhc3M9XCJwb3BvdmVyLWNvbnRlbnRcIj48L2Rpdj48L2Rpdj4nXG4gICAgICB9KS5vbihcIm1vdXNlbGVhdmVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdGltZW91dEZuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghJChcIi5wb3BvdmVyOmhvdmVyXCIpLmxlbmd0aCkge1xuICAgICAgICAgICAgJChfdGhpcykucG9wb3ZlcihcImhpZGVcIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGltZW91dEZuLCAxMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc2V0VGltZW91dCh0aW1lb3V0Rm4sIDEwMCk7XG4gICAgICB9KTtcbiAgfSxcblxuICBwb3BvdmVyUGVvcGxlT246IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB2YXIgdGFyZ2V0ID0gJChlLmN1cnJlbnRUYXJnZXQpO1xuICAgIHZhciBwb3BvdmVyID0gdGFyZ2V0LmRhdGEoJ2JzLnBvcG92ZXInKTtcbiAgICAvLyBpZiB0aGUgZGF0YSBlbGVtZW50IGlzbid0IHNldCBvciBwb3BvdmVycyBub3QgaW5pdCdkLCBhYm9ydFxuICAgIGlmICgoXy5pc1VuZGVmaW5lZCh0YXJnZXQuZGF0YSgndXNlcmlkJykpKSB8fCAoXy5pc1VuZGVmaW5lZChwb3BvdmVyKSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGFyZ2V0LnBvcG92ZXIoJ3Nob3cnKTtcbiAgICAvLyBPbmx5IGxvYWQgZGF0YSBpZiB0aGUgcG9wb3ZlciBoYXNuJ3QgcHJldmlvdXNseSBiZWVuIGxvYWRlZFxuICAgIGlmIChwb3BvdmVyLm9wdGlvbnMudGl0bGUgPT0gJ2xvYWQnKSB7XG4gICAgICAkLmFqYXgoeyB1cmw6ICcvYXBpL3VzZXIvaW5mby8nICsgdGFyZ2V0LmRhdGEoJ3VzZXJpZCcpIH0pLmRvbmUoZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgdGVtcGxhdGUgPSBfLnRlbXBsYXRlKFBvcG92ZXJQcm9maWxlKSh7ZGF0YTogZGF0YX0pO1xuICAgICAgICBwb3BvdmVyLm9wdGlvbnMudGl0bGUgPSAnZG9uZSc7XG4gICAgICAgIHBvcG92ZXIub3B0aW9ucy5jb250ZW50ID0gdGVtcGxhdGU7XG4gICAgICAgIHBvcG92ZXIuc2V0Q29udGVudCgpO1xuICAgICAgICBwb3BvdmVyLiR0aXAuYWRkQ2xhc3MocG9wb3Zlci5vcHRpb25zLnBsYWNlbWVudCk7XG4gICAgICAgIC8vIGhhbmRsZSBsaW5rcyBpbiB0aGUgcG9wb3ZlcnNcbiAgICAgICAgJChcIi5wb3BvdmVyXCIpLm9uKCdjbGljaycsIFwiLmxpbmstYmFja2JvbmVcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB0YXJnZXQucG9wb3ZlcignaGlkZScpO1xuICAgICAgICAgIGxpbmtCYWNrYm9uZShlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgcG9wb3ZlckNsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIGlkID0gJChlLmN1cnJlbnRUYXJnZXQpLmRhdGEoJ3VzZXJpZCcpO1xuICAgICQoZS5jdXJyZW50VGFyZ2V0KS5wb3BvdmVyKCdoaWRlJyk7XG4gICAgQmFja2JvbmUuaGlzdG9yeS5uYXZpZ2F0ZSgncHJvZmlsZS8nICsgaWQsIHsgdHJpZ2dlcjogdHJ1ZSB9KTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUG9wb3ZlcnM7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwicG9wb3Zlci10YWJsZVxcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJwb3BvdmVyLXJvd1xcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcInBvcG92ZXItY2VsbC1sZWZ0XFxcIj5cXG4gICAgICA8aW1nIGFsaWduPVxcXCJsZWZ0XFxcIiBzcmM9XFxcIi9hcGkvdXNlci9waG90by88JS0gZGF0YS5pZCAlPlxcXCIgY2xhc3M9XFxcInBvcG92ZXItaW1hZ2VcXFwiLz5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcInBvcG92ZXItY2VsbC1yaWdodCBwb3BvdmVyLXBlcnNvblxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwidGl0bGVcXFwiPjxhIGNsYXNzPVxcXCJsaW5rLWJhY2tib25lXFxcIiBocmVmPVxcXCIvcHJvZmlsZS88JS0gZGF0YS5pZCAlPlxcXCI+PCUtIGRhdGEubmFtZSAlPjwvYT48L2Rpdj5cXG4gICAgICA8JSBpZiAoZGF0YS50aXRsZSkgeyAlPjxkaXYgY2xhc3M9XFxcInRleHQtbGluZVxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLWJyaWVmY2FzZVxcXCI+PC9pPiA8JS0gZGF0YS50aXRsZSAlPjwvZGl2PjwlIH0gJT5cXG4gICAgICA8JSBpZiAoZGF0YS5hZ2VuY3kpIHsgJT48ZGl2IGNsYXNzPVxcXCJ0ZXh0LWxpbmVcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1saWJyYXJ5XFxcIj48L2k+IDwlLSBkYXRhLmFnZW5jeS50YWcubmFtZSAlPjwvZGl2PjwlIH0gJT5cXG4gICAgICA8JSBpZiAoZGF0YS5sb2NhdGlvbikgeyAlPjxkaXYgY2xhc3M9XFxcInRleHQtbGluZVxcXCI+PHNwYW4gY2xhc3M9XFxcImZhIGZhLW1hcC1tYXJrZXJcXFwiPjwvc3Bhbj4gPCUtIGRhdGEubG9jYXRpb24udGFnLm5hbWUgJT48L2Rpdj48JSB9ICU+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC9kaXY+XCI7XG4iLCIvLyBJbnB1dDpcbi8vIEBjb2xsZWN0aW9uIFtBUlJBWV0gQmFja2JvbmUgY29sbGVjdGlvbi5cbi8vIEBtb2RlbElkIFtJTlRFR0VSXSBCYWNrYm9uZSBNb2RlbC5jaWRcblxuLy8gUmV0dXJuOiBbT0JKRUNUXSBNb2RlbCBpbnN0YW5jZSBsb29rZWQgdXAgZnJvbSBtb2RlbElkIHdpdGhpbiBjb2xsZWN0aW9uLlxuZ2xvYmFsLmdldEN1cnJlbnRNb2RlbEZyb21JZCA9IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBtb2RlbElkKSB7XG5cdHZhciBpID0gMDtcblx0XHRcdGlkID0gcGFyc2VJbnQobW9kZWxJZClcblx0XHRcdG1vZGVscyA9IGNvbGxlY3Rpb24ubW9kZWxzO1xuXG5cdGZvciAoIDsgaSA8IG1vZGVscy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGlmIChtb2RlbHNbaV0uaWQgPT09IGlkKSB7XG5cdFx0XHRyZXR1cm4gbW9kZWxzW2ldO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cdH1cbn1cblxuLy8gSW5wdXQ6XG4vLyBAY29sbGVjdGlvbiBbQVJSQVldIEJhY2tib25lIGNvbGxlY3Rpb24uXG4vLyBAYXR0ciBbU1RSSU5HXSBWYWx1ZSwgdG8gYmUgZm91bmQuXG5cbi8vIFJldHVybjogW09CSkVDVF0gTW9kZWwgaW5zdGFuY2UgdGhhdCBpcyBjb3JvbGxhcnkgdG8gdGhlIGZvdW5kIEBhdHRyIHZhbHVlLlxuZ2xvYmFsLmdldEN1cnJlbnRNb2RlbEZyb21Gb3JtQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBhdHRyKSB7XG5cdHZhclx0aixcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXR0ciA9ICQudHJpbShhdHRyKSxcblx0XHRcdG1vZGVscyA9IGNvbGxlY3Rpb24ubW9kZWxzO1xuXG5cdC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIG1vZGVsc1xuXHRmb3IgKCA7IGkgPCBtb2RlbHMubGVuZ3RoOyBpICs9IDEpIHtcblxuXHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIGF0dHJpYnV0ZXMgd2l0aGluIHRoZSBtb2RlbFxuXHRcdGZvciAoaiBpbiBtb2RlbHNbaV0uYXR0cmlidXRlcykge1xuXG5cdFx0XHQvLyBJZiB3ZSBmaW5kIHRoZSBtb2RlbC5hdHRyW3ZhbHVlXSBvbiB0aGUgY3VycmVudCBtb2RlbHNcblx0XHRcdC8vIGF0dHJpYnV0ZSB0aGF0IHdlIGFyZSBsb29waW5nIG92ZXIsIHRoZW4gc3RvcCBhbmQgcmV0dXJuIHRoYXRcblx0XHRcdC8vIG1vZGVsIGJhY2sgb3V0IHRvIHRoZSBmcm9udC1lbmQuXG5cdFx0XHRpZiAobW9kZWxzW2ldLmF0dHJpYnV0ZXNbal0gPT09IGF0dHIpIHtcblx0XHRcdFx0cmV0dXJuIG1vZGVsc1tpXVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGNvbnRpbnVlIG9uLlxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBDb21wbGV0ZWx5IHJlbW92ZSBhIGJhY2tib25lIHZpZXcgYW5kIGFsbCBvZiBpdHNcbiAqIHJlZmVyZW5jZXMuICBUaGlzIGlzIG5lZWRlZCB0byBkZXN0cm95IHRoZSB2aWV3XG4gKiBhbmQgYWxsIG9mIGl0cyBsaXN0ZW5lcnMsIGluIG9yZGVyIHRvIHN0YXJ0XG4gKiBmcmVzaCBhZ2FpbiBhbmQgcmVuZGVyIGEgbmV3IHZpZXcgd2l0aCBhIG5ld1xuICogbW9kZWwuXG4gKlxuICogSW5wdXQ6XG4gKiBAdmlldyB0aGUgdmlldyB0byBiZSByZW1vdmVkLCB0eXBpY2FsbHkgY2FsbGVkIHdpdGggcmVtb3ZlVmlldyh0aGlzKTtcbiAqXG4gKiBSZXR1cm46XG4gKiBub3RoaW5nXG4gKi9cbmdsb2JhbC5yZW1vdmVWaWV3ID0gZnVuY3Rpb24gKHZpZXcpIHtcbiAgdmlldy51bmRlbGVnYXRlRXZlbnRzKCk7XG4gIHZpZXcuJGVsLmh0bWwoXCJcIik7XG59XG5cbi8qKlxuICogQ2xlYXIgb3V0IGFueSBlbC5cbiAqIEBwYXJhbXMge1tUaGUgbm9uLWpxdWVyeSBtYXBwZWQgZWwgZm9yIHRoZSB2aWV3IGluc3RhbmNlXX1cbiAqIFJldHVybjogTm90aGluZy5cbiAqL1xuZ2xvYmFsLmNsZWFyRWwgPSBmdW5jdGlvbiAoZWwpIHtcbiAgJChlbCkuY2hpbGRyZW4oKS5yZW1vdmUoKTtcbn1cblxuLyoqXG4gKiBDbGVhciBvdXQgb3VyIGdsb2JhbCBjb250YWluZXIgZm9yIGZ1bGwgcGFnZSB0cmFuc2l0aW9ucy5cbiAqIEBwYXJhbXMgTm9uZVxuICogQHJldHVybiBOb3RoaW5nXG4gKi9cbmdsb2JhbC5jbGVhckNvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgJChcIiNjb250YWluZXJcIikuY2hpbGRyZW4oKS5yZW1vdmUoKTtcbn1cblxuLyoqXG4gKiBUaGlzIGhlbHBzIGFsbGV2aWF0ZSBhIGNvbW1vbiBidWcgd2l0aCBhamF4IGJhc2VkXG4gKiBwYWdlIHRyYW5zaXRpb25zLiBUaGF0IGlzIHNvbWV0aW1lcyB3aGVuIHRoZSBwYWdlIHB1c2hlcyBpdHNlbGYgb2ZmIHRoZSBzY3JlZW5cbiAqIGFuZCBhbGxvd3MgYSBicm93c2VyIGRlZmF1bHQgYmFja2dyb3VuZCB0byBzaG93LCBhZnRlciB3aGljaCBzY3JvbGxpbmdcbiAqIHVwIGlzIHJlcXVpcmVkLiAgSXQgaXMgYSBzb21ld2hhdCByYXJlIGJ1ZywgYnV0IHVzZWZ1bCB0byBoYXZlIHRoaXMgZnVuY3Rpb25cbiAqIGlmIHlvdSBuZWVkIGl0LlxuICpcbiAqIFJldHVybjpcbiAqIG5vdGhpbmdcbiAqL1xuZ2xvYmFsLnNjcm9sbFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgJCh3aW5kb3cpLnNjcm9sbFRvcCgkKHdpbmRvdykuc2Nyb2xsVG9wKCkpO1xufVxuXG4vKipcbiAqIE9yZ2FuaXplIHRoZSB0YWdzIG91dHB1dCBpbnRvIGFuIGFzc29jaWF0aXZlIGFycmF5IGtleSdkIGJ5IHRoZWlyIHR5cGUuXG4gKiBJZiB0aGUgdGFnIGhhcyBtb3JlIHRoYW4gb25lIHZhbHVlIGZvciBzYWlkIGtleSwgbWFrZSBpdCBhbiBhcnJheSBvdGhlcndpc2VcbiAqIGtlZXAgaXQgYXMgYSB0b3AgbGV2ZWwgb2JqZWN0LlxuICogQHBhcmFtICB7W2FycmF5XX0gdGFncyAgICAgICAgICAgW2FycmF5IG9mIHRhZ3NdXG4gKiBAcmV0dXJuIHtbb2JqZWN0XX0gICAgICAgICAgICAgICBbYmluZGluZ09iamVjdCByZXR1cm5lZCBvdXRdXG4gKi9cbmdsb2JhbC5vcmdhbml6ZVRhZ3MgPSBmdW5jdGlvbiAodGFncykge1xuICB2YXIgb3V0VGFncyA9IHt9O1xuICBmb3IgKHQgaW4gdGFncykge1xuICAgIGlmICghKF8uaGFzKG91dFRhZ3MsIHRhZ3NbdF0udGFnLnR5cGUpKSkge1xuICAgICAgb3V0VGFnc1t0YWdzW3RdLnRhZy50eXBlXSA9IFtdO1xuICAgIH1cbiAgICBvdXRUYWdzW3RhZ3NbdF0udGFnLnR5cGVdLnB1c2godGFnc1t0XS50YWcpO1xuICB9XG4gIHJldHVybiBvdXRUYWdzO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIGFuIGlucHV0IGZpZWxkLiAgQXNzdW1lcyB0aGF0IHRoZXJlIGlzIGEgZGF0YVxuICogdmFyaWFibGUgaW4gdGhlIEhUTUwgdGFnIGNhbGxlZCBgZGF0YS12YWxpZGF0ZWAgd2l0aCB0aGVcbiAqIHZhbGlkYXRpb24gb3B0aW9ucyB0aGF0IHlvdSB3YW50IHRvIGVuZm9yY2UuXG4gKlxuICogZW1haWwgaXMgb25seSBtZWFudCB0byBhbGxvdyB0aGUgdmFsdWUgaXMgZ2VuZXJhbGx5IGVtYWlsIHNoYXBlZFxuICogICAgaXQgaXMgbm90IGJ1bGxldCBwcm9vZlxuICpcbiAqIGVtYWlsZG9tYWluIHJlcXVpcmVzIGEgZGF0YS1lbWFpbGRvbWFpbiB2YXJpYWJsZSBpbiB0aGUgSFRNTCB0YWdcbiAqICAgIGl0IHdpbGwgdmFsaWRhdGUgYWdhaW5zdCB0aGUgdmFsdWUgdGhlcmVcbiAqXG4gKiBUaGUgaW5wdXQgc2hvdWxkIGJlIGluIGEgYGZvcm0tZ3JvdXBgIGNvbXBvbmVudCxcbiAqIGFuZCB0aGUgY29tcG9uZW50IHNob3VsZCBoYXZlIGEgLmhlbHAtdGV4dCBlbGVtZW50XG4gKiB3aXRoIGEgY2xhc3MgYC5lcnJvci1bY29kZV1gIHdoZXJlIFtjb2RlXSBpcyB0aGVcbiAqIHZhbGlkYXRpb24gcnVsZSAoZWcsIGBlbXB0eWApO1xuICpcbiAqIEV4cGVjdHMgYW4gb2JqZWN0IHdpdGggY3VycmVudFRhcmdldCwgZWcgeyBjdXJyZW50VGFyZ2V0OiAnI2ZvbycgfVxuICovXG5nbG9iYWwudmFsaWRhdGUgPSBmdW5jdGlvbiAoZSkge1xuICB2YXIgb3B0cyA9IFN0cmluZygkKGUuY3VycmVudFRhcmdldCkuZGF0YSgndmFsaWRhdGUnKSkuc3BsaXQoJywnKTtcbiAgdmFyIHZhbCA9ICQoZS5jdXJyZW50VGFyZ2V0KS52YWwoKTtcbiAgdmFyIHBhcmVudCA9ICQoZS5jdXJyZW50VGFyZ2V0KS5wYXJlbnRzKCcuZm9ybS1ncm91cCwgLmNoZWNrYm94JylbMF07XG4gIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgXy5lYWNoKG9wdHMsIGZ1bmN0aW9uIChvKSB7XG4gICAgaWYgKG8gPT0gJ2VtcHR5Jykge1xuICAgICAgaWYgKCF2YWwpIHtcbiAgICAgICAgJChwYXJlbnQpLmZpbmQoJy5lcnJvci1lbXB0eScpLnNob3coKTtcbiAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICQocGFyZW50KS5maW5kKCcuZXJyb3ItZW1wdHknKS5oaWRlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvID09ICdjaGVja2VkJykge1xuICAgICAgaWYgKCQoZS5jdXJyZW50VGFyZ2V0KS5wcm9wKCdjaGVja2VkJykgIT09IHRydWUpIHtcbiAgICAgICAgJChwYXJlbnQpLmZpbmQoJy5lcnJvci1jaGVja2VkJykuc2hvdygpO1xuICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJChwYXJlbnQpLmZpbmQoJy5lcnJvci1jaGVja2VkJykuaGlkZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoby5zdWJzdHJpbmcoMCw1KSA9PSAnY291bnQnKSB7XG4gICAgICB2YXIgbGVuID0gcGFyc2VJbnQoby5zdWJzdHJpbmcoNSkpO1xuICAgICAgaWYgKHZhbC5sZW5ndGggPiBsZW4pIHtcbiAgICAgICAgJChwYXJlbnQpLmZpbmQoJy5lcnJvci0nICsgbykuc2hvdygpO1xuICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJChwYXJlbnQpLmZpbmQoJy5lcnJvci0nICsgbykuaGlkZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobyA9PSAnY29uZmlybScpIHtcbiAgICAgIHZhciBpZCA9ICQoZS5jdXJyZW50VGFyZ2V0KS5hdHRyKCdpZCcpO1xuICAgICAgdmFyIG5ld1ZhbCA9ICQoJyMnICsgaWQgKyAnLWNvbmZpcm0nKS52YWwoKTtcbiAgICAgIGlmICh2YWwgIT0gbmV3VmFsKSB7XG4gICAgICAgICQocGFyZW50KS5maW5kKCcuZXJyb3ItJyArIG8pLnNob3coKTtcbiAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICQocGFyZW50KS5maW5kKCcuZXJyb3ItJyArIG8pLmhpZGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG8gPT0gJ2J1dHRvbicpIHtcbiAgICAgIGlmICghKCQoJChwYXJlbnQpLmZpbmQoXCIjXCIgKyAkKGUuY3VycmVudFRhcmdldCkuYXR0cignaWQnKSArIFwiLWJ1dHRvblwiKVswXSkuaGFzQ2xhc3MoJ2J0bi1zdWNjZXNzJykpKSB7XG4gICAgICAgICQocGFyZW50KS5maW5kKCcuZXJyb3ItJyArIG8pLnNob3coKTtcbiAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICQocGFyZW50KS5maW5kKCcuZXJyb3ItJyArIG8pLmhpZGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG8gPT0gJ2VtYWlsJyl7XG4gICAgICB2YXIgY29ycmVjdExlbmd0aCA9IGZhbHNlO1xuICAgICAgaWYgKCB2YWwgIT0gXCJcIiAmJiB2YWwuaW5kZXhPZihcIkBcIikgPj0gMiApe1xuICAgICAgICB2YXIgYml0cyA9IHZhbC5zcGxpdChcIkBcIik7XG4gICAgICAgIHZhciBhZGRyQml0cyA9IGJpdHNbMV0uc3BsaXQoXCIuXCIpO1xuICAgICAgICBpZiAoIGFkZHJCaXRzLmxlbmd0aCA+PTIgKSB7XG4gICAgICAgICAgZm9yIChpPTA7IGk8YWRkckJpdHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIGlmICggYWRkckJpdHNbaV0ubGVuZ3RoIDwgMiApe1xuICAgICAgICAgICAgICBjb3JyZWN0TGVuZ3RoID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29ycmVjdExlbmd0aCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoICFjb3JyZWN0TGVuZ3RoIHx8IGJpdHNbMF0ubGVuZ3RoIDwgMiApIHtcbiAgICAgICAgJChwYXJlbnQpLmZpbmQoJy5lcnJvci1lbWFpbCcpLnNob3coKTtcbiAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICQocGFyZW50KS5maW5kKCcuZXJyb3ItZW1haWwnKS5oaWRlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICggbz09ICdlbWFpbGRvbWFpbicpe1xuICAgICAgdmFyIGRvbWFpbiA9ICQoZS5jdXJyZW50VGFyZ2V0KS5kYXRhKCdlbWFpbGRvbWFpbicpO1xuICAgICAgaWYgKCB2YWwgIT0gXCJcIiAmJiB2YWwuaW5kZXhPZihcIkBcIikgPj0gMiApe1xuICAgICAgICB2YXIgYml0cyA9IHZhbC5zcGxpdChcIkBcIik7XG4gICAgICAgIGlmICggYml0c1sxXSAhPSBkb21haW4gKXtcbiAgICAgICAgICAkKHBhcmVudCkuZmluZCgnLmVycm9yLWVtYWlsZG9tYWluJykuc2hvdygpO1xuICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJChwYXJlbnQpLmZpbmQoJy5lcnJvci1lbWFpbGRvbWFpbicpLmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSk7XG4gIGlmIChyZXN1bHQgPT09IHRydWUpIHtcbiAgICAkKHBhcmVudCkuYWRkQ2xhc3MoJ2hhcy1lcnJvcicpO1xuICB9IGVsc2Uge1xuICAgICQocGFyZW50KS5yZW1vdmVDbGFzcygnaGFzLWVycm9yJyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmdsb2JhbC52YWxpZGF0ZVBhc3N3b3JkID0gZnVuY3Rpb24gKHVzZXJuYW1lLCBwYXNzd29yZCkge1xuICB2YXIgcnVsZXMgPSB7XG4gICAgdXNlcm5hbWU6IGZhbHNlLFxuICAgIGxlbmd0aDogZmFsc2UsXG4gICAgdXBwZXI6IGZhbHNlLFxuICAgIGxvd2VyOiBmYWxzZSxcbiAgICBudW1iZXI6IGZhbHNlLFxuICAgIHN5bWJvbDogZmFsc2VcbiAgfTtcbiAgdmFyIF91c2VybmFtZSA9IHVzZXJuYW1lLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICB2YXIgX3Bhc3N3b3JkID0gcGFzc3dvcmQudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gIC8vIGNoZWNrIHVzZXJuYW1lIGlzIG5vdCB0aGUgc2FtZSBhcyB0aGUgcGFzc3dvcmQsIGluIGFueSBjYXNlXG4gIGlmIChfdXNlcm5hbWUgIT0gX3Bhc3N3b3JkICYmIF91c2VybmFtZS5zcGxpdCgnQCcsMSlbMF0gIT0gX3Bhc3N3b3JkKSB7XG4gICAgcnVsZXNbJ3VzZXJuYW1lJ10gPSB0cnVlO1xuICB9XG4gIC8vIGxlbmd0aCA+IDggY2hhcmFjdGVyc1xuICBpZiAocGFzc3dvcmQgJiYgcGFzc3dvcmQubGVuZ3RoID49IDgpIHtcbiAgICBydWxlc1snbGVuZ3RoJ10gPSB0cnVlO1xuICB9XG4gIC8vIFVwcGVyY2FzZSwgTG93ZXJjYXNlLCBhbmQgTnVtYmVyc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhc3N3b3JkLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRlc3QgPSBwYXNzd29yZC5jaGFyQXQoaSk7XG4gICAgLy8gZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM4MTY5MDUvY2hlY2tpbmctaWYtYS1zdHJpbmctc3RhcnRzLXdpdGgtYS1sb3dlcmNhc2UtbGV0dGVyXG4gICAgaWYgKHRlc3QgPT09IHRlc3QudG9Mb3dlckNhc2UoKSAmJiB0ZXN0ICE9PSB0ZXN0LnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIC8vIGxvd2VyY2FzZSBmb3VuZFxuICAgICAgcnVsZXNbJ2xvd2VyJ10gPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmICh0ZXN0ID09PSB0ZXN0LnRvVXBwZXJDYXNlKCkgJiYgdGVzdCAhPT0gdGVzdC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICBydWxlc1sndXBwZXInXSA9IHRydWU7XG4gICAgfVxuICAgIC8vIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xODA4Mi92YWxpZGF0ZS1udW1iZXJzLWluLWphdmFzY3JpcHQtaXNudW1lcmljXG4gICAgZWxzZSBpZiAoIWlzTmFOKHBhcnNlRmxvYXQodGVzdCkpICYmIGlzRmluaXRlKHRlc3QpKSB7XG4gICAgICBydWxlc1snbnVtYmVyJ10gPSB0cnVlO1xuICAgIH1cbiAgfVxuICAvLyBjaGVjayBmb3Igc3ltYm9sc1xuICBpZiAoLy4qW15cXHdcXHNdLiovLnRlc3QocGFzc3dvcmQpKSB7XG4gICAgcnVsZXNbJ3N5bWJvbCddID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcnVsZXM7XG59O1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBuYXZpZ2F0ZSBsaW5rcyB3aXRoaW4gYmFja2JvbmVcbiAqIGluc3RlYWQgb2YgcmVsb2FkaW5nIHRoZSB3aG9sZSBwYWdlIHRocm91Z2ggYSBoYXJkIGxpbmsuXG4gKiBUeXBpY2FsbHkgdXNlZCB3aXRoIHRoZSBgZXZlbnRzOiB7fWAgaGFuZGxlciBvZiBiYWNrYm9uZVxuICogc3VjaCBhcyAnY2xpY2sgLmxpbmstYmFja2JvbmUnIDogbGlua0JhY2tib25lXG4gKiBAcGFyYW0gZSB0aGUgZXZlbnQgZmlyZWQgYnkganF1ZXJ5L2JhY2tib25lXG4gKi9cbmdsb2JhbC5saW5rQmFja2JvbmUgPSBmdW5jdGlvbiAoZSkge1xuICAvLyBpZiBtZXRhIG9yIGNvbnRyb2wgaXMgaGVsZCwgb3IgaWYgdGhlIG1pZGRsZSBtb3VzZSBidXR0b24gaXMgcHJlc3NlZCxcbiAgLy8gbGV0IHRoZSBsaW5rIHByb2Nlc3Mgbm9ybWFsbHkuXG4gIC8vIGVnOiBvcGVuIGEgbmV3IHRhYiBvciB3aW5kb3cgYmFzZWQgb24gdGhlIGJyb3dzZXIgcHJlZnNcbiAgaWYgKChlLm1ldGFLZXkgPT09IHRydWUpIHx8IChlLmN0cmxLZXkgPT09IHRydWUpIHx8IChlLndoaWNoID09IDIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIG90aGVyd2lzZSBjb250YWluIHRoZSBsaW5rIHdpdGhpbiBiYWNrYm9uZVxuICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB2YXIgaHJlZiA9ICQoZS5jdXJyZW50VGFyZ2V0KS5hdHRyKCdocmVmJyk7XG4gIEJhY2tib25lLmhpc3RvcnkubmF2aWdhdGUoaHJlZiwgeyB0cmlnZ2VyOiB0cnVlIH0pO1xufTtcbiIsIi8qIVxuICogalF1ZXJ5LnNlbGVjdGlvbiAtIGpRdWVyeSBQbHVnaW5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBJV0FTQUtJIEtvamkgKEBtYWRhcGFqYSkuXG4gKiBodHRwOi8vYmxvZy5tYWRhcGFqYS5uZXQvXG4gKiBVbmRlciBUaGUgTUlUIExpY2Vuc2VcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbiAqIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuICogXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4gKiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4gKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbiAqIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xuICogdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRVxuICogTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTlxuICogT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4gKiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuKGZ1bmN0aW9uKCQsIHdpbiwgZG9jKSB7XG4gICAgLyoqXG4gICAgICogZ2V0IGNhcmV0IHN0YXR1cyBvZiB0aGUgc2VsZWN0aW9uIG9mIHRoZSBlbGVtZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0gICB7RWxlbWVudH0gICBlbGVtZW50ICAgICAgICAgdGFyZ2V0IERPTSBlbGVtZW50XG4gICAgICogQHJldHVybiAge09iamVjdH0gICAgcmV0dXJuXG4gICAgICogQHJldHVybiAge1N0cmluZ30gICAgcmV0dXJuLnRleHQgICAgIHNlbGVjdGVkIHRleHRcbiAgICAgKiBAcmV0dXJuICB7TnVtYmVyfSAgICByZXR1cm4uc3RhcnQgICAgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHNlbGVjdGlvblxuICAgICAqIEByZXR1cm4gIHtOdW1iZXJ9ICAgIHJldHVybi5lbmQgICAgICBlbmQgcG9zaXRpb24gb2YgdGhlIHNlbGVjdGlvblxuICAgICAqL1xuICAgIHZhciBfZ2V0Q2FyZXRJbmZvID0gZnVuY3Rpb24oZWxlbWVudCl7XG4gICAgICAgIHZhciByZXMgPSB7XG4gICAgICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgZW5kOiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFlbGVtZW50LnZhbHVlKSB7XG4gICAgICAgICAgICAvKiBubyB2YWx1ZSBvciBlbXB0eSBzdHJpbmcgKi9cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHdpbi5nZXRTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAvKiBleGNlcHQgSUUgKi9cbiAgICAgICAgICAgICAgICByZXMuc3RhcnQgPSBlbGVtZW50LnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgICAgICAgIHJlcy5lbmQgPSBlbGVtZW50LnNlbGVjdGlvbkVuZDtcbiAgICAgICAgICAgICAgICByZXMudGV4dCA9IGVsZW1lbnQudmFsdWUuc2xpY2UocmVzLnN0YXJ0LCByZXMuZW5kKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZG9jLnNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIC8qIGZvciBJRSAqL1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuZm9jdXMoKTtcblxuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGRvYy5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKSxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UyID0gZG9jLmJvZHkuY3JlYXRlVGV4dFJhbmdlKCksXG4gICAgICAgICAgICAgICAgICAgIHRtcExlbmd0aDtcblxuICAgICAgICAgICAgICAgIHJlcy50ZXh0ID0gcmFuZ2UudGV4dDtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlMi5tb3ZlVG9FbGVtZW50VGV4dChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UyLnNldEVuZFBvaW50KCdTdGFydFRvU3RhcnQnLCByYW5nZSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByYW5nZTIgPSBlbGVtZW50LmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZTIuc2V0RW5kUG9pbnQoJ1N0YXJ0VG9TdGFydCcsIHJhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXMuc3RhcnQgPSBlbGVtZW50LnZhbHVlLmxlbmd0aCAtIHJhbmdlMi50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXMuZW5kID0gcmVzLnN0YXJ0ICsgcmFuZ2UudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8qIGdpdmUgdXAgKi9cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNhcmV0IG9wZXJhdGlvbiBmb3IgdGhlIGVsZW1lbnRcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHZhciBfQ2FyZXRPcGVyYXRpb24gPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgY2FyZXQgcG9zaXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICAge0VsZW1lbnR9ICAgZWxlbWVudCAgICAgICAgIHRhcmdldCBlbGVtZW50XG4gICAgICAgICAqIEByZXR1cm4gIHtPYmplY3R9ICAgIHJldHVyblxuICAgICAgICAgKiBAcmV0dXJuICB7TnVtYmVyfSAgICByZXR1cm4uc3RhcnQgICAgc3RhcnQgcG9zaXRpb24gZm9yIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgICogQHJldHVybiAge051bWJlcn0gICAgcmV0dXJuLmVuZCAgICAgIGVuZCBwb3NpdGlvbiBmb3IgdGhlIHNlbGVjdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0UG9zOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgdG1wID0gX2dldENhcmV0SW5mbyhlbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiB7c3RhcnQ6IHRtcC5zdGFydCwgZW5kOiB0bXAuZW5kfTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0IGNhcmV0IHBvc2l0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAgIHtFbGVtZW50fSAgIGVsZW1lbnQgICAgICAgICB0YXJnZXQgZWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0gICB7T2JqZWN0fSAgICB0b1JhbmdlICAgICAgICAgY2FyZXQgcG9zaXRpb25cbiAgICAgICAgICogQHBhcmFtICAge051bWJlcn0gICAgdG9SYW5nZS5zdGFydCAgIHN0YXJ0IHBvc2l0aW9uIGZvciB0aGUgc2VsZWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSAgIHtOdW1iZXJ9ICAgIHRvUmFuZ2UuZW5kICAgICBlbmQgcG9zaXRpb24gZm9yIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgICogQHBhcmFtICAge1N0cmluZ30gICAgY2FyZXQgICAgICAgICAgIGNhcmV0IG1vZGU6IGFueSBvZiB0aGUgZm9sbG93aW5nOiBcImtlZXBcIiB8IFwic3RhcnRcIiB8IFwiZW5kXCJcbiAgICAgICAgICovXG4gICAgICAgIHNldFBvczogZnVuY3Rpb24oZWxlbWVudCwgdG9SYW5nZSwgY2FyZXQpIHtcbiAgICAgICAgICAgIGNhcmV0ID0gdGhpcy5fY2FyZXRNb2RlKGNhcmV0KTtcblxuICAgICAgICAgICAgaWYgKGNhcmV0ID09ICdzdGFydCcpIHtcbiAgICAgICAgICAgICAgICB0b1JhbmdlLmVuZCA9IHRvUmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNhcmV0ID09ICdlbmQnKSB7XG4gICAgICAgICAgICAgICAgdG9SYW5nZS5zdGFydCA9IHRvUmFuZ2UuZW5kO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmNyZWF0ZVRleHRSYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBlbGVtZW50LmNyZWF0ZVRleHRSYW5nZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW4ubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJtc2llXCIpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvUmFuZ2Uuc3RhcnQgPSBlbGVtZW50LnZhbHVlLnN1YnN0cigwLCB0b1JhbmdlLnN0YXJ0KS5yZXBsYWNlKC9cXHIvZywgJycpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvUmFuZ2UuZW5kID0gZWxlbWVudC52YWx1ZS5zdWJzdHIoMCwgdG9SYW5nZS5lbmQpLnJlcGxhY2UoL1xcci9nLCAnJykubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgdG9SYW5nZS5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIHRvUmFuZ2UuZW5kIC0gdG9SYW5nZS5zdGFydCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LnNldFNlbGVjdGlvblJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0U2VsZWN0aW9uUmFuZ2UodG9SYW5nZS5zdGFydCwgdG9SYW5nZS5lbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvKiBnaXZlIHVwICovXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCBzZWxlY3RlZCB0ZXh0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAgIHtFbGVtZW50fSAgIGVsZW1lbnQgICAgICAgICB0YXJnZXQgZWxlbWVudFxuICAgICAgICAgKiBAcmV0dXJuICB7U3RyaW5nfSAgICByZXR1cm4gICAgICAgICAgc2VsZWN0ZWQgdGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VGV4dDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIF9nZXRDYXJldEluZm8oZWxlbWVudCkudGV4dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IGNhcmV0IG1vZGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICAge1N0cmluZ30gICAgY2FyZXQgICAgICAgICAgIGNhcmV0IG1vZGVcbiAgICAgICAgICogQHJldHVybiAge1N0cmluZ30gICAgcmV0dXJuICAgICAgICAgIGFueSBvZiB0aGUgZm9sbG93aW5nOiBcImtlZXBcIiB8IFwic3RhcnRcIiB8IFwiZW5kXCJcbiAgICAgICAgICovXG4gICAgICAgIF9jYXJldE1vZGU6IGZ1bmN0aW9uKGNhcmV0KSB7XG4gICAgICAgICAgICBjYXJldCA9IGNhcmV0IHx8IFwia2VlcFwiO1xuICAgICAgICAgICAgaWYgKGNhcmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNhcmV0ID0gJ2VuZCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN3aXRjaCAoY2FyZXQpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdrZWVwJzpcbiAgICAgICAgICAgICAgICBjYXNlICdzdGFydCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBjYXJldCA9ICdrZWVwJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNhcmV0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZXBsYWNlIHNlbGVjdGVkIHRleHRcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICAge0VsZW1lbnR9ICAgZWxlbWVudCAgICAgICAgIHRhcmdldCBlbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgIHRleHQgICAgICAgICAgICByZXBsYWNlbWVudCB0ZXh0XG4gICAgICAgICAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgIGNhcmV0ICAgICAgICAgICBjYXJldCBtb2RlOiBhbnkgb2YgdGhlIGZvbGxvd2luZzogXCJrZWVwXCIgfCBcInN0YXJ0XCIgfCBcImVuZFwiXG4gICAgICAgICAqL1xuICAgICAgICByZXBsYWNlOiBmdW5jdGlvbihlbGVtZW50LCB0ZXh0LCBjYXJldCkge1xuICAgICAgICAgICAgdmFyIHRtcCA9IF9nZXRDYXJldEluZm8oZWxlbWVudCksXG4gICAgICAgICAgICAgICAgb3JpZyA9IGVsZW1lbnQudmFsdWUsXG4gICAgICAgICAgICAgICAgcG9zID0gJChlbGVtZW50KS5zY3JvbGxUb3AoKSxcbiAgICAgICAgICAgICAgICByYW5nZSA9IHtzdGFydDogdG1wLnN0YXJ0LCBlbmQ6IHRtcC5zdGFydCArIHRleHQubGVuZ3RofTtcblxuICAgICAgICAgICAgZWxlbWVudC52YWx1ZSA9IG9yaWcuc3Vic3RyKDAsIHRtcC5zdGFydCkgKyB0ZXh0ICsgb3JpZy5zdWJzdHIodG1wLmVuZCk7XG5cbiAgICAgICAgICAgICQoZWxlbWVudCkuc2Nyb2xsVG9wKHBvcyk7XG4gICAgICAgICAgICB0aGlzLnNldFBvcyhlbGVtZW50LCByYW5nZSwgY2FyZXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpbnNlcnQgYmVmb3JlIHRoZSBzZWxlY3RlZCB0ZXh0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAgIHtFbGVtZW50fSAgIGVsZW1lbnQgICAgICAgICB0YXJnZXQgZWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0gICB7U3RyaW5nfSAgICB0ZXh0ICAgICAgICAgICAgaW5zZXJ0aW9uIHRleHRcbiAgICAgICAgICogQHBhcmFtICAge1N0cmluZ30gICAgY2FyZXQgICAgICAgICAgIGNhcmV0IG1vZGU6IGFueSBvZiB0aGUgZm9sbG93aW5nOiBcImtlZXBcIiB8IFwic3RhcnRcIiB8IFwiZW5kXCJcbiAgICAgICAgICovXG4gICAgICAgIGluc2VydEJlZm9yZTogZnVuY3Rpb24oZWxlbWVudCwgdGV4dCwgY2FyZXQpIHtcbiAgICAgICAgICAgIHZhciB0bXAgPSBfZ2V0Q2FyZXRJbmZvKGVsZW1lbnQpLFxuICAgICAgICAgICAgICAgIG9yaWcgPSBlbGVtZW50LnZhbHVlLFxuICAgICAgICAgICAgICAgIHBvcyA9ICQoZWxlbWVudCkuc2Nyb2xsVG9wKCksXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSB7c3RhcnQ6IHRtcC5zdGFydCArIHRleHQubGVuZ3RoLCBlbmQ6IHRtcC5lbmQgKyB0ZXh0Lmxlbmd0aH07XG5cbiAgICAgICAgICAgIGVsZW1lbnQudmFsdWUgPSBvcmlnLnN1YnN0cigwLCB0bXAuc3RhcnQpICsgdGV4dCArIG9yaWcuc3Vic3RyKHRtcC5zdGFydCk7XG5cbiAgICAgICAgICAgICQoZWxlbWVudCkuc2Nyb2xsVG9wKHBvcyk7XG4gICAgICAgICAgICB0aGlzLnNldFBvcyhlbGVtZW50LCByYW5nZSwgY2FyZXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpbnNlcnQgYWZ0ZXIgdGhlIHNlbGVjdGVkIHRleHRcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICAge0VsZW1lbnR9ICAgZWxlbWVudCAgICAgICAgIHRhcmdldCBlbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgIHRleHQgICAgICAgICAgICBpbnNlcnRpb24gdGV4dFxuICAgICAgICAgKiBAcGFyYW0gICB7U3RyaW5nfSAgICBjYXJldCAgICAgICAgICAgY2FyZXQgbW9kZTogYW55IG9mIHRoZSBmb2xsb3dpbmc6IFwia2VlcFwiIHwgXCJzdGFydFwiIHwgXCJlbmRcIlxuICAgICAgICAgKi9cbiAgICAgICAgaW5zZXJ0QWZ0ZXI6IGZ1bmN0aW9uKGVsZW1lbnQsIHRleHQsIGNhcmV0KSB7XG4gICAgICAgICAgICB2YXIgdG1wID0gX2dldENhcmV0SW5mbyhlbGVtZW50KSxcbiAgICAgICAgICAgICAgICBvcmlnID0gZWxlbWVudC52YWx1ZSxcbiAgICAgICAgICAgICAgICBwb3MgPSAkKGVsZW1lbnQpLnNjcm9sbFRvcCgpLFxuICAgICAgICAgICAgICAgIHJhbmdlID0ge3N0YXJ0OiB0bXAuc3RhcnQsIGVuZDogdG1wLmVuZH07XG5cbiAgICAgICAgICAgIGVsZW1lbnQudmFsdWUgPSBvcmlnLnN1YnN0cigwLCB0bXAuZW5kKSArIHRleHQgKyBvcmlnLnN1YnN0cih0bXAuZW5kKTtcblxuICAgICAgICAgICAgJChlbGVtZW50KS5zY3JvbGxUb3AocG9zKTtcbiAgICAgICAgICAgIHRoaXMuc2V0UG9zKGVsZW1lbnQsIHJhbmdlLCBjYXJldCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyogYWRkIGpRdWVyeS5zZWxlY3Rpb24gKi9cbiAgICAkLmV4dGVuZCh7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgc2VsZWN0ZWQgdGV4dCBvbiB0aGUgd2luZG93XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgIG1vZGUgICAgICAgICAgICBzZWxlY3Rpb24gbW9kZTogYW55IG9mIHRoZSBmb2xsb3dpbmc6IFwidGV4dFwiIHwgXCJodG1sXCJcbiAgICAgICAgICogQHJldHVybiAge1N0cmluZ30gICAgcmV0dXJuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3Rpb246IGZ1bmN0aW9uKG1vZGUpIHtcbiAgICAgICAgICAgIHZhciBnZXRUZXh0ID0gKChtb2RlIHx8ICd0ZXh0JykudG9Mb3dlckNhc2UoKSA9PSAndGV4dCcpO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh3aW4uZ2V0U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZXRUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbi5nZXRTZWxlY3Rpb24oKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IGh0bWxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWwgPSB3aW4uZ2V0U2VsZWN0aW9uKCksIHJhbmdlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsLmdldFJhbmdlQXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHNlbC5nZXRSYW5nZUF0KDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZSA9IGRvYy5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KHNlbC5hbmNob3JOb2RlLCBzZWwuYW5jaG9yT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRFbmQoc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQoJzxkaXY+PC9kaXY+JykuYXBwZW5kKHJhbmdlLmNsb25lQ29udGVudHMoKSkuaHRtbCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkb2Muc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZXRUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvYy5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKS50ZXh0O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IGh0bWxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2Muc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCkuaHRtbFRleHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLyogZ2l2ZSB1cCAqL1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qIGFkZCBzZWxlY3Rpb24gKi9cbiAgICAkLmZuLmV4dGVuZCh7XG4gICAgICAgIHNlbGVjdGlvbjogZnVuY3Rpb24obW9kZSwgb3B0cykge1xuICAgICAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICAgICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIHNlbGVjdGlvbignZ2V0UG9zJylcbiAgICAgICAgICAgICAgICAgKiBnZXQgY2FyZXQgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4gIHtPYmplY3R9ICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4gIHtOdW1iZXJ9ICAgIHJldHVybi5zdGFydCAgICBzdGFydCBwb3NpdGlvbiBmb3IgdGhlIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4gIHtOdW1iZXJ9ICAgIHJldHVybi5lbmQgICAgICBlbmQgcG9zaXRpb24gZm9yIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjYXNlICdnZXRQb3MnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX0NhcmV0T3BlcmF0aW9uLmdldFBvcyh0aGlzWzBdKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIHNlbGVjdGlvbignc2V0UG9zJywgb3B0cylcbiAgICAgICAgICAgICAgICAgKiBzZXQgY2FyZXQgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSAgIHtOdW1iZXJ9ICAgIG9wdHMuc3RhcnQgICAgICBzdGFydCBwb3NpdGlvbiBmb3IgdGhlIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSAgIHtOdW1iZXJ9ICAgIG9wdHMuZW5kICAgICAgICBlbmQgcG9zaXRpb24gZm9yIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjYXNlICdzZXRQb3MnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX0NhcmV0T3BlcmF0aW9uLnNldFBvcyh0aGlzLCBvcHRzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBzZWxlY3Rpb24oJ3JlcGxhY2UnLCBvcHRzKVxuICAgICAgICAgICAgICAgICAqIHJlcGxhY2UgdGhlIHNlbGVjdGVkIHRleHRcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgIG9wdHMudGV4dCAgICAgICAgICAgIHJlcGxhY2VtZW50IHRleHRcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gICB7U3RyaW5nfSAgICBvcHRzLmNhcmV0ICAgICAgICAgICBjYXJldCBtb2RlOiBhbnkgb2YgdGhlIGZvbGxvd2luZzogXCJrZWVwXCIgfCBcInN0YXJ0XCIgfCBcImVuZFwiXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY2FzZSAncmVwbGFjZSc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfQ2FyZXRPcGVyYXRpb24ucmVwbGFjZSh0aGlzLCBvcHRzLnRleHQsIG9wdHMuY2FyZXQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIHNlbGVjdGlvbignaW5zZXJ0Jywgb3B0cylcbiAgICAgICAgICAgICAgICAgKiBpbnNlcnQgYmVmb3JlL2FmdGVyIHRoZSBzZWxlY3RlZCB0ZXh0XG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gICB7U3RyaW5nfSAgICBvcHRzLnRleHQgICAgICAgICAgICBpbnNlcnRpb24gdGV4dFxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgIG9wdHMuY2FyZXQgICAgICAgICAgIGNhcmV0IG1vZGU6IGFueSBvZiB0aGUgZm9sbG93aW5nOiBcImtlZXBcIiB8IFwic3RhcnRcIiB8IFwiZW5kXCJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gICB7U3RyaW5nfSAgICBvcHRzLm1vZGUgICAgICAgICAgICBpbnNlcnRpb24gbW9kZTogYW55IG9mIHRoZSBmb2xsb3dpbmc6IFwiYmVmb3JlXCIgfCBcImFmdGVyXCJcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjYXNlICdpbnNlcnQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMubW9kZSA9PSAnYmVmb3JlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9DYXJldE9wZXJhdGlvbi5pbnNlcnRCZWZvcmUodGhpcywgb3B0cy50ZXh0LCBvcHRzLmNhcmV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX0NhcmV0T3BlcmF0aW9uLmluc2VydEFmdGVyKHRoaXMsIG9wdHMudGV4dCwgb3B0cy5jYXJldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogc2VsZWN0aW9uKCdnZXQnKVxuICAgICAgICAgICAgICAgICAqIGdldCBzZWxlY3RlZCB0ZXh0XG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuICB7U3RyaW5nfSAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjYXNlICdnZXQnOlxuICAgICAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9DYXJldE9wZXJhdGlvbi5nZXRUZXh0KHRoaXNbMF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH0pO1xufSkoalF1ZXJ5LCB3aW5kb3csIHdpbmRvdy5kb2N1bWVudCk7XG4iLCIvKipcbiAqIFRpbWVhZ28gaXMgYSBqUXVlcnkgcGx1Z2luIHRoYXQgbWFrZXMgaXQgZWFzeSB0byBzdXBwb3J0IGF1dG9tYXRpY2FsbHlcbiAqIHVwZGF0aW5nIGZ1enp5IHRpbWVzdGFtcHMgKGUuZy4gXCI0IG1pbnV0ZXMgYWdvXCIgb3IgXCJhYm91dCAxIGRheSBhZ29cIikuXG4gKlxuICogQG5hbWUgdGltZWFnb1xuICogQHZlcnNpb24gMS4zLjBcbiAqIEByZXF1aXJlcyBqUXVlcnkgdjEuMi4zK1xuICogQGF1dGhvciBSeWFuIE1jR2VhcnlcbiAqIEBsaWNlbnNlIE1JVCBMaWNlbnNlIC0gaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAqXG4gKiBGb3IgdXNhZ2UgYW5kIGV4YW1wbGVzLCB2aXNpdDpcbiAqIGh0dHA6Ly90aW1lYWdvLnlhcnAuY29tL1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAwOC0yMDEzLCBSeWFuIE1jR2VhcnkgKHJ5YW4gLVthdF0tIG1jZ2VhcnkgWypkb3QqXSBvcmcpXG4gKi9cblxuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgZGVmaW5lKFsnanF1ZXJ5J10sIGZhY3RvcnkpO1xuICB9IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFsc1xuICAgIGZhY3RvcnkoalF1ZXJ5KTtcbiAgfVxufShmdW5jdGlvbiAoJCkge1xuICAkLnRpbWVhZ28gPSBmdW5jdGlvbih0aW1lc3RhbXApIHtcbiAgICBpZiAodGltZXN0YW1wIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuIGluV29yZHModGltZXN0YW1wKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aW1lc3RhbXAgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBpbldvcmRzKCQudGltZWFnby5wYXJzZSh0aW1lc3RhbXApKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aW1lc3RhbXAgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBpbldvcmRzKG5ldyBEYXRlKHRpbWVzdGFtcCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaW5Xb3JkcygkLnRpbWVhZ28uZGF0ZXRpbWUodGltZXN0YW1wKSk7XG4gICAgfVxuICB9O1xuICB2YXIgJHQgPSAkLnRpbWVhZ287XG5cbiAgJC5leHRlbmQoJC50aW1lYWdvLCB7XG4gICAgc2V0dGluZ3M6IHtcbiAgICAgIHJlZnJlc2hNaWxsaXM6IDYwMDAwLFxuICAgICAgYWxsb3dGdXR1cmU6IGZhbHNlLFxuICAgICAgbG9jYWxlVGl0bGU6IGZhbHNlLFxuICAgICAgY3V0b2ZmOiAwLFxuICAgICAgc3RyaW5nczoge1xuICAgICAgICBwcmVmaXhBZ286IG51bGwsXG4gICAgICAgIHByZWZpeEZyb21Ob3c6IG51bGwsXG4gICAgICAgIHN1ZmZpeEFnbzogXCJhZ29cIixcbiAgICAgICAgc3VmZml4RnJvbU5vdzogXCJmcm9tIG5vd1wiLFxuICAgICAgICBzZWNvbmRzOiBcImxlc3MgdGhhbiBhIG1pbnV0ZVwiLFxuICAgICAgICBtaW51dGU6IFwiYWJvdXQgYSBtaW51dGVcIixcbiAgICAgICAgbWludXRlczogXCIlZCBtaW51dGVzXCIsXG4gICAgICAgIGhvdXI6IFwiYWJvdXQgYW4gaG91clwiLFxuICAgICAgICBob3VyczogXCJhYm91dCAlZCBob3Vyc1wiLFxuICAgICAgICBkYXk6IFwiYSBkYXlcIixcbiAgICAgICAgZGF5czogXCIlZCBkYXlzXCIsXG4gICAgICAgIG1vbnRoOiBcImFib3V0IGEgbW9udGhcIixcbiAgICAgICAgbW9udGhzOiBcIiVkIG1vbnRoc1wiLFxuICAgICAgICB5ZWFyOiBcImFib3V0IGEgeWVhclwiLFxuICAgICAgICB5ZWFyczogXCIlZCB5ZWFyc1wiLFxuICAgICAgICB3b3JkU2VwYXJhdG9yOiBcIiBcIixcbiAgICAgICAgbnVtYmVyczogW11cbiAgICAgIH1cbiAgICB9LFxuICAgIGluV29yZHM6IGZ1bmN0aW9uKGRpc3RhbmNlTWlsbGlzKSB7XG4gICAgICB2YXIgJGwgPSB0aGlzLnNldHRpbmdzLnN0cmluZ3M7XG4gICAgICB2YXIgcHJlZml4ID0gJGwucHJlZml4QWdvO1xuICAgICAgdmFyIHN1ZmZpeCA9ICRsLnN1ZmZpeEFnbztcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmFsbG93RnV0dXJlKSB7XG4gICAgICAgIGlmIChkaXN0YW5jZU1pbGxpcyA8IDApIHtcbiAgICAgICAgICBwcmVmaXggPSAkbC5wcmVmaXhGcm9tTm93O1xuICAgICAgICAgIHN1ZmZpeCA9ICRsLnN1ZmZpeEZyb21Ob3c7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNlY29uZHMgPSBNYXRoLmFicyhkaXN0YW5jZU1pbGxpcykgLyAxMDAwO1xuICAgICAgdmFyIG1pbnV0ZXMgPSBzZWNvbmRzIC8gNjA7XG4gICAgICB2YXIgaG91cnMgPSBtaW51dGVzIC8gNjA7XG4gICAgICB2YXIgZGF5cyA9IGhvdXJzIC8gMjQ7XG4gICAgICB2YXIgeWVhcnMgPSBkYXlzIC8gMzY1O1xuXG4gICAgICBmdW5jdGlvbiBzdWJzdGl0dXRlKHN0cmluZ09yRnVuY3Rpb24sIG51bWJlcikge1xuICAgICAgICB2YXIgc3RyaW5nID0gJC5pc0Z1bmN0aW9uKHN0cmluZ09yRnVuY3Rpb24pID8gc3RyaW5nT3JGdW5jdGlvbihudW1iZXIsIGRpc3RhbmNlTWlsbGlzKSA6IHN0cmluZ09yRnVuY3Rpb247XG4gICAgICAgIHZhciB2YWx1ZSA9ICgkbC5udW1iZXJzICYmICRsLm51bWJlcnNbbnVtYmVyXSkgfHwgbnVtYmVyO1xuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoLyVkL2ksIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHdvcmRzID0gc2Vjb25kcyA8IDQ1ICYmIHN1YnN0aXR1dGUoJGwuc2Vjb25kcywgTWF0aC5yb3VuZChzZWNvbmRzKSkgfHxcbiAgICAgICAgc2Vjb25kcyA8IDkwICYmIHN1YnN0aXR1dGUoJGwubWludXRlLCAxKSB8fFxuICAgICAgICBtaW51dGVzIDwgNDUgJiYgc3Vic3RpdHV0ZSgkbC5taW51dGVzLCBNYXRoLnJvdW5kKG1pbnV0ZXMpKSB8fFxuICAgICAgICBtaW51dGVzIDwgOTAgJiYgc3Vic3RpdHV0ZSgkbC5ob3VyLCAxKSB8fFxuICAgICAgICBob3VycyA8IDI0ICYmIHN1YnN0aXR1dGUoJGwuaG91cnMsIE1hdGgucm91bmQoaG91cnMpKSB8fFxuICAgICAgICBob3VycyA8IDQyICYmIHN1YnN0aXR1dGUoJGwuZGF5LCAxKSB8fFxuICAgICAgICBkYXlzIDwgMzAgJiYgc3Vic3RpdHV0ZSgkbC5kYXlzLCBNYXRoLnJvdW5kKGRheXMpKSB8fFxuICAgICAgICBkYXlzIDwgNDUgJiYgc3Vic3RpdHV0ZSgkbC5tb250aCwgMSkgfHxcbiAgICAgICAgZGF5cyA8IDM2NSAmJiBzdWJzdGl0dXRlKCRsLm1vbnRocywgTWF0aC5yb3VuZChkYXlzIC8gMzApKSB8fFxuICAgICAgICB5ZWFycyA8IDEuNSAmJiBzdWJzdGl0dXRlKCRsLnllYXIsIDEpIHx8XG4gICAgICAgIHN1YnN0aXR1dGUoJGwueWVhcnMsIE1hdGgucm91bmQoeWVhcnMpKTtcblxuICAgICAgdmFyIHNlcGFyYXRvciA9ICRsLndvcmRTZXBhcmF0b3IgfHwgXCJcIjtcbiAgICAgIGlmICgkbC53b3JkU2VwYXJhdG9yID09PSB1bmRlZmluZWQpIHsgc2VwYXJhdG9yID0gXCIgXCI7IH1cbiAgICAgIHJldHVybiAkLnRyaW0oW3ByZWZpeCwgd29yZHMsIHN1ZmZpeF0uam9pbihzZXBhcmF0b3IpKTtcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbihpc284NjAxKSB7XG4gICAgICB2YXIgcyA9ICQudHJpbShpc284NjAxKTtcbiAgICAgIHMgPSBzLnJlcGxhY2UoL1xcLlxcZCsvLFwiXCIpOyAvLyByZW1vdmUgbWlsbGlzZWNvbmRzXG4gICAgICBzID0gcy5yZXBsYWNlKC8tLyxcIi9cIikucmVwbGFjZSgvLS8sXCIvXCIpO1xuICAgICAgcyA9IHMucmVwbGFjZSgvVC8sXCIgXCIpLnJlcGxhY2UoL1ovLFwiIFVUQ1wiKTtcbiAgICAgIHMgPSBzLnJlcGxhY2UoLyhbXFwrXFwtXVxcZFxcZClcXDo/KFxcZFxcZCkvLFwiICQxJDJcIik7IC8vIC0wNDowMCAtPiAtMDQwMFxuICAgICAgcmV0dXJuIG5ldyBEYXRlKHMpO1xuICAgIH0sXG4gICAgZGF0ZXRpbWU6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgIHZhciBpc284NjAxID0gJHQuaXNUaW1lKGVsZW0pID8gJChlbGVtKS5hdHRyKFwiZGF0ZXRpbWVcIikgOiAkKGVsZW0pLmF0dHIoXCJ0aXRsZVwiKTtcbiAgICAgIHJldHVybiAkdC5wYXJzZShpc284NjAxKTtcbiAgICB9LFxuICAgIGlzVGltZTogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgLy8galF1ZXJ5J3MgYGlzKClgIGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggSFRNTDUgaW4gSUVcbiAgICAgIHJldHVybiAkKGVsZW0pLmdldCgwKS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidGltZVwiOyAvLyAkKGVsZW0pLmlzKFwidGltZVwiKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSBjYWxsZWQgdmlhICQoZWwpLnRpbWVhZ28oJ2FjdGlvbicpXG4gIC8vIGluaXQgaXMgZGVmYXVsdCB3aGVuIG5vIGFjdGlvbiBpcyBnaXZlblxuICAvLyBmdW5jdGlvbnMgYXJlIGNhbGxlZCB3aXRoIGNvbnRleHQgb2YgYSBzaW5nbGUgZWxlbWVudFxuICB2YXIgZnVuY3Rpb25zID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgcmVmcmVzaF9lbCA9ICQucHJveHkocmVmcmVzaCwgdGhpcyk7XG4gICAgICByZWZyZXNoX2VsKCk7XG4gICAgICB2YXIgJHMgPSAkdC5zZXR0aW5ncztcbiAgICAgIGlmICgkcy5yZWZyZXNoTWlsbGlzID4gMCkge1xuICAgICAgICBzZXRJbnRlcnZhbChyZWZyZXNoX2VsLCAkcy5yZWZyZXNoTWlsbGlzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24odGltZSl7XG4gICAgICAkKHRoaXMpLmRhdGEoJ3RpbWVhZ28nLCB7IGRhdGV0aW1lOiAkdC5wYXJzZSh0aW1lKSB9KTtcbiAgICAgIHJlZnJlc2guYXBwbHkodGhpcyk7XG4gICAgfSxcbiAgICB1cGRhdGVGcm9tRE9NOiBmdW5jdGlvbigpe1xuICAgICAgJCh0aGlzKS5kYXRhKCd0aW1lYWdvJywgeyBkYXRldGltZTogJHQucGFyc2UoICR0LmlzVGltZSh0aGlzKSA/ICQodGhpcykuYXR0cihcImRhdGV0aW1lXCIpIDogJCh0aGlzKS5hdHRyKFwidGl0bGVcIikgKSB9KTtcbiAgICAgIHJlZnJlc2guYXBwbHkodGhpcyk7XG4gICAgfVxuICB9O1xuXG4gICQuZm4udGltZWFnbyA9IGZ1bmN0aW9uKGFjdGlvbiwgb3B0aW9ucykge1xuICAgIHZhciBmbiA9IGFjdGlvbiA/IGZ1bmN0aW9uc1thY3Rpb25dIDogZnVuY3Rpb25zLmluaXQ7XG4gICAgaWYoIWZuKXtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZnVuY3Rpb24gbmFtZSAnXCIrIGFjdGlvbiArXCInIGZvciB0aW1lYWdvXCIpO1xuICAgIH1cbiAgICAvLyBlYWNoIG92ZXIgb2JqZWN0cyBoZXJlIGFuZCBjYWxsIHRoZSByZXF1ZXN0ZWQgZnVuY3Rpb25cbiAgICB0aGlzLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgIGZuLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVmcmVzaCgpIHtcbiAgICB2YXIgZGF0YSA9IHByZXBhcmVEYXRhKHRoaXMpO1xuICAgIHZhciAkcyA9ICR0LnNldHRpbmdzO1xuXG4gICAgaWYgKCFpc05hTihkYXRhLmRhdGV0aW1lKSkge1xuICAgICAgaWYgKCAkcy5jdXRvZmYgPT0gMCB8fCBkaXN0YW5jZShkYXRhLmRhdGV0aW1lKSA8ICRzLmN1dG9mZikge1xuICAgICAgICAkKHRoaXMpLnRleHQoaW5Xb3JkcyhkYXRhLmRhdGV0aW1lKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZURhdGEoZWxlbWVudCkge1xuICAgIGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xuICAgIGlmICghZWxlbWVudC5kYXRhKFwidGltZWFnb1wiKSkge1xuICAgICAgZWxlbWVudC5kYXRhKFwidGltZWFnb1wiLCB7IGRhdGV0aW1lOiAkdC5kYXRldGltZShlbGVtZW50KSB9KTtcbiAgICAgIHZhciB0ZXh0ID0gJC50cmltKGVsZW1lbnQudGV4dCgpKTtcbiAgICAgIGlmICgkdC5zZXR0aW5ncy5sb2NhbGVUaXRsZSkge1xuICAgICAgICBlbGVtZW50LmF0dHIoXCJ0aXRsZVwiLCBlbGVtZW50LmRhdGEoJ3RpbWVhZ28nKS5kYXRldGltZS50b0xvY2FsZVN0cmluZygpKTtcbiAgICAgIH0gZWxzZSBpZiAodGV4dC5sZW5ndGggPiAwICYmICEoJHQuaXNUaW1lKGVsZW1lbnQpICYmIGVsZW1lbnQuYXR0cihcInRpdGxlXCIpKSkge1xuICAgICAgICBlbGVtZW50LmF0dHIoXCJ0aXRsZVwiLCB0ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQuZGF0YShcInRpbWVhZ29cIik7XG4gIH1cblxuICBmdW5jdGlvbiBpbldvcmRzKGRhdGUpIHtcbiAgICByZXR1cm4gJHQuaW5Xb3JkcyhkaXN0YW5jZShkYXRlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBkaXN0YW5jZShkYXRlKSB7XG4gICAgcmV0dXJuIChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIGRhdGUuZ2V0VGltZSgpKTtcbiAgfVxuXG4gIC8vIGZpeCBmb3IgSUU2IHN1Y2thZ2VcbiAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFiYnJcIik7XG4gIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0aW1lXCIpO1xufSkpO1xuIiwiLypnbG9iYWwgc2V0SW1tZWRpYXRlOiBmYWxzZSwgc2V0VGltZW91dDogZmFsc2UsIGNvbnNvbGU6IGZhbHNlICovXG4oZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGFzeW5jID0ge307XG5cbiAgICAvLyBnbG9iYWwgb24gdGhlIHNlcnZlciwgd2luZG93IGluIHRoZSBicm93c2VyXG4gICAgdmFyIHJvb3QsIHByZXZpb3VzX2FzeW5jO1xuXG4gICAgcm9vdCA9IHRoaXM7XG4gICAgaWYgKHJvb3QgIT0gbnVsbCkge1xuICAgICAgcHJldmlvdXNfYXN5bmMgPSByb290LmFzeW5jO1xuICAgIH1cblxuICAgIGFzeW5jLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJvb3QuYXN5bmMgPSBwcmV2aW91c19hc3luYztcbiAgICAgICAgcmV0dXJuIGFzeW5jO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBvbmx5X29uY2UoZm4pIHtcbiAgICAgICAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGVkKSB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsYmFjayB3YXMgYWxyZWFkeSBjYWxsZWQuXCIpO1xuICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZuLmFwcGx5KHJvb3QsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLy8vIGNyb3NzLWJyb3dzZXIgY29tcGF0aWJsaXR5IGZ1bmN0aW9ucyAvLy8vXG5cbiAgICB2YXIgX2VhY2ggPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvcikge1xuICAgICAgICBpZiAoYXJyLmZvckVhY2gpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnIuZm9yRWFjaChpdGVyYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKGFycltpXSwgaSwgYXJyKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgX21hcCA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yKSB7XG4gICAgICAgIGlmIChhcnIubWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyLm1hcChpdGVyYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgX2VhY2goYXJyLCBmdW5jdGlvbiAoeCwgaSwgYSkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGl0ZXJhdG9yKHgsIGksIGEpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG5cbiAgICB2YXIgX3JlZHVjZSA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBtZW1vKSB7XG4gICAgICAgIGlmIChhcnIucmVkdWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyLnJlZHVjZShpdGVyYXRvciwgbWVtbyk7XG4gICAgICAgIH1cbiAgICAgICAgX2VhY2goYXJyLCBmdW5jdGlvbiAoeCwgaSwgYSkge1xuICAgICAgICAgICAgbWVtbyA9IGl0ZXJhdG9yKG1lbW8sIHgsIGksIGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcblxuICAgIHZhciBfa2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9O1xuXG4gICAgLy8vLyBleHBvcnRlZCBhc3luYyBtb2R1bGUgZnVuY3Rpb25zIC8vLy9cblxuICAgIC8vLy8gbmV4dFRpY2sgaW1wbGVtZW50YXRpb24gd2l0aCBicm93c2VyLWNvbXBhdGlibGUgZmFsbGJhY2sgLy8vL1xuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHwgIShwcm9jZXNzLm5leHRUaWNrKSkge1xuICAgICAgICBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYXN5bmMubmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICAvLyBub3QgYSBkaXJlY3QgYWxpYXMgZm9yIElFMTAgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZShmbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlID0gYXN5bmMubmV4dFRpY2s7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhc3luYy5uZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZSA9IGFzeW5jLm5leHRUaWNrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhc3luYy5uZXh0VGljayA9IHByb2Nlc3MubmV4dFRpY2s7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgIC8vIG5vdCBhIGRpcmVjdCBhbGlhcyBmb3IgSUUxMCBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICAgIHNldEltbWVkaWF0ZShmbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlID0gYXN5bmMubmV4dFRpY2s7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYy5lYWNoID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIGlmICghYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbXBsZXRlZCA9IDA7XG4gICAgICAgIF9lYWNoKGFyciwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIG9ubHlfb25jZShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPj0gYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYXN5bmMuZm9yRWFjaCA9IGFzeW5jLmVhY2g7XG5cbiAgICBhc3luYy5lYWNoU2VyaWVzID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIGlmICghYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbXBsZXRlZCA9IDA7XG4gICAgICAgIHZhciBpdGVyYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaXRlcmF0b3IoYXJyW2NvbXBsZXRlZF0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpdGVyYXRlKCk7XG4gICAgfTtcbiAgICBhc3luYy5mb3JFYWNoU2VyaWVzID0gYXN5bmMuZWFjaFNlcmllcztcblxuICAgIGFzeW5jLmVhY2hMaW1pdCA9IGZ1bmN0aW9uIChhcnIsIGxpbWl0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGZuID0gX2VhY2hMaW1pdChsaW1pdCk7XG4gICAgICAgIGZuLmFwcGx5KG51bGwsIFthcnIsIGl0ZXJhdG9yLCBjYWxsYmFja10pO1xuICAgIH07XG4gICAgYXN5bmMuZm9yRWFjaExpbWl0ID0gYXN5bmMuZWFjaExpbWl0O1xuXG4gICAgdmFyIF9lYWNoTGltaXQgPSBmdW5jdGlvbiAobGltaXQpIHtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgaWYgKCFhcnIubGVuZ3RoIHx8IGxpbWl0IDw9IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb21wbGV0ZWQgPSAwO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ZWQgPSAwO1xuICAgICAgICAgICAgdmFyIHJ1bm5pbmcgPSAwO1xuXG4gICAgICAgICAgICAoZnVuY3Rpb24gcmVwbGVuaXNoICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkID49IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd2hpbGUgKHJ1bm5pbmcgPCBsaW1pdCAmJiBzdGFydGVkIDwgYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydGVkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5pbmcgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IoYXJyW3N0YXJ0ZWQgLSAxXSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmcgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkID49IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxlbmlzaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG5cbiAgICB2YXIgZG9QYXJhbGxlbCA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIFthc3luYy5lYWNoXS5jb25jYXQoYXJncykpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgdmFyIGRvUGFyYWxsZWxMaW1pdCA9IGZ1bmN0aW9uKGxpbWl0LCBmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIFtfZWFjaExpbWl0KGxpbWl0KV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBkb1NlcmllcyA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIFthc3luYy5lYWNoU2VyaWVzXS5jb25jYXQoYXJncykpO1xuICAgICAgICB9O1xuICAgIH07XG5cblxuICAgIHZhciBfYXN5bmNNYXAgPSBmdW5jdGlvbiAoZWFjaGZuLCBhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBhcnIgPSBfbWFwKGFyciwgZnVuY3Rpb24gKHgsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB7aW5kZXg6IGksIHZhbHVlOiB4fTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeC52YWx1ZSwgZnVuY3Rpb24gKGVyciwgdikge1xuICAgICAgICAgICAgICAgIHJlc3VsdHNbeC5pbmRleF0gPSB2O1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHRzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBhc3luYy5tYXAgPSBkb1BhcmFsbGVsKF9hc3luY01hcCk7XG4gICAgYXN5bmMubWFwU2VyaWVzID0gZG9TZXJpZXMoX2FzeW5jTWFwKTtcbiAgICBhc3luYy5tYXBMaW1pdCA9IGZ1bmN0aW9uIChhcnIsIGxpbWl0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIF9tYXBMaW1pdChsaW1pdCkoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICB2YXIgX21hcExpbWl0ID0gZnVuY3Rpb24obGltaXQpIHtcbiAgICAgICAgcmV0dXJuIGRvUGFyYWxsZWxMaW1pdChsaW1pdCwgX2FzeW5jTWFwKTtcbiAgICB9O1xuXG4gICAgLy8gcmVkdWNlIG9ubHkgaGFzIGEgc2VyaWVzIHZlcnNpb24sIGFzIGRvaW5nIHJlZHVjZSBpbiBwYXJhbGxlbCB3b24ndFxuICAgIC8vIHdvcmsgaW4gbWFueSBzaXR1YXRpb25zLlxuICAgIGFzeW5jLnJlZHVjZSA9IGZ1bmN0aW9uIChhcnIsIG1lbW8sIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBhc3luYy5lYWNoU2VyaWVzKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihtZW1vLCB4LCBmdW5jdGlvbiAoZXJyLCB2KSB7XG4gICAgICAgICAgICAgICAgbWVtbyA9IHY7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIG1lbW8pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIGluamVjdCBhbGlhc1xuICAgIGFzeW5jLmluamVjdCA9IGFzeW5jLnJlZHVjZTtcbiAgICAvLyBmb2xkbCBhbGlhc1xuICAgIGFzeW5jLmZvbGRsID0gYXN5bmMucmVkdWNlO1xuXG4gICAgYXN5bmMucmVkdWNlUmlnaHQgPSBmdW5jdGlvbiAoYXJyLCBtZW1vLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJldmVyc2VkID0gX21hcChhcnIsIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfSkucmV2ZXJzZSgpO1xuICAgICAgICBhc3luYy5yZWR1Y2UocmV2ZXJzZWQsIG1lbW8sIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICAvLyBmb2xkciBhbGlhc1xuICAgIGFzeW5jLmZvbGRyID0gYXN5bmMucmVkdWNlUmlnaHQ7XG5cbiAgICB2YXIgX2ZpbHRlciA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGFyciA9IF9tYXAoYXJyLCBmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHtpbmRleDogaSwgdmFsdWU6IHh9O1xuICAgICAgICB9KTtcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LnZhbHVlLCBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhfbWFwKHJlc3VsdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgICAgICAgICAgIH0pLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4LnZhbHVlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGFzeW5jLmZpbHRlciA9IGRvUGFyYWxsZWwoX2ZpbHRlcik7XG4gICAgYXN5bmMuZmlsdGVyU2VyaWVzID0gZG9TZXJpZXMoX2ZpbHRlcik7XG4gICAgLy8gc2VsZWN0IGFsaWFzXG4gICAgYXN5bmMuc2VsZWN0ID0gYXN5bmMuZmlsdGVyO1xuICAgIGFzeW5jLnNlbGVjdFNlcmllcyA9IGFzeW5jLmZpbHRlclNlcmllcztcblxuICAgIHZhciBfcmVqZWN0ID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgYXJyID0gX21hcChhcnIsIGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgICAgICAgICByZXR1cm4ge2luZGV4OiBpLCB2YWx1ZTogeH07XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgudmFsdWUsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhfbWFwKHJlc3VsdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgICAgICAgICAgIH0pLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4LnZhbHVlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGFzeW5jLnJlamVjdCA9IGRvUGFyYWxsZWwoX3JlamVjdCk7XG4gICAgYXN5bmMucmVqZWN0U2VyaWVzID0gZG9TZXJpZXMoX3JlamVjdCk7XG5cbiAgICB2YXIgX2RldGVjdCA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgaXRlcmF0b3IsIG1haW5fY2FsbGJhY2spIHtcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrKHgpO1xuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBtYWluX2NhbGxiYWNrKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYXN5bmMuZGV0ZWN0ID0gZG9QYXJhbGxlbChfZGV0ZWN0KTtcbiAgICBhc3luYy5kZXRlY3RTZXJpZXMgPSBkb1NlcmllcyhfZGV0ZWN0KTtcblxuICAgIGFzeW5jLnNvbWUgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgbWFpbl9jYWxsYmFjaykge1xuICAgICAgICBhc3luYy5lYWNoKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LCBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBtYWluX2NhbGxiYWNrKGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBhbnkgYWxpYXNcbiAgICBhc3luYy5hbnkgPSBhc3luYy5zb21lO1xuXG4gICAgYXN5bmMuZXZlcnkgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgbWFpbl9jYWxsYmFjaykge1xuICAgICAgICBhc3luYy5lYWNoKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LCBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIGlmICghdikge1xuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIG1haW5fY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gYWxsIGFsaWFzXG4gICAgYXN5bmMuYWxsID0gYXN5bmMuZXZlcnk7XG5cbiAgICBhc3luYy5zb3J0QnkgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgYXN5bmMubWFwKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LCBmdW5jdGlvbiAoZXJyLCBjcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHt2YWx1ZTogeCwgY3JpdGVyaWE6IGNyaXRlcmlhfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlc3VsdHMpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWEsIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgX21hcChyZXN1bHRzLnNvcnQoZm4pLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBhc3luYy5hdXRvID0gZnVuY3Rpb24gKHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICB2YXIga2V5cyA9IF9rZXlzKHRhc2tzKTtcbiAgICAgICAgaWYgKCFrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdHMgPSB7fTtcblxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gW107XG4gICAgICAgIHZhciBhZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgbGlzdGVuZXJzLnVuc2hpZnQoZm4pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpXSA9PT0gZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRhc2tDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF9lYWNoKGxpc3RlbmVycy5zbGljZSgwKSwgZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGFkZExpc3RlbmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfa2V5cyhyZXN1bHRzKS5sZW5ndGggPT09IGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgX2VhY2goa2V5cywgZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gKHRhc2tzW2tdIGluc3RhbmNlb2YgRnVuY3Rpb24pID8gW3Rhc2tzW2tdXTogdGFza3Nba107XG4gICAgICAgICAgICB2YXIgdGFza0NhbGxiYWNrID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2FmZVJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgX2VhY2goX2tleXMocmVzdWx0cyksIGZ1bmN0aW9uKHJrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhZmVSZXN1bHRzW3JrZXldID0gcmVzdWx0c1tya2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNhZmVSZXN1bHRzW2tdID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBzYWZlUmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3Agc3Vic2VxdWVudCBlcnJvcnMgaGl0dGluZyBjYWxsYmFjayBtdWx0aXBsZSB0aW1lc1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1trXSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZSh0YXNrQ29tcGxldGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgcmVxdWlyZXMgPSB0YXNrLnNsaWNlKDAsIE1hdGguYWJzKHRhc2subGVuZ3RoIC0gMSkpIHx8IFtdO1xuICAgICAgICAgICAgdmFyIHJlYWR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcmVkdWNlKHJlcXVpcmVzLCBmdW5jdGlvbiAoYSwgeCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGEgJiYgcmVzdWx0cy5oYXNPd25Qcm9wZXJ0eSh4KSk7XG4gICAgICAgICAgICAgICAgfSwgdHJ1ZSkgJiYgIXJlc3VsdHMuaGFzT3duUHJvcGVydHkoayk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHJlYWR5KCkpIHtcbiAgICAgICAgICAgICAgICB0YXNrW3Rhc2subGVuZ3RoIC0gMV0odGFza0NhbGxiYWNrLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlYWR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2tbdGFzay5sZW5ndGggLSAxXSh0YXNrQ2FsbGJhY2ssIHJlc3VsdHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBhZGRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBhc3luYy53YXRlcmZhbGwgPSBmdW5jdGlvbiAodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIGlmICh0YXNrcy5jb25zdHJ1Y3RvciAhPT0gQXJyYXkpIHtcbiAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCB0byB3YXRlcmZhbGwgbXVzdCBiZSBhbiBhcnJheSBvZiBmdW5jdGlvbnMnKTtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdyYXBJdGVyYXRvciA9IGZ1bmN0aW9uIChpdGVyYXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKHdyYXBJdGVyYXRvcihuZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRvci5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgd3JhcEl0ZXJhdG9yKGFzeW5jLml0ZXJhdG9yKHRhc2tzKSkoKTtcbiAgICB9O1xuXG4gICAgdmFyIF9wYXJhbGxlbCA9IGZ1bmN0aW9uKGVhY2hmbiwgdGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIGlmICh0YXNrcy5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbiAgICAgICAgICAgIGVhY2hmbi5tYXAodGFza3MsIGZ1bmN0aW9uIChmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgZm4oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwobnVsbCwgZXJyLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgIGVhY2hmbi5lYWNoKF9rZXlzKHRhc2tzKSwgZnVuY3Rpb24gKGssIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGFza3Nba10oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2tdID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYXN5bmMucGFyYWxsZWwgPSBmdW5jdGlvbiAodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIF9wYXJhbGxlbCh7IG1hcDogYXN5bmMubWFwLCBlYWNoOiBhc3luYy5lYWNoIH0sIHRhc2tzLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLnBhcmFsbGVsTGltaXQgPSBmdW5jdGlvbih0YXNrcywgbGltaXQsIGNhbGxiYWNrKSB7XG4gICAgICAgIF9wYXJhbGxlbCh7IG1hcDogX21hcExpbWl0KGxpbWl0KSwgZWFjaDogX2VhY2hMaW1pdChsaW1pdCkgfSwgdGFza3MsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMuc2VyaWVzID0gZnVuY3Rpb24gKHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICBpZiAodGFza3MuY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4gICAgICAgICAgICBhc3luYy5tYXBTZXJpZXModGFza3MsIGZ1bmN0aW9uIChmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgZm4oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwobnVsbCwgZXJyLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgIGFzeW5jLmVhY2hTZXJpZXMoX2tleXModGFza3MpLCBmdW5jdGlvbiAoaywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0YXNrc1trXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNba10gPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBhc3luYy5pdGVyYXRvciA9IGZ1bmN0aW9uICh0YXNrcykge1xuICAgICAgICB2YXIgbWFrZUNhbGxiYWNrID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrc1tpbmRleF0uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLm5leHQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmbi5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoaW5kZXggPCB0YXNrcy5sZW5ndGggLSAxKSA/IG1ha2VDYWxsYmFjayhpbmRleCArIDEpOiBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBmbjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG1ha2VDYWxsYmFjaygwKTtcbiAgICB9O1xuXG4gICAgYXN5bmMuYXBwbHkgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KFxuICAgICAgICAgICAgICAgIG51bGwsIGFyZ3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgX2NvbmNhdCA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgZm4sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByID0gW107XG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYikge1xuICAgICAgICAgICAgZm4oeCwgZnVuY3Rpb24gKGVyciwgeSkge1xuICAgICAgICAgICAgICAgIHIgPSByLmNvbmNhdCh5IHx8IFtdKTtcbiAgICAgICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYXN5bmMuY29uY2F0ID0gZG9QYXJhbGxlbChfY29uY2F0KTtcbiAgICBhc3luYy5jb25jYXRTZXJpZXMgPSBkb1NlcmllcyhfY29uY2F0KTtcblxuICAgIGFzeW5jLndoaWxzdCA9IGZ1bmN0aW9uICh0ZXN0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRlc3QoKSkge1xuICAgICAgICAgICAgaXRlcmF0b3IoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzeW5jLndoaWxzdCh0ZXN0LCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGFzeW5jLmRvV2hpbHN0ID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCB0ZXN0LCBjYWxsYmFjaykge1xuICAgICAgICBpdGVyYXRvcihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGVzdCgpKSB7XG4gICAgICAgICAgICAgICAgYXN5bmMuZG9XaGlsc3QoaXRlcmF0b3IsIHRlc3QsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBhc3luYy51bnRpbCA9IGZ1bmN0aW9uICh0ZXN0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCF0ZXN0KCkpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhc3luYy51bnRpbCh0ZXN0LCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGFzeW5jLmRvVW50aWwgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIHRlc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIGl0ZXJhdG9yKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGVzdCgpKSB7XG4gICAgICAgICAgICAgICAgYXN5bmMuZG9VbnRpbChpdGVyYXRvciwgdGVzdCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGFzeW5jLnF1ZXVlID0gZnVuY3Rpb24gKHdvcmtlciwgY29uY3VycmVuY3kpIHtcbiAgICAgICAgaWYgKGNvbmN1cnJlbmN5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbmN1cnJlbmN5ID0gMTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBfaW5zZXJ0KHEsIGRhdGEsIHBvcywgY2FsbGJhY2spIHtcbiAgICAgICAgICBpZihkYXRhLmNvbnN0cnVjdG9yICE9PSBBcnJheSkge1xuICAgICAgICAgICAgICBkYXRhID0gW2RhdGFdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfZWFjaChkYXRhLCBmdW5jdGlvbih0YXNrKSB7XG4gICAgICAgICAgICAgIHZhciBpdGVtID0ge1xuICAgICAgICAgICAgICAgICAgZGF0YTogdGFzayxcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBjYWxsYmFjayA6IG51bGxcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBpZiAocG9zKSB7XG4gICAgICAgICAgICAgICAgcS50YXNrcy51bnNoaWZ0KGl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHEudGFza3MucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChxLnNhdHVyYXRlZCAmJiBxLnRhc2tzLmxlbmd0aCA9PT0gY29uY3VycmVuY3kpIHtcbiAgICAgICAgICAgICAgICAgIHEuc2F0dXJhdGVkKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKHEucHJvY2Vzcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgd29ya2VycyA9IDA7XG4gICAgICAgIHZhciBxID0ge1xuICAgICAgICAgICAgdGFza3M6IFtdLFxuICAgICAgICAgICAgY29uY3VycmVuY3k6IGNvbmN1cnJlbmN5LFxuICAgICAgICAgICAgc2F0dXJhdGVkOiBudWxsLFxuICAgICAgICAgICAgZW1wdHk6IG51bGwsXG4gICAgICAgICAgICBkcmFpbjogbnVsbCxcbiAgICAgICAgICAgIHB1c2g6IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICBfaW5zZXJ0KHEsIGRhdGEsIGZhbHNlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5zaGlmdDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIF9pbnNlcnQocSwgZGF0YSwgdHJ1ZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAod29ya2VycyA8IHEuY29uY3VycmVuY3kgJiYgcS50YXNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhc2sgPSBxLnRhc2tzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxLmVtcHR5ICYmIHEudGFza3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxLmVtcHR5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd29ya2VycyArPSAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtlcnMgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXNrLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5jYWxsYmFjay5hcHBseSh0YXNrLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHEuZHJhaW4gJiYgcS50YXNrcy5sZW5ndGggKyB3b3JrZXJzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcS5kcmFpbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcS5wcm9jZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYiA9IG9ubHlfb25jZShuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgd29ya2VyKHRhc2suZGF0YSwgY2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsZW5ndGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcS50YXNrcy5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVubmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3b3JrZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcTtcbiAgICB9O1xuXG4gICAgYXN5bmMuY2FyZ28gPSBmdW5jdGlvbiAod29ya2VyLCBwYXlsb2FkKSB7XG4gICAgICAgIHZhciB3b3JraW5nICAgICA9IGZhbHNlLFxuICAgICAgICAgICAgdGFza3MgICAgICAgPSBbXTtcblxuICAgICAgICB2YXIgY2FyZ28gPSB7XG4gICAgICAgICAgICB0YXNrczogdGFza3MsXG4gICAgICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgICAgICAgc2F0dXJhdGVkOiBudWxsLFxuICAgICAgICAgICAgZW1wdHk6IG51bGwsXG4gICAgICAgICAgICBkcmFpbjogbnVsbCxcbiAgICAgICAgICAgIHB1c2g6IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmKGRhdGEuY29uc3RydWN0b3IgIT09IEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9lYWNoKGRhdGEsIGZ1bmN0aW9uKHRhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGFza3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB0YXNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IGNhbGxiYWNrIDogbnVsbFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhcmdvLnNhdHVyYXRlZCAmJiB0YXNrcy5sZW5ndGggPT09IHBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmdvLnNhdHVyYXRlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKGNhcmdvLnByb2Nlc3MpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uIHByb2Nlc3MoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdvcmtpbmcpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAodGFza3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGNhcmdvLmRyYWluKSBjYXJnby5kcmFpbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHRzID0gdHlwZW9mIHBheWxvYWQgPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0YXNrcy5zcGxpY2UoMCwgcGF5bG9hZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRhc2tzLnNwbGljZSgwKTtcblxuICAgICAgICAgICAgICAgIHZhciBkcyA9IF9tYXAodHMsIGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXNrLmRhdGE7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZihjYXJnby5lbXB0eSkgY2FyZ28uZW1wdHkoKTtcbiAgICAgICAgICAgICAgICB3b3JraW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB3b3JrZXIoZHMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya2luZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICBfZWFjaCh0cywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5jYWxsYmFjay5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcHJvY2VzcygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxlbmd0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXNrcy5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVubmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3b3JraW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2FyZ287XG4gICAgfTtcblxuICAgIHZhciBfY29uc29sZV9mbiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KFtmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29uc29sZVtuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2VhY2goYXJncywgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlW25hbWVdKHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSkpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgYXN5bmMubG9nID0gX2NvbnNvbGVfZm4oJ2xvZycpO1xuICAgIGFzeW5jLmRpciA9IF9jb25zb2xlX2ZuKCdkaXInKTtcbiAgICAvKmFzeW5jLmluZm8gPSBfY29uc29sZV9mbignaW5mbycpO1xuICAgIGFzeW5jLndhcm4gPSBfY29uc29sZV9mbignd2FybicpO1xuICAgIGFzeW5jLmVycm9yID0gX2NvbnNvbGVfZm4oJ2Vycm9yJyk7Ki9cblxuICAgIGFzeW5jLm1lbW9pemUgPSBmdW5jdGlvbiAoZm4sIGhhc2hlcikge1xuICAgICAgICB2YXIgbWVtbyA9IHt9O1xuICAgICAgICB2YXIgcXVldWVzID0ge307XG4gICAgICAgIGhhc2hlciA9IGhhc2hlciB8fCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgICB2YXIga2V5ID0gaGFzaGVyLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKGtleSBpbiBtZW1vKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgbWVtb1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSBpbiBxdWV1ZXMpIHtcbiAgICAgICAgICAgICAgICBxdWV1ZXNba2V5XS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHF1ZXVlc1trZXldID0gW2NhbGxiYWNrXTtcbiAgICAgICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzLmNvbmNhdChbZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBtZW1vW2tleV0gPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBxID0gcXVldWVzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBxdWV1ZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBxLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgIHFbaV0uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1dKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIG1lbW9pemVkLm1lbW8gPSBtZW1vO1xuICAgICAgICBtZW1vaXplZC51bm1lbW9pemVkID0gZm47XG4gICAgICAgIHJldHVybiBtZW1vaXplZDtcbiAgICB9O1xuXG4gICAgYXN5bmMudW5tZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKGZuLnVubWVtb2l6ZWQgfHwgZm4pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBhc3luYy50aW1lcyA9IGZ1bmN0aW9uIChjb3VudCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBjb3VudGVyID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgY291bnRlci5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3luYy5tYXAoY291bnRlciwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMudGltZXNTZXJpZXMgPSBmdW5jdGlvbiAoY291bnQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgY291bnRlciA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvdW50ZXIucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN5bmMubWFwU2VyaWVzKGNvdW50ZXIsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLmNvbXBvc2UgPSBmdW5jdGlvbiAoLyogZnVuY3Rpb25zLi4uICovKSB7XG4gICAgICAgIHZhciBmbnMgPSBBcnJheS5wcm90b3R5cGUucmV2ZXJzZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgYXN5bmMucmVkdWNlKGZucywgYXJncywgZnVuY3Rpb24gKG5ld2FyZ3MsIGZuLCBjYikge1xuICAgICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIG5ld2FyZ3MuY29uY2F0KFtmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgIGNiKGVyciwgbmV4dGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1dKSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZXJyLCByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodGhhdCwgW2Vycl0uY29uY2F0KHJlc3VsdHMpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgX2FwcGx5RWFjaCA9IGZ1bmN0aW9uIChlYWNoZm4sIGZucyAvKmFyZ3MuLi4qLykge1xuICAgICAgICB2YXIgZ28gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIGVhY2hmbihmbnMsIGZ1bmN0aW9uIChmbiwgY2IpIHtcbiAgICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBhcmdzLmNvbmNhdChbY2JdKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICAgICAgICAgIHJldHVybiBnby5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnbztcbiAgICAgICAgfVxuICAgIH07XG4gICAgYXN5bmMuYXBwbHlFYWNoID0gZG9QYXJhbGxlbChfYXBwbHlFYWNoKTtcbiAgICBhc3luYy5hcHBseUVhY2hTZXJpZXMgPSBkb1NlcmllcyhfYXBwbHlFYWNoKTtcblxuICAgIGFzeW5jLmZvcmV2ZXIgPSBmdW5jdGlvbiAoZm4sIGNhbGxiYWNrKSB7XG4gICAgICAgIGZ1bmN0aW9uIG5leHQoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbihuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgfTtcblxuICAgIC8vIEFNRCAvIFJlcXVpcmVKU1xuICAgIGlmICh0eXBlb2YgZGVmaW5lICE9PSAndW5kZWZpbmVkJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGFzeW5jO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gTm9kZS5qc1xuICAgIGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gYXN5bmM7XG4gICAgfVxuICAgIC8vIGluY2x1ZGVkIGRpcmVjdGx5IHZpYSA8c2NyaXB0PiB0YWdcbiAgICBlbHNlIHtcbiAgICAgICAgcm9vdC5hc3luYyA9IGFzeW5jO1xuICAgIH1cblxufSgpKTtcbiIsIihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xyXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcclxuICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cclxuICAgIGRlZmluZShbXSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gKHJvb3QucmV0dXJuRXhwb3J0c0dsb2JhbCA9IGZhY3RvcnkoKSk7XHJcbiAgICB9KTtcclxuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xyXG4gICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XHJcbiAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxyXG4gICAgLy8gbGlrZSBOb2RlLlxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJvb3RbJ0F1dG9saW5rZXInXSA9IGZhY3RvcnkoKTtcclxuICB9XHJcbn0odGhpcywgZnVuY3Rpb24gKCkge1xyXG5cclxuXHQvKiFcclxuXHQgKiBBdXRvbGlua2VyLmpzXHJcblx0ICogMC4xNS4yXHJcblx0ICpcclxuXHQgKiBDb3B5cmlnaHQoYykgMjAxNSBHcmVnb3J5IEphY29icyA8Z3JlZ0BncmVnLWphY29icy5jb20+XHJcblx0ICogTUlUIExpY2Vuc2VkLiBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdCAqXHJcblx0ICogaHR0cHM6Ly9naXRodWIuY29tL2dyZWdqYWNvYnMvQXV0b2xpbmtlci5qc1xyXG5cdCAqL1xyXG5cdC8qKlxyXG5cdCAqIEBjbGFzcyBBdXRvbGlua2VyXHJcblx0ICogQGV4dGVuZHMgT2JqZWN0XHJcblx0ICogXHJcblx0ICogVXRpbGl0eSBjbGFzcyB1c2VkIHRvIHByb2Nlc3MgYSBnaXZlbiBzdHJpbmcgb2YgdGV4dCwgYW5kIHdyYXAgdGhlIFVSTHMsIGVtYWlsIGFkZHJlc3NlcywgYW5kIFR3aXR0ZXIgaGFuZGxlcyBpbiBcclxuXHQgKiB0aGUgYXBwcm9wcmlhdGUgYW5jaG9yICgmbHQ7YSZndDspIHRhZ3MgdG8gdHVybiB0aGVtIGludG8gbGlua3MuXHJcblx0ICogXHJcblx0ICogQW55IG9mIHRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgbWF5IGJlIHByb3ZpZGVkIGluIGFuIE9iamVjdCAobWFwKSBwcm92aWRlZCB0byB0aGUgQXV0b2xpbmtlciBjb25zdHJ1Y3Rvciwgd2hpY2hcclxuXHQgKiB3aWxsIGNvbmZpZ3VyZSBob3cgdGhlIHtAbGluayAjbGluayBsaW5rKCl9IG1ldGhvZCB3aWxsIHByb2Nlc3MgdGhlIGxpbmtzLlxyXG5cdCAqIFxyXG5cdCAqIEZvciBleGFtcGxlOlxyXG5cdCAqIFxyXG5cdCAqICAgICB2YXIgYXV0b2xpbmtlciA9IG5ldyBBdXRvbGlua2VyKCB7XHJcblx0ICogICAgICAgICBuZXdXaW5kb3cgOiBmYWxzZSxcclxuXHQgKiAgICAgICAgIHRydW5jYXRlICA6IDMwXHJcblx0ICogICAgIH0gKTtcclxuXHQgKiAgICAgXHJcblx0ICogICAgIHZhciBodG1sID0gYXV0b2xpbmtlci5saW5rKCBcIkpvZSB3ZW50IHRvIHd3dy55YWhvby5jb21cIiApO1xyXG5cdCAqICAgICAvLyBwcm9kdWNlczogJ0pvZSB3ZW50IHRvIDxhIGhyZWY9XCJodHRwOi8vd3d3LnlhaG9vLmNvbVwiPnlhaG9vLmNvbTwvYT4nXHJcblx0ICogXHJcblx0ICogXHJcblx0ICogVGhlIHtAbGluayAjc3RhdGljLWxpbmsgc3RhdGljIGxpbmsoKX0gbWV0aG9kIG1heSBhbHNvIGJlIHVzZWQgdG8gaW5saW5lIG9wdGlvbnMgaW50byBhIHNpbmdsZSBjYWxsLCB3aGljaCBtYXlcclxuXHQgKiBiZSBtb3JlIGNvbnZlbmllbnQgZm9yIG9uZS1vZmYgdXNlcy4gRm9yIGV4YW1wbGU6XHJcblx0ICogXHJcblx0ICogICAgIHZhciBodG1sID0gQXV0b2xpbmtlci5saW5rKCBcIkpvZSB3ZW50IHRvIHd3dy55YWhvby5jb21cIiwge1xyXG5cdCAqICAgICAgICAgbmV3V2luZG93IDogZmFsc2UsXHJcblx0ICogICAgICAgICB0cnVuY2F0ZSAgOiAzMFxyXG5cdCAqICAgICB9ICk7XHJcblx0ICogICAgIC8vIHByb2R1Y2VzOiAnSm9lIHdlbnQgdG8gPGEgaHJlZj1cImh0dHA6Ly93d3cueWFob28uY29tXCI+eWFob28uY29tPC9hPidcclxuXHQgKiBcclxuXHQgKiBcclxuXHQgKiAjIyBDdXN0b20gUmVwbGFjZW1lbnRzIG9mIExpbmtzXHJcblx0ICogXHJcblx0ICogSWYgdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBkbyBub3QgcHJvdmlkZSBlbm91Z2ggZmxleGliaWxpdHksIGEge0BsaW5rICNyZXBsYWNlRm59IG1heSBiZSBwcm92aWRlZCB0byBmdWxseSBjdXN0b21pemVcclxuXHQgKiB0aGUgb3V0cHV0IG9mIEF1dG9saW5rZXIuIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9uY2UgZm9yIGVhY2ggVVJML0VtYWlsL1R3aXR0ZXIgaGFuZGxlIG1hdGNoIHRoYXQgaXMgZW5jb3VudGVyZWQuXHJcblx0ICogXHJcblx0ICogRm9yIGV4YW1wbGU6XHJcblx0ICogXHJcblx0ICogICAgIHZhciBpbnB1dCA9IFwiLi4uXCI7ICAvLyBzdHJpbmcgd2l0aCBVUkxzLCBFbWFpbCBBZGRyZXNzZXMsIGFuZCBUd2l0dGVyIEhhbmRsZXNcclxuXHQgKiAgICAgXHJcblx0ICogICAgIHZhciBsaW5rZWRUZXh0ID0gQXV0b2xpbmtlci5saW5rKCBpbnB1dCwge1xyXG5cdCAqICAgICAgICAgcmVwbGFjZUZuIDogZnVuY3Rpb24oIGF1dG9saW5rZXIsIG1hdGNoICkge1xyXG5cdCAqICAgICAgICAgICAgIGNvbnNvbGUubG9nKCBcImhyZWYgPSBcIiwgbWF0Y2guZ2V0QW5jaG9ySHJlZigpICk7XHJcblx0ICogICAgICAgICAgICAgY29uc29sZS5sb2coIFwidGV4dCA9IFwiLCBtYXRjaC5nZXRBbmNob3JUZXh0KCkgKTtcclxuXHQgKiAgICAgICAgIFxyXG5cdCAqICAgICAgICAgICAgIHN3aXRjaCggbWF0Y2guZ2V0VHlwZSgpICkge1xyXG5cdCAqICAgICAgICAgICAgICAgICBjYXNlICd1cmwnIDogXHJcblx0ICogICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyggXCJ1cmw6IFwiLCBtYXRjaC5nZXRVcmwoKSApO1xyXG5cdCAqICAgICAgICAgICAgICAgICAgICAgXHJcblx0ICogICAgICAgICAgICAgICAgICAgICBpZiggbWF0Y2guZ2V0VXJsKCkuaW5kZXhPZiggJ215c2l0ZS5jb20nICkgPT09IC0xICkge1xyXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YWcgPSBhdXRvbGlua2VyLmdldFRhZ0J1aWxkZXIoKS5idWlsZCggbWF0Y2ggKTsgIC8vIHJldHVybnMgYW4gYEF1dG9saW5rZXIuSHRtbFRhZ2AgaW5zdGFuY2UsIHdoaWNoIHByb3ZpZGVzIG11dGF0b3IgbWV0aG9kcyBmb3IgZWFzeSBjaGFuZ2VzXHJcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgdGFnLnNldEF0dHIoICdyZWwnLCAnbm9mb2xsb3cnICk7XHJcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgdGFnLmFkZENsYXNzKCAnZXh0ZXJuYWwtbGluaycgKTtcclxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICBcclxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFnO1xyXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG5cdCAqICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgIC8vIGxldCBBdXRvbGlua2VyIHBlcmZvcm0gaXRzIG5vcm1hbCBhbmNob3IgdGFnIHJlcGxhY2VtZW50XHJcblx0ICogICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICogICAgICAgICAgICAgICAgICAgICBcclxuXHQgKiAgICAgICAgICAgICAgICAgY2FzZSAnZW1haWwnIDpcclxuXHQgKiAgICAgICAgICAgICAgICAgICAgIHZhciBlbWFpbCA9IG1hdGNoLmdldEVtYWlsKCk7XHJcblx0ICogICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyggXCJlbWFpbDogXCIsIGVtYWlsICk7XHJcblx0ICogICAgICAgICAgICAgICAgICAgICBcclxuXHQgKiAgICAgICAgICAgICAgICAgICAgIGlmKCBlbWFpbCA9PT0gXCJteUBvd24uYWRkcmVzc1wiICkge1xyXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgIC8vIGRvbid0IGF1dG8tbGluayB0aGlzIHBhcnRpY3VsYXIgZW1haWwgYWRkcmVzczsgbGVhdmUgYXMtaXNcclxuXHQgKiAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAgLy8gbm8gcmV0dXJuIHZhbHVlIHdpbGwgaGF2ZSBBdXRvbGlua2VyIHBlcmZvcm0gaXRzIG5vcm1hbCBhbmNob3IgdGFnIHJlcGxhY2VtZW50IChzYW1lIGFzIHJldHVybmluZyBgdHJ1ZWApXHJcblx0ICogICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICogICAgICAgICAgICAgICAgIFxyXG5cdCAqICAgICAgICAgICAgICAgICBjYXNlICd0d2l0dGVyJyA6XHJcblx0ICogICAgICAgICAgICAgICAgICAgICB2YXIgdHdpdHRlckhhbmRsZSA9IG1hdGNoLmdldFR3aXR0ZXJIYW5kbGUoKTtcclxuXHQgKiAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCB0d2l0dGVySGFuZGxlICk7XHJcblx0ICogICAgICAgICAgICAgICAgICAgICBcclxuXHQgKiAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnPGEgaHJlZj1cImh0dHA6Ly9uZXdwbGFjZS50by5saW5rLnR3aXR0ZXIuaGFuZGxlcy50by9cIj4nICsgdHdpdHRlckhhbmRsZSArICc8L2E+JztcclxuXHQgKiAgICAgICAgICAgICB9XHJcblx0ICogICAgICAgICB9XHJcblx0ICogICAgIH0gKTtcclxuXHQgKiBcclxuXHQgKiBcclxuXHQgKiBUaGUgZnVuY3Rpb24gbWF5IHJldHVybiB0aGUgZm9sbG93aW5nIHZhbHVlczpcclxuXHQgKiBcclxuXHQgKiAtIGB0cnVlYCAoQm9vbGVhbik6IEFsbG93IEF1dG9saW5rZXIgdG8gcmVwbGFjZSB0aGUgbWF0Y2ggYXMgaXQgbm9ybWFsbHkgd291bGQuXHJcblx0ICogLSBgZmFsc2VgIChCb29sZWFuKTogRG8gbm90IHJlcGxhY2UgdGhlIGN1cnJlbnQgbWF0Y2ggYXQgYWxsIC0gbGVhdmUgYXMtaXMuXHJcblx0ICogLSBBbnkgU3RyaW5nOiBJZiBhIHN0cmluZyBpcyByZXR1cm5lZCBmcm9tIHRoZSBmdW5jdGlvbiwgdGhlIHN0cmluZyB3aWxsIGJlIHVzZWQgZGlyZWN0bHkgYXMgdGhlIHJlcGxhY2VtZW50IEhUTUwgZm9yXHJcblx0ICogICB0aGUgbWF0Y2guXHJcblx0ICogLSBBbiB7QGxpbmsgQXV0b2xpbmtlci5IdG1sVGFnfSBpbnN0YW5jZSwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gYnVpbGQvbW9kaWZ5IGFuIEhUTUwgdGFnIGJlZm9yZSB3cml0aW5nIG91dCBpdHMgSFRNTCB0ZXh0LlxyXG5cdCAqIFxyXG5cdCAqIEBjb25zdHJ1Y3RvclxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgQXV0b2xpbmtlciBpbnN0YW5jZSwgc3BlY2lmaWVkIGluIGFuIE9iamVjdCAobWFwKS5cclxuXHQgKi9cclxuXHR2YXIgQXV0b2xpbmtlciA9IGZ1bmN0aW9uKCBjZmcgKSB7XHJcblx0XHRBdXRvbGlua2VyLlV0aWwuYXNzaWduKCB0aGlzLCBjZmcgKTsgIC8vIGFzc2lnbiB0aGUgcHJvcGVydGllcyBvZiBgY2ZnYCBvbnRvIHRoZSBBdXRvbGlua2VyIGluc3RhbmNlLiBQcm90b3R5cGUgcHJvcGVydGllcyB3aWxsIGJlIHVzZWQgZm9yIG1pc3NpbmcgY29uZmlncy5cclxuXHJcblx0XHR0aGlzLm1hdGNoVmFsaWRhdG9yID0gbmV3IEF1dG9saW5rZXIuTWF0Y2hWYWxpZGF0b3IoKTtcclxuXHR9O1xyXG5cclxuXHJcblx0QXV0b2xpbmtlci5wcm90b3R5cGUgPSB7XHJcblx0XHRjb25zdHJ1Y3RvciA6IEF1dG9saW5rZXIsICAvLyBmaXggY29uc3RydWN0b3IgcHJvcGVydHlcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEBjZmcge0Jvb2xlYW59IHVybHNcclxuXHRcdCAqIFxyXG5cdFx0ICogYHRydWVgIGlmIG1pc2NlbGxhbmVvdXMgVVJMcyBzaG91bGQgYmUgYXV0b21hdGljYWxseSBsaW5rZWQsIGBmYWxzZWAgaWYgdGhleSBzaG91bGQgbm90IGJlLlxyXG5cdFx0ICovXHJcblx0XHR1cmxzIDogdHJ1ZSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEBjZmcge0Jvb2xlYW59IGVtYWlsXHJcblx0XHQgKiBcclxuXHRcdCAqIGB0cnVlYCBpZiBlbWFpbCBhZGRyZXNzZXMgc2hvdWxkIGJlIGF1dG9tYXRpY2FsbHkgbGlua2VkLCBgZmFsc2VgIGlmIHRoZXkgc2hvdWxkIG5vdCBiZS5cclxuXHRcdCAqL1xyXG5cdFx0ZW1haWwgOiB0cnVlLFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQGNmZyB7Qm9vbGVhbn0gdHdpdHRlclxyXG5cdFx0ICogXHJcblx0XHQgKiBgdHJ1ZWAgaWYgVHdpdHRlciBoYW5kbGVzIChcIkBleGFtcGxlXCIpIHNob3VsZCBiZSBhdXRvbWF0aWNhbGx5IGxpbmtlZCwgYGZhbHNlYCBpZiB0aGV5IHNob3VsZCBub3QgYmUuXHJcblx0XHQgKi9cclxuXHRcdHR3aXR0ZXIgOiB0cnVlLFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQGNmZyB7Qm9vbGVhbn0gbmV3V2luZG93XHJcblx0XHQgKiBcclxuXHRcdCAqIGB0cnVlYCBpZiB0aGUgbGlua3Mgc2hvdWxkIG9wZW4gaW4gYSBuZXcgd2luZG93LCBgZmFsc2VgIG90aGVyd2lzZS5cclxuXHRcdCAqL1xyXG5cdFx0bmV3V2luZG93IDogdHJ1ZSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEBjZmcge0Jvb2xlYW59IHN0cmlwUHJlZml4XHJcblx0XHQgKiBcclxuXHRcdCAqIGB0cnVlYCBpZiAnaHR0cDovLycgb3IgJ2h0dHBzOi8vJyBhbmQvb3IgdGhlICd3d3cuJyBzaG91bGQgYmUgc3RyaXBwZWQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIFVSTCBsaW5rcycgdGV4dCwgXHJcblx0XHQgKiBgZmFsc2VgIG90aGVyd2lzZS5cclxuXHRcdCAqL1xyXG5cdFx0c3RyaXBQcmVmaXggOiB0cnVlLFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQGNmZyB7TnVtYmVyfSB0cnVuY2F0ZVxyXG5cdFx0ICogXHJcblx0XHQgKiBBIG51bWJlciBmb3IgaG93IG1hbnkgY2hhcmFjdGVycyBsb25nIFVSTHMvZW1haWxzL3R3aXR0ZXIgaGFuZGxlcyBzaG91bGQgYmUgdHJ1bmNhdGVkIHRvIGluc2lkZSB0aGUgdGV4dCBvZiBcclxuXHRcdCAqIGEgbGluay4gSWYgdGhlIFVSTC9lbWFpbC90d2l0dGVyIGlzIG92ZXIgdGhpcyBudW1iZXIgb2YgY2hhcmFjdGVycywgaXQgd2lsbCBiZSB0cnVuY2F0ZWQgdG8gdGhpcyBsZW5ndGggYnkgXHJcblx0XHQgKiBhZGRpbmcgYSB0d28gcGVyaW9kIGVsbGlwc2lzICgnLi4nKSB0byB0aGUgZW5kIG9mIHRoZSBzdHJpbmcuXHJcblx0XHQgKiBcclxuXHRcdCAqIEZvciBleGFtcGxlOiBBIHVybCBsaWtlICdodHRwOi8vd3d3LnlhaG9vLmNvbS9zb21lL2xvbmcvcGF0aC90by9hL2ZpbGUnIHRydW5jYXRlZCB0byAyNSBjaGFyYWN0ZXJzIG1pZ2h0IGxvb2tcclxuXHRcdCAqIHNvbWV0aGluZyBsaWtlIHRoaXM6ICd5YWhvby5jb20vc29tZS9sb25nL3BhdC4uJ1xyXG5cdFx0ICovXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBAY2ZnIHtTdHJpbmd9IGNsYXNzTmFtZVxyXG5cdFx0ICogXHJcblx0XHQgKiBBIENTUyBjbGFzcyBuYW1lIHRvIGFkZCB0byB0aGUgZ2VuZXJhdGVkIGxpbmtzLiBUaGlzIGNsYXNzIHdpbGwgYmUgYWRkZWQgdG8gYWxsIGxpbmtzLCBhcyB3ZWxsIGFzIHRoaXMgY2xhc3NcclxuXHRcdCAqIHBsdXMgdXJsL2VtYWlsL3R3aXR0ZXIgc3VmZml4ZXMgZm9yIHN0eWxpbmcgdXJsL2VtYWlsL3R3aXR0ZXIgbGlua3MgZGlmZmVyZW50bHkuXHJcblx0XHQgKiBcclxuXHRcdCAqIEZvciBleGFtcGxlLCBpZiB0aGlzIGNvbmZpZyBpcyBwcm92aWRlZCBhcyBcIm15TGlua1wiLCB0aGVuOlxyXG5cdFx0ICogXHJcblx0XHQgKiAtIFVSTCBsaW5rcyB3aWxsIGhhdmUgdGhlIENTUyBjbGFzc2VzOiBcIm15TGluayBteUxpbmstdXJsXCJcclxuXHRcdCAqIC0gRW1haWwgbGlua3Mgd2lsbCBoYXZlIHRoZSBDU1MgY2xhc3NlczogXCJteUxpbmsgbXlMaW5rLWVtYWlsXCIsIGFuZFxyXG5cdFx0ICogLSBUd2l0dGVyIGxpbmtzIHdpbGwgaGF2ZSB0aGUgQ1NTIGNsYXNzZXM6IFwibXlMaW5rIG15TGluay10d2l0dGVyXCJcclxuXHRcdCAqL1xyXG5cdFx0Y2xhc3NOYW1lIDogXCJcIixcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEBjZmcge0Z1bmN0aW9ufSByZXBsYWNlRm5cclxuXHRcdCAqIFxyXG5cdFx0ICogQSBmdW5jdGlvbiB0byBpbmRpdmlkdWFsbHkgcHJvY2VzcyBlYWNoIFVSTC9FbWFpbC9Ud2l0dGVyIG1hdGNoIGZvdW5kIGluIHRoZSBpbnB1dCBzdHJpbmcuXHJcblx0XHQgKiBcclxuXHRcdCAqIFNlZSB0aGUgY2xhc3MncyBkZXNjcmlwdGlvbiBmb3IgdXNhZ2UuXHJcblx0XHQgKiBcclxuXHRcdCAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxyXG5cdFx0ICogXHJcblx0XHQgKiBAY2ZnIHtBdXRvbGlua2VyfSByZXBsYWNlRm4uYXV0b2xpbmtlciBUaGUgQXV0b2xpbmtlciBpbnN0YW5jZSwgd2hpY2ggbWF5IGJlIHVzZWQgdG8gcmV0cmlldmUgY2hpbGQgb2JqZWN0cyBmcm9tIChzdWNoXHJcblx0XHQgKiAgIGFzIHRoZSBpbnN0YW5jZSdzIHtAbGluayAjZ2V0VGFnQnVpbGRlciB0YWcgYnVpbGRlcn0pLlxyXG5cdFx0ICogQGNmZyB7QXV0b2xpbmtlci5tYXRjaC5NYXRjaH0gcmVwbGFjZUZuLm1hdGNoIFRoZSBNYXRjaCBpbnN0YW5jZSB3aGljaCBjYW4gYmUgdXNlZCB0byByZXRyaWV2ZSBpbmZvcm1hdGlvbiBhYm91dCB0aGVcclxuXHRcdCAqICAge0BsaW5rIEF1dG9saW5rZXIubWF0Y2guVXJsIFVSTH0ve0BsaW5rIEF1dG9saW5rZXIubWF0Y2guRW1haWwgZW1haWx9L3tAbGluayBBdXRvbGlua2VyLm1hdGNoLlR3aXR0ZXIgVHdpdHRlcn1cclxuXHRcdCAqICAgbWF0Y2ggdGhhdCB0aGUgYHJlcGxhY2VGbmAgaXMgY3VycmVudGx5IHByb2Nlc3NpbmcuXHJcblx0XHQgKi9cclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHByb3BlcnR5IHtSZWdFeHB9IGh0bWxDaGFyYWN0ZXJFbnRpdGllc1JlZ2V4XHJcblx0XHQgKlxyXG5cdFx0ICogVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IG1hdGNoZXMgY29tbW9uIEhUTUwgY2hhcmFjdGVyIGVudGl0aWVzLlxyXG5cdFx0ICogXHJcblx0XHQgKiBJZ25vcmluZyAmYW1wOyBhcyBpdCBjb3VsZCBiZSBwYXJ0IG9mIGEgcXVlcnkgc3RyaW5nIC0tIGhhbmRsaW5nIGl0IHNlcGFyYXRlbHkuXHJcblx0XHQgKi9cclxuXHRcdGh0bWxDaGFyYWN0ZXJFbnRpdGllc1JlZ2V4OiAvKCZuYnNwO3wmIzE2MDt8Jmx0O3wmIzYwO3wmZ3Q7fCYjNjI7fCZxdW90O3wmIzM0O3wmIzM5OykvZ2ksXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHByb3BlcnR5IHtSZWdFeHB9IG1hdGNoZXJSZWdleFxyXG5cdFx0ICogXHJcblx0XHQgKiBUaGUgcmVndWxhciBleHByZXNzaW9uIHRoYXQgbWF0Y2hlcyBVUkxzLCBlbWFpbCBhZGRyZXNzZXMsIGFuZCBUd2l0dGVyIGhhbmRsZXMuXHJcblx0XHQgKiBcclxuXHRcdCAqIFRoaXMgcmVndWxhciBleHByZXNzaW9uIGhhcyB0aGUgZm9sbG93aW5nIGNhcHR1cmluZyBncm91cHM6XHJcblx0XHQgKiBcclxuXHRcdCAqIDEuIEdyb3VwIHRoYXQgaXMgdXNlZCB0byBkZXRlcm1pbmUgaWYgdGhlcmUgaXMgYSBUd2l0dGVyIGhhbmRsZSBtYXRjaCAoaS5lLiBcXEBzb21lVHdpdHRlclVzZXIpLiBTaW1wbHkgY2hlY2sgZm9yIGl0cyBcclxuXHRcdCAqICAgIGV4aXN0ZW5jZSB0byBkZXRlcm1pbmUgaWYgdGhlcmUgaXMgYSBUd2l0dGVyIGhhbmRsZSBtYXRjaC4gVGhlIG5leHQgY291cGxlIG9mIGNhcHR1cmluZyBncm91cHMgZ2l2ZSBpbmZvcm1hdGlvbiBcclxuXHRcdCAqICAgIGFib3V0IHRoZSBUd2l0dGVyIGhhbmRsZSBtYXRjaC5cclxuXHRcdCAqIDIuIFRoZSB3aGl0ZXNwYWNlIGNoYXJhY3RlciBiZWZvcmUgdGhlIFxcQHNpZ24gaW4gYSBUd2l0dGVyIGhhbmRsZS4gVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSB0aGVyZSBhcmUgbm8gbG9va2JlaGluZHMgaW5cclxuXHRcdCAqICAgIEpTIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGFuZCBjYW4gYmUgdXNlZCB0byByZWNvbnN0cnVjdCB0aGUgb3JpZ2luYWwgc3RyaW5nIGluIGEgcmVwbGFjZSgpLlxyXG5cdFx0ICogMy4gVGhlIFR3aXR0ZXIgaGFuZGxlIGl0c2VsZiBpbiBhIFR3aXR0ZXIgbWF0Y2guIElmIHRoZSBtYXRjaCBpcyAnQHNvbWVUd2l0dGVyVXNlcicsIHRoZSBoYW5kbGUgaXMgJ3NvbWVUd2l0dGVyVXNlcicuXHJcblx0XHQgKiA0LiBHcm91cCB0aGF0IG1hdGNoZXMgYW4gZW1haWwgYWRkcmVzcy4gVXNlZCB0byBkZXRlcm1pbmUgaWYgdGhlIG1hdGNoIGlzIGFuIGVtYWlsIGFkZHJlc3MsIGFzIHdlbGwgYXMgaG9sZGluZyB0aGUgZnVsbCBcclxuXHRcdCAqICAgIGFkZHJlc3MuIEV4OiAnbWVAbXkuY29tJ1xyXG5cdFx0ICogNS4gR3JvdXAgdGhhdCBtYXRjaGVzIGEgVVJMIGluIHRoZSBpbnB1dCB0ZXh0LiBFeDogJ2h0dHA6Ly9nb29nbGUuY29tJywgJ3d3dy5nb29nbGUuY29tJywgb3IganVzdCAnZ29vZ2xlLmNvbScuXHJcblx0XHQgKiAgICBUaGlzIGFsc28gaW5jbHVkZXMgYSBwYXRoLCB1cmwgcGFyYW1ldGVycywgb3IgaGFzaCBhbmNob3JzLiBFeDogZ29vZ2xlLmNvbS9wYXRoL3RvL2ZpbGU/cTE9MSZxMj0yI215QW5jaG9yXHJcblx0XHQgKiA2LiBHcm91cCB0aGF0IG1hdGNoZXMgYSBwcm90b2NvbCBVUkwgKGkuZS4gJ2h0dHA6Ly9nb29nbGUuY29tJykuIFRoaXMgaXMgdXNlZCB0byBtYXRjaCBwcm90b2NvbCBVUkxzIHdpdGgganVzdCBhIHNpbmdsZVxyXG5cdFx0ICogICAgd29yZCwgbGlrZSAnaHR0cDovL2xvY2FsaG9zdCcsIHdoZXJlIHdlIHdvbid0IGRvdWJsZSBjaGVjayB0aGF0IHRoZSBkb21haW4gbmFtZSBoYXMgYXQgbGVhc3Qgb25lICcuJyBpbiBpdC5cclxuXHRcdCAqIDcuIEEgcHJvdG9jb2wtcmVsYXRpdmUgKCcvLycpIG1hdGNoIGZvciB0aGUgY2FzZSBvZiBhICd3d3cuJyBwcmVmaXhlZCBVUkwuIFdpbGwgYmUgYW4gZW1wdHkgc3RyaW5nIGlmIGl0IGlzIG5vdCBhIFxyXG5cdFx0ICogICAgcHJvdG9jb2wtcmVsYXRpdmUgbWF0Y2guIFdlIG5lZWQgdG8ga25vdyB0aGUgY2hhcmFjdGVyIGJlZm9yZSB0aGUgJy8vJyBpbiBvcmRlciB0byBkZXRlcm1pbmUgaWYgaXQgaXMgYSB2YWxpZCBtYXRjaFxyXG5cdFx0ICogICAgb3IgdGhlIC8vIHdhcyBpbiBhIHN0cmluZyB3ZSBkb24ndCB3YW50IHRvIGF1dG8tbGluay5cclxuXHRcdCAqIDguIEEgcHJvdG9jb2wtcmVsYXRpdmUgKCcvLycpIG1hdGNoIGZvciB0aGUgY2FzZSBvZiBhIGtub3duIFRMRCBwcmVmaXhlZCBVUkwuIFdpbGwgYmUgYW4gZW1wdHkgc3RyaW5nIGlmIGl0IGlzIG5vdCBhIFxyXG5cdFx0ICogICAgcHJvdG9jb2wtcmVsYXRpdmUgbWF0Y2guIFNlZSAjNiBmb3IgbW9yZSBpbmZvLiBcclxuXHRcdCAqL1xyXG5cdFx0bWF0Y2hlclJlZ2V4IDogKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR2YXIgdHdpdHRlclJlZ2V4ID0gLyhefFteXFx3XSlAKFxcd3sxLDE1fSkvLCAgICAgICAgICAgICAgLy8gRm9yIG1hdGNoaW5nIGEgdHdpdHRlciBoYW5kbGUuIEV4OiBAZ3JlZ29yeV9qYWNvYnNcclxuXHJcblx0XHRcdCAgICBlbWFpbFJlZ2V4ID0gLyg/OltcXC07OiY9XFwrXFwkLFxcd1xcLl0rQCkvLCAgICAgICAgICAgICAvLyBzb21ldGhpbmdAIGZvciBlbWFpbCBhZGRyZXNzZXMgKGEuay5hLiBsb2NhbC1wYXJ0KVxyXG5cclxuXHRcdFx0ICAgIHByb3RvY29sUmVnZXggPSAvKD86W0EtWmEtel1bLS4rQS1aYS16MC05XSs6KD8hW0EtWmEtel1bLS4rQS1aYS16MC05XSs6XFwvXFwvKSg/IVxcZCtcXC8/KSg/OlxcL1xcLyk/KS8sICAvLyBtYXRjaCBwcm90b2NvbCwgYWxsb3cgaW4gZm9ybWF0IFwiaHR0cDovL1wiIG9yIFwibWFpbHRvOlwiLiBIb3dldmVyLCBkbyBub3QgbWF0Y2ggdGhlIGZpcnN0IHBhcnQgb2Ygc29tZXRoaW5nIGxpa2UgJ2xpbms6aHR0cDovL3d3dy5nb29nbGUuY29tJyAoaS5lLiBkb24ndCBtYXRjaCBcImxpbms6XCIpLiBBbHNvLCBtYWtlIHN1cmUgd2UgZG9uJ3QgaW50ZXJwcmV0ICdnb29nbGUuY29tOjgwMDAnIGFzIGlmICdnb29nbGUuY29tJyB3YXMgYSBwcm90b2NvbCBoZXJlIChpLmUuIGlnbm9yZSBhIHRyYWlsaW5nIHBvcnQgbnVtYmVyIGluIHRoaXMgcmVnZXgpXHJcblx0XHRcdCAgICB3d3dSZWdleCA9IC8oPzp3d3dcXC4pLywgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0aW5nIHdpdGggJ3d3dy4nXHJcblx0XHRcdCAgICBkb21haW5OYW1lUmVnZXggPSAvW0EtWmEtejAtOVxcLlxcLV0qW0EtWmEtejAtOVxcLV0vLCAgLy8gYW55dGhpbmcgbG9va2luZyBhdCBhbGwgbGlrZSBhIGRvbWFpbiwgbm9uLXVuaWNvZGUgZG9tYWlucywgbm90IGVuZGluZyBpbiBhIHBlcmlvZFxyXG5cdFx0XHQgICAgdGxkUmVnZXggPSAvXFwuKD86aW50ZXJuYXRpb25hbHxjb25zdHJ1Y3Rpb258Y29udHJhY3RvcnN8ZW50ZXJwcmlzZXN8cGhvdG9ncmFwaHl8cHJvZHVjdGlvbnN8Zm91bmRhdGlvbnxpbW1vYmlsaWVufGluZHVzdHJpZXN8bWFuYWdlbWVudHxwcm9wZXJ0aWVzfHRlY2hub2xvZ3l8Y2hyaXN0bWFzfGNvbW11bml0eXxkaXJlY3Rvcnl8ZWR1Y2F0aW9ufGVxdWlwbWVudHxpbnN0aXR1dGV8bWFya2V0aW5nfHNvbHV0aW9uc3x2YWNhdGlvbnN8YmFyZ2FpbnN8Ym91dGlxdWV8YnVpbGRlcnN8Y2F0ZXJpbmd8Y2xlYW5pbmd8Y2xvdGhpbmd8Y29tcHV0ZXJ8ZGVtb2NyYXR8ZGlhbW9uZHN8Z3JhcGhpY3N8aG9sZGluZ3N8bGlnaHRpbmd8cGFydG5lcnN8cGx1bWJpbmd8c3VwcGxpZXN8dHJhaW5pbmd8dmVudHVyZXN8YWNhZGVteXxjYXJlZXJzfGNvbXBhbnl8Y3J1aXNlc3xkb21haW5zfGV4cG9zZWR8ZmxpZ2h0c3xmbG9yaXN0fGdhbGxlcnl8Z3VpdGFyc3xob2xpZGF5fGtpdGNoZW58bmV1c3Rhcnxva2luYXdhfHJlY2lwZXN8cmVudGFsc3xyZXZpZXdzfHNoaWtzaGF8c2luZ2xlc3xzdXBwb3J0fHN5c3RlbXN8YWdlbmN5fGJlcmxpbnxjYW1lcmF8Y2VudGVyfGNvZmZlZXxjb25kb3N8ZGF0aW5nfGVzdGF0ZXxldmVudHN8ZXhwZXJ0fGZ1dGJvbHxrYXVmZW58bHV4dXJ5fG1haXNvbnxtb25hc2h8bXVzZXVtfG5hZ295YXxwaG90b3N8cmVwYWlyfHJlcG9ydHxzb2NpYWx8c3VwcGx5fHRhdHRvb3x0aWVuZGF8dHJhdmVsfHZpYWplc3x2aWxsYXN8dmlzaW9ufHZvdGluZ3x2b3lhZ2V8YWN0b3J8YnVpbGR8Y2FyZHN8Y2hlYXB8Y29kZXN8ZGFuY2V8ZW1haWx8Z2xhc3N8aG91c2V8bWFuZ298bmluamF8cGFydHN8cGhvdG98c2hvZXN8c29sYXJ8dG9kYXl8dG9reW98dG9vbHN8d2F0Y2h8d29ya3N8YWVyb3xhcnBhfGFzaWF8YmVzdHxiaWtlfGJsdWV8YnV6enxjYW1wfGNsdWJ8Y29vbHxjb29wfGZhcm18ZmlzaHxnaWZ0fGd1cnV8aW5mb3xqb2JzfGtpd2l8a3JlZHxsYW5kfGxpbW98bGlua3xtZW51fG1vYml8bW9kYXxuYW1lfHBpY3N8cGlua3xwb3N0fHFwb258cmljaHxydWhyfHNleHl8dGlwc3x2b3RlfHZvdG98d2FuZ3x3aWVufHdpa2l8em9uZXxiYXJ8YmlkfGJpenxjYWJ8Y2F0fGNlb3xjb218ZWR1fGdvdnxpbnR8a2ltfG1pbHxuZXR8b25sfG9yZ3xwcm98cHVifHJlZHx0ZWx8dW5vfHdlZHx4eHh8eHl6fGFjfGFkfGFlfGFmfGFnfGFpfGFsfGFtfGFufGFvfGFxfGFyfGFzfGF0fGF1fGF3fGF4fGF6fGJhfGJifGJkfGJlfGJmfGJnfGJofGJpfGJqfGJtfGJufGJvfGJyfGJzfGJ0fGJ2fGJ3fGJ5fGJ6fGNhfGNjfGNkfGNmfGNnfGNofGNpfGNrfGNsfGNtfGNufGNvfGNyfGN1fGN2fGN3fGN4fGN5fGN6fGRlfGRqfGRrfGRtfGRvfGR6fGVjfGVlfGVnfGVyfGVzfGV0fGV1fGZpfGZqfGZrfGZtfGZvfGZyfGdhfGdifGdkfGdlfGdmfGdnfGdofGdpfGdsfGdtfGdufGdwfGdxfGdyfGdzfGd0fGd1fGd3fGd5fGhrfGhtfGhufGhyfGh0fGh1fGlkfGllfGlsfGltfGlufGlvfGlxfGlyfGlzfGl0fGplfGptfGpvfGpwfGtlfGtnfGtofGtpfGttfGtufGtwfGtyfGt3fGt5fGt6fGxhfGxifGxjfGxpfGxrfGxyfGxzfGx0fGx1fGx2fGx5fG1hfG1jfG1kfG1lfG1nfG1ofG1rfG1sfG1tfG1ufG1vfG1wfG1xfG1yfG1zfG10fG11fG12fG13fG14fG15fG16fG5hfG5jfG5lfG5mfG5nfG5pfG5sfG5vfG5wfG5yfG51fG56fG9tfHBhfHBlfHBmfHBnfHBofHBrfHBsfHBtfHBufHByfHBzfHB0fHB3fHB5fHFhfHJlfHJvfHJzfHJ1fHJ3fHNhfHNifHNjfHNkfHNlfHNnfHNofHNpfHNqfHNrfHNsfHNtfHNufHNvfHNyfHN0fHN1fHN2fHN4fHN5fHN6fHRjfHRkfHRmfHRnfHRofHRqfHRrfHRsfHRtfHRufHRvfHRwfHRyfHR0fHR2fHR3fHR6fHVhfHVnfHVrfHVzfHV5fHV6fHZhfHZjfHZlfHZnfHZpfHZufHZ1fHdmfHdzfHllfHl0fHphfHptfHp3KVxcYi8sICAgLy8gbWF0Y2ggb3VyIGtub3duIHRvcCBsZXZlbCBkb21haW5zIChUTERzKVxyXG5cclxuXHRcdFx0ICAgIC8vIEFsbG93IG9wdGlvbmFsIHBhdGgsIHF1ZXJ5IHN0cmluZywgYW5kIGhhc2ggYW5jaG9yLCBub3QgZW5kaW5nIGluIHRoZSBmb2xsb3dpbmcgY2hhcmFjdGVyczogXCI/ITosLjtcIlxyXG5cdFx0XHQgICAgLy8gaHR0cDovL2Jsb2cuY29kaW5naG9ycm9yLmNvbS90aGUtcHJvYmxlbS13aXRoLXVybHMvXHJcblx0XHRcdCAgICB1cmxTdWZmaXhSZWdleCA9IC9bXFwtQS1aYS16MC05KyZAI1xcLyU9fl8oKXwnJCpcXFtcXF0/ITosLjtdKltcXC1BLVphLXowLTkrJkAjXFwvJT1+XygpfCckKlxcW1xcXV0vO1xyXG5cclxuXHRcdFx0cmV0dXJuIG5ldyBSZWdFeHAoIFtcclxuXHRcdFx0XHQnKCcsICAvLyAqKiogQ2FwdHVyaW5nIGdyb3VwICQxLCB3aGljaCBjYW4gYmUgdXNlZCB0byBjaGVjayBmb3IgYSB0d2l0dGVyIGhhbmRsZSBtYXRjaC4gVXNlIGdyb3VwICQzIGZvciB0aGUgYWN0dWFsIHR3aXR0ZXIgaGFuZGxlIHRob3VnaC4gJDIgbWF5IGJlIHVzZWQgdG8gcmVjb25zdHJ1Y3QgdGhlIG9yaWdpbmFsIHN0cmluZyBpbiBhIHJlcGxhY2UoKSBcclxuXHRcdFx0XHRcdC8vICoqKiBDYXB0dXJpbmcgZ3JvdXAgJDIsIHdoaWNoIG1hdGNoZXMgdGhlIHdoaXRlc3BhY2UgY2hhcmFjdGVyIGJlZm9yZSB0aGUgJ0AnIHNpZ24gKG5lZWRlZCBiZWNhdXNlIG9mIG5vIGxvb2tiZWhpbmRzKSwgYW5kIFxyXG5cdFx0XHRcdFx0Ly8gKioqIENhcHR1cmluZyBncm91cCAkMywgd2hpY2ggbWF0Y2hlcyB0aGUgYWN0dWFsIHR3aXR0ZXIgaGFuZGxlXHJcblx0XHRcdFx0XHR0d2l0dGVyUmVnZXguc291cmNlLFxyXG5cdFx0XHRcdCcpJyxcclxuXHJcblx0XHRcdFx0J3wnLFxyXG5cclxuXHRcdFx0XHQnKCcsICAvLyAqKiogQ2FwdHVyaW5nIGdyb3VwICQ0LCB3aGljaCBpcyB1c2VkIHRvIGRldGVybWluZSBhbiBlbWFpbCBtYXRjaFxyXG5cdFx0XHRcdFx0ZW1haWxSZWdleC5zb3VyY2UsXHJcblx0XHRcdFx0XHRkb21haW5OYW1lUmVnZXguc291cmNlLFxyXG5cdFx0XHRcdFx0dGxkUmVnZXguc291cmNlLFxyXG5cdFx0XHRcdCcpJyxcclxuXHJcblx0XHRcdFx0J3wnLFxyXG5cclxuXHRcdFx0XHQnKCcsICAvLyAqKiogQ2FwdHVyaW5nIGdyb3VwICQ1LCB3aGljaCBpcyB1c2VkIHRvIG1hdGNoIGEgVVJMXHJcblx0XHRcdFx0XHQnKD86JywgLy8gcGFyZW5zIHRvIGNvdmVyIG1hdGNoIGZvciBwcm90b2NvbCAob3B0aW9uYWwpLCBhbmQgZG9tYWluXHJcblx0XHRcdFx0XHRcdCcoJywgIC8vICoqKiBDYXB0dXJpbmcgZ3JvdXAgJDYsIGZvciBhIHByb3RvY29sLXByZWZpeGVkIHVybCAoZXg6IGh0dHA6Ly9nb29nbGUuY29tKVxyXG5cdFx0XHRcdFx0XHRcdHByb3RvY29sUmVnZXguc291cmNlLFxyXG5cdFx0XHRcdFx0XHRcdGRvbWFpbk5hbWVSZWdleC5zb3VyY2UsXHJcblx0XHRcdFx0XHRcdCcpJyxcclxuXHJcblx0XHRcdFx0XHRcdCd8JyxcclxuXHJcblx0XHRcdFx0XHRcdCcoPzonLCAgLy8gbm9uLWNhcHR1cmluZyBwYXJlbiBmb3IgYSAnd3d3LicgcHJlZml4ZWQgdXJsIChleDogd3d3Lmdvb2dsZS5jb20pXHJcblx0XHRcdFx0XHRcdFx0JyguPy8vKT8nLCAgLy8gKioqIENhcHR1cmluZyBncm91cCAkNyBmb3IgYW4gb3B0aW9uYWwgcHJvdG9jb2wtcmVsYXRpdmUgVVJMLiBNdXN0IGJlIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHN0cmluZyBvciBzdGFydCB3aXRoIGEgbm9uLXdvcmQgY2hhcmFjdGVyXHJcblx0XHRcdFx0XHRcdFx0d3d3UmVnZXguc291cmNlLFxyXG5cdFx0XHRcdFx0XHRcdGRvbWFpbk5hbWVSZWdleC5zb3VyY2UsXHJcblx0XHRcdFx0XHRcdCcpJyxcclxuXHJcblx0XHRcdFx0XHRcdCd8JyxcclxuXHJcblx0XHRcdFx0XHRcdCcoPzonLCAgLy8gbm9uLWNhcHR1cmluZyBwYXJlbiBmb3Iga25vd24gYSBUTEQgdXJsIChleDogZ29vZ2xlLmNvbSlcclxuXHRcdFx0XHRcdFx0XHQnKC4/Ly8pPycsICAvLyAqKiogQ2FwdHVyaW5nIGdyb3VwICQ4IGZvciBhbiBvcHRpb25hbCBwcm90b2NvbC1yZWxhdGl2ZSBVUkwuIE11c3QgYmUgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgc3RyaW5nIG9yIHN0YXJ0IHdpdGggYSBub24td29yZCBjaGFyYWN0ZXJcclxuXHRcdFx0XHRcdFx0XHRkb21haW5OYW1lUmVnZXguc291cmNlLFxyXG5cdFx0XHRcdFx0XHRcdHRsZFJlZ2V4LnNvdXJjZSxcclxuXHRcdFx0XHRcdFx0JyknLFxyXG5cdFx0XHRcdFx0JyknLFxyXG5cclxuXHRcdFx0XHRcdCcoPzonICsgdXJsU3VmZml4UmVnZXguc291cmNlICsgJyk/JywgIC8vIG1hdGNoIGZvciBwYXRoLCBxdWVyeSBzdHJpbmcsIGFuZC9vciBoYXNoIGFuY2hvciAtIG9wdGlvbmFsXHJcblx0XHRcdFx0JyknXHJcblx0XHRcdF0uam9pbiggXCJcIiApLCAnZ2knICk7XHJcblx0XHR9ICkoKSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAcHJvcGVydHkge1JlZ0V4cH0gY2hhckJlZm9yZVByb3RvY29sUmVsTWF0Y2hSZWdleFxyXG5cdFx0ICogXHJcblx0XHQgKiBUaGUgcmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gcmV0cmlldmUgdGhlIGNoYXJhY3RlciBiZWZvcmUgYSBwcm90b2NvbC1yZWxhdGl2ZSBVUkwgbWF0Y2guXHJcblx0XHQgKiBcclxuXHRcdCAqIFRoaXMgaXMgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSB7QGxpbmsgI21hdGNoZXJSZWdleH0sIHdoaWNoIG5lZWRzIHRvIGdyYWIgdGhlIGNoYXJhY3RlciBiZWZvcmUgYSBwcm90b2NvbC1yZWxhdGl2ZVxyXG5cdFx0ICogJy8vJyBkdWUgdG8gdGhlIGxhY2sgb2YgYSBuZWdhdGl2ZSBsb29rLWJlaGluZCBpbiBKYXZhU2NyaXB0IHJlZ3VsYXIgZXhwcmVzc2lvbnMuIFRoZSBjaGFyYWN0ZXIgYmVmb3JlIHRoZSBtYXRjaCBpcyBzdHJpcHBlZFxyXG5cdFx0ICogZnJvbSB0aGUgVVJMLlxyXG5cdFx0ICovXHJcblx0XHRjaGFyQmVmb3JlUHJvdG9jb2xSZWxNYXRjaFJlZ2V4IDogL14oLik/XFwvXFwvLyxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAcHJvcGVydHkge0F1dG9saW5rZXIuTWF0Y2hWYWxpZGF0b3J9IG1hdGNoVmFsaWRhdG9yXHJcblx0XHQgKiBcclxuXHRcdCAqIFRoZSBNYXRjaFZhbGlkYXRvciBvYmplY3QsIHVzZWQgdG8gZmlsdGVyIG91dCBhbnkgZmFsc2UgcG9zaXRpdmVzIGZyb20gdGhlIHtAbGluayAjbWF0Y2hlclJlZ2V4fS4gU2VlXHJcblx0XHQgKiB7QGxpbmsgQXV0b2xpbmtlci5NYXRjaFZhbGlkYXRvcn0gZm9yIGRldGFpbHMuXHJcblx0XHQgKi9cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAcHJvcGVydHkge0F1dG9saW5rZXIuSHRtbFBhcnNlcn0gaHRtbFBhcnNlclxyXG5cdFx0ICogXHJcblx0XHQgKiBUaGUgSHRtbFBhcnNlciBpbnN0YW5jZSB1c2VkIHRvIHNraXAgb3ZlciBIVE1MIHRhZ3MsIHdoaWxlIGZpbmRpbmcgdGV4dCBub2RlcyB0byBwcm9jZXNzLiBUaGlzIGlzIGxhemlseSBpbnN0YW50aWF0ZWRcclxuXHRcdCAqIGluIHRoZSB7QGxpbmsgI2dldEh0bWxQYXJzZXJ9IG1ldGhvZC5cclxuXHRcdCAqL1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEBwcm9wZXJ0eSB7QXV0b2xpbmtlci5BbmNob3JUYWdCdWlsZGVyfSB0YWdCdWlsZGVyXHJcblx0XHQgKiBcclxuXHRcdCAqIFRoZSBBbmNob3JUYWdCdWlsZGVyIGluc3RhbmNlIHVzZWQgdG8gYnVpbGQgdGhlIFVSTC9lbWFpbC9Ud2l0dGVyIHJlcGxhY2VtZW50IGFuY2hvciB0YWdzLiBUaGlzIGlzIGxhemlseSBpbnN0YW50aWF0ZWRcclxuXHRcdCAqIGluIHRoZSB7QGxpbmsgI2dldFRhZ0J1aWxkZXJ9IG1ldGhvZC5cclxuXHRcdCAqL1xyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEF1dG9tYXRpY2FsbHkgbGlua3MgVVJMcywgZW1haWwgYWRkcmVzc2VzLCBhbmQgVHdpdHRlciBoYW5kbGVzIGZvdW5kIGluIHRoZSBnaXZlbiBjaHVuayBvZiBIVE1MLiBcclxuXHRcdCAqIERvZXMgbm90IGxpbmsgVVJMcyBmb3VuZCB3aXRoaW4gSFRNTCB0YWdzLlxyXG5cdFx0ICogXHJcblx0XHQgKiBGb3IgaW5zdGFuY2UsIGlmIGdpdmVuIHRoZSB0ZXh0OiBgWW91IHNob3VsZCBnbyB0byBodHRwOi8vd3d3LnlhaG9vLmNvbWAsIHRoZW4gdGhlIHJlc3VsdFxyXG5cdFx0ICogd2lsbCBiZSBgWW91IHNob3VsZCBnbyB0byAmbHQ7YSBocmVmPVwiaHR0cDovL3d3dy55YWhvby5jb21cIiZndDtodHRwOi8vd3d3LnlhaG9vLmNvbSZsdDsvYSZndDtgXHJcblx0XHQgKiBcclxuXHRcdCAqIFRoaXMgbWV0aG9kIGZpbmRzIHRoZSB0ZXh0IGFyb3VuZCBhbnkgSFRNTCBlbGVtZW50cyBpbiB0aGUgaW5wdXQgYHRleHRPckh0bWxgLCB3aGljaCB3aWxsIGJlIHRoZSB0ZXh0IHRoYXQgaXMgcHJvY2Vzc2VkLlxyXG5cdFx0ICogQW55IG9yaWdpbmFsIEhUTUwgZWxlbWVudHMgd2lsbCBiZSBsZWZ0IGFzLWlzLCBhcyB3ZWxsIGFzIHRoZSB0ZXh0IHRoYXQgaXMgYWxyZWFkeSB3cmFwcGVkIGluIGFuY2hvciAoJmx0O2EmZ3Q7KSB0YWdzLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dE9ySHRtbCBUaGUgSFRNTCBvciB0ZXh0IHRvIGxpbmsgVVJMcywgZW1haWwgYWRkcmVzc2VzLCBhbmQgVHdpdHRlciBoYW5kbGVzIHdpdGhpbiAoZGVwZW5kaW5nIG9uIGlmXHJcblx0XHQgKiAgIHRoZSB7QGxpbmsgI3VybHN9LCB7QGxpbmsgI2VtYWlsfSwgYW5kIHtAbGluayAjdHdpdHRlcn0gb3B0aW9ucyBhcmUgZW5hYmxlZCkuXHJcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBIVE1MLCB3aXRoIFVSTHMvZW1haWxzL1R3aXR0ZXIgaGFuZGxlcyBhdXRvbWF0aWNhbGx5IGxpbmtlZC5cclxuXHRcdCAqL1xyXG5cdFx0bGluayA6IGZ1bmN0aW9uKCB0ZXh0T3JIdG1sICkge1xyXG5cdFx0XHR2YXIgbWUgPSB0aGlzLCAgLy8gZm9yIGNsb3N1cmVcclxuXHRcdFx0ICAgIGh0bWxQYXJzZXIgPSB0aGlzLmdldEh0bWxQYXJzZXIoKSxcclxuXHRcdFx0ICAgIGh0bWxDaGFyYWN0ZXJFbnRpdGllc1JlZ2V4ID0gdGhpcy5odG1sQ2hhcmFjdGVyRW50aXRpZXNSZWdleCxcclxuXHRcdFx0ICAgIGFuY2hvclRhZ1N0YWNrQ291bnQgPSAwLCAgLy8gdXNlZCB0byBvbmx5IHByb2Nlc3MgdGV4dCBhcm91bmQgYW5jaG9yIHRhZ3MsIGFuZCBhbnkgaW5uZXIgdGV4dC9odG1sIHRoZXkgbWF5IGhhdmVcclxuXHRcdFx0ICAgIHJlc3VsdEh0bWwgPSBbXTtcclxuXHJcblx0XHRcdGh0bWxQYXJzZXIucGFyc2UoIHRleHRPckh0bWwsIHtcclxuXHRcdFx0XHQvLyBQcm9jZXNzIEhUTUwgbm9kZXMgaW4gdGhlIGlucHV0IGB0ZXh0T3JIdG1sYFxyXG5cdFx0XHRcdHByb2Nlc3NIdG1sTm9kZSA6IGZ1bmN0aW9uKCB0YWdUZXh0LCB0YWdOYW1lLCBpc0Nsb3NpbmdUYWcgKSB7XHJcblx0XHRcdFx0XHRpZiggdGFnTmFtZSA9PT0gJ2EnICkge1xyXG5cdFx0XHRcdFx0XHRpZiggIWlzQ2xvc2luZ1RhZyApIHsgIC8vIGl0J3MgdGhlIHN0YXJ0IDxhPiB0YWdcclxuXHRcdFx0XHRcdFx0XHRhbmNob3JUYWdTdGFja0NvdW50Kys7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7ICAgLy8gaXQncyB0aGUgZW5kIDwvYT4gdGFnXHJcblx0XHRcdFx0XHRcdFx0YW5jaG9yVGFnU3RhY2tDb3VudCA9IE1hdGgubWF4KCBhbmNob3JUYWdTdGFja0NvdW50IC0gMSwgMCApOyAgLy8gYXR0ZW1wdCB0byBoYW5kbGUgZXh0cmFuZW91cyA8L2E+IHRhZ3MgYnkgbWFraW5nIHN1cmUgdGhlIHN0YWNrIGNvdW50IG5ldmVyIGdvZXMgYmVsb3cgMFxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXN1bHRIdG1sLnB1c2goIHRhZ1RleHQgKTsgIC8vIG5vdyBhZGQgdGhlIHRleHQgb2YgdGhlIHRhZyBpdHNlbGYgdmVyYmF0aW1cclxuXHRcdFx0XHR9LFxyXG5cclxuXHRcdFx0XHQvLyBQcm9jZXNzIHRleHQgbm9kZXMgaW4gdGhlIGlucHV0IGB0ZXh0T3JIdG1sYFxyXG5cdFx0XHRcdHByb2Nlc3NUZXh0Tm9kZSA6IGZ1bmN0aW9uKCB0ZXh0ICkge1xyXG5cdFx0XHRcdFx0aWYoIGFuY2hvclRhZ1N0YWNrQ291bnQgPT09IDAgKSB7XHJcblx0XHRcdFx0XHRcdC8vIElmIHdlJ3JlIG5vdCB3aXRoaW4gYW4gPGE+IHRhZywgcHJvY2VzcyB0aGUgdGV4dCBub2RlXHJcblx0XHRcdFx0XHRcdHZhciB1bmVzY2FwZWRUZXh0ID0gQXV0b2xpbmtlci5VdGlsLnNwbGl0QW5kQ2FwdHVyZSggdGV4dCwgaHRtbENoYXJhY3RlckVudGl0aWVzUmVnZXggKTsgIC8vIHNwbGl0IGF0IEhUTUwgZW50aXRpZXMsIGJ1dCBpbmNsdWRlIHRoZSBIVE1MIGVudGl0aWVzIGluIHRoZSByZXN1bHRzIGFycmF5XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGxlbiA9IHVuZXNjYXBlZFRleHQubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIHRleHRUb1Byb2Nlc3MgPSB1bmVzY2FwZWRUZXh0WyBpIF0sXHJcblx0XHRcdFx0XHRcdFx0ICAgIHByb2Nlc3NlZFRleHROb2RlID0gbWUucHJvY2Vzc1RleHROb2RlKCB0ZXh0VG9Qcm9jZXNzICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHJlc3VsdEh0bWwucHVzaCggcHJvY2Vzc2VkVGV4dE5vZGUgKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdC8vIGB0ZXh0YCBpcyB3aXRoaW4gYW4gPGE+IHRhZywgc2ltcGx5IGFwcGVuZCB0aGUgdGV4dCAtIHdlIGRvIG5vdCB3YW50IHRvIGF1dG9saW5rIGFueXRoaW5nIFxyXG5cdFx0XHRcdFx0XHQvLyBhbHJlYWR5IHdpdGhpbiBhbiA8YT4uLi48L2E+IHRhZ1xyXG5cdFx0XHRcdFx0XHRyZXN1bHRIdG1sLnB1c2goIHRleHQgKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gKTtcclxuXHJcblx0XHRcdHJldHVybiByZXN1bHRIdG1sLmpvaW4oIFwiXCIgKTtcclxuXHRcdH0sXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogTGF6aWx5IGluc3RhbnRpYXRlcyBhbmQgcmV0dXJucyB0aGUge0BsaW5rICNodG1sUGFyc2VyfSBpbnN0YW5jZSBmb3IgdGhpcyBBdXRvbGlua2VyIGluc3RhbmNlLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcHJvdGVjdGVkXHJcblx0XHQgKiBAcmV0dXJuIHtBdXRvbGlua2VyLkh0bWxQYXJzZXJ9XHJcblx0XHQgKi9cclxuXHRcdGdldEh0bWxQYXJzZXIgOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0dmFyIGh0bWxQYXJzZXIgPSB0aGlzLmh0bWxQYXJzZXI7XHJcblxyXG5cdFx0XHRpZiggIWh0bWxQYXJzZXIgKSB7XHJcblx0XHRcdFx0aHRtbFBhcnNlciA9IHRoaXMuaHRtbFBhcnNlciA9IG5ldyBBdXRvbGlua2VyLkh0bWxQYXJzZXIoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGh0bWxQYXJzZXI7XHJcblx0XHR9LFxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFJldHVybnMgdGhlIHtAbGluayAjdGFnQnVpbGRlcn0gaW5zdGFuY2UgZm9yIHRoaXMgQXV0b2xpbmtlciBpbnN0YW5jZSwgbGF6aWx5IGluc3RhbnRpYXRpbmcgaXRcclxuXHRcdCAqIGlmIGl0IGRvZXMgbm90IHlldCBleGlzdC5cclxuXHRcdCAqIFxyXG5cdFx0ICogVGhpcyBtZXRob2QgbWF5IGJlIHVzZWQgaW4gYSB7QGxpbmsgI3JlcGxhY2VGbn0gdG8gZ2VuZXJhdGUgdGhlIHtAbGluayBBdXRvbGlua2VyLkh0bWxUYWcgSHRtbFRhZ30gaW5zdGFuY2UgdGhhdCBcclxuXHRcdCAqIEF1dG9saW5rZXIgd291bGQgbm9ybWFsbHkgZ2VuZXJhdGUsIGFuZCB0aGVuIGFsbG93IGZvciBtb2RpZmljYXRpb25zIGJlZm9yZSByZXR1cm5pbmcgaXQuIEZvciBleGFtcGxlOlxyXG5cdFx0ICogXHJcblx0XHQgKiAgICAgdmFyIGh0bWwgPSBBdXRvbGlua2VyLmxpbmsoIFwiVGVzdCBnb29nbGUuY29tXCIsIHtcclxuXHRcdCAqICAgICAgICAgcmVwbGFjZUZuIDogZnVuY3Rpb24oIGF1dG9saW5rZXIsIG1hdGNoICkge1xyXG5cdFx0ICogICAgICAgICAgICAgdmFyIHRhZyA9IGF1dG9saW5rZXIuZ2V0VGFnQnVpbGRlcigpLmJ1aWxkKCBtYXRjaCApOyAgLy8gcmV0dXJucyBhbiB7QGxpbmsgQXV0b2xpbmtlci5IdG1sVGFnfSBpbnN0YW5jZVxyXG5cdFx0ICogICAgICAgICAgICAgdGFnLnNldEF0dHIoICdyZWwnLCAnbm9mb2xsb3cnICk7XHJcblx0XHQgKiAgICAgICAgICAgICBcclxuXHRcdCAqICAgICAgICAgICAgIHJldHVybiB0YWc7XHJcblx0XHQgKiAgICAgICAgIH1cclxuXHRcdCAqICAgICB9ICk7XHJcblx0XHQgKiAgICAgXHJcblx0XHQgKiAgICAgLy8gZ2VuZXJhdGVkIGh0bWw6XHJcblx0XHQgKiAgICAgLy8gICBUZXN0IDxhIGhyZWY9XCJodHRwOi8vZ29vZ2xlLmNvbVwiIHRhcmdldD1cIl9ibGFua1wiIHJlbD1cIm5vZm9sbG93XCI+Z29vZ2xlLmNvbTwvYT5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHJldHVybiB7QXV0b2xpbmtlci5BbmNob3JUYWdCdWlsZGVyfVxyXG5cdFx0ICovXHJcblx0XHRnZXRUYWdCdWlsZGVyIDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHZhciB0YWdCdWlsZGVyID0gdGhpcy50YWdCdWlsZGVyO1xyXG5cclxuXHRcdFx0aWYoICF0YWdCdWlsZGVyICkge1xyXG5cdFx0XHRcdHRhZ0J1aWxkZXIgPSB0aGlzLnRhZ0J1aWxkZXIgPSBuZXcgQXV0b2xpbmtlci5BbmNob3JUYWdCdWlsZGVyKCB7XHJcblx0XHRcdFx0XHRuZXdXaW5kb3cgICA6IHRoaXMubmV3V2luZG93LFxyXG5cdFx0XHRcdFx0dHJ1bmNhdGUgICAgOiB0aGlzLnRydW5jYXRlLFxyXG5cdFx0XHRcdFx0Y2xhc3NOYW1lICAgOiB0aGlzLmNsYXNzTmFtZVxyXG5cdFx0XHRcdH0gKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRhZ0J1aWxkZXI7XHJcblx0XHR9LFxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFByb2Nlc3MgdGhlIHRleHQgdGhhdCBsaWVzIGluYmV0d2VlbiBIVE1MIHRhZ3MuIFRoaXMgbWV0aG9kIGRvZXMgdGhlIGFjdHVhbCB3cmFwcGluZyBvZiBVUkxzIHdpdGhcclxuXHRcdCAqIGFuY2hvciB0YWdzLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gYXV0by1saW5rLlxyXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgdGV4dCB3aXRoIGFuY2hvciB0YWdzIGF1dG8tZmlsbGVkLlxyXG5cdFx0ICovXHJcblx0XHRwcm9jZXNzVGV4dE5vZGUgOiBmdW5jdGlvbiggdGV4dCApIHtcclxuXHRcdFx0dmFyIG1lID0gdGhpczsgIC8vIGZvciBjbG9zdXJlXHJcblxyXG5cdFx0XHRyZXR1cm4gdGV4dC5yZXBsYWNlKCB0aGlzLm1hdGNoZXJSZWdleCwgZnVuY3Rpb24oIG1hdGNoU3RyLCAkMSwgJDIsICQzLCAkNCwgJDUsICQ2LCAkNywgJDggKSB7XHJcblx0XHRcdFx0dmFyIG1hdGNoRGVzY09iaiA9IG1lLnByb2Nlc3NDYW5kaWRhdGVNYXRjaCggbWF0Y2hTdHIsICQxLCAkMiwgJDMsICQ0LCAkNSwgJDYsICQ3LCAkOCApOyAgLy8gbWF0Y2ggZGVzY3JpcHRpb24gb2JqZWN0XHJcblxyXG5cdFx0XHRcdC8vIFJldHVybiBvdXQgd2l0aCBubyBjaGFuZ2VzIGZvciBtYXRjaCB0eXBlcyB0aGF0IGFyZSBkaXNhYmxlZCAodXJsLCBlbWFpbCwgdHdpdHRlciksIG9yIGZvciBtYXRjaGVzIHRoYXQgYXJlIFxyXG5cdFx0XHRcdC8vIGludmFsaWQgKGZhbHNlIHBvc2l0aXZlcyBmcm9tIHRoZSBtYXRjaGVyUmVnZXgsIHdoaWNoIGNhbid0IHVzZSBsb29rLWJlaGluZHMgc2luY2UgdGhleSBhcmUgdW5hdmFpbGFibGUgaW4gSlMpLlxyXG5cdFx0XHRcdGlmKCAhbWF0Y2hEZXNjT2JqICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoU3RyO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Ly8gR2VuZXJhdGUgdGhlIHJlcGxhY2VtZW50IHRleHQgZm9yIHRoZSBtYXRjaFxyXG5cdFx0XHRcdFx0dmFyIG1hdGNoUmV0dXJuVmFsID0gbWUuY3JlYXRlTWF0Y2hSZXR1cm5WYWwoIG1hdGNoRGVzY09iai5tYXRjaCwgbWF0Y2hEZXNjT2JqLm1hdGNoU3RyICk7XHJcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hEZXNjT2JqLnByZWZpeFN0ciArIG1hdGNoUmV0dXJuVmFsICsgbWF0Y2hEZXNjT2JqLnN1ZmZpeFN0cjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gKTtcclxuXHRcdH0sXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogUHJvY2Vzc2VzIGEgY2FuZGlkYXRlIG1hdGNoIGZyb20gdGhlIHtAbGluayAjbWF0Y2hlclJlZ2V4fS4gXHJcblx0XHQgKiBcclxuXHRcdCAqIE5vdCBhbGwgbWF0Y2hlcyBmb3VuZCBieSB0aGUgcmVnZXggYXJlIGFjdHVhbCBVUkwvZW1haWwvVHdpdHRlciBtYXRjaGVzLCBhcyBkZXRlcm1pbmVkIGJ5IHRoZSB7QGxpbmsgI21hdGNoVmFsaWRhdG9yfS4gSW5cclxuXHRcdCAqIHRoaXMgY2FzZSwgdGhlIG1ldGhvZCByZXR1cm5zIGBudWxsYC4gT3RoZXJ3aXNlLCBhIHZhbGlkIE9iamVjdCB3aXRoIGBwcmVmaXhTdHJgLCBgbWF0Y2hgLCBhbmQgYHN1ZmZpeFN0cmAgaXMgcmV0dXJuZWQuXHJcblx0XHQgKiBcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbWF0Y2hTdHIgVGhlIGZ1bGwgbWF0Y2ggdGhhdCB3YXMgZm91bmQgYnkgdGhlIHtAbGluayAjbWF0Y2hlclJlZ2V4fS5cclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB0d2l0dGVyTWF0Y2ggVGhlIG1hdGNoZWQgdGV4dCBvZiBhIFR3aXR0ZXIgaGFuZGxlLCBpZiB0aGUgbWF0Y2ggaXMgYSBUd2l0dGVyIG1hdGNoLlxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHR3aXR0ZXJIYW5kbGVQcmVmaXhXaGl0ZXNwYWNlQ2hhciBUaGUgd2hpdGVzcGFjZSBjaGFyIGJlZm9yZSB0aGUgQCBzaWduIGluIGEgVHdpdHRlciBoYW5kbGUgbWF0Y2guIFRoaXMgXHJcblx0XHQgKiAgIGlzIG5lZWRlZCBiZWNhdXNlIG9mIG5vIGxvb2tiZWhpbmRzIGluIEpTIHJlZ2V4ZXMsIGFuZCBpcyBuZWVkIHRvIHJlLWluY2x1ZGUgdGhlIGNoYXJhY3RlciBmb3IgdGhlIGFuY2hvciB0YWcgcmVwbGFjZW1lbnQuXHJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdHdpdHRlckhhbmRsZSBUaGUgYWN0dWFsIFR3aXR0ZXIgdXNlciAoaS5lIHRoZSB3b3JkIGFmdGVyIHRoZSBAIHNpZ24gaW4gYSBUd2l0dGVyIG1hdGNoKS5cclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBlbWFpbEFkZHJlc3NNYXRjaCBUaGUgbWF0Y2hlZCBlbWFpbCBhZGRyZXNzIGZvciBhbiBlbWFpbCBhZGRyZXNzIG1hdGNoLlxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHVybE1hdGNoIFRoZSBtYXRjaGVkIFVSTCBzdHJpbmcgZm9yIGEgVVJMIG1hdGNoLlxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sVXJsTWF0Y2ggVGhlIG1hdGNoIFVSTCBzdHJpbmcgZm9yIGEgcHJvdG9jb2wgbWF0Y2guIEV4OiAnaHR0cDovL3lhaG9vLmNvbScuIFRoaXMgaXMgdXNlZCB0byBtYXRjaFxyXG5cdFx0ICogICBzb21ldGhpbmcgbGlrZSAnaHR0cDovL2xvY2FsaG9zdCcsIHdoZXJlIHdlIHdvbid0IGRvdWJsZSBjaGVjayB0aGF0IHRoZSBkb21haW4gbmFtZSBoYXMgYXQgbGVhc3Qgb25lICcuJyBpbiBpdC5cclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB3d3dQcm90b2NvbFJlbGF0aXZlTWF0Y2ggVGhlICcvLycgZm9yIGEgcHJvdG9jb2wtcmVsYXRpdmUgbWF0Y2ggZnJvbSBhICd3d3cnIHVybCwgd2l0aCB0aGUgY2hhcmFjdGVyIHRoYXQgXHJcblx0XHQgKiAgIGNvbWVzIGJlZm9yZSB0aGUgJy8vJy5cclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB0bGRQcm90b2NvbFJlbGF0aXZlTWF0Y2ggVGhlICcvLycgZm9yIGEgcHJvdG9jb2wtcmVsYXRpdmUgbWF0Y2ggZnJvbSBhIFRMRCAodG9wIGxldmVsIGRvbWFpbikgbWF0Y2gsIHdpdGggXHJcblx0XHQgKiAgIHRoZSBjaGFyYWN0ZXIgdGhhdCBjb21lcyBiZWZvcmUgdGhlICcvLycuXHJcblx0XHQgKiAgIFxyXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fSBBIFwibWF0Y2ggZGVzY3JpcHRpb24gb2JqZWN0XCIuIFRoaXMgd2lsbCBiZSBgbnVsbGAgaWYgdGhlIG1hdGNoIHdhcyBpbnZhbGlkLCBvciBpZiBhIG1hdGNoIHR5cGUgaXMgZGlzYWJsZWQuXHJcblx0XHQgKiAgIE90aGVyd2lzZSwgdGhpcyB3aWxsIGJlIGFuIE9iamVjdCAobWFwKSB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcclxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJuLnByZWZpeFN0ciBUaGUgY2hhcihzKSB0aGF0IHNob3VsZCBiZSBwcmVwZW5kZWQgdG8gdGhlIHJlcGxhY2VtZW50IHN0cmluZy4gVGhlc2UgYXJlIGNoYXIocykgdGhhdFxyXG5cdFx0ICogICB3ZXJlIG5lZWRlZCB0byBiZSBpbmNsdWRlZCBmcm9tIHRoZSByZWdleCBtYXRjaCB0aGF0IHdlcmUgaWdub3JlZCBieSBwcm9jZXNzaW5nIGNvZGUsIGFuZCBzaG91bGQgYmUgcmUtaW5zZXJ0ZWQgaW50byBcclxuXHRcdCAqICAgdGhlIHJlcGxhY2VtZW50IHN0cmVhbS5cclxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJuLnN1ZmZpeFN0ciBUaGUgY2hhcihzKSB0aGF0IHNob3VsZCBiZSBhcHBlbmRlZCB0byB0aGUgcmVwbGFjZW1lbnQgc3RyaW5nLiBUaGVzZSBhcmUgY2hhcihzKSB0aGF0XHJcblx0XHQgKiAgIHdlcmUgbmVlZGVkIHRvIGJlIGluY2x1ZGVkIGZyb20gdGhlIHJlZ2V4IG1hdGNoIHRoYXQgd2VyZSBpZ25vcmVkIGJ5IHByb2Nlc3NpbmcgY29kZSwgYW5kIHNob3VsZCBiZSByZS1pbnNlcnRlZCBpbnRvIFxyXG5cdFx0ICogICB0aGUgcmVwbGFjZW1lbnQgc3RyZWFtLlxyXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSByZXR1cm4ubWF0Y2hTdHIgVGhlIGBtYXRjaFN0cmAsIGZpeGVkIHVwIHRvIHJlbW92ZSBjaGFyYWN0ZXJzIHRoYXQgYXJlIG5vIGxvbmdlciBuZWVkZWQgKHdoaWNoIGhhdmUgYmVlblxyXG5cdFx0ICogICBhZGRlZCB0byBgcHJlZml4U3RyYCBhbmQgYHN1ZmZpeFN0cmApLlxyXG5cdFx0ICogQHJldHVybiB7QXV0b2xpbmtlci5tYXRjaC5NYXRjaH0gcmV0dXJuLm1hdGNoIFRoZSBNYXRjaCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBtYXRjaCB0aGF0IHdhcyBmb3VuZC5cclxuXHRcdCAqL1xyXG5cdFx0cHJvY2Vzc0NhbmRpZGF0ZU1hdGNoIDogZnVuY3Rpb24oIFxyXG5cdFx0XHRtYXRjaFN0ciwgdHdpdHRlck1hdGNoLCB0d2l0dGVySGFuZGxlUHJlZml4V2hpdGVzcGFjZUNoYXIsIHR3aXR0ZXJIYW5kbGUsIFxyXG5cdFx0XHRlbWFpbEFkZHJlc3NNYXRjaCwgdXJsTWF0Y2gsIHByb3RvY29sVXJsTWF0Y2gsIHd3d1Byb3RvY29sUmVsYXRpdmVNYXRjaCwgdGxkUHJvdG9jb2xSZWxhdGl2ZU1hdGNoXHJcblx0XHQpIHtcclxuXHRcdFx0dmFyIHByb3RvY29sUmVsYXRpdmVNYXRjaCA9IHd3d1Byb3RvY29sUmVsYXRpdmVNYXRjaCB8fCB0bGRQcm90b2NvbFJlbGF0aXZlTWF0Y2gsXHJcblx0XHRcdCAgICBtYXRjaCwgIC8vIFdpbGwgYmUgYW4gQXV0b2xpbmtlci5tYXRjaC5NYXRjaCBvYmplY3RcclxuXHJcblx0XHRcdCAgICBwcmVmaXhTdHIgPSBcIlwiLCAgICAgICAvLyBBIHN0cmluZyB0byB1c2UgdG8gcHJlZml4IHRoZSBhbmNob3IgdGFnIHRoYXQgaXMgY3JlYXRlZC4gVGhpcyBpcyBuZWVkZWQgZm9yIHRoZSBUd2l0dGVyIGhhbmRsZSBtYXRjaFxyXG5cdFx0XHQgICAgc3VmZml4U3RyID0gXCJcIjsgICAgICAgLy8gQSBzdHJpbmcgdG8gc3VmZml4IHRoZSBhbmNob3IgdGFnIHRoYXQgaXMgY3JlYXRlZC4gVGhpcyBpcyB1c2VkIGlmIHRoZXJlIGlzIGEgdHJhaWxpbmcgcGFyZW50aGVzaXMgdGhhdCBzaG91bGQgbm90IGJlIGF1dG8tbGlua2VkLlxyXG5cclxuXHJcblx0XHRcdC8vIFJldHVybiBvdXQgd2l0aCBgbnVsbGAgZm9yIG1hdGNoIHR5cGVzIHRoYXQgYXJlIGRpc2FibGVkICh1cmwsIGVtYWlsLCB0d2l0dGVyKSwgb3IgZm9yIG1hdGNoZXMgdGhhdCBhcmUgXHJcblx0XHRcdC8vIGludmFsaWQgKGZhbHNlIHBvc2l0aXZlcyBmcm9tIHRoZSBtYXRjaGVyUmVnZXgsIHdoaWNoIGNhbid0IHVzZSBsb29rLWJlaGluZHMgc2luY2UgdGhleSBhcmUgdW5hdmFpbGFibGUgaW4gSlMpLlxyXG5cdFx0XHRpZihcclxuXHRcdFx0XHQoIHR3aXR0ZXJNYXRjaCAmJiAhdGhpcy50d2l0dGVyICkgfHwgKCBlbWFpbEFkZHJlc3NNYXRjaCAmJiAhdGhpcy5lbWFpbCApIHx8ICggdXJsTWF0Y2ggJiYgIXRoaXMudXJscyApIHx8XHJcblx0XHRcdFx0IXRoaXMubWF0Y2hWYWxpZGF0b3IuaXNWYWxpZE1hdGNoKCB1cmxNYXRjaCwgcHJvdG9jb2xVcmxNYXRjaCwgcHJvdG9jb2xSZWxhdGl2ZU1hdGNoICkgXHJcblx0XHRcdCkge1xyXG5cdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBIYW5kbGUgYSBjbG9zaW5nIHBhcmVudGhlc2lzIGF0IHRoZSBlbmQgb2YgdGhlIG1hdGNoLCBhbmQgZXhjbHVkZSBpdCBpZiB0aGVyZSBpcyBub3QgYSBtYXRjaGluZyBvcGVuIHBhcmVudGhlc2lzXHJcblx0XHRcdC8vIGluIHRoZSBtYXRjaCBpdHNlbGYuIFxyXG5cdFx0XHRpZiggdGhpcy5tYXRjaEhhc1VuYmFsYW5jZWRDbG9zaW5nUGFyZW4oIG1hdGNoU3RyICkgKSB7XHJcblx0XHRcdFx0bWF0Y2hTdHIgPSBtYXRjaFN0ci5zdWJzdHIoIDAsIG1hdGNoU3RyLmxlbmd0aCAtIDEgKTsgIC8vIHJlbW92ZSB0aGUgdHJhaWxpbmcgXCIpXCJcclxuXHRcdFx0XHRzdWZmaXhTdHIgPSBcIilcIjsgIC8vIHRoaXMgd2lsbCBiZSBhZGRlZCBhZnRlciB0aGUgZ2VuZXJhdGVkIDxhPiB0YWdcclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdGlmKCBlbWFpbEFkZHJlc3NNYXRjaCApIHtcclxuXHRcdFx0XHRtYXRjaCA9IG5ldyBBdXRvbGlua2VyLm1hdGNoLkVtYWlsKCB7IG1hdGNoZWRUZXh0OiBtYXRjaFN0ciwgZW1haWw6IGVtYWlsQWRkcmVzc01hdGNoIH0gKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiggdHdpdHRlck1hdGNoICkge1xyXG5cdFx0XHRcdC8vIGZpeCB1cCB0aGUgYG1hdGNoU3RyYCBpZiB0aGVyZSB3YXMgYSBwcmVjZWRpbmcgd2hpdGVzcGFjZSBjaGFyLCB3aGljaCB3YXMgbmVlZGVkIHRvIGRldGVybWluZSB0aGUgbWF0Y2ggXHJcblx0XHRcdFx0Ly8gaXRzZWxmIChzaW5jZSB0aGVyZSBhcmUgbm8gbG9vay1iZWhpbmRzIGluIEpTIHJlZ2V4ZXMpXHJcblx0XHRcdFx0aWYoIHR3aXR0ZXJIYW5kbGVQcmVmaXhXaGl0ZXNwYWNlQ2hhciApIHtcclxuXHRcdFx0XHRcdHByZWZpeFN0ciA9IHR3aXR0ZXJIYW5kbGVQcmVmaXhXaGl0ZXNwYWNlQ2hhcjtcclxuXHRcdFx0XHRcdG1hdGNoU3RyID0gbWF0Y2hTdHIuc2xpY2UoIDEgKTsgIC8vIHJlbW92ZSB0aGUgcHJlZml4ZWQgd2hpdGVzcGFjZSBjaGFyIGZyb20gdGhlIG1hdGNoXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdG1hdGNoID0gbmV3IEF1dG9saW5rZXIubWF0Y2guVHdpdHRlciggeyBtYXRjaGVkVGV4dDogbWF0Y2hTdHIsIHR3aXR0ZXJIYW5kbGU6IHR3aXR0ZXJIYW5kbGUgfSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHsgIC8vIHVybCBtYXRjaFxyXG5cdFx0XHRcdC8vIElmIGl0J3MgYSBwcm90b2NvbC1yZWxhdGl2ZSAnLy8nIG1hdGNoLCByZW1vdmUgdGhlIGNoYXJhY3RlciBiZWZvcmUgdGhlICcvLycgKHdoaWNoIHRoZSBtYXRjaGVyUmVnZXggbmVlZGVkXHJcblx0XHRcdFx0Ly8gdG8gbWF0Y2ggZHVlIHRvIHRoZSBsYWNrIG9mIGEgbmVnYXRpdmUgbG9vay1iZWhpbmQgaW4gSmF2YVNjcmlwdCByZWd1bGFyIGV4cHJlc3Npb25zKVxyXG5cdFx0XHRcdGlmKCBwcm90b2NvbFJlbGF0aXZlTWF0Y2ggKSB7XHJcblx0XHRcdFx0XHR2YXIgY2hhckJlZm9yZU1hdGNoID0gcHJvdG9jb2xSZWxhdGl2ZU1hdGNoLm1hdGNoKCB0aGlzLmNoYXJCZWZvcmVQcm90b2NvbFJlbE1hdGNoUmVnZXggKVsgMSBdIHx8IFwiXCI7XHJcblxyXG5cdFx0XHRcdFx0aWYoIGNoYXJCZWZvcmVNYXRjaCApIHsgIC8vIGZpeCB1cCB0aGUgYG1hdGNoU3RyYCBpZiB0aGVyZSB3YXMgYSBwcmVjZWRpbmcgY2hhciBiZWZvcmUgYSBwcm90b2NvbC1yZWxhdGl2ZSBtYXRjaCwgd2hpY2ggd2FzIG5lZWRlZCB0byBkZXRlcm1pbmUgdGhlIG1hdGNoIGl0c2VsZiAoc2luY2UgdGhlcmUgYXJlIG5vIGxvb2stYmVoaW5kcyBpbiBKUyByZWdleGVzKVxyXG5cdFx0XHRcdFx0XHRwcmVmaXhTdHIgPSBjaGFyQmVmb3JlTWF0Y2g7XHJcblx0XHRcdFx0XHRcdG1hdGNoU3RyID0gbWF0Y2hTdHIuc2xpY2UoIDEgKTsgIC8vIHJlbW92ZSB0aGUgcHJlZml4ZWQgY2hhciBmcm9tIHRoZSBtYXRjaFxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bWF0Y2ggPSBuZXcgQXV0b2xpbmtlci5tYXRjaC5VcmwoIHtcclxuXHRcdFx0XHRcdG1hdGNoZWRUZXh0IDogbWF0Y2hTdHIsXHJcblx0XHRcdFx0XHR1cmwgOiBtYXRjaFN0cixcclxuXHRcdFx0XHRcdHByb3RvY29sVXJsTWF0Y2ggOiAhIXByb3RvY29sVXJsTWF0Y2gsXHJcblx0XHRcdFx0XHRwcm90b2NvbFJlbGF0aXZlTWF0Y2ggOiAhIXByb3RvY29sUmVsYXRpdmVNYXRjaCxcclxuXHRcdFx0XHRcdHN0cmlwUHJlZml4IDogdGhpcy5zdHJpcFByZWZpeFxyXG5cdFx0XHRcdH0gKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRwcmVmaXhTdHIgOiBwcmVmaXhTdHIsXHJcblx0XHRcdFx0c3VmZml4U3RyIDogc3VmZml4U3RyLFxyXG5cdFx0XHRcdG1hdGNoU3RyICA6IG1hdGNoU3RyLFxyXG5cdFx0XHRcdG1hdGNoICAgICA6IG1hdGNoXHJcblx0XHRcdH07XHJcblx0XHR9LFxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIERldGVybWluZXMgaWYgYSBtYXRjaCBmb3VuZCBoYXMgYW4gdW5tYXRjaGVkIGNsb3NpbmcgcGFyZW50aGVzaXMuIElmIHNvLCB0aGlzIHBhcmVudGhlc2lzIHdpbGwgYmUgcmVtb3ZlZFxyXG5cdFx0ICogZnJvbSB0aGUgbWF0Y2ggaXRzZWxmLCBhbmQgYXBwZW5kZWQgYWZ0ZXIgdGhlIGdlbmVyYXRlZCBhbmNob3IgdGFnIGluIHtAbGluayAjcHJvY2Vzc1RleHROb2RlfS5cclxuXHRcdCAqIFxyXG5cdFx0ICogQSBtYXRjaCBtYXkgaGF2ZSBhbiBleHRyYSBjbG9zaW5nIHBhcmVudGhlc2lzIGF0IHRoZSBlbmQgb2YgdGhlIG1hdGNoIGJlY2F1c2UgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBtdXN0IGluY2x1ZGUgcGFyZW50aGVzaXNcclxuXHRcdCAqIGZvciBVUkxzIHN1Y2ggYXMgXCJ3aWtpcGVkaWEuY29tL3NvbWV0aGluZ18oZGlzYW1iaWd1YXRpb24pXCIsIHdoaWNoIHNob3VsZCBiZSBhdXRvLWxpbmtlZC4gXHJcblx0XHQgKiBcclxuXHRcdCAqIEhvd2V2ZXIsIGFuIGV4dHJhIHBhcmVudGhlc2lzICp3aWxsKiBiZSBpbmNsdWRlZCB3aGVuIHRoZSBVUkwgaXRzZWxmIGlzIHdyYXBwZWQgaW4gcGFyZW50aGVzaXMsIHN1Y2ggYXMgaW4gdGhlIGNhc2Ugb2ZcclxuXHRcdCAqIFwiKHdpa2lwZWRpYS5jb20vc29tZXRoaW5nXyhkaXNhbWJpZ3VhdGlvbikpXCIuIEluIHRoaXMgY2FzZSwgdGhlIGxhc3QgY2xvc2luZyBwYXJlbnRoZXNpcyBzaG91bGQgKm5vdCogYmUgcGFydCBvZiB0aGUgVVJMIFxyXG5cdFx0ICogaXRzZWxmLCBhbmQgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gYHRydWVgLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG1hdGNoU3RyIFRoZSBmdWxsIG1hdGNoIHN0cmluZyBmcm9tIHRoZSB7QGxpbmsgI21hdGNoZXJSZWdleH0uXHJcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlcmUgaXMgYW4gdW5iYWxhbmNlZCBjbG9zaW5nIHBhcmVudGhlc2lzIGF0IHRoZSBlbmQgb2YgdGhlIGBtYXRjaFN0cmAsIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG5cdFx0ICovXHJcblx0XHRtYXRjaEhhc1VuYmFsYW5jZWRDbG9zaW5nUGFyZW4gOiBmdW5jdGlvbiggbWF0Y2hTdHIgKSB7XHJcblx0XHRcdHZhciBsYXN0Q2hhciA9IG1hdGNoU3RyLmNoYXJBdCggbWF0Y2hTdHIubGVuZ3RoIC0gMSApO1xyXG5cclxuXHRcdFx0aWYoIGxhc3RDaGFyID09PSAnKScgKSB7XHJcblx0XHRcdFx0dmFyIG9wZW5QYXJlbnNNYXRjaCA9IG1hdGNoU3RyLm1hdGNoKCAvXFwoL2cgKSxcclxuXHRcdFx0XHQgICAgY2xvc2VQYXJlbnNNYXRjaCA9IG1hdGNoU3RyLm1hdGNoKCAvXFwpL2cgKSxcclxuXHRcdFx0XHQgICAgbnVtT3BlblBhcmVucyA9ICggb3BlblBhcmVuc01hdGNoICYmIG9wZW5QYXJlbnNNYXRjaC5sZW5ndGggKSB8fCAwLFxyXG5cdFx0XHRcdCAgICBudW1DbG9zZVBhcmVucyA9ICggY2xvc2VQYXJlbnNNYXRjaCAmJiBjbG9zZVBhcmVuc01hdGNoLmxlbmd0aCApIHx8IDA7XHJcblxyXG5cdFx0XHRcdGlmKCBudW1PcGVuUGFyZW5zIDwgbnVtQ2xvc2VQYXJlbnMgKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH0sXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQ3JlYXRlcyB0aGUgcmV0dXJuIHN0cmluZyB2YWx1ZSBmb3IgYSBnaXZlbiBtYXRjaCBpbiB0aGUgaW5wdXQgc3RyaW5nLCBmb3IgdGhlIHtAbGluayAjcHJvY2Vzc1RleHROb2RlfSBtZXRob2QuXHJcblx0XHQgKiBcclxuXHRcdCAqIFRoaXMgbWV0aG9kIGhhbmRsZXMgdGhlIHtAbGluayAjcmVwbGFjZUZufSwgaWYgb25lIHdhcyBwcm92aWRlZC5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEBwYXJhbSB7QXV0b2xpbmtlci5tYXRjaC5NYXRjaH0gbWF0Y2ggVGhlIE1hdGNoIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIG1hdGNoLlxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG1hdGNoU3RyIFRoZSBvcmlnaW5hbCBtYXRjaCBzdHJpbmcsIGFmdGVyIGhhdmluZyBiZWVuIHByZXByb2Nlc3NlZCB0byBmaXggbWF0Y2ggZWRnZSBjYXNlcyAoc2VlXHJcblx0XHQgKiAgIHRoZSBgcHJlZml4U3RyYCBhbmQgYHN1ZmZpeFN0cmAgdmFycyBpbiB7QGxpbmsgI3Byb2Nlc3NUZXh0Tm9kZX0uXHJcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBzdHJpbmcgdGhhdCB0aGUgYG1hdGNoYCBzaG91bGQgYmUgcmVwbGFjZWQgd2l0aC4gVGhpcyBpcyB1c3VhbGx5IHRoZSBhbmNob3IgdGFnIHN0cmluZywgYnV0XHJcblx0XHQgKiAgIG1heSBiZSB0aGUgYG1hdGNoU3RyYCBpdHNlbGYgaWYgdGhlIG1hdGNoIGlzIG5vdCB0byBiZSByZXBsYWNlZC5cclxuXHRcdCAqL1xyXG5cdFx0Y3JlYXRlTWF0Y2hSZXR1cm5WYWwgOiBmdW5jdGlvbiggbWF0Y2gsIG1hdGNoU3RyICkge1xyXG5cdFx0XHQvLyBIYW5kbGUgYSBjdXN0b20gYHJlcGxhY2VGbmAgYmVpbmcgcHJvdmlkZWRcclxuXHRcdFx0dmFyIHJlcGxhY2VGblJlc3VsdDtcclxuXHRcdFx0aWYoIHRoaXMucmVwbGFjZUZuICkge1xyXG5cdFx0XHRcdHJlcGxhY2VGblJlc3VsdCA9IHRoaXMucmVwbGFjZUZuLmNhbGwoIHRoaXMsIHRoaXMsIG1hdGNoICk7ICAvLyBBdXRvbGlua2VyIGluc3RhbmNlIGlzIHRoZSBjb250ZXh0LCBhbmQgdGhlIGZpcnN0IGFyZ1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiggdHlwZW9mIHJlcGxhY2VGblJlc3VsdCA9PT0gJ3N0cmluZycgKSB7XHJcblx0XHRcdFx0cmV0dXJuIHJlcGxhY2VGblJlc3VsdDsgIC8vIGByZXBsYWNlRm5gIHJldHVybmVkIGEgc3RyaW5nLCB1c2UgdGhhdFxyXG5cclxuXHRcdFx0fSBlbHNlIGlmKCByZXBsYWNlRm5SZXN1bHQgPT09IGZhbHNlICkge1xyXG5cdFx0XHRcdHJldHVybiBtYXRjaFN0cjsgIC8vIG5vIHJlcGxhY2VtZW50IGZvciB0aGUgbWF0Y2hcclxuXHJcblx0XHRcdH0gZWxzZSBpZiggcmVwbGFjZUZuUmVzdWx0IGluc3RhbmNlb2YgQXV0b2xpbmtlci5IdG1sVGFnICkge1xyXG5cdFx0XHRcdHJldHVybiByZXBsYWNlRm5SZXN1bHQudG9TdHJpbmcoKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7ICAvLyByZXBsYWNlRm5SZXN1bHQgPT09IHRydWUsIG9yIG5vL3Vua25vd24gcmV0dXJuIHZhbHVlIGZyb20gZnVuY3Rpb25cclxuXHRcdFx0XHQvLyBQZXJmb3JtIEF1dG9saW5rZXIncyBkZWZhdWx0IGFuY2hvciB0YWcgZ2VuZXJhdGlvblxyXG5cdFx0XHRcdHZhciB0YWdCdWlsZGVyID0gdGhpcy5nZXRUYWdCdWlsZGVyKCksXHJcblx0XHRcdFx0ICAgIGFuY2hvclRhZyA9IHRhZ0J1aWxkZXIuYnVpbGQoIG1hdGNoICk7ICAvLyByZXR1cm5zIGFuIEF1dG9saW5rZXIuSHRtbFRhZyBpbnN0YW5jZVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gYW5jaG9yVGFnLnRvU3RyaW5nKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIEF1dG9tYXRpY2FsbHkgbGlua3MgVVJMcywgZW1haWwgYWRkcmVzc2VzLCBhbmQgVHdpdHRlciBoYW5kbGVzIGZvdW5kIGluIHRoZSBnaXZlbiBjaHVuayBvZiBIVE1MLiBcclxuXHQgKiBEb2VzIG5vdCBsaW5rIFVSTHMgZm91bmQgd2l0aGluIEhUTUwgdGFncy5cclxuXHQgKiBcclxuXHQgKiBGb3IgaW5zdGFuY2UsIGlmIGdpdmVuIHRoZSB0ZXh0OiBgWW91IHNob3VsZCBnbyB0byBodHRwOi8vd3d3LnlhaG9vLmNvbWAsIHRoZW4gdGhlIHJlc3VsdFxyXG5cdCAqIHdpbGwgYmUgYFlvdSBzaG91bGQgZ28gdG8gJmx0O2EgaHJlZj1cImh0dHA6Ly93d3cueWFob28uY29tXCImZ3Q7aHR0cDovL3d3dy55YWhvby5jb20mbHQ7L2EmZ3Q7YFxyXG5cdCAqIFxyXG5cdCAqIEV4YW1wbGU6XHJcblx0ICogXHJcblx0ICogICAgIHZhciBsaW5rZWRUZXh0ID0gQXV0b2xpbmtlci5saW5rKCBcIkdvIHRvIGdvb2dsZS5jb21cIiwgeyBuZXdXaW5kb3c6IGZhbHNlIH0gKTtcclxuXHQgKiAgICAgLy8gUHJvZHVjZXM6IFwiR28gdG8gPGEgaHJlZj1cImh0dHA6Ly9nb29nbGUuY29tXCI+Z29vZ2xlLmNvbTwvYT5cIlxyXG5cdCAqIFxyXG5cdCAqIEBzdGF0aWNcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dE9ySHRtbCBUaGUgSFRNTCBvciB0ZXh0IHRvIGZpbmQgVVJMcywgZW1haWwgYWRkcmVzc2VzLCBhbmQgVHdpdHRlciBoYW5kbGVzIHdpdGhpbiAoZGVwZW5kaW5nIG9uIGlmXHJcblx0ICogICB0aGUge0BsaW5rICN1cmxzfSwge0BsaW5rICNlbWFpbH0sIGFuZCB7QGxpbmsgI3R3aXR0ZXJ9IG9wdGlvbnMgYXJlIGVuYWJsZWQpLlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQW55IG9mIHRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBBdXRvbGlua2VyIGNsYXNzLCBzcGVjaWZpZWQgaW4gYW4gT2JqZWN0IChtYXApLlxyXG5cdCAqICAgU2VlIHRoZSBjbGFzcyBkZXNjcmlwdGlvbiBmb3IgYW4gZXhhbXBsZSBjYWxsLlxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIEhUTUwgdGV4dCwgd2l0aCBVUkxzIGF1dG9tYXRpY2FsbHkgbGlua2VkXHJcblx0ICovXHJcblx0QXV0b2xpbmtlci5saW5rID0gZnVuY3Rpb24oIHRleHRPckh0bWwsIG9wdGlvbnMgKSB7XHJcblx0XHR2YXIgYXV0b2xpbmtlciA9IG5ldyBBdXRvbGlua2VyKCBvcHRpb25zICk7XHJcblx0XHRyZXR1cm4gYXV0b2xpbmtlci5saW5rKCB0ZXh0T3JIdG1sICk7XHJcblx0fTtcclxuXHJcblxyXG5cdC8vIE5hbWVzcGFjZSBmb3IgYG1hdGNoYCBjbGFzc2VzXHJcblx0QXV0b2xpbmtlci5tYXRjaCA9IHt9O1xyXG5cdC8qZ2xvYmFsIEF1dG9saW5rZXIgKi9cclxuXHQvKmpzaGludCBlcW51bGw6dHJ1ZSwgYm9zczp0cnVlICovXHJcblx0LyoqXHJcblx0ICogQGNsYXNzIEF1dG9saW5rZXIuVXRpbFxyXG5cdCAqIEBzaW5nbGV0b25cclxuXHQgKiBcclxuXHQgKiBBIGZldyB1dGlsaXR5IG1ldGhvZHMgZm9yIEF1dG9saW5rZXIuXHJcblx0ICovXHJcblx0QXV0b2xpbmtlci5VdGlsID0ge1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gYWJzdHJhY3RNZXRob2RcclxuXHRcdCAqIFxyXG5cdFx0ICogQSBmdW5jdGlvbiBvYmplY3Qgd2hpY2ggcmVwcmVzZW50cyBhbiBhYnN0cmFjdCBtZXRob2QuXHJcblx0XHQgKi9cclxuXHRcdGFic3RyYWN0TWV0aG9kIDogZnVuY3Rpb24oKSB7IHRocm93IFwiYWJzdHJhY3RcIjsgfSxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBc3NpZ25zIChzaGFsbG93IGNvcGllcykgdGhlIHByb3BlcnRpZXMgb2YgYHNyY2Agb250byBgZGVzdGAuXHJcblx0XHQgKiBcclxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXHJcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gc3JjIFRoZSBzb3VyY2Ugb2JqZWN0LlxyXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVzdGluYXRpb24gb2JqZWN0IChgZGVzdGApXHJcblx0XHQgKi9cclxuXHRcdGFzc2lnbiA6IGZ1bmN0aW9uKCBkZXN0LCBzcmMgKSB7XHJcblx0XHRcdGZvciggdmFyIHByb3AgaW4gc3JjICkge1xyXG5cdFx0XHRcdGlmKCBzcmMuaGFzT3duUHJvcGVydHkoIHByb3AgKSApIHtcclxuXHRcdFx0XHRcdGRlc3RbIHByb3AgXSA9IHNyY1sgcHJvcCBdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGRlc3Q7XHJcblx0XHR9LFxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEV4dGVuZHMgYHN1cGVyY2xhc3NgIHRvIGNyZWF0ZSBhIG5ldyBzdWJjbGFzcywgYWRkaW5nIHRoZSBgcHJvdG9Qcm9wc2AgdG8gdGhlIG5ldyBzdWJjbGFzcydzIHByb3RvdHlwZS5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gc3VwZXJjbGFzcyBUaGUgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHRoZSBzdXBlcmNsYXNzLlxyXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHByb3RvUHJvcHMgVGhlIG1ldGhvZHMvcHJvcGVydGllcyB0byBhZGQgdG8gdGhlIHN1YmNsYXNzJ3MgcHJvdG90eXBlLiBUaGlzIG1heSBjb250YWluIHRoZVxyXG5cdFx0ICogICBzcGVjaWFsIHByb3BlcnR5IGBjb25zdHJ1Y3RvcmAsIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyB0aGUgbmV3IHN1YmNsYXNzJ3MgY29uc3RydWN0b3IgZnVuY3Rpb24uXHJcblx0XHQgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIG5ldyBzdWJjbGFzcyBmdW5jdGlvbi5cclxuXHRcdCAqL1xyXG5cdFx0ZXh0ZW5kIDogZnVuY3Rpb24oIHN1cGVyY2xhc3MsIHByb3RvUHJvcHMgKSB7XHJcblx0XHRcdHZhciBzdXBlcmNsYXNzUHJvdG8gPSBzdXBlcmNsYXNzLnByb3RvdHlwZTtcclxuXHJcblx0XHRcdHZhciBGID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdFx0Ri5wcm90b3R5cGUgPSBzdXBlcmNsYXNzUHJvdG87XHJcblxyXG5cdFx0XHR2YXIgc3ViY2xhc3M7XHJcblx0XHRcdGlmKCBwcm90b1Byb3BzLmhhc093blByb3BlcnR5KCAnY29uc3RydWN0b3InICkgKSB7XHJcblx0XHRcdFx0c3ViY2xhc3MgPSBwcm90b1Byb3BzLmNvbnN0cnVjdG9yO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHN1YmNsYXNzID0gZnVuY3Rpb24oKSB7IHN1cGVyY2xhc3NQcm90by5jb25zdHJ1Y3Rvci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7IH07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBzdWJjbGFzc1Byb3RvID0gc3ViY2xhc3MucHJvdG90eXBlID0gbmV3IEYoKTsgIC8vIHNldCB1cCBwcm90b3R5cGUgY2hhaW5cclxuXHRcdFx0c3ViY2xhc3NQcm90by5jb25zdHJ1Y3RvciA9IHN1YmNsYXNzOyAgLy8gZml4IGNvbnN0cnVjdG9yIHByb3BlcnR5XHJcblx0XHRcdHN1YmNsYXNzUHJvdG8uc3VwZXJjbGFzcyA9IHN1cGVyY2xhc3NQcm90bztcclxuXHJcblx0XHRcdGRlbGV0ZSBwcm90b1Byb3BzLmNvbnN0cnVjdG9yOyAgLy8gZG9uJ3QgcmUtYXNzaWduIGNvbnN0cnVjdG9yIHByb3BlcnR5IHRvIHRoZSBwcm90b3R5cGUsIHNpbmNlIGEgbmV3IGZ1bmN0aW9uIG1heSBoYXZlIGJlZW4gY3JlYXRlZCAoYHN1YmNsYXNzYCksIHdoaWNoIGlzIG5vdyBhbHJlYWR5IHRoZXJlXHJcblx0XHRcdEF1dG9saW5rZXIuVXRpbC5hc3NpZ24oIHN1YmNsYXNzUHJvdG8sIHByb3RvUHJvcHMgKTtcclxuXHJcblx0XHRcdHJldHVybiBzdWJjbGFzcztcclxuXHRcdH0sXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVHJ1bmNhdGVzIHRoZSBgc3RyYCBhdCBgbGVuIC0gZWxsaXBzaXNDaGFycy5sZW5ndGhgLCBhbmQgYWRkcyB0aGUgYGVsbGlwc2lzQ2hhcnNgIHRvIHRoZVxyXG5cdFx0ICogZW5kIG9mIHRoZSBzdHJpbmcgKGJ5IGRlZmF1bHQsIHR3byBwZXJpb2RzOiAnLi4nKS4gSWYgdGhlIGBzdHJgIGxlbmd0aCBkb2VzIG5vdCBleGNlZWQgXHJcblx0XHQgKiBgbGVuYCwgdGhlIHN0cmluZyB3aWxsIGJlIHJldHVybmVkIHVuY2hhbmdlZC5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIHRydW5jYXRlIGFuZCBhZGQgYW4gZWxsaXBzaXMgdG8uXHJcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gdHJ1bmNhdGVMZW4gVGhlIGxlbmd0aCB0byB0cnVuY2F0ZSB0aGUgc3RyaW5nIGF0LlxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IFtlbGxpcHNpc0NoYXJzPS4uXSBUaGUgZWxsaXBzaXMgY2hhcmFjdGVyKHMpIHRvIGFkZCB0byB0aGUgZW5kIG9mIGBzdHJgXHJcblx0XHQgKiAgIHdoZW4gdHJ1bmNhdGVkLiBEZWZhdWx0cyB0byAnLi4nXHJcblx0XHQgKi9cclxuXHRcdGVsbGlwc2lzIDogZnVuY3Rpb24oIHN0ciwgdHJ1bmNhdGVMZW4sIGVsbGlwc2lzQ2hhcnMgKSB7XHJcblx0XHRcdGlmKCBzdHIubGVuZ3RoID4gdHJ1bmNhdGVMZW4gKSB7XHJcblx0XHRcdFx0ZWxsaXBzaXNDaGFycyA9ICggZWxsaXBzaXNDaGFycyA9PSBudWxsICkgPyAnLi4nIDogZWxsaXBzaXNDaGFycztcclxuXHRcdFx0XHRzdHIgPSBzdHIuc3Vic3RyaW5nKCAwLCB0cnVuY2F0ZUxlbiAtIGVsbGlwc2lzQ2hhcnMubGVuZ3RoICkgKyBlbGxpcHNpc0NoYXJzO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBzdHI7XHJcblx0XHR9LFxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFN1cHBvcnRzIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZigpYCBmdW5jdGlvbmFsaXR5IGZvciBvbGQgSUUgKElFOCBhbmQgYmVsb3cpLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcGFyYW0ge0FycmF5fSBhcnIgVGhlIGFycmF5IHRvIGZpbmQgYW4gZWxlbWVudCBvZi5cclxuXHRcdCAqIEBwYXJhbSB7Kn0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBmaW5kIGluIHRoZSBhcnJheSwgYW5kIHJldHVybiB0aGUgaW5kZXggb2YuXHJcblx0XHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgYGVsZW1lbnRgLCBvciAtMSBpZiBpdCB3YXMgbm90IGZvdW5kLlxyXG5cdFx0ICovXHJcblx0XHRpbmRleE9mIDogZnVuY3Rpb24oIGFyciwgZWxlbWVudCApIHtcclxuXHRcdFx0aWYoIEFycmF5LnByb3RvdHlwZS5pbmRleE9mICkge1xyXG5cdFx0XHRcdHJldHVybiBhcnIuaW5kZXhPZiggZWxlbWVudCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRmb3IoIHZhciBpID0gMCwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xyXG5cdFx0XHRcdFx0aWYoIGFyclsgaSBdID09PSBlbGVtZW50ICkgcmV0dXJuIGk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiAtMTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogUGVyZm9ybXMgdGhlIGZ1bmN0aW9uYWxpdHkgb2Ygd2hhdCBtb2Rlcm4gYnJvd3NlcnMgZG8gd2hlbiBgU3RyaW5nLnByb3RvdHlwZS5zcGxpdCgpYCBpcyBjYWxsZWRcclxuXHRcdCAqIHdpdGggYSByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBjb250YWlucyBjYXB0dXJpbmcgcGFyZW50aGVzaXMuXHJcblx0XHQgKiBcclxuXHRcdCAqIEZvciBleGFtcGxlOlxyXG5cdFx0ICogXHJcblx0XHQgKiAgICAgLy8gTW9kZXJuIGJyb3dzZXJzOiBcclxuXHRcdCAqICAgICBcImEsYixjXCIuc3BsaXQoIC8oLCkvICk7ICAvLyAtLT4gWyAnYScsICcsJywgJ2InLCAnLCcsICdjJyBdXHJcblx0XHQgKiAgICAgXHJcblx0XHQgKiAgICAgLy8gT2xkIElFIChpbmNsdWRpbmcgSUU4KTpcclxuXHRcdCAqICAgICBcImEsYixjXCIuc3BsaXQoIC8oLCkvICk7ICAvLyAtLT4gWyAnYScsICdiJywgJ2MnIF1cclxuXHRcdCAqICAgICBcclxuXHRcdCAqIFRoaXMgbWV0aG9kIGVtdWxhdGVzIHRoZSBmdW5jdGlvbmFsaXR5IG9mIG1vZGVybiBicm93c2VycyBmb3IgdGhlIG9sZCBJRSBjYXNlLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gc3BsaXQuXHJcblx0XHQgKiBAcGFyYW0ge1JlZ0V4cH0gc3BsaXRSZWdleCBUaGUgcmVndWxhciBleHByZXNzaW9uIHRvIHNwbGl0IHRoZSBpbnB1dCBgc3RyYCBvbi4gVGhlIHNwbGl0dGluZ1xyXG5cdFx0ICogICBjaGFyYWN0ZXIocykgd2lsbCBiZSBzcGxpY2VkIGludG8gdGhlIGFycmF5LCBhcyBpbiB0aGUgXCJtb2Rlcm4gYnJvd3NlcnNcIiBleGFtcGxlIGluIHRoZSBcclxuXHRcdCAqICAgZGVzY3JpcHRpb24gb2YgdGhpcyBtZXRob2QuIFxyXG5cdFx0ICogICBOb3RlICMxOiB0aGUgc3VwcGxpZWQgcmVndWxhciBleHByZXNzaW9uICoqbXVzdCoqIGhhdmUgdGhlICdnJyBmbGFnIHNwZWNpZmllZC5cclxuXHRcdCAqICAgTm90ZSAjMjogZm9yIHNpbXBsaWNpdHkncyBzYWtlLCB0aGUgcmVndWxhciBleHByZXNzaW9uIGRvZXMgbm90IG5lZWQgXHJcblx0XHQgKiAgIHRvIGNvbnRhaW4gY2FwdHVyaW5nIHBhcmVudGhlc2lzIC0gaXQgd2lsbCBiZSBhc3N1bWVkIHRoYXQgYW55IG1hdGNoIGhhcyB0aGVtLlxyXG5cdFx0ICogQHJldHVybiB7U3RyaW5nW119IFRoZSBzcGxpdCBhcnJheSBvZiBzdHJpbmdzLCB3aXRoIHRoZSBzcGxpdHRpbmcgY2hhcmFjdGVyKHMpIGluY2x1ZGVkLlxyXG5cdFx0ICovXHJcblx0XHRzcGxpdEFuZENhcHR1cmUgOiBmdW5jdGlvbiggc3RyLCBzcGxpdFJlZ2V4ICkge1xyXG5cdFx0XHRpZiggIXNwbGl0UmVnZXguZ2xvYmFsICkgdGhyb3cgbmV3IEVycm9yKCBcImBzcGxpdFJlZ2V4YCBtdXN0IGhhdmUgdGhlICdnJyBmbGFnIHNldFwiICk7XHJcblxyXG5cdFx0XHR2YXIgcmVzdWx0ID0gW10sXHJcblx0XHRcdCAgICBsYXN0SWR4ID0gMCxcclxuXHRcdFx0ICAgIG1hdGNoO1xyXG5cclxuXHRcdFx0d2hpbGUoIG1hdGNoID0gc3BsaXRSZWdleC5leGVjKCBzdHIgKSApIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaCggc3RyLnN1YnN0cmluZyggbGFzdElkeCwgbWF0Y2guaW5kZXggKSApO1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKCBtYXRjaFsgMCBdICk7ICAvLyBwdXNoIHRoZSBzcGxpdHRpbmcgY2hhcihzKVxyXG5cclxuXHRcdFx0XHRsYXN0SWR4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFsgMCBdLmxlbmd0aDtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXN1bHQucHVzaCggc3RyLnN1YnN0cmluZyggbGFzdElkeCApICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cdC8qZ2xvYmFsIEF1dG9saW5rZXIgKi9cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBjbGFzcyBBdXRvbGlua2VyLkh0bWxQYXJzZXJcclxuXHQgKiBAZXh0ZW5kcyBPYmplY3RcclxuXHQgKiBcclxuXHQgKiBBbiBIVE1MIHBhcnNlciBpbXBsZW1lbnRhdGlvbiB3aGljaCBzaW1wbHkgd2Fsa3MgYW4gSFRNTCBzdHJpbmcgYW5kIGNhbGxzIHRoZSBwcm92aWRlZCB2aXNpdG9yIGZ1bmN0aW9ucyB0byBwcm9jZXNzIFxyXG5cdCAqIEhUTUwgYW5kIHRleHQgbm9kZXMuXHJcblx0ICogXHJcblx0ICogQXV0b2xpbmtlciB1c2VzIHRoaXMgdG8gb25seSBsaW5rIFVSTHMvZW1haWxzL1R3aXR0ZXIgaGFuZGxlcyB3aXRoaW4gdGV4dCBub2RlcywgYmFzaWNhbGx5IGlnbm9yaW5nIEhUTUwgdGFncy5cclxuXHQgKi9cclxuXHRBdXRvbGlua2VyLkh0bWxQYXJzZXIgPSBBdXRvbGlua2VyLlV0aWwuZXh0ZW5kKCBPYmplY3QsIHtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAcHJvcGVydHkge1JlZ0V4cH0gaHRtbFJlZ2V4XHJcblx0XHQgKiBcclxuXHRcdCAqIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byBwdWxsIG91dCBIVE1MIHRhZ3MgZnJvbSBhIHN0cmluZy4gSGFuZGxlcyBuYW1lc3BhY2VkIEhUTUwgdGFncyBhbmRcclxuXHRcdCAqIGF0dHJpYnV0ZSBuYW1lcywgYXMgc3BlY2lmaWVkIGJ5IGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWwtbWFya3VwL3N5bnRheC5odG1sLlxyXG5cdFx0ICogXHJcblx0XHQgKiBDYXB0dXJpbmcgZ3JvdXBzOlxyXG5cdFx0ICogXHJcblx0XHQgKiAxLiBUaGUgXCIhRE9DVFlQRVwiIHRhZyBuYW1lLCBpZiBhIHRhZyBpcyBhICZsdDshRE9DVFlQRSZndDsgdGFnLlxyXG5cdFx0ICogMi4gSWYgaXQgaXMgYW4gZW5kIHRhZywgdGhpcyBncm91cCB3aWxsIGhhdmUgdGhlICcvJy5cclxuXHRcdCAqIDMuIFRoZSB0YWcgbmFtZSBmb3IgYWxsIHRhZ3MgKG90aGVyIHRoYW4gdGhlICZsdDshRE9DVFlQRSZndDsgdGFnKVxyXG5cdFx0ICovXHJcblx0XHRodG1sUmVnZXggOiAoZnVuY3Rpb24oKSB7XHJcblx0XHRcdHZhciB0YWdOYW1lUmVnZXggPSAvWzAtOWEtekEtWl1bMC05YS16QS1aOl0qLyxcclxuXHRcdFx0ICAgIGF0dHJOYW1lUmVnZXggPSAvW15cXHNcXDBcIic+XFwvPVxceDAxLVxceDFGXFx4N0ZdKy8sICAgLy8gdGhlIHVuaWNvZGUgcmFuZ2UgYWNjb3VudHMgZm9yIGV4Y2x1ZGluZyBjb250cm9sIGNoYXJzLCBhbmQgdGhlIGRlbGV0ZSBjaGFyXHJcblx0XHRcdCAgICBhdHRyVmFsdWVSZWdleCA9IC8oPzpcIlteXCJdKj9cInwnW14nXSo/J3xbXidcIj08PmBcXHNdKykvLCAvLyBkb3VibGUgcXVvdGVkLCBzaW5nbGUgcXVvdGVkLCBvciB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWVzXHJcblx0XHRcdCAgICBuYW1lRXF1YWxzVmFsdWVSZWdleCA9IGF0dHJOYW1lUmVnZXguc291cmNlICsgJyg/OlxcXFxzKj1cXFxccyonICsgYXR0clZhbHVlUmVnZXguc291cmNlICsgJyk/JzsgIC8vIG9wdGlvbmFsICc9W3ZhbHVlXSdcclxuXHJcblx0XHRcdHJldHVybiBuZXcgUmVnRXhwKCBbXHJcblx0XHRcdFx0Ly8gZm9yIDwhRE9DVFlQRT4gdGFnLiBFeDogPCFET0NUWVBFIGh0bWwgUFVCTElDIFwiLS8vVzNDLy9EVEQgWEhUTUwgMS4wIFN0cmljdC8vRU5cIiBcImh0dHA6Ly93d3cudzMub3JnL1RSL3hodG1sMS9EVEQveGh0bWwxLXN0cmljdC5kdGRcIj4pIFxyXG5cdFx0XHRcdCcoPzonLFxyXG5cdFx0XHRcdFx0JzwoIURPQ1RZUEUpJywgIC8vICoqKiBDYXB0dXJpbmcgR3JvdXAgMSAtIElmIGl0J3MgYSBkb2N0eXBlIHRhZ1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gWmVybyBvciBtb3JlIGF0dHJpYnV0ZXMgZm9sbG93aW5nIHRoZSB0YWcgbmFtZVxyXG5cdFx0XHRcdFx0XHQnKD86JyxcclxuXHRcdFx0XHRcdFx0XHQnXFxcXHMrJywgIC8vIG9uZSBvciBtb3JlIHdoaXRlc3BhY2UgY2hhcnMgYmVmb3JlIGFuIGF0dHJpYnV0ZVxyXG5cclxuXHRcdFx0XHRcdFx0XHQvLyBFaXRoZXI6XHJcblx0XHRcdFx0XHRcdFx0Ly8gQS4gYXR0cj1cInZhbHVlXCIsIG9yIFxyXG5cdFx0XHRcdFx0XHRcdC8vIEIuIFwidmFsdWVcIiBhbG9uZSAoVG8gY292ZXIgZXhhbXBsZSBkb2N0eXBlIHRhZzogPCFET0NUWVBFIGh0bWwgUFVCTElDIFwiLS8vVzNDLy9EVEQgWEhUTUwgMS4wIFN0cmljdC8vRU5cIiBcImh0dHA6Ly93d3cudzMub3JnL1RSL3hodG1sMS9EVEQveGh0bWwxLXN0cmljdC5kdGRcIj4pIFxyXG5cdFx0XHRcdFx0XHRcdCcoPzonLCBuYW1lRXF1YWxzVmFsdWVSZWdleCwgJ3wnLCBhdHRyVmFsdWVSZWdleC5zb3VyY2UgKyAnKScsXHJcblx0XHRcdFx0XHRcdCcpKicsXHJcblx0XHRcdFx0XHQnPicsXHJcblx0XHRcdFx0JyknLFxyXG5cclxuXHRcdFx0XHQnfCcsXHJcblxyXG5cdFx0XHRcdC8vIEFsbCBvdGhlciBIVE1MIHRhZ3MgKGkuZS4gdGFncyB0aGF0IGFyZSBub3QgPCFET0NUWVBFPilcclxuXHRcdFx0XHQnKD86JyxcclxuXHRcdFx0XHRcdCc8KC8pPycsICAvLyBCZWdpbm5pbmcgb2YgYSB0YWcuIEVpdGhlciAnPCcgZm9yIGEgc3RhcnQgdGFnLCBvciAnPC8nIGZvciBhbiBlbmQgdGFnLiBcclxuXHRcdFx0XHRcdCAgICAgICAgICAvLyAqKiogQ2FwdHVyaW5nIEdyb3VwIDI6IFRoZSBzbGFzaCBvciBhbiBlbXB0eSBzdHJpbmcuIFNsYXNoICgnLycpIGZvciBlbmQgdGFnLCBlbXB0eSBzdHJpbmcgZm9yIHN0YXJ0IG9yIHNlbGYtY2xvc2luZyB0YWcuXHJcblxyXG5cdFx0XHRcdFx0XHQvLyAqKiogQ2FwdHVyaW5nIEdyb3VwIDMgLSBUaGUgdGFnIG5hbWVcclxuXHRcdFx0XHRcdFx0JygnICsgdGFnTmFtZVJlZ2V4LnNvdXJjZSArICcpJyxcclxuXHJcblx0XHRcdFx0XHRcdC8vIFplcm8gb3IgbW9yZSBhdHRyaWJ1dGVzIGZvbGxvd2luZyB0aGUgdGFnIG5hbWVcclxuXHRcdFx0XHRcdFx0Jyg/OicsXHJcblx0XHRcdFx0XHRcdFx0J1xcXFxzKycsICAgICAgICAgICAgICAgIC8vIG9uZSBvciBtb3JlIHdoaXRlc3BhY2UgY2hhcnMgYmVmb3JlIGFuIGF0dHJpYnV0ZVxyXG5cdFx0XHRcdFx0XHRcdG5hbWVFcXVhbHNWYWx1ZVJlZ2V4LCAgLy8gYXR0cj1cInZhbHVlXCIgKHdpdGggb3B0aW9uYWwgPVwidmFsdWVcIiBwYXJ0KVxyXG5cdFx0XHRcdFx0XHQnKSonLFxyXG5cclxuXHRcdFx0XHRcdFx0J1xcXFxzKi8/JywgIC8vIGFueSB0cmFpbGluZyBzcGFjZXMgYW5kIG9wdGlvbmFsICcvJyBiZWZvcmUgdGhlIGNsb3NpbmcgJz4nXHJcblx0XHRcdFx0XHQnPicsXHJcblx0XHRcdFx0JyknXHJcblx0XHRcdF0uam9pbiggXCJcIiApLCAnZ2knICk7XHJcblx0XHR9ICkoKSxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBXYWxrcyBhbiBIVE1MIHN0cmluZywgY2FsbGluZyB0aGUgYG9wdGlvbnMucHJvY2Vzc0h0bWxOb2RlYCBmdW5jdGlvbiBmb3IgZWFjaCBIVE1MIHRhZyB0aGF0IGlzIGVuY291bnRlcmVkLCBhbmQgY2FsbGluZ1xyXG5cdFx0ICogdGhlIGBvcHRpb25zLnByb2Nlc3NUZXh0Tm9kZWAgZnVuY3Rpb24gd2hlbiBlYWNoIHRleHQgYXJvdW5kIEhUTUwgdGFncyBpcyBlbmNvdW50ZXJlZC5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGh0bWwgVGhlIEhUTUwgdG8gcGFyc2UuXHJcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFuIE9iamVjdCAobWFwKSB3aGljaCBtYXkgY29udGFpbiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcblx0XHQgKiBcclxuXHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLnByb2Nlc3NIdG1sTm9kZV0gQSB2aXNpdG9yIGZ1bmN0aW9uIHdoaWNoIGFsbG93cyBwcm9jZXNzaW5nIG9mIGFuIGVuY291bnRlcmVkIEhUTUwgbm9kZS5cclxuXHRcdCAqICAgVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCB0aGUgZm9sbG93aW5nIGFyZ3VtZW50czpcclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wcm9jZXNzSHRtbE5vZGUudGFnVGV4dF0gVGhlIEhUTUwgdGFnIHRleHQgdGhhdCB3YXMgZm91bmQuXHJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucHJvY2Vzc0h0bWxOb2RlLnRhZ05hbWVdIFRoZSB0YWcgbmFtZSBmb3IgdGhlIEhUTUwgdGFnIHRoYXQgd2FzIGZvdW5kLiBFeDogJ2EnIGZvciBhbiBhbmNob3IgdGFnLlxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnByb2Nlc3NIdG1sTm9kZS5pc0Nsb3NpbmdUYWddIGB0cnVlYCBpZiB0aGUgdGFnIGlzIGEgY2xvc2luZyB0YWcgKGV4OiAmbHQ7L2EmZ3Q7KSwgYGZhbHNlYCBvdGhlcndpc2UuXHJcblx0XHQgKiAgXHJcblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5wcm9jZXNzVGV4dE5vZGVdIEEgdmlzaXRvciBmdW5jdGlvbiB3aGljaCBhbGxvd3MgcHJvY2Vzc2luZyBvZiBhbiBlbmNvdW50ZXJlZCB0ZXh0IG5vZGUuXHJcblx0XHQgKiAgIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggdGhlIGZvbGxvd2luZyBhcmd1bWVudHM6XHJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucHJvY2Vzc1RleHROb2RlLnRleHRdIFRoZSB0ZXh0IG5vZGUgdGhhdCB3YXMgbWF0Y2hlZC5cclxuXHRcdCAqL1xyXG5cdFx0cGFyc2UgOiBmdW5jdGlvbiggaHRtbCwgb3B0aW9ucyApIHtcclxuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG5cdFx0XHR2YXIgcHJvY2Vzc0h0bWxOb2RlVmlzaXRvciA9IG9wdGlvbnMucHJvY2Vzc0h0bWxOb2RlIHx8IGZ1bmN0aW9uKCkge30sXHJcblx0XHRcdCAgICBwcm9jZXNzVGV4dE5vZGVWaXNpdG9yID0gb3B0aW9ucy5wcm9jZXNzVGV4dE5vZGUgfHwgZnVuY3Rpb24oKSB7fSxcclxuXHRcdFx0ICAgIGh0bWxSZWdleCA9IHRoaXMuaHRtbFJlZ2V4LFxyXG5cdFx0XHQgICAgY3VycmVudFJlc3VsdCxcclxuXHRcdFx0ICAgIGxhc3RJbmRleCA9IDA7XHJcblxyXG5cdFx0XHQvLyBMb29wIG92ZXIgdGhlIEhUTUwgc3RyaW5nLCBpZ25vcmluZyBIVE1MIHRhZ3MsIGFuZCBwcm9jZXNzaW5nIHRoZSB0ZXh0IHRoYXQgbGllcyBiZXR3ZWVuIHRoZW0sXHJcblx0XHRcdC8vIHdyYXBwaW5nIHRoZSBVUkxzIGluIGFuY2hvciB0YWdzXHJcblx0XHRcdHdoaWxlKCAoIGN1cnJlbnRSZXN1bHQgPSBodG1sUmVnZXguZXhlYyggaHRtbCApICkgIT09IG51bGwgKSB7XHJcblx0XHRcdFx0dmFyIHRhZ1RleHQgPSBjdXJyZW50UmVzdWx0WyAwIF0sXHJcblx0XHRcdFx0ICAgIHRhZ05hbWUgPSBjdXJyZW50UmVzdWx0WyAxIF0gfHwgY3VycmVudFJlc3VsdFsgMyBdLCAgLy8gVGhlIDwhRE9DVFlQRT4gdGFnIChleDogXCIhRE9DVFlQRVwiKSwgb3IgYW5vdGhlciB0YWcgKGV4OiBcImFcIikgXHJcblx0XHRcdFx0ICAgIGlzQ2xvc2luZ1RhZyA9ICEhY3VycmVudFJlc3VsdFsgMiBdLFxyXG5cdFx0XHRcdCAgICBpbkJldHdlZW5UYWdzVGV4dCA9IGh0bWwuc3Vic3RyaW5nKCBsYXN0SW5kZXgsIGN1cnJlbnRSZXN1bHQuaW5kZXggKTtcclxuXHJcblx0XHRcdFx0aWYoIGluQmV0d2VlblRhZ3NUZXh0ICkge1xyXG5cdFx0XHRcdFx0cHJvY2Vzc1RleHROb2RlVmlzaXRvciggaW5CZXR3ZWVuVGFnc1RleHQgKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHByb2Nlc3NIdG1sTm9kZVZpc2l0b3IoIHRhZ1RleHQsIHRhZ05hbWUudG9Mb3dlckNhc2UoKSwgaXNDbG9zaW5nVGFnICk7XHJcblxyXG5cdFx0XHRcdGxhc3RJbmRleCA9IGN1cnJlbnRSZXN1bHQuaW5kZXggKyB0YWdUZXh0Lmxlbmd0aDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gUHJvY2VzcyBhbnkgcmVtYWluaW5nIHRleHQgYWZ0ZXIgdGhlIGxhc3QgSFRNTCBlbGVtZW50LiBXaWxsIHByb2Nlc3MgYWxsIG9mIHRoZSB0ZXh0IGlmIHRoZXJlIHdlcmUgbm8gSFRNTCBlbGVtZW50cy5cclxuXHRcdFx0aWYoIGxhc3RJbmRleCA8IGh0bWwubGVuZ3RoICkge1xyXG5cdFx0XHRcdHZhciB0ZXh0ID0gaHRtbC5zdWJzdHJpbmcoIGxhc3RJbmRleCApO1xyXG5cclxuXHRcdFx0XHRpZiggdGV4dCApIHtcclxuXHRcdFx0XHRcdHByb2Nlc3NUZXh0Tm9kZVZpc2l0b3IoIHRleHQgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cdC8qZ2xvYmFsIEF1dG9saW5rZXIgKi9cclxuXHQvKmpzaGludCBib3NzOnRydWUgKi9cclxuXHQvKipcclxuXHQgKiBAY2xhc3MgQXV0b2xpbmtlci5IdG1sVGFnXHJcblx0ICogQGV4dGVuZHMgT2JqZWN0XHJcblx0ICogXHJcblx0ICogUmVwcmVzZW50cyBhbiBIVE1MIHRhZywgd2hpY2ggY2FuIGJlIHVzZWQgdG8gZWFzaWx5IGJ1aWxkL21vZGlmeSBIVE1MIHRhZ3MgcHJvZ3JhbW1hdGljYWxseS5cclxuXHQgKiBcclxuXHQgKiBBdXRvbGlua2VyIHVzZXMgdGhpcyBhYnN0cmFjdGlvbiB0byBjcmVhdGUgSFRNTCB0YWdzLCBhbmQgdGhlbiB3cml0ZSB0aGVtIG91dCBhcyBzdHJpbmdzLiBZb3UgbWF5IGFsc28gdXNlXHJcblx0ICogdGhpcyBjbGFzcyBpbiB5b3VyIGNvZGUsIGVzcGVjaWFsbHkgd2l0aGluIGEge0BsaW5rIEF1dG9saW5rZXIjcmVwbGFjZUZuIHJlcGxhY2VGbn0uXHJcblx0ICogXHJcblx0ICogIyMgRXhhbXBsZXNcclxuXHQgKiBcclxuXHQgKiBFeGFtcGxlIGluc3RhbnRpYXRpb246XHJcblx0ICogXHJcblx0ICogICAgIHZhciB0YWcgPSBuZXcgQXV0b2xpbmtlci5IdG1sVGFnKCB7XHJcblx0ICogICAgICAgICB0YWdOYW1lIDogJ2EnLFxyXG5cdCAqICAgICAgICAgYXR0cnMgICA6IHsgJ2hyZWYnOiAnaHR0cDovL2dvb2dsZS5jb20nLCAnY2xhc3MnOiAnZXh0ZXJuYWwtbGluaycgfSxcclxuXHQgKiAgICAgICAgIGlubmVySHRtbCA6ICdHb29nbGUnXHJcblx0ICogICAgIH0gKTtcclxuXHQgKiAgICAgXHJcblx0ICogICAgIHRhZy50b1N0cmluZygpOyAgLy8gPGEgaHJlZj1cImh0dHA6Ly9nb29nbGUuY29tXCIgY2xhc3M9XCJleHRlcm5hbC1saW5rXCI+R29vZ2xlPC9hPlxyXG5cdCAqICAgICBcclxuXHQgKiAgICAgLy8gSW5kaXZpZHVhbCBhY2Nlc3NvciBtZXRob2RzXHJcblx0ICogICAgIHRhZy5nZXRUYWdOYW1lKCk7ICAgICAgICAgICAgICAgICAvLyAnYSdcclxuXHQgKiAgICAgdGFnLmdldEF0dHIoICdocmVmJyApOyAgICAgICAgICAgIC8vICdodHRwOi8vZ29vZ2xlLmNvbSdcclxuXHQgKiAgICAgdGFnLmhhc0NsYXNzKCAnZXh0ZXJuYWwtbGluaycgKTsgIC8vIHRydWVcclxuXHQgKiBcclxuXHQgKiBcclxuXHQgKiBVc2luZyBtdXRhdG9yIG1ldGhvZHMgKHdoaWNoIG1heSBiZSB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggaW5zdGFudGlhdGlvbiBjb25maWcgcHJvcGVydGllcyk6XHJcblx0ICogXHJcblx0ICogICAgIHZhciB0YWcgPSBuZXcgQXV0b2xpbmtlci5IdG1sVGFnKCk7XHJcblx0ICogICAgIHRhZy5zZXRUYWdOYW1lKCAnYScgKTtcclxuXHQgKiAgICAgdGFnLnNldEF0dHIoICdocmVmJywgJ2h0dHA6Ly9nb29nbGUuY29tJyApO1xyXG5cdCAqICAgICB0YWcuYWRkQ2xhc3MoICdleHRlcm5hbC1saW5rJyApO1xyXG5cdCAqICAgICB0YWcuc2V0SW5uZXJIdG1sKCAnR29vZ2xlJyApO1xyXG5cdCAqICAgICBcclxuXHQgKiAgICAgdGFnLmdldFRhZ05hbWUoKTsgICAgICAgICAgICAgICAgIC8vICdhJ1xyXG5cdCAqICAgICB0YWcuZ2V0QXR0ciggJ2hyZWYnICk7ICAgICAgICAgICAgLy8gJ2h0dHA6Ly9nb29nbGUuY29tJ1xyXG5cdCAqICAgICB0YWcuaGFzQ2xhc3MoICdleHRlcm5hbC1saW5rJyApOyAgLy8gdHJ1ZVxyXG5cdCAqICAgICBcclxuXHQgKiAgICAgdGFnLnRvU3RyaW5nKCk7ICAvLyA8YSBocmVmPVwiaHR0cDovL2dvb2dsZS5jb21cIiBjbGFzcz1cImV4dGVybmFsLWxpbmtcIj5Hb29nbGU8L2E+XHJcblx0ICogICAgIFxyXG5cdCAqIFxyXG5cdCAqICMjIEV4YW1wbGUgdXNlIHdpdGhpbiBhIHtAbGluayBBdXRvbGlua2VyI3JlcGxhY2VGbiByZXBsYWNlRm59XHJcblx0ICogXHJcblx0ICogICAgIHZhciBodG1sID0gQXV0b2xpbmtlci5saW5rKCBcIlRlc3QgZ29vZ2xlLmNvbVwiLCB7XHJcblx0ICogICAgICAgICByZXBsYWNlRm4gOiBmdW5jdGlvbiggYXV0b2xpbmtlciwgbWF0Y2ggKSB7XHJcblx0ICogICAgICAgICAgICAgdmFyIHRhZyA9IGF1dG9saW5rZXIuZ2V0VGFnQnVpbGRlcigpLmJ1aWxkKCBtYXRjaCApOyAgLy8gcmV0dXJucyBhbiB7QGxpbmsgQXV0b2xpbmtlci5IdG1sVGFnfSBpbnN0YW5jZSwgY29uZmlndXJlZCB3aXRoIHRoZSBNYXRjaCdzIGhyZWYgYW5kIGFuY2hvciB0ZXh0XHJcblx0ICogICAgICAgICAgICAgdGFnLnNldEF0dHIoICdyZWwnLCAnbm9mb2xsb3cnICk7XHJcblx0ICogICAgICAgICAgICAgXHJcblx0ICogICAgICAgICAgICAgcmV0dXJuIHRhZztcclxuXHQgKiAgICAgICAgIH1cclxuXHQgKiAgICAgfSApO1xyXG5cdCAqICAgICBcclxuXHQgKiAgICAgLy8gZ2VuZXJhdGVkIGh0bWw6XHJcblx0ICogICAgIC8vICAgVGVzdCA8YSBocmVmPVwiaHR0cDovL2dvb2dsZS5jb21cIiB0YXJnZXQ9XCJfYmxhbmtcIiByZWw9XCJub2ZvbGxvd1wiPmdvb2dsZS5jb208L2E+XHJcblx0ICogICAgIFxyXG5cdCAqICAgICBcclxuXHQgKiAjIyBFeGFtcGxlIHVzZSB3aXRoIGEgbmV3IHRhZyBmb3IgdGhlIHJlcGxhY2VtZW50XHJcblx0ICogXHJcblx0ICogICAgIHZhciBodG1sID0gQXV0b2xpbmtlci5saW5rKCBcIlRlc3QgZ29vZ2xlLmNvbVwiLCB7XHJcblx0ICogICAgICAgICByZXBsYWNlRm4gOiBmdW5jdGlvbiggYXV0b2xpbmtlciwgbWF0Y2ggKSB7XHJcblx0ICogICAgICAgICAgICAgdmFyIHRhZyA9IG5ldyBBdXRvbGlua2VyLkh0bWxUYWcoIHtcclxuXHQgKiAgICAgICAgICAgICAgICAgdGFnTmFtZSA6ICdidXR0b24nLFxyXG5cdCAqICAgICAgICAgICAgICAgICBhdHRycyAgIDogeyAndGl0bGUnOiAnTG9hZCBVUkw6ICcgKyBtYXRjaC5nZXRBbmNob3JIcmVmKCkgfSxcclxuXHQgKiAgICAgICAgICAgICAgICAgaW5uZXJIdG1sIDogJ0xvYWQgVVJMOiAnICsgbWF0Y2guZ2V0QW5jaG9yVGV4dCgpXHJcblx0ICogICAgICAgICAgICAgfSApO1xyXG5cdCAqICAgICAgICAgICAgIFxyXG5cdCAqICAgICAgICAgICAgIHJldHVybiB0YWc7XHJcblx0ICogICAgICAgICB9XHJcblx0ICogICAgIH0gKTtcclxuXHQgKiAgICAgXHJcblx0ICogICAgIC8vIGdlbmVyYXRlZCBodG1sOlxyXG5cdCAqICAgICAvLyAgIFRlc3QgPGJ1dHRvbiB0aXRsZT1cIkxvYWQgVVJMOiBodHRwOi8vZ29vZ2xlLmNvbVwiPkxvYWQgVVJMOiBnb29nbGUuY29tPC9idXR0b24+XHJcblx0ICovXHJcblx0QXV0b2xpbmtlci5IdG1sVGFnID0gQXV0b2xpbmtlci5VdGlsLmV4dGVuZCggT2JqZWN0LCB7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBAY2ZnIHtTdHJpbmd9IHRhZ05hbWVcclxuXHRcdCAqIFxyXG5cdFx0ICogVGhlIHRhZyBuYW1lLiBFeDogJ2EnLCAnYnV0dG9uJywgZXRjLlxyXG5cdFx0ICogXHJcblx0XHQgKiBOb3QgcmVxdWlyZWQgYXQgaW5zdGFudGlhdGlvbiB0aW1lLCBidXQgc2hvdWxkIGJlIHNldCB1c2luZyB7QGxpbmsgI3NldFRhZ05hbWV9IGJlZm9yZSB7QGxpbmsgI3RvU3RyaW5nfVxyXG5cdFx0ICogaXMgZXhlY3V0ZWQuXHJcblx0XHQgKi9cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEBjZmcge09iamVjdC48U3RyaW5nLCBTdHJpbmc+fSBhdHRyc1xyXG5cdFx0ICogXHJcblx0XHQgKiBBbiBrZXkvdmFsdWUgT2JqZWN0IChtYXApIG9mIGF0dHJpYnV0ZXMgdG8gY3JlYXRlIHRoZSB0YWcgd2l0aC4gVGhlIGtleXMgYXJlIHRoZSBhdHRyaWJ1dGUgbmFtZXMsIGFuZCB0aGVcclxuXHRcdCAqIHZhbHVlcyBhcmUgdGhlIGF0dHJpYnV0ZSB2YWx1ZXMuXHJcblx0XHQgKi9cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEBjZmcge1N0cmluZ30gaW5uZXJIdG1sXHJcblx0XHQgKiBcclxuXHRcdCAqIFRoZSBpbm5lciBIVE1MIGZvciB0aGUgdGFnLiBcclxuXHRcdCAqIFxyXG5cdFx0ICogTm90ZSB0aGUgY2FtZWwgY2FzZSBuYW1lIG9uIGBpbm5lckh0bWxgLiBBY3JvbnltcyBhcmUgY2FtZWxDYXNlZCBpbiB0aGlzIHV0aWxpdHkgKHN1Y2ggYXMgbm90IHRvIHJ1biBpbnRvIHRoZSBhY3JvbnltIFxyXG5cdFx0ICogbmFtaW5nIGluY29uc2lzdGVuY3kgdGhhdCB0aGUgRE9NIGRldmVsb3BlcnMgY3JlYXRlZCB3aXRoIGBYTUxIdHRwUmVxdWVzdGApLiBZb3UgbWF5IGFsdGVybmF0aXZlbHkgdXNlIHtAbGluayAjaW5uZXJIVE1MfVxyXG5cdFx0ICogaWYgeW91IHByZWZlciwgYnV0IHRoaXMgb25lIGlzIHJlY29tbWVuZGVkLlxyXG5cdFx0ICovXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBAY2ZnIHtTdHJpbmd9IGlubmVySFRNTFxyXG5cdFx0ICogXHJcblx0XHQgKiBBbGlhcyBvZiB7QGxpbmsgI2lubmVySHRtbH0sIGFjY2VwdGVkIGZvciBjb25zaXN0ZW5jeSB3aXRoIHRoZSBicm93c2VyIERPTSBhcGksIGJ1dCBwcmVmZXIgdGhlIGNhbWVsQ2FzZWQgdmVyc2lvblxyXG5cdFx0ICogZm9yIGFjcm9ueW0gbmFtZXMuXHJcblx0XHQgKi9cclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBAcHJvdGVjdGVkXHJcblx0XHQgKiBAcHJvcGVydHkge1JlZ0V4cH0gd2hpdGVzcGFjZVJlZ2V4XHJcblx0XHQgKiBcclxuXHRcdCAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIG1hdGNoIHdoaXRlc3BhY2UgaW4gYSBzdHJpbmcgb2YgQ1NTIGNsYXNzZXMuXHJcblx0XHQgKi9cclxuXHRcdHdoaXRlc3BhY2VSZWdleCA6IC9cXHMrLyxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBAY29uc3RydWN0b3JcclxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBbY2ZnXSBUaGUgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIGZvciB0aGlzIGNsYXNzLCBpbiBhbiBPYmplY3QgKG1hcClcclxuXHRcdCAqL1xyXG5cdFx0Y29uc3RydWN0b3IgOiBmdW5jdGlvbiggY2ZnICkge1xyXG5cdFx0XHRBdXRvbGlua2VyLlV0aWwuYXNzaWduKCB0aGlzLCBjZmcgKTtcclxuXHJcblx0XHRcdHRoaXMuaW5uZXJIdG1sID0gdGhpcy5pbm5lckh0bWwgfHwgdGhpcy5pbm5lckhUTUw7ICAvLyBhY2NlcHQgZWl0aGVyIHRoZSBjYW1lbENhc2VkIGZvcm0gb3IgdGhlIGZ1bGx5IGNhcGl0YWxpemVkIGFjcm9ueW1cclxuXHRcdH0sXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogU2V0cyB0aGUgdGFnIG5hbWUgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRhZyB3aXRoLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdGFnTmFtZVxyXG5cdFx0ICogQHJldHVybiB7QXV0b2xpbmtlci5IdG1sVGFnfSBUaGlzIEh0bWxUYWcgaW5zdGFuY2UsIHNvIHRoYXQgbWV0aG9kIGNhbGxzIG1heSBiZSBjaGFpbmVkLlxyXG5cdFx0ICovXHJcblx0XHRzZXRUYWdOYW1lIDogZnVuY3Rpb24oIHRhZ05hbWUgKSB7XHJcblx0XHRcdHRoaXMudGFnTmFtZSA9IHRhZ05hbWU7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBSZXRyaWV2ZXMgdGhlIHRhZyBuYW1lLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XHJcblx0XHQgKi9cclxuXHRcdGdldFRhZ05hbWUgOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMudGFnTmFtZSB8fCBcIlwiO1xyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBTZXRzIGFuIGF0dHJpYnV0ZSBvbiB0aGUgSHRtbFRhZy5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGF0dHJOYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZSB0byBzZXQuXHJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gYXR0clZhbHVlIFRoZSBhdHRyaWJ1dGUgdmFsdWUgdG8gc2V0LlxyXG5cdFx0ICogQHJldHVybiB7QXV0b2xpbmtlci5IdG1sVGFnfSBUaGlzIEh0bWxUYWcgaW5zdGFuY2UsIHNvIHRoYXQgbWV0aG9kIGNhbGxzIG1heSBiZSBjaGFpbmVkLlxyXG5cdFx0ICovXHJcblx0XHRzZXRBdHRyIDogZnVuY3Rpb24oIGF0dHJOYW1lLCBhdHRyVmFsdWUgKSB7XHJcblx0XHRcdHZhciB0YWdBdHRycyA9IHRoaXMuZ2V0QXR0cnMoKTtcclxuXHRcdFx0dGFnQXR0cnNbIGF0dHJOYW1lIF0gPSBhdHRyVmFsdWU7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH0sXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogUmV0cmlldmVzIGFuIGF0dHJpYnV0ZSBmcm9tIHRoZSBIdG1sVGFnLiBJZiB0aGUgYXR0cmlidXRlIGRvZXMgbm90IGV4aXN0LCByZXR1cm5zIGB1bmRlZmluZWRgLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgYXR0cmlidXRlIG5hbWUgdG8gcmV0cmlldmUuXHJcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBhdHRyaWJ1dGUncyB2YWx1ZSwgb3IgYHVuZGVmaW5lZGAgaWYgaXQgZG9lcyBub3QgZXhpc3Qgb24gdGhlIEh0bWxUYWcuXHJcblx0XHQgKi9cclxuXHRcdGdldEF0dHIgOiBmdW5jdGlvbiggYXR0ck5hbWUgKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmdldEF0dHJzKClbIGF0dHJOYW1lIF07XHJcblx0XHR9LFxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFNldHMgb25lIG9yIG1vcmUgYXR0cmlidXRlcyBvbiB0aGUgSHRtbFRhZy5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHBhcmFtIHtPYmplY3QuPFN0cmluZywgU3RyaW5nPn0gYXR0cnMgQSBrZXkvdmFsdWUgT2JqZWN0IChtYXApIG9mIHRoZSBhdHRyaWJ1dGVzIHRvIHNldC5cclxuXHRcdCAqIEByZXR1cm4ge0F1dG9saW5rZXIuSHRtbFRhZ30gVGhpcyBIdG1sVGFnIGluc3RhbmNlLCBzbyB0aGF0IG1ldGhvZCBjYWxscyBtYXkgYmUgY2hhaW5lZC5cclxuXHRcdCAqL1xyXG5cdFx0c2V0QXR0cnMgOiBmdW5jdGlvbiggYXR0cnMgKSB7XHJcblx0XHRcdHZhciB0YWdBdHRycyA9IHRoaXMuZ2V0QXR0cnMoKTtcclxuXHRcdFx0QXV0b2xpbmtlci5VdGlsLmFzc2lnbiggdGFnQXR0cnMsIGF0dHJzICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH0sXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogUmV0cmlldmVzIHRoZSBhdHRyaWJ1dGVzIE9iamVjdCAobWFwKSBmb3IgdGhlIEh0bWxUYWcuXHJcblx0XHQgKiBcclxuXHRcdCAqIEByZXR1cm4ge09iamVjdC48U3RyaW5nLCBTdHJpbmc+fSBBIGtleS92YWx1ZSBvYmplY3Qgb2YgdGhlIGF0dHJpYnV0ZXMgZm9yIHRoZSBIdG1sVGFnLlxyXG5cdFx0ICovXHJcblx0XHRnZXRBdHRycyA6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRycyB8fCAoIHRoaXMuYXR0cnMgPSB7fSApO1xyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBTZXRzIHRoZSBwcm92aWRlZCBgY3NzQ2xhc3NgLCBvdmVyd3JpdGluZyBhbnkgY3VycmVudCBDU1MgY2xhc3NlcyBvbiB0aGUgSHRtbFRhZy5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGNzc0NsYXNzIE9uZSBvciBtb3JlIHNwYWNlLXNlcGFyYXRlZCBDU1MgY2xhc3NlcyB0byBzZXQgKG92ZXJ3cml0ZSkuXHJcblx0XHQgKiBAcmV0dXJuIHtBdXRvbGlua2VyLkh0bWxUYWd9IFRoaXMgSHRtbFRhZyBpbnN0YW5jZSwgc28gdGhhdCBtZXRob2QgY2FsbHMgbWF5IGJlIGNoYWluZWQuXHJcblx0XHQgKi9cclxuXHRcdHNldENsYXNzIDogZnVuY3Rpb24oIGNzc0NsYXNzICkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRBdHRyKCAnY2xhc3MnLCBjc3NDbGFzcyApO1xyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gYWRkIG9uZSBvciBtb3JlIENTUyBjbGFzc2VzIHRvIHRoZSBIdG1sVGFnLiBXaWxsIG5vdCBhZGQgZHVwbGljYXRlIENTUyBjbGFzc2VzLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gY3NzQ2xhc3MgT25lIG9yIG1vcmUgc3BhY2Utc2VwYXJhdGVkIENTUyBjbGFzc2VzIHRvIGFkZC5cclxuXHRcdCAqIEByZXR1cm4ge0F1dG9saW5rZXIuSHRtbFRhZ30gVGhpcyBIdG1sVGFnIGluc3RhbmNlLCBzbyB0aGF0IG1ldGhvZCBjYWxscyBtYXkgYmUgY2hhaW5lZC5cclxuXHRcdCAqL1xyXG5cdFx0YWRkQ2xhc3MgOiBmdW5jdGlvbiggY3NzQ2xhc3MgKSB7XHJcblx0XHRcdHZhciBjbGFzc0F0dHIgPSB0aGlzLmdldENsYXNzKCksXHJcblx0XHRcdCAgICB3aGl0ZXNwYWNlUmVnZXggPSB0aGlzLndoaXRlc3BhY2VSZWdleCxcclxuXHRcdFx0ICAgIGluZGV4T2YgPSBBdXRvbGlua2VyLlV0aWwuaW5kZXhPZiwgIC8vIHRvIHN1cHBvcnQgSUU4IGFuZCBiZWxvd1xyXG5cdFx0XHQgICAgY2xhc3NlcyA9ICggIWNsYXNzQXR0ciApID8gW10gOiBjbGFzc0F0dHIuc3BsaXQoIHdoaXRlc3BhY2VSZWdleCApLFxyXG5cdFx0XHQgICAgbmV3Q2xhc3NlcyA9IGNzc0NsYXNzLnNwbGl0KCB3aGl0ZXNwYWNlUmVnZXggKSxcclxuXHRcdFx0ICAgIG5ld0NsYXNzO1xyXG5cclxuXHRcdFx0d2hpbGUoIG5ld0NsYXNzID0gbmV3Q2xhc3Nlcy5zaGlmdCgpICkge1xyXG5cdFx0XHRcdGlmKCBpbmRleE9mKCBjbGFzc2VzLCBuZXdDbGFzcyApID09PSAtMSApIHtcclxuXHRcdFx0XHRcdGNsYXNzZXMucHVzaCggbmV3Q2xhc3MgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZ2V0QXR0cnMoKVsgJ2NsYXNzJyBdID0gY2xhc3Nlcy5qb2luKCBcIiBcIiApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH0sXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJlbW92ZSBvbmUgb3IgbW9yZSBDU1MgY2xhc3NlcyBmcm9tIHRoZSBIdG1sVGFnLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gY3NzQ2xhc3MgT25lIG9yIG1vcmUgc3BhY2Utc2VwYXJhdGVkIENTUyBjbGFzc2VzIHRvIHJlbW92ZS5cclxuXHRcdCAqIEByZXR1cm4ge0F1dG9saW5rZXIuSHRtbFRhZ30gVGhpcyBIdG1sVGFnIGluc3RhbmNlLCBzbyB0aGF0IG1ldGhvZCBjYWxscyBtYXkgYmUgY2hhaW5lZC5cclxuXHRcdCAqL1xyXG5cdFx0cmVtb3ZlQ2xhc3MgOiBmdW5jdGlvbiggY3NzQ2xhc3MgKSB7XHJcblx0XHRcdHZhciBjbGFzc0F0dHIgPSB0aGlzLmdldENsYXNzKCksXHJcblx0XHRcdCAgICB3aGl0ZXNwYWNlUmVnZXggPSB0aGlzLndoaXRlc3BhY2VSZWdleCxcclxuXHRcdFx0ICAgIGluZGV4T2YgPSBBdXRvbGlua2VyLlV0aWwuaW5kZXhPZiwgIC8vIHRvIHN1cHBvcnQgSUU4IGFuZCBiZWxvd1xyXG5cdFx0XHQgICAgY2xhc3NlcyA9ICggIWNsYXNzQXR0ciApID8gW10gOiBjbGFzc0F0dHIuc3BsaXQoIHdoaXRlc3BhY2VSZWdleCApLFxyXG5cdFx0XHQgICAgcmVtb3ZlQ2xhc3NlcyA9IGNzc0NsYXNzLnNwbGl0KCB3aGl0ZXNwYWNlUmVnZXggKSxcclxuXHRcdFx0ICAgIHJlbW92ZUNsYXNzO1xyXG5cclxuXHRcdFx0d2hpbGUoIGNsYXNzZXMubGVuZ3RoICYmICggcmVtb3ZlQ2xhc3MgPSByZW1vdmVDbGFzc2VzLnNoaWZ0KCkgKSApIHtcclxuXHRcdFx0XHR2YXIgaWR4ID0gaW5kZXhPZiggY2xhc3NlcywgcmVtb3ZlQ2xhc3MgKTtcclxuXHRcdFx0XHRpZiggaWR4ICE9PSAtMSApIHtcclxuXHRcdFx0XHRcdGNsYXNzZXMuc3BsaWNlKCBpZHgsIDEgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZ2V0QXR0cnMoKVsgJ2NsYXNzJyBdID0gY2xhc3Nlcy5qb2luKCBcIiBcIiApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH0sXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJldHJpZXZlIHRoZSBDU1MgY2xhc3MoZXMpIGZvciB0aGUgSHRtbFRhZywgd2hpY2ggd2lsbCBlYWNoIGJlIHNlcGFyYXRlZCBieSBzcGFjZXMgd2hlblxyXG5cdFx0ICogdGhlcmUgYXJlIG11bHRpcGxlLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XHJcblx0XHQgKi9cclxuXHRcdGdldENsYXNzIDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmdldEF0dHJzKClbICdjbGFzcycgXSB8fCBcIlwiO1xyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gY2hlY2sgaWYgdGhlIHRhZyBoYXMgYSBDU1MgY2xhc3Mgb3Igbm90LlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gY3NzQ2xhc3MgVGhlIENTUyBjbGFzcyB0byBjaGVjayBmb3IuXHJcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIEh0bWxUYWcgaGFzIHRoZSBDU1MgY2xhc3MsIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG5cdFx0ICovXHJcblx0XHRoYXNDbGFzcyA6IGZ1bmN0aW9uKCBjc3NDbGFzcyApIHtcclxuXHRcdFx0cmV0dXJuICggJyAnICsgdGhpcy5nZXRDbGFzcygpICsgJyAnICkuaW5kZXhPZiggJyAnICsgY3NzQ2xhc3MgKyAnICcgKSAhPT0gLTE7XHJcblx0XHR9LFxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFNldHMgdGhlIGlubmVyIEhUTUwgZm9yIHRoZSB0YWcuXHJcblx0XHQgKiBcclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBodG1sIFRoZSBpbm5lciBIVE1MIHRvIHNldC5cclxuXHRcdCAqIEByZXR1cm4ge0F1dG9saW5rZXIuSHRtbFRhZ30gVGhpcyBIdG1sVGFnIGluc3RhbmNlLCBzbyB0aGF0IG1ldGhvZCBjYWxscyBtYXkgYmUgY2hhaW5lZC5cclxuXHRcdCAqL1xyXG5cdFx0c2V0SW5uZXJIdG1sIDogZnVuY3Rpb24oIGh0bWwgKSB7XHJcblx0XHRcdHRoaXMuaW5uZXJIdG1sID0gaHRtbDtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBSZXRyaWV2ZXMgdGhlIGlubmVyIEhUTUwgZm9yIHRoZSB0YWcuXHJcblx0XHQgKiBcclxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cclxuXHRcdCAqL1xyXG5cdFx0Z2V0SW5uZXJIdG1sIDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmlubmVySHRtbCB8fCBcIlwiO1xyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBPdmVycmlkZSBvZiBzdXBlcmNsYXNzIG1ldGhvZCB1c2VkIHRvIGdlbmVyYXRlIHRoZSBIVE1MIHN0cmluZyBmb3IgdGhlIHRhZy5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfVxyXG5cdFx0ICovXHJcblx0XHR0b1N0cmluZyA6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR2YXIgdGFnTmFtZSA9IHRoaXMuZ2V0VGFnTmFtZSgpLFxyXG5cdFx0XHQgICAgYXR0cnNTdHIgPSB0aGlzLmJ1aWxkQXR0cnNTdHIoKTtcclxuXHJcblx0XHRcdGF0dHJzU3RyID0gKCBhdHRyc1N0ciApID8gJyAnICsgYXR0cnNTdHIgOiAnJzsgIC8vIHByZXBlbmQgYSBzcGFjZSBpZiB0aGVyZSBhcmUgYWN0dWFsbHkgYXR0cmlidXRlc1xyXG5cclxuXHRcdFx0cmV0dXJuIFsgJzwnLCB0YWdOYW1lLCBhdHRyc1N0ciwgJz4nLCB0aGlzLmdldElubmVySHRtbCgpLCAnPC8nLCB0YWdOYW1lLCAnPicgXS5qb2luKCBcIlwiICk7XHJcblx0XHR9LFxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFN1cHBvcnQgbWV0aG9kIGZvciB7QGxpbmsgI3RvU3RyaW5nfSwgcmV0dXJucyB0aGUgc3RyaW5nIHNwYWNlLXNlcGFyYXRlZCBrZXk9XCJ2YWx1ZVwiIHBhaXJzLCB1c2VkIHRvIHBvcHVsYXRlIFxyXG5cdFx0ICogdGhlIHN0cmluZ2lmaWVkIEh0bWxUYWcuXHJcblx0XHQgKiBcclxuXHRcdCAqIEBwcm90ZWN0ZWRcclxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ30gRXhhbXBsZSByZXR1cm46IGBhdHRyMT1cInZhbHVlMVwiIGF0dHIyPVwidmFsdWUyXCJgXHJcblx0XHQgKi9cclxuXHRcdGJ1aWxkQXR0cnNTdHIgOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0aWYoICF0aGlzLmF0dHJzICkgcmV0dXJuIFwiXCI7ICAvLyBubyBgYXR0cnNgIE9iamVjdCAobWFwKSBoYXMgYmVlbiBzZXQsIHJldHVybiBlbXB0eSBzdHJpbmdcclxuXHJcblx0XHRcdHZhciBhdHRycyA9IHRoaXMuZ2V0QXR0cnMoKSxcclxuXHRcdFx0ICAgIGF0dHJzQXJyID0gW107XHJcblxyXG5cdFx0XHRmb3IoIHZhciBwcm9wIGluIGF0dHJzICkge1xyXG5cdFx0XHRcdGlmKCBhdHRycy5oYXNPd25Qcm9wZXJ0eSggcHJvcCApICkge1xyXG5cdFx0XHRcdFx0YXR0cnNBcnIucHVzaCggcHJvcCArICc9XCInICsgYXR0cnNbIHByb3AgXSArICdcIicgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGF0dHJzQXJyLmpvaW4oIFwiIFwiICk7XHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHQvKmdsb2JhbCBBdXRvbGlua2VyICovXHJcblx0Lypqc2hpbnQgc2NyaXB0dXJsOnRydWUgKi9cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBjbGFzcyBBdXRvbGlua2VyLk1hdGNoVmFsaWRhdG9yXHJcblx0ICogQGV4dGVuZHMgT2JqZWN0XHJcblx0ICogXHJcblx0ICogVXNlZCBieSBBdXRvbGlua2VyIHRvIGZpbHRlciBvdXQgZmFsc2UgcG9zaXRpdmVzIGZyb20gdGhlIHtAbGluayBBdXRvbGlua2VyI21hdGNoZXJSZWdleH0uXHJcblx0ICogXHJcblx0ICogRHVlIHRvIHRoZSBsaW1pdGF0aW9ucyBvZiByZWd1bGFyIGV4cHJlc3Npb25zIChpbmNsdWRpbmcgdGhlIG1pc3NpbmcgZmVhdHVyZSBvZiBsb29rLWJlaGluZHMgaW4gSlMgcmVndWxhciBleHByZXNzaW9ucyksXHJcblx0ICogd2UgY2Fubm90IGFsd2F5cyBkZXRlcm1pbmUgdGhlIHZhbGlkaXR5IG9mIGEgZ2l2ZW4gbWF0Y2guIFRoaXMgY2xhc3MgYXBwbGllcyBhIGJpdCBvZiBhZGRpdGlvbmFsIGxvZ2ljIHRvIGZpbHRlciBvdXQgYW55XHJcblx0ICogZmFsc2UgcG9zaXRpdmVzIHRoYXQgaGF2ZSBiZWVuIG1hdGNoZWQgYnkgdGhlIHtAbGluayBBdXRvbGlua2VyI21hdGNoZXJSZWdleH0uXHJcblx0ICovXHJcblx0QXV0b2xpbmtlci5NYXRjaFZhbGlkYXRvciA9IEF1dG9saW5rZXIuVXRpbC5leHRlbmQoIE9iamVjdCwge1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEBwcm9wZXJ0eSB7UmVnRXhwfSBpbnZhbGlkUHJvdG9jb2xSZWxNYXRjaFJlZ2V4XHJcblx0XHQgKiBcclxuXHRcdCAqIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byBjaGVjayBhIHBvdGVudGlhbCBwcm90b2NvbC1yZWxhdGl2ZSBVUkwgbWF0Y2gsIGNvbWluZyBmcm9tIHRoZSBcclxuXHRcdCAqIHtAbGluayBBdXRvbGlua2VyI21hdGNoZXJSZWdleH0uIEEgcHJvdG9jb2wtcmVsYXRpdmUgVVJMIGlzLCBmb3IgZXhhbXBsZSwgXCIvL3lhaG9vLmNvbVwiXHJcblx0XHQgKiBcclxuXHRcdCAqIFRoaXMgcmVndWxhciBleHByZXNzaW9uIGNoZWNrcyB0byBzZWUgaWYgdGhlcmUgaXMgYSB3b3JkIGNoYXJhY3RlciBiZWZvcmUgdGhlICcvLycgbWF0Y2ggaW4gb3JkZXIgdG8gZGV0ZXJtaW5lIGlmIFxyXG5cdFx0ICogd2Ugc2hvdWxkIGFjdHVhbGx5IGF1dG9saW5rIGEgcHJvdG9jb2wtcmVsYXRpdmUgVVJMLiBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIHRoZXJlIGlzIG5vIG5lZ2F0aXZlIGxvb2stYmVoaW5kIGluIFxyXG5cdFx0ICogSmF2YVNjcmlwdCByZWd1bGFyIGV4cHJlc3Npb25zLiBcclxuXHRcdCAqIFxyXG5cdFx0ICogRm9yIGluc3RhbmNlLCB3ZSB3YW50IHRvIGF1dG9saW5rIHNvbWV0aGluZyBsaWtlIFwiR28gdG86IC8vZ29vZ2xlLmNvbVwiLCBidXQgd2UgZG9uJ3Qgd2FudCB0byBhdXRvbGluayBzb21ldGhpbmcgXHJcblx0XHQgKiBsaWtlIFwiYWJjLy9nb29nbGUuY29tXCJcclxuXHRcdCAqL1xyXG5cdFx0aW52YWxpZFByb3RvY29sUmVsTWF0Y2hSZWdleCA6IC9eW1xcd11cXC9cXC8vLFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogUmVnZXggdG8gdGVzdCBmb3IgYSBmdWxsIHByb3RvY29sLCB3aXRoIHRoZSB0d28gdHJhaWxpbmcgc2xhc2hlcy4gRXg6ICdodHRwOi8vJ1xyXG5cdFx0ICogXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHByb3BlcnR5IHtSZWdFeHB9IGhhc0Z1bGxQcm90b2NvbFJlZ2V4XHJcblx0XHQgKi9cclxuXHRcdGhhc0Z1bGxQcm90b2NvbFJlZ2V4IDogL15bQS1aYS16XVstLitBLVphLXowLTldKzpcXC9cXC8vLFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogUmVnZXggdG8gZmluZCB0aGUgVVJJIHNjaGVtZSwgc3VjaCBhcyAnbWFpbHRvOicuXHJcblx0XHQgKiBcclxuXHRcdCAqIFRoaXMgaXMgdXNlZCB0byBmaWx0ZXIgb3V0ICdqYXZhc2NyaXB0OicgYW5kICd2YnNjcmlwdDonIHNjaGVtZXMuXHJcblx0XHQgKiBcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAcHJvcGVydHkge1JlZ0V4cH0gdXJpU2NoZW1lUmVnZXhcclxuXHRcdCAqL1xyXG5cdFx0dXJpU2NoZW1lUmVnZXggOiAvXltBLVphLXpdWy0uK0EtWmEtejAtOV0rOi8sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBSZWdleCB0byBkZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIHdvcmQgY2hhciBleGlzdHMgYWZ0ZXIgdGhlIHByb3RvY29sIChpLmUuIGFmdGVyIHRoZSAnOicpXHJcblx0XHQgKiBcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAcHJvcGVydHkge1JlZ0V4cH0gaGFzV29yZENoYXJBZnRlclByb3RvY29sUmVnZXhcclxuXHRcdCAqL1xyXG5cdFx0aGFzV29yZENoYXJBZnRlclByb3RvY29sUmVnZXggOiAvOlteXFxzXSo/W0EtWmEtel0vLFxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIERldGVybWluZXMgaWYgYSBnaXZlbiBtYXRjaCBmb3VuZCBieSB7QGxpbmsgQXV0b2xpbmtlciNwcm9jZXNzVGV4dE5vZGV9IGlzIHZhbGlkLiBXaWxsIHJldHVybiBgZmFsc2VgIGZvcjpcclxuXHRcdCAqIFxyXG5cdFx0ICogMSkgVVJMIG1hdGNoZXMgd2hpY2ggZG8gbm90IGhhdmUgYXQgbGVhc3QgaGF2ZSBvbmUgcGVyaW9kICgnLicpIGluIHRoZSBkb21haW4gbmFtZSAoZWZmZWN0aXZlbHkgc2tpcHBpbmcgb3ZlciBcclxuXHRcdCAqICAgIG1hdGNoZXMgbGlrZSBcImFiYzpkZWZcIikuIEhvd2V2ZXIsIFVSTCBtYXRjaGVzIHdpdGggYSBwcm90b2NvbCB3aWxsIGJlIGFsbG93ZWQgKGV4OiAnaHR0cDovL2xvY2FsaG9zdCcpXHJcblx0XHQgKiAyKSBVUkwgbWF0Y2hlcyB3aGljaCBkbyBub3QgaGF2ZSBhdCBsZWFzdCBvbmUgd29yZCBjaGFyYWN0ZXIgaW4gdGhlIGRvbWFpbiBuYW1lIChlZmZlY3RpdmVseSBza2lwcGluZyBvdmVyXHJcblx0XHQgKiAgICBtYXRjaGVzIGxpa2UgXCJnaXQ6MS4wXCIpLlxyXG5cdFx0ICogMykgQSBwcm90b2NvbC1yZWxhdGl2ZSB1cmwgbWF0Y2ggKGEgVVJMIGJlZ2lubmluZyB3aXRoICcvLycpIHdob3NlIHByZXZpb3VzIGNoYXJhY3RlciBpcyBhIHdvcmQgY2hhcmFjdGVyIFxyXG5cdFx0ICogICAgKGVmZmVjdGl2ZWx5IHNraXBwaW5nIG92ZXIgc3RyaW5ncyBsaWtlIFwiYWJjLy9nb29nbGUuY29tXCIpXHJcblx0XHQgKiBcclxuXHRcdCAqIE90aGVyd2lzZSwgcmV0dXJucyBgdHJ1ZWAuXHJcblx0XHQgKiBcclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB1cmxNYXRjaCBUaGUgbWF0Y2hlZCBVUkwsIGlmIHRoZXJlIHdhcyBvbmUuIFdpbGwgYmUgYW4gZW1wdHkgc3RyaW5nIGlmIHRoZSBtYXRjaCBpcyBub3QgYSBVUkwgbWF0Y2guXHJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gcHJvdG9jb2xVcmxNYXRjaCBUaGUgbWF0Y2ggVVJMIHN0cmluZyBmb3IgYSBwcm90b2NvbCBtYXRjaC4gRXg6ICdodHRwOi8veWFob28uY29tJy4gVGhpcyBpcyB1c2VkIHRvIG1hdGNoXHJcblx0XHQgKiAgIHNvbWV0aGluZyBsaWtlICdodHRwOi8vbG9jYWxob3N0Jywgd2hlcmUgd2Ugd29uJ3QgZG91YmxlIGNoZWNrIHRoYXQgdGhlIGRvbWFpbiBuYW1lIGhhcyBhdCBsZWFzdCBvbmUgJy4nIGluIGl0LlxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sUmVsYXRpdmVNYXRjaCBUaGUgcHJvdG9jb2wtcmVsYXRpdmUgc3RyaW5nIGZvciBhIFVSTCBtYXRjaCAoaS5lLiAnLy8nKSwgcG9zc2libHkgd2l0aCBhIHByZWNlZGluZ1xyXG5cdFx0ICogICBjaGFyYWN0ZXIgKGV4LCBhIHNwYWNlLCBzdWNoIGFzOiAnIC8vJywgb3IgYSBsZXR0ZXIsIHN1Y2ggYXM6ICdhLy8nKS4gVGhlIG1hdGNoIGlzIGludmFsaWQgaWYgdGhlcmUgaXMgYSB3b3JkIGNoYXJhY3RlclxyXG5cdFx0ICogICBwcmVjZWRpbmcgdGhlICcvLycuXHJcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIG1hdGNoIGdpdmVuIGlzIHZhbGlkIGFuZCBzaG91bGQgYmUgcHJvY2Vzc2VkLCBvciBgZmFsc2VgIGlmIHRoZSBtYXRjaCBpcyBpbnZhbGlkIGFuZC9vciBcclxuXHRcdCAqICAgc2hvdWxkIGp1c3Qgbm90IGJlIHByb2Nlc3NlZC5cclxuXHRcdCAqL1xyXG5cdFx0aXNWYWxpZE1hdGNoIDogZnVuY3Rpb24oIHVybE1hdGNoLCBwcm90b2NvbFVybE1hdGNoLCBwcm90b2NvbFJlbGF0aXZlTWF0Y2ggKSB7XHJcblx0XHRcdGlmKFxyXG5cdFx0XHRcdCggcHJvdG9jb2xVcmxNYXRjaCAmJiAhdGhpcy5pc1ZhbGlkVXJpU2NoZW1lKCBwcm90b2NvbFVybE1hdGNoICkgKSB8fFxyXG5cdFx0XHRcdHRoaXMudXJsTWF0Y2hEb2VzTm90SGF2ZVByb3RvY29sT3JEb3QoIHVybE1hdGNoLCBwcm90b2NvbFVybE1hdGNoICkgfHwgICAgICAgLy8gQXQgbGVhc3Qgb25lIHBlcmlvZCAoJy4nKSBtdXN0IGV4aXN0IGluIHRoZSBVUkwgbWF0Y2ggZm9yIHVzIHRvIGNvbnNpZGVyIGl0IGFuIGFjdHVhbCBVUkwsICp1bmxlc3MqIGl0IHdhcyBhIGZ1bGwgcHJvdG9jb2wgbWF0Y2ggKGxpa2UgJ2h0dHA6Ly9sb2NhbGhvc3QnKVxyXG5cdFx0XHRcdHRoaXMudXJsTWF0Y2hEb2VzTm90SGF2ZUF0TGVhc3RPbmVXb3JkQ2hhciggdXJsTWF0Y2gsIHByb3RvY29sVXJsTWF0Y2ggKSB8fCAgLy8gQXQgbGVhc3Qgb25lIGxldHRlciBjaGFyYWN0ZXIgbXVzdCBleGlzdCBpbiB0aGUgZG9tYWluIG5hbWUgYWZ0ZXIgYSBwcm90b2NvbCBtYXRjaC4gRXg6IHNraXAgb3ZlciBzb21ldGhpbmcgbGlrZSBcImdpdDoxLjBcIlxyXG5cdFx0XHRcdHRoaXMuaXNJbnZhbGlkUHJvdG9jb2xSZWxhdGl2ZU1hdGNoKCBwcm90b2NvbFJlbGF0aXZlTWF0Y2ggKSAgICAgICAgICAgICAgICAgLy8gQSBwcm90b2NvbC1yZWxhdGl2ZSBtYXRjaCB3aGljaCBoYXMgYSB3b3JkIGNoYXJhY3RlciBpbiBmcm9udCBvZiBpdCAoc28gd2UgY2FuIHNraXAgc29tZXRoaW5nIGxpa2UgXCJhYmMvL2dvb2dsZS5jb21cIilcclxuXHRcdFx0KSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0sXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgVVJJIHNjaGVtZSBpcyBhIHZhbGlkIHNjaGVtZSB0byBiZSBhdXRvbGlua2VkLiBSZXR1cm5zIGBmYWxzZWAgaWYgdGhlIHNjaGVtZSBpcyBcclxuXHRcdCAqICdqYXZhc2NyaXB0Oicgb3IgJ3Zic2NyaXB0OidcclxuXHRcdCAqIFxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB1cmlTY2hlbWVNYXRjaCBUaGUgbWF0Y2ggVVJMIHN0cmluZyBmb3IgYSBmdWxsIFVSSSBzY2hlbWUgbWF0Y2guIEV4OiAnaHR0cDovL3lhaG9vLmNvbScgXHJcblx0XHQgKiAgIG9yICdtYWlsdG86YUBhLmNvbScuXHJcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHNjaGVtZSBpcyBhIHZhbGlkIG9uZSwgYGZhbHNlYCBvdGhlcndpc2UuXHJcblx0XHQgKi9cclxuXHRcdGlzVmFsaWRVcmlTY2hlbWUgOiBmdW5jdGlvbiggdXJpU2NoZW1lTWF0Y2ggKSB7XHJcblx0XHRcdHZhciB1cmlTY2hlbWUgPSB1cmlTY2hlbWVNYXRjaC5tYXRjaCggdGhpcy51cmlTY2hlbWVSZWdleCApWyAwIF07XHJcblxyXG5cdFx0XHRyZXR1cm4gKCB1cmlTY2hlbWUgIT09ICdqYXZhc2NyaXB0OicgJiYgdXJpU2NoZW1lICE9PSAndmJzY3JpcHQ6JyApO1xyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBEZXRlcm1pbmVzIGlmIGEgVVJMIG1hdGNoIGRvZXMgbm90IGhhdmUgZWl0aGVyOlxyXG5cdFx0ICogXHJcblx0XHQgKiBhKSBhIGZ1bGwgcHJvdG9jb2wgKGkuZS4gJ2h0dHA6Ly8nKSwgb3JcclxuXHRcdCAqIGIpIGF0IGxlYXN0IG9uZSBkb3QgKCcuJykgaW4gdGhlIGRvbWFpbiBuYW1lIChmb3IgYSBub24tZnVsbC1wcm90b2NvbCBtYXRjaCkuXHJcblx0XHQgKiBcclxuXHRcdCAqIEVpdGhlciBzaXR1YXRpb24gaXMgY29uc2lkZXJlZCBhbiBpbnZhbGlkIFVSTCAoZXg6ICdnaXQ6ZCcgZG9lcyBub3QgaGF2ZSBlaXRoZXIgdGhlICc6Ly8nIHBhcnQsIG9yIGF0IGxlYXN0IG9uZSBkb3RcclxuXHRcdCAqIGluIHRoZSBkb21haW4gbmFtZS4gSWYgdGhlIG1hdGNoIHdhcyAnZ2l0OmFiYy5jb20nLCB3ZSB3b3VsZCBjb25zaWRlciB0aGlzIHZhbGlkLilcclxuXHRcdCAqIFxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB1cmxNYXRjaCBUaGUgbWF0Y2hlZCBVUkwsIGlmIHRoZXJlIHdhcyBvbmUuIFdpbGwgYmUgYW4gZW1wdHkgc3RyaW5nIGlmIHRoZSBtYXRjaCBpcyBub3QgYSBVUkwgbWF0Y2guXHJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gcHJvdG9jb2xVcmxNYXRjaCBUaGUgbWF0Y2ggVVJMIHN0cmluZyBmb3IgYSBwcm90b2NvbCBtYXRjaC4gRXg6ICdodHRwOi8veWFob28uY29tJy4gVGhpcyBpcyB1c2VkIHRvIG1hdGNoXHJcblx0XHQgKiAgIHNvbWV0aGluZyBsaWtlICdodHRwOi8vbG9jYWxob3N0Jywgd2hlcmUgd2Ugd29uJ3QgZG91YmxlIGNoZWNrIHRoYXQgdGhlIGRvbWFpbiBuYW1lIGhhcyBhdCBsZWFzdCBvbmUgJy4nIGluIGl0LlxyXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBVUkwgbWF0Y2ggZG9lcyBub3QgaGF2ZSBhIGZ1bGwgcHJvdG9jb2wsIG9yIGF0IGxlYXN0IG9uZSBkb3QgKCcuJykgaW4gYSBub24tZnVsbC1wcm90b2NvbFxyXG5cdFx0ICogICBtYXRjaC5cclxuXHRcdCAqL1xyXG5cdFx0dXJsTWF0Y2hEb2VzTm90SGF2ZVByb3RvY29sT3JEb3QgOiBmdW5jdGlvbiggdXJsTWF0Y2gsIHByb3RvY29sVXJsTWF0Y2ggKSB7XHJcblx0XHRcdHJldHVybiAoICEhdXJsTWF0Y2ggJiYgKCAhcHJvdG9jb2xVcmxNYXRjaCB8fCAhdGhpcy5oYXNGdWxsUHJvdG9jb2xSZWdleC50ZXN0KCBwcm90b2NvbFVybE1hdGNoICkgKSAmJiB1cmxNYXRjaC5pbmRleE9mKCAnLicgKSA9PT0gLTEgKTtcclxuXHRcdH0sXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogRGV0ZXJtaW5lcyBpZiBhIFVSTCBtYXRjaCBkb2VzIG5vdCBoYXZlIGF0IGxlYXN0IG9uZSB3b3JkIGNoYXJhY3RlciBhZnRlciB0aGUgcHJvdG9jb2wgKGkuZS4gaW4gdGhlIGRvbWFpbiBuYW1lKS5cclxuXHRcdCAqIFxyXG5cdFx0ICogQXQgbGVhc3Qgb25lIGxldHRlciBjaGFyYWN0ZXIgbXVzdCBleGlzdCBpbiB0aGUgZG9tYWluIG5hbWUgYWZ0ZXIgYSBwcm90b2NvbCBtYXRjaC4gRXg6IHNraXAgb3ZlciBzb21ldGhpbmcgXHJcblx0XHQgKiBsaWtlIFwiZ2l0OjEuMFwiXHJcblx0XHQgKiBcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdXJsTWF0Y2ggVGhlIG1hdGNoZWQgVVJMLCBpZiB0aGVyZSB3YXMgb25lLiBXaWxsIGJlIGFuIGVtcHR5IHN0cmluZyBpZiB0aGUgbWF0Y2ggaXMgbm90IGEgVVJMIG1hdGNoLlxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sVXJsTWF0Y2ggVGhlIG1hdGNoIFVSTCBzdHJpbmcgZm9yIGEgcHJvdG9jb2wgbWF0Y2guIEV4OiAnaHR0cDovL3lhaG9vLmNvbScuIFRoaXMgaXMgdXNlZCB0b1xyXG5cdFx0ICogICBrbm93IHdoZXRoZXIgb3Igbm90IHdlIGhhdmUgYSBwcm90b2NvbCBpbiB0aGUgVVJMIHN0cmluZywgaW4gb3JkZXIgdG8gY2hlY2sgZm9yIGEgd29yZCBjaGFyYWN0ZXIgYWZ0ZXIgdGhlIHByb3RvY29sXHJcblx0XHQgKiAgIHNlcGFyYXRvciAoJzonKS5cclxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgVVJMIG1hdGNoIGRvZXMgbm90IGhhdmUgYXQgbGVhc3Qgb25lIHdvcmQgY2hhcmFjdGVyIGluIGl0IGFmdGVyIHRoZSBwcm90b2NvbCwgYGZhbHNlYFxyXG5cdFx0ICogICBvdGhlcndpc2UuXHJcblx0XHQgKi9cclxuXHRcdHVybE1hdGNoRG9lc05vdEhhdmVBdExlYXN0T25lV29yZENoYXIgOiBmdW5jdGlvbiggdXJsTWF0Y2gsIHByb3RvY29sVXJsTWF0Y2ggKSB7XHJcblx0XHRcdGlmKCB1cmxNYXRjaCAmJiBwcm90b2NvbFVybE1hdGNoICkge1xyXG5cdFx0XHRcdHJldHVybiAhdGhpcy5oYXNXb3JkQ2hhckFmdGVyUHJvdG9jb2xSZWdleC50ZXN0KCB1cmxNYXRjaCApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBEZXRlcm1pbmVzIGlmIGEgcHJvdG9jb2wtcmVsYXRpdmUgbWF0Y2ggaXMgYW4gaW52YWxpZCBvbmUuIFRoaXMgbWV0aG9kIHJldHVybnMgYHRydWVgIGlmIHRoZXJlIGlzIGEgYHByb3RvY29sUmVsYXRpdmVNYXRjaGAsXHJcblx0XHQgKiBhbmQgdGhhdCBtYXRjaCBjb250YWlucyBhIHdvcmQgY2hhcmFjdGVyIGJlZm9yZSB0aGUgJy8vJyAoaS5lLiBpdCBtdXN0IGNvbnRhaW4gd2hpdGVzcGFjZSBvciBub3RoaW5nIGJlZm9yZSB0aGUgJy8vJyBpblxyXG5cdFx0ICogb3JkZXIgdG8gYmUgY29uc2lkZXJlZCB2YWxpZCkuXHJcblx0XHQgKiBcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gcHJvdG9jb2xSZWxhdGl2ZU1hdGNoIFRoZSBwcm90b2NvbC1yZWxhdGl2ZSBzdHJpbmcgZm9yIGEgVVJMIG1hdGNoIChpLmUuICcvLycpLCBwb3NzaWJseSB3aXRoIGEgcHJlY2VkaW5nXHJcblx0XHQgKiAgIGNoYXJhY3RlciAoZXgsIGEgc3BhY2UsIHN1Y2ggYXM6ICcgLy8nLCBvciBhIGxldHRlciwgc3VjaCBhczogJ2EvLycpLiBUaGUgbWF0Y2ggaXMgaW52YWxpZCBpZiB0aGVyZSBpcyBhIHdvcmQgY2hhcmFjdGVyXHJcblx0XHQgKiAgIHByZWNlZGluZyB0aGUgJy8vJy5cclxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBpdCBpcyBhbiBpbnZhbGlkIHByb3RvY29sLXJlbGF0aXZlIG1hdGNoLCBgZmFsc2VgIG90aGVyd2lzZS5cclxuXHRcdCAqL1xyXG5cdFx0aXNJbnZhbGlkUHJvdG9jb2xSZWxhdGl2ZU1hdGNoIDogZnVuY3Rpb24oIHByb3RvY29sUmVsYXRpdmVNYXRjaCApIHtcclxuXHRcdFx0cmV0dXJuICggISFwcm90b2NvbFJlbGF0aXZlTWF0Y2ggJiYgdGhpcy5pbnZhbGlkUHJvdG9jb2xSZWxNYXRjaFJlZ2V4LnRlc3QoIHByb3RvY29sUmVsYXRpdmVNYXRjaCApICk7XHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHQvKmdsb2JhbCBBdXRvbGlua2VyICovXHJcblx0Lypqc2hpbnQgc3ViOnRydWUgKi9cclxuXHQvKipcclxuXHQgKiBAcHJvdGVjdGVkXHJcblx0ICogQGNsYXNzIEF1dG9saW5rZXIuQW5jaG9yVGFnQnVpbGRlclxyXG5cdCAqIEBleHRlbmRzIE9iamVjdFxyXG5cdCAqIFxyXG5cdCAqIEJ1aWxkcyBhbmNob3IgKCZsdDthJmd0OykgdGFncyBmb3IgdGhlIEF1dG9saW5rZXIgdXRpbGl0eSB3aGVuIGEgbWF0Y2ggaXMgZm91bmQuXHJcblx0ICogXHJcblx0ICogTm9ybWFsbHkgdGhpcyBjbGFzcyBpcyBpbnN0YW50aWF0ZWQsIGNvbmZpZ3VyZWQsIGFuZCB1c2VkIGludGVybmFsbHkgYnkgYW4ge0BsaW5rIEF1dG9saW5rZXJ9IGluc3RhbmNlLCBidXQgbWF5IFxyXG5cdCAqIGFjdHVhbGx5IGJlIHJldHJpZXZlZCBpbiBhIHtAbGluayBBdXRvbGlua2VyI3JlcGxhY2VGbiByZXBsYWNlRm59IHRvIGNyZWF0ZSB7QGxpbmsgQXV0b2xpbmtlci5IdG1sVGFnIEh0bWxUYWd9IGluc3RhbmNlc1xyXG5cdCAqIHdoaWNoIG1heSBiZSBtb2RpZmllZCBiZWZvcmUgcmV0dXJuaW5nIGZyb20gdGhlIHtAbGluayBBdXRvbGlua2VyI3JlcGxhY2VGbiByZXBsYWNlRm59LiBGb3IgZXhhbXBsZTpcclxuXHQgKiBcclxuXHQgKiAgICAgdmFyIGh0bWwgPSBBdXRvbGlua2VyLmxpbmsoIFwiVGVzdCBnb29nbGUuY29tXCIsIHtcclxuXHQgKiAgICAgICAgIHJlcGxhY2VGbiA6IGZ1bmN0aW9uKCBhdXRvbGlua2VyLCBtYXRjaCApIHtcclxuXHQgKiAgICAgICAgICAgICB2YXIgdGFnID0gYXV0b2xpbmtlci5nZXRUYWdCdWlsZGVyKCkuYnVpbGQoIG1hdGNoICk7ICAvLyByZXR1cm5zIGFuIHtAbGluayBBdXRvbGlua2VyLkh0bWxUYWd9IGluc3RhbmNlXHJcblx0ICogICAgICAgICAgICAgdGFnLnNldEF0dHIoICdyZWwnLCAnbm9mb2xsb3cnICk7XHJcblx0ICogICAgICAgICAgICAgXHJcblx0ICogICAgICAgICAgICAgcmV0dXJuIHRhZztcclxuXHQgKiAgICAgICAgIH1cclxuXHQgKiAgICAgfSApO1xyXG5cdCAqICAgICBcclxuXHQgKiAgICAgLy8gZ2VuZXJhdGVkIGh0bWw6XHJcblx0ICogICAgIC8vICAgVGVzdCA8YSBocmVmPVwiaHR0cDovL2dvb2dsZS5jb21cIiB0YXJnZXQ9XCJfYmxhbmtcIiByZWw9XCJub2ZvbGxvd1wiPmdvb2dsZS5jb208L2E+XHJcblx0ICovXHJcblx0QXV0b2xpbmtlci5BbmNob3JUYWdCdWlsZGVyID0gQXV0b2xpbmtlci5VdGlsLmV4dGVuZCggT2JqZWN0LCB7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBAY2ZnIHtCb29sZWFufSBuZXdXaW5kb3dcclxuXHRcdCAqIEBpbmhlcml0ZG9jIEF1dG9saW5rZXIjbmV3V2luZG93XHJcblx0XHQgKi9cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEBjZmcge051bWJlcn0gdHJ1bmNhdGVcclxuXHRcdCAqIEBpbmhlcml0ZG9jIEF1dG9saW5rZXIjdHJ1bmNhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQGNmZyB7U3RyaW5nfSBjbGFzc05hbWVcclxuXHRcdCAqIEBpbmhlcml0ZG9jIEF1dG9saW5rZXIjY2xhc3NOYW1lXHJcblx0XHQgKi9cclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBAY29uc3RydWN0b3JcclxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBbY2ZnXSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgQW5jaG9yVGFnQnVpbGRlciBpbnN0YW5jZSwgc3BlY2lmaWVkIGluIGFuIE9iamVjdCAobWFwKS5cclxuXHRcdCAqL1xyXG5cdFx0Y29uc3RydWN0b3IgOiBmdW5jdGlvbiggY2ZnICkge1xyXG5cdFx0XHRBdXRvbGlua2VyLlV0aWwuYXNzaWduKCB0aGlzLCBjZmcgKTtcclxuXHRcdH0sXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogR2VuZXJhdGVzIHRoZSBhY3R1YWwgYW5jaG9yICgmbHQ7YSZndDspIHRhZyB0byB1c2UgaW4gcGxhY2Ugb2YgdGhlIG1hdGNoZWQgVVJML2VtYWlsL1R3aXR0ZXIgdGV4dCxcclxuXHRcdCAqIHZpYSBpdHMgYG1hdGNoYCBvYmplY3QuXHJcblx0XHQgKiBcclxuXHRcdCAqIEBwYXJhbSB7QXV0b2xpbmtlci5tYXRjaC5NYXRjaH0gbWF0Y2ggVGhlIE1hdGNoIGluc3RhbmNlIHRvIGdlbmVyYXRlIGFuIGFuY2hvciB0YWcgZnJvbS5cclxuXHRcdCAqIEByZXR1cm4ge0F1dG9saW5rZXIuSHRtbFRhZ30gVGhlIEh0bWxUYWcgaW5zdGFuY2UgZm9yIHRoZSBhbmNob3IgdGFnLlxyXG5cdFx0ICovXHJcblx0XHRidWlsZCA6IGZ1bmN0aW9uKCBtYXRjaCApIHtcclxuXHRcdFx0dmFyIHRhZyA9IG5ldyBBdXRvbGlua2VyLkh0bWxUYWcoIHtcclxuXHRcdFx0XHR0YWdOYW1lICAgOiAnYScsXHJcblx0XHRcdFx0YXR0cnMgICAgIDogdGhpcy5jcmVhdGVBdHRycyggbWF0Y2guZ2V0VHlwZSgpLCBtYXRjaC5nZXRBbmNob3JIcmVmKCkgKSxcclxuXHRcdFx0XHRpbm5lckh0bWwgOiB0aGlzLnByb2Nlc3NBbmNob3JUZXh0KCBtYXRjaC5nZXRBbmNob3JUZXh0KCkgKVxyXG5cdFx0XHR9ICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGFnO1xyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBDcmVhdGVzIHRoZSBPYmplY3QgKG1hcCkgb2YgdGhlIEhUTUwgYXR0cmlidXRlcyBmb3IgdGhlIGFuY2hvciAoJmx0O2EmZ3Q7KSB0YWcgYmVpbmcgZ2VuZXJhdGVkLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcHJvdGVjdGVkXHJcblx0XHQgKiBAcGFyYW0ge1widXJsXCIvXCJlbWFpbFwiL1widHdpdHRlclwifSBtYXRjaFR5cGUgVGhlIHR5cGUgb2YgbWF0Y2ggdGhhdCBhbiBhbmNob3IgdGFnIGlzIGJlaW5nIGdlbmVyYXRlZCBmb3IuXHJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gaHJlZiBUaGUgaHJlZiBmb3IgdGhlIGFuY2hvciB0YWcuXHJcblx0XHQgKiBAcmV0dXJuIHtPYmplY3R9IEEga2V5L3ZhbHVlIE9iamVjdCAobWFwKSBvZiB0aGUgYW5jaG9yIHRhZydzIGF0dHJpYnV0ZXMuIFxyXG5cdFx0ICovXHJcblx0XHRjcmVhdGVBdHRycyA6IGZ1bmN0aW9uKCBtYXRjaFR5cGUsIGFuY2hvckhyZWYgKSB7XHJcblx0XHRcdHZhciBhdHRycyA9IHtcclxuXHRcdFx0XHQnaHJlZicgOiBhbmNob3JIcmVmICAvLyB3ZSdsbCBhbHdheXMgaGF2ZSB0aGUgYGhyZWZgIGF0dHJpYnV0ZVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0dmFyIGNzc0NsYXNzID0gdGhpcy5jcmVhdGVDc3NDbGFzcyggbWF0Y2hUeXBlICk7XHJcblx0XHRcdGlmKCBjc3NDbGFzcyApIHtcclxuXHRcdFx0XHRhdHRyc1sgJ2NsYXNzJyBdID0gY3NzQ2xhc3M7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoIHRoaXMubmV3V2luZG93ICkge1xyXG5cdFx0XHRcdGF0dHJzWyAndGFyZ2V0JyBdID0gXCJfYmxhbmtcIjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGF0dHJzO1xyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBDcmVhdGVzIHRoZSBDU1MgY2xhc3MgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIGEgZ2l2ZW4gYW5jaG9yIHRhZywgYmFzZWQgb24gdGhlIGBtYXRjaFR5cGVgIGFuZCB0aGUge0BsaW5rICNjbGFzc05hbWV9XHJcblx0XHQgKiBjb25maWcuXHJcblx0XHQgKiBcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAcGFyYW0ge1widXJsXCIvXCJlbWFpbFwiL1widHdpdHRlclwifSBtYXRjaFR5cGUgVGhlIHR5cGUgb2YgbWF0Y2ggdGhhdCBhbiBhbmNob3IgdGFnIGlzIGJlaW5nIGdlbmVyYXRlZCBmb3IuXHJcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBDU1MgY2xhc3Mgc3RyaW5nIGZvciB0aGUgbGluay4gRXhhbXBsZSByZXR1cm46IFwibXlMaW5rIG15TGluay11cmxcIi4gSWYgbm8ge0BsaW5rICNjbGFzc05hbWV9XHJcblx0XHQgKiAgIHdhcyBjb25maWd1cmVkLCByZXR1cm5zIGFuIGVtcHR5IHN0cmluZy5cclxuXHRcdCAqL1xyXG5cdFx0Y3JlYXRlQ3NzQ2xhc3MgOiBmdW5jdGlvbiggbWF0Y2hUeXBlICkge1xyXG5cdFx0XHR2YXIgY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWU7XHJcblxyXG5cdFx0XHRpZiggIWNsYXNzTmFtZSApIFxyXG5cdFx0XHRcdHJldHVybiBcIlwiO1xyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0cmV0dXJuIGNsYXNzTmFtZSArIFwiIFwiICsgY2xhc3NOYW1lICsgXCItXCIgKyBtYXRjaFR5cGU7ICAvLyBleDogXCJteUxpbmsgbXlMaW5rLXVybFwiLCBcIm15TGluayBteUxpbmstZW1haWxcIiwgb3IgXCJteUxpbmsgbXlMaW5rLXR3aXR0ZXJcIlxyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBQcm9jZXNzZXMgdGhlIGBhbmNob3JUZXh0YCBieSB0cnVuY2F0aW5nIHRoZSB0ZXh0IGFjY29yZGluZyB0byB0aGUge0BsaW5rICN0cnVuY2F0ZX0gY29uZmlnLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGFuY2hvclRleHQgVGhlIGFuY2hvciB0YWcncyB0ZXh0IChpLmUuIHdoYXQgd2lsbCBiZSBkaXNwbGF5ZWQpLlxyXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgcHJvY2Vzc2VkIGBhbmNob3JUZXh0YC5cclxuXHRcdCAqL1xyXG5cdFx0cHJvY2Vzc0FuY2hvclRleHQgOiBmdW5jdGlvbiggYW5jaG9yVGV4dCApIHtcclxuXHRcdFx0YW5jaG9yVGV4dCA9IHRoaXMuZG9UcnVuY2F0ZSggYW5jaG9yVGV4dCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIGFuY2hvclRleHQ7XHJcblx0XHR9LFxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFBlcmZvcm1zIHRoZSB0cnVuY2F0aW9uIG9mIHRoZSBgYW5jaG9yVGV4dGAsIGlmIHRoZSBgYW5jaG9yVGV4dGAgaXMgbG9uZ2VyIHRoYW4gdGhlIHtAbGluayAjdHJ1bmNhdGV9IG9wdGlvbi5cclxuXHRcdCAqIFRydW5jYXRlcyB0aGUgdGV4dCB0byAyIGNoYXJhY3RlcnMgZmV3ZXIgdGhhbiB0aGUge0BsaW5rICN0cnVuY2F0ZX0gb3B0aW9uLCBhbmQgYWRkcyBcIi4uXCIgdG8gdGhlIGVuZC5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSBhbmNob3IgdGFnJ3MgdGV4dCAoaS5lLiB3aGF0IHdpbGwgYmUgZGlzcGxheWVkKS5cclxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHRydW5jYXRlZCBhbmNob3IgdGV4dC5cclxuXHRcdCAqL1xyXG5cdFx0ZG9UcnVuY2F0ZSA6IGZ1bmN0aW9uKCBhbmNob3JUZXh0ICkge1xyXG5cdFx0XHRyZXR1cm4gQXV0b2xpbmtlci5VdGlsLmVsbGlwc2lzKCBhbmNob3JUZXh0LCB0aGlzLnRydW5jYXRlIHx8IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSApO1xyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblx0LypnbG9iYWwgQXV0b2xpbmtlciAqL1xyXG5cdC8qKlxyXG5cdCAqIEBhYnN0cmFjdFxyXG5cdCAqIEBjbGFzcyBBdXRvbGlua2VyLm1hdGNoLk1hdGNoXHJcblx0ICogXHJcblx0ICogUmVwcmVzZW50cyBhIG1hdGNoIGZvdW5kIGluIGFuIGlucHV0IHN0cmluZyB3aGljaCBzaG91bGQgYmUgQXV0b2xpbmtlZC4gQSBNYXRjaCBvYmplY3QgaXMgd2hhdCBpcyBwcm92aWRlZCBpbiBhIFxyXG5cdCAqIHtAbGluayBBdXRvbGlua2VyI3JlcGxhY2VGbiByZXBsYWNlRm59LCBhbmQgbWF5IGJlIHVzZWQgdG8gcXVlcnkgZm9yIGRldGFpbHMgYWJvdXQgdGhlIG1hdGNoLlxyXG5cdCAqIFxyXG5cdCAqIEZvciBleGFtcGxlOlxyXG5cdCAqIFxyXG5cdCAqICAgICB2YXIgaW5wdXQgPSBcIi4uLlwiOyAgLy8gc3RyaW5nIHdpdGggVVJMcywgRW1haWwgQWRkcmVzc2VzLCBhbmQgVHdpdHRlciBIYW5kbGVzXHJcblx0ICogICAgIFxyXG5cdCAqICAgICB2YXIgbGlua2VkVGV4dCA9IEF1dG9saW5rZXIubGluayggaW5wdXQsIHtcclxuXHQgKiAgICAgICAgIHJlcGxhY2VGbiA6IGZ1bmN0aW9uKCBhdXRvbGlua2VyLCBtYXRjaCApIHtcclxuXHQgKiAgICAgICAgICAgICBjb25zb2xlLmxvZyggXCJocmVmID0gXCIsIG1hdGNoLmdldEFuY2hvckhyZWYoKSApO1xyXG5cdCAqICAgICAgICAgICAgIGNvbnNvbGUubG9nKCBcInRleHQgPSBcIiwgbWF0Y2guZ2V0QW5jaG9yVGV4dCgpICk7XHJcblx0ICogICAgICAgICBcclxuXHQgKiAgICAgICAgICAgICBzd2l0Y2goIG1hdGNoLmdldFR5cGUoKSApIHtcclxuXHQgKiAgICAgICAgICAgICAgICAgY2FzZSAndXJsJyA6IFxyXG5cdCAqICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coIFwidXJsOiBcIiwgbWF0Y2guZ2V0VXJsKCkgKTtcclxuXHQgKiAgICAgICAgICAgICAgICAgICAgIFxyXG5cdCAqICAgICAgICAgICAgICAgICBjYXNlICdlbWFpbCcgOlxyXG5cdCAqICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coIFwiZW1haWw6IFwiLCBtYXRjaC5nZXRFbWFpbCgpICk7XHJcblx0ICogICAgICAgICAgICAgICAgICAgICBcclxuXHQgKiAgICAgICAgICAgICAgICAgY2FzZSAndHdpdHRlcicgOlxyXG5cdCAqICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coIFwidHdpdHRlcjogXCIsIG1hdGNoLmdldFR3aXR0ZXJIYW5kbGUoKSApO1xyXG5cdCAqICAgICAgICAgICAgIH1cclxuXHQgKiAgICAgICAgIH1cclxuXHQgKiAgICAgfSApO1xyXG5cdCAqICAgICBcclxuXHQgKiBTZWUgdGhlIHtAbGluayBBdXRvbGlua2VyfSBjbGFzcyBmb3IgbW9yZSBkZXRhaWxzIG9uIHVzaW5nIHRoZSB7QGxpbmsgQXV0b2xpbmtlciNyZXBsYWNlRm4gcmVwbGFjZUZufS5cclxuXHQgKi9cclxuXHRBdXRvbGlua2VyLm1hdGNoLk1hdGNoID0gQXV0b2xpbmtlci5VdGlsLmV4dGVuZCggT2JqZWN0LCB7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBAY2ZnIHtTdHJpbmd9IG1hdGNoZWRUZXh0IChyZXF1aXJlZClcclxuXHRcdCAqIFxyXG5cdFx0ICogVGhlIG9yaWdpbmFsIHRleHQgdGhhdCB3YXMgbWF0Y2hlZC5cclxuXHRcdCAqL1xyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEBjb25zdHJ1Y3RvclxyXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGNmZyBUaGUgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIGZvciB0aGUgTWF0Y2ggaW5zdGFuY2UsIHNwZWNpZmllZCBpbiBhbiBPYmplY3QgKG1hcCkuXHJcblx0XHQgKi9cclxuXHRcdGNvbnN0cnVjdG9yIDogZnVuY3Rpb24oIGNmZyApIHtcclxuXHRcdFx0QXV0b2xpbmtlci5VdGlsLmFzc2lnbiggdGhpcywgY2ZnICk7XHJcblx0XHR9LFxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFJldHVybnMgYSBzdHJpbmcgbmFtZSBmb3IgdGhlIHR5cGUgb2YgbWF0Y2ggdGhhdCB0aGlzIGNsYXNzIHJlcHJlc2VudHMuXHJcblx0XHQgKiBcclxuXHRcdCAqIEBhYnN0cmFjdFxyXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfVxyXG5cdFx0ICovXHJcblx0XHRnZXRUeXBlIDogQXV0b2xpbmtlci5VdGlsLmFic3RyYWN0TWV0aG9kLFxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHRleHQgdGhhdCB3YXMgbWF0Y2hlZC5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfVxyXG5cdFx0ICovXHJcblx0XHRnZXRNYXRjaGVkVGV4dCA6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5tYXRjaGVkVGV4dDtcclxuXHRcdH0sXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogUmV0dXJucyB0aGUgYW5jaG9yIGhyZWYgdGhhdCBzaG91bGQgYmUgZ2VuZXJhdGVkIGZvciB0aGUgbWF0Y2guXHJcblx0XHQgKiBcclxuXHRcdCAqIEBhYnN0cmFjdFxyXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfVxyXG5cdFx0ICovXHJcblx0XHRnZXRBbmNob3JIcmVmIDogQXV0b2xpbmtlci5VdGlsLmFic3RyYWN0TWV0aG9kLFxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFJldHVybnMgdGhlIGFuY2hvciB0ZXh0IHRoYXQgc2hvdWxkIGJlIGdlbmVyYXRlZCBmb3IgdGhlIG1hdGNoLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAYWJzdHJhY3RcclxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cclxuXHRcdCAqL1xyXG5cdFx0Z2V0QW5jaG9yVGV4dCA6IEF1dG9saW5rZXIuVXRpbC5hYnN0cmFjdE1ldGhvZFxyXG5cclxuXHR9ICk7XHJcblx0LypnbG9iYWwgQXV0b2xpbmtlciAqL1xyXG5cdC8qKlxyXG5cdCAqIEBjbGFzcyBBdXRvbGlua2VyLm1hdGNoLkVtYWlsXHJcblx0ICogQGV4dGVuZHMgQXV0b2xpbmtlci5tYXRjaC5NYXRjaFxyXG5cdCAqIFxyXG5cdCAqIFJlcHJlc2VudHMgYSBFbWFpbCBtYXRjaCBmb3VuZCBpbiBhbiBpbnB1dCBzdHJpbmcgd2hpY2ggc2hvdWxkIGJlIEF1dG9saW5rZWQuXHJcblx0ICogXHJcblx0ICogU2VlIHRoaXMgY2xhc3MncyBzdXBlcmNsYXNzICh7QGxpbmsgQXV0b2xpbmtlci5tYXRjaC5NYXRjaH0pIGZvciBtb3JlIGRldGFpbHMuXHJcblx0ICovXHJcblx0QXV0b2xpbmtlci5tYXRjaC5FbWFpbCA9IEF1dG9saW5rZXIuVXRpbC5leHRlbmQoIEF1dG9saW5rZXIubWF0Y2guTWF0Y2gsIHtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEBjZmcge1N0cmluZ30gZW1haWwgKHJlcXVpcmVkKVxyXG5cdFx0ICogXHJcblx0XHQgKiBUaGUgZW1haWwgYWRkcmVzcyB0aGF0IHdhcyBtYXRjaGVkLlxyXG5cdFx0ICovXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogUmV0dXJucyBhIHN0cmluZyBuYW1lIGZvciB0aGUgdHlwZSBvZiBtYXRjaCB0aGF0IHRoaXMgY2xhc3MgcmVwcmVzZW50cy5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfVxyXG5cdFx0ICovXHJcblx0XHRnZXRUeXBlIDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiAnZW1haWwnO1xyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBSZXR1cm5zIHRoZSBlbWFpbCBhZGRyZXNzIHRoYXQgd2FzIG1hdGNoZWQuXHJcblx0XHQgKiBcclxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cclxuXHRcdCAqL1xyXG5cdFx0Z2V0RW1haWwgOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZW1haWw7XHJcblx0XHR9LFxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFJldHVybnMgdGhlIGFuY2hvciBocmVmIHRoYXQgc2hvdWxkIGJlIGdlbmVyYXRlZCBmb3IgdGhlIG1hdGNoLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XHJcblx0XHQgKi9cclxuXHRcdGdldEFuY2hvckhyZWYgOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuICdtYWlsdG86JyArIHRoaXMuZW1haWw7XHJcblx0XHR9LFxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFJldHVybnMgdGhlIGFuY2hvciB0ZXh0IHRoYXQgc2hvdWxkIGJlIGdlbmVyYXRlZCBmb3IgdGhlIG1hdGNoLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XHJcblx0XHQgKi9cclxuXHRcdGdldEFuY2hvclRleHQgOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZW1haWw7XHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHQvKmdsb2JhbCBBdXRvbGlua2VyICovXHJcblx0LyoqXHJcblx0ICogQGNsYXNzIEF1dG9saW5rZXIubWF0Y2guVHdpdHRlclxyXG5cdCAqIEBleHRlbmRzIEF1dG9saW5rZXIubWF0Y2guTWF0Y2hcclxuXHQgKiBcclxuXHQgKiBSZXByZXNlbnRzIGEgVHdpdHRlciBtYXRjaCBmb3VuZCBpbiBhbiBpbnB1dCBzdHJpbmcgd2hpY2ggc2hvdWxkIGJlIEF1dG9saW5rZWQuXHJcblx0ICogXHJcblx0ICogU2VlIHRoaXMgY2xhc3MncyBzdXBlcmNsYXNzICh7QGxpbmsgQXV0b2xpbmtlci5tYXRjaC5NYXRjaH0pIGZvciBtb3JlIGRldGFpbHMuXHJcblx0ICovXHJcblx0QXV0b2xpbmtlci5tYXRjaC5Ud2l0dGVyID0gQXV0b2xpbmtlci5VdGlsLmV4dGVuZCggQXV0b2xpbmtlci5tYXRjaC5NYXRjaCwge1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQGNmZyB7U3RyaW5nfSB0d2l0dGVySGFuZGxlIChyZXF1aXJlZClcclxuXHRcdCAqIFxyXG5cdFx0ICogVGhlIFR3aXR0ZXIgaGFuZGxlIHRoYXQgd2FzIG1hdGNoZWQuXHJcblx0XHQgKi9cclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBSZXR1cm5zIHRoZSB0eXBlIG9mIG1hdGNoIHRoYXQgdGhpcyBjbGFzcyByZXByZXNlbnRzLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XHJcblx0XHQgKi9cclxuXHRcdGdldFR5cGUgOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuICd0d2l0dGVyJztcclxuXHRcdH0sXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogUmV0dXJucyBhIHN0cmluZyBuYW1lIGZvciB0aGUgdHlwZSBvZiBtYXRjaCB0aGF0IHRoaXMgY2xhc3MgcmVwcmVzZW50cy5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfVxyXG5cdFx0ICovXHJcblx0XHRnZXRUd2l0dGVySGFuZGxlIDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnR3aXR0ZXJIYW5kbGU7XHJcblx0XHR9LFxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFJldHVybnMgdGhlIGFuY2hvciBocmVmIHRoYXQgc2hvdWxkIGJlIGdlbmVyYXRlZCBmb3IgdGhlIG1hdGNoLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XHJcblx0XHQgKi9cclxuXHRcdGdldEFuY2hvckhyZWYgOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuICdodHRwczovL3R3aXR0ZXIuY29tLycgKyB0aGlzLnR3aXR0ZXJIYW5kbGU7XHJcblx0XHR9LFxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFJldHVybnMgdGhlIGFuY2hvciB0ZXh0IHRoYXQgc2hvdWxkIGJlIGdlbmVyYXRlZCBmb3IgdGhlIG1hdGNoLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XHJcblx0XHQgKi9cclxuXHRcdGdldEFuY2hvclRleHQgOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuICdAJyArIHRoaXMudHdpdHRlckhhbmRsZTtcclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cdC8qZ2xvYmFsIEF1dG9saW5rZXIgKi9cclxuXHQvKipcclxuXHQgKiBAY2xhc3MgQXV0b2xpbmtlci5tYXRjaC5VcmxcclxuXHQgKiBAZXh0ZW5kcyBBdXRvbGlua2VyLm1hdGNoLk1hdGNoXHJcblx0ICogXHJcblx0ICogUmVwcmVzZW50cyBhIFVybCBtYXRjaCBmb3VuZCBpbiBhbiBpbnB1dCBzdHJpbmcgd2hpY2ggc2hvdWxkIGJlIEF1dG9saW5rZWQuXHJcblx0ICogXHJcblx0ICogU2VlIHRoaXMgY2xhc3MncyBzdXBlcmNsYXNzICh7QGxpbmsgQXV0b2xpbmtlci5tYXRjaC5NYXRjaH0pIGZvciBtb3JlIGRldGFpbHMuXHJcblx0ICovXHJcblx0QXV0b2xpbmtlci5tYXRjaC5VcmwgPSBBdXRvbGlua2VyLlV0aWwuZXh0ZW5kKCBBdXRvbGlua2VyLm1hdGNoLk1hdGNoLCB7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBAY2ZnIHtTdHJpbmd9IHVybCAocmVxdWlyZWQpXHJcblx0XHQgKiBcclxuXHRcdCAqIFRoZSB1cmwgdGhhdCB3YXMgbWF0Y2hlZC5cclxuXHRcdCAqL1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQGNmZyB7Qm9vbGVhbn0gcHJvdG9jb2xVcmxNYXRjaCAocmVxdWlyZWQpXHJcblx0XHQgKiBcclxuXHRcdCAqIGB0cnVlYCBpZiB0aGUgVVJMIGlzIGEgbWF0Y2ggd2hpY2ggYWxyZWFkeSBoYXMgYSBwcm90b2NvbCAoaS5lLiAnaHR0cDovLycpLCBgZmFsc2VgIGlmIHRoZSBtYXRjaCB3YXMgZnJvbSBhICd3d3cnIG9yXHJcblx0XHQgKiBrbm93biBUTEQgbWF0Y2guXHJcblx0XHQgKi9cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEBjZmcge0Jvb2xlYW59IHByb3RvY29sUmVsYXRpdmVNYXRjaCAocmVxdWlyZWQpXHJcblx0XHQgKiBcclxuXHRcdCAqIGB0cnVlYCBpZiB0aGUgVVJMIGlzIGEgcHJvdG9jb2wtcmVsYXRpdmUgbWF0Y2guIEEgcHJvdG9jb2wtcmVsYXRpdmUgbWF0Y2ggaXMgYSBVUkwgdGhhdCBzdGFydHMgd2l0aCAnLy8nLFxyXG5cdFx0ICogYW5kIHdpbGwgYmUgZWl0aGVyIGh0dHA6Ly8gb3IgaHR0cHM6Ly8gYmFzZWQgb24gdGhlIHByb3RvY29sIHRoYXQgdGhlIHNpdGUgaXMgbG9hZGVkIHVuZGVyLlxyXG5cdFx0ICovXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBAY2ZnIHtCb29sZWFufSBzdHJpcFByZWZpeCAocmVxdWlyZWQpXHJcblx0XHQgKiBAaW5oZXJpdGRvYyBBdXRvbGlua2VyI3N0cmlwUHJlZml4XHJcblx0XHQgKi9cclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHByb3BlcnR5IHtSZWdFeHB9IHVybFByZWZpeFJlZ2V4XHJcblx0XHQgKiBcclxuXHRcdCAqIEEgcmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gcmVtb3ZlIHRoZSAnaHR0cDovLycgb3IgJ2h0dHBzOi8vJyBhbmQvb3IgdGhlICd3d3cuJyBmcm9tIFVSTHMuXHJcblx0XHQgKi9cclxuXHRcdHVybFByZWZpeFJlZ2V4OiAvXihodHRwcz86XFwvXFwvKT8od3d3XFwuKT8vaSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAcHJvcGVydHkge1JlZ0V4cH0gcHJvdG9jb2xSZWxhdGl2ZVJlZ2V4XHJcblx0XHQgKiBcclxuXHRcdCAqIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byByZW1vdmUgdGhlIHByb3RvY29sLXJlbGF0aXZlICcvLycgZnJvbSB0aGUge0BsaW5rICN1cmx9IHN0cmluZywgZm9yIHB1cnBvc2VzXHJcblx0XHQgKiBvZiB7QGxpbmsgI2dldEFuY2hvclRleHR9LiBBIHByb3RvY29sLXJlbGF0aXZlIFVSTCBpcywgZm9yIGV4YW1wbGUsIFwiLy95YWhvby5jb21cIlxyXG5cdFx0ICovXHJcblx0XHRwcm90b2NvbFJlbGF0aXZlUmVnZXggOiAvXlxcL1xcLy8sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBwcm90b2NvbFByZXBlbmRlZFxyXG5cdFx0ICogXHJcblx0XHQgKiBXaWxsIGJlIHNldCB0byBgdHJ1ZWAgaWYgdGhlICdodHRwOi8vJyBwcm90b2NvbCBoYXMgYmVlbiBwcmVwZW5kZWQgdG8gdGhlIHtAbGluayAjdXJsfSAoYmVjYXVzZSB0aGVcclxuXHRcdCAqIHtAbGluayAjdXJsfSBkaWQgbm90IGhhdmUgYSBwcm90b2NvbClcclxuXHRcdCAqL1xyXG5cdFx0cHJvdG9jb2xQcmVwZW5kZWQgOiBmYWxzZSxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBSZXR1cm5zIGEgc3RyaW5nIG5hbWUgZm9yIHRoZSB0eXBlIG9mIG1hdGNoIHRoYXQgdGhpcyBjbGFzcyByZXByZXNlbnRzLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XHJcblx0XHQgKi9cclxuXHRcdGdldFR5cGUgOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuICd1cmwnO1xyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBSZXR1cm5zIHRoZSB1cmwgdGhhdCB3YXMgbWF0Y2hlZCwgYXNzdW1pbmcgdGhlIHByb3RvY29sIHRvIGJlICdodHRwOi8vJyBpZiB0aGUgb3JpZ2luYWxcclxuXHRcdCAqIG1hdGNoIHdhcyBtaXNzaW5nIGEgcHJvdG9jb2wuXHJcblx0XHQgKiBcclxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cclxuXHRcdCAqL1xyXG5cdFx0Z2V0VXJsIDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHZhciB1cmwgPSB0aGlzLnVybDtcclxuXHJcblx0XHRcdC8vIGlmIHRoZSB1cmwgc3RyaW5nIGRvZXNuJ3QgYmVnaW4gd2l0aCBhIHByb3RvY29sLCBhc3N1bWUgJ2h0dHA6Ly8nXHJcblx0XHRcdGlmKCAhdGhpcy5wcm90b2NvbFJlbGF0aXZlTWF0Y2ggJiYgIXRoaXMucHJvdG9jb2xVcmxNYXRjaCAmJiAhdGhpcy5wcm90b2NvbFByZXBlbmRlZCApIHtcclxuXHRcdFx0XHR1cmwgPSB0aGlzLnVybCA9ICdodHRwOi8vJyArIHVybDtcclxuXHJcblx0XHRcdFx0dGhpcy5wcm90b2NvbFByZXBlbmRlZCA9IHRydWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB1cmw7XHJcblx0XHR9LFxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFJldHVybnMgdGhlIGFuY2hvciBocmVmIHRoYXQgc2hvdWxkIGJlIGdlbmVyYXRlZCBmb3IgdGhlIG1hdGNoLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XHJcblx0XHQgKi9cclxuXHRcdGdldEFuY2hvckhyZWYgOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0dmFyIHVybCA9IHRoaXMuZ2V0VXJsKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdXJsLnJlcGxhY2UoIC8mYW1wOy9nLCAnJicgKTsgIC8vIGFueSAmYW1wOydzIGluIHRoZSBVUkwgc2hvdWxkIGJlIGNvbnZlcnRlZCBiYWNrIHRvICcmJyBpZiB0aGV5IHdlcmUgZGlzcGxheWVkIGFzICZhbXA7IGluIHRoZSBzb3VyY2UgaHRtbCBcclxuXHRcdH0sXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogUmV0dXJucyB0aGUgYW5jaG9yIHRleHQgdGhhdCBzaG91bGQgYmUgZ2VuZXJhdGVkIGZvciB0aGUgbWF0Y2guXHJcblx0XHQgKiBcclxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cclxuXHRcdCAqL1xyXG5cdFx0Z2V0QW5jaG9yVGV4dCA6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR2YXIgYW5jaG9yVGV4dCA9IHRoaXMuZ2V0VXJsKCk7XHJcblxyXG5cdFx0XHRpZiggdGhpcy5wcm90b2NvbFJlbGF0aXZlTWF0Y2ggKSB7XHJcblx0XHRcdFx0Ly8gU3RyaXAgb2ZmIGFueSBwcm90b2NvbC1yZWxhdGl2ZSAnLy8nIGZyb20gdGhlIGFuY2hvciB0ZXh0XHJcblx0XHRcdFx0YW5jaG9yVGV4dCA9IHRoaXMuc3RyaXBQcm90b2NvbFJlbGF0aXZlUHJlZml4KCBhbmNob3JUZXh0ICk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoIHRoaXMuc3RyaXBQcmVmaXggKSB7XHJcblx0XHRcdFx0YW5jaG9yVGV4dCA9IHRoaXMuc3RyaXBVcmxQcmVmaXgoIGFuY2hvclRleHQgKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRhbmNob3JUZXh0ID0gdGhpcy5yZW1vdmVUcmFpbGluZ1NsYXNoKCBhbmNob3JUZXh0ICk7ICAvLyByZW1vdmUgdHJhaWxpbmcgc2xhc2gsIGlmIHRoZXJlIGlzIG9uZVxyXG5cclxuXHRcdFx0cmV0dXJuIGFuY2hvclRleHQ7XHJcblx0XHR9LFxyXG5cclxuXHJcblx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblx0XHQvLyBVdGlsaXR5IEZ1bmN0aW9uYWxpdHlcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFN0cmlwcyB0aGUgVVJMIHByZWZpeCAoc3VjaCBhcyBcImh0dHA6Ly9cIiBvciBcImh0dHBzOi8vXCIpIGZyb20gdGhlIGdpdmVuIHRleHQuXHJcblx0XHQgKiBcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgdGV4dCBvZiB0aGUgYW5jaG9yIHRoYXQgaXMgYmVpbmcgZ2VuZXJhdGVkLCBmb3Igd2hpY2ggdG8gc3RyaXAgb2ZmIHRoZVxyXG5cdFx0ICogICB1cmwgcHJlZml4IChzdWNoIGFzIHN0cmlwcGluZyBvZmYgXCJodHRwOi8vXCIpXHJcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBgYW5jaG9yVGV4dGAsIHdpdGggdGhlIHByZWZpeCBzdHJpcHBlZC5cclxuXHRcdCAqL1xyXG5cdFx0c3RyaXBVcmxQcmVmaXggOiBmdW5jdGlvbiggdGV4dCApIHtcclxuXHRcdFx0cmV0dXJuIHRleHQucmVwbGFjZSggdGhpcy51cmxQcmVmaXhSZWdleCwgJycgKTtcclxuXHRcdH0sXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogU3RyaXBzIGFueSBwcm90b2NvbC1yZWxhdGl2ZSAnLy8nIGZyb20gdGhlIGFuY2hvciB0ZXh0LlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGhlIHRleHQgb2YgdGhlIGFuY2hvciB0aGF0IGlzIGJlaW5nIGdlbmVyYXRlZCwgZm9yIHdoaWNoIHRvIHN0cmlwIG9mZiB0aGVcclxuXHRcdCAqICAgcHJvdG9jb2wtcmVsYXRpdmUgcHJlZml4IChzdWNoIGFzIHN0cmlwcGluZyBvZmYgXCIvL1wiKVxyXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgYGFuY2hvclRleHRgLCB3aXRoIHRoZSBwcm90b2NvbC1yZWxhdGl2ZSBwcmVmaXggc3RyaXBwZWQuXHJcblx0XHQgKi9cclxuXHRcdHN0cmlwUHJvdG9jb2xSZWxhdGl2ZVByZWZpeCA6IGZ1bmN0aW9uKCB0ZXh0ICkge1xyXG5cdFx0XHRyZXR1cm4gdGV4dC5yZXBsYWNlKCB0aGlzLnByb3RvY29sUmVsYXRpdmVSZWdleCwgJycgKTtcclxuXHRcdH0sXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogUmVtb3ZlcyBhbnkgdHJhaWxpbmcgc2xhc2ggZnJvbSB0aGUgZ2l2ZW4gYGFuY2hvclRleHRgLCBpbiBwcmVwYXJhdGlvbiBmb3IgdGhlIHRleHQgdG8gYmUgZGlzcGxheWVkLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGFuY2hvclRleHQgVGhlIHRleHQgb2YgdGhlIGFuY2hvciB0aGF0IGlzIGJlaW5nIGdlbmVyYXRlZCwgZm9yIHdoaWNoIHRvIHJlbW92ZSBhbnkgdHJhaWxpbmdcclxuXHRcdCAqICAgc2xhc2ggKCcvJykgdGhhdCBtYXkgZXhpc3QuXHJcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBgYW5jaG9yVGV4dGAsIHdpdGggdGhlIHRyYWlsaW5nIHNsYXNoIHJlbW92ZWQuXHJcblx0XHQgKi9cclxuXHRcdHJlbW92ZVRyYWlsaW5nU2xhc2ggOiBmdW5jdGlvbiggYW5jaG9yVGV4dCApIHtcclxuXHRcdFx0aWYoIGFuY2hvclRleHQuY2hhckF0KCBhbmNob3JUZXh0Lmxlbmd0aCAtIDEgKSA9PT0gJy8nICkge1xyXG5cdFx0XHRcdGFuY2hvclRleHQgPSBhbmNob3JUZXh0LnNsaWNlKCAwLCAtMSApO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBhbmNob3JUZXh0O1xyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdHJldHVybiBBdXRvbGlua2VyO1xyXG5cclxuXHJcbn0pKTtcclxuIiwiLy8gICAgIEJhY2tib25lLmpzIDEuMS4yXG5cbi8vICAgICAoYykgMjAxMC0yMDE0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgQmFja2JvbmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4vLyAgICAgRm9yIGFsbCBkZXRhaWxzIGFuZCBkb2N1bWVudGF0aW9uOlxuLy8gICAgIGh0dHA6Ly9iYWNrYm9uZWpzLm9yZ1xuXG4oZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuXG4gIC8vIFNldCB1cCBCYWNrYm9uZSBhcHByb3ByaWF0ZWx5IGZvciB0aGUgZW52aXJvbm1lbnQuIFN0YXJ0IHdpdGggQU1ELlxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFsndW5kZXJzY29yZScsICdqcXVlcnknLCAnZXhwb3J0cyddLCBmdW5jdGlvbihfLCAkLCBleHBvcnRzKSB7XG4gICAgICAvLyBFeHBvcnQgZ2xvYmFsIGV2ZW4gaW4gQU1EIGNhc2UgaW4gY2FzZSB0aGlzIHNjcmlwdCBpcyBsb2FkZWQgd2l0aFxuICAgICAgLy8gb3RoZXJzIHRoYXQgbWF5IHN0aWxsIGV4cGVjdCBhIGdsb2JhbCBCYWNrYm9uZS5cbiAgICAgIHJvb3QuQmFja2JvbmUgPSBmYWN0b3J5KHJvb3QsIGV4cG9ydHMsIF8sICQpO1xuICAgIH0pO1xuXG4gIC8vIE5leHQgZm9yIE5vZGUuanMgb3IgQ29tbW9uSlMuIGpRdWVyeSBtYXkgbm90IGJlIG5lZWRlZCBhcyBhIG1vZHVsZS5cbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbiAgICBmYWN0b3J5KHJvb3QsIGV4cG9ydHMsIF8pO1xuXG4gIC8vIEZpbmFsbHksIGFzIGEgYnJvd3NlciBnbG9iYWwuXG4gIH0gZWxzZSB7XG4gICAgcm9vdC5CYWNrYm9uZSA9IGZhY3Rvcnkocm9vdCwge30sIHJvb3QuXywgKHJvb3QualF1ZXJ5IHx8IHJvb3QuWmVwdG8gfHwgcm9vdC5lbmRlciB8fCByb290LiQpKTtcbiAgfVxuXG59KHRoaXMsIGZ1bmN0aW9uKHJvb3QsIEJhY2tib25lLCBfLCAkKSB7XG5cbiAgLy8gSW5pdGlhbCBTZXR1cFxuICAvLyAtLS0tLS0tLS0tLS0tXG5cbiAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGBCYWNrYm9uZWAgdmFyaWFibGUsIHNvIHRoYXQgaXQgY2FuIGJlXG4gIC8vIHJlc3RvcmVkIGxhdGVyIG9uLCBpZiBgbm9Db25mbGljdGAgaXMgdXNlZC5cbiAgdmFyIHByZXZpb3VzQmFja2JvbmUgPSByb290LkJhY2tib25lO1xuXG4gIC8vIENyZWF0ZSBsb2NhbCByZWZlcmVuY2VzIHRvIGFycmF5IG1ldGhvZHMgd2UnbGwgd2FudCB0byB1c2UgbGF0ZXIuXG4gIHZhciBhcnJheSA9IFtdO1xuICB2YXIgcHVzaCA9IGFycmF5LnB1c2g7XG4gIHZhciBzbGljZSA9IGFycmF5LnNsaWNlO1xuICB2YXIgc3BsaWNlID0gYXJyYXkuc3BsaWNlO1xuXG4gIC8vIEN1cnJlbnQgdmVyc2lvbiBvZiB0aGUgbGlicmFyeS4gS2VlcCBpbiBzeW5jIHdpdGggYHBhY2thZ2UuanNvbmAuXG4gIEJhY2tib25lLlZFUlNJT04gPSAnMS4xLjInO1xuXG4gIC8vIEZvciBCYWNrYm9uZSdzIHB1cnBvc2VzLCBqUXVlcnksIFplcHRvLCBFbmRlciwgb3IgTXkgTGlicmFyeSAoa2lkZGluZykgb3duc1xuICAvLyB0aGUgYCRgIHZhcmlhYmxlLlxuICBCYWNrYm9uZS4kID0gJDtcblxuICAvLyBSdW5zIEJhY2tib25lLmpzIGluICpub0NvbmZsaWN0KiBtb2RlLCByZXR1cm5pbmcgdGhlIGBCYWNrYm9uZWAgdmFyaWFibGVcbiAgLy8gdG8gaXRzIHByZXZpb3VzIG93bmVyLiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoaXMgQmFja2JvbmUgb2JqZWN0LlxuICBCYWNrYm9uZS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcm9vdC5CYWNrYm9uZSA9IHByZXZpb3VzQmFja2JvbmU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gVHVybiBvbiBgZW11bGF0ZUhUVFBgIHRvIHN1cHBvcnQgbGVnYWN5IEhUVFAgc2VydmVycy4gU2V0dGluZyB0aGlzIG9wdGlvblxuICAvLyB3aWxsIGZha2UgYFwiUEFUQ0hcImAsIGBcIlBVVFwiYCBhbmQgYFwiREVMRVRFXCJgIHJlcXVlc3RzIHZpYSB0aGUgYF9tZXRob2RgIHBhcmFtZXRlciBhbmRcbiAgLy8gc2V0IGEgYFgtSHR0cC1NZXRob2QtT3ZlcnJpZGVgIGhlYWRlci5cbiAgQmFja2JvbmUuZW11bGF0ZUhUVFAgPSBmYWxzZTtcblxuICAvLyBUdXJuIG9uIGBlbXVsYXRlSlNPTmAgdG8gc3VwcG9ydCBsZWdhY3kgc2VydmVycyB0aGF0IGNhbid0IGRlYWwgd2l0aCBkaXJlY3RcbiAgLy8gYGFwcGxpY2F0aW9uL2pzb25gIHJlcXVlc3RzIC4uLiB3aWxsIGVuY29kZSB0aGUgYm9keSBhc1xuICAvLyBgYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkYCBpbnN0ZWFkIGFuZCB3aWxsIHNlbmQgdGhlIG1vZGVsIGluIGFcbiAgLy8gZm9ybSBwYXJhbSBuYW1lZCBgbW9kZWxgLlxuICBCYWNrYm9uZS5lbXVsYXRlSlNPTiA9IGZhbHNlO1xuXG4gIC8vIEJhY2tib25lLkV2ZW50c1xuICAvLyAtLS0tLS0tLS0tLS0tLS1cblxuICAvLyBBIG1vZHVsZSB0aGF0IGNhbiBiZSBtaXhlZCBpbiB0byAqYW55IG9iamVjdCogaW4gb3JkZXIgdG8gcHJvdmlkZSBpdCB3aXRoXG4gIC8vIGN1c3RvbSBldmVudHMuIFlvdSBtYXkgYmluZCB3aXRoIGBvbmAgb3IgcmVtb3ZlIHdpdGggYG9mZmAgY2FsbGJhY2tcbiAgLy8gZnVuY3Rpb25zIHRvIGFuIGV2ZW50OyBgdHJpZ2dlcmAtaW5nIGFuIGV2ZW50IGZpcmVzIGFsbCBjYWxsYmFja3MgaW5cbiAgLy8gc3VjY2Vzc2lvbi5cbiAgLy9cbiAgLy8gICAgIHZhciBvYmplY3QgPSB7fTtcbiAgLy8gICAgIF8uZXh0ZW5kKG9iamVjdCwgQmFja2JvbmUuRXZlbnRzKTtcbiAgLy8gICAgIG9iamVjdC5vbignZXhwYW5kJywgZnVuY3Rpb24oKXsgYWxlcnQoJ2V4cGFuZGVkJyk7IH0pO1xuICAvLyAgICAgb2JqZWN0LnRyaWdnZXIoJ2V4cGFuZCcpO1xuICAvL1xuICB2YXIgRXZlbnRzID0gQmFja2JvbmUuRXZlbnRzID0ge1xuXG4gICAgLy8gQmluZCBhbiBldmVudCB0byBhIGBjYWxsYmFja2AgZnVuY3Rpb24uIFBhc3NpbmcgYFwiYWxsXCJgIHdpbGwgYmluZFxuICAgIC8vIHRoZSBjYWxsYmFjayB0byBhbGwgZXZlbnRzIGZpcmVkLlxuICAgIG9uOiBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgaWYgKCFldmVudHNBcGkodGhpcywgJ29uJywgbmFtZSwgW2NhbGxiYWNrLCBjb250ZXh0XSkgfHwgIWNhbGxiYWNrKSByZXR1cm4gdGhpcztcbiAgICAgIHRoaXMuX2V2ZW50cyB8fCAodGhpcy5fZXZlbnRzID0ge30pO1xuICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1tuYW1lXSB8fCAodGhpcy5fZXZlbnRzW25hbWVdID0gW10pO1xuICAgICAgZXZlbnRzLnB1c2goe2NhbGxiYWNrOiBjYWxsYmFjaywgY29udGV4dDogY29udGV4dCwgY3R4OiBjb250ZXh0IHx8IHRoaXN9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBCaW5kIGFuIGV2ZW50IHRvIG9ubHkgYmUgdHJpZ2dlcmVkIGEgc2luZ2xlIHRpbWUuIEFmdGVyIHRoZSBmaXJzdCB0aW1lXG4gICAgLy8gdGhlIGNhbGxiYWNrIGlzIGludm9rZWQsIGl0IHdpbGwgYmUgcmVtb3ZlZC5cbiAgICBvbmNlOiBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgaWYgKCFldmVudHNBcGkodGhpcywgJ29uY2UnLCBuYW1lLCBbY2FsbGJhY2ssIGNvbnRleHRdKSB8fCAhY2FsbGJhY2spIHJldHVybiB0aGlzO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIG9uY2UgPSBfLm9uY2UoZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYub2ZmKG5hbWUsIG9uY2UpO1xuICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG4gICAgICBvbmNlLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgcmV0dXJuIHRoaXMub24obmFtZSwgb25jZSwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSBvbmUgb3IgbWFueSBjYWxsYmFja3MuIElmIGBjb250ZXh0YCBpcyBudWxsLCByZW1vdmVzIGFsbFxuICAgIC8vIGNhbGxiYWNrcyB3aXRoIHRoYXQgZnVuY3Rpb24uIElmIGBjYWxsYmFja2AgaXMgbnVsbCwgcmVtb3ZlcyBhbGxcbiAgICAvLyBjYWxsYmFja3MgZm9yIHRoZSBldmVudC4gSWYgYG5hbWVgIGlzIG51bGwsIHJlbW92ZXMgYWxsIGJvdW5kXG4gICAgLy8gY2FsbGJhY2tzIGZvciBhbGwgZXZlbnRzLlxuICAgIG9mZjogZnVuY3Rpb24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgIHZhciByZXRhaW4sIGV2LCBldmVudHMsIG5hbWVzLCBpLCBsLCBqLCBrO1xuICAgICAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIWV2ZW50c0FwaSh0aGlzLCAnb2ZmJywgbmFtZSwgW2NhbGxiYWNrLCBjb250ZXh0XSkpIHJldHVybiB0aGlzO1xuICAgICAgaWYgKCFuYW1lICYmICFjYWxsYmFjayAmJiAhY29udGV4dCkge1xuICAgICAgICB0aGlzLl9ldmVudHMgPSB2b2lkIDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgbmFtZXMgPSBuYW1lID8gW25hbWVdIDogXy5rZXlzKHRoaXMuX2V2ZW50cyk7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gbmFtZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgaWYgKGV2ZW50cyA9IHRoaXMuX2V2ZW50c1tuYW1lXSkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50c1tuYW1lXSA9IHJldGFpbiA9IFtdO1xuICAgICAgICAgIGlmIChjYWxsYmFjayB8fCBjb250ZXh0KSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBrID0gZXZlbnRzLmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgICBldiA9IGV2ZW50c1tqXTtcbiAgICAgICAgICAgICAgaWYgKChjYWxsYmFjayAmJiBjYWxsYmFjayAhPT0gZXYuY2FsbGJhY2sgJiYgY2FsbGJhY2sgIT09IGV2LmNhbGxiYWNrLl9jYWxsYmFjaykgfHxcbiAgICAgICAgICAgICAgICAgIChjb250ZXh0ICYmIGNvbnRleHQgIT09IGV2LmNvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0YWluLnB1c2goZXYpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmV0YWluLmxlbmd0aCkgZGVsZXRlIHRoaXMuX2V2ZW50c1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gVHJpZ2dlciBvbmUgb3IgbWFueSBldmVudHMsIGZpcmluZyBhbGwgYm91bmQgY2FsbGJhY2tzLiBDYWxsYmFja3MgYXJlXG4gICAgLy8gcGFzc2VkIHRoZSBzYW1lIGFyZ3VtZW50cyBhcyBgdHJpZ2dlcmAgaXMsIGFwYXJ0IGZyb20gdGhlIGV2ZW50IG5hbWVcbiAgICAvLyAodW5sZXNzIHlvdSdyZSBsaXN0ZW5pbmcgb24gYFwiYWxsXCJgLCB3aGljaCB3aWxsIGNhdXNlIHlvdXIgY2FsbGJhY2sgdG9cbiAgICAvLyByZWNlaXZlIHRoZSB0cnVlIG5hbWUgb2YgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBhcmd1bWVudCkuXG4gICAgdHJpZ2dlcjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgaWYgKCF0aGlzLl9ldmVudHMpIHJldHVybiB0aGlzO1xuICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICBpZiAoIWV2ZW50c0FwaSh0aGlzLCAndHJpZ2dlcicsIG5hbWUsIGFyZ3MpKSByZXR1cm4gdGhpcztcbiAgICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHNbbmFtZV07XG4gICAgICB2YXIgYWxsRXZlbnRzID0gdGhpcy5fZXZlbnRzLmFsbDtcbiAgICAgIGlmIChldmVudHMpIHRyaWdnZXJFdmVudHMoZXZlbnRzLCBhcmdzKTtcbiAgICAgIGlmIChhbGxFdmVudHMpIHRyaWdnZXJFdmVudHMoYWxsRXZlbnRzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFRlbGwgdGhpcyBvYmplY3QgdG8gc3RvcCBsaXN0ZW5pbmcgdG8gZWl0aGVyIHNwZWNpZmljIGV2ZW50cyAuLi4gb3JcbiAgICAvLyB0byBldmVyeSBvYmplY3QgaXQncyBjdXJyZW50bHkgbGlzdGVuaW5nIHRvLlxuICAgIHN0b3BMaXN0ZW5pbmc6IGZ1bmN0aW9uKG9iaiwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBsaXN0ZW5pbmdUbyA9IHRoaXMuX2xpc3RlbmluZ1RvO1xuICAgICAgaWYgKCFsaXN0ZW5pbmdUbykgcmV0dXJuIHRoaXM7XG4gICAgICB2YXIgcmVtb3ZlID0gIW5hbWUgJiYgIWNhbGxiYWNrO1xuICAgICAgaWYgKCFjYWxsYmFjayAmJiB0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIGNhbGxiYWNrID0gdGhpcztcbiAgICAgIGlmIChvYmopIChsaXN0ZW5pbmdUbyA9IHt9KVtvYmouX2xpc3RlbklkXSA9IG9iajtcbiAgICAgIGZvciAodmFyIGlkIGluIGxpc3RlbmluZ1RvKSB7XG4gICAgICAgIG9iaiA9IGxpc3RlbmluZ1RvW2lkXTtcbiAgICAgICAgb2JqLm9mZihuYW1lLCBjYWxsYmFjaywgdGhpcyk7XG4gICAgICAgIGlmIChyZW1vdmUgfHwgXy5pc0VtcHR5KG9iai5fZXZlbnRzKSkgZGVsZXRlIHRoaXMuX2xpc3RlbmluZ1RvW2lkXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICB9O1xuXG4gIC8vIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHNwbGl0IGV2ZW50IHN0cmluZ3MuXG4gIHZhciBldmVudFNwbGl0dGVyID0gL1xccysvO1xuXG4gIC8vIEltcGxlbWVudCBmYW5jeSBmZWF0dXJlcyBvZiB0aGUgRXZlbnRzIEFQSSBzdWNoIGFzIG11bHRpcGxlIGV2ZW50XG4gIC8vIG5hbWVzIGBcImNoYW5nZSBibHVyXCJgIGFuZCBqUXVlcnktc3R5bGUgZXZlbnQgbWFwcyBge2NoYW5nZTogYWN0aW9ufWBcbiAgLy8gaW4gdGVybXMgb2YgdGhlIGV4aXN0aW5nIEFQSS5cbiAgdmFyIGV2ZW50c0FwaSA9IGZ1bmN0aW9uKG9iaiwgYWN0aW9uLCBuYW1lLCByZXN0KSB7XG4gICAgaWYgKCFuYW1lKSByZXR1cm4gdHJ1ZTtcblxuICAgIC8vIEhhbmRsZSBldmVudCBtYXBzLlxuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBuYW1lKSB7XG4gICAgICAgIG9ialthY3Rpb25dLmFwcGx5KG9iaiwgW2tleSwgbmFtZVtrZXldXS5jb25jYXQocmVzdCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBzcGFjZSBzZXBhcmF0ZWQgZXZlbnQgbmFtZXMuXG4gICAgaWYgKGV2ZW50U3BsaXR0ZXIudGVzdChuYW1lKSkge1xuICAgICAgdmFyIG5hbWVzID0gbmFtZS5zcGxpdChldmVudFNwbGl0dGVyKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbmFtZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG9ialthY3Rpb25dLmFwcGx5KG9iaiwgW25hbWVzW2ldXS5jb25jYXQocmVzdCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIEEgZGlmZmljdWx0LXRvLWJlbGlldmUsIGJ1dCBvcHRpbWl6ZWQgaW50ZXJuYWwgZGlzcGF0Y2ggZnVuY3Rpb24gZm9yXG4gIC8vIHRyaWdnZXJpbmcgZXZlbnRzLiBUcmllcyB0byBrZWVwIHRoZSB1c3VhbCBjYXNlcyBzcGVlZHkgKG1vc3QgaW50ZXJuYWxcbiAgLy8gQmFja2JvbmUgZXZlbnRzIGhhdmUgMyBhcmd1bWVudHMpLlxuICB2YXIgdHJpZ2dlckV2ZW50cyA9IGZ1bmN0aW9uKGV2ZW50cywgYXJncykge1xuICAgIHZhciBldiwgaSA9IC0xLCBsID0gZXZlbnRzLmxlbmd0aCwgYTEgPSBhcmdzWzBdLCBhMiA9IGFyZ3NbMV0sIGEzID0gYXJnc1syXTtcbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4KTsgcmV0dXJuO1xuICAgICAgY2FzZSAxOiB3aGlsZSAoKytpIDwgbCkgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5jYWxsKGV2LmN0eCwgYTEpOyByZXR1cm47XG4gICAgICBjYXNlIDI6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4LCBhMSwgYTIpOyByZXR1cm47XG4gICAgICBjYXNlIDM6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4LCBhMSwgYTIsIGEzKTsgcmV0dXJuO1xuICAgICAgZGVmYXVsdDogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suYXBwbHkoZXYuY3R4LCBhcmdzKTsgcmV0dXJuO1xuICAgIH1cbiAgfTtcblxuICB2YXIgbGlzdGVuTWV0aG9kcyA9IHtsaXN0ZW5UbzogJ29uJywgbGlzdGVuVG9PbmNlOiAnb25jZSd9O1xuXG4gIC8vIEludmVyc2lvbi1vZi1jb250cm9sIHZlcnNpb25zIG9mIGBvbmAgYW5kIGBvbmNlYC4gVGVsbCAqdGhpcyogb2JqZWN0IHRvXG4gIC8vIGxpc3RlbiB0byBhbiBldmVudCBpbiBhbm90aGVyIG9iamVjdCAuLi4ga2VlcGluZyB0cmFjayBvZiB3aGF0IGl0J3NcbiAgLy8gbGlzdGVuaW5nIHRvLlxuICBfLmVhY2gobGlzdGVuTWV0aG9kcywgZnVuY3Rpb24oaW1wbGVtZW50YXRpb24sIG1ldGhvZCkge1xuICAgIEV2ZW50c1ttZXRob2RdID0gZnVuY3Rpb24ob2JqLCBuYW1lLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGxpc3RlbmluZ1RvID0gdGhpcy5fbGlzdGVuaW5nVG8gfHwgKHRoaXMuX2xpc3RlbmluZ1RvID0ge30pO1xuICAgICAgdmFyIGlkID0gb2JqLl9saXN0ZW5JZCB8fCAob2JqLl9saXN0ZW5JZCA9IF8udW5pcXVlSWQoJ2wnKSk7XG4gICAgICBsaXN0ZW5pbmdUb1tpZF0gPSBvYmo7XG4gICAgICBpZiAoIWNhbGxiYWNrICYmIHR5cGVvZiBuYW1lID09PSAnb2JqZWN0JykgY2FsbGJhY2sgPSB0aGlzO1xuICAgICAgb2JqW2ltcGxlbWVudGF0aW9uXShuYW1lLCBjYWxsYmFjaywgdGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICB9KTtcblxuICAvLyBBbGlhc2VzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgRXZlbnRzLmJpbmQgICA9IEV2ZW50cy5vbjtcbiAgRXZlbnRzLnVuYmluZCA9IEV2ZW50cy5vZmY7XG5cbiAgLy8gQWxsb3cgdGhlIGBCYWNrYm9uZWAgb2JqZWN0IHRvIHNlcnZlIGFzIGEgZ2xvYmFsIGV2ZW50IGJ1cywgZm9yIGZvbGtzIHdob1xuICAvLyB3YW50IGdsb2JhbCBcInB1YnN1YlwiIGluIGEgY29udmVuaWVudCBwbGFjZS5cbiAgXy5leHRlbmQoQmFja2JvbmUsIEV2ZW50cyk7XG5cbiAgLy8gQmFja2JvbmUuTW9kZWxcbiAgLy8gLS0tLS0tLS0tLS0tLS1cblxuICAvLyBCYWNrYm9uZSAqKk1vZGVscyoqIGFyZSB0aGUgYmFzaWMgZGF0YSBvYmplY3QgaW4gdGhlIGZyYW1ld29yayAtLVxuICAvLyBmcmVxdWVudGx5IHJlcHJlc2VudGluZyBhIHJvdyBpbiBhIHRhYmxlIGluIGEgZGF0YWJhc2Ugb24geW91ciBzZXJ2ZXIuXG4gIC8vIEEgZGlzY3JldGUgY2h1bmsgb2YgZGF0YSBhbmQgYSBidW5jaCBvZiB1c2VmdWwsIHJlbGF0ZWQgbWV0aG9kcyBmb3JcbiAgLy8gcGVyZm9ybWluZyBjb21wdXRhdGlvbnMgYW5kIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGF0IGRhdGEuXG5cbiAgLy8gQ3JlYXRlIGEgbmV3IG1vZGVsIHdpdGggdGhlIHNwZWNpZmllZCBhdHRyaWJ1dGVzLiBBIGNsaWVudCBpZCAoYGNpZGApXG4gIC8vIGlzIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGFuZCBhc3NpZ25lZCBmb3IgeW91LlxuICB2YXIgTW9kZWwgPSBCYWNrYm9uZS5Nb2RlbCA9IGZ1bmN0aW9uKGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgYXR0cnMgPSBhdHRyaWJ1dGVzIHx8IHt9O1xuICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgdGhpcy5jaWQgPSBfLnVuaXF1ZUlkKCdjJyk7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgaWYgKG9wdGlvbnMuY29sbGVjdGlvbikgdGhpcy5jb2xsZWN0aW9uID0gb3B0aW9ucy5jb2xsZWN0aW9uO1xuICAgIGlmIChvcHRpb25zLnBhcnNlKSBhdHRycyA9IHRoaXMucGFyc2UoYXR0cnMsIG9wdGlvbnMpIHx8IHt9O1xuICAgIGF0dHJzID0gXy5kZWZhdWx0cyh7fSwgYXR0cnMsIF8ucmVzdWx0KHRoaXMsICdkZWZhdWx0cycpKTtcbiAgICB0aGlzLnNldChhdHRycywgb3B0aW9ucyk7XG4gICAgdGhpcy5jaGFuZ2VkID0ge307XG4gICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gQXR0YWNoIGFsbCBpbmhlcml0YWJsZSBtZXRob2RzIHRvIHRoZSBNb2RlbCBwcm90b3R5cGUuXG4gIF8uZXh0ZW5kKE1vZGVsLnByb3RvdHlwZSwgRXZlbnRzLCB7XG5cbiAgICAvLyBBIGhhc2ggb2YgYXR0cmlidXRlcyB3aG9zZSBjdXJyZW50IGFuZCBwcmV2aW91cyB2YWx1ZSBkaWZmZXIuXG4gICAgY2hhbmdlZDogbnVsbCxcblxuICAgIC8vIFRoZSB2YWx1ZSByZXR1cm5lZCBkdXJpbmcgdGhlIGxhc3QgZmFpbGVkIHZhbGlkYXRpb24uXG4gICAgdmFsaWRhdGlvbkVycm9yOiBudWxsLFxuXG4gICAgLy8gVGhlIGRlZmF1bHQgbmFtZSBmb3IgdGhlIEpTT04gYGlkYCBhdHRyaWJ1dGUgaXMgYFwiaWRcImAuIE1vbmdvREIgYW5kXG4gICAgLy8gQ291Y2hEQiB1c2VycyBtYXkgd2FudCB0byBzZXQgdGhpcyB0byBgXCJfaWRcImAuXG4gICAgaWRBdHRyaWJ1dGU6ICdpZCcsXG5cbiAgICAvLyBJbml0aWFsaXplIGlzIGFuIGVtcHR5IGZ1bmN0aW9uIGJ5IGRlZmF1bHQuIE92ZXJyaWRlIGl0IHdpdGggeW91ciBvd25cbiAgICAvLyBpbml0aWFsaXphdGlvbiBsb2dpYy5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpe30sXG5cbiAgICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBtb2RlbCdzIGBhdHRyaWJ1dGVzYCBvYmplY3QuXG4gICAgdG9KU09OOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gXy5jbG9uZSh0aGlzLmF0dHJpYnV0ZXMpO1xuICAgIH0sXG5cbiAgICAvLyBQcm94eSBgQmFja2JvbmUuc3luY2AgYnkgZGVmYXVsdCAtLSBidXQgb3ZlcnJpZGUgdGhpcyBpZiB5b3UgbmVlZFxuICAgIC8vIGN1c3RvbSBzeW5jaW5nIHNlbWFudGljcyBmb3IgKnRoaXMqIHBhcnRpY3VsYXIgbW9kZWwuXG4gICAgc3luYzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQmFja2JvbmUuc3luYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZS5cbiAgICBnZXQ6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbYXR0cl07XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgSFRNTC1lc2NhcGVkIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZS5cbiAgICBlc2NhcGU6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIHJldHVybiBfLmVzY2FwZSh0aGlzLmdldChhdHRyKSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBhdHRyaWJ1dGUgY29udGFpbnMgYSB2YWx1ZSB0aGF0IGlzIG5vdCBudWxsXG4gICAgLy8gb3IgdW5kZWZpbmVkLlxuICAgIGhhczogZnVuY3Rpb24oYXR0cikge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KGF0dHIpICE9IG51bGw7XG4gICAgfSxcblxuICAgIC8vIFNldCBhIGhhc2ggb2YgbW9kZWwgYXR0cmlidXRlcyBvbiB0aGUgb2JqZWN0LCBmaXJpbmcgYFwiY2hhbmdlXCJgLiBUaGlzIGlzXG4gICAgLy8gdGhlIGNvcmUgcHJpbWl0aXZlIG9wZXJhdGlvbiBvZiBhIG1vZGVsLCB1cGRhdGluZyB0aGUgZGF0YSBhbmQgbm90aWZ5aW5nXG4gICAgLy8gYW55b25lIHdobyBuZWVkcyB0byBrbm93IGFib3V0IHRoZSBjaGFuZ2UgaW4gc3RhdGUuIFRoZSBoZWFydCBvZiB0aGUgYmVhc3QuXG4gICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbCwgb3B0aW9ucykge1xuICAgICAgdmFyIGF0dHIsIGF0dHJzLCB1bnNldCwgY2hhbmdlcywgc2lsZW50LCBjaGFuZ2luZywgcHJldiwgY3VycmVudDtcbiAgICAgIGlmIChrZXkgPT0gbnVsbCkgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIEhhbmRsZSBib3RoIGBcImtleVwiLCB2YWx1ZWAgYW5kIGB7a2V5OiB2YWx1ZX1gIC1zdHlsZSBhcmd1bWVudHMuXG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYXR0cnMgPSBrZXk7XG4gICAgICAgIG9wdGlvbnMgPSB2YWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoYXR0cnMgPSB7fSlba2V5XSA9IHZhbDtcbiAgICAgIH1cblxuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcblxuICAgICAgLy8gUnVuIHZhbGlkYXRpb24uXG4gICAgICBpZiAoIXRoaXMuX3ZhbGlkYXRlKGF0dHJzLCBvcHRpb25zKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBFeHRyYWN0IGF0dHJpYnV0ZXMgYW5kIG9wdGlvbnMuXG4gICAgICB1bnNldCAgICAgICAgICAgPSBvcHRpb25zLnVuc2V0O1xuICAgICAgc2lsZW50ICAgICAgICAgID0gb3B0aW9ucy5zaWxlbnQ7XG4gICAgICBjaGFuZ2VzICAgICAgICAgPSBbXTtcbiAgICAgIGNoYW5naW5nICAgICAgICA9IHRoaXMuX2NoYW5naW5nO1xuICAgICAgdGhpcy5fY2hhbmdpbmcgID0gdHJ1ZTtcblxuICAgICAgaWYgKCFjaGFuZ2luZykge1xuICAgICAgICB0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXMgPSBfLmNsb25lKHRoaXMuYXR0cmlidXRlcyk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IHt9O1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IHRoaXMuYXR0cmlidXRlcywgcHJldiA9IHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcztcblxuICAgICAgLy8gQ2hlY2sgZm9yIGNoYW5nZXMgb2YgYGlkYC5cbiAgICAgIGlmICh0aGlzLmlkQXR0cmlidXRlIGluIGF0dHJzKSB0aGlzLmlkID0gYXR0cnNbdGhpcy5pZEF0dHJpYnV0ZV07XG5cbiAgICAgIC8vIEZvciBlYWNoIGBzZXRgIGF0dHJpYnV0ZSwgdXBkYXRlIG9yIGRlbGV0ZSB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICAgIGZvciAoYXR0ciBpbiBhdHRycykge1xuICAgICAgICB2YWwgPSBhdHRyc1thdHRyXTtcbiAgICAgICAgaWYgKCFfLmlzRXF1YWwoY3VycmVudFthdHRyXSwgdmFsKSkgY2hhbmdlcy5wdXNoKGF0dHIpO1xuICAgICAgICBpZiAoIV8uaXNFcXVhbChwcmV2W2F0dHJdLCB2YWwpKSB7XG4gICAgICAgICAgdGhpcy5jaGFuZ2VkW2F0dHJdID0gdmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmNoYW5nZWRbYXR0cl07XG4gICAgICAgIH1cbiAgICAgICAgdW5zZXQgPyBkZWxldGUgY3VycmVudFthdHRyXSA6IGN1cnJlbnRbYXR0cl0gPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIC8vIFRyaWdnZXIgYWxsIHJlbGV2YW50IGF0dHJpYnV0ZSBjaGFuZ2VzLlxuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMubGVuZ3RoKSB0aGlzLl9wZW5kaW5nID0gb3B0aW9ucztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGFuZ2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlOicgKyBjaGFuZ2VzW2ldLCB0aGlzLCBjdXJyZW50W2NoYW5nZXNbaV1dLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBZb3UgbWlnaHQgYmUgd29uZGVyaW5nIHdoeSB0aGVyZSdzIGEgYHdoaWxlYCBsb29wIGhlcmUuIENoYW5nZXMgY2FuXG4gICAgICAvLyBiZSByZWN1cnNpdmVseSBuZXN0ZWQgd2l0aGluIGBcImNoYW5nZVwiYCBldmVudHMuXG4gICAgICBpZiAoY2hhbmdpbmcpIHJldHVybiB0aGlzO1xuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuX3BlbmRpbmcpIHtcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5fcGVuZGluZztcbiAgICAgICAgICB0aGlzLl9wZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fcGVuZGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5fY2hhbmdpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgYW4gYXR0cmlidXRlIGZyb20gdGhlIG1vZGVsLCBmaXJpbmcgYFwiY2hhbmdlXCJgLiBgdW5zZXRgIGlzIGEgbm9vcFxuICAgIC8vIGlmIHRoZSBhdHRyaWJ1dGUgZG9lc24ndCBleGlzdC5cbiAgICB1bnNldDogZnVuY3Rpb24oYXR0ciwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KGF0dHIsIHZvaWQgMCwgXy5leHRlbmQoe30sIG9wdGlvbnMsIHt1bnNldDogdHJ1ZX0pKTtcbiAgICB9LFxuXG4gICAgLy8gQ2xlYXIgYWxsIGF0dHJpYnV0ZXMgb24gdGhlIG1vZGVsLCBmaXJpbmcgYFwiY2hhbmdlXCJgLlxuICAgIGNsZWFyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgYXR0cnMgPSB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmF0dHJpYnV0ZXMpIGF0dHJzW2tleV0gPSB2b2lkIDA7XG4gICAgICByZXR1cm4gdGhpcy5zZXQoYXR0cnMsIF8uZXh0ZW5kKHt9LCBvcHRpb25zLCB7dW5zZXQ6IHRydWV9KSk7XG4gICAgfSxcblxuICAgIC8vIERldGVybWluZSBpZiB0aGUgbW9kZWwgaGFzIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgYFwiY2hhbmdlXCJgIGV2ZW50LlxuICAgIC8vIElmIHlvdSBzcGVjaWZ5IGFuIGF0dHJpYnV0ZSBuYW1lLCBkZXRlcm1pbmUgaWYgdGhhdCBhdHRyaWJ1dGUgaGFzIGNoYW5nZWQuXG4gICAgaGFzQ2hhbmdlZDogZnVuY3Rpb24oYXR0cikge1xuICAgICAgaWYgKGF0dHIgPT0gbnVsbCkgcmV0dXJuICFfLmlzRW1wdHkodGhpcy5jaGFuZ2VkKTtcbiAgICAgIHJldHVybiBfLmhhcyh0aGlzLmNoYW5nZWQsIGF0dHIpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBhdHRyaWJ1dGVzIHRoYXQgaGF2ZSBjaGFuZ2VkLCBvclxuICAgIC8vIGZhbHNlIGlmIHRoZXJlIGFyZSBubyBjaGFuZ2VkIGF0dHJpYnV0ZXMuIFVzZWZ1bCBmb3IgZGV0ZXJtaW5pbmcgd2hhdFxuICAgIC8vIHBhcnRzIG9mIGEgdmlldyBuZWVkIHRvIGJlIHVwZGF0ZWQgYW5kL29yIHdoYXQgYXR0cmlidXRlcyBuZWVkIHRvIGJlXG4gICAgLy8gcGVyc2lzdGVkIHRvIHRoZSBzZXJ2ZXIuIFVuc2V0IGF0dHJpYnV0ZXMgd2lsbCBiZSBzZXQgdG8gdW5kZWZpbmVkLlxuICAgIC8vIFlvdSBjYW4gYWxzbyBwYXNzIGFuIGF0dHJpYnV0ZXMgb2JqZWN0IHRvIGRpZmYgYWdhaW5zdCB0aGUgbW9kZWwsXG4gICAgLy8gZGV0ZXJtaW5pbmcgaWYgdGhlcmUgKndvdWxkIGJlKiBhIGNoYW5nZS5cbiAgICBjaGFuZ2VkQXR0cmlidXRlczogZnVuY3Rpb24oZGlmZikge1xuICAgICAgaWYgKCFkaWZmKSByZXR1cm4gdGhpcy5oYXNDaGFuZ2VkKCkgPyBfLmNsb25lKHRoaXMuY2hhbmdlZCkgOiBmYWxzZTtcbiAgICAgIHZhciB2YWwsIGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIHZhciBvbGQgPSB0aGlzLl9jaGFuZ2luZyA/IHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcyA6IHRoaXMuYXR0cmlidXRlcztcbiAgICAgIGZvciAodmFyIGF0dHIgaW4gZGlmZikge1xuICAgICAgICBpZiAoXy5pc0VxdWFsKG9sZFthdHRyXSwgKHZhbCA9IGRpZmZbYXR0cl0pKSkgY29udGludWU7XG4gICAgICAgIChjaGFuZ2VkIHx8IChjaGFuZ2VkID0ge30pKVthdHRyXSA9IHZhbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIHByZXZpb3VzIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZSwgcmVjb3JkZWQgYXQgdGhlIHRpbWUgdGhlIGxhc3RcbiAgICAvLyBgXCJjaGFuZ2VcImAgZXZlbnQgd2FzIGZpcmVkLlxuICAgIHByZXZpb3VzOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICBpZiAoYXR0ciA9PSBudWxsIHx8ICF0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXMpIHJldHVybiBudWxsO1xuICAgICAgcmV0dXJuIHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlc1thdHRyXTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IGFsbCBvZiB0aGUgYXR0cmlidXRlcyBvZiB0aGUgbW9kZWwgYXQgdGhlIHRpbWUgb2YgdGhlIHByZXZpb3VzXG4gICAgLy8gYFwiY2hhbmdlXCJgIGV2ZW50LlxuICAgIHByZXZpb3VzQXR0cmlidXRlczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXy5jbG9uZSh0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXMpO1xuICAgIH0sXG5cbiAgICAvLyBGZXRjaCB0aGUgbW9kZWwgZnJvbSB0aGUgc2VydmVyLiBJZiB0aGUgc2VydmVyJ3MgcmVwcmVzZW50YXRpb24gb2YgdGhlXG4gICAgLy8gbW9kZWwgZGlmZmVycyBmcm9tIGl0cyBjdXJyZW50IGF0dHJpYnV0ZXMsIHRoZXkgd2lsbCBiZSBvdmVycmlkZGVuLFxuICAgIC8vIHRyaWdnZXJpbmcgYSBgXCJjaGFuZ2VcImAgZXZlbnQuXG4gICAgZmV0Y2g6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgaWYgKG9wdGlvbnMucGFyc2UgPT09IHZvaWQgMCkgb3B0aW9ucy5wYXJzZSA9IHRydWU7XG4gICAgICB2YXIgbW9kZWwgPSB0aGlzO1xuICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG4gICAgICBvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgIGlmICghbW9kZWwuc2V0KG1vZGVsLnBhcnNlKHJlc3AsIG9wdGlvbnMpLCBvcHRpb25zKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoc3VjY2Vzcykgc3VjY2Vzcyhtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICAgIG1vZGVsLnRyaWdnZXIoJ3N5bmMnLCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICB9O1xuICAgICAgd3JhcEVycm9yKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXMuc3luYygncmVhZCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgYSBoYXNoIG9mIG1vZGVsIGF0dHJpYnV0ZXMsIGFuZCBzeW5jIHRoZSBtb2RlbCB0byB0aGUgc2VydmVyLlxuICAgIC8vIElmIHRoZSBzZXJ2ZXIgcmV0dXJucyBhbiBhdHRyaWJ1dGVzIGhhc2ggdGhhdCBkaWZmZXJzLCB0aGUgbW9kZWwnc1xuICAgIC8vIHN0YXRlIHdpbGwgYmUgYHNldGAgYWdhaW4uXG4gICAgc2F2ZTogZnVuY3Rpb24oa2V5LCB2YWwsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBhdHRycywgbWV0aG9kLCB4aHIsIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cbiAgICAgIC8vIEhhbmRsZSBib3RoIGBcImtleVwiLCB2YWx1ZWAgYW5kIGB7a2V5OiB2YWx1ZX1gIC1zdHlsZSBhcmd1bWVudHMuXG4gICAgICBpZiAoa2V5ID09IG51bGwgfHwgdHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYXR0cnMgPSBrZXk7XG4gICAgICAgIG9wdGlvbnMgPSB2YWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoYXR0cnMgPSB7fSlba2V5XSA9IHZhbDtcbiAgICAgIH1cblxuICAgICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHt2YWxpZGF0ZTogdHJ1ZX0sIG9wdGlvbnMpO1xuXG4gICAgICAvLyBJZiB3ZSdyZSBub3Qgd2FpdGluZyBhbmQgYXR0cmlidXRlcyBleGlzdCwgc2F2ZSBhY3RzIGFzXG4gICAgICAvLyBgc2V0KGF0dHIpLnNhdmUobnVsbCwgb3B0cylgIHdpdGggdmFsaWRhdGlvbi4gT3RoZXJ3aXNlLCBjaGVjayBpZlxuICAgICAgLy8gdGhlIG1vZGVsIHdpbGwgYmUgdmFsaWQgd2hlbiB0aGUgYXR0cmlidXRlcywgaWYgYW55LCBhcmUgc2V0LlxuICAgICAgaWYgKGF0dHJzICYmICFvcHRpb25zLndhaXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNldChhdHRycywgb3B0aW9ucykpIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGhpcy5fdmFsaWRhdGUoYXR0cnMsIG9wdGlvbnMpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB0ZW1wb3JhcnkgYXR0cmlidXRlcyBpZiBge3dhaXQ6IHRydWV9YC5cbiAgICAgIGlmIChhdHRycyAmJiBvcHRpb25zLndhaXQpIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gXy5leHRlbmQoe30sIGF0dHJpYnV0ZXMsIGF0dHJzKTtcbiAgICAgIH1cblxuICAgICAgLy8gQWZ0ZXIgYSBzdWNjZXNzZnVsIHNlcnZlci1zaWRlIHNhdmUsIHRoZSBjbGllbnQgaXMgKG9wdGlvbmFsbHkpXG4gICAgICAvLyB1cGRhdGVkIHdpdGggdGhlIHNlcnZlci1zaWRlIHN0YXRlLlxuICAgICAgaWYgKG9wdGlvbnMucGFyc2UgPT09IHZvaWQgMCkgb3B0aW9ucy5wYXJzZSA9IHRydWU7XG4gICAgICB2YXIgbW9kZWwgPSB0aGlzO1xuICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG4gICAgICBvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgIC8vIEVuc3VyZSBhdHRyaWJ1dGVzIGFyZSByZXN0b3JlZCBkdXJpbmcgc3luY2hyb25vdXMgc2F2ZXMuXG4gICAgICAgIG1vZGVsLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICB2YXIgc2VydmVyQXR0cnMgPSBtb2RlbC5wYXJzZShyZXNwLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKG9wdGlvbnMud2FpdCkgc2VydmVyQXR0cnMgPSBfLmV4dGVuZChhdHRycyB8fCB7fSwgc2VydmVyQXR0cnMpO1xuICAgICAgICBpZiAoXy5pc09iamVjdChzZXJ2ZXJBdHRycykgJiYgIW1vZGVsLnNldChzZXJ2ZXJBdHRycywgb3B0aW9ucykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHN1Y2Nlc3MobW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgICBtb2RlbC50cmlnZ2VyKCdzeW5jJywgbW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgfTtcbiAgICAgIHdyYXBFcnJvcih0aGlzLCBvcHRpb25zKTtcblxuICAgICAgbWV0aG9kID0gdGhpcy5pc05ldygpID8gJ2NyZWF0ZScgOiAob3B0aW9ucy5wYXRjaCA/ICdwYXRjaCcgOiAndXBkYXRlJyk7XG4gICAgICBpZiAobWV0aG9kID09PSAncGF0Y2gnKSBvcHRpb25zLmF0dHJzID0gYXR0cnM7XG4gICAgICB4aHIgPSB0aGlzLnN5bmMobWV0aG9kLCB0aGlzLCBvcHRpb25zKTtcblxuICAgICAgLy8gUmVzdG9yZSBhdHRyaWJ1dGVzLlxuICAgICAgaWYgKGF0dHJzICYmIG9wdGlvbnMud2FpdCkgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcblxuICAgICAgcmV0dXJuIHhocjtcbiAgICB9LFxuXG4gICAgLy8gRGVzdHJveSB0aGlzIG1vZGVsIG9uIHRoZSBzZXJ2ZXIgaWYgaXQgd2FzIGFscmVhZHkgcGVyc2lzdGVkLlxuICAgIC8vIE9wdGltaXN0aWNhbGx5IHJlbW92ZXMgdGhlIG1vZGVsIGZyb20gaXRzIGNvbGxlY3Rpb24sIGlmIGl0IGhhcyBvbmUuXG4gICAgLy8gSWYgYHdhaXQ6IHRydWVgIGlzIHBhc3NlZCwgd2FpdHMgZm9yIHRoZSBzZXJ2ZXIgdG8gcmVzcG9uZCBiZWZvcmUgcmVtb3ZhbC5cbiAgICBkZXN0cm95OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyA/IF8uY2xvbmUob3B0aW9ucykgOiB7fTtcbiAgICAgIHZhciBtb2RlbCA9IHRoaXM7XG4gICAgICB2YXIgc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcztcblxuICAgICAgdmFyIGRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbW9kZWwudHJpZ2dlcignZGVzdHJveScsIG1vZGVsLCBtb2RlbC5jb2xsZWN0aW9uLCBvcHRpb25zKTtcbiAgICAgIH07XG5cbiAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgICAgaWYgKG9wdGlvbnMud2FpdCB8fCBtb2RlbC5pc05ldygpKSBkZXN0cm95KCk7XG4gICAgICAgIGlmIChzdWNjZXNzKSBzdWNjZXNzKG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKCFtb2RlbC5pc05ldygpKSBtb2RlbC50cmlnZ2VyKCdzeW5jJywgbW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuaXNOZXcoKSkge1xuICAgICAgICBvcHRpb25zLnN1Y2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgd3JhcEVycm9yKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICB2YXIgeGhyID0gdGhpcy5zeW5jKCdkZWxldGUnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgIGlmICghb3B0aW9ucy53YWl0KSBkZXN0cm95KCk7XG4gICAgICByZXR1cm4geGhyO1xuICAgIH0sXG5cbiAgICAvLyBEZWZhdWx0IFVSTCBmb3IgdGhlIG1vZGVsJ3MgcmVwcmVzZW50YXRpb24gb24gdGhlIHNlcnZlciAtLSBpZiB5b3UncmVcbiAgICAvLyB1c2luZyBCYWNrYm9uZSdzIHJlc3RmdWwgbWV0aG9kcywgb3ZlcnJpZGUgdGhpcyB0byBjaGFuZ2UgdGhlIGVuZHBvaW50XG4gICAgLy8gdGhhdCB3aWxsIGJlIGNhbGxlZC5cbiAgICB1cmw6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGJhc2UgPVxuICAgICAgICBfLnJlc3VsdCh0aGlzLCAndXJsUm9vdCcpIHx8XG4gICAgICAgIF8ucmVzdWx0KHRoaXMuY29sbGVjdGlvbiwgJ3VybCcpIHx8XG4gICAgICAgIHVybEVycm9yKCk7XG4gICAgICBpZiAodGhpcy5pc05ldygpKSByZXR1cm4gYmFzZTtcbiAgICAgIHJldHVybiBiYXNlLnJlcGxhY2UoLyhbXlxcL10pJC8sICckMS8nKSArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmlkKTtcbiAgICB9LFxuXG4gICAgLy8gKipwYXJzZSoqIGNvbnZlcnRzIGEgcmVzcG9uc2UgaW50byB0aGUgaGFzaCBvZiBhdHRyaWJ1dGVzIHRvIGJlIGBzZXRgIG9uXG4gICAgLy8gdGhlIG1vZGVsLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBpcyBqdXN0IHRvIHBhc3MgdGhlIHJlc3BvbnNlIGFsb25nLlxuICAgIHBhcnNlOiBmdW5jdGlvbihyZXNwLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gcmVzcDtcbiAgICB9LFxuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IG1vZGVsIHdpdGggaWRlbnRpY2FsIGF0dHJpYnV0ZXMgdG8gdGhpcyBvbmUuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuYXR0cmlidXRlcyk7XG4gICAgfSxcblxuICAgIC8vIEEgbW9kZWwgaXMgbmV3IGlmIGl0IGhhcyBuZXZlciBiZWVuIHNhdmVkIHRvIHRoZSBzZXJ2ZXIsIGFuZCBsYWNrcyBhbiBpZC5cbiAgICBpc05ldzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXRoaXMuaGFzKHRoaXMuaWRBdHRyaWJ1dGUpO1xuICAgIH0sXG5cbiAgICAvLyBDaGVjayBpZiB0aGUgbW9kZWwgaXMgY3VycmVudGx5IGluIGEgdmFsaWQgc3RhdGUuXG4gICAgaXNWYWxpZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRlKHt9LCBfLmV4dGVuZChvcHRpb25zIHx8IHt9LCB7IHZhbGlkYXRlOiB0cnVlIH0pKTtcbiAgICB9LFxuXG4gICAgLy8gUnVuIHZhbGlkYXRpb24gYWdhaW5zdCB0aGUgbmV4dCBjb21wbGV0ZSBzZXQgb2YgbW9kZWwgYXR0cmlidXRlcyxcbiAgICAvLyByZXR1cm5pbmcgYHRydWVgIGlmIGFsbCBpcyB3ZWxsLiBPdGhlcndpc2UsIGZpcmUgYW4gYFwiaW52YWxpZFwiYCBldmVudC5cbiAgICBfdmFsaWRhdGU6IGZ1bmN0aW9uKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIW9wdGlvbnMudmFsaWRhdGUgfHwgIXRoaXMudmFsaWRhdGUpIHJldHVybiB0cnVlO1xuICAgICAgYXR0cnMgPSBfLmV4dGVuZCh7fSwgdGhpcy5hdHRyaWJ1dGVzLCBhdHRycyk7XG4gICAgICB2YXIgZXJyb3IgPSB0aGlzLnZhbGlkYXRpb25FcnJvciA9IHRoaXMudmFsaWRhdGUoYXR0cnMsIG9wdGlvbnMpIHx8IG51bGw7XG4gICAgICBpZiAoIWVycm9yKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHRoaXMudHJpZ2dlcignaW52YWxpZCcsIHRoaXMsIGVycm9yLCBfLmV4dGVuZChvcHRpb25zLCB7dmFsaWRhdGlvbkVycm9yOiBlcnJvcn0pKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgLy8gVW5kZXJzY29yZSBtZXRob2RzIHRoYXQgd2Ugd2FudCB0byBpbXBsZW1lbnQgb24gdGhlIE1vZGVsLlxuICB2YXIgbW9kZWxNZXRob2RzID0gWydrZXlzJywgJ3ZhbHVlcycsICdwYWlycycsICdpbnZlcnQnLCAncGljaycsICdvbWl0J107XG5cbiAgLy8gTWl4IGluIGVhY2ggVW5kZXJzY29yZSBtZXRob2QgYXMgYSBwcm94eSB0byBgTW9kZWwjYXR0cmlidXRlc2AuXG4gIF8uZWFjaChtb2RlbE1ldGhvZHMsIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIE1vZGVsLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIGFyZ3MudW5zaGlmdCh0aGlzLmF0dHJpYnV0ZXMpO1xuICAgICAgcmV0dXJuIF9bbWV0aG9kXS5hcHBseShfLCBhcmdzKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBCYWNrYm9uZS5Db2xsZWN0aW9uXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBJZiBtb2RlbHMgdGVuZCB0byByZXByZXNlbnQgYSBzaW5nbGUgcm93IG9mIGRhdGEsIGEgQmFja2JvbmUgQ29sbGVjdGlvbiBpc1xuICAvLyBtb3JlIGFuYWxhZ291cyB0byBhIHRhYmxlIGZ1bGwgb2YgZGF0YSAuLi4gb3IgYSBzbWFsbCBzbGljZSBvciBwYWdlIG9mIHRoYXRcbiAgLy8gdGFibGUsIG9yIGEgY29sbGVjdGlvbiBvZiByb3dzIHRoYXQgYmVsb25nIHRvZ2V0aGVyIGZvciBhIHBhcnRpY3VsYXIgcmVhc29uXG4gIC8vIC0tIGFsbCBvZiB0aGUgbWVzc2FnZXMgaW4gdGhpcyBwYXJ0aWN1bGFyIGZvbGRlciwgYWxsIG9mIHRoZSBkb2N1bWVudHNcbiAgLy8gYmVsb25naW5nIHRvIHRoaXMgcGFydGljdWxhciBhdXRob3IsIGFuZCBzbyBvbi4gQ29sbGVjdGlvbnMgbWFpbnRhaW5cbiAgLy8gaW5kZXhlcyBvZiB0aGVpciBtb2RlbHMsIGJvdGggaW4gb3JkZXIsIGFuZCBmb3IgbG9va3VwIGJ5IGBpZGAuXG5cbiAgLy8gQ3JlYXRlIGEgbmV3ICoqQ29sbGVjdGlvbioqLCBwZXJoYXBzIHRvIGNvbnRhaW4gYSBzcGVjaWZpYyB0eXBlIG9mIGBtb2RlbGAuXG4gIC8vIElmIGEgYGNvbXBhcmF0b3JgIGlzIHNwZWNpZmllZCwgdGhlIENvbGxlY3Rpb24gd2lsbCBtYWludGFpblxuICAvLyBpdHMgbW9kZWxzIGluIHNvcnQgb3JkZXIsIGFzIHRoZXkncmUgYWRkZWQgYW5kIHJlbW92ZWQuXG4gIHZhciBDb2xsZWN0aW9uID0gQmFja2JvbmUuQ29sbGVjdGlvbiA9IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgaWYgKG9wdGlvbnMubW9kZWwpIHRoaXMubW9kZWwgPSBvcHRpb25zLm1vZGVsO1xuICAgIGlmIChvcHRpb25zLmNvbXBhcmF0b3IgIT09IHZvaWQgMCkgdGhpcy5jb21wYXJhdG9yID0gb3B0aW9ucy5jb21wYXJhdG9yO1xuICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKG1vZGVscykgdGhpcy5yZXNldChtb2RlbHMsIF8uZXh0ZW5kKHtzaWxlbnQ6IHRydWV9LCBvcHRpb25zKSk7XG4gIH07XG5cbiAgLy8gRGVmYXVsdCBvcHRpb25zIGZvciBgQ29sbGVjdGlvbiNzZXRgLlxuICB2YXIgc2V0T3B0aW9ucyA9IHthZGQ6IHRydWUsIHJlbW92ZTogdHJ1ZSwgbWVyZ2U6IHRydWV9O1xuICB2YXIgYWRkT3B0aW9ucyA9IHthZGQ6IHRydWUsIHJlbW92ZTogZmFsc2V9O1xuXG4gIC8vIERlZmluZSB0aGUgQ29sbGVjdGlvbidzIGluaGVyaXRhYmxlIG1ldGhvZHMuXG4gIF8uZXh0ZW5kKENvbGxlY3Rpb24ucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIC8vIFRoZSBkZWZhdWx0IG1vZGVsIGZvciBhIGNvbGxlY3Rpb24gaXMganVzdCBhICoqQmFja2JvbmUuTW9kZWwqKi5cbiAgICAvLyBUaGlzIHNob3VsZCBiZSBvdmVycmlkZGVuIGluIG1vc3QgY2FzZXMuXG4gICAgbW9kZWw6IE1vZGVsLFxuXG4gICAgLy8gSW5pdGlhbGl6ZSBpcyBhbiBlbXB0eSBmdW5jdGlvbiBieSBkZWZhdWx0LiBPdmVycmlkZSBpdCB3aXRoIHlvdXIgb3duXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gbG9naWMuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKXt9LFxuXG4gICAgLy8gVGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSBDb2xsZWN0aW9uIGlzIGFuIGFycmF5IG9mIHRoZVxuICAgIC8vIG1vZGVscycgYXR0cmlidXRlcy5cbiAgICB0b0pTT046IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihtb2RlbCl7IHJldHVybiBtb2RlbC50b0pTT04ob3B0aW9ucyk7IH0pO1xuICAgIH0sXG5cbiAgICAvLyBQcm94eSBgQmFja2JvbmUuc3luY2AgYnkgZGVmYXVsdC5cbiAgICBzeW5jOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBCYWNrYm9uZS5zeW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8vIEFkZCBhIG1vZGVsLCBvciBsaXN0IG9mIG1vZGVscyB0byB0aGUgc2V0LlxuICAgIGFkZDogZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXQobW9kZWxzLCBfLmV4dGVuZCh7bWVyZ2U6IGZhbHNlfSwgb3B0aW9ucywgYWRkT3B0aW9ucykpO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgYSBtb2RlbCwgb3IgYSBsaXN0IG9mIG1vZGVscyBmcm9tIHRoZSBzZXQuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzaW5ndWxhciA9ICFfLmlzQXJyYXkobW9kZWxzKTtcbiAgICAgIG1vZGVscyA9IHNpbmd1bGFyID8gW21vZGVsc10gOiBfLmNsb25lKG1vZGVscyk7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgICAgdmFyIGksIGwsIGluZGV4LCBtb2RlbDtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBtb2RlbHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG1vZGVsID0gbW9kZWxzW2ldID0gdGhpcy5nZXQobW9kZWxzW2ldKTtcbiAgICAgICAgaWYgKCFtb2RlbCkgY29udGludWU7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ieUlkW21vZGVsLmlkXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2J5SWRbbW9kZWwuY2lkXTtcbiAgICAgICAgaW5kZXggPSB0aGlzLmluZGV4T2YobW9kZWwpO1xuICAgICAgICB0aGlzLm1vZGVscy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB0aGlzLmxlbmd0aC0tO1xuICAgICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgb3B0aW9ucy5pbmRleCA9IGluZGV4O1xuICAgICAgICAgIG1vZGVsLnRyaWdnZXIoJ3JlbW92ZScsIG1vZGVsLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW1vdmVSZWZlcmVuY2UobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNpbmd1bGFyID8gbW9kZWxzWzBdIDogbW9kZWxzO1xuICAgIH0sXG5cbiAgICAvLyBVcGRhdGUgYSBjb2xsZWN0aW9uIGJ5IGBzZXRgLWluZyBhIG5ldyBsaXN0IG9mIG1vZGVscywgYWRkaW5nIG5ldyBvbmVzLFxuICAgIC8vIHJlbW92aW5nIG1vZGVscyB0aGF0IGFyZSBubyBsb25nZXIgcHJlc2VudCwgYW5kIG1lcmdpbmcgbW9kZWxzIHRoYXRcbiAgICAvLyBhbHJlYWR5IGV4aXN0IGluIHRoZSBjb2xsZWN0aW9uLCBhcyBuZWNlc3NhcnkuIFNpbWlsYXIgdG8gKipNb2RlbCNzZXQqKixcbiAgICAvLyB0aGUgY29yZSBvcGVyYXRpb24gZm9yIHVwZGF0aW5nIHRoZSBkYXRhIGNvbnRhaW5lZCBieSB0aGUgY29sbGVjdGlvbi5cbiAgICBzZXQ6IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IF8uZGVmYXVsdHMoe30sIG9wdGlvbnMsIHNldE9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMucGFyc2UpIG1vZGVscyA9IHRoaXMucGFyc2UobW9kZWxzLCBvcHRpb25zKTtcbiAgICAgIHZhciBzaW5ndWxhciA9ICFfLmlzQXJyYXkobW9kZWxzKTtcbiAgICAgIG1vZGVscyA9IHNpbmd1bGFyID8gKG1vZGVscyA/IFttb2RlbHNdIDogW10pIDogXy5jbG9uZShtb2RlbHMpO1xuICAgICAgdmFyIGksIGwsIGlkLCBtb2RlbCwgYXR0cnMsIGV4aXN0aW5nLCBzb3J0O1xuICAgICAgdmFyIGF0ID0gb3B0aW9ucy5hdDtcbiAgICAgIHZhciB0YXJnZXRNb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICB2YXIgc29ydGFibGUgPSB0aGlzLmNvbXBhcmF0b3IgJiYgKGF0ID09IG51bGwpICYmIG9wdGlvbnMuc29ydCAhPT0gZmFsc2U7XG4gICAgICB2YXIgc29ydEF0dHIgPSBfLmlzU3RyaW5nKHRoaXMuY29tcGFyYXRvcikgPyB0aGlzLmNvbXBhcmF0b3IgOiBudWxsO1xuICAgICAgdmFyIHRvQWRkID0gW10sIHRvUmVtb3ZlID0gW10sIG1vZGVsTWFwID0ge307XG4gICAgICB2YXIgYWRkID0gb3B0aW9ucy5hZGQsIG1lcmdlID0gb3B0aW9ucy5tZXJnZSwgcmVtb3ZlID0gb3B0aW9ucy5yZW1vdmU7XG4gICAgICB2YXIgb3JkZXIgPSAhc29ydGFibGUgJiYgYWRkICYmIHJlbW92ZSA/IFtdIDogZmFsc2U7XG5cbiAgICAgIC8vIFR1cm4gYmFyZSBvYmplY3RzIGludG8gbW9kZWwgcmVmZXJlbmNlcywgYW5kIHByZXZlbnQgaW52YWxpZCBtb2RlbHNcbiAgICAgIC8vIGZyb20gYmVpbmcgYWRkZWQuXG4gICAgICBmb3IgKGkgPSAwLCBsID0gbW9kZWxzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBhdHRycyA9IG1vZGVsc1tpXSB8fCB7fTtcbiAgICAgICAgaWYgKGF0dHJzIGluc3RhbmNlb2YgTW9kZWwpIHtcbiAgICAgICAgICBpZCA9IG1vZGVsID0gYXR0cnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWQgPSBhdHRyc1t0YXJnZXRNb2RlbC5wcm90b3R5cGUuaWRBdHRyaWJ1dGUgfHwgJ2lkJ107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBhIGR1cGxpY2F0ZSBpcyBmb3VuZCwgcHJldmVudCBpdCBmcm9tIGJlaW5nIGFkZGVkIGFuZFxuICAgICAgICAvLyBvcHRpb25hbGx5IG1lcmdlIGl0IGludG8gdGhlIGV4aXN0aW5nIG1vZGVsLlxuICAgICAgICBpZiAoZXhpc3RpbmcgPSB0aGlzLmdldChpZCkpIHtcbiAgICAgICAgICBpZiAocmVtb3ZlKSBtb2RlbE1hcFtleGlzdGluZy5jaWRdID0gdHJ1ZTtcbiAgICAgICAgICBpZiAobWVyZ2UpIHtcbiAgICAgICAgICAgIGF0dHJzID0gYXR0cnMgPT09IG1vZGVsID8gbW9kZWwuYXR0cmlidXRlcyA6IGF0dHJzO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGFyc2UpIGF0dHJzID0gZXhpc3RpbmcucGFyc2UoYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgZXhpc3Rpbmcuc2V0KGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChzb3J0YWJsZSAmJiAhc29ydCAmJiBleGlzdGluZy5oYXNDaGFuZ2VkKHNvcnRBdHRyKSkgc29ydCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1vZGVsc1tpXSA9IGV4aXN0aW5nO1xuXG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBuZXcsIHZhbGlkIG1vZGVsLCBwdXNoIGl0IHRvIHRoZSBgdG9BZGRgIGxpc3QuXG4gICAgICAgIH0gZWxzZSBpZiAoYWRkKSB7XG4gICAgICAgICAgbW9kZWwgPSBtb2RlbHNbaV0gPSB0aGlzLl9wcmVwYXJlTW9kZWwoYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICAgIGlmICghbW9kZWwpIGNvbnRpbnVlO1xuICAgICAgICAgIHRvQWRkLnB1c2gobW9kZWwpO1xuICAgICAgICAgIHRoaXMuX2FkZFJlZmVyZW5jZShtb2RlbCwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEbyBub3QgYWRkIG11bHRpcGxlIG1vZGVscyB3aXRoIHRoZSBzYW1lIGBpZGAuXG4gICAgICAgIG1vZGVsID0gZXhpc3RpbmcgfHwgbW9kZWw7XG4gICAgICAgIGlmIChvcmRlciAmJiAobW9kZWwuaXNOZXcoKSB8fCAhbW9kZWxNYXBbbW9kZWwuaWRdKSkgb3JkZXIucHVzaChtb2RlbCk7XG4gICAgICAgIG1vZGVsTWFwW21vZGVsLmlkXSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBub25leGlzdGVudCBtb2RlbHMgaWYgYXBwcm9wcmlhdGUuXG4gICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgIGlmICghbW9kZWxNYXBbKG1vZGVsID0gdGhpcy5tb2RlbHNbaV0pLmNpZF0pIHRvUmVtb3ZlLnB1c2gobW9kZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b1JlbW92ZS5sZW5ndGgpIHRoaXMucmVtb3ZlKHRvUmVtb3ZlLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2VlIGlmIHNvcnRpbmcgaXMgbmVlZGVkLCB1cGRhdGUgYGxlbmd0aGAgYW5kIHNwbGljZSBpbiBuZXcgbW9kZWxzLlxuICAgICAgaWYgKHRvQWRkLmxlbmd0aCB8fCAob3JkZXIgJiYgb3JkZXIubGVuZ3RoKSkge1xuICAgICAgICBpZiAoc29ydGFibGUpIHNvcnQgPSB0cnVlO1xuICAgICAgICB0aGlzLmxlbmd0aCArPSB0b0FkZC5sZW5ndGg7XG4gICAgICAgIGlmIChhdCAhPSBudWxsKSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgbCA9IHRvQWRkLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5tb2RlbHMuc3BsaWNlKGF0ICsgaSwgMCwgdG9BZGRbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAob3JkZXIpIHRoaXMubW9kZWxzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgdmFyIG9yZGVyZWRNb2RlbHMgPSBvcmRlciB8fCB0b0FkZDtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gb3JkZXJlZE1vZGVscy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMubW9kZWxzLnB1c2gob3JkZXJlZE1vZGVsc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFNpbGVudGx5IHNvcnQgdGhlIGNvbGxlY3Rpb24gaWYgYXBwcm9wcmlhdGUuXG4gICAgICBpZiAoc29ydCkgdGhpcy5zb3J0KHtzaWxlbnQ6IHRydWV9KTtcblxuICAgICAgLy8gVW5sZXNzIHNpbGVuY2VkLCBpdCdzIHRpbWUgdG8gZmlyZSBhbGwgYXBwcm9wcmlhdGUgYWRkL3NvcnQgZXZlbnRzLlxuICAgICAgaWYgKCFvcHRpb25zLnNpbGVudCkge1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gdG9BZGQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgKG1vZGVsID0gdG9BZGRbaV0pLnRyaWdnZXIoJ2FkZCcsIG1vZGVsLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc29ydCB8fCAob3JkZXIgJiYgb3JkZXIubGVuZ3RoKSkgdGhpcy50cmlnZ2VyKCdzb3J0JywgdGhpcywgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiB0aGUgYWRkZWQgKG9yIG1lcmdlZCkgbW9kZWwgKG9yIG1vZGVscykuXG4gICAgICByZXR1cm4gc2luZ3VsYXIgPyBtb2RlbHNbMF0gOiBtb2RlbHM7XG4gICAgfSxcblxuICAgIC8vIFdoZW4geW91IGhhdmUgbW9yZSBpdGVtcyB0aGFuIHlvdSB3YW50IHRvIGFkZCBvciByZW1vdmUgaW5kaXZpZHVhbGx5LFxuICAgIC8vIHlvdSBjYW4gcmVzZXQgdGhlIGVudGlyZSBzZXQgd2l0aCBhIG5ldyBsaXN0IG9mIG1vZGVscywgd2l0aG91dCBmaXJpbmdcbiAgICAvLyBhbnkgZ3JhbnVsYXIgYGFkZGAgb3IgYHJlbW92ZWAgZXZlbnRzLiBGaXJlcyBgcmVzZXRgIHdoZW4gZmluaXNoZWQuXG4gICAgLy8gVXNlZnVsIGZvciBidWxrIG9wZXJhdGlvbnMgYW5kIG9wdGltaXphdGlvbnMuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5tb2RlbHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZVJlZmVyZW5jZSh0aGlzLm1vZGVsc1tpXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBvcHRpb25zLnByZXZpb3VzTW9kZWxzID0gdGhpcy5tb2RlbHM7XG4gICAgICB0aGlzLl9yZXNldCgpO1xuICAgICAgbW9kZWxzID0gdGhpcy5hZGQobW9kZWxzLCBfLmV4dGVuZCh7c2lsZW50OiB0cnVlfSwgb3B0aW9ucykpO1xuICAgICAgaWYgKCFvcHRpb25zLnNpbGVudCkgdGhpcy50cmlnZ2VyKCdyZXNldCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIG1vZGVscztcbiAgICB9LFxuXG4gICAgLy8gQWRkIGEgbW9kZWwgdG8gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICBwdXNoOiBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuYWRkKG1vZGVsLCBfLmV4dGVuZCh7YXQ6IHRoaXMubGVuZ3RofSwgb3B0aW9ucykpO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgYSBtb2RlbCBmcm9tIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgcG9wOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgbW9kZWwgPSB0aGlzLmF0KHRoaXMubGVuZ3RoIC0gMSk7XG4gICAgICB0aGlzLnJlbW92ZShtb2RlbCwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gbW9kZWw7XG4gICAgfSxcblxuICAgIC8vIEFkZCBhIG1vZGVsIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgdW5zaGlmdDogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZChtb2RlbCwgXy5leHRlbmQoe2F0OiAwfSwgb3B0aW9ucykpO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgYSBtb2RlbCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgc2hpZnQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBtb2RlbCA9IHRoaXMuYXQoMCk7XG4gICAgICB0aGlzLnJlbW92ZShtb2RlbCwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gbW9kZWw7XG4gICAgfSxcblxuICAgIC8vIFNsaWNlIG91dCBhIHN1Yi1hcnJheSBvZiBtb2RlbHMgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAgICBzbGljZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc2xpY2UuYXBwbHkodGhpcy5tb2RlbHMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8vIEdldCBhIG1vZGVsIGZyb20gdGhlIHNldCBieSBpZC5cbiAgICBnZXQ6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgICAgcmV0dXJuIHRoaXMuX2J5SWRbb2JqXSB8fCB0aGlzLl9ieUlkW29iai5pZF0gfHwgdGhpcy5fYnlJZFtvYmouY2lkXTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBtb2RlbCBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgYXQ6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5tb2RlbHNbaW5kZXhdO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gbW9kZWxzIHdpdGggbWF0Y2hpbmcgYXR0cmlidXRlcy4gVXNlZnVsIGZvciBzaW1wbGUgY2FzZXMgb2ZcbiAgICAvLyBgZmlsdGVyYC5cbiAgICB3aGVyZTogZnVuY3Rpb24oYXR0cnMsIGZpcnN0KSB7XG4gICAgICBpZiAoXy5pc0VtcHR5KGF0dHJzKSkgcmV0dXJuIGZpcnN0ID8gdm9pZCAwIDogW107XG4gICAgICByZXR1cm4gdGhpc1tmaXJzdCA/ICdmaW5kJyA6ICdmaWx0ZXInXShmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgICBpZiAoYXR0cnNba2V5XSAhPT0gbW9kZWwuZ2V0KGtleSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gdGhlIGZpcnN0IG1vZGVsIHdpdGggbWF0Y2hpbmcgYXR0cmlidXRlcy4gVXNlZnVsIGZvciBzaW1wbGUgY2FzZXNcbiAgICAvLyBvZiBgZmluZGAuXG4gICAgZmluZFdoZXJlOiBmdW5jdGlvbihhdHRycykge1xuICAgICAgcmV0dXJuIHRoaXMud2hlcmUoYXR0cnMsIHRydWUpO1xuICAgIH0sXG5cbiAgICAvLyBGb3JjZSB0aGUgY29sbGVjdGlvbiB0byByZS1zb3J0IGl0c2VsZi4gWW91IGRvbid0IG5lZWQgdG8gY2FsbCB0aGlzIHVuZGVyXG4gICAgLy8gbm9ybWFsIGNpcmN1bXN0YW5jZXMsIGFzIHRoZSBzZXQgd2lsbCBtYWludGFpbiBzb3J0IG9yZGVyIGFzIGVhY2ggaXRlbVxuICAgIC8vIGlzIGFkZGVkLlxuICAgIHNvcnQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICghdGhpcy5jb21wYXJhdG9yKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzb3J0IGEgc2V0IHdpdGhvdXQgYSBjb21wYXJhdG9yJyk7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuXG4gICAgICAvLyBSdW4gc29ydCBiYXNlZCBvbiB0eXBlIG9mIGBjb21wYXJhdG9yYC5cbiAgICAgIGlmIChfLmlzU3RyaW5nKHRoaXMuY29tcGFyYXRvcikgfHwgdGhpcy5jb21wYXJhdG9yLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0aGlzLm1vZGVscyA9IHRoaXMuc29ydEJ5KHRoaXMuY29tcGFyYXRvciwgdGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1vZGVscy5zb3J0KF8uYmluZCh0aGlzLmNvbXBhcmF0b3IsIHRoaXMpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFvcHRpb25zLnNpbGVudCkgdGhpcy50cmlnZ2VyKCdzb3J0JywgdGhpcywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUGx1Y2sgYW4gYXR0cmlidXRlIGZyb20gZWFjaCBtb2RlbCBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICBwbHVjazogZnVuY3Rpb24oYXR0cikge1xuICAgICAgcmV0dXJuIF8uaW52b2tlKHRoaXMubW9kZWxzLCAnZ2V0JywgYXR0cik7XG4gICAgfSxcblxuICAgIC8vIEZldGNoIHRoZSBkZWZhdWx0IHNldCBvZiBtb2RlbHMgZm9yIHRoaXMgY29sbGVjdGlvbiwgcmVzZXR0aW5nIHRoZVxuICAgIC8vIGNvbGxlY3Rpb24gd2hlbiB0aGV5IGFycml2ZS4gSWYgYHJlc2V0OiB0cnVlYCBpcyBwYXNzZWQsIHRoZSByZXNwb25zZVxuICAgIC8vIGRhdGEgd2lsbCBiZSBwYXNzZWQgdGhyb3VnaCB0aGUgYHJlc2V0YCBtZXRob2QgaW5zdGVhZCBvZiBgc2V0YC5cbiAgICBmZXRjaDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBfLmNsb25lKG9wdGlvbnMpIDoge307XG4gICAgICBpZiAob3B0aW9ucy5wYXJzZSA9PT0gdm9pZCAwKSBvcHRpb25zLnBhcnNlID0gdHJ1ZTtcbiAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xuICAgICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzO1xuICAgICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICB2YXIgbWV0aG9kID0gb3B0aW9ucy5yZXNldCA/ICdyZXNldCcgOiAnc2V0JztcbiAgICAgICAgY29sbGVjdGlvblttZXRob2RdKHJlc3AsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoc3VjY2Vzcykgc3VjY2Vzcyhjb2xsZWN0aW9uLCByZXNwLCBvcHRpb25zKTtcbiAgICAgICAgY29sbGVjdGlvbi50cmlnZ2VyKCdzeW5jJywgY29sbGVjdGlvbiwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICB9O1xuICAgICAgd3JhcEVycm9yKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXMuc3luYygncmVhZCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgYSBtb2RlbCBpbiB0aGlzIGNvbGxlY3Rpb24uIEFkZCB0aGUgbW9kZWwgdG8gdGhlXG4gICAgLy8gY29sbGVjdGlvbiBpbW1lZGlhdGVseSwgdW5sZXNzIGB3YWl0OiB0cnVlYCBpcyBwYXNzZWQsIGluIHdoaWNoIGNhc2Ugd2VcbiAgICAvLyB3YWl0IGZvciB0aGUgc2VydmVyIHRvIGFncmVlLlxuICAgIGNyZWF0ZTogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgaWYgKCEobW9kZWwgPSB0aGlzLl9wcmVwYXJlTW9kZWwobW9kZWwsIG9wdGlvbnMpKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKCFvcHRpb25zLndhaXQpIHRoaXMuYWRkKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcztcbiAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xuICAgICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24obW9kZWwsIHJlc3ApIHtcbiAgICAgICAgaWYgKG9wdGlvbnMud2FpdCkgY29sbGVjdGlvbi5hZGQobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoc3VjY2Vzcykgc3VjY2Vzcyhtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICB9O1xuICAgICAgbW9kZWwuc2F2ZShudWxsLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBtb2RlbDtcbiAgICB9LFxuXG4gICAgLy8gKipwYXJzZSoqIGNvbnZlcnRzIGEgcmVzcG9uc2UgaW50byBhIGxpc3Qgb2YgbW9kZWxzIHRvIGJlIGFkZGVkIHRvIHRoZVxuICAgIC8vIGNvbGxlY3Rpb24uIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGlzIGp1c3QgdG8gcGFzcyBpdCB0aHJvdWdoLlxuICAgIHBhcnNlOiBmdW5jdGlvbihyZXNwLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gcmVzcDtcbiAgICB9LFxuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IGNvbGxlY3Rpb24gd2l0aCBhbiBpZGVudGljYWwgbGlzdCBvZiBtb2RlbHMgYXMgdGhpcyBvbmUuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMubW9kZWxzKTtcbiAgICB9LFxuXG4gICAgLy8gUHJpdmF0ZSBtZXRob2QgdG8gcmVzZXQgYWxsIGludGVybmFsIHN0YXRlLiBDYWxsZWQgd2hlbiB0aGUgY29sbGVjdGlvblxuICAgIC8vIGlzIGZpcnN0IGluaXRpYWxpemVkIG9yIHJlc2V0LlxuICAgIF9yZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLm1vZGVscyA9IFtdO1xuICAgICAgdGhpcy5fYnlJZCAgPSB7fTtcbiAgICB9LFxuXG4gICAgLy8gUHJlcGFyZSBhIGhhc2ggb2YgYXR0cmlidXRlcyAob3Igb3RoZXIgbW9kZWwpIHRvIGJlIGFkZGVkIHRvIHRoaXNcbiAgICAvLyBjb2xsZWN0aW9uLlxuICAgIF9wcmVwYXJlTW9kZWw6IGZ1bmN0aW9uKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICBpZiAoYXR0cnMgaW5zdGFuY2VvZiBNb2RlbCkgcmV0dXJuIGF0dHJzO1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBfLmNsb25lKG9wdGlvbnMpIDoge307XG4gICAgICBvcHRpb25zLmNvbGxlY3Rpb24gPSB0aGlzO1xuICAgICAgdmFyIG1vZGVsID0gbmV3IHRoaXMubW9kZWwoYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgaWYgKCFtb2RlbC52YWxpZGF0aW9uRXJyb3IpIHJldHVybiBtb2RlbDtcbiAgICAgIHRoaXMudHJpZ2dlcignaW52YWxpZCcsIHRoaXMsIG1vZGVsLnZhbGlkYXRpb25FcnJvciwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8vIEludGVybmFsIG1ldGhvZCB0byBjcmVhdGUgYSBtb2RlbCdzIHRpZXMgdG8gYSBjb2xsZWN0aW9uLlxuICAgIF9hZGRSZWZlcmVuY2U6IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICB0aGlzLl9ieUlkW21vZGVsLmNpZF0gPSBtb2RlbDtcbiAgICAgIGlmIChtb2RlbC5pZCAhPSBudWxsKSB0aGlzLl9ieUlkW21vZGVsLmlkXSA9IG1vZGVsO1xuICAgICAgaWYgKCFtb2RlbC5jb2xsZWN0aW9uKSBtb2RlbC5jb2xsZWN0aW9uID0gdGhpcztcbiAgICAgIG1vZGVsLm9uKCdhbGwnLCB0aGlzLl9vbk1vZGVsRXZlbnQsIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgdG8gc2V2ZXIgYSBtb2RlbCdzIHRpZXMgdG8gYSBjb2xsZWN0aW9uLlxuICAgIF9yZW1vdmVSZWZlcmVuY2U6IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcyA9PT0gbW9kZWwuY29sbGVjdGlvbikgZGVsZXRlIG1vZGVsLmNvbGxlY3Rpb247XG4gICAgICBtb2RlbC5vZmYoJ2FsbCcsIHRoaXMuX29uTW9kZWxFdmVudCwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8vIEludGVybmFsIG1ldGhvZCBjYWxsZWQgZXZlcnkgdGltZSBhIG1vZGVsIGluIHRoZSBzZXQgZmlyZXMgYW4gZXZlbnQuXG4gICAgLy8gU2V0cyBuZWVkIHRvIHVwZGF0ZSB0aGVpciBpbmRleGVzIHdoZW4gbW9kZWxzIGNoYW5nZSBpZHMuIEFsbCBvdGhlclxuICAgIC8vIGV2ZW50cyBzaW1wbHkgcHJveHkgdGhyb3VnaC4gXCJhZGRcIiBhbmQgXCJyZW1vdmVcIiBldmVudHMgdGhhdCBvcmlnaW5hdGVcbiAgICAvLyBpbiBvdGhlciBjb2xsZWN0aW9ucyBhcmUgaWdub3JlZC5cbiAgICBfb25Nb2RlbEV2ZW50OiBmdW5jdGlvbihldmVudCwgbW9kZWwsIGNvbGxlY3Rpb24sIG9wdGlvbnMpIHtcbiAgICAgIGlmICgoZXZlbnQgPT09ICdhZGQnIHx8IGV2ZW50ID09PSAncmVtb3ZlJykgJiYgY29sbGVjdGlvbiAhPT0gdGhpcykgcmV0dXJuO1xuICAgICAgaWYgKGV2ZW50ID09PSAnZGVzdHJveScpIHRoaXMucmVtb3ZlKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgIGlmIChtb2RlbCAmJiBldmVudCA9PT0gJ2NoYW5nZTonICsgbW9kZWwuaWRBdHRyaWJ1dGUpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2J5SWRbbW9kZWwucHJldmlvdXMobW9kZWwuaWRBdHRyaWJ1dGUpXTtcbiAgICAgICAgaWYgKG1vZGVsLmlkICE9IG51bGwpIHRoaXMuX2J5SWRbbW9kZWwuaWRdID0gbW9kZWw7XG4gICAgICB9XG4gICAgICB0aGlzLnRyaWdnZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgLy8gVW5kZXJzY29yZSBtZXRob2RzIHRoYXQgd2Ugd2FudCB0byBpbXBsZW1lbnQgb24gdGhlIENvbGxlY3Rpb24uXG4gIC8vIDkwJSBvZiB0aGUgY29yZSB1c2VmdWxuZXNzIG9mIEJhY2tib25lIENvbGxlY3Rpb25zIGlzIGFjdHVhbGx5IGltcGxlbWVudGVkXG4gIC8vIHJpZ2h0IGhlcmU6XG4gIHZhciBtZXRob2RzID0gWydmb3JFYWNoJywgJ2VhY2gnLCAnbWFwJywgJ2NvbGxlY3QnLCAncmVkdWNlJywgJ2ZvbGRsJyxcbiAgICAnaW5qZWN0JywgJ3JlZHVjZVJpZ2h0JywgJ2ZvbGRyJywgJ2ZpbmQnLCAnZGV0ZWN0JywgJ2ZpbHRlcicsICdzZWxlY3QnLFxuICAgICdyZWplY3QnLCAnZXZlcnknLCAnYWxsJywgJ3NvbWUnLCAnYW55JywgJ2luY2x1ZGUnLCAnY29udGFpbnMnLCAnaW52b2tlJyxcbiAgICAnbWF4JywgJ21pbicsICd0b0FycmF5JywgJ3NpemUnLCAnZmlyc3QnLCAnaGVhZCcsICd0YWtlJywgJ2luaXRpYWwnLCAncmVzdCcsXG4gICAgJ3RhaWwnLCAnZHJvcCcsICdsYXN0JywgJ3dpdGhvdXQnLCAnZGlmZmVyZW5jZScsICdpbmRleE9mJywgJ3NodWZmbGUnLFxuICAgICdsYXN0SW5kZXhPZicsICdpc0VtcHR5JywgJ2NoYWluJywgJ3NhbXBsZSddO1xuXG4gIC8vIE1peCBpbiBlYWNoIFVuZGVyc2NvcmUgbWV0aG9kIGFzIGEgcHJveHkgdG8gYENvbGxlY3Rpb24jbW9kZWxzYC5cbiAgXy5lYWNoKG1ldGhvZHMsIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIENvbGxlY3Rpb24ucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgYXJncy51bnNoaWZ0KHRoaXMubW9kZWxzKTtcbiAgICAgIHJldHVybiBfW21ldGhvZF0uYXBwbHkoXywgYXJncyk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gVW5kZXJzY29yZSBtZXRob2RzIHRoYXQgdGFrZSBhIHByb3BlcnR5IG5hbWUgYXMgYW4gYXJndW1lbnQuXG4gIHZhciBhdHRyaWJ1dGVNZXRob2RzID0gWydncm91cEJ5JywgJ2NvdW50QnknLCAnc29ydEJ5JywgJ2luZGV4QnknXTtcblxuICAvLyBVc2UgYXR0cmlidXRlcyBpbnN0ZWFkIG9mIHByb3BlcnRpZXMuXG4gIF8uZWFjaChhdHRyaWJ1dGVNZXRob2RzLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odmFsdWUsIGNvbnRleHQpIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IF8uaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZSA6IGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgIHJldHVybiBtb2RlbC5nZXQodmFsdWUpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfW21ldGhvZF0odGhpcy5tb2RlbHMsIGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBCYWNrYm9uZS5WaWV3XG4gIC8vIC0tLS0tLS0tLS0tLS1cblxuICAvLyBCYWNrYm9uZSBWaWV3cyBhcmUgYWxtb3N0IG1vcmUgY29udmVudGlvbiB0aGFuIHRoZXkgYXJlIGFjdHVhbCBjb2RlLiBBIFZpZXdcbiAgLy8gaXMgc2ltcGx5IGEgSmF2YVNjcmlwdCBvYmplY3QgdGhhdCByZXByZXNlbnRzIGEgbG9naWNhbCBjaHVuayBvZiBVSSBpbiB0aGVcbiAgLy8gRE9NLiBUaGlzIG1pZ2h0IGJlIGEgc2luZ2xlIGl0ZW0sIGFuIGVudGlyZSBsaXN0LCBhIHNpZGViYXIgb3IgcGFuZWwsIG9yXG4gIC8vIGV2ZW4gdGhlIHN1cnJvdW5kaW5nIGZyYW1lIHdoaWNoIHdyYXBzIHlvdXIgd2hvbGUgYXBwLiBEZWZpbmluZyBhIGNodW5rIG9mXG4gIC8vIFVJIGFzIGEgKipWaWV3KiogYWxsb3dzIHlvdSB0byBkZWZpbmUgeW91ciBET00gZXZlbnRzIGRlY2xhcmF0aXZlbHksIHdpdGhvdXRcbiAgLy8gaGF2aW5nIHRvIHdvcnJ5IGFib3V0IHJlbmRlciBvcmRlciAuLi4gYW5kIG1ha2VzIGl0IGVhc3kgZm9yIHRoZSB2aWV3IHRvXG4gIC8vIHJlYWN0IHRvIHNwZWNpZmljIGNoYW5nZXMgaW4gdGhlIHN0YXRlIG9mIHlvdXIgbW9kZWxzLlxuXG4gIC8vIENyZWF0aW5nIGEgQmFja2JvbmUuVmlldyBjcmVhdGVzIGl0cyBpbml0aWFsIGVsZW1lbnQgb3V0c2lkZSBvZiB0aGUgRE9NLFxuICAvLyBpZiBhbiBleGlzdGluZyBlbGVtZW50IGlzIG5vdCBwcm92aWRlZC4uLlxuICB2YXIgVmlldyA9IEJhY2tib25lLlZpZXcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5jaWQgPSBfLnVuaXF1ZUlkKCd2aWV3Jyk7XG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICBfLmV4dGVuZCh0aGlzLCBfLnBpY2sob3B0aW9ucywgdmlld09wdGlvbnMpKTtcbiAgICB0aGlzLl9lbnN1cmVFbGVtZW50KCk7XG4gICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5kZWxlZ2F0ZUV2ZW50cygpO1xuICB9O1xuXG4gIC8vIENhY2hlZCByZWdleCB0byBzcGxpdCBrZXlzIGZvciBgZGVsZWdhdGVgLlxuICB2YXIgZGVsZWdhdGVFdmVudFNwbGl0dGVyID0gL14oXFxTKylcXHMqKC4qKSQvO1xuXG4gIC8vIExpc3Qgb2YgdmlldyBvcHRpb25zIHRvIGJlIG1lcmdlZCBhcyBwcm9wZXJ0aWVzLlxuICB2YXIgdmlld09wdGlvbnMgPSBbJ21vZGVsJywgJ2NvbGxlY3Rpb24nLCAnZWwnLCAnaWQnLCAnYXR0cmlidXRlcycsICdjbGFzc05hbWUnLCAndGFnTmFtZScsICdldmVudHMnXTtcblxuICAvLyBTZXQgdXAgYWxsIGluaGVyaXRhYmxlICoqQmFja2JvbmUuVmlldyoqIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG4gIF8uZXh0ZW5kKFZpZXcucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIC8vIFRoZSBkZWZhdWx0IGB0YWdOYW1lYCBvZiBhIFZpZXcncyBlbGVtZW50IGlzIGBcImRpdlwiYC5cbiAgICB0YWdOYW1lOiAnZGl2JyxcblxuICAgIC8vIGpRdWVyeSBkZWxlZ2F0ZSBmb3IgZWxlbWVudCBsb29rdXAsIHNjb3BlZCB0byBET00gZWxlbWVudHMgd2l0aGluIHRoZVxuICAgIC8vIGN1cnJlbnQgdmlldy4gVGhpcyBzaG91bGQgYmUgcHJlZmVycmVkIHRvIGdsb2JhbCBsb29rdXBzIHdoZXJlIHBvc3NpYmxlLlxuICAgICQ6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy4kZWwuZmluZChzZWxlY3Rvcik7XG4gICAgfSxcblxuICAgIC8vIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7fSxcblxuICAgIC8vICoqcmVuZGVyKiogaXMgdGhlIGNvcmUgZnVuY3Rpb24gdGhhdCB5b3VyIHZpZXcgc2hvdWxkIG92ZXJyaWRlLCBpbiBvcmRlclxuICAgIC8vIHRvIHBvcHVsYXRlIGl0cyBlbGVtZW50IChgdGhpcy5lbGApLCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBIVE1MLiBUaGVcbiAgICAvLyBjb252ZW50aW9uIGlzIGZvciAqKnJlbmRlcioqIHRvIGFsd2F5cyByZXR1cm4gYHRoaXNgLlxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIHRoaXMgdmlldyBieSB0YWtpbmcgdGhlIGVsZW1lbnQgb3V0IG9mIHRoZSBET00sIGFuZCByZW1vdmluZyBhbnlcbiAgICAvLyBhcHBsaWNhYmxlIEJhY2tib25lLkV2ZW50cyBsaXN0ZW5lcnMuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuJGVsLnJlbW92ZSgpO1xuICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQ2hhbmdlIHRoZSB2aWV3J3MgZWxlbWVudCAoYHRoaXMuZWxgIHByb3BlcnR5KSwgaW5jbHVkaW5nIGV2ZW50XG4gICAgLy8gcmUtZGVsZWdhdGlvbi5cbiAgICBzZXRFbGVtZW50OiBmdW5jdGlvbihlbGVtZW50LCBkZWxlZ2F0ZSkge1xuICAgICAgaWYgKHRoaXMuJGVsKSB0aGlzLnVuZGVsZWdhdGVFdmVudHMoKTtcbiAgICAgIHRoaXMuJGVsID0gZWxlbWVudCBpbnN0YW5jZW9mIEJhY2tib25lLiQgPyBlbGVtZW50IDogQmFja2JvbmUuJChlbGVtZW50KTtcbiAgICAgIHRoaXMuZWwgPSB0aGlzLiRlbFswXTtcbiAgICAgIGlmIChkZWxlZ2F0ZSAhPT0gZmFsc2UpIHRoaXMuZGVsZWdhdGVFdmVudHMoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgY2FsbGJhY2tzLCB3aGVyZSBgdGhpcy5ldmVudHNgIGlzIGEgaGFzaCBvZlxuICAgIC8vXG4gICAgLy8gKntcImV2ZW50IHNlbGVjdG9yXCI6IFwiY2FsbGJhY2tcIn0qXG4gICAgLy9cbiAgICAvLyAgICAge1xuICAgIC8vICAgICAgICdtb3VzZWRvd24gLnRpdGxlJzogICdlZGl0JyxcbiAgICAvLyAgICAgICAnY2xpY2sgLmJ1dHRvbic6ICAgICAnc2F2ZScsXG4gICAgLy8gICAgICAgJ2NsaWNrIC5vcGVuJzogICAgICAgZnVuY3Rpb24oZSkgeyAuLi4gfVxuICAgIC8vICAgICB9XG4gICAgLy9cbiAgICAvLyBwYWlycy4gQ2FsbGJhY2tzIHdpbGwgYmUgYm91bmQgdG8gdGhlIHZpZXcsIHdpdGggYHRoaXNgIHNldCBwcm9wZXJseS5cbiAgICAvLyBVc2VzIGV2ZW50IGRlbGVnYXRpb24gZm9yIGVmZmljaWVuY3kuXG4gICAgLy8gT21pdHRpbmcgdGhlIHNlbGVjdG9yIGJpbmRzIHRoZSBldmVudCB0byBgdGhpcy5lbGAuXG4gICAgLy8gVGhpcyBvbmx5IHdvcmtzIGZvciBkZWxlZ2F0ZS1hYmxlIGV2ZW50czogbm90IGBmb2N1c2AsIGBibHVyYCwgYW5kXG4gICAgLy8gbm90IGBjaGFuZ2VgLCBgc3VibWl0YCwgYW5kIGByZXNldGAgaW4gSW50ZXJuZXQgRXhwbG9yZXIuXG4gICAgZGVsZWdhdGVFdmVudHM6IGZ1bmN0aW9uKGV2ZW50cykge1xuICAgICAgaWYgKCEoZXZlbnRzIHx8IChldmVudHMgPSBfLnJlc3VsdCh0aGlzLCAnZXZlbnRzJykpKSkgcmV0dXJuIHRoaXM7XG4gICAgICB0aGlzLnVuZGVsZWdhdGVFdmVudHMoKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBldmVudHMpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IGV2ZW50c1trZXldO1xuICAgICAgICBpZiAoIV8uaXNGdW5jdGlvbihtZXRob2QpKSBtZXRob2QgPSB0aGlzW2V2ZW50c1trZXldXTtcbiAgICAgICAgaWYgKCFtZXRob2QpIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciBtYXRjaCA9IGtleS5tYXRjaChkZWxlZ2F0ZUV2ZW50U3BsaXR0ZXIpO1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gbWF0Y2hbMV0sIHNlbGVjdG9yID0gbWF0Y2hbMl07XG4gICAgICAgIG1ldGhvZCA9IF8uYmluZChtZXRob2QsIHRoaXMpO1xuICAgICAgICBldmVudE5hbWUgKz0gJy5kZWxlZ2F0ZUV2ZW50cycgKyB0aGlzLmNpZDtcbiAgICAgICAgaWYgKHNlbGVjdG9yID09PSAnJykge1xuICAgICAgICAgIHRoaXMuJGVsLm9uKGV2ZW50TmFtZSwgbWV0aG9kKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLiRlbC5vbihldmVudE5hbWUsIHNlbGVjdG9yLCBtZXRob2QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQ2xlYXJzIGFsbCBjYWxsYmFja3MgcHJldmlvdXNseSBib3VuZCB0byB0aGUgdmlldyB3aXRoIGBkZWxlZ2F0ZUV2ZW50c2AuXG4gICAgLy8gWW91IHVzdWFsbHkgZG9uJ3QgbmVlZCB0byB1c2UgdGhpcywgYnV0IG1heSB3aXNoIHRvIGlmIHlvdSBoYXZlIG11bHRpcGxlXG4gICAgLy8gQmFja2JvbmUgdmlld3MgYXR0YWNoZWQgdG8gdGhlIHNhbWUgRE9NIGVsZW1lbnQuXG4gICAgdW5kZWxlZ2F0ZUV2ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLiRlbC5vZmYoJy5kZWxlZ2F0ZUV2ZW50cycgKyB0aGlzLmNpZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIFZpZXcgaGFzIGEgRE9NIGVsZW1lbnQgdG8gcmVuZGVyIGludG8uXG4gICAgLy8gSWYgYHRoaXMuZWxgIGlzIGEgc3RyaW5nLCBwYXNzIGl0IHRocm91Z2ggYCQoKWAsIHRha2UgdGhlIGZpcnN0XG4gICAgLy8gbWF0Y2hpbmcgZWxlbWVudCwgYW5kIHJlLWFzc2lnbiBpdCB0byBgZWxgLiBPdGhlcndpc2UsIGNyZWF0ZVxuICAgIC8vIGFuIGVsZW1lbnQgZnJvbSB0aGUgYGlkYCwgYGNsYXNzTmFtZWAgYW5kIGB0YWdOYW1lYCBwcm9wZXJ0aWVzLlxuICAgIF9lbnN1cmVFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5lbCkge1xuICAgICAgICB2YXIgYXR0cnMgPSBfLmV4dGVuZCh7fSwgXy5yZXN1bHQodGhpcywgJ2F0dHJpYnV0ZXMnKSk7XG4gICAgICAgIGlmICh0aGlzLmlkKSBhdHRycy5pZCA9IF8ucmVzdWx0KHRoaXMsICdpZCcpO1xuICAgICAgICBpZiAodGhpcy5jbGFzc05hbWUpIGF0dHJzWydjbGFzcyddID0gXy5yZXN1bHQodGhpcywgJ2NsYXNzTmFtZScpO1xuICAgICAgICB2YXIgJGVsID0gQmFja2JvbmUuJCgnPCcgKyBfLnJlc3VsdCh0aGlzLCAndGFnTmFtZScpICsgJz4nKS5hdHRyKGF0dHJzKTtcbiAgICAgICAgdGhpcy5zZXRFbGVtZW50KCRlbCwgZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRFbGVtZW50KF8ucmVzdWx0KHRoaXMsICdlbCcpLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIEJhY2tib25lLnN5bmNcbiAgLy8gLS0tLS0tLS0tLS0tLVxuXG4gIC8vIE92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gdG8gY2hhbmdlIHRoZSBtYW5uZXIgaW4gd2hpY2ggQmFja2JvbmUgcGVyc2lzdHNcbiAgLy8gbW9kZWxzIHRvIHRoZSBzZXJ2ZXIuIFlvdSB3aWxsIGJlIHBhc3NlZCB0aGUgdHlwZSBvZiByZXF1ZXN0LCBhbmQgdGhlXG4gIC8vIG1vZGVsIGluIHF1ZXN0aW9uLiBCeSBkZWZhdWx0LCBtYWtlcyBhIFJFU1RmdWwgQWpheCByZXF1ZXN0XG4gIC8vIHRvIHRoZSBtb2RlbCdzIGB1cmwoKWAuIFNvbWUgcG9zc2libGUgY3VzdG9taXphdGlvbnMgY291bGQgYmU6XG4gIC8vXG4gIC8vICogVXNlIGBzZXRUaW1lb3V0YCB0byBiYXRjaCByYXBpZC1maXJlIHVwZGF0ZXMgaW50byBhIHNpbmdsZSByZXF1ZXN0LlxuICAvLyAqIFNlbmQgdXAgdGhlIG1vZGVscyBhcyBYTUwgaW5zdGVhZCBvZiBKU09OLlxuICAvLyAqIFBlcnNpc3QgbW9kZWxzIHZpYSBXZWJTb2NrZXRzIGluc3RlYWQgb2YgQWpheC5cbiAgLy9cbiAgLy8gVHVybiBvbiBgQmFja2JvbmUuZW11bGF0ZUhUVFBgIGluIG9yZGVyIHRvIHNlbmQgYFBVVGAgYW5kIGBERUxFVEVgIHJlcXVlc3RzXG4gIC8vIGFzIGBQT1NUYCwgd2l0aCBhIGBfbWV0aG9kYCBwYXJhbWV0ZXIgY29udGFpbmluZyB0aGUgdHJ1ZSBIVFRQIG1ldGhvZCxcbiAgLy8gYXMgd2VsbCBhcyBhbGwgcmVxdWVzdHMgd2l0aCB0aGUgYm9keSBhcyBgYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkYFxuICAvLyBpbnN0ZWFkIG9mIGBhcHBsaWNhdGlvbi9qc29uYCB3aXRoIHRoZSBtb2RlbCBpbiBhIHBhcmFtIG5hbWVkIGBtb2RlbGAuXG4gIC8vIFVzZWZ1bCB3aGVuIGludGVyZmFjaW5nIHdpdGggc2VydmVyLXNpZGUgbGFuZ3VhZ2VzIGxpa2UgKipQSFAqKiB0aGF0IG1ha2VcbiAgLy8gaXQgZGlmZmljdWx0IHRvIHJlYWQgdGhlIGJvZHkgb2YgYFBVVGAgcmVxdWVzdHMuXG4gIEJhY2tib25lLnN5bmMgPSBmdW5jdGlvbihtZXRob2QsIG1vZGVsLCBvcHRpb25zKSB7XG4gICAgdmFyIHR5cGUgPSBtZXRob2RNYXBbbWV0aG9kXTtcblxuICAgIC8vIERlZmF1bHQgb3B0aW9ucywgdW5sZXNzIHNwZWNpZmllZC5cbiAgICBfLmRlZmF1bHRzKG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSksIHtcbiAgICAgIGVtdWxhdGVIVFRQOiBCYWNrYm9uZS5lbXVsYXRlSFRUUCxcbiAgICAgIGVtdWxhdGVKU09OOiBCYWNrYm9uZS5lbXVsYXRlSlNPTlxuICAgIH0pO1xuXG4gICAgLy8gRGVmYXVsdCBKU09OLXJlcXVlc3Qgb3B0aW9ucy5cbiAgICB2YXIgcGFyYW1zID0ge3R5cGU6IHR5cGUsIGRhdGFUeXBlOiAnanNvbid9O1xuXG4gICAgLy8gRW5zdXJlIHRoYXQgd2UgaGF2ZSBhIFVSTC5cbiAgICBpZiAoIW9wdGlvbnMudXJsKSB7XG4gICAgICBwYXJhbXMudXJsID0gXy5yZXN1bHQobW9kZWwsICd1cmwnKSB8fCB1cmxFcnJvcigpO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSB0aGF0IHdlIGhhdmUgdGhlIGFwcHJvcHJpYXRlIHJlcXVlc3QgZGF0YS5cbiAgICBpZiAob3B0aW9ucy5kYXRhID09IG51bGwgJiYgbW9kZWwgJiYgKG1ldGhvZCA9PT0gJ2NyZWF0ZScgfHwgbWV0aG9kID09PSAndXBkYXRlJyB8fCBtZXRob2QgPT09ICdwYXRjaCcpKSB7XG4gICAgICBwYXJhbXMuY29udGVudFR5cGUgPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICBwYXJhbXMuZGF0YSA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuYXR0cnMgfHwgbW9kZWwudG9KU09OKG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICAvLyBGb3Igb2xkZXIgc2VydmVycywgZW11bGF0ZSBKU09OIGJ5IGVuY29kaW5nIHRoZSByZXF1ZXN0IGludG8gYW4gSFRNTC1mb3JtLlxuICAgIGlmIChvcHRpb25zLmVtdWxhdGVKU09OKSB7XG4gICAgICBwYXJhbXMuY29udGVudFR5cGUgPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcbiAgICAgIHBhcmFtcy5kYXRhID0gcGFyYW1zLmRhdGEgPyB7bW9kZWw6IHBhcmFtcy5kYXRhfSA6IHt9O1xuICAgIH1cblxuICAgIC8vIEZvciBvbGRlciBzZXJ2ZXJzLCBlbXVsYXRlIEhUVFAgYnkgbWltaWNraW5nIHRoZSBIVFRQIG1ldGhvZCB3aXRoIGBfbWV0aG9kYFxuICAgIC8vIEFuZCBhbiBgWC1IVFRQLU1ldGhvZC1PdmVycmlkZWAgaGVhZGVyLlxuICAgIGlmIChvcHRpb25zLmVtdWxhdGVIVFRQICYmICh0eXBlID09PSAnUFVUJyB8fCB0eXBlID09PSAnREVMRVRFJyB8fCB0eXBlID09PSAnUEFUQ0gnKSkge1xuICAgICAgcGFyYW1zLnR5cGUgPSAnUE9TVCc7XG4gICAgICBpZiAob3B0aW9ucy5lbXVsYXRlSlNPTikgcGFyYW1zLmRhdGEuX21ldGhvZCA9IHR5cGU7XG4gICAgICB2YXIgYmVmb3JlU2VuZCA9IG9wdGlvbnMuYmVmb3JlU2VuZDtcbiAgICAgIG9wdGlvbnMuYmVmb3JlU2VuZCA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignWC1IVFRQLU1ldGhvZC1PdmVycmlkZScsIHR5cGUpO1xuICAgICAgICBpZiAoYmVmb3JlU2VuZCkgcmV0dXJuIGJlZm9yZVNlbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRG9uJ3QgcHJvY2VzcyBkYXRhIG9uIGEgbm9uLUdFVCByZXF1ZXN0LlxuICAgIGlmIChwYXJhbXMudHlwZSAhPT0gJ0dFVCcgJiYgIW9wdGlvbnMuZW11bGF0ZUpTT04pIHtcbiAgICAgIHBhcmFtcy5wcm9jZXNzRGF0YSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIElmIHdlJ3JlIHNlbmRpbmcgYSBgUEFUQ0hgIHJlcXVlc3QsIGFuZCB3ZSdyZSBpbiBhbiBvbGQgSW50ZXJuZXQgRXhwbG9yZXJcbiAgICAvLyB0aGF0IHN0aWxsIGhhcyBBY3RpdmVYIGVuYWJsZWQgYnkgZGVmYXVsdCwgb3ZlcnJpZGUgalF1ZXJ5IHRvIHVzZSB0aGF0XG4gICAgLy8gZm9yIFhIUiBpbnN0ZWFkLiBSZW1vdmUgdGhpcyBsaW5lIHdoZW4galF1ZXJ5IHN1cHBvcnRzIGBQQVRDSGAgb24gSUU4LlxuICAgIGlmIChwYXJhbXMudHlwZSA9PT0gJ1BBVENIJyAmJiBub1hoclBhdGNoKSB7XG4gICAgICBwYXJhbXMueGhyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxIVFRQXCIpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHRoZSByZXF1ZXN0LCBhbGxvd2luZyB0aGUgdXNlciB0byBvdmVycmlkZSBhbnkgQWpheCBvcHRpb25zLlxuICAgIHZhciB4aHIgPSBvcHRpb25zLnhociA9IEJhY2tib25lLmFqYXgoXy5leHRlbmQocGFyYW1zLCBvcHRpb25zKSk7XG4gICAgbW9kZWwudHJpZ2dlcigncmVxdWVzdCcsIG1vZGVsLCB4aHIsIG9wdGlvbnMpO1xuICAgIHJldHVybiB4aHI7XG4gIH07XG5cbiAgdmFyIG5vWGhyUGF0Y2ggPVxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICEhd2luZG93LkFjdGl2ZVhPYmplY3QgJiZcbiAgICAgICEod2luZG93LlhNTEh0dHBSZXF1ZXN0ICYmIChuZXcgWE1MSHR0cFJlcXVlc3QpLmRpc3BhdGNoRXZlbnQpO1xuXG4gIC8vIE1hcCBmcm9tIENSVUQgdG8gSFRUUCBmb3Igb3VyIGRlZmF1bHQgYEJhY2tib25lLnN5bmNgIGltcGxlbWVudGF0aW9uLlxuICB2YXIgbWV0aG9kTWFwID0ge1xuICAgICdjcmVhdGUnOiAnUE9TVCcsXG4gICAgJ3VwZGF0ZSc6ICdQVVQnLFxuICAgICdwYXRjaCc6ICAnUEFUQ0gnLFxuICAgICdkZWxldGUnOiAnREVMRVRFJyxcbiAgICAncmVhZCc6ICAgJ0dFVCdcbiAgfTtcblxuICAvLyBTZXQgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgYEJhY2tib25lLmFqYXhgIHRvIHByb3h5IHRocm91Z2ggdG8gYCRgLlxuICAvLyBPdmVycmlkZSB0aGlzIGlmIHlvdSdkIGxpa2UgdG8gdXNlIGEgZGlmZmVyZW50IGxpYnJhcnkuXG4gIEJhY2tib25lLmFqYXggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gQmFja2JvbmUuJC5hamF4LmFwcGx5KEJhY2tib25lLiQsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gQmFja2JvbmUuUm91dGVyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFJvdXRlcnMgbWFwIGZhdXgtVVJMcyB0byBhY3Rpb25zLCBhbmQgZmlyZSBldmVudHMgd2hlbiByb3V0ZXMgYXJlXG4gIC8vIG1hdGNoZWQuIENyZWF0aW5nIGEgbmV3IG9uZSBzZXRzIGl0cyBgcm91dGVzYCBoYXNoLCBpZiBub3Qgc2V0IHN0YXRpY2FsbHkuXG4gIHZhciBSb3V0ZXIgPSBCYWNrYm9uZS5Sb3V0ZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICBpZiAob3B0aW9ucy5yb3V0ZXMpIHRoaXMucm91dGVzID0gb3B0aW9ucy5yb3V0ZXM7XG4gICAgdGhpcy5fYmluZFJvdXRlcygpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIENhY2hlZCByZWd1bGFyIGV4cHJlc3Npb25zIGZvciBtYXRjaGluZyBuYW1lZCBwYXJhbSBwYXJ0cyBhbmQgc3BsYXR0ZWRcbiAgLy8gcGFydHMgb2Ygcm91dGUgc3RyaW5ncy5cbiAgdmFyIG9wdGlvbmFsUGFyYW0gPSAvXFwoKC4qPylcXCkvZztcbiAgdmFyIG5hbWVkUGFyYW0gICAgPSAvKFxcKFxcPyk/OlxcdysvZztcbiAgdmFyIHNwbGF0UGFyYW0gICAgPSAvXFwqXFx3Ky9nO1xuICB2YXIgZXNjYXBlUmVnRXhwICA9IC9bXFwte31cXFtcXF0rPy4sXFxcXFxcXiR8I1xcc10vZztcblxuICAvLyBTZXQgdXAgYWxsIGluaGVyaXRhYmxlICoqQmFja2JvbmUuUm91dGVyKiogcHJvcGVydGllcyBhbmQgbWV0aG9kcy5cbiAgXy5leHRlbmQoUm91dGVyLnByb3RvdHlwZSwgRXZlbnRzLCB7XG5cbiAgICAvLyBJbml0aWFsaXplIGlzIGFuIGVtcHR5IGZ1bmN0aW9uIGJ5IGRlZmF1bHQuIE92ZXJyaWRlIGl0IHdpdGggeW91ciBvd25cbiAgICAvLyBpbml0aWFsaXphdGlvbiBsb2dpYy5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpe30sXG5cbiAgICAvLyBNYW51YWxseSBiaW5kIGEgc2luZ2xlIG5hbWVkIHJvdXRlIHRvIGEgY2FsbGJhY2suIEZvciBleGFtcGxlOlxuICAgIC8vXG4gICAgLy8gICAgIHRoaXMucm91dGUoJ3NlYXJjaC86cXVlcnkvcDpudW0nLCAnc2VhcmNoJywgZnVuY3Rpb24ocXVlcnksIG51bSkge1xuICAgIC8vICAgICAgIC4uLlxuICAgIC8vICAgICB9KTtcbiAgICAvL1xuICAgIHJvdXRlOiBmdW5jdGlvbihyb3V0ZSwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIGlmICghXy5pc1JlZ0V4cChyb3V0ZSkpIHJvdXRlID0gdGhpcy5fcm91dGVUb1JlZ0V4cChyb3V0ZSk7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG5hbWUpKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmFtZTtcbiAgICAgICAgbmFtZSA9ICcnO1xuICAgICAgfVxuICAgICAgaWYgKCFjYWxsYmFjaykgY2FsbGJhY2sgPSB0aGlzW25hbWVdO1xuICAgICAgdmFyIHJvdXRlciA9IHRoaXM7XG4gICAgICBCYWNrYm9uZS5oaXN0b3J5LnJvdXRlKHJvdXRlLCBmdW5jdGlvbihmcmFnbWVudCkge1xuICAgICAgICB2YXIgYXJncyA9IHJvdXRlci5fZXh0cmFjdFBhcmFtZXRlcnMocm91dGUsIGZyYWdtZW50KTtcbiAgICAgICAgcm91dGVyLmV4ZWN1dGUoY2FsbGJhY2ssIGFyZ3MpO1xuICAgICAgICByb3V0ZXIudHJpZ2dlci5hcHBseShyb3V0ZXIsIFsncm91dGU6JyArIG5hbWVdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIHJvdXRlci50cmlnZ2VyKCdyb3V0ZScsIG5hbWUsIGFyZ3MpO1xuICAgICAgICBCYWNrYm9uZS5oaXN0b3J5LnRyaWdnZXIoJ3JvdXRlJywgcm91dGVyLCBuYW1lLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEV4ZWN1dGUgYSByb3V0ZSBoYW5kbGVyIHdpdGggdGhlIHByb3ZpZGVkIHBhcmFtZXRlcnMuICBUaGlzIGlzIGFuXG4gICAgLy8gZXhjZWxsZW50IHBsYWNlIHRvIGRvIHByZS1yb3V0ZSBzZXR1cCBvciBwb3N0LXJvdXRlIGNsZWFudXAuXG4gICAgZXhlY3V0ZTogZnVuY3Rpb24oY2FsbGJhY2ssIGFyZ3MpIHtcbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2suYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSxcblxuICAgIC8vIFNpbXBsZSBwcm94eSB0byBgQmFja2JvbmUuaGlzdG9yeWAgdG8gc2F2ZSBhIGZyYWdtZW50IGludG8gdGhlIGhpc3RvcnkuXG4gICAgbmF2aWdhdGU6IGZ1bmN0aW9uKGZyYWdtZW50LCBvcHRpb25zKSB7XG4gICAgICBCYWNrYm9uZS5oaXN0b3J5Lm5hdmlnYXRlKGZyYWdtZW50LCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBCaW5kIGFsbCBkZWZpbmVkIHJvdXRlcyB0byBgQmFja2JvbmUuaGlzdG9yeWAuIFdlIGhhdmUgdG8gcmV2ZXJzZSB0aGVcbiAgICAvLyBvcmRlciBvZiB0aGUgcm91dGVzIGhlcmUgdG8gc3VwcG9ydCBiZWhhdmlvciB3aGVyZSB0aGUgbW9zdCBnZW5lcmFsXG4gICAgLy8gcm91dGVzIGNhbiBiZSBkZWZpbmVkIGF0IHRoZSBib3R0b20gb2YgdGhlIHJvdXRlIG1hcC5cbiAgICBfYmluZFJvdXRlczogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMucm91dGVzKSByZXR1cm47XG4gICAgICB0aGlzLnJvdXRlcyA9IF8ucmVzdWx0KHRoaXMsICdyb3V0ZXMnKTtcbiAgICAgIHZhciByb3V0ZSwgcm91dGVzID0gXy5rZXlzKHRoaXMucm91dGVzKTtcbiAgICAgIHdoaWxlICgocm91dGUgPSByb3V0ZXMucG9wKCkpICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5yb3V0ZShyb3V0ZSwgdGhpcy5yb3V0ZXNbcm91dGVdKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBhIHJvdXRlIHN0cmluZyBpbnRvIGEgcmVndWxhciBleHByZXNzaW9uLCBzdWl0YWJsZSBmb3IgbWF0Y2hpbmdcbiAgICAvLyBhZ2FpbnN0IHRoZSBjdXJyZW50IGxvY2F0aW9uIGhhc2guXG4gICAgX3JvdXRlVG9SZWdFeHA6IGZ1bmN0aW9uKHJvdXRlKSB7XG4gICAgICByb3V0ZSA9IHJvdXRlLnJlcGxhY2UoZXNjYXBlUmVnRXhwLCAnXFxcXCQmJylcbiAgICAgICAgICAgICAgICAgICAucmVwbGFjZShvcHRpb25hbFBhcmFtLCAnKD86JDEpPycpXG4gICAgICAgICAgICAgICAgICAgLnJlcGxhY2UobmFtZWRQYXJhbSwgZnVuY3Rpb24obWF0Y2gsIG9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9uYWwgPyBtYXRjaCA6ICcoW14vP10rKSc7XG4gICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAucmVwbGFjZShzcGxhdFBhcmFtLCAnKFteP10qPyknKTtcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKCdeJyArIHJvdXRlICsgJyg/OlxcXFw/KFtcXFxcc1xcXFxTXSopKT8kJyk7XG4gICAgfSxcblxuICAgIC8vIEdpdmVuIGEgcm91dGUsIGFuZCBhIFVSTCBmcmFnbWVudCB0aGF0IGl0IG1hdGNoZXMsIHJldHVybiB0aGUgYXJyYXkgb2ZcbiAgICAvLyBleHRyYWN0ZWQgZGVjb2RlZCBwYXJhbWV0ZXJzLiBFbXB0eSBvciB1bm1hdGNoZWQgcGFyYW1ldGVycyB3aWxsIGJlXG4gICAgLy8gdHJlYXRlZCBhcyBgbnVsbGAgdG8gbm9ybWFsaXplIGNyb3NzLWJyb3dzZXIgYmVoYXZpb3IuXG4gICAgX2V4dHJhY3RQYXJhbWV0ZXJzOiBmdW5jdGlvbihyb3V0ZSwgZnJhZ21lbnQpIHtcbiAgICAgIHZhciBwYXJhbXMgPSByb3V0ZS5leGVjKGZyYWdtZW50KS5zbGljZSgxKTtcbiAgICAgIHJldHVybiBfLm1hcChwYXJhbXMsIGZ1bmN0aW9uKHBhcmFtLCBpKSB7XG4gICAgICAgIC8vIERvbid0IGRlY29kZSB0aGUgc2VhcmNoIHBhcmFtcy5cbiAgICAgICAgaWYgKGkgPT09IHBhcmFtcy5sZW5ndGggLSAxKSByZXR1cm4gcGFyYW0gfHwgbnVsbDtcbiAgICAgICAgcmV0dXJuIHBhcmFtID8gZGVjb2RlVVJJQ29tcG9uZW50KHBhcmFtKSA6IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgLy8gQmFja2JvbmUuSGlzdG9yeVxuICAvLyAtLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gSGFuZGxlcyBjcm9zcy1icm93c2VyIGhpc3RvcnkgbWFuYWdlbWVudCwgYmFzZWQgb24gZWl0aGVyXG4gIC8vIFtwdXNoU3RhdGVdKGh0dHA6Ly9kaXZlaW50b2h0bWw1LmluZm8vaGlzdG9yeS5odG1sKSBhbmQgcmVhbCBVUkxzLCBvclxuICAvLyBbb25oYXNoY2hhbmdlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0RPTS93aW5kb3cub25oYXNoY2hhbmdlKVxuICAvLyBhbmQgVVJMIGZyYWdtZW50cy4gSWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgbmVpdGhlciAob2xkIElFLCBuYXRjaCksXG4gIC8vIGZhbGxzIGJhY2sgdG8gcG9sbGluZy5cbiAgdmFyIEhpc3RvcnkgPSBCYWNrYm9uZS5IaXN0b3J5ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuICAgIF8uYmluZEFsbCh0aGlzLCAnY2hlY2tVcmwnKTtcblxuICAgIC8vIEVuc3VyZSB0aGF0IGBIaXN0b3J5YCBjYW4gYmUgdXNlZCBvdXRzaWRlIG9mIHRoZSBicm93c2VyLlxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5sb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICAgIHRoaXMuaGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuICAgIH1cbiAgfTtcblxuICAvLyBDYWNoZWQgcmVnZXggZm9yIHN0cmlwcGluZyBhIGxlYWRpbmcgaGFzaC9zbGFzaCBhbmQgdHJhaWxpbmcgc3BhY2UuXG4gIHZhciByb3V0ZVN0cmlwcGVyID0gL15bI1xcL118XFxzKyQvZztcblxuICAvLyBDYWNoZWQgcmVnZXggZm9yIHN0cmlwcGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzLlxuICB2YXIgcm9vdFN0cmlwcGVyID0gL15cXC8rfFxcLyskL2c7XG5cbiAgLy8gQ2FjaGVkIHJlZ2V4IGZvciBkZXRlY3RpbmcgTVNJRS5cbiAgdmFyIGlzRXhwbG9yZXIgPSAvbXNpZSBbXFx3Ll0rLztcblxuICAvLyBDYWNoZWQgcmVnZXggZm9yIHJlbW92aW5nIGEgdHJhaWxpbmcgc2xhc2guXG4gIHZhciB0cmFpbGluZ1NsYXNoID0gL1xcLyQvO1xuXG4gIC8vIENhY2hlZCByZWdleCBmb3Igc3RyaXBwaW5nIHVybHMgb2YgaGFzaC5cbiAgdmFyIHBhdGhTdHJpcHBlciA9IC8jLiokLztcblxuICAvLyBIYXMgdGhlIGhpc3RvcnkgaGFuZGxpbmcgYWxyZWFkeSBiZWVuIHN0YXJ0ZWQ/XG4gIEhpc3Rvcnkuc3RhcnRlZCA9IGZhbHNlO1xuXG4gIC8vIFNldCB1cCBhbGwgaW5oZXJpdGFibGUgKipCYWNrYm9uZS5IaXN0b3J5KiogcHJvcGVydGllcyBhbmQgbWV0aG9kcy5cbiAgXy5leHRlbmQoSGlzdG9yeS5wcm90b3R5cGUsIEV2ZW50cywge1xuXG4gICAgLy8gVGhlIGRlZmF1bHQgaW50ZXJ2YWwgdG8gcG9sbCBmb3IgaGFzaCBjaGFuZ2VzLCBpZiBuZWNlc3NhcnksIGlzXG4gICAgLy8gdHdlbnR5IHRpbWVzIGEgc2Vjb25kLlxuICAgIGludGVydmFsOiA1MCxcblxuICAgIC8vIEFyZSB3ZSBhdCB0aGUgYXBwIHJvb3Q/XG4gICAgYXRSb290OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1teXFwvXSQvLCAnJCYvJykgPT09IHRoaXMucm9vdDtcbiAgICB9LFxuXG4gICAgLy8gR2V0cyB0aGUgdHJ1ZSBoYXNoIHZhbHVlLiBDYW5ub3QgdXNlIGxvY2F0aW9uLmhhc2ggZGlyZWN0bHkgZHVlIHRvIGJ1Z1xuICAgIC8vIGluIEZpcmVmb3ggd2hlcmUgbG9jYXRpb24uaGFzaCB3aWxsIGFsd2F5cyBiZSBkZWNvZGVkLlxuICAgIGdldEhhc2g6IGZ1bmN0aW9uKHdpbmRvdykge1xuICAgICAgdmFyIG1hdGNoID0gKHdpbmRvdyB8fCB0aGlzKS5sb2NhdGlvbi5ocmVmLm1hdGNoKC8jKC4qKSQvKTtcbiAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJyc7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgY3Jvc3MtYnJvd3NlciBub3JtYWxpemVkIFVSTCBmcmFnbWVudCwgZWl0aGVyIGZyb20gdGhlIFVSTCxcbiAgICAvLyB0aGUgaGFzaCwgb3IgdGhlIG92ZXJyaWRlLlxuICAgIGdldEZyYWdtZW50OiBmdW5jdGlvbihmcmFnbWVudCwgZm9yY2VQdXNoU3RhdGUpIHtcbiAgICAgIGlmIChmcmFnbWVudCA9PSBudWxsKSB7XG4gICAgICAgIGlmICh0aGlzLl9oYXNQdXNoU3RhdGUgfHwgIXRoaXMuX3dhbnRzSGFzaENoYW5nZSB8fCBmb3JjZVB1c2hTdGF0ZSkge1xuICAgICAgICAgIGZyYWdtZW50ID0gZGVjb2RlVVJJKHRoaXMubG9jYXRpb24ucGF0aG5hbWUgKyB0aGlzLmxvY2F0aW9uLnNlYXJjaCk7XG4gICAgICAgICAgdmFyIHJvb3QgPSB0aGlzLnJvb3QucmVwbGFjZSh0cmFpbGluZ1NsYXNoLCAnJyk7XG4gICAgICAgICAgaWYgKCFmcmFnbWVudC5pbmRleE9mKHJvb3QpKSBmcmFnbWVudCA9IGZyYWdtZW50LnNsaWNlKHJvb3QubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZ2V0SGFzaCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZnJhZ21lbnQucmVwbGFjZShyb3V0ZVN0cmlwcGVyLCAnJyk7XG4gICAgfSxcblxuICAgIC8vIFN0YXJ0IHRoZSBoYXNoIGNoYW5nZSBoYW5kbGluZywgcmV0dXJuaW5nIGB0cnVlYCBpZiB0aGUgY3VycmVudCBVUkwgbWF0Y2hlc1xuICAgIC8vIGFuIGV4aXN0aW5nIHJvdXRlLCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmIChIaXN0b3J5LnN0YXJ0ZWQpIHRocm93IG5ldyBFcnJvcihcIkJhY2tib25lLmhpc3RvcnkgaGFzIGFscmVhZHkgYmVlbiBzdGFydGVkXCIpO1xuICAgICAgSGlzdG9yeS5zdGFydGVkID0gdHJ1ZTtcblxuICAgICAgLy8gRmlndXJlIG91dCB0aGUgaW5pdGlhbCBjb25maWd1cmF0aW9uLiBEbyB3ZSBuZWVkIGFuIGlmcmFtZT9cbiAgICAgIC8vIElzIHB1c2hTdGF0ZSBkZXNpcmVkIC4uLiBpcyBpdCBhdmFpbGFibGU/XG4gICAgICB0aGlzLm9wdGlvbnMgICAgICAgICAgPSBfLmV4dGVuZCh7cm9vdDogJy8nfSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMucm9vdCAgICAgICAgICAgICA9IHRoaXMub3B0aW9ucy5yb290O1xuICAgICAgdGhpcy5fd2FudHNIYXNoQ2hhbmdlID0gdGhpcy5vcHRpb25zLmhhc2hDaGFuZ2UgIT09IGZhbHNlO1xuICAgICAgdGhpcy5fd2FudHNQdXNoU3RhdGUgID0gISF0aGlzLm9wdGlvbnMucHVzaFN0YXRlO1xuICAgICAgdGhpcy5faGFzUHVzaFN0YXRlICAgID0gISEodGhpcy5vcHRpb25zLnB1c2hTdGF0ZSAmJiB0aGlzLmhpc3RvcnkgJiYgdGhpcy5oaXN0b3J5LnB1c2hTdGF0ZSk7XG4gICAgICB2YXIgZnJhZ21lbnQgICAgICAgICAgPSB0aGlzLmdldEZyYWdtZW50KCk7XG4gICAgICB2YXIgZG9jTW9kZSAgICAgICAgICAgPSBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG4gICAgICB2YXIgb2xkSUUgICAgICAgICAgICAgPSAoaXNFeHBsb3Jlci5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSkgJiYgKCFkb2NNb2RlIHx8IGRvY01vZGUgPD0gNykpO1xuXG4gICAgICAvLyBOb3JtYWxpemUgcm9vdCB0byBhbHdheXMgaW5jbHVkZSBhIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoLlxuICAgICAgdGhpcy5yb290ID0gKCcvJyArIHRoaXMucm9vdCArICcvJykucmVwbGFjZShyb290U3RyaXBwZXIsICcvJyk7XG5cbiAgICAgIGlmIChvbGRJRSAmJiB0aGlzLl93YW50c0hhc2hDaGFuZ2UpIHtcbiAgICAgICAgdmFyIGZyYW1lID0gQmFja2JvbmUuJCgnPGlmcmFtZSBzcmM9XCJqYXZhc2NyaXB0OjBcIiB0YWJpbmRleD1cIi0xXCI+Jyk7XG4gICAgICAgIHRoaXMuaWZyYW1lID0gZnJhbWUuaGlkZSgpLmFwcGVuZFRvKCdib2R5JylbMF0uY29udGVudFdpbmRvdztcbiAgICAgICAgdGhpcy5uYXZpZ2F0ZShmcmFnbWVudCk7XG4gICAgICB9XG5cbiAgICAgIC8vIERlcGVuZGluZyBvbiB3aGV0aGVyIHdlJ3JlIHVzaW5nIHB1c2hTdGF0ZSBvciBoYXNoZXMsIGFuZCB3aGV0aGVyXG4gICAgICAvLyAnb25oYXNoY2hhbmdlJyBpcyBzdXBwb3J0ZWQsIGRldGVybWluZSBob3cgd2UgY2hlY2sgdGhlIFVSTCBzdGF0ZS5cbiAgICAgIGlmICh0aGlzLl9oYXNQdXNoU3RhdGUpIHtcbiAgICAgICAgQmFja2JvbmUuJCh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHRoaXMuY2hlY2tVcmwpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl93YW50c0hhc2hDaGFuZ2UgJiYgKCdvbmhhc2hjaGFuZ2UnIGluIHdpbmRvdykgJiYgIW9sZElFKSB7XG4gICAgICAgIEJhY2tib25lLiQod2luZG93KS5vbignaGFzaGNoYW5nZScsIHRoaXMuY2hlY2tVcmwpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl93YW50c0hhc2hDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tVcmxJbnRlcnZhbCA9IHNldEludGVydmFsKHRoaXMuY2hlY2tVcmwsIHRoaXMuaW50ZXJ2YWwpO1xuICAgICAgfVxuXG4gICAgICAvLyBEZXRlcm1pbmUgaWYgd2UgbmVlZCB0byBjaGFuZ2UgdGhlIGJhc2UgdXJsLCBmb3IgYSBwdXNoU3RhdGUgbGlua1xuICAgICAgLy8gb3BlbmVkIGJ5IGEgbm9uLXB1c2hTdGF0ZSBicm93c2VyLlxuICAgICAgdGhpcy5mcmFnbWVudCA9IGZyYWdtZW50O1xuICAgICAgdmFyIGxvYyA9IHRoaXMubG9jYXRpb247XG5cbiAgICAgIC8vIFRyYW5zaXRpb24gZnJvbSBoYXNoQ2hhbmdlIHRvIHB1c2hTdGF0ZSBvciB2aWNlIHZlcnNhIGlmIGJvdGggYXJlXG4gICAgICAvLyByZXF1ZXN0ZWQuXG4gICAgICBpZiAodGhpcy5fd2FudHNIYXNoQ2hhbmdlICYmIHRoaXMuX3dhbnRzUHVzaFN0YXRlKSB7XG5cbiAgICAgICAgLy8gSWYgd2UndmUgc3RhcnRlZCBvZmYgd2l0aCBhIHJvdXRlIGZyb20gYSBgcHVzaFN0YXRlYC1lbmFibGVkXG4gICAgICAgIC8vIGJyb3dzZXIsIGJ1dCB3ZSdyZSBjdXJyZW50bHkgaW4gYSBicm93c2VyIHRoYXQgZG9lc24ndCBzdXBwb3J0IGl0Li4uXG4gICAgICAgIGlmICghdGhpcy5faGFzUHVzaFN0YXRlICYmICF0aGlzLmF0Um9vdCgpKSB7XG4gICAgICAgICAgdGhpcy5mcmFnbWVudCA9IHRoaXMuZ2V0RnJhZ21lbnQobnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgdGhpcy5sb2NhdGlvbi5yZXBsYWNlKHRoaXMucm9vdCArICcjJyArIHRoaXMuZnJhZ21lbnQpO1xuICAgICAgICAgIC8vIFJldHVybiBpbW1lZGlhdGVseSBhcyBicm93c2VyIHdpbGwgZG8gcmVkaXJlY3QgdG8gbmV3IHVybFxuICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIC8vIE9yIGlmIHdlJ3ZlIHN0YXJ0ZWQgb3V0IHdpdGggYSBoYXNoLWJhc2VkIHJvdXRlLCBidXQgd2UncmUgY3VycmVudGx5XG4gICAgICAgIC8vIGluIGEgYnJvd3NlciB3aGVyZSBpdCBjb3VsZCBiZSBgcHVzaFN0YXRlYC1iYXNlZCBpbnN0ZWFkLi4uXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5faGFzUHVzaFN0YXRlICYmIHRoaXMuYXRSb290KCkgJiYgbG9jLmhhc2gpIHtcbiAgICAgICAgICB0aGlzLmZyYWdtZW50ID0gdGhpcy5nZXRIYXNoKCkucmVwbGFjZShyb3V0ZVN0cmlwcGVyLCAnJyk7XG4gICAgICAgICAgdGhpcy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh7fSwgZG9jdW1lbnQudGl0bGUsIHRoaXMucm9vdCArIHRoaXMuZnJhZ21lbnQpO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2lsZW50KSByZXR1cm4gdGhpcy5sb2FkVXJsKCk7XG4gICAgfSxcblxuICAgIC8vIERpc2FibGUgQmFja2JvbmUuaGlzdG9yeSwgcGVyaGFwcyB0ZW1wb3JhcmlseS4gTm90IHVzZWZ1bCBpbiBhIHJlYWwgYXBwLFxuICAgIC8vIGJ1dCBwb3NzaWJseSB1c2VmdWwgZm9yIHVuaXQgdGVzdGluZyBSb3V0ZXJzLlxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgQmFja2JvbmUuJCh3aW5kb3cpLm9mZigncG9wc3RhdGUnLCB0aGlzLmNoZWNrVXJsKS5vZmYoJ2hhc2hjaGFuZ2UnLCB0aGlzLmNoZWNrVXJsKTtcbiAgICAgIGlmICh0aGlzLl9jaGVja1VybEludGVydmFsKSBjbGVhckludGVydmFsKHRoaXMuX2NoZWNrVXJsSW50ZXJ2YWwpO1xuICAgICAgSGlzdG9yeS5zdGFydGVkID0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8vIEFkZCBhIHJvdXRlIHRvIGJlIHRlc3RlZCB3aGVuIHRoZSBmcmFnbWVudCBjaGFuZ2VzLiBSb3V0ZXMgYWRkZWQgbGF0ZXJcbiAgICAvLyBtYXkgb3ZlcnJpZGUgcHJldmlvdXMgcm91dGVzLlxuICAgIHJvdXRlOiBmdW5jdGlvbihyb3V0ZSwgY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuaGFuZGxlcnMudW5zaGlmdCh7cm91dGU6IHJvdXRlLCBjYWxsYmFjazogY2FsbGJhY2t9KTtcbiAgICB9LFxuXG4gICAgLy8gQ2hlY2tzIHRoZSBjdXJyZW50IFVSTCB0byBzZWUgaWYgaXQgaGFzIGNoYW5nZWQsIGFuZCBpZiBpdCBoYXMsXG4gICAgLy8gY2FsbHMgYGxvYWRVcmxgLCBub3JtYWxpemluZyBhY3Jvc3MgdGhlIGhpZGRlbiBpZnJhbWUuXG4gICAgY2hlY2tVcmw6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5nZXRGcmFnbWVudCgpO1xuICAgICAgaWYgKGN1cnJlbnQgPT09IHRoaXMuZnJhZ21lbnQgJiYgdGhpcy5pZnJhbWUpIHtcbiAgICAgICAgY3VycmVudCA9IHRoaXMuZ2V0RnJhZ21lbnQodGhpcy5nZXRIYXNoKHRoaXMuaWZyYW1lKSk7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudCA9PT0gdGhpcy5mcmFnbWVudCkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKHRoaXMuaWZyYW1lKSB0aGlzLm5hdmlnYXRlKGN1cnJlbnQpO1xuICAgICAgdGhpcy5sb2FkVXJsKCk7XG4gICAgfSxcblxuICAgIC8vIEF0dGVtcHQgdG8gbG9hZCB0aGUgY3VycmVudCBVUkwgZnJhZ21lbnQuIElmIGEgcm91dGUgc3VjY2VlZHMgd2l0aCBhXG4gICAgLy8gbWF0Y2gsIHJldHVybnMgYHRydWVgLiBJZiBubyBkZWZpbmVkIHJvdXRlcyBtYXRjaGVzIHRoZSBmcmFnbWVudCxcbiAgICAvLyByZXR1cm5zIGBmYWxzZWAuXG4gICAgbG9hZFVybDogZnVuY3Rpb24oZnJhZ21lbnQpIHtcbiAgICAgIGZyYWdtZW50ID0gdGhpcy5mcmFnbWVudCA9IHRoaXMuZ2V0RnJhZ21lbnQoZnJhZ21lbnQpO1xuICAgICAgcmV0dXJuIF8uYW55KHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGhhbmRsZXIucm91dGUudGVzdChmcmFnbWVudCkpIHtcbiAgICAgICAgICBoYW5kbGVyLmNhbGxiYWNrKGZyYWdtZW50KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIFNhdmUgYSBmcmFnbWVudCBpbnRvIHRoZSBoYXNoIGhpc3RvcnksIG9yIHJlcGxhY2UgdGhlIFVSTCBzdGF0ZSBpZiB0aGVcbiAgICAvLyAncmVwbGFjZScgb3B0aW9uIGlzIHBhc3NlZC4gWW91IGFyZSByZXNwb25zaWJsZSBmb3IgcHJvcGVybHkgVVJMLWVuY29kaW5nXG4gICAgLy8gdGhlIGZyYWdtZW50IGluIGFkdmFuY2UuXG4gICAgLy9cbiAgICAvLyBUaGUgb3B0aW9ucyBvYmplY3QgY2FuIGNvbnRhaW4gYHRyaWdnZXI6IHRydWVgIGlmIHlvdSB3aXNoIHRvIGhhdmUgdGhlXG4gICAgLy8gcm91dGUgY2FsbGJhY2sgYmUgZmlyZWQgKG5vdCB1c3VhbGx5IGRlc2lyYWJsZSksIG9yIGByZXBsYWNlOiB0cnVlYCwgaWZcbiAgICAvLyB5b3Ugd2lzaCB0byBtb2RpZnkgdGhlIGN1cnJlbnQgVVJMIHdpdGhvdXQgYWRkaW5nIGFuIGVudHJ5IHRvIHRoZSBoaXN0b3J5LlxuICAgIG5hdmlnYXRlOiBmdW5jdGlvbihmcmFnbWVudCwgb3B0aW9ucykge1xuICAgICAgaWYgKCFIaXN0b3J5LnN0YXJ0ZWQpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICghb3B0aW9ucyB8fCBvcHRpb25zID09PSB0cnVlKSBvcHRpb25zID0ge3RyaWdnZXI6ICEhb3B0aW9uc307XG5cbiAgICAgIHZhciB1cmwgPSB0aGlzLnJvb3QgKyAoZnJhZ21lbnQgPSB0aGlzLmdldEZyYWdtZW50KGZyYWdtZW50IHx8ICcnKSk7XG5cbiAgICAgIC8vIFN0cmlwIHRoZSBoYXNoIGZvciBtYXRjaGluZy5cbiAgICAgIGZyYWdtZW50ID0gZnJhZ21lbnQucmVwbGFjZShwYXRoU3RyaXBwZXIsICcnKTtcblxuICAgICAgaWYgKHRoaXMuZnJhZ21lbnQgPT09IGZyYWdtZW50KSByZXR1cm47XG4gICAgICB0aGlzLmZyYWdtZW50ID0gZnJhZ21lbnQ7XG5cbiAgICAgIC8vIERvbid0IGluY2x1ZGUgYSB0cmFpbGluZyBzbGFzaCBvbiB0aGUgcm9vdC5cbiAgICAgIGlmIChmcmFnbWVudCA9PT0gJycgJiYgdXJsICE9PSAnLycpIHVybCA9IHVybC5zbGljZSgwLCAtMSk7XG5cbiAgICAgIC8vIElmIHB1c2hTdGF0ZSBpcyBhdmFpbGFibGUsIHdlIHVzZSBpdCB0byBzZXQgdGhlIGZyYWdtZW50IGFzIGEgcmVhbCBVUkwuXG4gICAgICBpZiAodGhpcy5faGFzUHVzaFN0YXRlKSB7XG4gICAgICAgIHRoaXMuaGlzdG9yeVtvcHRpb25zLnJlcGxhY2UgPyAncmVwbGFjZVN0YXRlJyA6ICdwdXNoU3RhdGUnXSh7fSwgZG9jdW1lbnQudGl0bGUsIHVybCk7XG5cbiAgICAgIC8vIElmIGhhc2ggY2hhbmdlcyBoYXZlbid0IGJlZW4gZXhwbGljaXRseSBkaXNhYmxlZCwgdXBkYXRlIHRoZSBoYXNoXG4gICAgICAvLyBmcmFnbWVudCB0byBzdG9yZSBoaXN0b3J5LlxuICAgICAgfSBlbHNlIGlmICh0aGlzLl93YW50c0hhc2hDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlSGFzaCh0aGlzLmxvY2F0aW9uLCBmcmFnbWVudCwgb3B0aW9ucy5yZXBsYWNlKTtcbiAgICAgICAgaWYgKHRoaXMuaWZyYW1lICYmIChmcmFnbWVudCAhPT0gdGhpcy5nZXRGcmFnbWVudCh0aGlzLmdldEhhc2godGhpcy5pZnJhbWUpKSkpIHtcbiAgICAgICAgICAvLyBPcGVuaW5nIGFuZCBjbG9zaW5nIHRoZSBpZnJhbWUgdHJpY2tzIElFNyBhbmQgZWFybGllciB0byBwdXNoIGFcbiAgICAgICAgICAvLyBoaXN0b3J5IGVudHJ5IG9uIGhhc2gtdGFnIGNoYW5nZS4gIFdoZW4gcmVwbGFjZSBpcyB0cnVlLCB3ZSBkb24ndFxuICAgICAgICAgIC8vIHdhbnQgdGhpcy5cbiAgICAgICAgICBpZighb3B0aW9ucy5yZXBsYWNlKSB0aGlzLmlmcmFtZS5kb2N1bWVudC5vcGVuKCkuY2xvc2UoKTtcbiAgICAgICAgICB0aGlzLl91cGRhdGVIYXNoKHRoaXMuaWZyYW1lLmxvY2F0aW9uLCBmcmFnbWVudCwgb3B0aW9ucy5yZXBsYWNlKTtcbiAgICAgICAgfVxuXG4gICAgICAvLyBJZiB5b3UndmUgdG9sZCB1cyB0aGF0IHlvdSBleHBsaWNpdGx5IGRvbid0IHdhbnQgZmFsbGJhY2sgaGFzaGNoYW5nZS1cbiAgICAgIC8vIGJhc2VkIGhpc3RvcnksIHRoZW4gYG5hdmlnYXRlYCBiZWNvbWVzIGEgcGFnZSByZWZyZXNoLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYXRpb24uYXNzaWduKHVybCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy50cmlnZ2VyKSByZXR1cm4gdGhpcy5sb2FkVXJsKGZyYWdtZW50KTtcbiAgICB9LFxuXG4gICAgLy8gVXBkYXRlIHRoZSBoYXNoIGxvY2F0aW9uLCBlaXRoZXIgcmVwbGFjaW5nIHRoZSBjdXJyZW50IGVudHJ5LCBvciBhZGRpbmdcbiAgICAvLyBhIG5ldyBvbmUgdG8gdGhlIGJyb3dzZXIgaGlzdG9yeS5cbiAgICBfdXBkYXRlSGFzaDogZnVuY3Rpb24obG9jYXRpb24sIGZyYWdtZW50LCByZXBsYWNlKSB7XG4gICAgICBpZiAocmVwbGFjZSkge1xuICAgICAgICB2YXIgaHJlZiA9IGxvY2F0aW9uLmhyZWYucmVwbGFjZSgvKGphdmFzY3JpcHQ6fCMpLiokLywgJycpO1xuICAgICAgICBsb2NhdGlvbi5yZXBsYWNlKGhyZWYgKyAnIycgKyBmcmFnbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTb21lIGJyb3dzZXJzIHJlcXVpcmUgdGhhdCBgaGFzaGAgY29udGFpbnMgYSBsZWFkaW5nICMuXG4gICAgICAgIGxvY2F0aW9uLmhhc2ggPSAnIycgKyBmcmFnbWVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgfSk7XG5cbiAgLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IEJhY2tib25lLmhpc3RvcnkuXG4gIEJhY2tib25lLmhpc3RvcnkgPSBuZXcgSGlzdG9yeTtcblxuICAvLyBIZWxwZXJzXG4gIC8vIC0tLS0tLS1cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29ycmVjdGx5IHNldCB1cCB0aGUgcHJvdG90eXBlIGNoYWluLCBmb3Igc3ViY2xhc3Nlcy5cbiAgLy8gU2ltaWxhciB0byBgZ29vZy5pbmhlcml0c2AsIGJ1dCB1c2VzIGEgaGFzaCBvZiBwcm90b3R5cGUgcHJvcGVydGllcyBhbmRcbiAgLy8gY2xhc3MgcHJvcGVydGllcyB0byBiZSBleHRlbmRlZC5cbiAgdmFyIGV4dGVuZCA9IGZ1bmN0aW9uKHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXM7XG4gICAgdmFyIGNoaWxkO1xuXG4gICAgLy8gVGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciB0aGUgbmV3IHN1YmNsYXNzIGlzIGVpdGhlciBkZWZpbmVkIGJ5IHlvdVxuICAgIC8vICh0aGUgXCJjb25zdHJ1Y3RvclwiIHByb3BlcnR5IGluIHlvdXIgYGV4dGVuZGAgZGVmaW5pdGlvbiksIG9yIGRlZmF1bHRlZFxuICAgIC8vIGJ5IHVzIHRvIHNpbXBseSBjYWxsIHRoZSBwYXJlbnQncyBjb25zdHJ1Y3Rvci5cbiAgICBpZiAocHJvdG9Qcm9wcyAmJiBfLmhhcyhwcm90b1Byb3BzLCAnY29uc3RydWN0b3InKSkge1xuICAgICAgY2hpbGQgPSBwcm90b1Byb3BzLmNvbnN0cnVjdG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZCA9IGZ1bmN0aW9uKCl7IHJldHVybiBwYXJlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICB9XG5cbiAgICAvLyBBZGQgc3RhdGljIHByb3BlcnRpZXMgdG8gdGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLCBpZiBzdXBwbGllZC5cbiAgICBfLmV4dGVuZChjaGlsZCwgcGFyZW50LCBzdGF0aWNQcm9wcyk7XG5cbiAgICAvLyBTZXQgdGhlIHByb3RvdHlwZSBjaGFpbiB0byBpbmhlcml0IGZyb20gYHBhcmVudGAsIHdpdGhvdXQgY2FsbGluZ1xuICAgIC8vIGBwYXJlbnRgJ3MgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAgdmFyIFN1cnJvZ2F0ZSA9IGZ1bmN0aW9uKCl7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfTtcbiAgICBTdXJyb2dhdGUucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcbiAgICBjaGlsZC5wcm90b3R5cGUgPSBuZXcgU3Vycm9nYXRlO1xuXG4gICAgLy8gQWRkIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChpbnN0YW5jZSBwcm9wZXJ0aWVzKSB0byB0aGUgc3ViY2xhc3MsXG4gICAgLy8gaWYgc3VwcGxpZWQuXG4gICAgaWYgKHByb3RvUHJvcHMpIF8uZXh0ZW5kKGNoaWxkLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG5cbiAgICAvLyBTZXQgYSBjb252ZW5pZW5jZSBwcm9wZXJ0eSBpbiBjYXNlIHRoZSBwYXJlbnQncyBwcm90b3R5cGUgaXMgbmVlZGVkXG4gICAgLy8gbGF0ZXIuXG4gICAgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTtcblxuICAgIHJldHVybiBjaGlsZDtcbiAgfTtcblxuICAvLyBTZXQgdXAgaW5oZXJpdGFuY2UgZm9yIHRoZSBtb2RlbCwgY29sbGVjdGlvbiwgcm91dGVyLCB2aWV3IGFuZCBoaXN0b3J5LlxuICBNb2RlbC5leHRlbmQgPSBDb2xsZWN0aW9uLmV4dGVuZCA9IFJvdXRlci5leHRlbmQgPSBWaWV3LmV4dGVuZCA9IEhpc3RvcnkuZXh0ZW5kID0gZXh0ZW5kO1xuXG4gIC8vIFRocm93IGFuIGVycm9yIHdoZW4gYSBVUkwgaXMgbmVlZGVkLCBhbmQgbm9uZSBpcyBzdXBwbGllZC5cbiAgdmFyIHVybEVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBIFwidXJsXCIgcHJvcGVydHkgb3IgZnVuY3Rpb24gbXVzdCBiZSBzcGVjaWZpZWQnKTtcbiAgfTtcblxuICAvLyBXcmFwIGFuIG9wdGlvbmFsIGVycm9yIGNhbGxiYWNrIHdpdGggYSBmYWxsYmFjayBlcnJvciBldmVudC5cbiAgdmFyIHdyYXBFcnJvciA9IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgdmFyIGVycm9yID0gb3B0aW9ucy5lcnJvcjtcbiAgICBvcHRpb25zLmVycm9yID0gZnVuY3Rpb24ocmVzcCkge1xuICAgICAgaWYgKGVycm9yKSBlcnJvcihtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICBtb2RlbC50cmlnZ2VyKCdlcnJvcicsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiBCYWNrYm9uZTtcblxufSkpO1xuIiwiLypcbiAqIGpRdWVyeSBGaWxlIFVwbG9hZCBQbHVnaW4gNS40MC4xXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmx1ZWltcC9qUXVlcnktRmlsZS1VcGxvYWRcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMCwgU2ViYXN0aWFuIFRzY2hhblxuICogaHR0cHM6Ly9ibHVlaW1wLm5ldFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKi9cblxuLyoganNoaW50IG5vbWVuOmZhbHNlICovXG4vKiBnbG9iYWwgZGVmaW5lLCB3aW5kb3csIGRvY3VtZW50LCBsb2NhdGlvbiwgQmxvYiwgRm9ybURhdGEgKi9cblxuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIEFNRCBtb2R1bGU6XG4gICAgICAgIGRlZmluZShbXG4gICAgICAgICAgICAnanF1ZXJ5JyxcbiAgICAgICAgICAgICdqcXVlcnkudWkud2lkZ2V0J1xuICAgICAgICBdLCBmYWN0b3J5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHM6XG4gICAgICAgIGZhY3Rvcnkod2luZG93LmpRdWVyeSk7XG4gICAgfVxufShmdW5jdGlvbiAoJCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8vIERldGVjdCBmaWxlIGlucHV0IHN1cHBvcnQsIGJhc2VkIG9uXG4gICAgLy8gaHR0cDovL3ZpbGphbWlzLmNvbS9ibG9nLzIwMTIvZmlsZS11cGxvYWQtc3VwcG9ydC1vbi1tb2JpbGUvXG4gICAgJC5zdXBwb3J0LmZpbGVJbnB1dCA9ICEobmV3IFJlZ0V4cChcbiAgICAgICAgLy8gSGFuZGxlIGRldmljZXMgd2hpY2ggZ2l2ZSBmYWxzZSBwb3NpdGl2ZXMgZm9yIHRoZSBmZWF0dXJlIGRldGVjdGlvbjpcbiAgICAgICAgJyhBbmRyb2lkICgxXFxcXC5bMDE1Nl18MlxcXFwuWzAxXSkpJyArXG4gICAgICAgICAgICAnfChXaW5kb3dzIFBob25lIChPUyA3fDhcXFxcLjApKXwoWEJMV1ApfChadW5lV1ApfChXUERlc2t0b3ApJyArXG4gICAgICAgICAgICAnfCh3KGViKT9PU0Jyb3dzZXIpfCh3ZWJPUyknICtcbiAgICAgICAgICAgICd8KEtpbmRsZS8oMVxcXFwuMHwyXFxcXC5bMDVdfDNcXFxcLjApKSdcbiAgICApLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpIHx8XG4gICAgICAgIC8vIEZlYXR1cmUgZGV0ZWN0aW9uIGZvciBhbGwgb3RoZXIgZGV2aWNlczpcbiAgICAgICAgJCgnPGlucHV0IHR5cGU9XCJmaWxlXCI+JykucHJvcCgnZGlzYWJsZWQnKSk7XG5cbiAgICAvLyBUaGUgRmlsZVJlYWRlciBBUEkgaXMgbm90IGFjdHVhbGx5IHVzZWQsIGJ1dCB3b3JrcyBhcyBmZWF0dXJlIGRldGVjdGlvbixcbiAgICAvLyBhcyBzb21lIFNhZmFyaSB2ZXJzaW9ucyAoNT8pIHN1cHBvcnQgWEhSIGZpbGUgdXBsb2FkcyB2aWEgdGhlIEZvcm1EYXRhIEFQSSxcbiAgICAvLyBidXQgbm90IG5vbi1tdWx0aXBhcnQgWEhSIGZpbGUgdXBsb2Fkcy5cbiAgICAvLyB3aW5kb3cuWE1MSHR0cFJlcXVlc3RVcGxvYWQgaXMgbm90IGF2YWlsYWJsZSBvbiBJRTEwLCBzbyB3ZSBjaGVjayBmb3JcbiAgICAvLyB3aW5kb3cuUHJvZ3Jlc3NFdmVudCBpbnN0ZWFkIHRvIGRldGVjdCBYSFIyIGZpbGUgdXBsb2FkIGNhcGFiaWxpdHk6XG4gICAgJC5zdXBwb3J0LnhockZpbGVVcGxvYWQgPSAhISh3aW5kb3cuUHJvZ3Jlc3NFdmVudCAmJiB3aW5kb3cuRmlsZVJlYWRlcik7XG4gICAgJC5zdXBwb3J0LnhockZvcm1EYXRhRmlsZVVwbG9hZCA9ICEhd2luZG93LkZvcm1EYXRhO1xuXG4gICAgLy8gRGV0ZWN0IHN1cHBvcnQgZm9yIEJsb2Igc2xpY2luZyAocmVxdWlyZWQgZm9yIGNodW5rZWQgdXBsb2Fkcyk6XG4gICAgJC5zdXBwb3J0LmJsb2JTbGljZSA9IHdpbmRvdy5CbG9iICYmIChCbG9iLnByb3RvdHlwZS5zbGljZSB8fFxuICAgICAgICBCbG9iLnByb3RvdHlwZS53ZWJraXRTbGljZSB8fCBCbG9iLnByb3RvdHlwZS5tb3pTbGljZSk7XG5cbiAgICAvLyBUaGUgZmlsZXVwbG9hZCB3aWRnZXQgbGlzdGVucyBmb3IgY2hhbmdlIGV2ZW50cyBvbiBmaWxlIGlucHV0IGZpZWxkcyBkZWZpbmVkXG4gICAgLy8gdmlhIGZpbGVJbnB1dCBzZXR0aW5nIGFuZCBwYXN0ZSBvciBkcm9wIGV2ZW50cyBvZiB0aGUgZ2l2ZW4gZHJvcFpvbmUuXG4gICAgLy8gSW4gYWRkaXRpb24gdG8gdGhlIGRlZmF1bHQgalF1ZXJ5IFdpZGdldCBtZXRob2RzLCB0aGUgZmlsZXVwbG9hZCB3aWRnZXRcbiAgICAvLyBleHBvc2VzIHRoZSBcImFkZFwiIGFuZCBcInNlbmRcIiBtZXRob2RzLCB0byBhZGQgb3IgZGlyZWN0bHkgc2VuZCBmaWxlcyB1c2luZ1xuICAgIC8vIHRoZSBmaWxldXBsb2FkIEFQSS5cbiAgICAvLyBCeSBkZWZhdWx0LCBmaWxlcyBhZGRlZCB2aWEgZmlsZSBpbnB1dCBzZWxlY3Rpb24sIHBhc3RlLCBkcmFnICYgZHJvcCBvclxuICAgIC8vIFwiYWRkXCIgbWV0aG9kIGFyZSB1cGxvYWRlZCBpbW1lZGlhdGVseSwgYnV0IGl0IGlzIHBvc3NpYmxlIHRvIG92ZXJyaWRlXG4gICAgLy8gdGhlIFwiYWRkXCIgY2FsbGJhY2sgb3B0aW9uIHRvIHF1ZXVlIGZpbGUgdXBsb2Fkcy5cbiAgICAkLndpZGdldCgnYmx1ZWltcC5maWxldXBsb2FkJywge1xuXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIC8vIFRoZSBkcm9wIHRhcmdldCBlbGVtZW50KHMpLCBieSB0aGUgZGVmYXVsdCB0aGUgY29tcGxldGUgZG9jdW1lbnQuXG4gICAgICAgICAgICAvLyBTZXQgdG8gbnVsbCB0byBkaXNhYmxlIGRyYWcgJiBkcm9wIHN1cHBvcnQ6XG4gICAgICAgICAgICBkcm9wWm9uZTogJChkb2N1bWVudCksXG4gICAgICAgICAgICAvLyBUaGUgcGFzdGUgdGFyZ2V0IGVsZW1lbnQocyksIGJ5IHRoZSBkZWZhdWx0IHRoZSBjb21wbGV0ZSBkb2N1bWVudC5cbiAgICAgICAgICAgIC8vIFNldCB0byBudWxsIHRvIGRpc2FibGUgcGFzdGUgc3VwcG9ydDpcbiAgICAgICAgICAgIHBhc3RlWm9uZTogJChkb2N1bWVudCksXG4gICAgICAgICAgICAvLyBUaGUgZmlsZSBpbnB1dCBmaWVsZChzKSwgdGhhdCBhcmUgbGlzdGVuZWQgdG8gZm9yIGNoYW5nZSBldmVudHMuXG4gICAgICAgICAgICAvLyBJZiB1bmRlZmluZWQsIGl0IGlzIHNldCB0byB0aGUgZmlsZSBpbnB1dCBmaWVsZHMgaW5zaWRlXG4gICAgICAgICAgICAvLyBvZiB0aGUgd2lkZ2V0IGVsZW1lbnQgb24gcGx1Z2luIGluaXRpYWxpemF0aW9uLlxuICAgICAgICAgICAgLy8gU2V0IHRvIG51bGwgdG8gZGlzYWJsZSB0aGUgY2hhbmdlIGxpc3RlbmVyLlxuICAgICAgICAgICAgZmlsZUlucHV0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCB0aGUgZmlsZSBpbnB1dCBmaWVsZCBpcyByZXBsYWNlZCB3aXRoIGEgY2xvbmUgYWZ0ZXJcbiAgICAgICAgICAgIC8vIGVhY2ggaW5wdXQgZmllbGQgY2hhbmdlIGV2ZW50LiBUaGlzIGlzIHJlcXVpcmVkIGZvciBpZnJhbWUgdHJhbnNwb3J0XG4gICAgICAgICAgICAvLyBxdWV1ZXMgYW5kIGFsbG93cyBjaGFuZ2UgZXZlbnRzIHRvIGJlIGZpcmVkIGZvciB0aGUgc2FtZSBmaWxlXG4gICAgICAgICAgICAvLyBzZWxlY3Rpb24sIGJ1dCBjYW4gYmUgZGlzYWJsZWQgYnkgc2V0dGluZyB0aGUgZm9sbG93aW5nIG9wdGlvbiB0byBmYWxzZTpcbiAgICAgICAgICAgIHJlcGxhY2VGaWxlSW5wdXQ6IHRydWUsXG4gICAgICAgICAgICAvLyBUaGUgcGFyYW1ldGVyIG5hbWUgZm9yIHRoZSBmaWxlIGZvcm0gZGF0YSAodGhlIHJlcXVlc3QgYXJndW1lbnQgbmFtZSkuXG4gICAgICAgICAgICAvLyBJZiB1bmRlZmluZWQgb3IgZW1wdHksIHRoZSBuYW1lIHByb3BlcnR5IG9mIHRoZSBmaWxlIGlucHV0IGZpZWxkIGlzXG4gICAgICAgICAgICAvLyB1c2VkLCBvciBcImZpbGVzW11cIiBpZiB0aGUgZmlsZSBpbnB1dCBuYW1lIHByb3BlcnR5IGlzIGFsc28gZW1wdHksXG4gICAgICAgICAgICAvLyBjYW4gYmUgYSBzdHJpbmcgb3IgYW4gYXJyYXkgb2Ygc3RyaW5nczpcbiAgICAgICAgICAgIHBhcmFtTmFtZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCwgZWFjaCBmaWxlIG9mIGEgc2VsZWN0aW9uIGlzIHVwbG9hZGVkIHVzaW5nIGFuIGluZGl2aWR1YWxcbiAgICAgICAgICAgIC8vIHJlcXVlc3QgZm9yIFhIUiB0eXBlIHVwbG9hZHMuIFNldCB0byBmYWxzZSB0byB1cGxvYWQgZmlsZVxuICAgICAgICAgICAgLy8gc2VsZWN0aW9ucyBpbiBvbmUgcmVxdWVzdCBlYWNoOlxuICAgICAgICAgICAgc2luZ2xlRmlsZVVwbG9hZHM6IHRydWUsXG4gICAgICAgICAgICAvLyBUbyBsaW1pdCB0aGUgbnVtYmVyIG9mIGZpbGVzIHVwbG9hZGVkIHdpdGggb25lIFhIUiByZXF1ZXN0LFxuICAgICAgICAgICAgLy8gc2V0IHRoZSBmb2xsb3dpbmcgb3B0aW9uIHRvIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIDA6XG4gICAgICAgICAgICBsaW1pdE11bHRpRmlsZVVwbG9hZHM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgb3B0aW9uIGxpbWl0cyB0aGUgbnVtYmVyIG9mIGZpbGVzIHVwbG9hZGVkIHdpdGggb25lXG4gICAgICAgICAgICAvLyBYSFIgcmVxdWVzdCB0byBrZWVwIHRoZSByZXF1ZXN0IHNpemUgdW5kZXIgb3IgZXF1YWwgdG8gdGhlIGRlZmluZWRcbiAgICAgICAgICAgIC8vIGxpbWl0IGluIGJ5dGVzOlxuICAgICAgICAgICAgbGltaXRNdWx0aUZpbGVVcGxvYWRTaXplOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAvLyBNdWx0aXBhcnQgZmlsZSB1cGxvYWRzIGFkZCBhIG51bWJlciBvZiBieXRlcyB0byBlYWNoIHVwbG9hZGVkIGZpbGUsXG4gICAgICAgICAgICAvLyB0aGVyZWZvcmUgdGhlIGZvbGxvd2luZyBvcHRpb24gYWRkcyBhbiBvdmVyaGVhZCBmb3IgZWFjaCBmaWxlIHVzZWRcbiAgICAgICAgICAgIC8vIGluIHRoZSBsaW1pdE11bHRpRmlsZVVwbG9hZFNpemUgY29uZmlndXJhdGlvbjpcbiAgICAgICAgICAgIGxpbWl0TXVsdGlGaWxlVXBsb2FkU2l6ZU92ZXJoZWFkOiA1MTIsXG4gICAgICAgICAgICAvLyBTZXQgdGhlIGZvbGxvd2luZyBvcHRpb24gdG8gdHJ1ZSB0byBpc3N1ZSBhbGwgZmlsZSB1cGxvYWQgcmVxdWVzdHNcbiAgICAgICAgICAgIC8vIGluIGEgc2VxdWVudGlhbCBvcmRlcjpcbiAgICAgICAgICAgIHNlcXVlbnRpYWxVcGxvYWRzOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIFRvIGxpbWl0IHRoZSBudW1iZXIgb2YgY29uY3VycmVudCB1cGxvYWRzLFxuICAgICAgICAgICAgLy8gc2V0IHRoZSBmb2xsb3dpbmcgb3B0aW9uIHRvIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIDA6XG4gICAgICAgICAgICBsaW1pdENvbmN1cnJlbnRVcGxvYWRzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAvLyBTZXQgdGhlIGZvbGxvd2luZyBvcHRpb24gdG8gdHJ1ZSB0byBmb3JjZSBpZnJhbWUgdHJhbnNwb3J0IHVwbG9hZHM6XG4gICAgICAgICAgICBmb3JjZUlmcmFtZVRyYW5zcG9ydDogZmFsc2UsXG4gICAgICAgICAgICAvLyBTZXQgdGhlIGZvbGxvd2luZyBvcHRpb24gdG8gdGhlIGxvY2F0aW9uIG9mIGEgcmVkaXJlY3QgdXJsIG9uIHRoZVxuICAgICAgICAgICAgLy8gb3JpZ2luIHNlcnZlciwgZm9yIGNyb3NzLWRvbWFpbiBpZnJhbWUgdHJhbnNwb3J0IHVwbG9hZHM6XG4gICAgICAgICAgICByZWRpcmVjdDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgLy8gVGhlIHBhcmFtZXRlciBuYW1lIGZvciB0aGUgcmVkaXJlY3QgdXJsLCBzZW50IGFzIHBhcnQgb2YgdGhlIGZvcm1cbiAgICAgICAgICAgIC8vIGRhdGEgYW5kIHNldCB0byAncmVkaXJlY3QnIGlmIHRoaXMgb3B0aW9uIGlzIGVtcHR5OlxuICAgICAgICAgICAgcmVkaXJlY3RQYXJhbU5hbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIFNldCB0aGUgZm9sbG93aW5nIG9wdGlvbiB0byB0aGUgbG9jYXRpb24gb2YgYSBwb3N0TWVzc2FnZSB3aW5kb3csXG4gICAgICAgICAgICAvLyB0byBlbmFibGUgcG9zdE1lc3NhZ2UgdHJhbnNwb3J0IHVwbG9hZHM6XG4gICAgICAgICAgICBwb3N0TWVzc2FnZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCwgWEhSIGZpbGUgdXBsb2FkcyBhcmUgc2VudCBhcyBtdWx0aXBhcnQvZm9ybS1kYXRhLlxuICAgICAgICAgICAgLy8gVGhlIGlmcmFtZSB0cmFuc3BvcnQgaXMgYWx3YXlzIHVzaW5nIG11bHRpcGFydC9mb3JtLWRhdGEuXG4gICAgICAgICAgICAvLyBTZXQgdG8gZmFsc2UgdG8gZW5hYmxlIG5vbi1tdWx0aXBhcnQgWEhSIHVwbG9hZHM6XG4gICAgICAgICAgICBtdWx0aXBhcnQ6IHRydWUsXG4gICAgICAgICAgICAvLyBUbyB1cGxvYWQgbGFyZ2UgZmlsZXMgaW4gc21hbGxlciBjaHVua3MsIHNldCB0aGUgZm9sbG93aW5nIG9wdGlvblxuICAgICAgICAgICAgLy8gdG8gYSBwcmVmZXJyZWQgbWF4aW11bSBjaHVuayBzaXplLiBJZiBzZXQgdG8gMCwgbnVsbCBvciB1bmRlZmluZWQsXG4gICAgICAgICAgICAvLyBvciB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSByZXF1aXJlZCBCbG9iIEFQSSwgZmlsZXMgd2lsbFxuICAgICAgICAgICAgLy8gYmUgdXBsb2FkZWQgYXMgYSB3aG9sZS5cbiAgICAgICAgICAgIG1heENodW5rU2l6ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgLy8gV2hlbiBhIG5vbi1tdWx0aXBhcnQgdXBsb2FkIG9yIGEgY2h1bmtlZCBtdWx0aXBhcnQgdXBsb2FkIGhhcyBiZWVuXG4gICAgICAgICAgICAvLyBhYm9ydGVkLCB0aGlzIG9wdGlvbiBjYW4gYmUgdXNlZCB0byByZXN1bWUgdGhlIHVwbG9hZCBieSBzZXR0aW5nXG4gICAgICAgICAgICAvLyBpdCB0byB0aGUgc2l6ZSBvZiB0aGUgYWxyZWFkeSB1cGxvYWRlZCBieXRlcy4gVGhpcyBvcHRpb24gaXMgbW9zdFxuICAgICAgICAgICAgLy8gdXNlZnVsIHdoZW4gbW9kaWZ5aW5nIHRoZSBvcHRpb25zIG9iamVjdCBpbnNpZGUgb2YgdGhlIFwiYWRkXCIgb3JcbiAgICAgICAgICAgIC8vIFwic2VuZFwiIGNhbGxiYWNrcywgYXMgdGhlIG9wdGlvbnMgYXJlIGNsb25lZCBmb3IgZWFjaCBmaWxlIHVwbG9hZC5cbiAgICAgICAgICAgIHVwbG9hZGVkQnl0ZXM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIEJ5IGRlZmF1bHQsIGZhaWxlZCAoYWJvcnQgb3IgZXJyb3IpIGZpbGUgdXBsb2FkcyBhcmUgcmVtb3ZlZCBmcm9tIHRoZVxuICAgICAgICAgICAgLy8gZ2xvYmFsIHByb2dyZXNzIGNhbGN1bGF0aW9uLiBTZXQgdGhlIGZvbGxvd2luZyBvcHRpb24gdG8gZmFsc2UgdG9cbiAgICAgICAgICAgIC8vIHByZXZlbnQgcmVjYWxjdWxhdGluZyB0aGUgZ2xvYmFsIHByb2dyZXNzIGRhdGE6XG4gICAgICAgICAgICByZWNhbGN1bGF0ZVByb2dyZXNzOiB0cnVlLFxuICAgICAgICAgICAgLy8gSW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzIHRvIGNhbGN1bGF0ZSBhbmQgdHJpZ2dlciBwcm9ncmVzcyBldmVudHM6XG4gICAgICAgICAgICBwcm9ncmVzc0ludGVydmFsOiAxMDAsXG4gICAgICAgICAgICAvLyBJbnRlcnZhbCBpbiBtaWxsaXNlY29uZHMgdG8gY2FsY3VsYXRlIHByb2dyZXNzIGJpdHJhdGU6XG4gICAgICAgICAgICBiaXRyYXRlSW50ZXJ2YWw6IDUwMCxcbiAgICAgICAgICAgIC8vIEJ5IGRlZmF1bHQsIHVwbG9hZHMgYXJlIHN0YXJ0ZWQgYXV0b21hdGljYWxseSB3aGVuIGFkZGluZyBmaWxlczpcbiAgICAgICAgICAgIGF1dG9VcGxvYWQ6IHRydWUsXG5cbiAgICAgICAgICAgIC8vIEVycm9yIGFuZCBpbmZvIG1lc3NhZ2VzOlxuICAgICAgICAgICAgbWVzc2FnZXM6IHtcbiAgICAgICAgICAgICAgICB1cGxvYWRlZEJ5dGVzOiAnVXBsb2FkZWQgYnl0ZXMgZXhjZWVkIGZpbGUgc2l6ZSdcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIFRyYW5zbGF0aW9uIGZ1bmN0aW9uLCBnZXRzIHRoZSBtZXNzYWdlIGtleSB0byBiZSB0cmFuc2xhdGVkXG4gICAgICAgICAgICAvLyBhbmQgYW4gb2JqZWN0IHdpdGggY29udGV4dCBzcGVjaWZpYyBkYXRhIGFzIGFyZ3VtZW50czpcbiAgICAgICAgICAgIGkxOG46IGZ1bmN0aW9uIChtZXNzYWdlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IHRoaXMubWVzc2FnZXNbbWVzc2FnZV0gfHwgbWVzc2FnZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICQuZWFjaChjb250ZXh0LCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZSgneycgKyBrZXkgKyAnfScsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gQWRkaXRpb25hbCBmb3JtIGRhdGEgdG8gYmUgc2VudCBhbG9uZyB3aXRoIHRoZSBmaWxlIHVwbG9hZHMgY2FuIGJlIHNldFxuICAgICAgICAgICAgLy8gdXNpbmcgdGhpcyBvcHRpb24sIHdoaWNoIGFjY2VwdHMgYW4gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIG5hbWUgYW5kXG4gICAgICAgICAgICAvLyB2YWx1ZSBwcm9wZXJ0aWVzLCBhIGZ1bmN0aW9uIHJldHVybmluZyBzdWNoIGFuIGFycmF5LCBhIEZvcm1EYXRhXG4gICAgICAgICAgICAvLyBvYmplY3QgKGZvciBYSFIgZmlsZSB1cGxvYWRzKSwgb3IgYSBzaW1wbGUgb2JqZWN0LlxuICAgICAgICAgICAgLy8gVGhlIGZvcm0gb2YgdGhlIGZpcnN0IGZpbGVJbnB1dCBpcyBnaXZlbiBhcyBwYXJhbWV0ZXIgdG8gdGhlIGZ1bmN0aW9uOlxuICAgICAgICAgICAgZm9ybURhdGE6IGZ1bmN0aW9uIChmb3JtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm0uc2VyaWFsaXplQXJyYXkoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIFRoZSBhZGQgY2FsbGJhY2sgaXMgaW52b2tlZCBhcyBzb29uIGFzIGZpbGVzIGFyZSBhZGRlZCB0byB0aGUgZmlsZXVwbG9hZFxuICAgICAgICAgICAgLy8gd2lkZ2V0ICh2aWEgZmlsZSBpbnB1dCBzZWxlY3Rpb24sIGRyYWcgJiBkcm9wLCBwYXN0ZSBvciBhZGQgQVBJIGNhbGwpLlxuICAgICAgICAgICAgLy8gSWYgdGhlIHNpbmdsZUZpbGVVcGxvYWRzIG9wdGlvbiBpcyBlbmFibGVkLCB0aGlzIGNhbGxiYWNrIHdpbGwgYmVcbiAgICAgICAgICAgIC8vIGNhbGxlZCBvbmNlIGZvciBlYWNoIGZpbGUgaW4gdGhlIHNlbGVjdGlvbiBmb3IgWEhSIGZpbGUgdXBsb2FkcywgZWxzZVxuICAgICAgICAgICAgLy8gb25jZSBmb3IgZWFjaCBmaWxlIHNlbGVjdGlvbi5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUaGUgdXBsb2FkIHN0YXJ0cyB3aGVuIHRoZSBzdWJtaXQgbWV0aG9kIGlzIGludm9rZWQgb24gdGhlIGRhdGEgcGFyYW1ldGVyLlxuICAgICAgICAgICAgLy8gVGhlIGRhdGEgb2JqZWN0IGNvbnRhaW5zIGEgZmlsZXMgcHJvcGVydHkgaG9sZGluZyB0aGUgYWRkZWQgZmlsZXNcbiAgICAgICAgICAgIC8vIGFuZCBhbGxvd3MgeW91IHRvIG92ZXJyaWRlIHBsdWdpbiBvcHRpb25zIGFzIHdlbGwgYXMgZGVmaW5lIGFqYXggc2V0dGluZ3MuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gTGlzdGVuZXJzIGZvciB0aGlzIGNhbGxiYWNrIGNhbiBhbHNvIGJlIGJvdW5kIHRoZSBmb2xsb3dpbmcgd2F5OlxuICAgICAgICAgICAgLy8gLmJpbmQoJ2ZpbGV1cGxvYWRhZGQnLCBmdW5jKTtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBkYXRhLnN1Ym1pdCgpIHJldHVybnMgYSBQcm9taXNlIG9iamVjdCBhbmQgYWxsb3dzIHRvIGF0dGFjaCBhZGRpdGlvbmFsXG4gICAgICAgICAgICAvLyBoYW5kbGVycyB1c2luZyBqUXVlcnkncyBEZWZlcnJlZCBjYWxsYmFja3M6XG4gICAgICAgICAgICAvLyBkYXRhLnN1Ym1pdCgpLmRvbmUoZnVuYykuZmFpbChmdW5jKS5hbHdheXMoZnVuYyk7XG4gICAgICAgICAgICBhZGQ6IGZ1bmN0aW9uIChlLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5hdXRvVXBsb2FkIHx8IChkYXRhLmF1dG9VcGxvYWQgIT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmZpbGV1cGxvYWQoJ29wdGlvbicsICdhdXRvVXBsb2FkJykpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEucHJvY2VzcygpLmRvbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5zdWJtaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gT3RoZXIgY2FsbGJhY2tzOlxuXG4gICAgICAgICAgICAvLyBDYWxsYmFjayBmb3IgdGhlIHN1Ym1pdCBldmVudCBvZiBlYWNoIGZpbGUgdXBsb2FkOlxuICAgICAgICAgICAgLy8gc3VibWl0OiBmdW5jdGlvbiAoZSwgZGF0YSkge30sIC8vIC5iaW5kKCdmaWxldXBsb2Fkc3VibWl0JywgZnVuYyk7XG5cbiAgICAgICAgICAgIC8vIENhbGxiYWNrIGZvciB0aGUgc3RhcnQgb2YgZWFjaCBmaWxlIHVwbG9hZCByZXF1ZXN0OlxuICAgICAgICAgICAgLy8gc2VuZDogZnVuY3Rpb24gKGUsIGRhdGEpIHt9LCAvLyAuYmluZCgnZmlsZXVwbG9hZHNlbmQnLCBmdW5jKTtcblxuICAgICAgICAgICAgLy8gQ2FsbGJhY2sgZm9yIHN1Y2Nlc3NmdWwgdXBsb2FkczpcbiAgICAgICAgICAgIC8vIGRvbmU6IGZ1bmN0aW9uIChlLCBkYXRhKSB7fSwgLy8gLmJpbmQoJ2ZpbGV1cGxvYWRkb25lJywgZnVuYyk7XG5cbiAgICAgICAgICAgIC8vIENhbGxiYWNrIGZvciBmYWlsZWQgKGFib3J0IG9yIGVycm9yKSB1cGxvYWRzOlxuICAgICAgICAgICAgLy8gZmFpbDogZnVuY3Rpb24gKGUsIGRhdGEpIHt9LCAvLyAuYmluZCgnZmlsZXVwbG9hZGZhaWwnLCBmdW5jKTtcblxuICAgICAgICAgICAgLy8gQ2FsbGJhY2sgZm9yIGNvbXBsZXRlZCAoc3VjY2VzcywgYWJvcnQgb3IgZXJyb3IpIHJlcXVlc3RzOlxuICAgICAgICAgICAgLy8gYWx3YXlzOiBmdW5jdGlvbiAoZSwgZGF0YSkge30sIC8vIC5iaW5kKCdmaWxldXBsb2FkYWx3YXlzJywgZnVuYyk7XG5cbiAgICAgICAgICAgIC8vIENhbGxiYWNrIGZvciB1cGxvYWQgcHJvZ3Jlc3MgZXZlbnRzOlxuICAgICAgICAgICAgLy8gcHJvZ3Jlc3M6IGZ1bmN0aW9uIChlLCBkYXRhKSB7fSwgLy8gLmJpbmQoJ2ZpbGV1cGxvYWRwcm9ncmVzcycsIGZ1bmMpO1xuXG4gICAgICAgICAgICAvLyBDYWxsYmFjayBmb3IgZ2xvYmFsIHVwbG9hZCBwcm9ncmVzcyBldmVudHM6XG4gICAgICAgICAgICAvLyBwcm9ncmVzc2FsbDogZnVuY3Rpb24gKGUsIGRhdGEpIHt9LCAvLyAuYmluZCgnZmlsZXVwbG9hZHByb2dyZXNzYWxsJywgZnVuYyk7XG5cbiAgICAgICAgICAgIC8vIENhbGxiYWNrIGZvciB1cGxvYWRzIHN0YXJ0LCBlcXVpdmFsZW50IHRvIHRoZSBnbG9iYWwgYWpheFN0YXJ0IGV2ZW50OlxuICAgICAgICAgICAgLy8gc3RhcnQ6IGZ1bmN0aW9uIChlKSB7fSwgLy8gLmJpbmQoJ2ZpbGV1cGxvYWRzdGFydCcsIGZ1bmMpO1xuXG4gICAgICAgICAgICAvLyBDYWxsYmFjayBmb3IgdXBsb2FkcyBzdG9wLCBlcXVpdmFsZW50IHRvIHRoZSBnbG9iYWwgYWpheFN0b3AgZXZlbnQ6XG4gICAgICAgICAgICAvLyBzdG9wOiBmdW5jdGlvbiAoZSkge30sIC8vIC5iaW5kKCdmaWxldXBsb2Fkc3RvcCcsIGZ1bmMpO1xuXG4gICAgICAgICAgICAvLyBDYWxsYmFjayBmb3IgY2hhbmdlIGV2ZW50cyBvZiB0aGUgZmlsZUlucHV0KHMpOlxuICAgICAgICAgICAgLy8gY2hhbmdlOiBmdW5jdGlvbiAoZSwgZGF0YSkge30sIC8vIC5iaW5kKCdmaWxldXBsb2FkY2hhbmdlJywgZnVuYyk7XG5cbiAgICAgICAgICAgIC8vIENhbGxiYWNrIGZvciBwYXN0ZSBldmVudHMgdG8gdGhlIHBhc3RlWm9uZShzKTpcbiAgICAgICAgICAgIC8vIHBhc3RlOiBmdW5jdGlvbiAoZSwgZGF0YSkge30sIC8vIC5iaW5kKCdmaWxldXBsb2FkcGFzdGUnLCBmdW5jKTtcblxuICAgICAgICAgICAgLy8gQ2FsbGJhY2sgZm9yIGRyb3AgZXZlbnRzIG9mIHRoZSBkcm9wWm9uZShzKTpcbiAgICAgICAgICAgIC8vIGRyb3A6IGZ1bmN0aW9uIChlLCBkYXRhKSB7fSwgLy8gLmJpbmQoJ2ZpbGV1cGxvYWRkcm9wJywgZnVuYyk7XG5cbiAgICAgICAgICAgIC8vIENhbGxiYWNrIGZvciBkcmFnb3ZlciBldmVudHMgb2YgdGhlIGRyb3Bab25lKHMpOlxuICAgICAgICAgICAgLy8gZHJhZ292ZXI6IGZ1bmN0aW9uIChlKSB7fSwgLy8gLmJpbmQoJ2ZpbGV1cGxvYWRkcmFnb3ZlcicsIGZ1bmMpO1xuXG4gICAgICAgICAgICAvLyBDYWxsYmFjayBmb3IgdGhlIHN0YXJ0IG9mIGVhY2ggY2h1bmsgdXBsb2FkIHJlcXVlc3Q6XG4gICAgICAgICAgICAvLyBjaHVua3NlbmQ6IGZ1bmN0aW9uIChlLCBkYXRhKSB7fSwgLy8gLmJpbmQoJ2ZpbGV1cGxvYWRjaHVua3NlbmQnLCBmdW5jKTtcblxuICAgICAgICAgICAgLy8gQ2FsbGJhY2sgZm9yIHN1Y2Nlc3NmdWwgY2h1bmsgdXBsb2FkczpcbiAgICAgICAgICAgIC8vIGNodW5rZG9uZTogZnVuY3Rpb24gKGUsIGRhdGEpIHt9LCAvLyAuYmluZCgnZmlsZXVwbG9hZGNodW5rZG9uZScsIGZ1bmMpO1xuXG4gICAgICAgICAgICAvLyBDYWxsYmFjayBmb3IgZmFpbGVkIChhYm9ydCBvciBlcnJvcikgY2h1bmsgdXBsb2FkczpcbiAgICAgICAgICAgIC8vIGNodW5rZmFpbDogZnVuY3Rpb24gKGUsIGRhdGEpIHt9LCAvLyAuYmluZCgnZmlsZXVwbG9hZGNodW5rZmFpbCcsIGZ1bmMpO1xuXG4gICAgICAgICAgICAvLyBDYWxsYmFjayBmb3IgY29tcGxldGVkIChzdWNjZXNzLCBhYm9ydCBvciBlcnJvcikgY2h1bmsgdXBsb2FkIHJlcXVlc3RzOlxuICAgICAgICAgICAgLy8gY2h1bmthbHdheXM6IGZ1bmN0aW9uIChlLCBkYXRhKSB7fSwgLy8gLmJpbmQoJ2ZpbGV1cGxvYWRjaHVua2Fsd2F5cycsIGZ1bmMpO1xuXG4gICAgICAgICAgICAvLyBUaGUgcGx1Z2luIG9wdGlvbnMgYXJlIHVzZWQgYXMgc2V0dGluZ3Mgb2JqZWN0IGZvciB0aGUgYWpheCBjYWxscy5cbiAgICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgYXJlIGpRdWVyeSBhamF4IHNldHRpbmdzIHJlcXVpcmVkIGZvciB0aGUgZmlsZSB1cGxvYWRzOlxuICAgICAgICAgICAgcHJvY2Vzc0RhdGE6IGZhbHNlLFxuICAgICAgICAgICAgY29udGVudFR5cGU6IGZhbHNlLFxuICAgICAgICAgICAgY2FjaGU6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQSBsaXN0IG9mIG9wdGlvbnMgdGhhdCByZXF1aXJlIHJlaW5pdGlhbGl6aW5nIGV2ZW50IGxpc3RlbmVycyBhbmQvb3JcbiAgICAgICAgLy8gc3BlY2lhbCBpbml0aWFsaXphdGlvbiBjb2RlOlxuICAgICAgICBfc3BlY2lhbE9wdGlvbnM6IFtcbiAgICAgICAgICAgICdmaWxlSW5wdXQnLFxuICAgICAgICAgICAgJ2Ryb3Bab25lJyxcbiAgICAgICAgICAgICdwYXN0ZVpvbmUnLFxuICAgICAgICAgICAgJ211bHRpcGFydCcsXG4gICAgICAgICAgICAnZm9yY2VJZnJhbWVUcmFuc3BvcnQnXG4gICAgICAgIF0sXG5cbiAgICAgICAgX2Jsb2JTbGljZTogJC5zdXBwb3J0LmJsb2JTbGljZSAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2xpY2UgPSB0aGlzLnNsaWNlIHx8IHRoaXMud2Via2l0U2xpY2UgfHwgdGhpcy5tb3pTbGljZTtcbiAgICAgICAgICAgIHJldHVybiBzbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9CaXRyYXRlVGltZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMudGltZXN0YW1wID0gKChEYXRlLm5vdykgPyBEYXRlLm5vdygpIDogKG5ldyBEYXRlKCkpLmdldFRpbWUoKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlZCA9IDA7XG4gICAgICAgICAgICB0aGlzLmJpdHJhdGUgPSAwO1xuICAgICAgICAgICAgdGhpcy5nZXRCaXRyYXRlID0gZnVuY3Rpb24gKG5vdywgbG9hZGVkLCBpbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIHZhciB0aW1lRGlmZiA9IG5vdyAtIHRoaXMudGltZXN0YW1wO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5iaXRyYXRlIHx8ICFpbnRlcnZhbCB8fCB0aW1lRGlmZiA+IGludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYml0cmF0ZSA9IChsb2FkZWQgLSB0aGlzLmxvYWRlZCkgKiAoMTAwMCAvIHRpbWVEaWZmKSAqIDg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZGVkID0gbG9hZGVkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IG5vdztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYml0cmF0ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2lzWEhSVXBsb2FkOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuICFvcHRpb25zLmZvcmNlSWZyYW1lVHJhbnNwb3J0ICYmXG4gICAgICAgICAgICAgICAgKCghb3B0aW9ucy5tdWx0aXBhcnQgJiYgJC5zdXBwb3J0LnhockZpbGVVcGxvYWQpIHx8XG4gICAgICAgICAgICAgICAgJC5zdXBwb3J0LnhockZvcm1EYXRhRmlsZVVwbG9hZCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldEZvcm1EYXRhOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIGZvcm1EYXRhO1xuICAgICAgICAgICAgaWYgKCQudHlwZShvcHRpb25zLmZvcm1EYXRhKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmZvcm1EYXRhKG9wdGlvbnMuZm9ybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJC5pc0FycmF5KG9wdGlvbnMuZm9ybURhdGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZm9ybURhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJC50eXBlKG9wdGlvbnMuZm9ybURhdGEpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGZvcm1EYXRhID0gW107XG4gICAgICAgICAgICAgICAgJC5lYWNoKG9wdGlvbnMuZm9ybURhdGEsIGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YS5wdXNoKHtuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWV9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybURhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldFRvdGFsOiBmdW5jdGlvbiAoZmlsZXMpIHtcbiAgICAgICAgICAgIHZhciB0b3RhbCA9IDA7XG4gICAgICAgICAgICAkLmVhY2goZmlsZXMsIGZ1bmN0aW9uIChpbmRleCwgZmlsZSkge1xuICAgICAgICAgICAgICAgIHRvdGFsICs9IGZpbGUuc2l6ZSB8fCAxO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2luaXRQcm9ncmVzc09iamVjdDogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgdmFyIHByb2dyZXNzID0ge1xuICAgICAgICAgICAgICAgIGxvYWRlZDogMCxcbiAgICAgICAgICAgICAgICB0b3RhbDogMCxcbiAgICAgICAgICAgICAgICBiaXRyYXRlOiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKG9iai5fcHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAkLmV4dGVuZChvYmouX3Byb2dyZXNzLCBwcm9ncmVzcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9iai5fcHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfaW5pdFJlc3BvbnNlT2JqZWN0OiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICB2YXIgcHJvcDtcbiAgICAgICAgICAgIGlmIChvYmouX3Jlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChwcm9wIGluIG9iai5fcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5fcmVzcG9uc2UuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmouX3Jlc3BvbnNlW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYmouX3Jlc3BvbnNlID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX29uUHJvZ3Jlc3M6IGZ1bmN0aW9uIChlLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZS5sZW5ndGhDb21wdXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vdyA9ICgoRGF0ZS5ub3cpID8gRGF0ZS5ub3coKSA6IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkpLFxuICAgICAgICAgICAgICAgICAgICBsb2FkZWQ7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuX3RpbWUgJiYgZGF0YS5wcm9ncmVzc0ludGVydmFsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAobm93IC0gZGF0YS5fdGltZSA8IGRhdGEucHJvZ3Jlc3NJbnRlcnZhbCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGUubG9hZGVkICE9PSBlLnRvdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YS5fdGltZSA9IG5vdztcbiAgICAgICAgICAgICAgICBsb2FkZWQgPSBNYXRoLmZsb29yKFxuICAgICAgICAgICAgICAgICAgICBlLmxvYWRlZCAvIGUudG90YWwgKiAoZGF0YS5jaHVua1NpemUgfHwgZGF0YS5fcHJvZ3Jlc3MudG90YWwpXG4gICAgICAgICAgICAgICAgKSArIChkYXRhLnVwbG9hZGVkQnl0ZXMgfHwgMCk7XG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBkaWZmZXJlbmNlIGZyb20gdGhlIHByZXZpb3VzbHkgbG9hZGVkIHN0YXRlXG4gICAgICAgICAgICAgICAgLy8gdG8gdGhlIGdsb2JhbCBsb2FkZWQgY291bnRlcjpcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9ncmVzcy5sb2FkZWQgKz0gKGxvYWRlZCAtIGRhdGEuX3Byb2dyZXNzLmxvYWRlZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3MuYml0cmF0ZSA9IHRoaXMuX2JpdHJhdGVUaW1lci5nZXRCaXRyYXRlKFxuICAgICAgICAgICAgICAgICAgICBub3csXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzLmxvYWRlZCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5iaXRyYXRlSW50ZXJ2YWxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGRhdGEuX3Byb2dyZXNzLmxvYWRlZCA9IGRhdGEubG9hZGVkID0gbG9hZGVkO1xuICAgICAgICAgICAgICAgIGRhdGEuX3Byb2dyZXNzLmJpdHJhdGUgPSBkYXRhLmJpdHJhdGUgPSBkYXRhLl9iaXRyYXRlVGltZXIuZ2V0Qml0cmF0ZShcbiAgICAgICAgICAgICAgICAgICAgbm93LFxuICAgICAgICAgICAgICAgICAgICBsb2FkZWQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuYml0cmF0ZUludGVydmFsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyIGEgY3VzdG9tIHByb2dyZXNzIGV2ZW50IHdpdGggYSB0b3RhbCBkYXRhIHByb3BlcnR5IHNldFxuICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBmaWxlIHNpemUocykgb2YgdGhlIGN1cnJlbnQgdXBsb2FkIGFuZCBhIGxvYWRlZCBkYXRhXG4gICAgICAgICAgICAgICAgLy8gcHJvcGVydHkgY2FsY3VsYXRlZCBhY2NvcmRpbmdseTpcbiAgICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyKFxuICAgICAgICAgICAgICAgICAgICAncHJvZ3Jlc3MnLFxuICAgICAgICAgICAgICAgICAgICAkLkV2ZW50KCdwcm9ncmVzcycsIHtkZWxlZ2F0ZWRFdmVudDogZX0pLFxuICAgICAgICAgICAgICAgICAgICBkYXRhXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyIGEgZ2xvYmFsIHByb2dyZXNzIGV2ZW50IGZvciBhbGwgY3VycmVudCBmaWxlIHVwbG9hZHMsXG4gICAgICAgICAgICAgICAgLy8gaW5jbHVkaW5nIGFqYXggY2FsbHMgcXVldWVkIGZvciBzZXF1ZW50aWFsIGZpbGUgdXBsb2FkczpcbiAgICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyKFxuICAgICAgICAgICAgICAgICAgICAncHJvZ3Jlc3NhbGwnLFxuICAgICAgICAgICAgICAgICAgICAkLkV2ZW50KCdwcm9ncmVzc2FsbCcsIHtkZWxlZ2F0ZWRFdmVudDogZX0pLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9ncmVzc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2luaXRQcm9ncmVzc0xpc3RlbmVyOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHhociA9IG9wdGlvbnMueGhyID8gb3B0aW9ucy54aHIoKSA6ICQuYWpheFNldHRpbmdzLnhocigpO1xuICAgICAgICAgICAgLy8gQWNjZXNzcyB0byB0aGUgbmF0aXZlIFhIUiBvYmplY3QgaXMgcmVxdWlyZWQgdG8gYWRkIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICAgICAgLy8gZm9yIHRoZSB1cGxvYWQgcHJvZ3Jlc3MgZXZlbnQ6XG4gICAgICAgICAgICBpZiAoeGhyLnVwbG9hZCkge1xuICAgICAgICAgICAgICAgICQoeGhyLnVwbG9hZCkuYmluZCgncHJvZ3Jlc3MnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2UgPSBlLm9yaWdpbmFsRXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgcHJvZ3Jlc3MgZXZlbnQgcHJvcGVydGllcyBnZXQgY29waWVkIG92ZXI6XG4gICAgICAgICAgICAgICAgICAgIGUubGVuZ3RoQ29tcHV0YWJsZSA9IG9lLmxlbmd0aENvbXB1dGFibGU7XG4gICAgICAgICAgICAgICAgICAgIGUubG9hZGVkID0gb2UubG9hZGVkO1xuICAgICAgICAgICAgICAgICAgICBlLnRvdGFsID0gb2UudG90YWw7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuX29uUHJvZ3Jlc3MoZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy54aHIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4aHI7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfaXNJbnN0YW5jZU9mOiBmdW5jdGlvbiAodHlwZSwgb2JqKSB7XG4gICAgICAgICAgICAvLyBDcm9zcy1mcmFtZSBpbnN0YW5jZW9mIGNoZWNrXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0ICcgKyB0eXBlICsgJ10nO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9pbml0WEhSRGF0YTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICBmb3JtRGF0YSxcbiAgICAgICAgICAgICAgICBmaWxlID0gb3B0aW9ucy5maWxlc1swXSxcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgbm9uLW11bHRpcGFydCBzZXR0aW5nIGlmIG5vdCBzdXBwb3J0ZWQ6XG4gICAgICAgICAgICAgICAgbXVsdGlwYXJ0ID0gb3B0aW9ucy5tdWx0aXBhcnQgfHwgISQuc3VwcG9ydC54aHJGaWxlVXBsb2FkLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZSA9ICQudHlwZShvcHRpb25zLnBhcmFtTmFtZSkgPT09ICdhcnJheScgP1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhcmFtTmFtZVswXSA6IG9wdGlvbnMucGFyYW1OYW1lO1xuICAgICAgICAgICAgb3B0aW9ucy5oZWFkZXJzID0gJC5leHRlbmQoe30sIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jb250ZW50UmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmhlYWRlcnNbJ0NvbnRlbnQtUmFuZ2UnXSA9IG9wdGlvbnMuY29udGVudFJhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtdWx0aXBhcnQgfHwgb3B0aW9ucy5ibG9iIHx8ICF0aGlzLl9pc0luc3RhbmNlT2YoJ0ZpbGUnLCBmaWxlKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVyc1snQ29udGVudC1EaXNwb3NpdGlvbiddID0gJ2F0dGFjaG1lbnQ7IGZpbGVuYW1lPVwiJyArXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZVVSSShmaWxlLm5hbWUpICsgJ1wiJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbXVsdGlwYXJ0KSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jb250ZW50VHlwZSA9IGZpbGUudHlwZSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBvcHRpb25zLmJsb2IgfHwgZmlsZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJC5zdXBwb3J0LnhockZvcm1EYXRhRmlsZVVwbG9hZCkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnBvc3RNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdpbmRvdy5wb3N0TWVzc2FnZSBkb2VzIG5vdCBhbGxvdyBzZW5kaW5nIEZvcm1EYXRhXG4gICAgICAgICAgICAgICAgICAgIC8vIG9iamVjdHMsIHNvIHdlIGp1c3QgYWRkIHRoZSBGaWxlL0Jsb2Igb2JqZWN0cyB0b1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZm9ybURhdGEgYXJyYXkgYW5kIGxldCB0aGUgcG9zdE1lc3NhZ2Ugd2luZG93XG4gICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgRm9ybURhdGEgb2JqZWN0IG91dCBvZiB0aGlzIGFycmF5OlxuICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YSA9IHRoaXMuX2dldEZvcm1EYXRhKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ibG9iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuYmxvYlxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkLmVhY2gob3B0aW9ucy5maWxlcywgZnVuY3Rpb24gKGluZGV4LCBmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybURhdGEucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICgkLnR5cGUob3B0aW9ucy5wYXJhbU5hbWUpID09PSAnYXJyYXknICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhcmFtTmFtZVtpbmRleF0pIHx8IHBhcmFtTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQuX2lzSW5zdGFuY2VPZignRm9ybURhdGEnLCBvcHRpb25zLmZvcm1EYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybURhdGEgPSBvcHRpb25zLmZvcm1EYXRhO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICQuZWFjaCh0aGlzLl9nZXRGb3JtRGF0YShvcHRpb25zKSwgZnVuY3Rpb24gKGluZGV4LCBmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChmaWVsZC5uYW1lLCBmaWVsZC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ibG9iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQocGFyYW1OYW1lLCBvcHRpb25zLmJsb2IsIGZpbGUubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkLmVhY2gob3B0aW9ucy5maWxlcywgZnVuY3Rpb24gKGluZGV4LCBmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBjaGVjayBhbGxvd3MgdGhlIHRlc3RzIHRvIHJ1biB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZHVtbXkgb2JqZWN0czpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5faXNJbnN0YW5jZU9mKCdGaWxlJywgZmlsZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX2lzSW5zdGFuY2VPZignQmxvYicsIGZpbGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgkLnR5cGUob3B0aW9ucy5wYXJhbU5hbWUpID09PSAnYXJyYXknICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXJhbU5hbWVbaW5kZXhdKSB8fCBwYXJhbU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS51cGxvYWROYW1lIHx8IGZpbGUubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IGZvcm1EYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQmxvYiByZWZlcmVuY2UgaXMgbm90IG5lZWRlZCBhbnltb3JlLCBmcmVlIG1lbW9yeTpcbiAgICAgICAgICAgIG9wdGlvbnMuYmxvYiA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2luaXRJZnJhbWVTZXR0aW5nczogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRIb3N0ID0gJCgnPGE+PC9hPicpLnByb3AoJ2hyZWYnLCBvcHRpb25zLnVybCkucHJvcCgnaG9zdCcpO1xuICAgICAgICAgICAgLy8gU2V0dGluZyB0aGUgZGF0YVR5cGUgdG8gaWZyYW1lIGVuYWJsZXMgdGhlIGlmcmFtZSB0cmFuc3BvcnQ6XG4gICAgICAgICAgICBvcHRpb25zLmRhdGFUeXBlID0gJ2lmcmFtZSAnICsgKG9wdGlvbnMuZGF0YVR5cGUgfHwgJycpO1xuICAgICAgICAgICAgLy8gVGhlIGlmcmFtZSB0cmFuc3BvcnQgYWNjZXB0cyBhIHNlcmlhbGl6ZWQgYXJyYXkgYXMgZm9ybSBkYXRhOlxuICAgICAgICAgICAgb3B0aW9ucy5mb3JtRGF0YSA9IHRoaXMuX2dldEZvcm1EYXRhKG9wdGlvbnMpO1xuICAgICAgICAgICAgLy8gQWRkIHJlZGlyZWN0IHVybCB0byBmb3JtIGRhdGEgb24gY3Jvc3MtZG9tYWluIHVwbG9hZHM6XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5yZWRpcmVjdCAmJiB0YXJnZXRIb3N0ICYmIHRhcmdldEhvc3QgIT09IGxvY2F0aW9uLmhvc3QpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmZvcm1EYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBvcHRpb25zLnJlZGlyZWN0UGFyYW1OYW1lIHx8ICdyZWRpcmVjdCcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLnJlZGlyZWN0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2luaXREYXRhU2V0dGluZ3M6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNYSFJVcGxvYWQob3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2NodW5rZWRVcGxvYWQob3B0aW9ucywgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXRYSFJEYXRhKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXRQcm9ncmVzc0xpc3RlbmVyKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wb3N0TWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZXR0aW5nIHRoZSBkYXRhVHlwZSB0byBwb3N0bWVzc2FnZSBlbmFibGVzIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBwb3N0TWVzc2FnZSB0cmFuc3BvcnQ6XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YVR5cGUgPSAncG9zdG1lc3NhZ2UgJyArIChvcHRpb25zLmRhdGFUeXBlIHx8ICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRJZnJhbWVTZXR0aW5ncyhvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0UGFyYW1OYW1lOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIGZpbGVJbnB1dCA9ICQob3B0aW9ucy5maWxlSW5wdXQpLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZSA9IG9wdGlvbnMucGFyYW1OYW1lO1xuICAgICAgICAgICAgaWYgKCFwYXJhbU5hbWUpIHtcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWUgPSBbXTtcbiAgICAgICAgICAgICAgICBmaWxlSW5wdXQuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9ICQodGhpcyksXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gaW5wdXQucHJvcCgnbmFtZScpIHx8ICdmaWxlc1tdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAoaW5wdXQucHJvcCgnZmlsZXMnKSB8fCBbMV0pLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtTmFtZS5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJhbU5hbWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtTmFtZSA9IFtmaWxlSW5wdXQucHJvcCgnbmFtZScpIHx8ICdmaWxlc1tdJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghJC5pc0FycmF5KHBhcmFtTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWUgPSBbcGFyYW1OYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJhbU5hbWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2luaXRGb3JtU2V0dGluZ3M6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICAvLyBSZXRyaWV2ZSBtaXNzaW5nIG9wdGlvbnMgZnJvbSB0aGUgaW5wdXQgZmllbGQgYW5kIHRoZVxuICAgICAgICAgICAgLy8gYXNzb2NpYXRlZCBmb3JtLCBpZiBhdmFpbGFibGU6XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuZm9ybSB8fCAhb3B0aW9ucy5mb3JtLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZm9ybSA9ICQob3B0aW9ucy5maWxlSW5wdXQucHJvcCgnZm9ybScpKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZ2l2ZW4gZmlsZSBpbnB1dCBkb2Vzbid0IGhhdmUgYW4gYXNzb2NpYXRlZCBmb3JtLFxuICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgZGVmYXVsdCB3aWRnZXQgZmlsZSBpbnB1dCdzIGZvcm06XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmZvcm0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZm9ybSA9ICQodGhpcy5vcHRpb25zLmZpbGVJbnB1dC5wcm9wKCdmb3JtJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMucGFyYW1OYW1lID0gdGhpcy5fZ2V0UGFyYW1OYW1lKG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnVybCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudXJsID0gb3B0aW9ucy5mb3JtLnByb3AoJ2FjdGlvbicpIHx8IGxvY2F0aW9uLmhyZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgSFRUUCByZXF1ZXN0IG1ldGhvZCBtdXN0IGJlIFwiUE9TVFwiIG9yIFwiUFVUXCI6XG4gICAgICAgICAgICBvcHRpb25zLnR5cGUgPSAob3B0aW9ucy50eXBlIHx8XG4gICAgICAgICAgICAgICAgKCQudHlwZShvcHRpb25zLmZvcm0ucHJvcCgnbWV0aG9kJykpID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmZvcm0ucHJvcCgnbWV0aG9kJykpIHx8ICcnXG4gICAgICAgICAgICAgICAgKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMudHlwZSAhPT0gJ1BPU1QnICYmIG9wdGlvbnMudHlwZSAhPT0gJ1BVVCcgJiZcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy50eXBlICE9PSAnUEFUQ0gnKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy50eXBlID0gJ1BPU1QnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmZvcm1BY2NlcHRDaGFyc2V0KSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5mb3JtQWNjZXB0Q2hhcnNldCA9IG9wdGlvbnMuZm9ybS5hdHRyKCdhY2NlcHQtY2hhcnNldCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRBSkFYU2V0dGluZ3M6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIGRhdGEpO1xuICAgICAgICAgICAgdGhpcy5faW5pdEZvcm1TZXR0aW5ncyhvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuX2luaXREYXRhU2V0dGluZ3Mob3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBqUXVlcnkgMS42IGRvZXNuJ3QgcHJvdmlkZSAuc3RhdGUoKSxcbiAgICAgICAgLy8gd2hpbGUgalF1ZXJ5IDEuOCsgcmVtb3ZlZCAuaXNSZWplY3RlZCgpIGFuZCAuaXNSZXNvbHZlZCgpOlxuICAgICAgICBfZ2V0RGVmZXJyZWRTdGF0ZTogZnVuY3Rpb24gKGRlZmVycmVkKSB7XG4gICAgICAgICAgICBpZiAoZGVmZXJyZWQuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQuc3RhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWZlcnJlZC5pc1Jlc29sdmVkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3Jlc29sdmVkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWZlcnJlZC5pc1JlamVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3JlamVjdGVkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAncGVuZGluZyc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gTWFwcyBqcVhIUiBjYWxsYmFja3MgdG8gdGhlIGVxdWl2YWxlbnRcbiAgICAgICAgLy8gbWV0aG9kcyBvZiB0aGUgZ2l2ZW4gUHJvbWlzZSBvYmplY3Q6XG4gICAgICAgIF9lbmhhbmNlUHJvbWlzZTogZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgICAgIHByb21pc2Uuc3VjY2VzcyA9IHByb21pc2UuZG9uZTtcbiAgICAgICAgICAgIHByb21pc2UuZXJyb3IgPSBwcm9taXNlLmZhaWw7XG4gICAgICAgICAgICBwcm9taXNlLmNvbXBsZXRlID0gcHJvbWlzZS5hbHdheXM7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBDcmVhdGVzIGFuZCByZXR1cm5zIGEgUHJvbWlzZSBvYmplY3QgZW5oYW5jZWQgd2l0aFxuICAgICAgICAvLyB0aGUganFYSFIgbWV0aG9kcyBhYm9ydCwgc3VjY2VzcywgZXJyb3IgYW5kIGNvbXBsZXRlOlxuICAgICAgICBfZ2V0WEhSUHJvbWlzZTogZnVuY3Rpb24gKHJlc29sdmVPclJlamVjdCwgY29udGV4dCwgYXJncykge1xuICAgICAgICAgICAgdmFyIGRmZCA9ICQuRGVmZXJyZWQoKSxcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gZGZkLnByb21pc2UoKTtcbiAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IHRoaXMub3B0aW9ucy5jb250ZXh0IHx8IHByb21pc2U7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZU9yUmVqZWN0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgZGZkLnJlc29sdmVXaXRoKGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXNvbHZlT3JSZWplY3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgZGZkLnJlamVjdFdpdGgoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9taXNlLmFib3J0ID0gZGZkLnByb21pc2U7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZW5oYW5jZVByb21pc2UocHJvbWlzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQWRkcyBjb252ZW5pZW5jZSBtZXRob2RzIHRvIHRoZSBkYXRhIGNhbGxiYWNrIGFyZ3VtZW50OlxuICAgICAgICBfYWRkQ29udmVuaWVuY2VNZXRob2RzOiBmdW5jdGlvbiAoZSwgZGF0YSkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGdldFByb21pc2UgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJC5EZWZlcnJlZCgpLnJlc29sdmVXaXRoKHRoYXQsIGFyZ3MpLnByb21pc2UoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGF0YS5wcm9jZXNzID0gZnVuY3Rpb24gKHJlc29sdmVGdW5jLCByZWplY3RGdW5jKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc29sdmVGdW5jIHx8IHJlamVjdEZ1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5fcHJvY2Vzc1F1ZXVlID0gdGhpcy5fcHJvY2Vzc1F1ZXVlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLl9wcm9jZXNzUXVldWUgfHwgZ2V0UHJvbWlzZShbdGhpc10pKS5waXBlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkLkRlZmVycmVkKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVqZWN0V2l0aCh0aGF0LCBbZGF0YV0pLnByb21pc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UHJvbWlzZShhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICkucGlwZShyZXNvbHZlRnVuYywgcmVqZWN0RnVuYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9jZXNzUXVldWUgfHwgZ2V0UHJvbWlzZShbdGhpc10pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRhdGEuc3VibWl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlKCkgIT09ICdwZW5kaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmpxWEhSID0gdGhpcy5qcVhIUiA9XG4gICAgICAgICAgICAgICAgICAgICAgICAodGhhdC5fdHJpZ2dlcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3VibWl0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLkV2ZW50KCdzdWJtaXQnLCB7ZGVsZWdhdGVkRXZlbnQ6IGV9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICApICE9PSBmYWxzZSkgJiYgdGhhdC5fb25TZW5kKGUsIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5qcVhIUiB8fCB0aGF0Ll9nZXRYSFJQcm9taXNlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGF0YS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5qcVhIUikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5qcVhIUi5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yVGhyb3duID0gJ2Fib3J0JztcbiAgICAgICAgICAgICAgICB0aGF0Ll90cmlnZ2VyKCdmYWlsJywgbnVsbCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuX2dldFhIUlByb21pc2UoZmFsc2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRhdGEuc3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuanFYSFIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuX2dldERlZmVycmVkU3RhdGUodGhpcy5qcVhIUik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wcm9jZXNzUXVldWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuX2dldERlZmVycmVkU3RhdGUodGhpcy5fcHJvY2Vzc1F1ZXVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGF0YS5wcm9jZXNzaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhdGhpcy5qcVhIUiAmJiB0aGlzLl9wcm9jZXNzUXVldWUgJiYgdGhhdFxuICAgICAgICAgICAgICAgICAgICAuX2dldERlZmVycmVkU3RhdGUodGhpcy5fcHJvY2Vzc1F1ZXVlKSA9PT0gJ3BlbmRpbmcnO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRhdGEucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2dyZXNzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRhdGEucmVzcG9uc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc3BvbnNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBQYXJzZXMgdGhlIFJhbmdlIGhlYWRlciBmcm9tIHRoZSBzZXJ2ZXIgcmVzcG9uc2VcbiAgICAgICAgLy8gYW5kIHJldHVybnMgdGhlIHVwbG9hZGVkIGJ5dGVzOlxuICAgICAgICBfZ2V0VXBsb2FkZWRCeXRlczogZnVuY3Rpb24gKGpxWEhSKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlcignUmFuZ2UnKSxcbiAgICAgICAgICAgICAgICBwYXJ0cyA9IHJhbmdlICYmIHJhbmdlLnNwbGl0KCctJyksXG4gICAgICAgICAgICAgICAgdXBwZXJCeXRlc1BvcyA9IHBhcnRzICYmIHBhcnRzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQocGFydHNbMV0sIDEwKTtcbiAgICAgICAgICAgIHJldHVybiB1cHBlckJ5dGVzUG9zICYmIHVwcGVyQnl0ZXNQb3MgKyAxO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFVwbG9hZHMgYSBmaWxlIGluIG11bHRpcGxlLCBzZXF1ZW50aWFsIHJlcXVlc3RzXG4gICAgICAgIC8vIGJ5IHNwbGl0dGluZyB0aGUgZmlsZSB1cCBpbiBtdWx0aXBsZSBibG9iIGNodW5rcy5cbiAgICAgICAgLy8gSWYgdGhlIHNlY29uZCBwYXJhbWV0ZXIgaXMgdHJ1ZSwgb25seSB0ZXN0cyBpZiB0aGUgZmlsZVxuICAgICAgICAvLyBzaG91bGQgYmUgdXBsb2FkZWQgaW4gY2h1bmtzLCBidXQgZG9lcyBub3QgaW52b2tlIGFueVxuICAgICAgICAvLyB1cGxvYWQgcmVxdWVzdHM6XG4gICAgICAgIF9jaHVua2VkVXBsb2FkOiBmdW5jdGlvbiAob3B0aW9ucywgdGVzdE9ubHkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMudXBsb2FkZWRCeXRlcyA9IG9wdGlvbnMudXBsb2FkZWRCeXRlcyB8fCAwO1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGZpbGUgPSBvcHRpb25zLmZpbGVzWzBdLFxuICAgICAgICAgICAgICAgIGZzID0gZmlsZS5zaXplLFxuICAgICAgICAgICAgICAgIHViID0gb3B0aW9ucy51cGxvYWRlZEJ5dGVzLFxuICAgICAgICAgICAgICAgIG1jcyA9IG9wdGlvbnMubWF4Q2h1bmtTaXplIHx8IGZzLFxuICAgICAgICAgICAgICAgIHNsaWNlID0gdGhpcy5fYmxvYlNsaWNlLFxuICAgICAgICAgICAgICAgIGRmZCA9ICQuRGVmZXJyZWQoKSxcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gZGZkLnByb21pc2UoKSxcbiAgICAgICAgICAgICAgICBqcVhIUixcbiAgICAgICAgICAgICAgICB1cGxvYWQ7XG4gICAgICAgICAgICBpZiAoISh0aGlzLl9pc1hIUlVwbG9hZChvcHRpb25zKSAmJiBzbGljZSAmJiAodWIgfHwgbWNzIDwgZnMpKSB8fFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGVzdE9ubHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1YiA+PSBmcykge1xuICAgICAgICAgICAgICAgIGZpbGUuZXJyb3IgPSBvcHRpb25zLmkxOG4oJ3VwbG9hZGVkQnl0ZXMnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0WEhSUHJvbWlzZShcbiAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgW251bGwsICdlcnJvcicsIGZpbGUuZXJyb3JdXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSBjaHVuayB1cGxvYWQgbWV0aG9kOlxuICAgICAgICAgICAgdXBsb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIENsb25lIHRoZSBvcHRpb25zIG9iamVjdCBmb3IgZWFjaCBjaHVuayB1cGxvYWQ6XG4gICAgICAgICAgICAgICAgdmFyIG8gPSAkLmV4dGVuZCh7fSwgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMb2FkZWQgPSBvLl9wcm9ncmVzcy5sb2FkZWQ7XG4gICAgICAgICAgICAgICAgby5ibG9iID0gc2xpY2UuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgZmlsZSxcbiAgICAgICAgICAgICAgICAgICAgdWIsXG4gICAgICAgICAgICAgICAgICAgIHViICsgbWNzLFxuICAgICAgICAgICAgICAgICAgICBmaWxlLnR5cGVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBjdXJyZW50IGNodW5rIHNpemUsIGFzIHRoZSBibG9iIGl0c2VsZlxuICAgICAgICAgICAgICAgIC8vIHdpbGwgYmUgZGVyZWZlcmVuY2VkIGFmdGVyIGRhdGEgcHJvY2Vzc2luZzpcbiAgICAgICAgICAgICAgICBvLmNodW5rU2l6ZSA9IG8uYmxvYi5zaXplO1xuICAgICAgICAgICAgICAgIC8vIEV4cG9zZSB0aGUgY2h1bmsgYnl0ZXMgcG9zaXRpb24gcmFuZ2U6XG4gICAgICAgICAgICAgICAgby5jb250ZW50UmFuZ2UgPSAnYnl0ZXMgJyArIHViICsgJy0nICtcbiAgICAgICAgICAgICAgICAgICAgKHViICsgby5jaHVua1NpemUgLSAxKSArICcvJyArIGZzO1xuICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIHVwbG9hZCBkYXRhICh0aGUgYmxvYiBhbmQgcG90ZW50aWFsIGZvcm0gZGF0YSk6XG4gICAgICAgICAgICAgICAgdGhhdC5faW5pdFhIUkRhdGEobyk7XG4gICAgICAgICAgICAgICAgLy8gQWRkIHByb2dyZXNzIGxpc3RlbmVycyBmb3IgdGhpcyBjaHVuayB1cGxvYWQ6XG4gICAgICAgICAgICAgICAgdGhhdC5faW5pdFByb2dyZXNzTGlzdGVuZXIobyk7XG4gICAgICAgICAgICAgICAganFYSFIgPSAoKHRoYXQuX3RyaWdnZXIoJ2NodW5rc2VuZCcsIG51bGwsIG8pICE9PSBmYWxzZSAmJiAkLmFqYXgobykpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll9nZXRYSFJQcm9taXNlKGZhbHNlLCBvLmNvbnRleHQpKVxuICAgICAgICAgICAgICAgICAgICAuZG9uZShmdW5jdGlvbiAocmVzdWx0LCB0ZXh0U3RhdHVzLCBqcVhIUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdWIgPSB0aGF0Ll9nZXRVcGxvYWRlZEJ5dGVzKGpxWEhSKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh1YiArIG8uY2h1bmtTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIHByb2dyZXNzIGV2ZW50IGlmIG5vIGZpbmFsIHByb2dyZXNzIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aXRoIGxvYWRlZCBlcXVhbGluZyB0b3RhbCBoYXMgYmVlbiB0cmlnZ2VyZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciB0aGlzIGNodW5rOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRMb2FkZWQgKyBvLmNodW5rU2l6ZSAtIG8uX3Byb2dyZXNzLmxvYWRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX29uUHJvZ3Jlc3MoJC5FdmVudCgncHJvZ3Jlc3MnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aENvbXB1dGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRlZDogdWIgLSBvLnVwbG9hZGVkQnl0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsOiB1YiAtIG8udXBsb2FkZWRCeXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudXBsb2FkZWRCeXRlcyA9IG8udXBsb2FkZWRCeXRlcyA9IHViO1xuICAgICAgICAgICAgICAgICAgICAgICAgby5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBvLnRleHRTdGF0dXMgPSB0ZXh0U3RhdHVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgby5qcVhIUiA9IGpxWEhSO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fdHJpZ2dlcignY2h1bmtkb25lJywgbnVsbCwgbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll90cmlnZ2VyKCdjaHVua2Fsd2F5cycsIG51bGwsIG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHViIDwgZnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaWxlIHVwbG9hZCBub3QgeWV0IGNvbXBsZXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlIHdpdGggdGhlIG5leHQgY2h1bms6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBsb2FkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRmZC5yZXNvbHZlV2l0aChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgby5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbcmVzdWx0LCB0ZXh0U3RhdHVzLCBqcVhIUl1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuZmFpbChmdW5jdGlvbiAoanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvLmpxWEhSID0ganFYSFI7XG4gICAgICAgICAgICAgICAgICAgICAgICBvLnRleHRTdGF0dXMgPSB0ZXh0U3RhdHVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgby5lcnJvclRocm93biA9IGVycm9yVGhyb3duO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fdHJpZ2dlcignY2h1bmtmYWlsJywgbnVsbCwgbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll90cmlnZ2VyKCdjaHVua2Fsd2F5cycsIG51bGwsIG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGZkLnJlamVjdFdpdGgoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgby5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtqcVhIUiwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd25dXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9lbmhhbmNlUHJvbWlzZShwcm9taXNlKTtcbiAgICAgICAgICAgIHByb21pc2UuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpxWEhSLmFib3J0KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdXBsb2FkKCk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBfYmVmb3JlU2VuZDogZnVuY3Rpb24gKGUsIGRhdGEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hY3RpdmUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgc3RhcnQgY2FsbGJhY2sgaXMgdHJpZ2dlcmVkIHdoZW4gYW4gdXBsb2FkIHN0YXJ0c1xuICAgICAgICAgICAgICAgIC8vIGFuZCBubyBvdGhlciB1cGxvYWRzIGFyZSBjdXJyZW50bHkgcnVubmluZyxcbiAgICAgICAgICAgICAgICAvLyBlcXVpdmFsZW50IHRvIHRoZSBnbG9iYWwgYWpheFN0YXJ0IGV2ZW50OlxuICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXIoJ3N0YXJ0Jyk7XG4gICAgICAgICAgICAgICAgLy8gU2V0IHRpbWVyIGZvciBnbG9iYWwgYml0cmF0ZSBwcm9ncmVzcyBjYWxjdWxhdGlvbjpcbiAgICAgICAgICAgICAgICB0aGlzLl9iaXRyYXRlVGltZXIgPSBuZXcgdGhpcy5fQml0cmF0ZVRpbWVyKCk7XG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGdsb2JhbCBwcm9ncmVzcyB2YWx1ZXM6XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3MubG9hZGVkID0gdGhpcy5fcHJvZ3Jlc3MudG90YWwgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzLmJpdHJhdGUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBjb250YWluZXIgb2JqZWN0cyBmb3IgdGhlIC5yZXNwb25zZSgpIGFuZFxuICAgICAgICAgICAgLy8gLnByb2dyZXNzKCkgbWV0aG9kcyBvbiB0aGUgZGF0YSBvYmplY3QgYXJlIGF2YWlsYWJsZVxuICAgICAgICAgICAgLy8gYW5kIHJlc2V0IHRvIHRoZWlyIGluaXRpYWwgc3RhdGU6XG4gICAgICAgICAgICB0aGlzLl9pbml0UmVzcG9uc2VPYmplY3QoZGF0YSk7XG4gICAgICAgICAgICB0aGlzLl9pbml0UHJvZ3Jlc3NPYmplY3QoZGF0YSk7XG4gICAgICAgICAgICBkYXRhLl9wcm9ncmVzcy5sb2FkZWQgPSBkYXRhLmxvYWRlZCA9IGRhdGEudXBsb2FkZWRCeXRlcyB8fCAwO1xuICAgICAgICAgICAgZGF0YS5fcHJvZ3Jlc3MudG90YWwgPSBkYXRhLnRvdGFsID0gdGhpcy5fZ2V0VG90YWwoZGF0YS5maWxlcykgfHwgMTtcbiAgICAgICAgICAgIGRhdGEuX3Byb2dyZXNzLmJpdHJhdGUgPSBkYXRhLmJpdHJhdGUgPSAwO1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlICs9IDE7XG4gICAgICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBnbG9iYWwgcHJvZ3Jlc3MgdmFsdWVzOlxuICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3MubG9hZGVkICs9IGRhdGEubG9hZGVkO1xuICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3MudG90YWwgKz0gZGF0YS50b3RhbDtcbiAgICAgICAgfSxcblxuICAgICAgICBfb25Eb25lOiBmdW5jdGlvbiAocmVzdWx0LCB0ZXh0U3RhdHVzLCBqcVhIUiwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIHRvdGFsID0gb3B0aW9ucy5fcHJvZ3Jlc3MudG90YWwsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBvcHRpb25zLl9yZXNwb25zZTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLl9wcm9ncmVzcy5sb2FkZWQgPCB0b3RhbCkge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIHByb2dyZXNzIGV2ZW50IGlmIG5vIGZpbmFsIHByb2dyZXNzIGV2ZW50XG4gICAgICAgICAgICAgICAgLy8gd2l0aCBsb2FkZWQgZXF1YWxpbmcgdG90YWwgaGFzIGJlZW4gdHJpZ2dlcmVkOlxuICAgICAgICAgICAgICAgIHRoaXMuX29uUHJvZ3Jlc3MoJC5FdmVudCgncHJvZ3Jlc3MnLCB7XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aENvbXB1dGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGxvYWRlZDogdG90YWwsXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsOiB0b3RhbFxuICAgICAgICAgICAgICAgIH0pLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3BvbnNlLnJlc3VsdCA9IG9wdGlvbnMucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICAgICAgcmVzcG9uc2UudGV4dFN0YXR1cyA9IG9wdGlvbnMudGV4dFN0YXR1cyA9IHRleHRTdGF0dXM7XG4gICAgICAgICAgICByZXNwb25zZS5qcVhIUiA9IG9wdGlvbnMuanFYSFIgPSBqcVhIUjtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXIoJ2RvbmUnLCBudWxsLCBvcHRpb25zKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfb25GYWlsOiBmdW5jdGlvbiAoanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSBvcHRpb25zLl9yZXNwb25zZTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnJlY2FsY3VsYXRlUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGZhaWxlZCAoZXJyb3Igb3IgYWJvcnQpIGZpbGUgdXBsb2FkIGZyb21cbiAgICAgICAgICAgICAgICAvLyB0aGUgZ2xvYmFsIHByb2dyZXNzIGNhbGN1bGF0aW9uOlxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzLmxvYWRlZCAtPSBvcHRpb25zLl9wcm9ncmVzcy5sb2FkZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3MudG90YWwgLT0gb3B0aW9ucy5fcHJvZ3Jlc3MudG90YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNwb25zZS5qcVhIUiA9IG9wdGlvbnMuanFYSFIgPSBqcVhIUjtcbiAgICAgICAgICAgIHJlc3BvbnNlLnRleHRTdGF0dXMgPSBvcHRpb25zLnRleHRTdGF0dXMgPSB0ZXh0U3RhdHVzO1xuICAgICAgICAgICAgcmVzcG9uc2UuZXJyb3JUaHJvd24gPSBvcHRpb25zLmVycm9yVGhyb3duID0gZXJyb3JUaHJvd247XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyKCdmYWlsJywgbnVsbCwgb3B0aW9ucyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX29uQWx3YXlzOiBmdW5jdGlvbiAoanFYSFJvclJlc3VsdCwgdGV4dFN0YXR1cywganFYSFJvckVycm9yLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAvLyBqcVhIUm9yUmVzdWx0LCB0ZXh0U3RhdHVzIGFuZCBqcVhIUm9yRXJyb3IgYXJlIGFkZGVkIHRvIHRoZVxuICAgICAgICAgICAgLy8gb3B0aW9ucyBvYmplY3QgdmlhIGRvbmUgYW5kIGZhaWwgY2FsbGJhY2tzXG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyKCdhbHdheXMnLCBudWxsLCBvcHRpb25zKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfb25TZW5kOiBmdW5jdGlvbiAoZSwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFkYXRhLnN1Ym1pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZENvbnZlbmllbmNlTWV0aG9kcyhlLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICBqcVhIUixcbiAgICAgICAgICAgICAgICBhYm9ydGVkLFxuICAgICAgICAgICAgICAgIHNsb3QsXG4gICAgICAgICAgICAgICAgcGlwZSxcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gdGhhdC5fZ2V0QUpBWFNldHRpbmdzKGRhdGEpLFxuICAgICAgICAgICAgICAgIHNlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuX3NlbmRpbmcgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHRpbWVyIGZvciBiaXRyYXRlIHByb2dyZXNzIGNhbGN1bGF0aW9uOlxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLl9iaXRyYXRlVGltZXIgPSBuZXcgdGhhdC5fQml0cmF0ZVRpbWVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGpxWEhSID0ganFYSFIgfHwgKFxuICAgICAgICAgICAgICAgICAgICAgICAgKChhYm9ydGVkIHx8IHRoYXQuX3RyaWdnZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NlbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuRXZlbnQoJ3NlbmQnLCB7ZGVsZWdhdGVkRXZlbnQ6IGV9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICApID09PSBmYWxzZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX2dldFhIUlByb21pc2UoZmFsc2UsIG9wdGlvbnMuY29udGV4dCwgYWJvcnRlZCkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll9jaHVua2VkVXBsb2FkKG9wdGlvbnMpIHx8ICQuYWpheChvcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICApLmRvbmUoZnVuY3Rpb24gKHJlc3VsdCwgdGV4dFN0YXR1cywganFYSFIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX29uRG9uZShyZXN1bHQsIHRleHRTdGF0dXMsIGpxWEhSLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfSkuZmFpbChmdW5jdGlvbiAoanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll9vbkZhaWwoanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfSkuYWx3YXlzKGZ1bmN0aW9uIChqcVhIUm9yUmVzdWx0LCB0ZXh0U3RhdHVzLCBqcVhIUm9yRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX29uQWx3YXlzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpxWEhSb3JSZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcVhIUm9yRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX3NlbmRpbmcgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX2FjdGl2ZSAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubGltaXRDb25jdXJyZW50VXBsb2FkcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmxpbWl0Q29uY3VycmVudFVwbG9hZHMgPiB0aGF0Ll9zZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgdGhlIG5leHQgcXVldWVkIHVwbG9hZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IGhhcyBub3QgYmVlbiBhYm9ydGVkOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0U2xvdCA9IHRoYXQuX3Nsb3RzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG5leHRTbG90KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0Ll9nZXREZWZlcnJlZFN0YXRlKG5leHRTbG90KSA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0U2xvdC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0U2xvdCA9IHRoYXQuX3Nsb3RzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQuX2FjdGl2ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBzdG9wIGNhbGxiYWNrIGlzIHRyaWdnZXJlZCB3aGVuIGFsbCB1cGxvYWRzIGhhdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBiZWVuIGNvbXBsZXRlZCwgZXF1aXZhbGVudCB0byB0aGUgZ2xvYmFsIGFqYXhTdG9wIGV2ZW50OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX3RyaWdnZXIoJ3N0b3AnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBqcVhIUjtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fYmVmb3JlU2VuZChlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2VxdWVudGlhbFVwbG9hZHMgfHxcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMub3B0aW9ucy5saW1pdENvbmN1cnJlbnRVcGxvYWRzICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5saW1pdENvbmN1cnJlbnRVcGxvYWRzIDw9IHRoaXMuX3NlbmRpbmcpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5saW1pdENvbmN1cnJlbnRVcGxvYWRzID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBzbG90ID0gJC5EZWZlcnJlZCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zbG90cy5wdXNoKHNsb3QpO1xuICAgICAgICAgICAgICAgICAgICBwaXBlID0gc2xvdC5waXBlKHNlbmQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlcXVlbmNlID0gdGhpcy5fc2VxdWVuY2UucGlwZShzZW5kLCBzZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgcGlwZSA9IHRoaXMuX3NlcXVlbmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdGhlIHBpcGVkIFByb21pc2Ugb2JqZWN0LCBlbmhhbmNlZCB3aXRoIGFuIGFib3J0IG1ldGhvZCxcbiAgICAgICAgICAgICAgICAvLyB3aGljaCBpcyBkZWxlZ2F0ZWQgdG8gdGhlIGpxWEhSIG9iamVjdCBvZiB0aGUgY3VycmVudCB1cGxvYWQsXG4gICAgICAgICAgICAgICAgLy8gYW5kIGpxWEhSIGNhbGxiYWNrcyBtYXBwZWQgdG8gdGhlIGVxdWl2YWxlbnQgUHJvbWlzZSBtZXRob2RzOlxuICAgICAgICAgICAgICAgIHBpcGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGFib3J0ZWQgPSBbdW5kZWZpbmVkLCAnYWJvcnQnLCAnYWJvcnQnXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFqcVhIUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNsb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbG90LnJlamVjdFdpdGgob3B0aW9ucy5jb250ZXh0LCBhYm9ydGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpxWEhSLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZW5oYW5jZVByb21pc2UocGlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VuZCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9vbkFkZDogZnVuY3Rpb24gKGUsIGRhdGEpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCBkYXRhKSxcbiAgICAgICAgICAgICAgICBmaWxlcyA9IGRhdGEuZmlsZXMsXG4gICAgICAgICAgICAgICAgZmlsZXNMZW5ndGggPSBmaWxlcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbGltaXQgPSBvcHRpb25zLmxpbWl0TXVsdGlGaWxlVXBsb2FkcyxcbiAgICAgICAgICAgICAgICBsaW1pdFNpemUgPSBvcHRpb25zLmxpbWl0TXVsdGlGaWxlVXBsb2FkU2l6ZSxcbiAgICAgICAgICAgICAgICBvdmVyaGVhZCA9IG9wdGlvbnMubGltaXRNdWx0aUZpbGVVcGxvYWRTaXplT3ZlcmhlYWQsXG4gICAgICAgICAgICAgICAgYmF0Y2hTaXplID0gMCxcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWUgPSB0aGlzLl9nZXRQYXJhbU5hbWUob3B0aW9ucyksXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lU2V0LFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZVNsaWNlLFxuICAgICAgICAgICAgICAgIGZpbGVTZXQsXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgIGlmIChsaW1pdFNpemUgJiYgKCFmaWxlc0xlbmd0aCB8fCBmaWxlc1swXS5zaXplID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgbGltaXRTaXplID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEob3B0aW9ucy5zaW5nbGVGaWxlVXBsb2FkcyB8fCBsaW1pdCB8fCBsaW1pdFNpemUpIHx8XG4gICAgICAgICAgICAgICAgICAgICF0aGlzLl9pc1hIUlVwbG9hZChvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIGZpbGVTZXQgPSBbZmlsZXNdO1xuICAgICAgICAgICAgICAgIHBhcmFtTmFtZVNldCA9IFtwYXJhbU5hbWVdO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghKG9wdGlvbnMuc2luZ2xlRmlsZVVwbG9hZHMgfHwgbGltaXRTaXplKSAmJiBsaW1pdCkge1xuICAgICAgICAgICAgICAgIGZpbGVTZXQgPSBbXTtcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWVTZXQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZmlsZXNMZW5ndGg7IGkgKz0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZVNldC5wdXNoKGZpbGVzLnNsaWNlKGksIGkgKyBsaW1pdCkpO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbU5hbWVTbGljZSA9IHBhcmFtTmFtZS5zbGljZShpLCBpICsgbGltaXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmFtTmFtZVNsaWNlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lU2xpY2UgPSBwYXJhbU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lU2V0LnB1c2gocGFyYW1OYW1lU2xpY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIW9wdGlvbnMuc2luZ2xlRmlsZVVwbG9hZHMgJiYgbGltaXRTaXplKSB7XG4gICAgICAgICAgICAgICAgZmlsZVNldCA9IFtdO1xuICAgICAgICAgICAgICAgIHBhcmFtTmFtZVNldCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBmaWxlc0xlbmd0aDsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhdGNoU2l6ZSArPSBmaWxlc1tpXS5zaXplICsgb3ZlcmhlYWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICsgMSA9PT0gZmlsZXNMZW5ndGggfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGJhdGNoU2l6ZSArIGZpbGVzW2kgKyAxXS5zaXplICsgb3ZlcmhlYWQpID4gbGltaXRTaXplKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsaW1pdCAmJiBpICsgMSAtIGogPj0gbGltaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlU2V0LnB1c2goZmlsZXMuc2xpY2UoaiwgaSArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtTmFtZVNsaWNlID0gcGFyYW1OYW1lLnNsaWNlKGosIGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyYW1OYW1lU2xpY2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lU2xpY2UgPSBwYXJhbU5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbU5hbWVTZXQucHVzaChwYXJhbU5hbWVTbGljZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBqID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXRjaFNpemUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWVTZXQgPSBwYXJhbU5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhLm9yaWdpbmFsRmlsZXMgPSBmaWxlcztcbiAgICAgICAgICAgICQuZWFjaChmaWxlU2V0IHx8IGZpbGVzLCBmdW5jdGlvbiAoaW5kZXgsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3RGF0YSA9ICQuZXh0ZW5kKHt9LCBkYXRhKTtcbiAgICAgICAgICAgICAgICBuZXdEYXRhLmZpbGVzID0gZmlsZVNldCA/IGVsZW1lbnQgOiBbZWxlbWVudF07XG4gICAgICAgICAgICAgICAgbmV3RGF0YS5wYXJhbU5hbWUgPSBwYXJhbU5hbWVTZXRbaW5kZXhdO1xuICAgICAgICAgICAgICAgIHRoYXQuX2luaXRSZXNwb25zZU9iamVjdChuZXdEYXRhKTtcbiAgICAgICAgICAgICAgICB0aGF0Ll9pbml0UHJvZ3Jlc3NPYmplY3QobmV3RGF0YSk7XG4gICAgICAgICAgICAgICAgdGhhdC5fYWRkQ29udmVuaWVuY2VNZXRob2RzKGUsIG5ld0RhdGEpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoYXQuX3RyaWdnZXIoXG4gICAgICAgICAgICAgICAgICAgICdhZGQnLFxuICAgICAgICAgICAgICAgICAgICAkLkV2ZW50KCdhZGQnLCB7ZGVsZWdhdGVkRXZlbnQ6IGV9KSxcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0YVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBfcmVwbGFjZUZpbGVJbnB1dDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRDbG9uZSA9IGlucHV0LmNsb25lKHRydWUpO1xuICAgICAgICAgICAgJCgnPGZvcm0+PC9mb3JtPicpLmFwcGVuZChpbnB1dENsb25lKVswXS5yZXNldCgpO1xuICAgICAgICAgICAgLy8gRGV0YWNoaW5nIGFsbG93cyB0byBpbnNlcnQgdGhlIGZpbGVJbnB1dCBvbiBhbm90aGVyIGZvcm1cbiAgICAgICAgICAgIC8vIHdpdGhvdXQgbG9vc2luZyB0aGUgZmlsZSBpbnB1dCB2YWx1ZTpcbiAgICAgICAgICAgIGlucHV0LmFmdGVyKGlucHV0Q2xvbmUpLmRldGFjaCgpO1xuICAgICAgICAgICAgLy8gQXZvaWQgbWVtb3J5IGxlYWtzIHdpdGggdGhlIGRldGFjaGVkIGZpbGUgaW5wdXQ6XG4gICAgICAgICAgICAkLmNsZWFuRGF0YShpbnB1dC51bmJpbmQoJ3JlbW92ZScpKTtcbiAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIG9yaWdpbmFsIGZpbGUgaW5wdXQgZWxlbWVudCBpbiB0aGUgZmlsZUlucHV0XG4gICAgICAgICAgICAvLyBlbGVtZW50cyBzZXQgd2l0aCB0aGUgY2xvbmUsIHdoaWNoIGhhcyBiZWVuIGNvcGllZCBpbmNsdWRpbmdcbiAgICAgICAgICAgIC8vIGV2ZW50IGhhbmRsZXJzOlxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmZpbGVJbnB1dCA9IHRoaXMub3B0aW9ucy5maWxlSW5wdXQubWFwKGZ1bmN0aW9uIChpLCBlbCkge1xuICAgICAgICAgICAgICAgIGlmIChlbCA9PT0gaW5wdXRbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0Q2xvbmVbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHdpZGdldCBoYXMgYmVlbiBpbml0aWFsaXplZCBvbiB0aGUgZmlsZSBpbnB1dCBpdHNlbGYsXG4gICAgICAgICAgICAvLyBvdmVycmlkZSB0aGlzLmVsZW1lbnQgd2l0aCB0aGUgZmlsZSBpbnB1dCBjbG9uZTpcbiAgICAgICAgICAgIGlmIChpbnB1dFswXSA9PT0gdGhpcy5lbGVtZW50WzBdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gaW5wdXRDbG9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfaGFuZGxlRmlsZVRyZWVFbnRyeTogZnVuY3Rpb24gKGVudHJ5LCBwYXRoKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgZGZkID0gJC5EZWZlcnJlZCgpLFxuICAgICAgICAgICAgICAgIGVycm9ySGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlICYmICFlLmVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLmVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gU2luY2UgJC53aGVuIHJldHVybnMgaW1tZWRpYXRlbHkgaWYgb25lXG4gICAgICAgICAgICAgICAgICAgIC8vIERlZmVycmVkIGlzIHJlamVjdGVkLCB3ZSB1c2UgcmVzb2x2ZSBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGFsbG93cyB2YWxpZCBmaWxlcyBhbmQgaW52YWxpZCBpdGVtc1xuICAgICAgICAgICAgICAgICAgICAvLyB0byBiZSByZXR1cm5lZCB0b2dldGhlciBpbiBvbmUgc2V0OlxuICAgICAgICAgICAgICAgICAgICBkZmQucmVzb2x2ZShbZV0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGlyUmVhZGVyO1xuICAgICAgICAgICAgcGF0aCA9IHBhdGggfHwgJyc7XG4gICAgICAgICAgICBpZiAoZW50cnkuaXNGaWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5Ll9maWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIENocm9tZSBidWcgIzE0OTczNVxuICAgICAgICAgICAgICAgICAgICBlbnRyeS5fZmlsZS5yZWxhdGl2ZVBhdGggPSBwYXRoO1xuICAgICAgICAgICAgICAgICAgICBkZmQucmVzb2x2ZShlbnRyeS5fZmlsZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW50cnkuZmlsZShmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5yZWxhdGl2ZVBhdGggPSBwYXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGZkLnJlc29sdmUoZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGVycm9ySGFuZGxlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChlbnRyeS5pc0RpcmVjdG9yeSkge1xuICAgICAgICAgICAgICAgIGRpclJlYWRlciA9IGVudHJ5LmNyZWF0ZVJlYWRlcigpO1xuICAgICAgICAgICAgICAgIGRpclJlYWRlci5yZWFkRW50cmllcyhmdW5jdGlvbiAoZW50cmllcykge1xuICAgICAgICAgICAgICAgICAgICB0aGF0Ll9oYW5kbGVGaWxlVHJlZUVudHJpZXMoXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyaWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCArIGVudHJ5Lm5hbWUgKyAnLydcbiAgICAgICAgICAgICAgICAgICAgKS5kb25lKGZ1bmN0aW9uIChmaWxlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGZkLnJlc29sdmUoZmlsZXMpO1xuICAgICAgICAgICAgICAgICAgICB9KS5mYWlsKGVycm9ySGFuZGxlcik7XG4gICAgICAgICAgICAgICAgfSwgZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIGFuIGVtcHkgbGlzdCBmb3IgZmlsZSBzeXN0ZW0gaXRlbXNcbiAgICAgICAgICAgICAgICAvLyBvdGhlciB0aGFuIGZpbGVzIG9yIGRpcmVjdG9yaWVzOlxuICAgICAgICAgICAgICAgIGRmZC5yZXNvbHZlKFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZmQucHJvbWlzZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9oYW5kbGVGaWxlVHJlZUVudHJpZXM6IGZ1bmN0aW9uIChlbnRyaWVzLCBwYXRoKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gJC53aGVuLmFwcGx5KFxuICAgICAgICAgICAgICAgICQsXG4gICAgICAgICAgICAgICAgJC5tYXAoZW50cmllcywgZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0Ll9oYW5kbGVGaWxlVHJlZUVudHJ5KGVudHJ5LCBwYXRoKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKS5waXBlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgW10sXG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0RHJvcHBlZEZpbGVzOiBmdW5jdGlvbiAoZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgICAgICBkYXRhVHJhbnNmZXIgPSBkYXRhVHJhbnNmZXIgfHwge307XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSBkYXRhVHJhbnNmZXIuaXRlbXM7XG4gICAgICAgICAgICBpZiAoaXRlbXMgJiYgaXRlbXMubGVuZ3RoICYmIChpdGVtc1swXS53ZWJraXRHZXRBc0VudHJ5IHx8XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zWzBdLmdldEFzRW50cnkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUZpbGVUcmVlRW50cmllcyhcbiAgICAgICAgICAgICAgICAgICAgJC5tYXAoaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS53ZWJraXRHZXRBc0VudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkgPSBpdGVtLndlYmtpdEdldEFzRW50cnkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgQ2hyb21lIGJ1ZyAjMTQ5NzM1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5fZmlsZSA9IGl0ZW0uZ2V0QXNGaWxlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmdldEFzRW50cnkoKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICQuRGVmZXJyZWQoKS5yZXNvbHZlKFxuICAgICAgICAgICAgICAgICQubWFrZUFycmF5KGRhdGFUcmFuc2Zlci5maWxlcylcbiAgICAgICAgICAgICkucHJvbWlzZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRTaW5nbGVGaWxlSW5wdXRGaWxlczogZnVuY3Rpb24gKGZpbGVJbnB1dCkge1xuICAgICAgICAgICAgZmlsZUlucHV0ID0gJChmaWxlSW5wdXQpO1xuICAgICAgICAgICAgdmFyIGVudHJpZXMgPSBmaWxlSW5wdXQucHJvcCgnd2Via2l0RW50cmllcycpIHx8XG4gICAgICAgICAgICAgICAgICAgIGZpbGVJbnB1dC5wcm9wKCdlbnRyaWVzJyksXG4gICAgICAgICAgICAgICAgZmlsZXMsXG4gICAgICAgICAgICAgICAgdmFsdWU7XG4gICAgICAgICAgICBpZiAoZW50cmllcyAmJiBlbnRyaWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVGaWxlVHJlZUVudHJpZXMoZW50cmllcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWxlcyA9ICQubWFrZUFycmF5KGZpbGVJbnB1dC5wcm9wKCdmaWxlcycpKTtcbiAgICAgICAgICAgIGlmICghZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmaWxlSW5wdXQucHJvcCgndmFsdWUnKTtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkLkRlZmVycmVkKCkucmVzb2x2ZShbXSkucHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZmlsZXMgcHJvcGVydHkgaXMgbm90IGF2YWlsYWJsZSwgdGhlIGJyb3dzZXIgZG9lcyBub3RcbiAgICAgICAgICAgICAgICAvLyBzdXBwb3J0IHRoZSBGaWxlIEFQSSBhbmQgd2UgYWRkIGEgcHNldWRvIEZpbGUgb2JqZWN0IHdpdGhcbiAgICAgICAgICAgICAgICAvLyB0aGUgaW5wdXQgdmFsdWUgYXMgbmFtZSB3aXRoIHBhdGggaW5mb3JtYXRpb24gcmVtb3ZlZDpcbiAgICAgICAgICAgICAgICBmaWxlcyA9IFt7bmFtZTogdmFsdWUucmVwbGFjZSgvXi4qXFxcXC8sICcnKX1dO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmaWxlc1swXS5uYW1lID09PSB1bmRlZmluZWQgJiYgZmlsZXNbMF0uZmlsZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBGaWxlIG5vcm1hbGl6YXRpb24gZm9yIFNhZmFyaSA0IGFuZCBGaXJlZm94IDM6XG4gICAgICAgICAgICAgICAgJC5lYWNoKGZpbGVzLCBmdW5jdGlvbiAoaW5kZXgsIGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZS5uYW1lID0gZmlsZS5maWxlTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgZmlsZS5zaXplID0gZmlsZS5maWxlU2l6ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkLkRlZmVycmVkKCkucmVzb2x2ZShmaWxlcykucHJvbWlzZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRGaWxlSW5wdXRGaWxlczogZnVuY3Rpb24gKGZpbGVJbnB1dCkge1xuICAgICAgICAgICAgaWYgKCEoZmlsZUlucHV0IGluc3RhbmNlb2YgJCkgfHwgZmlsZUlucHV0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRTaW5nbGVGaWxlSW5wdXRGaWxlcyhmaWxlSW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICQud2hlbi5hcHBseShcbiAgICAgICAgICAgICAgICAkLFxuICAgICAgICAgICAgICAgICQubWFwKGZpbGVJbnB1dCwgdGhpcy5fZ2V0U2luZ2xlRmlsZUlucHV0RmlsZXMpXG4gICAgICAgICAgICApLnBpcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICBbXSxcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9vbkNoYW5nZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICBmaWxlSW5wdXQ6ICQoZS50YXJnZXQpLFxuICAgICAgICAgICAgICAgICAgICBmb3JtOiAkKGUudGFyZ2V0LmZvcm0pXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX2dldEZpbGVJbnB1dEZpbGVzKGRhdGEuZmlsZUlucHV0KS5hbHdheXMoZnVuY3Rpb24gKGZpbGVzKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5maWxlcyA9IGZpbGVzO1xuICAgICAgICAgICAgICAgIGlmICh0aGF0Lm9wdGlvbnMucmVwbGFjZUZpbGVJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICB0aGF0Ll9yZXBsYWNlRmlsZUlucHV0KGRhdGEuZmlsZUlucHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoYXQuX3RyaWdnZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2hhbmdlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICQuRXZlbnQoJ2NoYW5nZScsIHtkZWxlZ2F0ZWRFdmVudDogZX0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgICAgICAgICApICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGF0Ll9vbkFkZChlLCBkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfb25QYXN0ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBpdGVtcyA9IGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQuY2xpcGJvYXJkRGF0YSAmJlxuICAgICAgICAgICAgICAgICAgICBlLm9yaWdpbmFsRXZlbnQuY2xpcGJvYXJkRGF0YS5pdGVtcyxcbiAgICAgICAgICAgICAgICBkYXRhID0ge2ZpbGVzOiBbXX07XG4gICAgICAgICAgICBpZiAoaXRlbXMgJiYgaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgJC5lYWNoKGl0ZW1zLCBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGUgPSBpdGVtLmdldEFzRmlsZSAmJiBpdGVtLmdldEFzRmlsZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5maWxlcy5wdXNoKGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RyaWdnZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICAncGFzdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJC5FdmVudCgncGFzdGUnLCB7ZGVsZWdhdGVkRXZlbnQ6IGV9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25BZGQoZSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9vbkRyb3A6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLmRhdGFUcmFuc2ZlciA9IGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQuZGF0YVRyYW5zZmVyO1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGRhdGFUcmFuc2ZlciA9IGUuZGF0YVRyYW5zZmVyLFxuICAgICAgICAgICAgICAgIGRhdGEgPSB7fTtcbiAgICAgICAgICAgIGlmIChkYXRhVHJhbnNmZXIgJiYgZGF0YVRyYW5zZmVyLmZpbGVzICYmIGRhdGFUcmFuc2Zlci5maWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0RHJvcHBlZEZpbGVzKGRhdGFUcmFuc2ZlcikuYWx3YXlzKGZ1bmN0aW9uIChmaWxlcykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmZpbGVzID0gZmlsZXM7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGF0Ll90cmlnZ2VyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkcm9wJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLkV2ZW50KCdkcm9wJywge2RlbGVnYXRlZEV2ZW50OiBlfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX29uQWRkKGUsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX29uRHJhZ092ZXI6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLmRhdGFUcmFuc2ZlciA9IGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQuZGF0YVRyYW5zZmVyO1xuICAgICAgICAgICAgdmFyIGRhdGFUcmFuc2ZlciA9IGUuZGF0YVRyYW5zZmVyO1xuICAgICAgICAgICAgaWYgKGRhdGFUcmFuc2ZlciAmJiAkLmluQXJyYXkoJ0ZpbGVzJywgZGF0YVRyYW5zZmVyLnR5cGVzKSAhPT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcihcbiAgICAgICAgICAgICAgICAgICAgICAgICdkcmFnb3ZlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAkLkV2ZW50KCdkcmFnb3ZlcicsIHtkZWxlZ2F0ZWRFdmVudDogZX0pXG4gICAgICAgICAgICAgICAgICAgICkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gJ2NvcHknO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9pbml0RXZlbnRIYW5kbGVyczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzWEhSVXBsb2FkKHRoaXMub3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbih0aGlzLm9wdGlvbnMuZHJvcFpvbmUsIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ292ZXI6IHRoaXMuX29uRHJhZ092ZXIsXG4gICAgICAgICAgICAgICAgICAgIGRyb3A6IHRoaXMuX29uRHJvcFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX29uKHRoaXMub3B0aW9ucy5wYXN0ZVpvbmUsIHtcbiAgICAgICAgICAgICAgICAgICAgcGFzdGU6IHRoaXMuX29uUGFzdGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgkLnN1cHBvcnQuZmlsZUlucHV0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb24odGhpcy5vcHRpb25zLmZpbGVJbnB1dCwge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2U6IHRoaXMuX29uQ2hhbmdlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2Rlc3Ryb3lFdmVudEhhbmRsZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9vZmYodGhpcy5vcHRpb25zLmRyb3Bab25lLCAnZHJhZ292ZXIgZHJvcCcpO1xuICAgICAgICAgICAgdGhpcy5fb2ZmKHRoaXMub3B0aW9ucy5wYXN0ZVpvbmUsICdwYXN0ZScpO1xuICAgICAgICAgICAgdGhpcy5fb2ZmKHRoaXMub3B0aW9ucy5maWxlSW5wdXQsICdjaGFuZ2UnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfc2V0T3B0aW9uOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHJlaW5pdCA9ICQuaW5BcnJheShrZXksIHRoaXMuX3NwZWNpYWxPcHRpb25zKSAhPT0gLTE7XG4gICAgICAgICAgICBpZiAocmVpbml0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVzdHJveUV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3N1cGVyKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgaWYgKHJlaW5pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRTcGVjaWFsT3B0aW9ucygpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2luaXRTcGVjaWFsT3B0aW9uczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5maWxlSW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZmlsZUlucHV0ID0gdGhpcy5lbGVtZW50LmlzKCdpbnB1dFt0eXBlPVwiZmlsZVwiXScpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudCA6IHRoaXMuZWxlbWVudC5maW5kKCdpbnB1dFt0eXBlPVwiZmlsZVwiXScpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghKG9wdGlvbnMuZmlsZUlucHV0IGluc3RhbmNlb2YgJCkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmZpbGVJbnB1dCA9ICQob3B0aW9ucy5maWxlSW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEob3B0aW9ucy5kcm9wWm9uZSBpbnN0YW5jZW9mICQpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kcm9wWm9uZSA9ICQob3B0aW9ucy5kcm9wWm9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIShvcHRpb25zLnBhc3RlWm9uZSBpbnN0YW5jZW9mICQpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wYXN0ZVpvbmUgPSAkKG9wdGlvbnMucGFzdGVab25lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0UmVnRXhwOiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoJy8nKSxcbiAgICAgICAgICAgICAgICBtb2RpZmllcnMgPSBwYXJ0cy5wb3AoKTtcbiAgICAgICAgICAgIHBhcnRzLnNoaWZ0KCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXJ0cy5qb2luKCcvJyksIG1vZGlmaWVycyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2lzUmVnRXhwT3B0aW9uOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGtleSAhPT0gJ3VybCcgJiYgJC50eXBlKHZhbHVlKSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAvXlxcLy4qXFwvW2lnbV17MCwzfSQvLnRlc3QodmFsdWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9pbml0RGF0YUF0dHJpYnV0ZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgICAgIGNsb25lID0gJCh0aGlzLmVsZW1lbnRbMF0uY2xvbmVOb2RlKGZhbHNlKSk7XG4gICAgICAgICAgICAvLyBJbml0aWFsaXplIG9wdGlvbnMgc2V0IHZpYSBIVE1MNSBkYXRhLWF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAkLmVhY2goXG4gICAgICAgICAgICAgICAgY2xvbmUuZGF0YSgpLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhQXR0cmlidXRlTmFtZSA9ICdkYXRhLScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCBjYW1lbENhc2UgdG8gaHlwaGVuLWF0ZWQga2V5OlxuICAgICAgICAgICAgICAgICAgICAgICAga2V5LnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbG9uZS5hdHRyKGRhdGFBdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQuX2lzUmVnRXhwT3B0aW9uKGtleSwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGF0Ll9nZXRSZWdFeHAodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9jcmVhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2luaXREYXRhQXR0cmlidXRlcygpO1xuICAgICAgICAgICAgdGhpcy5faW5pdFNwZWNpYWxPcHRpb25zKCk7XG4gICAgICAgICAgICB0aGlzLl9zbG90cyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2VxdWVuY2UgPSB0aGlzLl9nZXRYSFJQcm9taXNlKHRydWUpO1xuICAgICAgICAgICAgdGhpcy5fc2VuZGluZyA9IHRoaXMuX2FjdGl2ZSA9IDA7XG4gICAgICAgICAgICB0aGlzLl9pbml0UHJvZ3Jlc3NPYmplY3QodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9pbml0RXZlbnRIYW5kbGVycygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIGlzIGV4cG9zZWQgdG8gdGhlIHdpZGdldCBBUEkgYW5kIGFsbG93cyB0byBxdWVyeVxuICAgICAgICAvLyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSB1cGxvYWRzOlxuICAgICAgICBhY3RpdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVGhpcyBtZXRob2QgaXMgZXhwb3NlZCB0byB0aGUgd2lkZ2V0IEFQSSBhbmQgYWxsb3dzIHRvIHF1ZXJ5XG4gICAgICAgIC8vIHRoZSB3aWRnZXQgdXBsb2FkIHByb2dyZXNzLlxuICAgICAgICAvLyBJdCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIGxvYWRlZCwgdG90YWwgYW5kIGJpdHJhdGUgcHJvcGVydGllc1xuICAgICAgICAvLyBmb3IgdGhlIHJ1bm5pbmcgdXBsb2FkczpcbiAgICAgICAgcHJvZ3Jlc3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9ncmVzcztcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBUaGlzIG1ldGhvZCBpcyBleHBvc2VkIHRvIHRoZSB3aWRnZXQgQVBJIGFuZCBhbGxvd3MgYWRkaW5nIGZpbGVzXG4gICAgICAgIC8vIHVzaW5nIHRoZSBmaWxldXBsb2FkIEFQSS4gVGhlIGRhdGEgcGFyYW1ldGVyIGFjY2VwdHMgYW4gb2JqZWN0IHdoaWNoXG4gICAgICAgIC8vIG11c3QgaGF2ZSBhIGZpbGVzIHByb3BlcnR5IGFuZCBjYW4gY29udGFpbiBhZGRpdGlvbmFsIG9wdGlvbnM6XG4gICAgICAgIC8vIC5maWxldXBsb2FkKCdhZGQnLCB7ZmlsZXM6IGZpbGVzTGlzdH0pO1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIWRhdGEgfHwgdGhpcy5vcHRpb25zLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEuZmlsZUlucHV0ICYmICFkYXRhLmZpbGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0RmlsZUlucHV0RmlsZXMoZGF0YS5maWxlSW5wdXQpLmFsd2F5cyhmdW5jdGlvbiAoZmlsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5maWxlcyA9IGZpbGVzO1xuICAgICAgICAgICAgICAgICAgICB0aGF0Ll9vbkFkZChudWxsLCBkYXRhKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YS5maWxlcyA9ICQubWFrZUFycmF5KGRhdGEuZmlsZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX29uQWRkKG51bGwsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIGlzIGV4cG9zZWQgdG8gdGhlIHdpZGdldCBBUEkgYW5kIGFsbG93cyBzZW5kaW5nIGZpbGVzXG4gICAgICAgIC8vIHVzaW5nIHRoZSBmaWxldXBsb2FkIEFQSS4gVGhlIGRhdGEgcGFyYW1ldGVyIGFjY2VwdHMgYW4gb2JqZWN0IHdoaWNoXG4gICAgICAgIC8vIG11c3QgaGF2ZSBhIGZpbGVzIG9yIGZpbGVJbnB1dCBwcm9wZXJ0eSBhbmQgY2FuIGNvbnRhaW4gYWRkaXRpb25hbCBvcHRpb25zOlxuICAgICAgICAvLyAuZmlsZXVwbG9hZCgnc2VuZCcsIHtmaWxlczogZmlsZXNMaXN0fSk7XG4gICAgICAgIC8vIFRoZSBtZXRob2QgcmV0dXJucyBhIFByb21pc2Ugb2JqZWN0IGZvciB0aGUgZmlsZSB1cGxvYWQgY2FsbC5cbiAgICAgICAgc2VuZDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChkYXRhICYmICF0aGlzLm9wdGlvbnMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5maWxlSW5wdXQgJiYgIWRhdGEuZmlsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGZkID0gJC5EZWZlcnJlZCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IGRmZC5wcm9taXNlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBqcVhIUixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqcVhIUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBqcVhIUi5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGZkLnJlamVjdChudWxsLCAnYWJvcnQnLCAnYWJvcnQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9nZXRGaWxlSW5wdXRGaWxlcyhkYXRhLmZpbGVJbnB1dCkuYWx3YXlzKFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGZpbGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZmQucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5maWxlcyA9IGZpbGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpxWEhSID0gdGhhdC5fb25TZW5kKG51bGwsIGRhdGEpLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChyZXN1bHQsIHRleHRTdGF0dXMsIGpxWEhSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZmQucmVzb2x2ZShyZXN1bHQsIHRleHRTdGF0dXMsIGpxWEhSKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGpxWEhSLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGZkLnJlamVjdChqcVhIUiwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VuaGFuY2VQcm9taXNlKHByb21pc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhLmZpbGVzID0gJC5tYWtlQXJyYXkoZGF0YS5maWxlcyk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vblNlbmQobnVsbCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFhIUlByb21pc2UoZmFsc2UsIGRhdGEgJiYgZGF0YS5jb250ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbn0pKTtcbiIsIi8qXG4gKiBqUXVlcnkgSWZyYW1lIFRyYW5zcG9ydCBQbHVnaW4gMS44LjJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ibHVlaW1wL2pRdWVyeS1GaWxlLVVwbG9hZFxuICpcbiAqIENvcHlyaWdodCAyMDExLCBTZWJhc3RpYW4gVHNjaGFuXG4gKiBodHRwczovL2JsdWVpbXAubmV0XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuXG4vKiBnbG9iYWwgZGVmaW5lLCB3aW5kb3csIGRvY3VtZW50ICovXG5cbihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBBTUQgbW9kdWxlOlxuICAgICAgICBkZWZpbmUoWydqcXVlcnknXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzOlxuICAgICAgICBmYWN0b3J5KHdpbmRvdy5qUXVlcnkpO1xuICAgIH1cbn0oZnVuY3Rpb24gKCQpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvLyBIZWxwZXIgdmFyaWFibGUgdG8gY3JlYXRlIHVuaXF1ZSBuYW1lcyBmb3IgdGhlIHRyYW5zcG9ydCBpZnJhbWVzOlxuICAgIHZhciBjb3VudGVyID0gMDtcblxuICAgIC8vIFRoZSBpZnJhbWUgdHJhbnNwb3J0IGFjY2VwdHMgZm91ciBhZGRpdGlvbmFsIG9wdGlvbnM6XG4gICAgLy8gb3B0aW9ucy5maWxlSW5wdXQ6IGEgalF1ZXJ5IGNvbGxlY3Rpb24gb2YgZmlsZSBpbnB1dCBmaWVsZHNcbiAgICAvLyBvcHRpb25zLnBhcmFtTmFtZTogdGhlIHBhcmFtZXRlciBuYW1lIGZvciB0aGUgZmlsZSBmb3JtIGRhdGEsXG4gICAgLy8gIG92ZXJyaWRlcyB0aGUgbmFtZSBwcm9wZXJ0eSBvZiB0aGUgZmlsZSBpbnB1dCBmaWVsZChzKSxcbiAgICAvLyAgY2FuIGJlIGEgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MuXG4gICAgLy8gb3B0aW9ucy5mb3JtRGF0YTogYW4gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIG5hbWUgYW5kIHZhbHVlIHByb3BlcnRpZXMsXG4gICAgLy8gIGVxdWl2YWxlbnQgdG8gdGhlIHJldHVybiBkYXRhIG9mIC5zZXJpYWxpemVBcnJheSgpLCBlLmcuOlxuICAgIC8vICBbe25hbWU6ICdhJywgdmFsdWU6IDF9LCB7bmFtZTogJ2InLCB2YWx1ZTogMn1dXG4gICAgLy8gb3B0aW9ucy5pbml0aWFsSWZyYW1lU3JjOiB0aGUgVVJMIG9mIHRoZSBpbml0aWFsIGlmcmFtZSBzcmMsXG4gICAgLy8gIGJ5IGRlZmF1bHQgc2V0IHRvIFwiamF2YXNjcmlwdDpmYWxzZTtcIlxuICAgICQuYWpheFRyYW5zcG9ydCgnaWZyYW1lJywgZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYXN5bmMpIHtcbiAgICAgICAgICAgIC8vIGphdmFzY3JpcHQ6ZmFsc2UgYXMgaW5pdGlhbCBpZnJhbWUgc3JjXG4gICAgICAgICAgICAvLyBwcmV2ZW50cyB3YXJuaW5nIHBvcHVwcyBvbiBIVFRQUyBpbiBJRTY6XG4gICAgICAgICAgICAvKmpzaGludCBzY3JpcHR1cmw6IHRydWUgKi9cbiAgICAgICAgICAgIHZhciBpbml0aWFsSWZyYW1lU3JjID0gb3B0aW9ucy5pbml0aWFsSWZyYW1lU3JjIHx8ICdqYXZhc2NyaXB0OmZhbHNlOycsXG4gICAgICAgICAgICAvKmpzaGludCBzY3JpcHR1cmw6IGZhbHNlICovXG4gICAgICAgICAgICAgICAgZm9ybSxcbiAgICAgICAgICAgICAgICBpZnJhbWUsXG4gICAgICAgICAgICAgICAgYWRkUGFyYW1DaGFyO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzZW5kOiBmdW5jdGlvbiAoXywgY29tcGxldGVDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBmb3JtID0gJCgnPGZvcm0gc3R5bGU9XCJkaXNwbGF5Om5vbmU7XCI+PC9mb3JtPicpO1xuICAgICAgICAgICAgICAgICAgICBmb3JtLmF0dHIoJ2FjY2VwdC1jaGFyc2V0Jywgb3B0aW9ucy5mb3JtQWNjZXB0Q2hhcnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZFBhcmFtQ2hhciA9IC9cXD8vLnRlc3Qob3B0aW9ucy51cmwpID8gJyYnIDogJz8nO1xuICAgICAgICAgICAgICAgICAgICAvLyBYRG9tYWluUmVxdWVzdCBvbmx5IHN1cHBvcnRzIEdFVCBhbmQgUE9TVDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ0RFTEVURScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudXJsID0gb3B0aW9ucy51cmwgKyBhZGRQYXJhbUNoYXIgKyAnX21ldGhvZD1ERUxFVEUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy50eXBlID0gJ1BPU1QnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ1BVVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudXJsID0gb3B0aW9ucy51cmwgKyBhZGRQYXJhbUNoYXIgKyAnX21ldGhvZD1QVVQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy50eXBlID0gJ1BPU1QnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ1BBVENIJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy51cmwgPSBvcHRpb25zLnVybCArIGFkZFBhcmFtQ2hhciArICdfbWV0aG9kPVBBVENIJztcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudHlwZSA9ICdQT1NUJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJRSB2ZXJzaW9ucyBiZWxvdyBJRTggY2Fubm90IHNldCB0aGUgbmFtZSBwcm9wZXJ0eSBvZlxuICAgICAgICAgICAgICAgICAgICAvLyBlbGVtZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGFkZGVkIHRvIHRoZSBET00sXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIHdlIHNldCB0aGUgbmFtZSBhbG9uZyB3aXRoIHRoZSBpZnJhbWUgSFRNTCBtYXJrdXA6XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXIgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWZyYW1lID0gJChcbiAgICAgICAgICAgICAgICAgICAgICAgICc8aWZyYW1lIHNyYz1cIicgKyBpbml0aWFsSWZyYW1lU3JjICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXCIgbmFtZT1cImlmcmFtZS10cmFuc3BvcnQtJyArIGNvdW50ZXIgKyAnXCI+PC9pZnJhbWU+J1xuICAgICAgICAgICAgICAgICAgICApLmJpbmQoJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZUlucHV0Q2xvbmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtTmFtZXMgPSAkLmlzQXJyYXkob3B0aW9ucy5wYXJhbU5hbWUpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGFyYW1OYW1lIDogW29wdGlvbnMucGFyYW1OYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmcmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC51bmJpbmQoJ2xvYWQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5iaW5kKCdsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdyYXAgaW4gYSB0cnkvY2F0Y2ggYmxvY2sgdG8gY2F0Y2ggZXhjZXB0aW9ucyB0aHJvd25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB0cnlpbmcgdG8gYWNjZXNzIGNyb3NzLWRvbWFpbiBpZnJhbWUgY29udGVudHM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGlmcmFtZS5jb250ZW50cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR29vZ2xlIENocm9tZSBhbmQgRmlyZWZveCBkbyBub3QgdGhyb3cgYW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4Y2VwdGlvbiB3aGVuIGNhbGxpbmcgaWZyYW1lLmNvbnRlbnRzKCkgb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc28gd2UgdW5pZnkgdGhlIHJlc3BvbnNlOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5sZW5ndGggfHwgIXJlc3BvbnNlWzBdLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGNvbXBsZXRlIGNhbGxiYWNrIHJldHVybnMgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmcmFtZSBjb250ZW50IGRvY3VtZW50IGFzIHJlc3BvbnNlIG9iamVjdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVDYWxsYmFjayhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzdWNjZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsnaWZyYW1lJzogcmVzcG9uc2V9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpeCBmb3IgSUUgZW5kbGVzcyBwcm9ncmVzcyBiYXIgYWN0aXZpdHkgYnVnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIChoYXBwZW5zIG9uIGZvcm0gc3VibWl0cyB0byBpZnJhbWUgdGFyZ2V0cyk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJzxpZnJhbWUgc3JjPVwiJyArIGluaXRpYWxJZnJhbWVTcmMgKyAnXCI+PC9pZnJhbWU+JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbyhmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZpbmcgdGhlIGZvcm0gaW4gYSBzZXRUaW1lb3V0IGNhbGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbG93cyBDaHJvbWUncyBkZXZlbG9wZXIgdG9vbHMgdG8gZGlzcGxheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHJlc3BvbnNlIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnByb3AoJ3RhcmdldCcsIGlmcmFtZS5wcm9wKCduYW1lJykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnByb3AoJ2FjdGlvbicsIG9wdGlvbnMudXJsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wcm9wKCdtZXRob2QnLCBvcHRpb25zLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZm9ybURhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmVhY2gob3B0aW9ucy5mb3JtRGF0YSwgZnVuY3Rpb24gKGluZGV4LCBmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCc8aW5wdXQgdHlwZT1cImhpZGRlblwiLz4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnByb3AoJ25hbWUnLCBmaWVsZC5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnZhbChmaWVsZC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbyhmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmZpbGVJbnB1dCAmJiBvcHRpb25zLmZpbGVJbnB1dC5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy50eXBlID09PSAnUE9TVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlSW5wdXRDbG9uZXMgPSBvcHRpb25zLmZpbGVJbnB1dC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluc2VydCBhIGNsb25lIGZvciBlYWNoIGZpbGUgaW5wdXQgZmllbGQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5maWxlSW5wdXQuYWZ0ZXIoZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWxlSW5wdXRDbG9uZXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnBhcmFtTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmZpbGVJbnB1dC5lYWNoKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5wcm9wKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbU5hbWVzW2luZGV4XSB8fCBvcHRpb25zLnBhcmFtTmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZGluZyB0aGUgZmlsZSBpbnB1dCBmaWVsZHMgdG8gdGhlIGhpZGRlbiBmb3JtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlcyB0aGVtIGZyb20gdGhlaXIgb3JpZ2luYWwgbG9jYXRpb246XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKG9wdGlvbnMuZmlsZUlucHV0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucHJvcCgnZW5jdHlwZScsICdtdWx0aXBhcnQvZm9ybS1kYXRhJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5jdHlwZSBtdXN0IGJlIHNldCBhcyBlbmNvZGluZyBmb3IgSUU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wcm9wKCdlbmNvZGluZycsICdtdWx0aXBhcnQvZm9ybS1kYXRhJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBIVE1MNSBmb3JtIGF0dHJpYnV0ZSBmcm9tIHRoZSBpbnB1dChzKTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmZpbGVJbnB1dC5yZW1vdmVBdHRyKCdmb3JtJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtLnN1Ym1pdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSBmaWxlIGlucHV0IGZpZWxkcyBhdCB0aGVpciBvcmlnaW5hbCBsb2NhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnkgcmVwbGFjaW5nIHRoZSBjbG9uZXMgd2l0aCB0aGUgb3JpZ2luYWxzOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVJbnB1dENsb25lcyAmJiBmaWxlSW5wdXRDbG9uZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5maWxlSW5wdXQuZWFjaChmdW5jdGlvbiAoaW5kZXgsIGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbG9uZSA9ICQoZmlsZUlucHV0Q2xvbmVzW2luZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIG5hbWUgYW5kIGZvcm0gcHJvcGVydGllczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChpbnB1dClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wcm9wKCduYW1lJywgY2xvbmUucHJvcCgnbmFtZScpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2Zvcm0nLCBjbG9uZS5hdHRyKCdmb3JtJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZS5yZXBsYWNlV2l0aChpbnB1dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBmb3JtLmFwcGVuZChpZnJhbWUpLmFwcGVuZFRvKGRvY3VtZW50LmJvZHkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlmcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gamF2YXNjcmlwdDpmYWxzZSBhcyBpZnJhbWUgc3JjIGFib3J0cyB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHByZXZlbnRzIHdhcm5pbmcgcG9wdXBzIG9uIEhUVFBTIGluIElFNi5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbmNhdCBpcyB1c2VkIHRvIGF2b2lkIHRoZSBcIlNjcmlwdCBVUkxcIiBKU0xpbnQgZXJyb3I6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZnJhbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudW5iaW5kKCdsb2FkJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucHJvcCgnc3JjJywgaW5pdGlhbElmcmFtZVNyYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBUaGUgaWZyYW1lIHRyYW5zcG9ydCByZXR1cm5zIHRoZSBpZnJhbWUgY29udGVudCBkb2N1bWVudCBhcyByZXNwb25zZS5cbiAgICAvLyBUaGUgZm9sbG93aW5nIGFkZHMgY29udmVydGVycyBmcm9tIGlmcmFtZSB0byB0ZXh0LCBqc29uLCBodG1sLCB4bWxcbiAgICAvLyBhbmQgc2NyaXB0LlxuICAgIC8vIFBsZWFzZSBub3RlIHRoYXQgdGhlIENvbnRlbnQtVHlwZSBmb3IgSlNPTiByZXNwb25zZXMgaGFzIHRvIGJlIHRleHQvcGxhaW5cbiAgICAvLyBvciB0ZXh0L2h0bWwsIGlmIHRoZSBicm93c2VyIGRvZXNuJ3QgaW5jbHVkZSBhcHBsaWNhdGlvbi9qc29uIGluIHRoZVxuICAgIC8vIEFjY2VwdCBoZWFkZXIsIGVsc2UgSUUgd2lsbCBzaG93IGEgZG93bmxvYWQgZGlhbG9nLlxuICAgIC8vIFRoZSBDb250ZW50LVR5cGUgZm9yIFhNTCByZXNwb25zZXMgb24gdGhlIG90aGVyIGhhbmQgaGFzIHRvIGJlIGFsd2F5c1xuICAgIC8vIGFwcGxpY2F0aW9uL3htbCBvciB0ZXh0L3htbCwgc28gSUUgcHJvcGVybHkgcGFyc2VzIHRoZSBYTUwgcmVzcG9uc2UuXG4gICAgLy8gU2VlIGFsc29cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYmx1ZWltcC9qUXVlcnktRmlsZS1VcGxvYWQvd2lraS9TZXR1cCNjb250ZW50LXR5cGUtbmVnb3RpYXRpb25cbiAgICAkLmFqYXhTZXR1cCh7XG4gICAgICAgIGNvbnZlcnRlcnM6IHtcbiAgICAgICAgICAgICdpZnJhbWUgdGV4dCc6IGZ1bmN0aW9uIChpZnJhbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWZyYW1lICYmICQoaWZyYW1lWzBdLmJvZHkpLnRleHQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnaWZyYW1lIGpzb24nOiBmdW5jdGlvbiAoaWZyYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlmcmFtZSAmJiAkLnBhcnNlSlNPTigkKGlmcmFtZVswXS5ib2R5KS50ZXh0KCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdpZnJhbWUgaHRtbCc6IGZ1bmN0aW9uIChpZnJhbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWZyYW1lICYmICQoaWZyYW1lWzBdLmJvZHkpLmh0bWwoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnaWZyYW1lIHhtbCc6IGZ1bmN0aW9uIChpZnJhbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgeG1sRG9jID0gaWZyYW1lICYmIGlmcmFtZVswXTtcbiAgICAgICAgICAgICAgICByZXR1cm4geG1sRG9jICYmICQuaXNYTUxEb2MoeG1sRG9jKSA/IHhtbERvYyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAkLnBhcnNlWE1MKCh4bWxEb2MuWE1MRG9jdW1lbnQgJiYgeG1sRG9jLlhNTERvY3VtZW50LnhtbCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHhtbERvYy5ib2R5KS5odG1sKCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdpZnJhbWUgc2NyaXB0JzogZnVuY3Rpb24gKGlmcmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZnJhbWUgJiYgJC5nbG9iYWxFdmFsKCQoaWZyYW1lWzBdLmJvZHkpLnRleHQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxufSkpO1xuIiwiLyohXG4gKiBqUXVlcnkgVUkgV2lkZ2V0IDEuMTAuNCthbWRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ibHVlaW1wL2pRdWVyeS1GaWxlLVVwbG9hZFxuICpcbiAqIENvcHlyaWdodCAyMDE0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9qUXVlcnkud2lkZ2V0L1xuICovXG5cbihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgQU1EIG1vZHVsZTpcbiAgICAgICAgZGVmaW5lKFtcImpxdWVyeVwiXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzOlxuICAgICAgICBmYWN0b3J5KGpRdWVyeSk7XG4gICAgfVxufShmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG52YXIgdXVpZCA9IDAsXG5cdHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLFxuXHRfY2xlYW5EYXRhID0gJC5jbGVhbkRhdGE7XG4kLmNsZWFuRGF0YSA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0Zm9yICggdmFyIGkgPSAwLCBlbGVtOyAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0dHJ5IHtcblx0XHRcdCQoIGVsZW0gKS50cmlnZ2VySGFuZGxlciggXCJyZW1vdmVcIiApO1xuXHRcdC8vIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzgyMzVcblx0XHR9IGNhdGNoKCBlICkge31cblx0fVxuXHRfY2xlYW5EYXRhKCBlbGVtcyApO1xufTtcblxuJC53aWRnZXQgPSBmdW5jdGlvbiggbmFtZSwgYmFzZSwgcHJvdG90eXBlICkge1xuXHR2YXIgZnVsbE5hbWUsIGV4aXN0aW5nQ29uc3RydWN0b3IsIGNvbnN0cnVjdG9yLCBiYXNlUHJvdG90eXBlLFxuXHRcdC8vIHByb3hpZWRQcm90b3R5cGUgYWxsb3dzIHRoZSBwcm92aWRlZCBwcm90b3R5cGUgdG8gcmVtYWluIHVubW9kaWZpZWRcblx0XHQvLyBzbyB0aGF0IGl0IGNhbiBiZSB1c2VkIGFzIGEgbWl4aW4gZm9yIG11bHRpcGxlIHdpZGdldHMgKCM4ODc2KVxuXHRcdHByb3hpZWRQcm90b3R5cGUgPSB7fSxcblx0XHRuYW1lc3BhY2UgPSBuYW1lLnNwbGl0KCBcIi5cIiApWyAwIF07XG5cblx0bmFtZSA9IG5hbWUuc3BsaXQoIFwiLlwiIClbIDEgXTtcblx0ZnVsbE5hbWUgPSBuYW1lc3BhY2UgKyBcIi1cIiArIG5hbWU7XG5cblx0aWYgKCAhcHJvdG90eXBlICkge1xuXHRcdHByb3RvdHlwZSA9IGJhc2U7XG5cdFx0YmFzZSA9ICQuV2lkZ2V0O1xuXHR9XG5cblx0Ly8gY3JlYXRlIHNlbGVjdG9yIGZvciBwbHVnaW5cblx0JC5leHByWyBcIjpcIiBdWyBmdWxsTmFtZS50b0xvd2VyQ2FzZSgpIF0gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gISEkLmRhdGEoIGVsZW0sIGZ1bGxOYW1lICk7XG5cdH07XG5cblx0JFsgbmFtZXNwYWNlIF0gPSAkWyBuYW1lc3BhY2UgXSB8fCB7fTtcblx0ZXhpc3RpbmdDb25zdHJ1Y3RvciA9ICRbIG5hbWVzcGFjZSBdWyBuYW1lIF07XG5cdGNvbnN0cnVjdG9yID0gJFsgbmFtZXNwYWNlIF1bIG5hbWUgXSA9IGZ1bmN0aW9uKCBvcHRpb25zLCBlbGVtZW50ICkge1xuXHRcdC8vIGFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCBcIm5ld1wiIGtleXdvcmRcblx0XHRpZiAoICF0aGlzLl9jcmVhdGVXaWRnZXQgKSB7XG5cdFx0XHRyZXR1cm4gbmV3IGNvbnN0cnVjdG9yKCBvcHRpb25zLCBlbGVtZW50ICk7XG5cdFx0fVxuXG5cdFx0Ly8gYWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IGluaXRpYWxpemluZyBmb3Igc2ltcGxlIGluaGVyaXRhbmNlXG5cdFx0Ly8gbXVzdCB1c2UgXCJuZXdcIiBrZXl3b3JkICh0aGUgY29kZSBhYm92ZSBhbHdheXMgcGFzc2VzIGFyZ3MpXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0dGhpcy5fY3JlYXRlV2lkZ2V0KCBvcHRpb25zLCBlbGVtZW50ICk7XG5cdFx0fVxuXHR9O1xuXHQvLyBleHRlbmQgd2l0aCB0aGUgZXhpc3RpbmcgY29uc3RydWN0b3IgdG8gY2Fycnkgb3ZlciBhbnkgc3RhdGljIHByb3BlcnRpZXNcblx0JC5leHRlbmQoIGNvbnN0cnVjdG9yLCBleGlzdGluZ0NvbnN0cnVjdG9yLCB7XG5cdFx0dmVyc2lvbjogcHJvdG90eXBlLnZlcnNpb24sXG5cdFx0Ly8gY29weSB0aGUgb2JqZWN0IHVzZWQgdG8gY3JlYXRlIHRoZSBwcm90b3R5cGUgaW4gY2FzZSB3ZSBuZWVkIHRvXG5cdFx0Ly8gcmVkZWZpbmUgdGhlIHdpZGdldCBsYXRlclxuXHRcdF9wcm90bzogJC5leHRlbmQoIHt9LCBwcm90b3R5cGUgKSxcblx0XHQvLyB0cmFjayB3aWRnZXRzIHRoYXQgaW5oZXJpdCBmcm9tIHRoaXMgd2lkZ2V0IGluIGNhc2UgdGhpcyB3aWRnZXQgaXNcblx0XHQvLyByZWRlZmluZWQgYWZ0ZXIgYSB3aWRnZXQgaW5oZXJpdHMgZnJvbSBpdFxuXHRcdF9jaGlsZENvbnN0cnVjdG9yczogW11cblx0fSk7XG5cblx0YmFzZVByb3RvdHlwZSA9IG5ldyBiYXNlKCk7XG5cdC8vIHdlIG5lZWQgdG8gbWFrZSB0aGUgb3B0aW9ucyBoYXNoIGEgcHJvcGVydHkgZGlyZWN0bHkgb24gdGhlIG5ldyBpbnN0YW5jZVxuXHQvLyBvdGhlcndpc2Ugd2UnbGwgbW9kaWZ5IHRoZSBvcHRpb25zIGhhc2ggb24gdGhlIHByb3RvdHlwZSB0aGF0IHdlJ3JlXG5cdC8vIGluaGVyaXRpbmcgZnJvbVxuXHRiYXNlUHJvdG90eXBlLm9wdGlvbnMgPSAkLndpZGdldC5leHRlbmQoIHt9LCBiYXNlUHJvdG90eXBlLm9wdGlvbnMgKTtcblx0JC5lYWNoKCBwcm90b3R5cGUsIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRpZiAoICEkLmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRwcm94aWVkUHJvdG90eXBlWyBwcm9wIF0gPSB2YWx1ZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0cHJveGllZFByb3RvdHlwZVsgcHJvcCBdID0gKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIF9zdXBlciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBiYXNlLnByb3RvdHlwZVsgcHJvcCBdLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0X3N1cGVyQXBwbHkgPSBmdW5jdGlvbiggYXJncyApIHtcblx0XHRcdFx0XHRyZXR1cm4gYmFzZS5wcm90b3R5cGVbIHByb3AgXS5hcHBseSggdGhpcywgYXJncyApO1xuXHRcdFx0XHR9O1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgX19zdXBlciA9IHRoaXMuX3N1cGVyLFxuXHRcdFx0XHRcdF9fc3VwZXJBcHBseSA9IHRoaXMuX3N1cGVyQXBwbHksXG5cdFx0XHRcdFx0cmV0dXJuVmFsdWU7XG5cblx0XHRcdFx0dGhpcy5fc3VwZXIgPSBfc3VwZXI7XG5cdFx0XHRcdHRoaXMuX3N1cGVyQXBwbHkgPSBfc3VwZXJBcHBseTtcblxuXHRcdFx0XHRyZXR1cm5WYWx1ZSA9IHZhbHVlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblxuXHRcdFx0XHR0aGlzLl9zdXBlciA9IF9fc3VwZXI7XG5cdFx0XHRcdHRoaXMuX3N1cGVyQXBwbHkgPSBfX3N1cGVyQXBwbHk7XG5cblx0XHRcdFx0cmV0dXJuIHJldHVyblZhbHVlO1xuXHRcdFx0fTtcblx0XHR9KSgpO1xuXHR9KTtcblx0Y29uc3RydWN0b3IucHJvdG90eXBlID0gJC53aWRnZXQuZXh0ZW5kKCBiYXNlUHJvdG90eXBlLCB7XG5cdFx0Ly8gVE9ETzogcmVtb3ZlIHN1cHBvcnQgZm9yIHdpZGdldEV2ZW50UHJlZml4XG5cdFx0Ly8gYWx3YXlzIHVzZSB0aGUgbmFtZSArIGEgY29sb24gYXMgdGhlIHByZWZpeCwgZS5nLiwgZHJhZ2dhYmxlOnN0YXJ0XG5cdFx0Ly8gZG9uJ3QgcHJlZml4IGZvciB3aWRnZXRzIHRoYXQgYXJlbid0IERPTS1iYXNlZFxuXHRcdHdpZGdldEV2ZW50UHJlZml4OiBleGlzdGluZ0NvbnN0cnVjdG9yID8gKGJhc2VQcm90b3R5cGUud2lkZ2V0RXZlbnRQcmVmaXggfHwgbmFtZSkgOiBuYW1lXG5cdH0sIHByb3hpZWRQcm90b3R5cGUsIHtcblx0XHRjb25zdHJ1Y3RvcjogY29uc3RydWN0b3IsXG5cdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2UsXG5cdFx0d2lkZ2V0TmFtZTogbmFtZSxcblx0XHR3aWRnZXRGdWxsTmFtZTogZnVsbE5hbWVcblx0fSk7XG5cblx0Ly8gSWYgdGhpcyB3aWRnZXQgaXMgYmVpbmcgcmVkZWZpbmVkIHRoZW4gd2UgbmVlZCB0byBmaW5kIGFsbCB3aWRnZXRzIHRoYXRcblx0Ly8gYXJlIGluaGVyaXRpbmcgZnJvbSBpdCBhbmQgcmVkZWZpbmUgYWxsIG9mIHRoZW0gc28gdGhhdCB0aGV5IGluaGVyaXQgZnJvbVxuXHQvLyB0aGUgbmV3IHZlcnNpb24gb2YgdGhpcyB3aWRnZXQuIFdlJ3JlIGVzc2VudGlhbGx5IHRyeWluZyB0byByZXBsYWNlIG9uZVxuXHQvLyBsZXZlbCBpbiB0aGUgcHJvdG90eXBlIGNoYWluLlxuXHRpZiAoIGV4aXN0aW5nQ29uc3RydWN0b3IgKSB7XG5cdFx0JC5lYWNoKCBleGlzdGluZ0NvbnN0cnVjdG9yLl9jaGlsZENvbnN0cnVjdG9ycywgZnVuY3Rpb24oIGksIGNoaWxkICkge1xuXHRcdFx0dmFyIGNoaWxkUHJvdG90eXBlID0gY2hpbGQucHJvdG90eXBlO1xuXG5cdFx0XHQvLyByZWRlZmluZSB0aGUgY2hpbGQgd2lkZ2V0IHVzaW5nIHRoZSBzYW1lIHByb3RvdHlwZSB0aGF0IHdhc1xuXHRcdFx0Ly8gb3JpZ2luYWxseSB1c2VkLCBidXQgaW5oZXJpdCBmcm9tIHRoZSBuZXcgdmVyc2lvbiBvZiB0aGUgYmFzZVxuXHRcdFx0JC53aWRnZXQoIGNoaWxkUHJvdG90eXBlLm5hbWVzcGFjZSArIFwiLlwiICsgY2hpbGRQcm90b3R5cGUud2lkZ2V0TmFtZSwgY29uc3RydWN0b3IsIGNoaWxkLl9wcm90byApO1xuXHRcdH0pO1xuXHRcdC8vIHJlbW92ZSB0aGUgbGlzdCBvZiBleGlzdGluZyBjaGlsZCBjb25zdHJ1Y3RvcnMgZnJvbSB0aGUgb2xkIGNvbnN0cnVjdG9yXG5cdFx0Ly8gc28gdGhlIG9sZCBjaGlsZCBjb25zdHJ1Y3RvcnMgY2FuIGJlIGdhcmJhZ2UgY29sbGVjdGVkXG5cdFx0ZGVsZXRlIGV4aXN0aW5nQ29uc3RydWN0b3IuX2NoaWxkQ29uc3RydWN0b3JzO1xuXHR9IGVsc2Uge1xuXHRcdGJhc2UuX2NoaWxkQ29uc3RydWN0b3JzLnB1c2goIGNvbnN0cnVjdG9yICk7XG5cdH1cblxuXHQkLndpZGdldC5icmlkZ2UoIG5hbWUsIGNvbnN0cnVjdG9yICk7XG59O1xuXG4kLndpZGdldC5leHRlbmQgPSBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHR2YXIgaW5wdXQgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKSxcblx0XHRpbnB1dEluZGV4ID0gMCxcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHRrZXksXG5cdFx0dmFsdWU7XG5cdGZvciAoIDsgaW5wdXRJbmRleCA8IGlucHV0TGVuZ3RoOyBpbnB1dEluZGV4KysgKSB7XG5cdFx0Zm9yICgga2V5IGluIGlucHV0WyBpbnB1dEluZGV4IF0gKSB7XG5cdFx0XHR2YWx1ZSA9IGlucHV0WyBpbnB1dEluZGV4IF1bIGtleSBdO1xuXHRcdFx0aWYgKCBpbnB1dFsgaW5wdXRJbmRleCBdLmhhc093blByb3BlcnR5KCBrZXkgKSAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHQvLyBDbG9uZSBvYmplY3RzXG5cdFx0XHRcdGlmICggJC5pc1BsYWluT2JqZWN0KCB2YWx1ZSApICkge1xuXHRcdFx0XHRcdHRhcmdldFsga2V5IF0gPSAkLmlzUGxhaW5PYmplY3QoIHRhcmdldFsga2V5IF0gKSA/XG5cdFx0XHRcdFx0XHQkLndpZGdldC5leHRlbmQoIHt9LCB0YXJnZXRbIGtleSBdLCB2YWx1ZSApIDpcblx0XHRcdFx0XHRcdC8vIERvbid0IGV4dGVuZCBzdHJpbmdzLCBhcnJheXMsIGV0Yy4gd2l0aCBvYmplY3RzXG5cdFx0XHRcdFx0XHQkLndpZGdldC5leHRlbmQoIHt9LCB2YWx1ZSApO1xuXHRcdFx0XHQvLyBDb3B5IGV2ZXJ5dGhpbmcgZWxzZSBieSByZWZlcmVuY2Vcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0YXJnZXRbIGtleSBdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbiQud2lkZ2V0LmJyaWRnZSA9IGZ1bmN0aW9uKCBuYW1lLCBvYmplY3QgKSB7XG5cdHZhciBmdWxsTmFtZSA9IG9iamVjdC5wcm90b3R5cGUud2lkZ2V0RnVsbE5hbWUgfHwgbmFtZTtcblx0JC5mblsgbmFtZSBdID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0dmFyIGlzTWV0aG9kQ2FsbCA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiLFxuXHRcdFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApLFxuXHRcdFx0cmV0dXJuVmFsdWUgPSB0aGlzO1xuXG5cdFx0Ly8gYWxsb3cgbXVsdGlwbGUgaGFzaGVzIHRvIGJlIHBhc3NlZCBvbiBpbml0XG5cdFx0b3B0aW9ucyA9ICFpc01ldGhvZENhbGwgJiYgYXJncy5sZW5ndGggP1xuXHRcdFx0JC53aWRnZXQuZXh0ZW5kLmFwcGx5KCBudWxsLCBbIG9wdGlvbnMgXS5jb25jYXQoYXJncykgKSA6XG5cdFx0XHRvcHRpb25zO1xuXG5cdFx0aWYgKCBpc01ldGhvZENhbGwgKSB7XG5cdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBtZXRob2RWYWx1ZSxcblx0XHRcdFx0XHRpbnN0YW5jZSA9ICQuZGF0YSggdGhpcywgZnVsbE5hbWUgKTtcblx0XHRcdFx0aWYgKCAhaW5zdGFuY2UgKSB7XG5cdFx0XHRcdFx0cmV0dXJuICQuZXJyb3IoIFwiY2Fubm90IGNhbGwgbWV0aG9kcyBvbiBcIiArIG5hbWUgKyBcIiBwcmlvciB0byBpbml0aWFsaXphdGlvbjsgXCIgK1xuXHRcdFx0XHRcdFx0XCJhdHRlbXB0ZWQgdG8gY2FsbCBtZXRob2QgJ1wiICsgb3B0aW9ucyArIFwiJ1wiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhJC5pc0Z1bmN0aW9uKCBpbnN0YW5jZVtvcHRpb25zXSApIHx8IG9wdGlvbnMuY2hhckF0KCAwICkgPT09IFwiX1wiICkge1xuXHRcdFx0XHRcdHJldHVybiAkLmVycm9yKCBcIm5vIHN1Y2ggbWV0aG9kICdcIiArIG9wdGlvbnMgKyBcIicgZm9yIFwiICsgbmFtZSArIFwiIHdpZGdldCBpbnN0YW5jZVwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bWV0aG9kVmFsdWUgPSBpbnN0YW5jZVsgb3B0aW9ucyBdLmFwcGx5KCBpbnN0YW5jZSwgYXJncyApO1xuXHRcdFx0XHRpZiAoIG1ldGhvZFZhbHVlICE9PSBpbnN0YW5jZSAmJiBtZXRob2RWYWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVyblZhbHVlID0gbWV0aG9kVmFsdWUgJiYgbWV0aG9kVmFsdWUuanF1ZXJ5ID9cblx0XHRcdFx0XHRcdHJldHVyblZhbHVlLnB1c2hTdGFjayggbWV0aG9kVmFsdWUuZ2V0KCkgKSA6XG5cdFx0XHRcdFx0XHRtZXRob2RWYWx1ZTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBpbnN0YW5jZSA9ICQuZGF0YSggdGhpcywgZnVsbE5hbWUgKTtcblx0XHRcdFx0aWYgKCBpbnN0YW5jZSApIHtcblx0XHRcdFx0XHRpbnN0YW5jZS5vcHRpb24oIG9wdGlvbnMgfHwge30gKS5faW5pdCgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCQuZGF0YSggdGhpcywgZnVsbE5hbWUsIG5ldyBvYmplY3QoIG9wdGlvbnMsIHRoaXMgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0dXJuVmFsdWU7XG5cdH07XG59O1xuXG4kLldpZGdldCA9IGZ1bmN0aW9uKCAvKiBvcHRpb25zLCBlbGVtZW50ICovICkge307XG4kLldpZGdldC5fY2hpbGRDb25zdHJ1Y3RvcnMgPSBbXTtcblxuJC5XaWRnZXQucHJvdG90eXBlID0ge1xuXHR3aWRnZXROYW1lOiBcIndpZGdldFwiLFxuXHR3aWRnZXRFdmVudFByZWZpeDogXCJcIixcblx0ZGVmYXVsdEVsZW1lbnQ6IFwiPGRpdj5cIixcblx0b3B0aW9uczoge1xuXHRcdGRpc2FibGVkOiBmYWxzZSxcblxuXHRcdC8vIGNhbGxiYWNrc1xuXHRcdGNyZWF0ZTogbnVsbFxuXHR9LFxuXHRfY3JlYXRlV2lkZ2V0OiBmdW5jdGlvbiggb3B0aW9ucywgZWxlbWVudCApIHtcblx0XHRlbGVtZW50ID0gJCggZWxlbWVudCB8fCB0aGlzLmRlZmF1bHRFbGVtZW50IHx8IHRoaXMgKVsgMCBdO1xuXHRcdHRoaXMuZWxlbWVudCA9ICQoIGVsZW1lbnQgKTtcblx0XHR0aGlzLnV1aWQgPSB1dWlkKys7XG5cdFx0dGhpcy5ldmVudE5hbWVzcGFjZSA9IFwiLlwiICsgdGhpcy53aWRnZXROYW1lICsgdGhpcy51dWlkO1xuXHRcdHRoaXMub3B0aW9ucyA9ICQud2lkZ2V0LmV4dGVuZCgge30sXG5cdFx0XHR0aGlzLm9wdGlvbnMsXG5cdFx0XHR0aGlzLl9nZXRDcmVhdGVPcHRpb25zKCksXG5cdFx0XHRvcHRpb25zICk7XG5cblx0XHR0aGlzLmJpbmRpbmdzID0gJCgpO1xuXHRcdHRoaXMuaG92ZXJhYmxlID0gJCgpO1xuXHRcdHRoaXMuZm9jdXNhYmxlID0gJCgpO1xuXG5cdFx0aWYgKCBlbGVtZW50ICE9PSB0aGlzICkge1xuXHRcdFx0JC5kYXRhKCBlbGVtZW50LCB0aGlzLndpZGdldEZ1bGxOYW1lLCB0aGlzICk7XG5cdFx0XHR0aGlzLl9vbiggdHJ1ZSwgdGhpcy5lbGVtZW50LCB7XG5cdFx0XHRcdHJlbW92ZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRcdGlmICggZXZlbnQudGFyZ2V0ID09PSBlbGVtZW50ICkge1xuXHRcdFx0XHRcdFx0dGhpcy5kZXN0cm95KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHRoaXMuZG9jdW1lbnQgPSAkKCBlbGVtZW50LnN0eWxlID9cblx0XHRcdFx0Ly8gZWxlbWVudCB3aXRoaW4gdGhlIGRvY3VtZW50XG5cdFx0XHRcdGVsZW1lbnQub3duZXJEb2N1bWVudCA6XG5cdFx0XHRcdC8vIGVsZW1lbnQgaXMgd2luZG93IG9yIGRvY3VtZW50XG5cdFx0XHRcdGVsZW1lbnQuZG9jdW1lbnQgfHwgZWxlbWVudCApO1xuXHRcdFx0dGhpcy53aW5kb3cgPSAkKCB0aGlzLmRvY3VtZW50WzBdLmRlZmF1bHRWaWV3IHx8IHRoaXMuZG9jdW1lbnRbMF0ucGFyZW50V2luZG93ICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fY3JlYXRlKCk7XG5cdFx0dGhpcy5fdHJpZ2dlciggXCJjcmVhdGVcIiwgbnVsbCwgdGhpcy5fZ2V0Q3JlYXRlRXZlbnREYXRhKCkgKTtcblx0XHR0aGlzLl9pbml0KCk7XG5cdH0sXG5cdF9nZXRDcmVhdGVPcHRpb25zOiAkLm5vb3AsXG5cdF9nZXRDcmVhdGVFdmVudERhdGE6ICQubm9vcCxcblx0X2NyZWF0ZTogJC5ub29wLFxuXHRfaW5pdDogJC5ub29wLFxuXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2Rlc3Ryb3koKTtcblx0XHQvLyB3ZSBjYW4gcHJvYmFibHkgcmVtb3ZlIHRoZSB1bmJpbmQgY2FsbHMgaW4gMi4wXG5cdFx0Ly8gYWxsIGV2ZW50IGJpbmRpbmdzIHNob3VsZCBnbyB0aHJvdWdoIHRoaXMuX29uKClcblx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdC51bmJpbmQoIHRoaXMuZXZlbnROYW1lc3BhY2UgKVxuXHRcdFx0Ly8gMS45IEJDIGZvciAjNzgxMFxuXHRcdFx0Ly8gVE9ETyByZW1vdmUgZHVhbCBzdG9yYWdlXG5cdFx0XHQucmVtb3ZlRGF0YSggdGhpcy53aWRnZXROYW1lIClcblx0XHRcdC5yZW1vdmVEYXRhKCB0aGlzLndpZGdldEZ1bGxOYW1lIClcblx0XHRcdC8vIHN1cHBvcnQ6IGpxdWVyeSA8MS42LjNcblx0XHRcdC8vIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0Lzk0MTNcblx0XHRcdC5yZW1vdmVEYXRhKCAkLmNhbWVsQ2FzZSggdGhpcy53aWRnZXRGdWxsTmFtZSApICk7XG5cdFx0dGhpcy53aWRnZXQoKVxuXHRcdFx0LnVuYmluZCggdGhpcy5ldmVudE5hbWVzcGFjZSApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWRpc2FibGVkXCIgKVxuXHRcdFx0LnJlbW92ZUNsYXNzKFxuXHRcdFx0XHR0aGlzLndpZGdldEZ1bGxOYW1lICsgXCItZGlzYWJsZWQgXCIgK1xuXHRcdFx0XHRcInVpLXN0YXRlLWRpc2FibGVkXCIgKTtcblxuXHRcdC8vIGNsZWFuIHVwIGV2ZW50cyBhbmQgc3RhdGVzXG5cdFx0dGhpcy5iaW5kaW5ncy51bmJpbmQoIHRoaXMuZXZlbnROYW1lc3BhY2UgKTtcblx0XHR0aGlzLmhvdmVyYWJsZS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1ob3ZlclwiICk7XG5cdFx0dGhpcy5mb2N1c2FibGUucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHR9LFxuXHRfZGVzdHJveTogJC5ub29wLFxuXG5cdHdpZGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWxlbWVudDtcblx0fSxcblxuXHRvcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBvcHRpb25zID0ga2V5LFxuXHRcdFx0cGFydHMsXG5cdFx0XHRjdXJPcHRpb24sXG5cdFx0XHRpO1xuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAwICkge1xuXHRcdFx0Ly8gZG9uJ3QgcmV0dXJuIGEgcmVmZXJlbmNlIHRvIHRoZSBpbnRlcm5hbCBoYXNoXG5cdFx0XHRyZXR1cm4gJC53aWRnZXQuZXh0ZW5kKCB7fSwgdGhpcy5vcHRpb25zICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Ly8gaGFuZGxlIG5lc3RlZCBrZXlzLCBlLmcuLCBcImZvby5iYXJcIiA9PiB7IGZvbzogeyBiYXI6IF9fXyB9IH1cblx0XHRcdG9wdGlvbnMgPSB7fTtcblx0XHRcdHBhcnRzID0ga2V5LnNwbGl0KCBcIi5cIiApO1xuXHRcdFx0a2V5ID0gcGFydHMuc2hpZnQoKTtcblx0XHRcdGlmICggcGFydHMubGVuZ3RoICkge1xuXHRcdFx0XHRjdXJPcHRpb24gPSBvcHRpb25zWyBrZXkgXSA9ICQud2lkZ2V0LmV4dGVuZCgge30sIHRoaXMub3B0aW9uc1sga2V5IF0gKTtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpKysgKSB7XG5cdFx0XHRcdFx0Y3VyT3B0aW9uWyBwYXJ0c1sgaSBdIF0gPSBjdXJPcHRpb25bIHBhcnRzWyBpIF0gXSB8fCB7fTtcblx0XHRcdFx0XHRjdXJPcHRpb24gPSBjdXJPcHRpb25bIHBhcnRzWyBpIF0gXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRrZXkgPSBwYXJ0cy5wb3AoKTtcblx0XHRcdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHRcdHJldHVybiBjdXJPcHRpb25bIGtleSBdID09PSB1bmRlZmluZWQgPyBudWxsIDogY3VyT3B0aW9uWyBrZXkgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjdXJPcHRpb25bIGtleSBdID0gdmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMub3B0aW9uc1sga2V5IF0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiB0aGlzLm9wdGlvbnNbIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9wdGlvbnNbIGtleSBdID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fc2V0T3B0aW9ucyggb3B0aW9ucyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdF9zZXRPcHRpb25zOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHR2YXIga2V5O1xuXG5cdFx0Zm9yICgga2V5IGluIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLl9zZXRPcHRpb24oIGtleSwgb3B0aW9uc1sga2V5IF0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dGhpcy5vcHRpb25zWyBrZXkgXSA9IHZhbHVlO1xuXG5cdFx0aWYgKCBrZXkgPT09IFwiZGlzYWJsZWRcIiApIHtcblx0XHRcdHRoaXMud2lkZ2V0KClcblx0XHRcdFx0LnRvZ2dsZUNsYXNzKCB0aGlzLndpZGdldEZ1bGxOYW1lICsgXCItZGlzYWJsZWQgdWktc3RhdGUtZGlzYWJsZWRcIiwgISF2YWx1ZSApXG5cdFx0XHRcdC5hdHRyKCBcImFyaWEtZGlzYWJsZWRcIiwgdmFsdWUgKTtcblx0XHRcdHRoaXMuaG92ZXJhYmxlLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHRcdHRoaXMuZm9jdXNhYmxlLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWZvY3VzXCIgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRlbmFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZXRPcHRpb24oIFwiZGlzYWJsZWRcIiwgZmFsc2UgKTtcblx0fSxcblx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NldE9wdGlvbiggXCJkaXNhYmxlZFwiLCB0cnVlICk7XG5cdH0sXG5cblx0X29uOiBmdW5jdGlvbiggc3VwcHJlc3NEaXNhYmxlZENoZWNrLCBlbGVtZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgZGVsZWdhdGVFbGVtZW50LFxuXHRcdFx0aW5zdGFuY2UgPSB0aGlzO1xuXG5cdFx0Ly8gbm8gc3VwcHJlc3NEaXNhYmxlZENoZWNrIGZsYWcsIHNodWZmbGUgYXJndW1lbnRzXG5cdFx0aWYgKCB0eXBlb2Ygc3VwcHJlc3NEaXNhYmxlZENoZWNrICE9PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdGhhbmRsZXJzID0gZWxlbWVudDtcblx0XHRcdGVsZW1lbnQgPSBzdXBwcmVzc0Rpc2FibGVkQ2hlY2s7XG5cdFx0XHRzdXBwcmVzc0Rpc2FibGVkQ2hlY2sgPSBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBubyBlbGVtZW50IGFyZ3VtZW50LCBzaHVmZmxlIGFuZCB1c2UgdGhpcy5lbGVtZW50XG5cdFx0aWYgKCAhaGFuZGxlcnMgKSB7XG5cdFx0XHRoYW5kbGVycyA9IGVsZW1lbnQ7XG5cdFx0XHRlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXHRcdFx0ZGVsZWdhdGVFbGVtZW50ID0gdGhpcy53aWRnZXQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gYWNjZXB0IHNlbGVjdG9ycywgRE9NIGVsZW1lbnRzXG5cdFx0XHRlbGVtZW50ID0gZGVsZWdhdGVFbGVtZW50ID0gJCggZWxlbWVudCApO1xuXHRcdFx0dGhpcy5iaW5kaW5ncyA9IHRoaXMuYmluZGluZ3MuYWRkKCBlbGVtZW50ICk7XG5cdFx0fVxuXG5cdFx0JC5lYWNoKCBoYW5kbGVycywgZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVyICkge1xuXHRcdFx0ZnVuY3Rpb24gaGFuZGxlclByb3h5KCkge1xuXHRcdFx0XHQvLyBhbGxvdyB3aWRnZXRzIHRvIGN1c3RvbWl6ZSB0aGUgZGlzYWJsZWQgaGFuZGxpbmdcblx0XHRcdFx0Ly8gLSBkaXNhYmxlZCBhcyBhbiBhcnJheSBpbnN0ZWFkIG9mIGJvb2xlYW5cblx0XHRcdFx0Ly8gLSBkaXNhYmxlZCBjbGFzcyBhcyBtZXRob2QgZm9yIGRpc2FibGluZyBpbmRpdmlkdWFsIHBhcnRzXG5cdFx0XHRcdGlmICggIXN1cHByZXNzRGlzYWJsZWRDaGVjayAmJlxuXHRcdFx0XHRcdFx0KCBpbnN0YW5jZS5vcHRpb25zLmRpc2FibGVkID09PSB0cnVlIHx8XG5cdFx0XHRcdFx0XHRcdCQoIHRoaXMgKS5oYXNDbGFzcyggXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiICkgKSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuICggdHlwZW9mIGhhbmRsZXIgPT09IFwic3RyaW5nXCIgPyBpbnN0YW5jZVsgaGFuZGxlciBdIDogaGFuZGxlciApXG5cdFx0XHRcdFx0LmFwcGx5KCBpbnN0YW5jZSwgYXJndW1lbnRzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNvcHkgdGhlIGd1aWQgc28gZGlyZWN0IHVuYmluZGluZyB3b3Jrc1xuXHRcdFx0aWYgKCB0eXBlb2YgaGFuZGxlciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0aGFuZGxlclByb3h5Lmd1aWQgPSBoYW5kbGVyLmd1aWQgPVxuXHRcdFx0XHRcdGhhbmRsZXIuZ3VpZCB8fCBoYW5kbGVyUHJveHkuZ3VpZCB8fCAkLmd1aWQrKztcblx0XHRcdH1cblxuXHRcdFx0dmFyIG1hdGNoID0gZXZlbnQubWF0Y2goIC9eKFxcdyspXFxzKiguKikkLyApLFxuXHRcdFx0XHRldmVudE5hbWUgPSBtYXRjaFsxXSArIGluc3RhbmNlLmV2ZW50TmFtZXNwYWNlLFxuXHRcdFx0XHRzZWxlY3RvciA9IG1hdGNoWzJdO1xuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0ZGVsZWdhdGVFbGVtZW50LmRlbGVnYXRlKCBzZWxlY3RvciwgZXZlbnROYW1lLCBoYW5kbGVyUHJveHkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnQuYmluZCggZXZlbnROYW1lLCBoYW5kbGVyUHJveHkgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRfb2ZmOiBmdW5jdGlvbiggZWxlbWVudCwgZXZlbnROYW1lICkge1xuXHRcdGV2ZW50TmFtZSA9IChldmVudE5hbWUgfHwgXCJcIikuc3BsaXQoIFwiIFwiICkuam9pbiggdGhpcy5ldmVudE5hbWVzcGFjZSArIFwiIFwiICkgKyB0aGlzLmV2ZW50TmFtZXNwYWNlO1xuXHRcdGVsZW1lbnQudW5iaW5kKCBldmVudE5hbWUgKS51bmRlbGVnYXRlKCBldmVudE5hbWUgKTtcblx0fSxcblxuXHRfZGVsYXk6IGZ1bmN0aW9uKCBoYW5kbGVyLCBkZWxheSApIHtcblx0XHRmdW5jdGlvbiBoYW5kbGVyUHJveHkoKSB7XG5cdFx0XHRyZXR1cm4gKCB0eXBlb2YgaGFuZGxlciA9PT0gXCJzdHJpbmdcIiA/IGluc3RhbmNlWyBoYW5kbGVyIF0gOiBoYW5kbGVyIClcblx0XHRcdFx0LmFwcGx5KCBpbnN0YW5jZSwgYXJndW1lbnRzICk7XG5cdFx0fVxuXHRcdHZhciBpbnN0YW5jZSA9IHRoaXM7XG5cdFx0cmV0dXJuIHNldFRpbWVvdXQoIGhhbmRsZXJQcm94eSwgZGVsYXkgfHwgMCApO1xuXHR9LFxuXG5cdF9ob3ZlcmFibGU6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHRoaXMuaG92ZXJhYmxlID0gdGhpcy5ob3ZlcmFibGUuYWRkKCBlbGVtZW50ICk7XG5cdFx0dGhpcy5fb24oIGVsZW1lbnQsIHtcblx0XHRcdG1vdXNlZW50ZXI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0JCggZXZlbnQuY3VycmVudFRhcmdldCApLmFkZENsYXNzKCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHRcdH0sXG5cdFx0XHRtb3VzZWxlYXZlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdCQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1ob3ZlclwiICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0X2ZvY3VzYWJsZTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0dGhpcy5mb2N1c2FibGUgPSB0aGlzLmZvY3VzYWJsZS5hZGQoIGVsZW1lbnQgKTtcblx0XHR0aGlzLl9vbiggZWxlbWVudCwge1xuXHRcdFx0Zm9jdXNpbjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHQkKCBldmVudC5jdXJyZW50VGFyZ2V0ICkuYWRkQ2xhc3MoIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHRcdFx0fSxcblx0XHRcdGZvY3Vzb3V0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdCQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0X3RyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBldmVudCwgZGF0YSApIHtcblx0XHR2YXIgcHJvcCwgb3JpZyxcblx0XHRcdGNhbGxiYWNrID0gdGhpcy5vcHRpb25zWyB0eXBlIF07XG5cblx0XHRkYXRhID0gZGF0YSB8fCB7fTtcblx0XHRldmVudCA9ICQuRXZlbnQoIGV2ZW50ICk7XG5cdFx0ZXZlbnQudHlwZSA9ICggdHlwZSA9PT0gdGhpcy53aWRnZXRFdmVudFByZWZpeCA/XG5cdFx0XHR0eXBlIDpcblx0XHRcdHRoaXMud2lkZ2V0RXZlbnRQcmVmaXggKyB0eXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHQvLyB0aGUgb3JpZ2luYWwgZXZlbnQgbWF5IGNvbWUgZnJvbSBhbnkgZWxlbWVudFxuXHRcdC8vIHNvIHdlIG5lZWQgdG8gcmVzZXQgdGhlIHRhcmdldCBvbiB0aGUgbmV3IGV2ZW50XG5cdFx0ZXZlbnQudGFyZ2V0ID0gdGhpcy5lbGVtZW50WyAwIF07XG5cblx0XHQvLyBjb3B5IG9yaWdpbmFsIGV2ZW50IHByb3BlcnRpZXMgb3ZlciB0byB0aGUgbmV3IGV2ZW50XG5cdFx0b3JpZyA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQ7XG5cdFx0aWYgKCBvcmlnICkge1xuXHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRpZiAoICEoIHByb3AgaW4gZXZlbnQgKSApIHtcblx0XHRcdFx0XHRldmVudFsgcHJvcCBdID0gb3JpZ1sgcHJvcCBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5lbGVtZW50LnRyaWdnZXIoIGV2ZW50LCBkYXRhICk7XG5cdFx0cmV0dXJuICEoICQuaXNGdW5jdGlvbiggY2FsbGJhY2sgKSAmJlxuXHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMuZWxlbWVudFswXSwgWyBldmVudCBdLmNvbmNhdCggZGF0YSApICkgPT09IGZhbHNlIHx8XG5cdFx0XHRldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApO1xuXHR9XG59O1xuXG4kLmVhY2goIHsgc2hvdzogXCJmYWRlSW5cIiwgaGlkZTogXCJmYWRlT3V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgZGVmYXVsdEVmZmVjdCApIHtcblx0JC5XaWRnZXQucHJvdG90eXBlWyBcIl9cIiArIG1ldGhvZCBdID0gZnVuY3Rpb24oIGVsZW1lbnQsIG9wdGlvbnMsIGNhbGxiYWNrICkge1xuXHRcdGlmICggdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvcHRpb25zID0geyBlZmZlY3Q6IG9wdGlvbnMgfTtcblx0XHR9XG5cdFx0dmFyIGhhc09wdGlvbnMsXG5cdFx0XHRlZmZlY3ROYW1lID0gIW9wdGlvbnMgP1xuXHRcdFx0XHRtZXRob2QgOlxuXHRcdFx0XHRvcHRpb25zID09PSB0cnVlIHx8IHR5cGVvZiBvcHRpb25zID09PSBcIm51bWJlclwiID9cblx0XHRcdFx0XHRkZWZhdWx0RWZmZWN0IDpcblx0XHRcdFx0XHRvcHRpb25zLmVmZmVjdCB8fCBkZWZhdWx0RWZmZWN0O1xuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdGlmICggdHlwZW9mIG9wdGlvbnMgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRvcHRpb25zID0geyBkdXJhdGlvbjogb3B0aW9ucyB9O1xuXHRcdH1cblx0XHRoYXNPcHRpb25zID0gISQuaXNFbXB0eU9iamVjdCggb3B0aW9ucyApO1xuXHRcdG9wdGlvbnMuY29tcGxldGUgPSBjYWxsYmFjaztcblx0XHRpZiAoIG9wdGlvbnMuZGVsYXkgKSB7XG5cdFx0XHRlbGVtZW50LmRlbGF5KCBvcHRpb25zLmRlbGF5ICk7XG5cdFx0fVxuXHRcdGlmICggaGFzT3B0aW9ucyAmJiAkLmVmZmVjdHMgJiYgJC5lZmZlY3RzLmVmZmVjdFsgZWZmZWN0TmFtZSBdICkge1xuXHRcdFx0ZWxlbWVudFsgbWV0aG9kIF0oIG9wdGlvbnMgKTtcblx0XHR9IGVsc2UgaWYgKCBlZmZlY3ROYW1lICE9PSBtZXRob2QgJiYgZWxlbWVudFsgZWZmZWN0TmFtZSBdICkge1xuXHRcdFx0ZWxlbWVudFsgZWZmZWN0TmFtZSBdKCBvcHRpb25zLmR1cmF0aW9uLCBvcHRpb25zLmVhc2luZywgY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbWVudC5xdWV1ZShmdW5jdGlvbiggbmV4dCApIHtcblx0XHRcdFx0JCggdGhpcyApWyBtZXRob2QgXSgpO1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGVsZW1lbnRbIDAgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5leHQoKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcbn0pO1xuXG59KSk7XG4iLCIvKipcbiAqIHZlcnNpb24gMi4xLjMwXG4gKiBAbGljZW5zZVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIuanNcbiAqIGh0dHA6Ly93d3cuZXllY29uLnJvL2Jvb3RzdHJhcC1kYXRlcGlja2VyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDEyIFN0ZWZhbiBQZXRyZVxuICpcbiAqIENvbnRyaWJ1dGlvbnM6XG4gKiAtIHVwZGF0ZWQgZm9yIEJvb3RzdHJhcCB2MyBieSBKb25hdGhhbiBQZXRlcnNvbiAoQEVvbmFzZGFuKSBhbmQgKGFsbW9zdClcbiAqICAgIGNvbXBsZXRlbHkgcmV3cml0dGVuIHRvIHVzZSBNb21lbnRqc1xuICogLSBiYXNlZCBvbiB0YXJydWRhJ3MgYm9vdHN0cmFwLWRhdGVwaWNrZXJcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG47IChmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBBTUQgaXMgdXNlZCAtIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgICAgIGRlZmluZShbJ2pxdWVyeScsICdtb21lbnQnXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQU1EIGlzIG5vdCB1c2VkIC0gQXR0ZW1wdCB0byBmZXRjaCBkZXBlbmRlbmNpZXMgZnJvbSBzY29wZS5cbiAgICAgICAgaWYoIWpRdWVyeSl7XG4gICAgICAgICAgICB0aHJvdyAnYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyIHJlcXVpcmVzIGpRdWVyeSB0byBiZSBsb2FkZWQgZmlyc3QnO1xuICAgICAgICB9ZWxzZSBpZighbW9tZW50KSB7XG4gICAgICAgICAgICB0aHJvdyAnYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyIHJlcXVpcmVzIG1vbWVudC5qcyB0byBiZSBsb2FkZWQgZmlyc3QnO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIGZhY3RvcnkoalF1ZXJ5LCBtb21lbnQpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4oZnVuY3Rpb24gKCQsIG1vbWVudCkge1xuICAgIGlmICh0eXBlb2YgbW9tZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBhbGVydChcIm1vbWVudGpzIGlzIHJlcXVyaWVkXCIpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21vbWVudGpzIGlzIHJlcXVpcmVkJyk7XG4gICAgfTtcblxuICAgIHZhciBkcGdJZCA9IDAsXG5cbiAgICBwTW9tZW50ID0gbW9tZW50LFxuXG4vLyBSZVNoYXJwZXIgZGlzYWJsZSBvbmNlIEluY29uc2lzdGVudE5hbWluZ1xuICAgIERhdGVUaW1lUGlja2VyID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICAgICAgcGlja0RhdGU6IHRydWUsXG4gICAgICAgICAgICBwaWNrVGltZTogdHJ1ZSxcbiAgICAgICAgICAgIHVzZU1pbnV0ZXM6IHRydWUsXG4gICAgICAgICAgICB1c2VTZWNvbmRzOiBmYWxzZSxcbiAgICAgICAgICAgIG1pbnV0ZVN0ZXBwaW5nOiAxLFxuICAgICAgICAgICAgc3RhcnREYXRlOiBuZXcgcE1vbWVudCh7IHk6IDE5NzAgfSksXG4gICAgICAgICAgICBlbmREYXRlOiBuZXcgcE1vbWVudCgpLmFkZCg1MCwgXCJ5XCIpLFxuICAgICAgICAgICAgY29sbGFwc2U6IHRydWUsXG4gICAgICAgICAgICBsYW5ndWFnZTogcE1vbWVudC5sYW5nKCksXG4gICAgICAgICAgICBkZWZhdWx0RGF0ZTogXCJcIixcbiAgICAgICAgICAgIGRpc2FibGVkRGF0ZXM6IFtdLFxuICAgICAgICAgICAgZW5hYmxlZERhdGVzOiBmYWxzZSxcbiAgICAgICAgICAgIGljb25zOiB7fSxcbiAgICAgICAgICAgIHVzZVN0cmljdDogZmFsc2UsXG4gICAgICAgICAgICBkaXJlY3Rpb246IFwiYXV0b1wiXG4gICAgICAgIH0sXG5cblx0XHRpY29ucyA9IHtcblx0XHQgICAgdGltZTogJ2dseXBoaWNvbiBnbHlwaGljb24tdGltZScsXG5cdFx0ICAgIGRhdGU6ICdnbHlwaGljb24gZ2x5cGhpY29uLWNhbGVuZGFyJyxcblx0XHQgICAgdXA6ICdnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tdXAnLFxuXHRcdCAgICBkb3duOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLWRvd24nXG5cdFx0fSxcblxuICAgICAgICBwaWNrZXIgPSB0aGlzLFxuXG4gICAgICAgIGluaXQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHZhciBpY29uID0gZmFsc2UsIGksIGREYXRlLCBsb25nRGF0ZUZvcm1hdDtcbiAgICAgICAgICAgIHBpY2tlci5vcHRpb25zID0gJC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHBpY2tlci5vcHRpb25zLmljb25zID0gJC5leHRlbmQoe30sIGljb25zLCBwaWNrZXIub3B0aW9ucy5pY29ucyk7XG5cbiAgICAgICAgICAgIHBpY2tlci5lbGVtZW50ID0gJChlbGVtZW50KTtcblxuICAgICAgICAgICAgZGF0YVRvT3B0aW9ucygpO1xuXG4gICAgICAgICAgICBpZiAoIShwaWNrZXIub3B0aW9ucy5waWNrVGltZSB8fCBwaWNrZXIub3B0aW9ucy5waWNrRGF0ZSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IGNob29zZSBhdCBsZWFzdCBvbmUgcGlja2VyJyk7XG5cbiAgICAgICAgICAgIHBpY2tlci5pZCA9IGRwZ0lkKys7XG4gICAgICAgICAgICBwTW9tZW50LmxhbmcocGlja2VyLm9wdGlvbnMubGFuZ3VhZ2UpO1xuICAgICAgICAgICAgcGlja2VyLmRhdGUgPSBwTW9tZW50KCk7XG4gICAgICAgICAgICBwaWNrZXIudW5zZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIHBpY2tlci5pc0lucHV0ID0gcGlja2VyLmVsZW1lbnQuaXMoJ2lucHV0Jyk7XG4gICAgICAgICAgICBwaWNrZXIuY29tcG9uZW50ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChwaWNrZXIuZWxlbWVudC5oYXNDbGFzcygnaW5wdXQtZ3JvdXAnKSkge1xuICAgICAgICAgICAgICAgIGlmIChwaWNrZXIuZWxlbWVudC5maW5kKCcuZGF0ZXBpY2tlcmJ1dHRvbicpLnNpemUoKSA9PSAwKSB7Ly9pbiBjYXNlIHRoZXJlIGlzIG1vcmUgdGhlbiBvbmUgJ2lucHV0LWdyb3VwLWFkZG9uYCAjNDhcbiAgICAgICAgICAgICAgICAgICAgcGlja2VyLmNvbXBvbmVudCA9IHBpY2tlci5lbGVtZW50LmZpbmQoXCJbY2xhc3NePSdpbnB1dC1ncm91cC0nXVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBpY2tlci5jb21wb25lbnQgPSBwaWNrZXIuZWxlbWVudC5maW5kKCcuZGF0ZXBpY2tlcmJ1dHRvbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBpY2tlci5mb3JtYXQgPSBwaWNrZXIub3B0aW9ucy5mb3JtYXQ7XG5cbiAgICAgICAgICAgIGxvbmdEYXRlRm9ybWF0ID0gcE1vbWVudCgpLl9sYW5nLl9sb25nRGF0ZUZvcm1hdDtcblxuICAgICAgICAgICAgaWYgKCFwaWNrZXIuZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHBpY2tlci5pc0lucHV0KSBwaWNrZXIuZm9ybWF0ID0gcGlja2VyLmVsZW1lbnQuZGF0YSgnZm9ybWF0Jyk7XG4gICAgICAgICAgICAgICAgZWxzZSBwaWNrZXIuZm9ybWF0ID0gcGlja2VyLmVsZW1lbnQuZmluZCgnaW5wdXQnKS5kYXRhKCdmb3JtYXQnKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBpY2tlci5mb3JtYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGlja2VyLmZvcm1hdCA9IChwaWNrZXIub3B0aW9ucy5waWNrRGF0ZSA/IGxvbmdEYXRlRm9ybWF0LkwgOiAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwaWNrZXIub3B0aW9ucy5waWNrRGF0ZSAmJiBwaWNrZXIub3B0aW9ucy5waWNrVGltZSkgcGlja2VyLmZvcm1hdCArPSAnICc7XG4gICAgICAgICAgICAgICAgICAgIHBpY2tlci5mb3JtYXQgKz0gKHBpY2tlci5vcHRpb25zLnBpY2tUaW1lID8gbG9uZ0RhdGVGb3JtYXQuTFQgOiAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwaWNrZXIub3B0aW9ucy51c2VTZWNvbmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAofmxvbmdEYXRlRm9ybWF0LkxULmluZGV4T2YoJyBBJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaWNrZXIuZm9ybWF0ID0gcGlja2VyLmZvcm1hdC5zcGxpdChcIiBBXCIpWzBdICsgXCI6c3MgQVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGlja2VyLmZvcm1hdCArPSAnOnNzJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGlja2VyLm9wdGlvbnMudXNlMjRob3VycyA9IHBpY2tlci5mb3JtYXQudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiYVwiKSA8IDE7XG5cbiAgICAgICAgICAgIGlmIChwaWNrZXIuY29tcG9uZW50KSBpY29uID0gcGlja2VyLmNvbXBvbmVudC5maW5kKCdzcGFuJyk7XG5cbiAgICAgICAgICAgIGlmIChwaWNrZXIub3B0aW9ucy5waWNrVGltZSkge1xuICAgICAgICAgICAgICAgIGlmIChpY29uKSBpY29uLmFkZENsYXNzKHBpY2tlci5vcHRpb25zLmljb25zLnRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBpY2tlci5vcHRpb25zLnBpY2tEYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGljb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbi5yZW1vdmVDbGFzcyhwaWNrZXIub3B0aW9ucy5pY29ucy50aW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWNvbi5hZGRDbGFzcyhwaWNrZXIub3B0aW9ucy5pY29ucy5kYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBpY2tlci53aWRnZXQgPSAkKGdldFRlbXBsYXRlKHBpY2tlci5vcHRpb25zLnBpY2tEYXRlLCBwaWNrZXIub3B0aW9ucy5waWNrVGltZSwgcGlja2VyLm9wdGlvbnMuY29sbGFwc2UpKS5hcHBlbmRUbygnYm9keScpO1xuICAgICAgICAgICAgcGlja2VyLm1pblZpZXdNb2RlID0gcGlja2VyLm9wdGlvbnMubWluVmlld01vZGUgfHwgcGlja2VyLmVsZW1lbnQuZGF0YSgnZGF0ZS1taW52aWV3bW9kZScpIHx8IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBpY2tlci5taW5WaWV3TW9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHBpY2tlci5taW5WaWV3TW9kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdtb250aHMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGlja2VyLm1pblZpZXdNb2RlID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd5ZWFycyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBwaWNrZXIubWluVmlld01vZGUgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBwaWNrZXIubWluVmlld01vZGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGlja2VyLnZpZXdNb2RlID0gcGlja2VyLm9wdGlvbnMudmlld01vZGUgfHwgcGlja2VyLmVsZW1lbnQuZGF0YSgnZGF0ZS12aWV3bW9kZScpIHx8IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBpY2tlci52aWV3TW9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHBpY2tlci52aWV3TW9kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdtb250aHMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGlja2VyLnZpZXdNb2RlID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd5ZWFycyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBwaWNrZXIudmlld01vZGUgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBwaWNrZXIudmlld01vZGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGlja2VyLm9wdGlvbnMuZGlzYWJsZWREYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGREYXRlID0gcGlja2VyLm9wdGlvbnMuZGlzYWJsZWREYXRlc1tpXTtcbiAgICAgICAgICAgICAgICBkRGF0ZSA9IHBNb21lbnQoZERhdGUpO1xuICAgICAgICAgICAgICAgIC8vaWYgdGhpcyBpcyBub3QgYSB2YWxpZCBkYXRlIHRoZW4gc2V0IGl0IHRvIHRoZSBzdGFydGRhdGUgLTEgZGF5IHNvIGl0J3MgZGlzYWJsZWQuXG4gICAgICAgICAgICAgICAgaWYgKCFkRGF0ZS5pc1ZhbGlkKCkpIGREYXRlID0gcE1vbWVudChwaWNrZXIub3B0aW9ucy5zdGFydERhdGUpLnN1YnRyYWN0KDEsIFwiZGF5XCIpO1xuICAgICAgICAgICAgICAgIHBpY2tlci5vcHRpb25zLmRpc2FibGVkRGF0ZXNbaV0gPSBkRGF0ZS5mb3JtYXQoXCJMXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGlja2VyLm9wdGlvbnMuZW5hYmxlZERhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZERhdGUgPSBwaWNrZXIub3B0aW9ucy5lbmFibGVkRGF0ZXNbaV07XG4gICAgICAgICAgICAgICAgZERhdGUgPSBwTW9tZW50KGREYXRlKTtcbiAgICAgICAgICAgICAgICAvL2lmIHRoaXMgaXMgbm90IGEgdmFsaWQgZGF0ZSB0aGVuIHNldCBpdCB0byB0aGUgc3RhcnRkYXRlIC0xIGRheSBzbyBpdCdzIGRpc2FibGVkLlxuICAgICAgICAgICAgICAgIGlmICghZERhdGUuaXNWYWxpZCgpKSBkRGF0ZSA9IHBNb21lbnQocGlja2VyLm9wdGlvbnMuc3RhcnREYXRlKS5zdWJ0cmFjdCgxLCBcImRheVwiKTtcbiAgICAgICAgICAgICAgICBwaWNrZXIub3B0aW9ucy5lbmFibGVkRGF0ZXNbaV0gPSBkRGF0ZS5mb3JtYXQoXCJMXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGlja2VyLnN0YXJ0Vmlld01vZGUgPSBwaWNrZXIudmlld01vZGU7XG4gICAgICAgICAgICBwaWNrZXIuc2V0U3RhcnREYXRlKHBpY2tlci5vcHRpb25zLnN0YXJ0RGF0ZSB8fCBwaWNrZXIuZWxlbWVudC5kYXRhKCdkYXRlLXN0YXJ0ZGF0ZScpKTtcbiAgICAgICAgICAgIHBpY2tlci5zZXRFbmREYXRlKHBpY2tlci5vcHRpb25zLmVuZERhdGUgfHwgcGlja2VyLmVsZW1lbnQuZGF0YSgnZGF0ZS1lbmRkYXRlJykpO1xuICAgICAgICAgICAgZmlsbERvdygpO1xuICAgICAgICAgICAgZmlsbE1vbnRocygpO1xuICAgICAgICAgICAgZmlsbEhvdXJzKCk7XG4gICAgICAgICAgICBmaWxsTWludXRlcygpO1xuXHRcdFx0ZmlsbFNlY29uZHMoKTtcbiAgICAgICAgICAgIHVwZGF0ZSgpO1xuICAgICAgICAgICAgc2hvd01vZGUoKTtcbiAgICAgICAgICAgIGF0dGFjaERhdGVQaWNrZXJFdmVudHMoKTtcbiAgICAgICAgICAgIGlmIChwaWNrZXIub3B0aW9ucy5kZWZhdWx0RGF0ZSAhPT0gXCJcIikgcGlja2VyLnNldFZhbHVlKHBpY2tlci5vcHRpb25zLmRlZmF1bHREYXRlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkYXRhVG9PcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGVEYXRhID0gcGlja2VyLmVsZW1lbnQuZGF0YSgpO1xuICAgICAgICAgICAgaWYgKGVEYXRhLnBpY2tkYXRlICE9PSB1bmRlZmluZWQpIHBpY2tlci5vcHRpb25zLnBpY2tEYXRlID0gZURhdGEucGlja2RhdGU7XG4gICAgICAgICAgICBpZiAoZURhdGEucGlja3RpbWUgIT09IHVuZGVmaW5lZCkgcGlja2VyLm9wdGlvbnMucGlja1RpbWUgPSBlRGF0YS5waWNrdGltZTtcbiAgICAgICAgICAgIGlmIChlRGF0YS51c2VtaW51dGVzICE9PSB1bmRlZmluZWQpIHBpY2tlci5vcHRpb25zLnVzZU1pbnV0ZXMgPSBlRGF0YS51c2VtaW51dGVzO1xuICAgICAgICAgICAgaWYgKGVEYXRhLnVzZXNlY29uZHMgIT09IHVuZGVmaW5lZCkgcGlja2VyLm9wdGlvbnMudXNlU2Vjb25kcyA9IGVEYXRhLnVzZXNlY29uZHM7XG4gICAgICAgICAgICBpZiAoZURhdGEubWludXRlc3RlcHBpbmcgIT09IHVuZGVmaW5lZCkgcGlja2VyLm9wdGlvbnMubWludXRlU3RlcHBpbmcgPSBlRGF0YS5taW51dGVzdGVwcGluZztcbiAgICAgICAgICAgIGlmIChlRGF0YS5zdGFydGRhdGUgIT09IHVuZGVmaW5lZCkgcGlja2VyLm9wdGlvbnMuc3RhcnREYXRlID0gZURhdGEuc3RhcnRkYXRlO1xuICAgICAgICAgICAgaWYgKGVEYXRhLmVuZGRhdGUgIT09IHVuZGVmaW5lZCkgcGlja2VyLm9wdGlvbnMuZW5kRGF0ZSA9IGVEYXRhLmVuZGRhdGU7XG4gICAgICAgICAgICBpZiAoZURhdGEuY29sbGFwc2UgIT09IHVuZGVmaW5lZCkgcGlja2VyLm9wdGlvbnMuY29sbGFwc2UgPSBlRGF0YS5jb2xsYXBzZTtcbiAgICAgICAgICAgIGlmIChlRGF0YS5sYW5ndWFnZSAhPT0gdW5kZWZpbmVkKSBwaWNrZXIub3B0aW9ucy5sYW5ndWFnZSA9IGVEYXRhLmxhbmd1YWdlO1xuICAgICAgICAgICAgaWYgKGVEYXRhLmRlZmF1bHRkYXRlICE9PSB1bmRlZmluZWQpIHBpY2tlci5vcHRpb25zLmRlZmF1bHREYXRlID0gZURhdGEuZGVmYXVsdGRhdGU7XG4gICAgICAgICAgICBpZiAoZURhdGEuZGlzYWJsZWRkYXRlcyAhPT0gdW5kZWZpbmVkKSBwaWNrZXIub3B0aW9ucy5kaXNhYmxlZERhdGVzID0gZURhdGEuZGlzYWJsZWRkYXRlcztcbiAgICAgICAgICAgIGlmIChlRGF0YS5lbmFibGVkZGF0ZXMgIT09IHVuZGVmaW5lZCkgcGlja2VyLm9wdGlvbnMuZW5hYmxlZERhdGVzID0gZURhdGEuZW5hYmxlZGRhdGVzO1xuICAgICAgICAgICAgaWYgKGVEYXRhLmljb25zICE9PSB1bmRlZmluZWQpIHBpY2tlci5vcHRpb25zLmljb25zID0gZURhdGEuaWNvbnM7XG4gICAgICAgICAgICBpZiAoZURhdGEudXNlc3RyaWN0ICE9PSB1bmRlZmluZWQpIHBpY2tlci5vcHRpb25zLnVzZVN0cmljdCA9IGVEYXRhLnVzZXN0cmljdDtcbiAgICAgICAgfSxcblxuICAgICAgICBwbGFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICBvZmZzZXQgPSBwaWNrZXIuY29tcG9uZW50ID8gcGlja2VyLmNvbXBvbmVudC5vZmZzZXQoKSA6IHBpY2tlci5lbGVtZW50Lm9mZnNldCgpLCAkd2luZG93ID0gJCh3aW5kb3cpO1xuICAgICAgICAgICAgcGlja2VyLndpZHRoID0gcGlja2VyLmNvbXBvbmVudCA/IHBpY2tlci5jb21wb25lbnQub3V0ZXJXaWR0aCgpIDogcGlja2VyLmVsZW1lbnQub3V0ZXJXaWR0aCgpO1xuICAgICAgICAgICAgb2Zmc2V0LnRvcCA9IG9mZnNldC50b3AgKyBwaWNrZXIuZWxlbWVudC5vdXRlckhlaWdodCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBpZiAocGlja2VyLm9wdGlvbnMuZGlyZWN0aW9uID09PSAndXAnIHx8IHBpY2tlci5vcHRpb25zLmRpcmVjdGlvbiA9PT0gJ2F1dG8nICYmIG9mZnNldC50b3AgKyBwaWNrZXIud2lkZ2V0LmhlaWdodCgpID4gJHdpbmRvdy5oZWlnaHQoKSkge1xuICAgICAgICBcdFx0Ly8gb2Zmc2V0LnRvcCAtPSBwaWNrZXIud2lkZ2V0LmhlaWdodCgpICsgcGlja2VyLmVsZW1lbnQub3V0ZXJIZWlnaHQoKTtcbiAgICAgICAgICAgIFx0Ly8gcGlja2VyLndpZGdldC5hZGRDbGFzcygndXAnKTtcbiAgICAgICAgICAgIC8vIH0gZWxzZSBpZiAocGlja2VyLm9wdGlvbnMuZGlyZWN0aW9uID09PSAnZG93bicgfHwgcGlja2VyLm9wdGlvbnMuZGlyZWN0aW9uID09PSAnYXV0bycgJiYgb2Zmc2V0LnRvcCArIHBpY2tlci53aWRnZXQuaGVpZ2h0KCkgPD0gJHdpbmRvdy5oZWlnaHQoKSkge1xuICAgICAgICAgICAgXHQvLyBvZmZzZXQudG9wICs9IHBpY2tlci5lbGVtZW50Lm91dGVySGVpZ2h0KCk7XG4gICAgICAgICAgICBcdC8vIHBpY2tlci53aWRnZXQuYWRkQ2xhc3MoJ2Rvd24nKTtcbiAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgaWYgKHBpY2tlci5vcHRpb25zLndpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwaWNrZXIud2lkZ2V0LndpZHRoKHBpY2tlci5vcHRpb25zLndpZHRoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBpY2tlci5vcHRpb25zLm9yaWVudGF0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgICAgICBwaWNrZXIud2lkZ2V0LmFkZENsYXNzKCdsZWZ0LW9yaWVudGVkJyk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0LmxlZnQgPSBvZmZzZXQubGVmdCAtIHBpY2tlci53aWRnZXQud2lkdGgoKSArIDIwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNJbkZpeGVkKCkpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICAgICAgICAgICAgb2Zmc2V0LnRvcCAtPSAkd2luZG93LnNjcm9sbFRvcCgpO1xuICAgICAgICAgICAgICAgIG9mZnNldC5sZWZ0IC09ICR3aW5kb3cuc2Nyb2xsTGVmdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoJHdpbmRvdy53aWR0aCgpIDwgb2Zmc2V0LmxlZnQgKyBwaWNrZXIud2lkZ2V0Lm91dGVyV2lkdGgoKSkge1xuICAgICAgICAgICAgICAgIG9mZnNldC5yaWdodCA9ICR3aW5kb3cud2lkdGgoKSAtIG9mZnNldC5sZWZ0IC0gcGlja2VyLndpZHRoO1xuICAgICAgICAgICAgICAgIG9mZnNldC5sZWZ0ID0gJ2F1dG8nO1xuICAgICAgICAgICAgICAgIHBpY2tlci53aWRnZXQuYWRkQ2xhc3MoJ3B1bGwtcmlnaHQnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0LnJpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICAgICAgICAgIHBpY2tlci53aWRnZXQucmVtb3ZlQ2xhc3MoJ3B1bGwtcmlnaHQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGlja2VyLndpZGdldC5jc3Moe1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICB0b3A6IG9mZnNldC50b3AsXG4gICAgICAgICAgICAgICAgbGVmdDogb2Zmc2V0LmxlZnQsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IG9mZnNldC5yaWdodFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbm90aWZ5Q2hhbmdlID0gZnVuY3Rpb24gKG9sZERhdGUsIGV2ZW50VHlwZSkge1xuICAgICAgICAgICAgcGlja2VyLmVsZW1lbnQudHJpZ2dlcih7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NoYW5nZS5kcCcsXG4gICAgICAgICAgICAgICAgZGF0ZTogcE1vbWVudChwaWNrZXIuZGF0ZSksXG4gICAgICAgICAgICAgICAgb2xkRGF0ZTogcE1vbWVudChvbGREYXRlKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChldmVudFR5cGUgIT09ICdjaGFuZ2UnKVxuICAgICAgICAgICAgICAgIHBpY2tlci5lbGVtZW50LmNoYW5nZSgpO1xuICAgICAgICB9LFxuXG5cdFx0bm90aWZ5RXJyb3IgPSBmdW5jdGlvbiAoZGF0ZSkge1xuXHRcdCAgICBwaWNrZXIuZWxlbWVudC50cmlnZ2VyKHtcblx0XHQgICAgICAgIHR5cGU6ICdlcnJvci5kcCcsXG5cdFx0ICAgICAgICBkYXRlOiBwTW9tZW50KGRhdGUpXG5cdFx0ICAgIH0pO1xuXHRcdH0sXG5cbiAgICAgICAgdXBkYXRlID0gZnVuY3Rpb24gKG5ld0RhdGUpIHtcbiAgICAgICAgICAgIHBNb21lbnQubGFuZyhwaWNrZXIub3B0aW9ucy5sYW5ndWFnZSk7XG4gICAgICAgICAgICB2YXIgZGF0ZVN0ciA9IG5ld0RhdGU7XG4gICAgICAgICAgICBpZiAoIWRhdGVTdHIpIHtcbiAgICAgICAgICAgICAgICBpZiAocGlja2VyLmlzSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVN0ciA9IHBpY2tlci5lbGVtZW50LnZhbCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVTdHIgPSBwaWNrZXIuZWxlbWVudC5maW5kKCdpbnB1dCcpLnZhbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF0ZVN0cikgcGlja2VyLmRhdGUgPSBwTW9tZW50KGRhdGVTdHIsIHBpY2tlci5mb3JtYXQsIHBpY2tlci5vcHRpb25zLnVzZVN0cmljdCk7XG4gICAgICAgICAgICAgICAgaWYgKCFwaWNrZXIuZGF0ZSkgcGlja2VyLmRhdGUgPSBwTW9tZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwaWNrZXIudmlld0RhdGUgPSBwTW9tZW50KHBpY2tlci5kYXRlKS5zdGFydE9mKFwibW9udGhcIik7XG4gICAgICAgICAgICBmaWxsRGF0ZSgpO1xuICAgICAgICAgICAgZmlsbFRpbWUoKTtcbiAgICAgICAgfSxcblxuXHRcdGZpbGxEb3cgPSBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgIHBNb21lbnQubGFuZyhwaWNrZXIub3B0aW9ucy5sYW5ndWFnZSk7XG5cdFx0ICAgIHZhciBodG1sID0gJCgnPHRyPicpLCB3ZWVrZGF5c01pbiA9IHBNb21lbnQud2Vla2RheXNNaW4oKSwgaTtcblx0XHQgICAgaWYgKHBNb21lbnQoKS5fbGFuZy5fd2Vlay5kb3cgPT0gMCkgeyAvLyBzdGFydHMgb24gU3VuZGF5XG5cdFx0ICAgICAgICBmb3IoaSA9IDA7IGkgPCA3OyBpKyspIHtcblx0XHQgICAgICAgICAgICBodG1sLmFwcGVuZCgnPHRoIGNsYXNzPVwiZG93XCI+JyArIHdlZWtkYXlzTWluW2ldICsgJzwvdGg+Jyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH0gZWxzZSB7XG5cdFx0ICAgICAgICBmb3IgKGkgPSAxOyBpIDwgODsgaSsrKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKGkgPT0gNykge1xuXHRcdCAgICAgICAgICAgICAgICBodG1sLmFwcGVuZCgnPHRoIGNsYXNzPVwiZG93XCI+JyArIHdlZWtkYXlzTWluWzBdICsgJzwvdGg+Jyk7XG5cdFx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0XHQgICAgICAgICAgICAgICAgaHRtbC5hcHBlbmQoJzx0aCBjbGFzcz1cImRvd1wiPicgKyB3ZWVrZGF5c01pbltpXSArICc8L3RoPicpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICBwaWNrZXIud2lkZ2V0LmZpbmQoJy5kYXRlcGlja2VyLWRheXMgdGhlYWQnKS5hcHBlbmQoaHRtbCk7XG5cdFx0fSxcblxuICAgICAgICBmaWxsTW9udGhzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcE1vbWVudC5sYW5nKHBpY2tlci5vcHRpb25zLmxhbmd1YWdlKTtcbiAgICAgICAgICAgIHZhciBodG1sID0gJycsIGkgPSAwLCBtb250aHNTaG9ydCA9IHBNb21lbnQubW9udGhzU2hvcnQoKTtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgMTIpIHtcbiAgICAgICAgICAgICAgICBodG1sICs9ICc8c3BhbiBjbGFzcz1cIm1vbnRoXCI+JyArIG1vbnRoc1Nob3J0W2krK10gKyAnPC9zcGFuPic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwaWNrZXIud2lkZ2V0LmZpbmQoJy5kYXRlcGlja2VyLW1vbnRocyB0ZCcpLmFwcGVuZChodG1sKTtcbiAgICAgICAgfSxcblxuICAgICAgICBmaWxsRGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHBNb21lbnQubGFuZyhwaWNrZXIub3B0aW9ucy5sYW5ndWFnZSk7XG4gICAgICAgICAgICB2YXIgeWVhciA9IHBpY2tlci52aWV3RGF0ZS55ZWFyKCksXG4gICAgICAgICAgICAgICAgbW9udGggPSBwaWNrZXIudmlld0RhdGUubW9udGgoKSxcbiAgICAgICAgICAgICAgICBzdGFydFllYXIgPSBwaWNrZXIub3B0aW9ucy5zdGFydERhdGUueWVhcigpLFxuICAgICAgICAgICAgICAgIHN0YXJ0TW9udGggPSBwaWNrZXIub3B0aW9ucy5zdGFydERhdGUubW9udGgoKSxcbiAgICAgICAgICAgICAgICBlbmRZZWFyID0gcGlja2VyLm9wdGlvbnMuZW5kRGF0ZS55ZWFyKCksXG4gICAgICAgICAgICAgICAgZW5kTW9udGggPSBwaWNrZXIub3B0aW9ucy5lbmREYXRlLm1vbnRoKCksXG4gICAgICAgICAgICAgICAgcHJldk1vbnRoLCBuZXh0TW9udGgsIGh0bWwgPSBbXSwgcm93LCBjbHNOYW1lLCBpLCBkYXlzLCB5ZWFyQ29udCwgY3VycmVudFllYXIsIG1vbnRocyA9IHBNb21lbnQubW9udGhzKCk7XG5cbiAgICAgICAgICAgIHBpY2tlci53aWRnZXQuZmluZCgnLmRhdGVwaWNrZXItZGF5cycpLmZpbmQoJy5kaXNhYmxlZCcpLnJlbW92ZUNsYXNzKCdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgcGlja2VyLndpZGdldC5maW5kKCcuZGF0ZXBpY2tlci1tb250aHMnKS5maW5kKCcuZGlzYWJsZWQnKS5yZW1vdmVDbGFzcygnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIHBpY2tlci53aWRnZXQuZmluZCgnLmRhdGVwaWNrZXIteWVhcnMnKS5maW5kKCcuZGlzYWJsZWQnKS5yZW1vdmVDbGFzcygnZGlzYWJsZWQnKTtcblxuICAgICAgICAgICAgcGlja2VyLndpZGdldC5maW5kKCcuZGF0ZXBpY2tlci1kYXlzIHRoOmVxKDEpJykudGV4dChcbiAgICAgICAgICAgICAgICBtb250aHNbbW9udGhdICsgJyAnICsgeWVhcik7XG5cbiAgICAgICAgICAgIHByZXZNb250aCA9IHBNb21lbnQocGlja2VyLnZpZXdEYXRlKS5zdWJ0cmFjdChcIm1vbnRoc1wiLCAxKTtcbiAgICAgICAgICAgIGRheXMgPSBwcmV2TW9udGguZGF5c0luTW9udGgoKTtcbiAgICAgICAgICAgIHByZXZNb250aC5kYXRlKGRheXMpLnN0YXJ0T2YoJ3dlZWsnKTtcbiAgICAgICAgICAgIGlmICgoeWVhciA9PSBzdGFydFllYXIgJiYgbW9udGggPD0gc3RhcnRNb250aCkgfHwgeWVhciA8IHN0YXJ0WWVhcikge1xuICAgICAgICAgICAgICAgIHBpY2tlci53aWRnZXQuZmluZCgnLmRhdGVwaWNrZXItZGF5cyB0aDplcSgwKScpLmFkZENsYXNzKCdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh5ZWFyID09IGVuZFllYXIgJiYgbW9udGggPj0gZW5kTW9udGgpIHx8IHllYXIgPiBlbmRZZWFyKSB7XG4gICAgICAgICAgICAgICAgcGlja2VyLndpZGdldC5maW5kKCcuZGF0ZXBpY2tlci1kYXlzIHRoOmVxKDIpJykuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5leHRNb250aCA9IHBNb21lbnQocHJldk1vbnRoKS5hZGQoNDIsIFwiZFwiKTtcbiAgICAgICAgICAgIHdoaWxlIChwcmV2TW9udGguaXNCZWZvcmUobmV4dE1vbnRoKSkge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2TW9udGgud2Vla2RheSgpID09PSBwTW9tZW50KCkuc3RhcnRPZignd2VlaycpLndlZWtkYXkoKSkge1xuICAgICAgICAgICAgICAgICAgICByb3cgPSAkKCc8dHI+Jyk7XG4gICAgICAgICAgICAgICAgICAgIGh0bWwucHVzaChyb3cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbHNOYW1lID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZNb250aC55ZWFyKCkgPCB5ZWFyIHx8IChwcmV2TW9udGgueWVhcigpID09IHllYXIgJiYgcHJldk1vbnRoLm1vbnRoKCkgPCBtb250aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xzTmFtZSArPSAnIG9sZCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2TW9udGgueWVhcigpID4geWVhciB8fCAocHJldk1vbnRoLnllYXIoKSA9PSB5ZWFyICYmIHByZXZNb250aC5tb250aCgpID4gbW9udGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsc05hbWUgKz0gJyBuZXcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJldk1vbnRoLmlzU2FtZShwTW9tZW50KHsgeTogcGlja2VyLmRhdGUueWVhcigpLCBNOiBwaWNrZXIuZGF0ZS5tb250aCgpLCBkOiBwaWNrZXIuZGF0ZS5kYXRlKCkgfSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsc05hbWUgKz0gJyBhY3RpdmUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNJbkRpc2FibGVEYXRlcyhwcmV2TW9udGgpIHx8ICFpc0luRW5hYmxlRGF0ZXMocHJldk1vbnRoKSkge1xuICAgICAgICAgICAgICAgICAgICBjbHNOYW1lICs9ICcgZGlzYWJsZWQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByb3cuYXBwZW5kKCc8dGQgY2xhc3M9XCJkYXknICsgY2xzTmFtZSArICdcIj4nICsgcHJldk1vbnRoLmRhdGUoKSArICc8L3RkPicpO1xuICAgICAgICAgICAgICAgIHByZXZNb250aC5hZGQoMSwgXCJkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGlja2VyLndpZGdldC5maW5kKCcuZGF0ZXBpY2tlci1kYXlzIHRib2R5JykuZW1wdHkoKS5hcHBlbmQoaHRtbCk7XG4gICAgICAgICAgICBjdXJyZW50WWVhciA9IHBNb21lbnQoKS55ZWFyKCksIG1vbnRocyA9IHBpY2tlci53aWRnZXQuZmluZCgnLmRhdGVwaWNrZXItbW9udGhzJylcblx0XHRcdFx0LmZpbmQoJ3RoOmVxKDEpJykudGV4dCh5ZWFyKS5lbmQoKS5maW5kKCdzcGFuJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRZZWFyID09PSB5ZWFyKSB7XG4gICAgICAgICAgICAgICAgbW9udGhzLmVxKHBNb21lbnQoKS5tb250aCgpKS5hZGRDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudFllYXIgLSAxIDwgc3RhcnRZZWFyKSB7XG4gICAgICAgICAgICAgICAgcGlja2VyLndpZGdldC5maW5kKCcuZGF0ZXBpY2tlci1tb250aHMgdGg6ZXEoMCknKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50WWVhciArIDEgPiBlbmRZZWFyKSB7XG4gICAgICAgICAgICAgICAgcGlja2VyLndpZGdldC5maW5kKCcuZGF0ZXBpY2tlci1tb250aHMgdGg6ZXEoMiknKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCh5ZWFyID09IHN0YXJ0WWVhciAmJiBzdGFydE1vbnRoID4gaSkgfHwgKHllYXIgPCBzdGFydFllYXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICQobW9udGhzW2ldKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCh5ZWFyID09IGVuZFllYXIgJiYgZW5kTW9udGggPCBpKSB8fCAoeWVhciA+IGVuZFllYXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICQobW9udGhzW2ldKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGh0bWwgPSAnJztcbiAgICAgICAgICAgIHllYXIgPSBwYXJzZUludCh5ZWFyIC8gMTAsIDEwKSAqIDEwO1xuICAgICAgICAgICAgeWVhckNvbnQgPSBwaWNrZXIud2lkZ2V0LmZpbmQoJy5kYXRlcGlja2VyLXllYXJzJykuZmluZChcbiAgICAgICAgICAgICAgICAndGg6ZXEoMSknKS50ZXh0KHllYXIgKyAnLScgKyAoeWVhciArIDkpKS5lbmQoKS5maW5kKCd0ZCcpO1xuICAgICAgICAgICAgcGlja2VyLndpZGdldC5maW5kKCcuZGF0ZXBpY2tlci15ZWFycycpLmZpbmQoJ3RoJykucmVtb3ZlQ2xhc3MoJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICBpZiAoc3RhcnRZZWFyID4geWVhcikge1xuICAgICAgICAgICAgICAgIHBpY2tlci53aWRnZXQuZmluZCgnLmRhdGVwaWNrZXIteWVhcnMnKS5maW5kKCd0aDplcSgwKScpLmFkZENsYXNzKCdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZFllYXIgPCB5ZWFyICsgOSkge1xuICAgICAgICAgICAgICAgIHBpY2tlci53aWRnZXQuZmluZCgnLmRhdGVwaWNrZXIteWVhcnMnKS5maW5kKCd0aDplcSgyKScpLmFkZENsYXNzKCdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWVhciAtPSAxO1xuICAgICAgICAgICAgZm9yIChpID0gLTE7IGkgPCAxMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPHNwYW4gY2xhc3M9XCJ5ZWFyJyArIChpID09PSAtMSB8fCBpID09PSAxMCA/ICcgb2xkJyA6ICcnKSArIChjdXJyZW50WWVhciA9PT0geWVhciA/ICcgYWN0aXZlJyA6ICcnKSArICgoeWVhciA8IHN0YXJ0WWVhciB8fCB5ZWFyID4gZW5kWWVhcikgPyAnIGRpc2FibGVkJyA6ICcnKSArICdcIj4nICsgeWVhciArICc8L3NwYW4+JztcbiAgICAgICAgICAgICAgICB5ZWFyICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5ZWFyQ29udC5odG1sKGh0bWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbGxIb3VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHBNb21lbnQubGFuZyhwaWNrZXIub3B0aW9ucy5sYW5ndWFnZSk7XG4gICAgICAgICAgICB2YXIgdGFibGUgPSBwaWNrZXIud2lkZ2V0LmZpbmQoJy50aW1lcGlja2VyIC50aW1lcGlja2VyLWhvdXJzIHRhYmxlJyksIGh0bWwgPSAnJywgY3VycmVudCwgaSwgajtcbiAgICAgICAgICAgIHRhYmxlLnBhcmVudCgpLmhpZGUoKTtcbiAgICAgICAgICAgIGlmIChwaWNrZXIub3B0aW9ucy51c2UyNGhvdXJzKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDY7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBodG1sICs9ICc8dHI+JztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IDQ7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnPHRkIGNsYXNzPVwiaG91clwiPicgKyBwYWRMZWZ0KGN1cnJlbnQudG9TdHJpbmcoKSkgKyAnPC90ZD4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJzwvdHI+JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gMTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMzsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJzx0cj4nO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgNDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sICs9ICc8dGQgY2xhc3M9XCJob3VyXCI+JyArIHBhZExlZnQoY3VycmVudC50b1N0cmluZygpKSArICc8L3RkPic7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnPC90cj4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhYmxlLmh0bWwoaHRtbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmlsbE1pbnV0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGFibGUgPSBwaWNrZXIud2lkZ2V0LmZpbmQoJy50aW1lcGlja2VyIC50aW1lcGlja2VyLW1pbnV0ZXMgdGFibGUnKSwgaHRtbCA9ICcnLCBjdXJyZW50ID0gMCwgaSwgajtcbiAgICAgICAgICAgIHRhYmxlLnBhcmVudCgpLmhpZGUoKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgICAgICAgICBodG1sICs9ICc8dHI+JztcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgNDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJzx0ZCBjbGFzcz1cIm1pbnV0ZVwiPicgKyBwYWRMZWZ0KGN1cnJlbnQudG9TdHJpbmcoKSkgKyAnPC90ZD4nO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ICs9IDM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGh0bWwgKz0gJzwvdHI+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhYmxlLmh0bWwoaHRtbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmlsbFNlY29uZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGFibGUgPSBwaWNrZXIud2lkZ2V0LmZpbmQoJy50aW1lcGlja2VyIC50aW1lcGlja2VyLXNlY29uZHMgdGFibGUnKSwgaHRtbCA9ICcnLCBjdXJyZW50ID0gMCwgaSwgajtcbiAgICAgICAgICAgIHRhYmxlLnBhcmVudCgpLmhpZGUoKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgICAgICAgICBodG1sICs9ICc8dHI+JztcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgNDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICBodG1sICs9ICc8dGQgY2xhc3M9XCJzZWNvbmRcIj4nICsgcGFkTGVmdChjdXJyZW50LnRvU3RyaW5nKCkpICsgJzwvdGQ+JztcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPC90cj4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFibGUuaHRtbChodG1sKTtcbiAgICAgICAgfSxcblxuICAgICAgICBmaWxsVGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghcGlja2VyLmRhdGUpIHJldHVybjtcbiAgICAgICAgICAgIHZhciB0aW1lQ29tcG9uZW50cyA9IHBpY2tlci53aWRnZXQuZmluZCgnLnRpbWVwaWNrZXIgc3BhbltkYXRhLXRpbWUtY29tcG9uZW50XScpLFxuICAgICAgICAgICAgaG91ciA9IHBpY2tlci5kYXRlLmhvdXJzKCksXG4gICAgICAgICAgICBwZXJpb2QgPSAnQU0nO1xuICAgICAgICAgICAgaWYgKCFwaWNrZXIub3B0aW9ucy51c2UyNGhvdXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhvdXIgPj0gMTIpIHBlcmlvZCA9ICdQTSc7XG4gICAgICAgICAgICAgICAgaWYgKGhvdXIgPT09IDApIGhvdXIgPSAxMjtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChob3VyICE9IDEyKSBob3VyID0gaG91ciAlIDEyO1xuICAgICAgICAgICAgICAgIHBpY2tlci53aWRnZXQuZmluZCgnLnRpbWVwaWNrZXIgW2RhdGEtYWN0aW9uPXRvZ2dsZVBlcmlvZF0nKS50ZXh0KHBlcmlvZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aW1lQ29tcG9uZW50cy5maWx0ZXIoJ1tkYXRhLXRpbWUtY29tcG9uZW50PWhvdXJzXScpLnRleHQocGFkTGVmdChob3VyKSk7XG4gICAgICAgICAgICB0aW1lQ29tcG9uZW50cy5maWx0ZXIoJ1tkYXRhLXRpbWUtY29tcG9uZW50PW1pbnV0ZXNdJykudGV4dChwYWRMZWZ0KHBpY2tlci5kYXRlLm1pbnV0ZXMoKSkpO1xuICAgICAgICAgICAgdGltZUNvbXBvbmVudHMuZmlsdGVyKCdbZGF0YS10aW1lLWNvbXBvbmVudD1zZWNvbmRzXScpLnRleHQocGFkTGVmdChwaWNrZXIuZGF0ZS5zZWNvbmQoKSkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsaWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBwaWNrZXIudW5zZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSAkKGUudGFyZ2V0KS5jbG9zZXN0KCdzcGFuLCB0ZCwgdGgnKSwgbW9udGgsIHllYXIsIHN0ZXAsIGRheSwgb2xkRGF0ZSA9IHBNb21lbnQocGlja2VyLmRhdGUpO1xuICAgICAgICAgICAgaWYgKHRhcmdldC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRhcmdldC5pcygnLmRpc2FibGVkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0YXJnZXRbMF0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndGgnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGFyZ2V0WzBdLmNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzd2l0Y2gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvd01vZGUoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncHJldic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ25leHQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcCA9IGRwR2xvYmFsLm1vZGVzW3BpY2tlci52aWV3TW9kZV0ubmF2U3RlcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRbMF0uY2xhc3NOYW1lID09PSAncHJldicpIHN0ZXAgPSBzdGVwICogLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaWNrZXIudmlld0RhdGUuYWRkKHN0ZXAsIGRwR2xvYmFsLm1vZGVzW3BpY2tlci52aWV3TW9kZV0ubmF2Rm5jKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxEYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzcGFuJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmlzKCcubW9udGgnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb250aCA9IHRhcmdldC5wYXJlbnQoKS5maW5kKCdzcGFuJykuaW5kZXgodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGlja2VyLnZpZXdEYXRlLm1vbnRoKG1vbnRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ZWFyID0gcGFyc2VJbnQodGFyZ2V0LnRleHQoKSwgMTApIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpY2tlci52aWV3RGF0ZS55ZWFyKHllYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGlja2VyLnZpZXdNb2RlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpY2tlci5kYXRlID0gcE1vbWVudCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBwaWNrZXIudmlld0RhdGUueWVhcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTTogcGlja2VyLnZpZXdEYXRlLm1vbnRoKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkOiBwaWNrZXIudmlld0RhdGUuZGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaDogcGlja2VyLmRhdGUuaG91cnMoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG06IHBpY2tlci5kYXRlLm1pbnV0ZXMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZ5Q2hhbmdlKG9sZERhdGUsIGUudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dNb2RlKC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndGQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuaXMoJy5kYXknKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXkgPSBwYXJzZUludCh0YXJnZXQudGV4dCgpLCAxMCkgfHwgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9udGggPSBwaWNrZXIudmlld0RhdGUubW9udGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWVhciA9IHBpY2tlci52aWV3RGF0ZS55ZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuaXMoJy5vbGQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vbnRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9udGggPSAxMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ZWFyIC09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoIC09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0LmlzKCcubmV3JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb250aCA9PSAxMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ZWFyICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGlja2VyLmRhdGUgPSBwTW9tZW50KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHllYXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNOiBtb250aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQ6IGRheSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGg6IHBpY2tlci5kYXRlLmhvdXJzKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtOiBwaWNrZXIuZGF0ZS5taW51dGVzKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaWNrZXIudmlld0RhdGUgPSBwTW9tZW50KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHllYXIsIE06IG1vbnRoLCBkOiBNYXRoLm1pbigyOCwgZGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmeUNoYW5nZShvbGREYXRlLCBlLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuXHRcdGFjdGlvbnMgPSB7XG5cdFx0ICAgIGluY3JlbWVudEhvdXJzOiBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICBjaGVja0RhdGUoXCJhZGRcIiwgXCJob3Vyc1wiLCAxKTtcblx0XHQgICAgfSxcblxuXHRcdCAgICBpbmNyZW1lbnRNaW51dGVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICBjaGVja0RhdGUoXCJhZGRcIiwgXCJtaW51dGVzXCIsIHBpY2tlci5vcHRpb25zLm1pbnV0ZVN0ZXBwaW5nKTtcblx0XHQgICAgfSxcblxuXHRcdCAgICBpbmNyZW1lbnRTZWNvbmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICBjaGVja0RhdGUoXCJhZGRcIiwgXCJzZWNvbmRzXCIsIDEpO1xuXHRcdCAgICB9LFxuXG5cdFx0ICAgIGRlY3JlbWVudEhvdXJzOiBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICBjaGVja0RhdGUoXCJzdWJ0cmFjdFwiLCBcImhvdXJzXCIsIDEpO1xuXHRcdCAgICB9LFxuXG5cdFx0ICAgIGRlY3JlbWVudE1pbnV0ZXM6IGZ1bmN0aW9uICgpIHtcblx0XHQgICAgICAgIGNoZWNrRGF0ZShcInN1YnRyYWN0XCIsIFwibWludXRlc1wiLCBwaWNrZXIub3B0aW9ucy5taW51dGVTdGVwcGluZyk7XG5cdFx0ICAgIH0sXG5cblx0XHQgICAgZGVjcmVtZW50U2Vjb25kczogZnVuY3Rpb24gKCkge1xuXHRcdCAgICAgICAgY2hlY2tEYXRlKFwic3VidHJhY3RcIiwgXCJzZWNvbmRzXCIsIDEpO1xuXHRcdCAgICB9LFxuXG5cdFx0ICAgIHRvZ2dsZVBlcmlvZDogZnVuY3Rpb24gKCkge1xuXHRcdCAgICAgICAgdmFyIGhvdXIgPSBwaWNrZXIuZGF0ZS5ob3VycygpO1xuXHRcdCAgICAgICAgaWYgKGhvdXIgPj0gMTIpIGhvdXIgLT0gMTI7XG5cdFx0ICAgICAgICBlbHNlIGhvdXIgKz0gMTI7XG5cdFx0ICAgICAgICBwaWNrZXIuZGF0ZS5ob3Vycyhob3VyKTtcblx0XHQgICAgfSxcblxuXHRcdCAgICBzaG93UGlja2VyOiBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICBwaWNrZXIud2lkZ2V0LmZpbmQoJy50aW1lcGlja2VyID4gZGl2Om5vdCgudGltZXBpY2tlci1waWNrZXIpJykuaGlkZSgpO1xuXHRcdCAgICAgICAgcGlja2VyLndpZGdldC5maW5kKCcudGltZXBpY2tlciAudGltZXBpY2tlci1waWNrZXInKS5zaG93KCk7XG5cdFx0ICAgIH0sXG5cblx0XHQgICAgc2hvd0hvdXJzOiBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICBwaWNrZXIud2lkZ2V0LmZpbmQoJy50aW1lcGlja2VyIC50aW1lcGlja2VyLXBpY2tlcicpLmhpZGUoKTtcblx0XHQgICAgICAgIHBpY2tlci53aWRnZXQuZmluZCgnLnRpbWVwaWNrZXIgLnRpbWVwaWNrZXItaG91cnMnKS5zaG93KCk7XG5cdFx0ICAgIH0sXG5cblx0XHQgICAgc2hvd01pbnV0ZXM6IGZ1bmN0aW9uICgpIHtcblx0XHQgICAgICAgIHBpY2tlci53aWRnZXQuZmluZCgnLnRpbWVwaWNrZXIgLnRpbWVwaWNrZXItcGlja2VyJykuaGlkZSgpO1xuXHRcdCAgICAgICAgcGlja2VyLndpZGdldC5maW5kKCcudGltZXBpY2tlciAudGltZXBpY2tlci1taW51dGVzJykuc2hvdygpO1xuXHRcdCAgICB9LFxuXG5cdFx0ICAgIHNob3dTZWNvbmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICBwaWNrZXIud2lkZ2V0LmZpbmQoJy50aW1lcGlja2VyIC50aW1lcGlja2VyLXBpY2tlcicpLmhpZGUoKTtcblx0XHQgICAgICAgIHBpY2tlci53aWRnZXQuZmluZCgnLnRpbWVwaWNrZXIgLnRpbWVwaWNrZXItc2Vjb25kcycpLnNob3coKTtcblx0XHQgICAgfSxcblxuXHRcdCAgICBzZWxlY3RIb3VyOiBmdW5jdGlvbiAoZSkge1xuXHRcdCAgICAgICAgcGlja2VyLmRhdGUuaG91cnMocGFyc2VJbnQoJChlLnRhcmdldCkudGV4dCgpLCAxMCkpO1xuXHRcdCAgICAgICAgYWN0aW9ucy5zaG93UGlja2VyLmNhbGwocGlja2VyKTtcblx0XHQgICAgfSxcblxuXHRcdCAgICBzZWxlY3RNaW51dGU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0ICAgICAgICBwaWNrZXIuZGF0ZS5taW51dGVzKHBhcnNlSW50KCQoZS50YXJnZXQpLnRleHQoKSwgMTApKTtcblx0XHQgICAgICAgIGFjdGlvbnMuc2hvd1BpY2tlci5jYWxsKHBpY2tlcik7XG5cdFx0ICAgIH0sXG5cblx0XHQgICAgc2VsZWN0U2Vjb25kOiBmdW5jdGlvbiAoZSkge1xuXHRcdCAgICAgICAgcGlja2VyLmRhdGUuc2Vjb25kcyhwYXJzZUludCgkKGUudGFyZ2V0KS50ZXh0KCksIDEwKSk7XG5cdFx0ICAgICAgICBhY3Rpb25zLnNob3dQaWNrZXIuY2FsbChwaWNrZXIpO1xuXHRcdCAgICB9XG5cdFx0fSxcblxuXHQgICAgZG9BY3Rpb24gPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIHZhciBvbGREYXRlID0gcE1vbWVudChwaWNrZXIuZGF0ZSksIGFjdGlvbiA9ICQoZS5jdXJyZW50VGFyZ2V0KS5kYXRhKCdhY3Rpb24nKSwgcnYgPSBhY3Rpb25zW2FjdGlvbl0uYXBwbHkocGlja2VyLCBhcmd1bWVudHMpO1xuXHQgICAgICAgIHN0b3BFdmVudChlKTtcblx0ICAgICAgICBpZiAoIXBpY2tlci5kYXRlKSBwaWNrZXIuZGF0ZSA9IHBNb21lbnQoeyB5OiAxOTcwIH0pO1xuXHQgICAgICAgIHNldCgpO1xuXHQgICAgICAgIGZpbGxUaW1lKCk7XG5cdCAgICAgICAgbm90aWZ5Q2hhbmdlKG9sZERhdGUsIGUudHlwZSk7XG5cdCAgICAgICAgcmV0dXJuIHJ2O1xuXHQgICAgfSxcblxuICAgICAgICBzdG9wRXZlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjaGFuZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcE1vbWVudC5sYW5nKHBpY2tlci5vcHRpb25zLmxhbmd1YWdlKTtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9ICQoZS50YXJnZXQpLCBvbGREYXRlID0gcE1vbWVudChwaWNrZXIuZGF0ZSksIG5ld0RhdGUgPSBwTW9tZW50KGlucHV0LnZhbCgpLCBwaWNrZXIuZm9ybWF0LCBwaWNrZXIub3B0aW9ucy51c2VTdHJpY3QpO1xuICAgICAgICAgICAgaWYgKG5ld0RhdGUuaXNWYWxpZCgpICYmICFpc0luRGlzYWJsZURhdGVzKG5ld0RhdGUpICYmIGlzSW5FbmFibGVEYXRlcyhuZXdEYXRlKSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIHBpY2tlci5zZXRWYWx1ZShuZXdEYXRlKTtcbiAgICAgICAgICAgICAgICBub3RpZnlDaGFuZ2Uob2xkRGF0ZSwgZS50eXBlKTtcbiAgICAgICAgICAgICAgICBzZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBpY2tlci52aWV3RGF0ZSA9IG9sZERhdGU7XG4gICAgICAgICAgICAgICAgaW5wdXQudmFsKHBNb21lbnQob2xkRGF0ZSkuZm9ybWF0KHBpY2tlci5mb3JtYXQpKTtcbiAgICAgICAgICAgICAgICAvL3BpY2tlci5zZXRWYWx1ZShcIlwiKTsgLy8gdW5zZXQgdGhlIGRhdGUgd2hlbiB0aGUgaW5wdXQgaXMgZXJhc2VkXG4gICAgICAgICAgICAgICAgbm90aWZ5Q2hhbmdlKG9sZERhdGUsIGUudHlwZSk7XG4gICAgICAgICAgICAgICAgbm90aWZ5RXJyb3IobmV3RGF0ZSk7XG4gICAgICAgICAgICAgICAgcGlja2VyLnVuc2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzaG93TW9kZSA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgICAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgICAgICAgICBwaWNrZXIudmlld01vZGUgPSBNYXRoLm1heChwaWNrZXIubWluVmlld01vZGUsIE1hdGgubWluKDIsIHBpY2tlci52aWV3TW9kZSArIGRpcikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwaWNrZXIud2lkZ2V0LmZpbmQoJy5kYXRlcGlja2VyID4gZGl2JykuaGlkZSgpLmZpbHRlcignLmRhdGVwaWNrZXItJyArIGRwR2xvYmFsLm1vZGVzW3BpY2tlci52aWV3TW9kZV0uY2xzTmFtZSkuc2hvdygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGF0dGFjaERhdGVQaWNrZXJFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgJHRoaXMsICRwYXJlbnQsIGV4cGFuZGVkLCBjbG9zZWQsIGNvbGxhcHNlRGF0YTtcbiAgICAgICAgICAgIHBpY2tlci53aWRnZXQub24oJ2NsaWNrJywgJy5kYXRlcGlja2VyIConLCAkLnByb3h5KGNsaWNrLCB0aGlzKSk7IC8vIHRoaXMgaGFuZGxlcyBkYXRlIHBpY2tlciBjbGlja3NcbiAgICAgICAgICAgIHBpY2tlci53aWRnZXQub24oJ2NsaWNrJywgJ1tkYXRhLWFjdGlvbl0nLCAkLnByb3h5KGRvQWN0aW9uLCB0aGlzKSk7IC8vIHRoaXMgaGFuZGxlcyB0aW1lIHBpY2tlciBjbGlja3NcbiAgICAgICAgICAgIHBpY2tlci53aWRnZXQub24oJ21vdXNlZG93bicsICQucHJveHkoc3RvcEV2ZW50LCB0aGlzKSk7XG4gICAgICAgICAgICBpZiAocGlja2VyLm9wdGlvbnMucGlja0RhdGUgJiYgcGlja2VyLm9wdGlvbnMucGlja1RpbWUpIHtcbiAgICAgICAgICAgICAgICBwaWNrZXIud2lkZ2V0Lm9uKCdjbGljay50b2dnbGVQaWNrZXInLCAnLmFjY29yZGlvbi10b2dnbGUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAkdGhpcyA9ICQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICRwYXJlbnQgPSAkdGhpcy5jbG9zZXN0KCd1bCcpO1xuICAgICAgICAgICAgICAgICAgICBleHBhbmRlZCA9ICRwYXJlbnQuZmluZCgnLmluJyk7XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlZCA9ICRwYXJlbnQuZmluZCgnLmNvbGxhcHNlOm5vdCguaW4pJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cGFuZGVkICYmIGV4cGFuZGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGFwc2VEYXRhID0gZXhwYW5kZWQuZGF0YSgnY29sbGFwc2UnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xsYXBzZURhdGEgJiYgY29sbGFwc2VEYXRhLnRyYW5zaXRpb25pbmcpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGFuZGVkLmNvbGxhcHNlKCdoaWRlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZWQuY29sbGFwc2UoJ3Nob3cnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmZpbmQoJ3NwYW4nKS50b2dnbGVDbGFzcyhwaWNrZXIub3B0aW9ucy5pY29ucy50aW1lICsgJyAnICsgcGlja2VyLm9wdGlvbnMuaWNvbnMuZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwaWNrZXIuZWxlbWVudC5maW5kKCcuaW5wdXQtZ3JvdXAtYWRkb24gc3BhbicpLnRvZ2dsZUNsYXNzKHBpY2tlci5vcHRpb25zLmljb25zLnRpbWUgKyAnICcgKyBwaWNrZXIub3B0aW9ucy5pY29ucy5kYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBpY2tlci5pc0lucHV0KSB7XG4gICAgICAgICAgICAgICAgcGlja2VyLmVsZW1lbnQub24oe1xuICAgICAgICAgICAgICAgICAgICAnZm9jdXMnOiAkLnByb3h5KHBpY2tlci5zaG93LCB0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgJ2NoYW5nZSc6ICQucHJveHkoY2hhbmdlLCB0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgJ2JsdXInOiAkLnByb3h5KHBpY2tlci5oaWRlLCB0aGlzKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwaWNrZXIuZWxlbWVudC5vbih7XG4gICAgICAgICAgICAgICAgICAgICdjaGFuZ2UnOiAkLnByb3h5KGNoYW5nZSwgdGhpcylcbiAgICAgICAgICAgICAgICB9LCAnaW5wdXQnKTtcbiAgICAgICAgICAgICAgICBpZiAocGlja2VyLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICBwaWNrZXIuY29tcG9uZW50Lm9uKCdjbGljaycsICQucHJveHkocGlja2VyLnNob3csIHRoaXMpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwaWNrZXIuZWxlbWVudC5vbignY2xpY2snLCAkLnByb3h5KHBpY2tlci5zaG93LCB0aGlzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGF0dGFjaERhdGVQaWNrZXJHbG9iYWxFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkKHdpbmRvdykub24oXG4gICAgICAgICAgICAgICAgJ3Jlc2l6ZS5kYXRldGltZXBpY2tlcicgKyBwaWNrZXIuaWQsICQucHJveHkocGxhY2UsIHRoaXMpKTtcbiAgICAgICAgICAgIGlmICghcGlja2VyLmlzSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAkKGRvY3VtZW50KS5vbihcbiAgICAgICAgICAgICAgICAgICAgJ21vdXNlZG93bi5kYXRldGltZXBpY2tlcicgKyBwaWNrZXIuaWQsICQucHJveHkocGlja2VyLmhpZGUsIHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkZXRhY2hEYXRlUGlja2VyRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcGlja2VyLndpZGdldC5vZmYoJ2NsaWNrJywgJy5kYXRlcGlja2VyIConLCBwaWNrZXIuY2xpY2spO1xuICAgICAgICAgICAgcGlja2VyLndpZGdldC5vZmYoJ2NsaWNrJywgJ1tkYXRhLWFjdGlvbl0nKTtcbiAgICAgICAgICAgIHBpY2tlci53aWRnZXQub2ZmKCdtb3VzZWRvd24nLCBwaWNrZXIuc3RvcEV2ZW50KTtcbiAgICAgICAgICAgIGlmIChwaWNrZXIub3B0aW9ucy5waWNrRGF0ZSAmJiBwaWNrZXIub3B0aW9ucy5waWNrVGltZSkge1xuICAgICAgICAgICAgICAgIHBpY2tlci53aWRnZXQub2ZmKCdjbGljay50b2dnbGVQaWNrZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwaWNrZXIuaXNJbnB1dCkge1xuICAgICAgICAgICAgICAgIHBpY2tlci5lbGVtZW50Lm9mZih7XG4gICAgICAgICAgICAgICAgICAgICdmb2N1cyc6IHBpY2tlci5zaG93LFxuICAgICAgICAgICAgICAgICAgICAnY2hhbmdlJzogcGlja2VyLmNoYW5nZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwaWNrZXIuZWxlbWVudC5vZmYoe1xuICAgICAgICAgICAgICAgICAgICAnY2hhbmdlJzogcGlja2VyLmNoYW5nZVxuICAgICAgICAgICAgICAgIH0sICdpbnB1dCcpO1xuICAgICAgICAgICAgICAgIGlmIChwaWNrZXIuY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHBpY2tlci5jb21wb25lbnQub2ZmKCdjbGljaycsIHBpY2tlci5zaG93KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwaWNrZXIuZWxlbWVudC5vZmYoJ2NsaWNrJywgcGlja2VyLnNob3cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkZXRhY2hEYXRlUGlja2VyR2xvYmFsRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJCh3aW5kb3cpLm9mZigncmVzaXplLmRhdGV0aW1lcGlja2VyJyArIHBpY2tlci5pZCk7XG4gICAgICAgICAgICBpZiAoIXBpY2tlci5pc0lucHV0KSB7XG4gICAgICAgICAgICAgICAgJChkb2N1bWVudCkub2ZmKCdtb3VzZWRvd24uZGF0ZXRpbWVwaWNrZXInICsgcGlja2VyLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBpc0luRml4ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAocGlja2VyLmVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50cyA9IHBpY2tlci5lbGVtZW50LnBhcmVudHMoKSwgaW5GaXhlZCA9IGZhbHNlLCBpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkKHBhcmVudHNbaV0pLmNzcygncG9zaXRpb24nKSA9PSAnZml4ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbkZpeGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5GaXhlZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHBNb21lbnQubGFuZyhwaWNrZXIub3B0aW9ucy5sYW5ndWFnZSk7XG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVkID0gJycsIGlucHV0O1xuICAgICAgICAgICAgaWYgKCFwaWNrZXIudW5zZXQpIGZvcm1hdHRlZCA9IHBNb21lbnQocGlja2VyLmRhdGUpLmZvcm1hdChwaWNrZXIuZm9ybWF0KTtcbiAgICAgICAgICAgIGlmICghcGlja2VyLmlzSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGlja2VyLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dCA9IHBpY2tlci5lbGVtZW50LmZpbmQoJ2lucHV0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0LnZhbChmb3JtYXR0ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwaWNrZXIuZWxlbWVudC5kYXRhKCdkYXRlJywgZm9ybWF0dGVkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGlja2VyLmVsZW1lbnQudmFsKGZvcm1hdHRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXBpY2tlci5vcHRpb25zLnBpY2tUaW1lKSBwaWNrZXIuaGlkZSgpO1xuICAgICAgICB9LFxuXG5cdFx0Y2hlY2tEYXRlID0gZnVuY3Rpb24gKGRpcmVjdGlvbiwgdW5pdCwgYW1vdW50KSB7XG5cdFx0ICAgIHBNb21lbnQubGFuZyhwaWNrZXIub3B0aW9ucy5sYW5ndWFnZSk7XG5cdFx0ICAgIHZhciBuZXdEYXRlO1xuXHRcdCAgICBpZiAoZGlyZWN0aW9uID09IFwiYWRkXCIpIHtcblx0XHQgICAgICAgIG5ld0RhdGUgPSBwTW9tZW50KHBpY2tlci5kYXRlKTtcblx0XHQgICAgICAgIGlmIChuZXdEYXRlLmhvdXJzKCkgPT0gMjMpIG5ld0RhdGUuYWRkKGFtb3VudCwgdW5pdCk7XG5cdFx0ICAgICAgICBuZXdEYXRlLmFkZChhbW91bnQsIHVuaXQpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGVsc2Uge1xuXHRcdCAgICAgICAgbmV3RGF0ZSA9IHBNb21lbnQocGlja2VyLmRhdGUpLnN1YnRyYWN0KGFtb3VudCwgdW5pdCk7XG5cdFx0ICAgIH1cblx0XHQgICAgaWYgKGlzSW5EaXNhYmxlRGF0ZXMocE1vbWVudChuZXdEYXRlLnN1YnRyYWN0KGFtb3VudCwgdW5pdCkpKSB8fCBpc0luRGlzYWJsZURhdGVzKG5ld0RhdGUpKSB7XG5cdFx0ICAgICAgICBub3RpZnlFcnJvcihuZXdEYXRlLmZvcm1hdChwaWNrZXIuZm9ybWF0KSk7XG5cdFx0ICAgICAgICByZXR1cm47XG5cdFx0ICAgIH1cblxuXHRcdCAgICBpZiAoZGlyZWN0aW9uID09IFwiYWRkXCIpIHtcblx0XHQgICAgICAgIHBpY2tlci5kYXRlLmFkZChhbW91bnQsIHVuaXQpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGVsc2Uge1xuXHRcdCAgICAgICAgcGlja2VyLmRhdGUuc3VidHJhY3QoYW1vdW50LCB1bml0KTtcblx0XHQgICAgfVxuICAgICAgICAgICAgcGlja2VyLnVuc2V0ID0gZmFsc2U7XG5cdFx0fSxcblxuXHRcdGlzSW5EaXNhYmxlRGF0ZXMgPSBmdW5jdGlvbiAoZGF0ZSkge1xuXHRcdCAgICBwTW9tZW50LmxhbmcocGlja2VyLm9wdGlvbnMubGFuZ3VhZ2UpO1xuICAgICAgICAgICAgaWYgKGRhdGUuaXNBZnRlcihwaWNrZXIub3B0aW9ucy5lbmREYXRlKSB8fCBkYXRlLmlzQmVmb3JlKHBpY2tlci5vcHRpb25zLnN0YXJ0RGF0ZSkpIHJldHVybiB0cnVlO1xuXHRcdCAgICB2YXIgZGlzYWJsZWQgPSBwaWNrZXIub3B0aW9ucy5kaXNhYmxlZERhdGVzLCBpO1xuXHRcdCAgICBmb3IgKGkgaW4gZGlzYWJsZWQpIHtcblx0XHQgICAgICAgIGlmIChkaXNhYmxlZFtpXSA9PSBwTW9tZW50KGRhdGUpLmZvcm1hdChcIkxcIikpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICByZXR1cm4gZmFsc2U7XG5cdFx0fSxcblxuICAgICAgICBpc0luRW5hYmxlRGF0ZXMgPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICAgICAgcE1vbWVudC5sYW5nKHBpY2tlci5vcHRpb25zLmxhbmd1YWdlKTtcbiAgICAgICAgICAgIHZhciBlbmFibGVkID0gcGlja2VyLm9wdGlvbnMuZW5hYmxlZERhdGVzLCBpO1xuICAgICAgICAgICAgaWYgKGVuYWJsZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpIGluIGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuYWJsZWRbaV0gPT0gcE1vbWVudChkYXRlKS5mb3JtYXQoXCJMXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZW5hYmxlZCA9PT0gZmFsc2UgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIHBhZExlZnQgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChzdHJpbmcubGVuZ3RoID49IDIpIHJldHVybiBzdHJpbmc7XG4gICAgICAgICAgICBlbHNlIHJldHVybiAnMCcgKyBzdHJpbmc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0VGVtcGxhdGUgPSBmdW5jdGlvbiAocGlja0RhdGUsIHBpY2tUaW1lLCBjb2xsYXBzZSkge1xuICAgICAgICAgICAgaWYgKHBpY2tEYXRlICYmIHBpY2tUaW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0IGRyb3Bkb3duLW1lbnVcIiBzdHlsZT1cInotaW5kZXg6OTk5OSAhaW1wb3J0YW50O1wiPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzx1bCBjbGFzcz1cImxpc3QtdW5zdHlsZWRcIj4nICtcblx0XHRcdFx0XHRcdFx0JzxsaScgKyAoY29sbGFwc2UgPyAnIGNsYXNzPVwiY29sbGFwc2UgaW5cIicgOiAnJykgKyAnPicgK1xuXHRcdFx0XHRcdFx0XHRcdCc8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlclwiPicgKyBkcEdsb2JhbC50ZW1wbGF0ZSArICc8L2Rpdj4nICtcblx0XHRcdFx0XHRcdFx0JzwvbGk+JyArXG5cdFx0XHRcdFx0XHRcdCc8bGkgY2xhc3M9XCJwaWNrZXItc3dpdGNoIGFjY29yZGlvbi10b2dnbGVcIj48YSBjbGFzcz1cImJ0blwiIHN0eWxlPVwid2lkdGg6MTAwJVwiPjxzcGFuIGNsYXNzPVwiJyArIHBpY2tlci5vcHRpb25zLmljb25zLnRpbWUgKyAnXCI+PC9zcGFuPjwvYT48L2xpPicgK1xuXHRcdFx0XHRcdFx0XHQnPGxpJyArIChjb2xsYXBzZSA/ICcgY2xhc3M9XCJjb2xsYXBzZVwiJyA6ICcnKSArICc+JyArXG5cdFx0XHRcdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJ0aW1lcGlja2VyXCI+JyArIHRwR2xvYmFsLmdldFRlbXBsYXRlKCkgKyAnPC9kaXY+JyArXG5cdFx0XHRcdFx0XHRcdCc8L2xpPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzwvdWw+JyArXG4gICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGlja1RpbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQgZHJvcGRvd24tbWVudVwiPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJ0aW1lcGlja2VyXCI+JyArIHRwR2xvYmFsLmdldFRlbXBsYXRlKCkgKyAnPC9kaXY+JyArXG4gICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0IGRyb3Bkb3duLW1lbnVcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlclwiPicgKyBkcEdsb2JhbC50ZW1wbGF0ZSArICc8L2Rpdj4nICtcbiAgICAgICAgICAgICAgICAgICAgJzwvZGl2PidcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG5cdFx0ZHBHbG9iYWwgPSB7XG5cdFx0ICAgIG1vZGVzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjbHNOYW1lOiAnZGF5cycsXG4gICAgICAgICAgICAgICAgICAgIG5hdkZuYzogJ21vbnRoJyxcbiAgICAgICAgICAgICAgICAgICAgbmF2U3RlcDogMVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjbHNOYW1lOiAnbW9udGhzJyxcbiAgICAgICAgICAgICAgICAgICAgbmF2Rm5jOiAneWVhcicsXG4gICAgICAgICAgICAgICAgICAgIG5hdlN0ZXA6IDFcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY2xzTmFtZTogJ3llYXJzJyxcbiAgICAgICAgICAgICAgICAgICAgbmF2Rm5jOiAneWVhcicsXG4gICAgICAgICAgICAgICAgICAgIG5hdlN0ZXA6IDEwXG4gICAgICAgICAgICAgICAgfV0sXG5cdFx0ICAgIGhlYWRUZW1wbGF0ZTpcbiAgICAgICAgICAgICAgICAgICAgJzx0aGVhZD4nICtcblx0XHRcdFx0XHRcdCc8dHI+JyArXG5cdFx0XHRcdFx0XHRcdCc8dGggY2xhc3M9XCJwcmV2XCI+JmxzYXF1bzs8L3RoPjx0aCBjb2xzcGFuPVwiNVwiIGNsYXNzPVwic3dpdGNoXCI+PC90aD48dGggY2xhc3M9XCJuZXh0XCI+JnJzYXF1bzs8L3RoPicgK1xuXHRcdFx0XHRcdFx0JzwvdHI+JyArXG4gICAgICAgICAgICAgICAgICAgICc8L3RoZWFkPicsXG5cdFx0ICAgIGNvbnRUZW1wbGF0ZTpcbiAgICAgICAgJzx0Ym9keT48dHI+PHRkIGNvbHNwYW49XCI3XCI+PC90ZD48L3RyPjwvdGJvZHk+J1xuXHRcdH0sXG5cbiAgICAgICAgdHBHbG9iYWwgPSB7XG4gICAgICAgICAgICBob3VyVGVtcGxhdGU6ICAgJzxzcGFuIGRhdGEtYWN0aW9uPVwic2hvd0hvdXJzXCIgICBkYXRhLXRpbWUtY29tcG9uZW50PVwiaG91cnNcIiAgIGNsYXNzPVwidGltZXBpY2tlci1ob3VyXCI+PC9zcGFuPicsXG4gICAgICAgICAgICBtaW51dGVUZW1wbGF0ZTogJzxzcGFuIGRhdGEtYWN0aW9uPVwic2hvd01pbnV0ZXNcIiBkYXRhLXRpbWUtY29tcG9uZW50PVwibWludXRlc1wiIGNsYXNzPVwidGltZXBpY2tlci1taW51dGVcIj48L3NwYW4+Jyxcblx0XHRcdHNlY29uZFRlbXBsYXRlOiAnPHNwYW4gZGF0YS1hY3Rpb249XCJzaG93U2Vjb25kc1wiICBkYXRhLXRpbWUtY29tcG9uZW50PVwic2Vjb25kc1wiIGNsYXNzPVwidGltZXBpY2tlci1zZWNvbmRcIj48L3NwYW4+J1xuICAgICAgICB9O1xuXG4gICAgICAgIGRwR2xvYmFsLnRlbXBsYXRlID1cbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci1kYXlzXCI+JyArXG4gICAgICAgICAgICAgICAgJzx0YWJsZSBjbGFzcz1cInRhYmxlLWNvbmRlbnNlZFwiPicgKyBkcEdsb2JhbC5oZWFkVGVtcGxhdGUgKyAnPHRib2R5PjwvdGJvZHk+PC90YWJsZT4nICtcbiAgICAgICAgICAgICc8L2Rpdj4nICtcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci1tb250aHNcIj4nICtcbiAgICAgICAgICAgICAgICAnPHRhYmxlIGNsYXNzPVwidGFibGUtY29uZGVuc2VkXCI+JyArIGRwR2xvYmFsLmhlYWRUZW1wbGF0ZSArIGRwR2xvYmFsLmNvbnRUZW1wbGF0ZSArICc8L3RhYmxlPicgK1xuICAgICAgICAgICAgJzwvZGl2PicgK1xuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLXllYXJzXCI+JyArXG5cdFx0XHRcdCc8dGFibGUgY2xhc3M9XCJ0YWJsZS1jb25kZW5zZWRcIj4nICsgZHBHbG9iYWwuaGVhZFRlbXBsYXRlICsgZHBHbG9iYWwuY29udFRlbXBsYXRlICsgJzwvdGFibGU+JyArXG4gICAgICAgICAgICAnPC9kaXY+JztcblxuICAgICAgICB0cEdsb2JhbC5nZXRUZW1wbGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJ0aW1lcGlja2VyLXBpY2tlclwiPicgK1xuICAgICAgICAgICAgICAgICAgICAnPHRhYmxlIGNsYXNzPVwidGFibGUtY29uZGVuc2VkXCI+JyArXG5cdFx0XHRcdFx0XHQnPHRyPicgK1xuXHRcdFx0XHRcdFx0XHQnPHRkPjxhIGhyZWY9XCIjXCIgY2xhc3M9XCJidG5cIiBkYXRhLWFjdGlvbj1cImluY3JlbWVudEhvdXJzXCI+PHNwYW4gY2xhc3M9XCInICsgcGlja2VyLm9wdGlvbnMuaWNvbnMudXAgKyAnXCI+PC9zcGFuPjwvYT48L3RkPicgK1xuXHRcdFx0XHRcdFx0XHQnPHRkIGNsYXNzPVwic2VwYXJhdG9yXCI+PC90ZD4nICtcblx0XHRcdFx0XHRcdFx0Jzx0ZD4nICsgKHBpY2tlci5vcHRpb25zLnVzZU1pbnV0ZXMgPyAnPGEgaHJlZj1cIiNcIiBjbGFzcz1cImJ0blwiIGRhdGEtYWN0aW9uPVwiaW5jcmVtZW50TWludXRlc1wiPjxzcGFuIGNsYXNzPVwiJyArIHBpY2tlci5vcHRpb25zLmljb25zLnVwICsgJ1wiPjwvc3Bhbj48L2E+JyA6ICcnKSArICc8L3RkPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwaWNrZXIub3B0aW9ucy51c2VTZWNvbmRzID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzx0ZCBjbGFzcz1cInNlcGFyYXRvclwiPjwvdGQ+PHRkPjxhIGhyZWY9XCIjXCIgY2xhc3M9XCJidG5cIiBkYXRhLWFjdGlvbj1cImluY3JlbWVudFNlY29uZHNcIj48c3BhbiBjbGFzcz1cIicgKyBwaWNrZXIub3B0aW9ucy5pY29ucy51cCArICdcIj48L3NwYW4+PC9hPjwvdGQ+JyA6ICcnKSArXG5cdFx0XHRcdFx0XHRcdChwaWNrZXIub3B0aW9ucy51c2UyNGhvdXJzID8gJycgOiAnPHRkIGNsYXNzPVwic2VwYXJhdG9yXCI+PC90ZD4nKSArXG5cdFx0XHRcdFx0XHQnPC90cj4nICtcblx0XHRcdFx0XHRcdCc8dHI+JyArXG5cdFx0XHRcdFx0XHRcdCc8dGQ+JyArIHRwR2xvYmFsLmhvdXJUZW1wbGF0ZSArICc8L3RkPiAnICtcblx0XHRcdFx0XHRcdFx0Jzx0ZCBjbGFzcz1cInNlcGFyYXRvclwiPjo8L3RkPicgK1xuXHRcdFx0XHRcdFx0XHQnPHRkPicgKyAocGlja2VyLm9wdGlvbnMudXNlTWludXRlcyA/IHRwR2xvYmFsLm1pbnV0ZVRlbXBsYXRlIDogJzxzcGFuIGNsYXNzPVwidGltZXBpY2tlci1taW51dGVcIj4wMDwvc3Bhbj4nKSArICc8L3RkPiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocGlja2VyLm9wdGlvbnMudXNlU2Vjb25kcyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8dGQgY2xhc3M9XCJzZXBhcmF0b3JcIj46PC90ZD48dGQ+JyArIHRwR2xvYmFsLnNlY29uZFRlbXBsYXRlICsgJzwvdGQ+JyA6ICcnKSArXG5cdFx0XHRcdFx0XHRcdChwaWNrZXIub3B0aW9ucy51c2UyNGhvdXJzID8gJycgOiAnPHRkIGNsYXNzPVwic2VwYXJhdG9yXCI+PC90ZD4nICtcblx0XHRcdFx0XHRcdFx0Jzx0ZD48YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeVwiIGRhdGEtYWN0aW9uPVwidG9nZ2xlUGVyaW9kXCI+PC9idXR0b24+PC90ZD4nKSArXG5cdFx0XHRcdFx0XHQnPC90cj4nICtcblx0XHRcdFx0XHRcdCc8dHI+JyArXG5cdFx0XHRcdFx0XHRcdCc8dGQ+PGEgaHJlZj1cIiNcIiBjbGFzcz1cImJ0blwiIGRhdGEtYWN0aW9uPVwiZGVjcmVtZW50SG91cnNcIj48c3BhbiBjbGFzcz1cIicgKyBwaWNrZXIub3B0aW9ucy5pY29ucy5kb3duICsgJ1wiPjwvc3Bhbj48L2E+PC90ZD4nICtcblx0XHRcdFx0XHRcdFx0Jzx0ZCBjbGFzcz1cInNlcGFyYXRvclwiPjwvdGQ+JyArXG5cdFx0XHRcdFx0XHRcdCc8dGQ+JyArIChwaWNrZXIub3B0aW9ucy51c2VNaW51dGVzID8gJzxhIGhyZWY9XCIjXCIgY2xhc3M9XCJidG5cIiBkYXRhLWFjdGlvbj1cImRlY3JlbWVudE1pbnV0ZXNcIj48c3BhbiBjbGFzcz1cIicgKyBwaWNrZXIub3B0aW9ucy5pY29ucy5kb3duICsgJ1wiPjwvc3Bhbj48L2E+JyA6ICcnKSArICc8L3RkPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwaWNrZXIub3B0aW9ucy51c2VTZWNvbmRzID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzx0ZCBjbGFzcz1cInNlcGFyYXRvclwiPjwvdGQ+PHRkPjxhIGhyZWY9XCIjXCIgY2xhc3M9XCJidG5cIiBkYXRhLWFjdGlvbj1cImRlY3JlbWVudFNlY29uZHNcIj48c3BhbiBjbGFzcz1cIicgKyBwaWNrZXIub3B0aW9ucy5pY29ucy5kb3duICsgJ1wiPjwvc3Bhbj48L2E+PC90ZD4nIDogJycpICtcblx0XHRcdFx0XHRcdFx0KHBpY2tlci5vcHRpb25zLnVzZTI0aG91cnMgPyAnJyA6ICc8dGQgY2xhc3M9XCJzZXBhcmF0b3JcIj48L3RkPicpICtcblx0XHRcdFx0XHRcdCc8L3RyPicgK1xuICAgICAgICAgICAgICAgICAgICAnPC90YWJsZT4nICtcbiAgICAgICAgICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJ0aW1lcGlja2VyLWhvdXJzXCIgZGF0YS1hY3Rpb249XCJzZWxlY3RIb3VyXCI+JyArXG4gICAgICAgICAgICAgICAgICAgICc8dGFibGUgY2xhc3M9XCJ0YWJsZS1jb25kZW5zZWRcIj48L3RhYmxlPicgK1xuICAgICAgICAgICAgICAgICc8L2Rpdj4nICtcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cInRpbWVwaWNrZXItbWludXRlc1wiIGRhdGEtYWN0aW9uPVwic2VsZWN0TWludXRlXCI+JyArXG4gICAgICAgICAgICAgICAgICAgICc8dGFibGUgY2xhc3M9XCJ0YWJsZS1jb25kZW5zZWRcIj48L3RhYmxlPicgK1xuICAgICAgICAgICAgICAgICc8L2Rpdj4nICtcbiAgICAgICAgICAgICAgICAocGlja2VyLm9wdGlvbnMudXNlU2Vjb25kcyA/XG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwidGltZXBpY2tlci1zZWNvbmRzXCIgZGF0YS1hY3Rpb249XCJzZWxlY3RTZWNvbmRcIj48dGFibGUgY2xhc3M9XCJ0YWJsZS1jb25kZW5zZWRcIj48L3RhYmxlPjwvZGl2PicgOiAnJylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcGlja2VyLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkZXRhY2hEYXRlUGlja2VyRXZlbnRzKCk7XG4gICAgICAgICAgICBkZXRhY2hEYXRlUGlja2VyR2xvYmFsRXZlbnRzKCk7XG4gICAgICAgICAgICBwaWNrZXIud2lkZ2V0LnJlbW92ZSgpO1xuICAgICAgICAgICAgcGlja2VyLmVsZW1lbnQucmVtb3ZlRGF0YSgnRGF0ZVRpbWVQaWNrZXInKTtcbiAgICAgICAgICAgIGlmIChwaWNrZXIuY29tcG9uZW50KVxuICAgICAgICAgICAgICAgIHBpY2tlci5jb21wb25lbnQucmVtb3ZlRGF0YSgnRGF0ZVRpbWVQaWNrZXInKTtcbiAgICAgICAgfTtcblxuICAgICAgICBwaWNrZXIuc2hvdyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBwaWNrZXIud2lkZ2V0LnNob3coKTtcbiAgICAgICAgICAgIHBpY2tlci5oZWlnaHQgPSBwaWNrZXIuY29tcG9uZW50ID8gcGlja2VyLmNvbXBvbmVudC5vdXRlckhlaWdodCgpIDogcGlja2VyLmVsZW1lbnQub3V0ZXJIZWlnaHQoKTtcbiAgICAgICAgICAgIHBsYWNlKCk7XG4gICAgICAgICAgICBwaWNrZXIuZWxlbWVudC50cmlnZ2VyKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc2hvdy5kcCcsXG4gICAgICAgICAgICAgICAgZGF0ZTogcE1vbWVudChwaWNrZXIuZGF0ZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXR0YWNoRGF0ZVBpY2tlckdsb2JhbEV2ZW50cygpO1xuICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICBzdG9wRXZlbnQoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGlja2VyLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBwaWNrZXIuZWxlbWVudC5maW5kKCdpbnB1dCcpO1xuICAgICAgICAgICAgaWYoaW5wdXQucHJvcCgnZGlzYWJsZWQnKSkgcmV0dXJuO1xuXG4gICAgICAgICAgICBpbnB1dC5wcm9wKCdkaXNhYmxlZCcsIHRydWUpO1xuICAgICAgICAgICAgZGV0YWNoRGF0ZVBpY2tlckV2ZW50cygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBpY2tlci5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBwaWNrZXIuZWxlbWVudC5maW5kKCdpbnB1dCcpO1xuICAgICAgICAgICAgaWYoIWlucHV0LnByb3AoJ2Rpc2FibGVkJykpIHJldHVybjtcblxuICAgICAgICAgICAgaW5wdXQucHJvcCgnZGlzYWJsZWQnLCBmYWxzZSk7XG4gICAgICAgICAgICBhdHRhY2hEYXRlUGlja2VyRXZlbnRzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGlja2VyLmhpZGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudCAmJiAkKGV2ZW50LnRhcmdldCkuaXMocGlja2VyLmVsZW1lbnQuYXR0cihcImlkXCIpKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBJZ25vcmUgZXZlbnQgaWYgaW4gdGhlIG1pZGRsZSBvZiBhIHBpY2tlciB0cmFuc2l0aW9uXG4gICAgICAgICAgICB2YXIgY29sbGFwc2UgPSBwaWNrZXIud2lkZ2V0LmZpbmQoJy5jb2xsYXBzZScpLCBpLCBjb2xsYXBzZURhdGE7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29sbGFwc2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb2xsYXBzZURhdGEgPSBjb2xsYXBzZS5lcShpKS5kYXRhKCdjb2xsYXBzZScpO1xuICAgICAgICAgICAgICAgIGlmIChjb2xsYXBzZURhdGEgJiYgY29sbGFwc2VEYXRhLnRyYW5zaXRpb25pbmcpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBpY2tlci53aWRnZXQuaGlkZSgpO1xuICAgICAgICAgICAgcGlja2VyLnZpZXdNb2RlID0gcGlja2VyLnN0YXJ0Vmlld01vZGU7XG4gICAgICAgICAgICBzaG93TW9kZSgpO1xuICAgICAgICAgICAgcGlja2VyLmVsZW1lbnQudHJpZ2dlcih7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2hpZGUuZHAnLFxuICAgICAgICAgICAgICAgIGRhdGU6IHBNb21lbnQocGlja2VyLmRhdGUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRldGFjaERhdGVQaWNrZXJHbG9iYWxFdmVudHMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBwaWNrZXIuc2V0VmFsdWUgPSBmdW5jdGlvbiAobmV3RGF0ZSkge1xuICAgICAgICAgICAgcE1vbWVudC5sYW5nKHBpY2tlci5vcHRpb25zLmxhbmd1YWdlKTtcbiAgICAgICAgICAgIGlmICghbmV3RGF0ZSkge1xuICAgICAgICAgICAgICAgIHBpY2tlci51bnNldCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBpY2tlci51bnNldCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwTW9tZW50LmlzTW9tZW50KG5ld0RhdGUpKSBuZXdEYXRlID0gcE1vbWVudChuZXdEYXRlKTtcbiAgICAgICAgICAgIGlmIChuZXdEYXRlLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHBpY2tlci5kYXRlID0gbmV3RGF0ZTtcbiAgICAgICAgICAgICAgICBzZXQoKTtcbiAgICAgICAgICAgICAgICBwaWNrZXIudmlld0RhdGUgPSBwTW9tZW50KHsgeTogcGlja2VyLmRhdGUueWVhcigpLCBNOiBwaWNrZXIuZGF0ZS5tb250aCgpIH0pO1xuICAgICAgICAgICAgICAgIGZpbGxEYXRlKCk7XG4gICAgICAgICAgICAgICAgZmlsbFRpbWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vdGlmeUVycm9yKG5ld0RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHBpY2tlci5nZXREYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHBpY2tlci51bnNldCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gcGlja2VyLmRhdGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGlja2VyLnNldERhdGUgPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICAgICAgZGF0ZSA9IHBNb21lbnQoZGF0ZSk7XG4gICAgICAgICAgICBpZiAoIWRhdGUpIHBpY2tlci5zZXRWYWx1ZShudWxsKTtcbiAgICAgICAgICAgIGVsc2UgcGlja2VyLnNldFZhbHVlKGRhdGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBpY2tlci5zZXRFbmFibGVkRGF0ZXMgPSBmdW5jdGlvbiAoZGF0ZXMpIHtcbiAgICAgICAgICAgIGlmICghZGF0ZXMpIHBpY2tlci5vcHRpb25zLmVuYWJsZWREYXRlcyA9IGZhbHNlO1xuICAgICAgICAgICAgZWxzZSBwaWNrZXIub3B0aW9ucy5lbmFibGVkRGF0ZXMgPSBkYXRlcztcbiAgICAgICAgICAgIGlmIChwaWNrZXIudmlld0RhdGUpIHVwZGF0ZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBpY2tlci5zZXRFbmREYXRlID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgICAgIGlmIChkYXRlID09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgICAgICAgcGlja2VyLm9wdGlvbnMuZW5kRGF0ZSA9IHBNb21lbnQoZGF0ZSk7XG4gICAgICAgICAgICBpZiAocGlja2VyLnZpZXdEYXRlKSB1cGRhdGUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBwaWNrZXIuc2V0U3RhcnREYXRlID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgICAgIGlmIChkYXRlID09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgICAgICAgcGlja2VyLm9wdGlvbnMuc3RhcnREYXRlID0gcE1vbWVudChkYXRlKTtcbiAgICAgICAgICAgIGlmIChwaWNrZXIudmlld0RhdGUpIHVwZGF0ZSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGluaXQoKTtcbiAgICB9O1xuXG4gICAgJC5mbi5kYXRldGltZXBpY2tlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKSwgZGF0YSA9ICR0aGlzLmRhdGEoJ0RhdGVUaW1lUGlja2VyJyk7XG4gICAgICAgICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ0RhdGVUaW1lUGlja2VyJywgbmV3IERhdGVUaW1lUGlja2VyKHRoaXMsIG9wdGlvbnMpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pKTsiLCIvLyBUaGlzIGZpbGUgaXMgYXV0b2dlbmVyYXRlZCB2aWEgdGhlIGBjb21tb25qc2AgR3J1bnQgdGFzay4gWW91IGNhbiByZXF1aXJlKCkgdGhpcyBmaWxlIGluIGEgQ29tbW9uSlMgZW52aXJvbm1lbnQuXG5yZXF1aXJlKCcuLi8uLi9qcy90cmFuc2l0aW9uLmpzJylcbnJlcXVpcmUoJy4uLy4uL2pzL2FsZXJ0LmpzJylcbnJlcXVpcmUoJy4uLy4uL2pzL2J1dHRvbi5qcycpXG5yZXF1aXJlKCcuLi8uLi9qcy9jYXJvdXNlbC5qcycpXG5yZXF1aXJlKCcuLi8uLi9qcy9jb2xsYXBzZS5qcycpXG5yZXF1aXJlKCcuLi8uLi9qcy9kcm9wZG93bi5qcycpXG5yZXF1aXJlKCcuLi8uLi9qcy9tb2RhbC5qcycpXG5yZXF1aXJlKCcuLi8uLi9qcy90b29sdGlwLmpzJylcbnJlcXVpcmUoJy4uLy4uL2pzL3BvcG92ZXIuanMnKVxucmVxdWlyZSgnLi4vLi4vanMvc2Nyb2xsc3B5LmpzJylcbnJlcXVpcmUoJy4uLy4uL2pzL3RhYi5qcycpXG5yZXF1aXJlKCcuLi8uLi9qcy9hZmZpeC5qcycpIiwiLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IGFmZml4LmpzIHYzLjMuNFxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jYWZmaXhcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNSBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBBRkZJWCBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgQWZmaXggPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBBZmZpeC5ERUZBVUxUUywgb3B0aW9ucylcblxuICAgIHRoaXMuJHRhcmdldCA9ICQodGhpcy5vcHRpb25zLnRhcmdldClcbiAgICAgIC5vbignc2Nyb2xsLmJzLmFmZml4LmRhdGEtYXBpJywgJC5wcm94eSh0aGlzLmNoZWNrUG9zaXRpb24sIHRoaXMpKVxuICAgICAgLm9uKCdjbGljay5icy5hZmZpeC5kYXRhLWFwaScsICAkLnByb3h5KHRoaXMuY2hlY2tQb3NpdGlvbldpdGhFdmVudExvb3AsIHRoaXMpKVxuXG4gICAgdGhpcy4kZWxlbWVudCAgICAgPSAkKGVsZW1lbnQpXG4gICAgdGhpcy5hZmZpeGVkICAgICAgPSBudWxsXG4gICAgdGhpcy51bnBpbiAgICAgICAgPSBudWxsXG4gICAgdGhpcy5waW5uZWRPZmZzZXQgPSBudWxsXG5cbiAgICB0aGlzLmNoZWNrUG9zaXRpb24oKVxuICB9XG5cbiAgQWZmaXguVkVSU0lPTiAgPSAnMy4zLjQnXG5cbiAgQWZmaXguUkVTRVQgICAgPSAnYWZmaXggYWZmaXgtdG9wIGFmZml4LWJvdHRvbSdcblxuICBBZmZpeC5ERUZBVUxUUyA9IHtcbiAgICBvZmZzZXQ6IDAsXG4gICAgdGFyZ2V0OiB3aW5kb3dcbiAgfVxuXG4gIEFmZml4LnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uIChzY3JvbGxIZWlnaHQsIGhlaWdodCwgb2Zmc2V0VG9wLCBvZmZzZXRCb3R0b20pIHtcbiAgICB2YXIgc2Nyb2xsVG9wICAgID0gdGhpcy4kdGFyZ2V0LnNjcm9sbFRvcCgpXG4gICAgdmFyIHBvc2l0aW9uICAgICA9IHRoaXMuJGVsZW1lbnQub2Zmc2V0KClcbiAgICB2YXIgdGFyZ2V0SGVpZ2h0ID0gdGhpcy4kdGFyZ2V0LmhlaWdodCgpXG5cbiAgICBpZiAob2Zmc2V0VG9wICE9IG51bGwgJiYgdGhpcy5hZmZpeGVkID09ICd0b3AnKSByZXR1cm4gc2Nyb2xsVG9wIDwgb2Zmc2V0VG9wID8gJ3RvcCcgOiBmYWxzZVxuXG4gICAgaWYgKHRoaXMuYWZmaXhlZCA9PSAnYm90dG9tJykge1xuICAgICAgaWYgKG9mZnNldFRvcCAhPSBudWxsKSByZXR1cm4gKHNjcm9sbFRvcCArIHRoaXMudW5waW4gPD0gcG9zaXRpb24udG9wKSA/IGZhbHNlIDogJ2JvdHRvbSdcbiAgICAgIHJldHVybiAoc2Nyb2xsVG9wICsgdGFyZ2V0SGVpZ2h0IDw9IHNjcm9sbEhlaWdodCAtIG9mZnNldEJvdHRvbSkgPyBmYWxzZSA6ICdib3R0b20nXG4gICAgfVxuXG4gICAgdmFyIGluaXRpYWxpemluZyAgID0gdGhpcy5hZmZpeGVkID09IG51bGxcbiAgICB2YXIgY29sbGlkZXJUb3AgICAgPSBpbml0aWFsaXppbmcgPyBzY3JvbGxUb3AgOiBwb3NpdGlvbi50b3BcbiAgICB2YXIgY29sbGlkZXJIZWlnaHQgPSBpbml0aWFsaXppbmcgPyB0YXJnZXRIZWlnaHQgOiBoZWlnaHRcblxuICAgIGlmIChvZmZzZXRUb3AgIT0gbnVsbCAmJiBzY3JvbGxUb3AgPD0gb2Zmc2V0VG9wKSByZXR1cm4gJ3RvcCdcbiAgICBpZiAob2Zmc2V0Qm90dG9tICE9IG51bGwgJiYgKGNvbGxpZGVyVG9wICsgY29sbGlkZXJIZWlnaHQgPj0gc2Nyb2xsSGVpZ2h0IC0gb2Zmc2V0Qm90dG9tKSkgcmV0dXJuICdib3R0b20nXG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIEFmZml4LnByb3RvdHlwZS5nZXRQaW5uZWRPZmZzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucGlubmVkT2Zmc2V0KSByZXR1cm4gdGhpcy5waW5uZWRPZmZzZXRcbiAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKEFmZml4LlJFU0VUKS5hZGRDbGFzcygnYWZmaXgnKVxuICAgIHZhciBzY3JvbGxUb3AgPSB0aGlzLiR0YXJnZXQuc2Nyb2xsVG9wKClcbiAgICB2YXIgcG9zaXRpb24gID0gdGhpcy4kZWxlbWVudC5vZmZzZXQoKVxuICAgIHJldHVybiAodGhpcy5waW5uZWRPZmZzZXQgPSBwb3NpdGlvbi50b3AgLSBzY3JvbGxUb3ApXG4gIH1cblxuICBBZmZpeC5wcm90b3R5cGUuY2hlY2tQb3NpdGlvbldpdGhFdmVudExvb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2V0VGltZW91dCgkLnByb3h5KHRoaXMuY2hlY2tQb3NpdGlvbiwgdGhpcyksIDEpXG4gIH1cblxuICBBZmZpeC5wcm90b3R5cGUuY2hlY2tQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuJGVsZW1lbnQuaXMoJzp2aXNpYmxlJykpIHJldHVyblxuXG4gICAgdmFyIGhlaWdodCAgICAgICA9IHRoaXMuJGVsZW1lbnQuaGVpZ2h0KClcbiAgICB2YXIgb2Zmc2V0ICAgICAgID0gdGhpcy5vcHRpb25zLm9mZnNldFxuICAgIHZhciBvZmZzZXRUb3AgICAgPSBvZmZzZXQudG9wXG4gICAgdmFyIG9mZnNldEJvdHRvbSA9IG9mZnNldC5ib3R0b21cbiAgICB2YXIgc2Nyb2xsSGVpZ2h0ID0gJChkb2N1bWVudC5ib2R5KS5oZWlnaHQoKVxuXG4gICAgaWYgKHR5cGVvZiBvZmZzZXQgIT0gJ29iamVjdCcpICAgICAgICAgb2Zmc2V0Qm90dG9tID0gb2Zmc2V0VG9wID0gb2Zmc2V0XG4gICAgaWYgKHR5cGVvZiBvZmZzZXRUb3AgPT0gJ2Z1bmN0aW9uJykgICAgb2Zmc2V0VG9wICAgID0gb2Zmc2V0LnRvcCh0aGlzLiRlbGVtZW50KVxuICAgIGlmICh0eXBlb2Ygb2Zmc2V0Qm90dG9tID09ICdmdW5jdGlvbicpIG9mZnNldEJvdHRvbSA9IG9mZnNldC5ib3R0b20odGhpcy4kZWxlbWVudClcblxuICAgIHZhciBhZmZpeCA9IHRoaXMuZ2V0U3RhdGUoc2Nyb2xsSGVpZ2h0LCBoZWlnaHQsIG9mZnNldFRvcCwgb2Zmc2V0Qm90dG9tKVxuXG4gICAgaWYgKHRoaXMuYWZmaXhlZCAhPSBhZmZpeCkge1xuICAgICAgaWYgKHRoaXMudW5waW4gIT0gbnVsbCkgdGhpcy4kZWxlbWVudC5jc3MoJ3RvcCcsICcnKVxuXG4gICAgICB2YXIgYWZmaXhUeXBlID0gJ2FmZml4JyArIChhZmZpeCA/ICctJyArIGFmZml4IDogJycpXG4gICAgICB2YXIgZSAgICAgICAgID0gJC5FdmVudChhZmZpeFR5cGUgKyAnLmJzLmFmZml4JylcblxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKGUpXG5cbiAgICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgICAgdGhpcy5hZmZpeGVkID0gYWZmaXhcbiAgICAgIHRoaXMudW5waW4gPSBhZmZpeCA9PSAnYm90dG9tJyA/IHRoaXMuZ2V0UGlubmVkT2Zmc2V0KCkgOiBudWxsXG5cbiAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgLnJlbW92ZUNsYXNzKEFmZml4LlJFU0VUKVxuICAgICAgICAuYWRkQ2xhc3MoYWZmaXhUeXBlKVxuICAgICAgICAudHJpZ2dlcihhZmZpeFR5cGUucmVwbGFjZSgnYWZmaXgnLCAnYWZmaXhlZCcpICsgJy5icy5hZmZpeCcpXG4gICAgfVxuXG4gICAgaWYgKGFmZml4ID09ICdib3R0b20nKSB7XG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZnNldCh7XG4gICAgICAgIHRvcDogc2Nyb2xsSGVpZ2h0IC0gaGVpZ2h0IC0gb2Zmc2V0Qm90dG9tXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG5cbiAgLy8gQUZGSVggUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICAgID0gJHRoaXMuZGF0YSgnYnMuYWZmaXgnKVxuICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uID09ICdvYmplY3QnICYmIG9wdGlvblxuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLmFmZml4JywgKGRhdGEgPSBuZXcgQWZmaXgodGhpcywgb3B0aW9ucykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXSgpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLmFmZml4XG5cbiAgJC5mbi5hZmZpeCAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLmFmZml4LkNvbnN0cnVjdG9yID0gQWZmaXhcblxuXG4gIC8vIEFGRklYIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi5hZmZpeC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4uYWZmaXggPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICAvLyBBRkZJWCBEQVRBLUFQSVxuICAvLyA9PT09PT09PT09PT09PVxuXG4gICQod2luZG93KS5vbignbG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAkKCdbZGF0YS1zcHk9XCJhZmZpeFwiXScpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICRzcHkgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSA9ICRzcHkuZGF0YSgpXG5cbiAgICAgIGRhdGEub2Zmc2V0ID0gZGF0YS5vZmZzZXQgfHwge31cblxuICAgICAgaWYgKGRhdGEub2Zmc2V0Qm90dG9tICE9IG51bGwpIGRhdGEub2Zmc2V0LmJvdHRvbSA9IGRhdGEub2Zmc2V0Qm90dG9tXG4gICAgICBpZiAoZGF0YS5vZmZzZXRUb3AgICAgIT0gbnVsbCkgZGF0YS5vZmZzZXQudG9wICAgID0gZGF0YS5vZmZzZXRUb3BcblxuICAgICAgUGx1Z2luLmNhbGwoJHNweSwgZGF0YSlcbiAgICB9KVxuICB9KVxuXG59KGpRdWVyeSk7XG4iLCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogYWxlcnQuanMgdjMuMy40XG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNhbGVydHNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNSBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBBTEVSVCBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgZGlzbWlzcyA9ICdbZGF0YS1kaXNtaXNzPVwiYWxlcnRcIl0nXG4gIHZhciBBbGVydCAgID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgJChlbCkub24oJ2NsaWNrJywgZGlzbWlzcywgdGhpcy5jbG9zZSlcbiAgfVxuXG4gIEFsZXJ0LlZFUlNJT04gPSAnMy4zLjQnXG5cbiAgQWxlcnQuVFJBTlNJVElPTl9EVVJBVElPTiA9IDE1MFxuXG4gIEFsZXJ0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyICR0aGlzICAgID0gJCh0aGlzKVxuICAgIHZhciBzZWxlY3RvciA9ICR0aGlzLmF0dHIoJ2RhdGEtdGFyZ2V0JylcblxuICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgIHNlbGVjdG9yID0gJHRoaXMuYXR0cignaHJlZicpXG4gICAgICBzZWxlY3RvciA9IHNlbGVjdG9yICYmIHNlbGVjdG9yLnJlcGxhY2UoLy4qKD89I1teXFxzXSokKS8sICcnKSAvLyBzdHJpcCBmb3IgaWU3XG4gICAgfVxuXG4gICAgdmFyICRwYXJlbnQgPSAkKHNlbGVjdG9yKVxuXG4gICAgaWYgKGUpIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgaWYgKCEkcGFyZW50Lmxlbmd0aCkge1xuICAgICAgJHBhcmVudCA9ICR0aGlzLmNsb3Nlc3QoJy5hbGVydCcpXG4gICAgfVxuXG4gICAgJHBhcmVudC50cmlnZ2VyKGUgPSAkLkV2ZW50KCdjbG9zZS5icy5hbGVydCcpKVxuXG4gICAgaWYgKGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgJHBhcmVudC5yZW1vdmVDbGFzcygnaW4nKVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRWxlbWVudCgpIHtcbiAgICAgIC8vIGRldGFjaCBmcm9tIHBhcmVudCwgZmlyZSBldmVudCB0aGVuIGNsZWFuIHVwIGRhdGFcbiAgICAgICRwYXJlbnQuZGV0YWNoKCkudHJpZ2dlcignY2xvc2VkLmJzLmFsZXJ0JykucmVtb3ZlKClcbiAgICB9XG5cbiAgICAkLnN1cHBvcnQudHJhbnNpdGlvbiAmJiAkcGFyZW50Lmhhc0NsYXNzKCdmYWRlJykgP1xuICAgICAgJHBhcmVudFxuICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCByZW1vdmVFbGVtZW50KVxuICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoQWxlcnQuVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgcmVtb3ZlRWxlbWVudCgpXG4gIH1cblxuXG4gIC8vIEFMRVJUIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgID0gJHRoaXMuZGF0YSgnYnMuYWxlcnQnKVxuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLmFsZXJ0JywgKGRhdGEgPSBuZXcgQWxlcnQodGhpcykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXS5jYWxsKCR0aGlzKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5hbGVydFxuXG4gICQuZm4uYWxlcnQgICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi5hbGVydC5Db25zdHJ1Y3RvciA9IEFsZXJ0XG5cblxuICAvLyBBTEVSVCBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PVxuXG4gICQuZm4uYWxlcnQubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLmFsZXJ0ID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gQUxFUlQgREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09PT1cblxuICAkKGRvY3VtZW50KS5vbignY2xpY2suYnMuYWxlcnQuZGF0YS1hcGknLCBkaXNtaXNzLCBBbGVydC5wcm90b3R5cGUuY2xvc2UpXG5cbn0oalF1ZXJ5KTtcbiIsIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBidXR0b24uanMgdjMuMy40XG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNidXR0b25zXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTUgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gQlVUVE9OIFBVQkxJQyBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBCdXR0b24gPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuJGVsZW1lbnQgID0gJChlbGVtZW50KVxuICAgIHRoaXMub3B0aW9ucyAgID0gJC5leHRlbmQoe30sIEJ1dHRvbi5ERUZBVUxUUywgb3B0aW9ucylcbiAgICB0aGlzLmlzTG9hZGluZyA9IGZhbHNlXG4gIH1cblxuICBCdXR0b24uVkVSU0lPTiAgPSAnMy4zLjQnXG5cbiAgQnV0dG9uLkRFRkFVTFRTID0ge1xuICAgIGxvYWRpbmdUZXh0OiAnbG9hZGluZy4uLidcbiAgfVxuXG4gIEJ1dHRvbi5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICB2YXIgZCAgICA9ICdkaXNhYmxlZCdcbiAgICB2YXIgJGVsICA9IHRoaXMuJGVsZW1lbnRcbiAgICB2YXIgdmFsICA9ICRlbC5pcygnaW5wdXQnKSA/ICd2YWwnIDogJ2h0bWwnXG4gICAgdmFyIGRhdGEgPSAkZWwuZGF0YSgpXG5cbiAgICBzdGF0ZSA9IHN0YXRlICsgJ1RleHQnXG5cbiAgICBpZiAoZGF0YS5yZXNldFRleHQgPT0gbnVsbCkgJGVsLmRhdGEoJ3Jlc2V0VGV4dCcsICRlbFt2YWxdKCkpXG5cbiAgICAvLyBwdXNoIHRvIGV2ZW50IGxvb3AgdG8gYWxsb3cgZm9ybXMgdG8gc3VibWl0XG4gICAgc2V0VGltZW91dCgkLnByb3h5KGZ1bmN0aW9uICgpIHtcbiAgICAgICRlbFt2YWxdKGRhdGFbc3RhdGVdID09IG51bGwgPyB0aGlzLm9wdGlvbnNbc3RhdGVdIDogZGF0YVtzdGF0ZV0pXG5cbiAgICAgIGlmIChzdGF0ZSA9PSAnbG9hZGluZ1RleHQnKSB7XG4gICAgICAgIHRoaXMuaXNMb2FkaW5nID0gdHJ1ZVxuICAgICAgICAkZWwuYWRkQ2xhc3MoZCkuYXR0cihkLCBkKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzTG9hZGluZykge1xuICAgICAgICB0aGlzLmlzTG9hZGluZyA9IGZhbHNlXG4gICAgICAgICRlbC5yZW1vdmVDbGFzcyhkKS5yZW1vdmVBdHRyKGQpXG4gICAgICB9XG4gICAgfSwgdGhpcyksIDApXG4gIH1cblxuICBCdXR0b24ucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2hhbmdlZCA9IHRydWVcbiAgICB2YXIgJHBhcmVudCA9IHRoaXMuJGVsZW1lbnQuY2xvc2VzdCgnW2RhdGEtdG9nZ2xlPVwiYnV0dG9uc1wiXScpXG5cbiAgICBpZiAoJHBhcmVudC5sZW5ndGgpIHtcbiAgICAgIHZhciAkaW5wdXQgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ2lucHV0JylcbiAgICAgIGlmICgkaW5wdXQucHJvcCgndHlwZScpID09ICdyYWRpbycpIHtcbiAgICAgICAgaWYgKCRpbnB1dC5wcm9wKCdjaGVja2VkJykgJiYgdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnYWN0aXZlJykpIGNoYW5nZWQgPSBmYWxzZVxuICAgICAgICBlbHNlICRwYXJlbnQuZmluZCgnLmFjdGl2ZScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKVxuICAgICAgfVxuICAgICAgaWYgKGNoYW5nZWQpICRpbnB1dC5wcm9wKCdjaGVja2VkJywgIXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2FjdGl2ZScpKS50cmlnZ2VyKCdjaGFuZ2UnKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ2FyaWEtcHJlc3NlZCcsICF0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdhY3RpdmUnKSlcbiAgICB9XG5cbiAgICBpZiAoY2hhbmdlZCkgdGhpcy4kZWxlbWVudC50b2dnbGVDbGFzcygnYWN0aXZlJylcbiAgfVxuXG5cbiAgLy8gQlVUVE9OIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgICAgPSAkdGhpcy5kYXRhKCdicy5idXR0b24nKVxuICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uID09ICdvYmplY3QnICYmIG9wdGlvblxuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLmJ1dHRvbicsIChkYXRhID0gbmV3IEJ1dHRvbih0aGlzLCBvcHRpb25zKSkpXG5cbiAgICAgIGlmIChvcHRpb24gPT0gJ3RvZ2dsZScpIGRhdGEudG9nZ2xlKClcbiAgICAgIGVsc2UgaWYgKG9wdGlvbikgZGF0YS5zZXRTdGF0ZShvcHRpb24pXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLmJ1dHRvblxuXG4gICQuZm4uYnV0dG9uICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4uYnV0dG9uLkNvbnN0cnVjdG9yID0gQnV0dG9uXG5cblxuICAvLyBCVVRUT04gTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi5idXR0b24ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLmJ1dHRvbiA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIEJVVFRPTiBEQVRBLUFQSVxuICAvLyA9PT09PT09PT09PT09PT1cblxuICAkKGRvY3VtZW50KVxuICAgIC5vbignY2xpY2suYnMuYnV0dG9uLmRhdGEtYXBpJywgJ1tkYXRhLXRvZ2dsZV49XCJidXR0b25cIl0nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyICRidG4gPSAkKGUudGFyZ2V0KVxuICAgICAgaWYgKCEkYnRuLmhhc0NsYXNzKCdidG4nKSkgJGJ0biA9ICRidG4uY2xvc2VzdCgnLmJ0bicpXG4gICAgICBQbHVnaW4uY2FsbCgkYnRuLCAndG9nZ2xlJylcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIH0pXG4gICAgLm9uKCdmb2N1cy5icy5idXR0b24uZGF0YS1hcGkgYmx1ci5icy5idXR0b24uZGF0YS1hcGknLCAnW2RhdGEtdG9nZ2xlXj1cImJ1dHRvblwiXScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAkKGUudGFyZ2V0KS5jbG9zZXN0KCcuYnRuJykudG9nZ2xlQ2xhc3MoJ2ZvY3VzJywgL15mb2N1cyhpbik/JC8udGVzdChlLnR5cGUpKVxuICAgIH0pXG5cbn0oalF1ZXJ5KTtcbiIsIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBjYXJvdXNlbC5qcyB2My4zLjRcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI2Nhcm91c2VsXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTUgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gQ0FST1VTRUwgQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIENhcm91c2VsID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ICAgID0gJChlbGVtZW50KVxuICAgIHRoaXMuJGluZGljYXRvcnMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy5jYXJvdXNlbC1pbmRpY2F0b3JzJylcbiAgICB0aGlzLm9wdGlvbnMgICAgID0gb3B0aW9uc1xuICAgIHRoaXMucGF1c2VkICAgICAgPSBudWxsXG4gICAgdGhpcy5zbGlkaW5nICAgICA9IG51bGxcbiAgICB0aGlzLmludGVydmFsICAgID0gbnVsbFxuICAgIHRoaXMuJGFjdGl2ZSAgICAgPSBudWxsXG4gICAgdGhpcy4kaXRlbXMgICAgICA9IG51bGxcblxuICAgIHRoaXMub3B0aW9ucy5rZXlib2FyZCAmJiB0aGlzLiRlbGVtZW50Lm9uKCdrZXlkb3duLmJzLmNhcm91c2VsJywgJC5wcm94eSh0aGlzLmtleWRvd24sIHRoaXMpKVxuXG4gICAgdGhpcy5vcHRpb25zLnBhdXNlID09ICdob3ZlcicgJiYgISgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpICYmIHRoaXMuJGVsZW1lbnRcbiAgICAgIC5vbignbW91c2VlbnRlci5icy5jYXJvdXNlbCcsICQucHJveHkodGhpcy5wYXVzZSwgdGhpcykpXG4gICAgICAub24oJ21vdXNlbGVhdmUuYnMuY2Fyb3VzZWwnLCAkLnByb3h5KHRoaXMuY3ljbGUsIHRoaXMpKVxuICB9XG5cbiAgQ2Fyb3VzZWwuVkVSU0lPTiAgPSAnMy4zLjQnXG5cbiAgQ2Fyb3VzZWwuVFJBTlNJVElPTl9EVVJBVElPTiA9IDYwMFxuXG4gIENhcm91c2VsLkRFRkFVTFRTID0ge1xuICAgIGludGVydmFsOiA1MDAwLFxuICAgIHBhdXNlOiAnaG92ZXInLFxuICAgIHdyYXA6IHRydWUsXG4gICAga2V5Ym9hcmQ6IHRydWVcbiAgfVxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5rZXlkb3duID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoL2lucHV0fHRleHRhcmVhL2kudGVzdChlLnRhcmdldC50YWdOYW1lKSkgcmV0dXJuXG4gICAgc3dpdGNoIChlLndoaWNoKSB7XG4gICAgICBjYXNlIDM3OiB0aGlzLnByZXYoKTsgYnJlYWtcbiAgICAgIGNhc2UgMzk6IHRoaXMubmV4dCgpOyBicmVha1xuICAgICAgZGVmYXVsdDogcmV0dXJuXG4gICAgfVxuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gIH1cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuY3ljbGUgPSBmdW5jdGlvbiAoZSkge1xuICAgIGUgfHwgKHRoaXMucGF1c2VkID0gZmFsc2UpXG5cbiAgICB0aGlzLmludGVydmFsICYmIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbClcblxuICAgIHRoaXMub3B0aW9ucy5pbnRlcnZhbFxuICAgICAgJiYgIXRoaXMucGF1c2VkXG4gICAgICAmJiAodGhpcy5pbnRlcnZhbCA9IHNldEludGVydmFsKCQucHJveHkodGhpcy5uZXh0LCB0aGlzKSwgdGhpcy5vcHRpb25zLmludGVydmFsKSlcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuZ2V0SXRlbUluZGV4ID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB0aGlzLiRpdGVtcyA9IGl0ZW0ucGFyZW50KCkuY2hpbGRyZW4oJy5pdGVtJylcbiAgICByZXR1cm4gdGhpcy4kaXRlbXMuaW5kZXgoaXRlbSB8fCB0aGlzLiRhY3RpdmUpXG4gIH1cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuZ2V0SXRlbUZvckRpcmVjdGlvbiA9IGZ1bmN0aW9uIChkaXJlY3Rpb24sIGFjdGl2ZSkge1xuICAgIHZhciBhY3RpdmVJbmRleCA9IHRoaXMuZ2V0SXRlbUluZGV4KGFjdGl2ZSlcbiAgICB2YXIgd2lsbFdyYXAgPSAoZGlyZWN0aW9uID09ICdwcmV2JyAmJiBhY3RpdmVJbmRleCA9PT0gMClcbiAgICAgICAgICAgICAgICB8fCAoZGlyZWN0aW9uID09ICduZXh0JyAmJiBhY3RpdmVJbmRleCA9PSAodGhpcy4kaXRlbXMubGVuZ3RoIC0gMSkpXG4gICAgaWYgKHdpbGxXcmFwICYmICF0aGlzLm9wdGlvbnMud3JhcCkgcmV0dXJuIGFjdGl2ZVxuICAgIHZhciBkZWx0YSA9IGRpcmVjdGlvbiA9PSAncHJldicgPyAtMSA6IDFcbiAgICB2YXIgaXRlbUluZGV4ID0gKGFjdGl2ZUluZGV4ICsgZGVsdGEpICUgdGhpcy4kaXRlbXMubGVuZ3RoXG4gICAgcmV0dXJuIHRoaXMuJGl0ZW1zLmVxKGl0ZW1JbmRleClcbiAgfVxuXG4gIENhcm91c2VsLnByb3RvdHlwZS50byA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICB2YXIgdGhhdCAgICAgICAgPSB0aGlzXG4gICAgdmFyIGFjdGl2ZUluZGV4ID0gdGhpcy5nZXRJdGVtSW5kZXgodGhpcy4kYWN0aXZlID0gdGhpcy4kZWxlbWVudC5maW5kKCcuaXRlbS5hY3RpdmUnKSlcblxuICAgIGlmIChwb3MgPiAodGhpcy4kaXRlbXMubGVuZ3RoIC0gMSkgfHwgcG9zIDwgMCkgcmV0dXJuXG5cbiAgICBpZiAodGhpcy5zbGlkaW5nKSAgICAgICByZXR1cm4gdGhpcy4kZWxlbWVudC5vbmUoJ3NsaWQuYnMuY2Fyb3VzZWwnLCBmdW5jdGlvbiAoKSB7IHRoYXQudG8ocG9zKSB9KSAvLyB5ZXMsIFwic2xpZFwiXG4gICAgaWYgKGFjdGl2ZUluZGV4ID09IHBvcykgcmV0dXJuIHRoaXMucGF1c2UoKS5jeWNsZSgpXG5cbiAgICByZXR1cm4gdGhpcy5zbGlkZShwb3MgPiBhY3RpdmVJbmRleCA/ICduZXh0JyA6ICdwcmV2JywgdGhpcy4kaXRlbXMuZXEocG9zKSlcbiAgfVxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgZSB8fCAodGhpcy5wYXVzZWQgPSB0cnVlKVxuXG4gICAgaWYgKHRoaXMuJGVsZW1lbnQuZmluZCgnLm5leHQsIC5wcmV2JykubGVuZ3RoICYmICQuc3VwcG9ydC50cmFuc2l0aW9uKSB7XG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJC5zdXBwb3J0LnRyYW5zaXRpb24uZW5kKVxuICAgICAgdGhpcy5jeWNsZSh0cnVlKVxuICAgIH1cblxuICAgIHRoaXMuaW50ZXJ2YWwgPSBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuc2xpZGluZykgcmV0dXJuXG4gICAgcmV0dXJuIHRoaXMuc2xpZGUoJ25leHQnKVxuICB9XG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuc2xpZGluZykgcmV0dXJuXG4gICAgcmV0dXJuIHRoaXMuc2xpZGUoJ3ByZXYnKVxuICB9XG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLnNsaWRlID0gZnVuY3Rpb24gKHR5cGUsIG5leHQpIHtcbiAgICB2YXIgJGFjdGl2ZSAgID0gdGhpcy4kZWxlbWVudC5maW5kKCcuaXRlbS5hY3RpdmUnKVxuICAgIHZhciAkbmV4dCAgICAgPSBuZXh0IHx8IHRoaXMuZ2V0SXRlbUZvckRpcmVjdGlvbih0eXBlLCAkYWN0aXZlKVxuICAgIHZhciBpc0N5Y2xpbmcgPSB0aGlzLmludGVydmFsXG4gICAgdmFyIGRpcmVjdGlvbiA9IHR5cGUgPT0gJ25leHQnID8gJ2xlZnQnIDogJ3JpZ2h0J1xuICAgIHZhciB0aGF0ICAgICAgPSB0aGlzXG5cbiAgICBpZiAoJG5leHQuaGFzQ2xhc3MoJ2FjdGl2ZScpKSByZXR1cm4gKHRoaXMuc2xpZGluZyA9IGZhbHNlKVxuXG4gICAgdmFyIHJlbGF0ZWRUYXJnZXQgPSAkbmV4dFswXVxuICAgIHZhciBzbGlkZUV2ZW50ID0gJC5FdmVudCgnc2xpZGUuYnMuY2Fyb3VzZWwnLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiByZWxhdGVkVGFyZ2V0LFxuICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb25cbiAgICB9KVxuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihzbGlkZUV2ZW50KVxuICAgIGlmIChzbGlkZUV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgIHRoaXMuc2xpZGluZyA9IHRydWVcblxuICAgIGlzQ3ljbGluZyAmJiB0aGlzLnBhdXNlKClcblxuICAgIGlmICh0aGlzLiRpbmRpY2F0b3JzLmxlbmd0aCkge1xuICAgICAgdGhpcy4kaW5kaWNhdG9ycy5maW5kKCcuYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpXG4gICAgICB2YXIgJG5leHRJbmRpY2F0b3IgPSAkKHRoaXMuJGluZGljYXRvcnMuY2hpbGRyZW4oKVt0aGlzLmdldEl0ZW1JbmRleCgkbmV4dCldKVxuICAgICAgJG5leHRJbmRpY2F0b3IgJiYgJG5leHRJbmRpY2F0b3IuYWRkQ2xhc3MoJ2FjdGl2ZScpXG4gICAgfVxuXG4gICAgdmFyIHNsaWRFdmVudCA9ICQuRXZlbnQoJ3NsaWQuYnMuY2Fyb3VzZWwnLCB7IHJlbGF0ZWRUYXJnZXQ6IHJlbGF0ZWRUYXJnZXQsIGRpcmVjdGlvbjogZGlyZWN0aW9uIH0pIC8vIHllcywgXCJzbGlkXCJcbiAgICBpZiAoJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnc2xpZGUnKSkge1xuICAgICAgJG5leHQuYWRkQ2xhc3ModHlwZSlcbiAgICAgICRuZXh0WzBdLm9mZnNldFdpZHRoIC8vIGZvcmNlIHJlZmxvd1xuICAgICAgJGFjdGl2ZS5hZGRDbGFzcyhkaXJlY3Rpb24pXG4gICAgICAkbmV4dC5hZGRDbGFzcyhkaXJlY3Rpb24pXG4gICAgICAkYWN0aXZlXG4gICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAkbmV4dC5yZW1vdmVDbGFzcyhbdHlwZSwgZGlyZWN0aW9uXS5qb2luKCcgJykpLmFkZENsYXNzKCdhY3RpdmUnKVxuICAgICAgICAgICRhY3RpdmUucmVtb3ZlQ2xhc3MoWydhY3RpdmUnLCBkaXJlY3Rpb25dLmpvaW4oJyAnKSlcbiAgICAgICAgICB0aGF0LnNsaWRpbmcgPSBmYWxzZVxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC4kZWxlbWVudC50cmlnZ2VyKHNsaWRFdmVudClcbiAgICAgICAgICB9LCAwKVxuICAgICAgICB9KVxuICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoQ2Fyb3VzZWwuVFJBTlNJVElPTl9EVVJBVElPTilcbiAgICB9IGVsc2Uge1xuICAgICAgJGFjdGl2ZS5yZW1vdmVDbGFzcygnYWN0aXZlJylcbiAgICAgICRuZXh0LmFkZENsYXNzKCdhY3RpdmUnKVxuICAgICAgdGhpcy5zbGlkaW5nID0gZmFsc2VcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihzbGlkRXZlbnQpXG4gICAgfVxuXG4gICAgaXNDeWNsaW5nICYmIHRoaXMuY3ljbGUoKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gQ0FST1VTRUwgUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICAgID0gJHRoaXMuZGF0YSgnYnMuY2Fyb3VzZWwnKVxuICAgICAgdmFyIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgQ2Fyb3VzZWwuREVGQVVMVFMsICR0aGlzLmRhdGEoKSwgdHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0JyAmJiBvcHRpb24pXG4gICAgICB2YXIgYWN0aW9uICA9IHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycgPyBvcHRpb24gOiBvcHRpb25zLnNsaWRlXG5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMuY2Fyb3VzZWwnLCAoZGF0YSA9IG5ldyBDYXJvdXNlbCh0aGlzLCBvcHRpb25zKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnbnVtYmVyJykgZGF0YS50byhvcHRpb24pXG4gICAgICBlbHNlIGlmIChhY3Rpb24pIGRhdGFbYWN0aW9uXSgpXG4gICAgICBlbHNlIGlmIChvcHRpb25zLmludGVydmFsKSBkYXRhLnBhdXNlKCkuY3ljbGUoKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5jYXJvdXNlbFxuXG4gICQuZm4uY2Fyb3VzZWwgICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi5jYXJvdXNlbC5Db25zdHJ1Y3RvciA9IENhcm91c2VsXG5cblxuICAvLyBDQVJPVVNFTCBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PT09PVxuXG4gICQuZm4uY2Fyb3VzZWwubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLmNhcm91c2VsID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gQ0FST1VTRUwgREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09PT09PT1cblxuICB2YXIgY2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgaHJlZlxuICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuICAgIHZhciAkdGFyZ2V0ID0gJCgkdGhpcy5hdHRyKCdkYXRhLXRhcmdldCcpIHx8IChocmVmID0gJHRoaXMuYXR0cignaHJlZicpKSAmJiBocmVmLnJlcGxhY2UoLy4qKD89I1teXFxzXSskKS8sICcnKSkgLy8gc3RyaXAgZm9yIGllN1xuICAgIGlmICghJHRhcmdldC5oYXNDbGFzcygnY2Fyb3VzZWwnKSkgcmV0dXJuXG4gICAgdmFyIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgJHRhcmdldC5kYXRhKCksICR0aGlzLmRhdGEoKSlcbiAgICB2YXIgc2xpZGVJbmRleCA9ICR0aGlzLmF0dHIoJ2RhdGEtc2xpZGUtdG8nKVxuICAgIGlmIChzbGlkZUluZGV4KSBvcHRpb25zLmludGVydmFsID0gZmFsc2VcblxuICAgIFBsdWdpbi5jYWxsKCR0YXJnZXQsIG9wdGlvbnMpXG5cbiAgICBpZiAoc2xpZGVJbmRleCkge1xuICAgICAgJHRhcmdldC5kYXRhKCdicy5jYXJvdXNlbCcpLnRvKHNsaWRlSW5kZXgpXG4gICAgfVxuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gIH1cblxuICAkKGRvY3VtZW50KVxuICAgIC5vbignY2xpY2suYnMuY2Fyb3VzZWwuZGF0YS1hcGknLCAnW2RhdGEtc2xpZGVdJywgY2xpY2tIYW5kbGVyKVxuICAgIC5vbignY2xpY2suYnMuY2Fyb3VzZWwuZGF0YS1hcGknLCAnW2RhdGEtc2xpZGUtdG9dJywgY2xpY2tIYW5kbGVyKVxuXG4gICQod2luZG93KS5vbignbG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAkKCdbZGF0YS1yaWRlPVwiY2Fyb3VzZWxcIl0nKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkY2Fyb3VzZWwgPSAkKHRoaXMpXG4gICAgICBQbHVnaW4uY2FsbCgkY2Fyb3VzZWwsICRjYXJvdXNlbC5kYXRhKCkpXG4gICAgfSlcbiAgfSlcblxufShqUXVlcnkpO1xuIiwiLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IGNvbGxhcHNlLmpzIHYzLjMuNFxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jY29sbGFwc2VcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNSBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBDT0xMQVBTRSBQVUJMSUMgQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBDb2xsYXBzZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy4kZWxlbWVudCAgICAgID0gJChlbGVtZW50KVxuICAgIHRoaXMub3B0aW9ucyAgICAgICA9ICQuZXh0ZW5kKHt9LCBDb2xsYXBzZS5ERUZBVUxUUywgb3B0aW9ucylcbiAgICB0aGlzLiR0cmlnZ2VyICAgICAgPSAkKCdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXVtocmVmPVwiIycgKyBlbGVtZW50LmlkICsgJ1wiXSwnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXVtkYXRhLXRhcmdldD1cIiMnICsgZWxlbWVudC5pZCArICdcIl0nKVxuICAgIHRoaXMudHJhbnNpdGlvbmluZyA9IG51bGxcblxuICAgIGlmICh0aGlzLm9wdGlvbnMucGFyZW50KSB7XG4gICAgICB0aGlzLiRwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHRoaXMuJGVsZW1lbnQsIHRoaXMuJHRyaWdnZXIpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy50b2dnbGUpIHRoaXMudG9nZ2xlKClcbiAgfVxuXG4gIENvbGxhcHNlLlZFUlNJT04gID0gJzMuMy40J1xuXG4gIENvbGxhcHNlLlRSQU5TSVRJT05fRFVSQVRJT04gPSAzNTBcblxuICBDb2xsYXBzZS5ERUZBVUxUUyA9IHtcbiAgICB0b2dnbGU6IHRydWVcbiAgfVxuXG4gIENvbGxhcHNlLnByb3RvdHlwZS5kaW1lbnNpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhc1dpZHRoID0gdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnd2lkdGgnKVxuICAgIHJldHVybiBoYXNXaWR0aCA/ICd3aWR0aCcgOiAnaGVpZ2h0J1xuICB9XG5cbiAgQ29sbGFwc2UucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMudHJhbnNpdGlvbmluZyB8fCB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdpbicpKSByZXR1cm5cblxuICAgIHZhciBhY3RpdmVzRGF0YVxuICAgIHZhciBhY3RpdmVzID0gdGhpcy4kcGFyZW50ICYmIHRoaXMuJHBhcmVudC5jaGlsZHJlbignLnBhbmVsJykuY2hpbGRyZW4oJy5pbiwgLmNvbGxhcHNpbmcnKVxuXG4gICAgaWYgKGFjdGl2ZXMgJiYgYWN0aXZlcy5sZW5ndGgpIHtcbiAgICAgIGFjdGl2ZXNEYXRhID0gYWN0aXZlcy5kYXRhKCdicy5jb2xsYXBzZScpXG4gICAgICBpZiAoYWN0aXZlc0RhdGEgJiYgYWN0aXZlc0RhdGEudHJhbnNpdGlvbmluZykgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0RXZlbnQgPSAkLkV2ZW50KCdzaG93LmJzLmNvbGxhcHNlJylcbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoc3RhcnRFdmVudClcbiAgICBpZiAoc3RhcnRFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICBpZiAoYWN0aXZlcyAmJiBhY3RpdmVzLmxlbmd0aCkge1xuICAgICAgUGx1Z2luLmNhbGwoYWN0aXZlcywgJ2hpZGUnKVxuICAgICAgYWN0aXZlc0RhdGEgfHwgYWN0aXZlcy5kYXRhKCdicy5jb2xsYXBzZScsIG51bGwpXG4gICAgfVxuXG4gICAgdmFyIGRpbWVuc2lvbiA9IHRoaXMuZGltZW5zaW9uKClcblxuICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgIC5yZW1vdmVDbGFzcygnY29sbGFwc2UnKVxuICAgICAgLmFkZENsYXNzKCdjb2xsYXBzaW5nJylbZGltZW5zaW9uXSgwKVxuICAgICAgLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKVxuXG4gICAgdGhpcy4kdHJpZ2dlclxuICAgICAgLnJlbW92ZUNsYXNzKCdjb2xsYXBzZWQnKVxuICAgICAgLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKVxuXG4gICAgdGhpcy50cmFuc2l0aW9uaW5nID0gMVxuXG4gICAgdmFyIGNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy4kZWxlbWVudFxuICAgICAgICAucmVtb3ZlQ2xhc3MoJ2NvbGxhcHNpbmcnKVxuICAgICAgICAuYWRkQ2xhc3MoJ2NvbGxhcHNlIGluJylbZGltZW5zaW9uXSgnJylcbiAgICAgIHRoaXMudHJhbnNpdGlvbmluZyA9IDBcbiAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgLnRyaWdnZXIoJ3Nob3duLmJzLmNvbGxhcHNlJylcbiAgICB9XG5cbiAgICBpZiAoISQuc3VwcG9ydC50cmFuc2l0aW9uKSByZXR1cm4gY29tcGxldGUuY2FsbCh0aGlzKVxuXG4gICAgdmFyIHNjcm9sbFNpemUgPSAkLmNhbWVsQ2FzZShbJ3Njcm9sbCcsIGRpbWVuc2lvbl0uam9pbignLScpKVxuXG4gICAgdGhpcy4kZWxlbWVudFxuICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgJC5wcm94eShjb21wbGV0ZSwgdGhpcykpXG4gICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoQ29sbGFwc2UuVFJBTlNJVElPTl9EVVJBVElPTilbZGltZW5zaW9uXSh0aGlzLiRlbGVtZW50WzBdW3Njcm9sbFNpemVdKVxuICB9XG5cbiAgQ29sbGFwc2UucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMudHJhbnNpdGlvbmluZyB8fCAhdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnaW4nKSkgcmV0dXJuXG5cbiAgICB2YXIgc3RhcnRFdmVudCA9ICQuRXZlbnQoJ2hpZGUuYnMuY29sbGFwc2UnKVxuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihzdGFydEV2ZW50KVxuICAgIGlmIChzdGFydEV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgIHZhciBkaW1lbnNpb24gPSB0aGlzLmRpbWVuc2lvbigpXG5cbiAgICB0aGlzLiRlbGVtZW50W2RpbWVuc2lvbl0odGhpcy4kZWxlbWVudFtkaW1lbnNpb25dKCkpWzBdLm9mZnNldEhlaWdodFxuXG4gICAgdGhpcy4kZWxlbWVudFxuICAgICAgLmFkZENsYXNzKCdjb2xsYXBzaW5nJylcbiAgICAgIC5yZW1vdmVDbGFzcygnY29sbGFwc2UgaW4nKVxuICAgICAgLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSlcblxuICAgIHRoaXMuJHRyaWdnZXJcbiAgICAgIC5hZGRDbGFzcygnY29sbGFwc2VkJylcbiAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgZmFsc2UpXG5cbiAgICB0aGlzLnRyYW5zaXRpb25pbmcgPSAxXG5cbiAgICB2YXIgY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnRyYW5zaXRpb25pbmcgPSAwXG4gICAgICB0aGlzLiRlbGVtZW50XG4gICAgICAgIC5yZW1vdmVDbGFzcygnY29sbGFwc2luZycpXG4gICAgICAgIC5hZGRDbGFzcygnY29sbGFwc2UnKVxuICAgICAgICAudHJpZ2dlcignaGlkZGVuLmJzLmNvbGxhcHNlJylcbiAgICB9XG5cbiAgICBpZiAoISQuc3VwcG9ydC50cmFuc2l0aW9uKSByZXR1cm4gY29tcGxldGUuY2FsbCh0aGlzKVxuXG4gICAgdGhpcy4kZWxlbWVudFxuICAgICAgW2RpbWVuc2lvbl0oMClcbiAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsICQucHJveHkoY29tcGxldGUsIHRoaXMpKVxuICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKENvbGxhcHNlLlRSQU5TSVRJT05fRFVSQVRJT04pXG4gIH1cblxuICBDb2xsYXBzZS5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXNbdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnaW4nKSA/ICdoaWRlJyA6ICdzaG93J10oKVxuICB9XG5cbiAgQ29sbGFwc2UucHJvdG90eXBlLmdldFBhcmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJCh0aGlzLm9wdGlvbnMucGFyZW50KVxuICAgICAgLmZpbmQoJ1tkYXRhLXRvZ2dsZT1cImNvbGxhcHNlXCJdW2RhdGEtcGFyZW50PVwiJyArIHRoaXMub3B0aW9ucy5wYXJlbnQgKyAnXCJdJylcbiAgICAgIC5lYWNoKCQucHJveHkoZnVuY3Rpb24gKGksIGVsZW1lbnQpIHtcbiAgICAgICAgdmFyICRlbGVtZW50ID0gJChlbGVtZW50KVxuICAgICAgICB0aGlzLmFkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyhnZXRUYXJnZXRGcm9tVHJpZ2dlcigkZWxlbWVudCksICRlbGVtZW50KVxuICAgICAgfSwgdGhpcykpXG4gICAgICAuZW5kKClcbiAgfVxuXG4gIENvbGxhcHNlLnByb3RvdHlwZS5hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MgPSBmdW5jdGlvbiAoJGVsZW1lbnQsICR0cmlnZ2VyKSB7XG4gICAgdmFyIGlzT3BlbiA9ICRlbGVtZW50Lmhhc0NsYXNzKCdpbicpXG5cbiAgICAkZWxlbWVudC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgaXNPcGVuKVxuICAgICR0cmlnZ2VyXG4gICAgICAudG9nZ2xlQ2xhc3MoJ2NvbGxhcHNlZCcsICFpc09wZW4pXG4gICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIGlzT3BlbilcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFRhcmdldEZyb21UcmlnZ2VyKCR0cmlnZ2VyKSB7XG4gICAgdmFyIGhyZWZcbiAgICB2YXIgdGFyZ2V0ID0gJHRyaWdnZXIuYXR0cignZGF0YS10YXJnZXQnKVxuICAgICAgfHwgKGhyZWYgPSAkdHJpZ2dlci5hdHRyKCdocmVmJykpICYmIGhyZWYucmVwbGFjZSgvLiooPz0jW15cXHNdKyQpLywgJycpIC8vIHN0cmlwIGZvciBpZTdcblxuICAgIHJldHVybiAkKHRhcmdldClcbiAgfVxuXG5cbiAgLy8gQ09MTEFQU0UgUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICAgID0gJHRoaXMuZGF0YSgnYnMuY29sbGFwc2UnKVxuICAgICAgdmFyIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgQ29sbGFwc2UuREVGQVVMVFMsICR0aGlzLmRhdGEoKSwgdHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0JyAmJiBvcHRpb24pXG5cbiAgICAgIGlmICghZGF0YSAmJiBvcHRpb25zLnRvZ2dsZSAmJiAvc2hvd3xoaWRlLy50ZXN0KG9wdGlvbikpIG9wdGlvbnMudG9nZ2xlID0gZmFsc2VcbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMuY29sbGFwc2UnLCAoZGF0YSA9IG5ldyBDb2xsYXBzZSh0aGlzLCBvcHRpb25zKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dKClcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4uY29sbGFwc2VcblxuICAkLmZuLmNvbGxhcHNlICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4uY29sbGFwc2UuQ29uc3RydWN0b3IgPSBDb2xsYXBzZVxuXG5cbiAgLy8gQ09MTEFQU0UgTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT09PT1cblxuICAkLmZuLmNvbGxhcHNlLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi5jb2xsYXBzZSA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIENPTExBUFNFIERBVEEtQVBJXG4gIC8vID09PT09PT09PT09PT09PT09XG5cbiAgJChkb2N1bWVudCkub24oJ2NsaWNrLmJzLmNvbGxhcHNlLmRhdGEtYXBpJywgJ1tkYXRhLXRvZ2dsZT1cImNvbGxhcHNlXCJdJywgZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcblxuICAgIGlmICghJHRoaXMuYXR0cignZGF0YS10YXJnZXQnKSkgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICB2YXIgJHRhcmdldCA9IGdldFRhcmdldEZyb21UcmlnZ2VyKCR0aGlzKVxuICAgIHZhciBkYXRhICAgID0gJHRhcmdldC5kYXRhKCdicy5jb2xsYXBzZScpXG4gICAgdmFyIG9wdGlvbiAgPSBkYXRhID8gJ3RvZ2dsZScgOiAkdGhpcy5kYXRhKClcblxuICAgIFBsdWdpbi5jYWxsKCR0YXJnZXQsIG9wdGlvbilcbiAgfSlcblxufShqUXVlcnkpO1xuIiwiLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IGRyb3Bkb3duLmpzIHYzLjMuNFxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jZHJvcGRvd25zXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTUgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gRFJPUERPV04gQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIGJhY2tkcm9wID0gJy5kcm9wZG93bi1iYWNrZHJvcCdcbiAgdmFyIHRvZ2dsZSAgID0gJ1tkYXRhLXRvZ2dsZT1cImRyb3Bkb3duXCJdJ1xuICB2YXIgRHJvcGRvd24gPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICQoZWxlbWVudCkub24oJ2NsaWNrLmJzLmRyb3Bkb3duJywgdGhpcy50b2dnbGUpXG4gIH1cblxuICBEcm9wZG93bi5WRVJTSU9OID0gJzMuMy40J1xuXG4gIERyb3Bkb3duLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciAkdGhpcyA9ICQodGhpcylcblxuICAgIGlmICgkdGhpcy5pcygnLmRpc2FibGVkLCA6ZGlzYWJsZWQnKSkgcmV0dXJuXG5cbiAgICB2YXIgJHBhcmVudCAgPSBnZXRQYXJlbnQoJHRoaXMpXG4gICAgdmFyIGlzQWN0aXZlID0gJHBhcmVudC5oYXNDbGFzcygnb3BlbicpXG5cbiAgICBjbGVhck1lbnVzKClcblxuICAgIGlmICghaXNBY3RpdmUpIHtcbiAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgISRwYXJlbnQuY2xvc2VzdCgnLm5hdmJhci1uYXYnKS5sZW5ndGgpIHtcbiAgICAgICAgLy8gaWYgbW9iaWxlIHdlIHVzZSBhIGJhY2tkcm9wIGJlY2F1c2UgY2xpY2sgZXZlbnRzIGRvbid0IGRlbGVnYXRlXG4gICAgICAgICQoJzxkaXYgY2xhc3M9XCJkcm9wZG93bi1iYWNrZHJvcFwiLz4nKS5pbnNlcnRBZnRlcigkKHRoaXMpKS5vbignY2xpY2snLCBjbGVhck1lbnVzKVxuICAgICAgfVxuXG4gICAgICB2YXIgcmVsYXRlZFRhcmdldCA9IHsgcmVsYXRlZFRhcmdldDogdGhpcyB9XG4gICAgICAkcGFyZW50LnRyaWdnZXIoZSA9ICQuRXZlbnQoJ3Nob3cuYnMuZHJvcGRvd24nLCByZWxhdGVkVGFyZ2V0KSlcblxuICAgICAgaWYgKGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgICAkdGhpc1xuICAgICAgICAudHJpZ2dlcignZm9jdXMnKVxuICAgICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsICd0cnVlJylcblxuICAgICAgJHBhcmVudFxuICAgICAgICAudG9nZ2xlQ2xhc3MoJ29wZW4nKVxuICAgICAgICAudHJpZ2dlcignc2hvd24uYnMuZHJvcGRvd24nLCByZWxhdGVkVGFyZ2V0KVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgRHJvcGRvd24ucHJvdG90eXBlLmtleWRvd24gPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmICghLygzOHw0MHwyN3wzMikvLnRlc3QoZS53aGljaCkgfHwgL2lucHV0fHRleHRhcmVhL2kudGVzdChlLnRhcmdldC50YWdOYW1lKSkgcmV0dXJuXG5cbiAgICB2YXIgJHRoaXMgPSAkKHRoaXMpXG5cbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgICBpZiAoJHRoaXMuaXMoJy5kaXNhYmxlZCwgOmRpc2FibGVkJykpIHJldHVyblxuXG4gICAgdmFyICRwYXJlbnQgID0gZ2V0UGFyZW50KCR0aGlzKVxuICAgIHZhciBpc0FjdGl2ZSA9ICRwYXJlbnQuaGFzQ2xhc3MoJ29wZW4nKVxuXG4gICAgaWYgKCghaXNBY3RpdmUgJiYgZS53aGljaCAhPSAyNykgfHwgKGlzQWN0aXZlICYmIGUud2hpY2ggPT0gMjcpKSB7XG4gICAgICBpZiAoZS53aGljaCA9PSAyNykgJHBhcmVudC5maW5kKHRvZ2dsZSkudHJpZ2dlcignZm9jdXMnKVxuICAgICAgcmV0dXJuICR0aGlzLnRyaWdnZXIoJ2NsaWNrJylcbiAgICB9XG5cbiAgICB2YXIgZGVzYyA9ICcgbGk6bm90KC5kaXNhYmxlZCk6dmlzaWJsZSBhJ1xuICAgIHZhciAkaXRlbXMgPSAkcGFyZW50LmZpbmQoJ1tyb2xlPVwibWVudVwiXScgKyBkZXNjICsgJywgW3JvbGU9XCJsaXN0Ym94XCJdJyArIGRlc2MpXG5cbiAgICBpZiAoISRpdGVtcy5sZW5ndGgpIHJldHVyblxuXG4gICAgdmFyIGluZGV4ID0gJGl0ZW1zLmluZGV4KGUudGFyZ2V0KVxuXG4gICAgaWYgKGUud2hpY2ggPT0gMzggJiYgaW5kZXggPiAwKSAgICAgICAgICAgICAgICAgaW5kZXgtLSAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVwXG4gICAgaWYgKGUud2hpY2ggPT0gNDAgJiYgaW5kZXggPCAkaXRlbXMubGVuZ3RoIC0gMSkgaW5kZXgrKyAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvd25cbiAgICBpZiAoIX5pbmRleCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gMFxuXG4gICAgJGl0ZW1zLmVxKGluZGV4KS50cmlnZ2VyKCdmb2N1cycpXG4gIH1cblxuICBmdW5jdGlvbiBjbGVhck1lbnVzKGUpIHtcbiAgICBpZiAoZSAmJiBlLndoaWNoID09PSAzKSByZXR1cm5cbiAgICAkKGJhY2tkcm9wKS5yZW1vdmUoKVxuICAgICQodG9nZ2xlKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyAgICAgICAgID0gJCh0aGlzKVxuICAgICAgdmFyICRwYXJlbnQgICAgICAgPSBnZXRQYXJlbnQoJHRoaXMpXG4gICAgICB2YXIgcmVsYXRlZFRhcmdldCA9IHsgcmVsYXRlZFRhcmdldDogdGhpcyB9XG5cbiAgICAgIGlmICghJHBhcmVudC5oYXNDbGFzcygnb3BlbicpKSByZXR1cm5cblxuICAgICAgJHBhcmVudC50cmlnZ2VyKGUgPSAkLkV2ZW50KCdoaWRlLmJzLmRyb3Bkb3duJywgcmVsYXRlZFRhcmdldCkpXG5cbiAgICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgICAgJHRoaXMuYXR0cignYXJpYS1leHBhbmRlZCcsICdmYWxzZScpXG4gICAgICAkcGFyZW50LnJlbW92ZUNsYXNzKCdvcGVuJykudHJpZ2dlcignaGlkZGVuLmJzLmRyb3Bkb3duJywgcmVsYXRlZFRhcmdldClcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UGFyZW50KCR0aGlzKSB7XG4gICAgdmFyIHNlbGVjdG9yID0gJHRoaXMuYXR0cignZGF0YS10YXJnZXQnKVxuXG4gICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgc2VsZWN0b3IgPSAkdGhpcy5hdHRyKCdocmVmJylcbiAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IgJiYgLyNbQS1aYS16XS8udGVzdChzZWxlY3RvcikgJiYgc2VsZWN0b3IucmVwbGFjZSgvLiooPz0jW15cXHNdKiQpLywgJycpIC8vIHN0cmlwIGZvciBpZTdcbiAgICB9XG5cbiAgICB2YXIgJHBhcmVudCA9IHNlbGVjdG9yICYmICQoc2VsZWN0b3IpXG5cbiAgICByZXR1cm4gJHBhcmVudCAmJiAkcGFyZW50Lmxlbmd0aCA/ICRwYXJlbnQgOiAkdGhpcy5wYXJlbnQoKVxuICB9XG5cblxuICAvLyBEUk9QRE9XTiBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICA9ICR0aGlzLmRhdGEoJ2JzLmRyb3Bkb3duJylcblxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy5kcm9wZG93bicsIChkYXRhID0gbmV3IERyb3Bkb3duKHRoaXMpKSlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0uY2FsbCgkdGhpcylcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4uZHJvcGRvd25cblxuICAkLmZuLmRyb3Bkb3duICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4uZHJvcGRvd24uQ29uc3RydWN0b3IgPSBEcm9wZG93blxuXG5cbiAgLy8gRFJPUERPV04gTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT09PT1cblxuICAkLmZuLmRyb3Bkb3duLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi5kcm9wZG93biA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIEFQUExZIFRPIFNUQU5EQVJEIERST1BET1dOIEVMRU1FTlRTXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgJChkb2N1bWVudClcbiAgICAub24oJ2NsaWNrLmJzLmRyb3Bkb3duLmRhdGEtYXBpJywgY2xlYXJNZW51cylcbiAgICAub24oJ2NsaWNrLmJzLmRyb3Bkb3duLmRhdGEtYXBpJywgJy5kcm9wZG93biBmb3JtJywgZnVuY3Rpb24gKGUpIHsgZS5zdG9wUHJvcGFnYXRpb24oKSB9KVxuICAgIC5vbignY2xpY2suYnMuZHJvcGRvd24uZGF0YS1hcGknLCB0b2dnbGUsIERyb3Bkb3duLnByb3RvdHlwZS50b2dnbGUpXG4gICAgLm9uKCdrZXlkb3duLmJzLmRyb3Bkb3duLmRhdGEtYXBpJywgdG9nZ2xlLCBEcm9wZG93bi5wcm90b3R5cGUua2V5ZG93bilcbiAgICAub24oJ2tleWRvd24uYnMuZHJvcGRvd24uZGF0YS1hcGknLCAnW3JvbGU9XCJtZW51XCJdJywgRHJvcGRvd24ucHJvdG90eXBlLmtleWRvd24pXG4gICAgLm9uKCdrZXlkb3duLmJzLmRyb3Bkb3duLmRhdGEtYXBpJywgJ1tyb2xlPVwibGlzdGJveFwiXScsIERyb3Bkb3duLnByb3RvdHlwZS5rZXlkb3duKVxuXG59KGpRdWVyeSk7XG4iLCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogbW9kYWwuanMgdjMuMy40XG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNtb2RhbHNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNSBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBNT0RBTCBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgTW9kYWwgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyAgICAgICAgICAgICA9IG9wdGlvbnNcbiAgICB0aGlzLiRib2R5ICAgICAgICAgICAgICAgPSAkKGRvY3VtZW50LmJvZHkpXG4gICAgdGhpcy4kZWxlbWVudCAgICAgICAgICAgID0gJChlbGVtZW50KVxuICAgIHRoaXMuJGRpYWxvZyAgICAgICAgICAgICA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLm1vZGFsLWRpYWxvZycpXG4gICAgdGhpcy4kYmFja2Ryb3AgICAgICAgICAgID0gbnVsbFxuICAgIHRoaXMuaXNTaG93biAgICAgICAgICAgICA9IG51bGxcbiAgICB0aGlzLm9yaWdpbmFsQm9keVBhZCAgICAgPSBudWxsXG4gICAgdGhpcy5zY3JvbGxiYXJXaWR0aCAgICAgID0gMFxuICAgIHRoaXMuaWdub3JlQmFja2Ryb3BDbGljayA9IGZhbHNlXG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnJlbW90ZSkge1xuICAgICAgdGhpcy4kZWxlbWVudFxuICAgICAgICAuZmluZCgnLm1vZGFsLWNvbnRlbnQnKVxuICAgICAgICAubG9hZCh0aGlzLm9wdGlvbnMucmVtb3RlLCAkLnByb3h5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2xvYWRlZC5icy5tb2RhbCcpXG4gICAgICAgIH0sIHRoaXMpKVxuICAgIH1cbiAgfVxuXG4gIE1vZGFsLlZFUlNJT04gID0gJzMuMy40J1xuXG4gIE1vZGFsLlRSQU5TSVRJT05fRFVSQVRJT04gPSAzMDBcbiAgTW9kYWwuQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTiA9IDE1MFxuXG4gIE1vZGFsLkRFRkFVTFRTID0ge1xuICAgIGJhY2tkcm9wOiB0cnVlLFxuICAgIGtleWJvYXJkOiB0cnVlLFxuICAgIHNob3c6IHRydWVcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoX3JlbGF0ZWRUYXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy5pc1Nob3duID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coX3JlbGF0ZWRUYXJnZXQpXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIChfcmVsYXRlZFRhcmdldCkge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIHZhciBlICAgID0gJC5FdmVudCgnc2hvdy5icy5tb2RhbCcsIHsgcmVsYXRlZFRhcmdldDogX3JlbGF0ZWRUYXJnZXQgfSlcblxuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihlKVxuXG4gICAgaWYgKHRoaXMuaXNTaG93biB8fCBlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgIHRoaXMuaXNTaG93biA9IHRydWVcblxuICAgIHRoaXMuY2hlY2tTY3JvbGxiYXIoKVxuICAgIHRoaXMuc2V0U2Nyb2xsYmFyKClcbiAgICB0aGlzLiRib2R5LmFkZENsYXNzKCdtb2RhbC1vcGVuJylcblxuICAgIHRoaXMuZXNjYXBlKClcbiAgICB0aGlzLnJlc2l6ZSgpXG5cbiAgICB0aGlzLiRlbGVtZW50Lm9uKCdjbGljay5kaXNtaXNzLmJzLm1vZGFsJywgJ1tkYXRhLWRpc21pc3M9XCJtb2RhbFwiXScsICQucHJveHkodGhpcy5oaWRlLCB0aGlzKSlcblxuICAgIHRoaXMuJGRpYWxvZy5vbignbW91c2Vkb3duLmRpc21pc3MuYnMubW9kYWwnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGF0LiRlbGVtZW50Lm9uZSgnbW91c2V1cC5kaXNtaXNzLmJzLm1vZGFsJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCQoZS50YXJnZXQpLmlzKHRoYXQuJGVsZW1lbnQpKSB0aGF0Lmlnbm9yZUJhY2tkcm9wQ2xpY2sgPSB0cnVlXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICB0aGlzLmJhY2tkcm9wKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0cmFuc2l0aW9uID0gJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgdGhhdC4kZWxlbWVudC5oYXNDbGFzcygnZmFkZScpXG5cbiAgICAgIGlmICghdGhhdC4kZWxlbWVudC5wYXJlbnQoKS5sZW5ndGgpIHtcbiAgICAgICAgdGhhdC4kZWxlbWVudC5hcHBlbmRUbyh0aGF0LiRib2R5KSAvLyBkb24ndCBtb3ZlIG1vZGFscyBkb20gcG9zaXRpb25cbiAgICAgIH1cblxuICAgICAgdGhhdC4kZWxlbWVudFxuICAgICAgICAuc2hvdygpXG4gICAgICAgIC5zY3JvbGxUb3AoMClcblxuICAgICAgdGhhdC5hZGp1c3REaWFsb2coKVxuXG4gICAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgICB0aGF0LiRlbGVtZW50WzBdLm9mZnNldFdpZHRoIC8vIGZvcmNlIHJlZmxvd1xuICAgICAgfVxuXG4gICAgICB0aGF0LiRlbGVtZW50XG4gICAgICAgIC5hZGRDbGFzcygnaW4nKVxuICAgICAgICAuYXR0cignYXJpYS1oaWRkZW4nLCBmYWxzZSlcblxuICAgICAgdGhhdC5lbmZvcmNlRm9jdXMoKVxuXG4gICAgICB2YXIgZSA9ICQuRXZlbnQoJ3Nob3duLmJzLm1vZGFsJywgeyByZWxhdGVkVGFyZ2V0OiBfcmVsYXRlZFRhcmdldCB9KVxuXG4gICAgICB0cmFuc2l0aW9uID9cbiAgICAgICAgdGhhdC4kZGlhbG9nIC8vIHdhaXQgZm9yIG1vZGFsIHRvIHNsaWRlIGluXG4gICAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC4kZWxlbWVudC50cmlnZ2VyKCdmb2N1cycpLnRyaWdnZXIoZSlcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChNb2RhbC5UUkFOU0lUSU9OX0RVUkFUSU9OKSA6XG4gICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignZm9jdXMnKS50cmlnZ2VyKGUpXG4gICAgfSlcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZSkgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICBlID0gJC5FdmVudCgnaGlkZS5icy5tb2RhbCcpXG5cbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoZSlcblxuICAgIGlmICghdGhpcy5pc1Nob3duIHx8IGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgdGhpcy5pc1Nob3duID0gZmFsc2VcblxuICAgIHRoaXMuZXNjYXBlKClcbiAgICB0aGlzLnJlc2l6ZSgpXG5cbiAgICAkKGRvY3VtZW50KS5vZmYoJ2ZvY3VzaW4uYnMubW9kYWwnKVxuXG4gICAgdGhpcy4kZWxlbWVudFxuICAgICAgLnJlbW92ZUNsYXNzKCdpbicpXG4gICAgICAuYXR0cignYXJpYS1oaWRkZW4nLCB0cnVlKVxuICAgICAgLm9mZignY2xpY2suZGlzbWlzcy5icy5tb2RhbCcpXG4gICAgICAub2ZmKCdtb3VzZXVwLmRpc21pc3MuYnMubW9kYWwnKVxuXG4gICAgdGhpcy4kZGlhbG9nLm9mZignbW91c2Vkb3duLmRpc21pc3MuYnMubW9kYWwnKVxuXG4gICAgJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnZmFkZScpID9cbiAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgJC5wcm94eSh0aGlzLmhpZGVNb2RhbCwgdGhpcykpXG4gICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChNb2RhbC5UUkFOU0lUSU9OX0RVUkFUSU9OKSA6XG4gICAgICB0aGlzLmhpZGVNb2RhbCgpXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuZW5mb3JjZUZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICQoZG9jdW1lbnQpXG4gICAgICAub2ZmKCdmb2N1c2luLmJzLm1vZGFsJykgLy8gZ3VhcmQgYWdhaW5zdCBpbmZpbml0ZSBmb2N1cyBsb29wXG4gICAgICAub24oJ2ZvY3VzaW4uYnMubW9kYWwnLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLiRlbGVtZW50WzBdICE9PSBlLnRhcmdldCAmJiAhdGhpcy4kZWxlbWVudC5oYXMoZS50YXJnZXQpLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignZm9jdXMnKVxuICAgICAgICB9XG4gICAgICB9LCB0aGlzKSlcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5lc2NhcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaXNTaG93biAmJiB0aGlzLm9wdGlvbnMua2V5Ym9hcmQpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQub24oJ2tleWRvd24uZGlzbWlzcy5icy5tb2RhbCcsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS53aGljaCA9PSAyNyAmJiB0aGlzLmhpZGUoKVxuICAgICAgfSwgdGhpcykpXG4gICAgfSBlbHNlIGlmICghdGhpcy5pc1Nob3duKSB7XG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZigna2V5ZG93bi5kaXNtaXNzLmJzLm1vZGFsJylcbiAgICB9XG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmlzU2hvd24pIHtcbiAgICAgICQod2luZG93KS5vbigncmVzaXplLmJzLm1vZGFsJywgJC5wcm94eSh0aGlzLmhhbmRsZVVwZGF0ZSwgdGhpcykpXG4gICAgfSBlbHNlIHtcbiAgICAgICQod2luZG93KS5vZmYoJ3Jlc2l6ZS5icy5tb2RhbCcpXG4gICAgfVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmhpZGVNb2RhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICB0aGlzLiRlbGVtZW50LmhpZGUoKVxuICAgIHRoaXMuYmFja2Ryb3AoZnVuY3Rpb24gKCkge1xuICAgICAgdGhhdC4kYm9keS5yZW1vdmVDbGFzcygnbW9kYWwtb3BlbicpXG4gICAgICB0aGF0LnJlc2V0QWRqdXN0bWVudHMoKVxuICAgICAgdGhhdC5yZXNldFNjcm9sbGJhcigpXG4gICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ2hpZGRlbi5icy5tb2RhbCcpXG4gICAgfSlcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5yZW1vdmVCYWNrZHJvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLiRiYWNrZHJvcCAmJiB0aGlzLiRiYWNrZHJvcC5yZW1vdmUoKVxuICAgIHRoaXMuJGJhY2tkcm9wID0gbnVsbFxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmJhY2tkcm9wID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgdmFyIGFuaW1hdGUgPSB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdmYWRlJykgPyAnZmFkZScgOiAnJ1xuXG4gICAgaWYgKHRoaXMuaXNTaG93biAmJiB0aGlzLm9wdGlvbnMuYmFja2Ryb3ApIHtcbiAgICAgIHZhciBkb0FuaW1hdGUgPSAkLnN1cHBvcnQudHJhbnNpdGlvbiAmJiBhbmltYXRlXG5cbiAgICAgIHRoaXMuJGJhY2tkcm9wID0gJCgnPGRpdiBjbGFzcz1cIm1vZGFsLWJhY2tkcm9wICcgKyBhbmltYXRlICsgJ1wiIC8+JylcbiAgICAgICAgLmFwcGVuZFRvKHRoaXMuJGJvZHkpXG5cbiAgICAgIHRoaXMuJGVsZW1lbnQub24oJ2NsaWNrLmRpc21pc3MuYnMubW9kYWwnLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLmlnbm9yZUJhY2tkcm9wQ2xpY2spIHtcbiAgICAgICAgICB0aGlzLmlnbm9yZUJhY2tkcm9wQ2xpY2sgPSBmYWxzZVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmIChlLnRhcmdldCAhPT0gZS5jdXJyZW50VGFyZ2V0KSByZXR1cm5cbiAgICAgICAgdGhpcy5vcHRpb25zLmJhY2tkcm9wID09ICdzdGF0aWMnXG4gICAgICAgICAgPyB0aGlzLiRlbGVtZW50WzBdLmZvY3VzKClcbiAgICAgICAgICA6IHRoaXMuaGlkZSgpXG4gICAgICB9LCB0aGlzKSlcblxuICAgICAgaWYgKGRvQW5pbWF0ZSkgdGhpcy4kYmFja2Ryb3BbMF0ub2Zmc2V0V2lkdGggLy8gZm9yY2UgcmVmbG93XG5cbiAgICAgIHRoaXMuJGJhY2tkcm9wLmFkZENsYXNzKCdpbicpXG5cbiAgICAgIGlmICghY2FsbGJhY2spIHJldHVyblxuXG4gICAgICBkb0FuaW1hdGUgP1xuICAgICAgICB0aGlzLiRiYWNrZHJvcFxuICAgICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGNhbGxiYWNrKVxuICAgICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChNb2RhbC5CQUNLRFJPUF9UUkFOU0lUSU9OX0RVUkFUSU9OKSA6XG4gICAgICAgIGNhbGxiYWNrKClcblxuICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNTaG93biAmJiB0aGlzLiRiYWNrZHJvcCkge1xuICAgICAgdGhpcy4kYmFja2Ryb3AucmVtb3ZlQ2xhc3MoJ2luJylcblxuICAgICAgdmFyIGNhbGxiYWNrUmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGF0LnJlbW92ZUJhY2tkcm9wKClcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKVxuICAgICAgfVxuICAgICAgJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnZmFkZScpID9cbiAgICAgICAgdGhpcy4kYmFja2Ryb3BcbiAgICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCBjYWxsYmFja1JlbW92ZSlcbiAgICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoTW9kYWwuQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgICBjYWxsYmFja1JlbW92ZSgpXG5cbiAgICB9IGVsc2UgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjaygpXG4gICAgfVxuICB9XG5cbiAgLy8gdGhlc2UgZm9sbG93aW5nIG1ldGhvZHMgYXJlIHVzZWQgdG8gaGFuZGxlIG92ZXJmbG93aW5nIG1vZGFsc1xuXG4gIE1vZGFsLnByb3RvdHlwZS5oYW5kbGVVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hZGp1c3REaWFsb2coKVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmFkanVzdERpYWxvZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kYWxJc092ZXJmbG93aW5nID0gdGhpcy4kZWxlbWVudFswXS5zY3JvbGxIZWlnaHQgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0XG5cbiAgICB0aGlzLiRlbGVtZW50LmNzcyh7XG4gICAgICBwYWRkaW5nTGVmdDogICF0aGlzLmJvZHlJc092ZXJmbG93aW5nICYmIG1vZGFsSXNPdmVyZmxvd2luZyA/IHRoaXMuc2Nyb2xsYmFyV2lkdGggOiAnJyxcbiAgICAgIHBhZGRpbmdSaWdodDogdGhpcy5ib2R5SXNPdmVyZmxvd2luZyAmJiAhbW9kYWxJc092ZXJmbG93aW5nID8gdGhpcy5zY3JvbGxiYXJXaWR0aCA6ICcnXG4gICAgfSlcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5yZXNldEFkanVzdG1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuJGVsZW1lbnQuY3NzKHtcbiAgICAgIHBhZGRpbmdMZWZ0OiAnJyxcbiAgICAgIHBhZGRpbmdSaWdodDogJydcbiAgICB9KVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmNoZWNrU2Nyb2xsYmFyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmdWxsV2luZG93V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aFxuICAgIGlmICghZnVsbFdpbmRvd1dpZHRoKSB7IC8vIHdvcmthcm91bmQgZm9yIG1pc3Npbmcgd2luZG93LmlubmVyV2lkdGggaW4gSUU4XG4gICAgICB2YXIgZG9jdW1lbnRFbGVtZW50UmVjdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgZnVsbFdpbmRvd1dpZHRoID0gZG9jdW1lbnRFbGVtZW50UmVjdC5yaWdodCAtIE1hdGguYWJzKGRvY3VtZW50RWxlbWVudFJlY3QubGVmdClcbiAgICB9XG4gICAgdGhpcy5ib2R5SXNPdmVyZmxvd2luZyA9IGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGggPCBmdWxsV2luZG93V2lkdGhcbiAgICB0aGlzLnNjcm9sbGJhcldpZHRoID0gdGhpcy5tZWFzdXJlU2Nyb2xsYmFyKClcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5zZXRTY3JvbGxiYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJvZHlQYWQgPSBwYXJzZUludCgodGhpcy4kYm9keS5jc3MoJ3BhZGRpbmctcmlnaHQnKSB8fCAwKSwgMTApXG4gICAgdGhpcy5vcmlnaW5hbEJvZHlQYWQgPSBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodCB8fCAnJ1xuICAgIGlmICh0aGlzLmJvZHlJc092ZXJmbG93aW5nKSB0aGlzLiRib2R5LmNzcygncGFkZGluZy1yaWdodCcsIGJvZHlQYWQgKyB0aGlzLnNjcm9sbGJhcldpZHRoKVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLnJlc2V0U2Nyb2xsYmFyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuJGJvZHkuY3NzKCdwYWRkaW5nLXJpZ2h0JywgdGhpcy5vcmlnaW5hbEJvZHlQYWQpXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUubWVhc3VyZVNjcm9sbGJhciA9IGZ1bmN0aW9uICgpIHsgLy8gdGh4IHdhbHNoXG4gICAgdmFyIHNjcm9sbERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgc2Nyb2xsRGl2LmNsYXNzTmFtZSA9ICdtb2RhbC1zY3JvbGxiYXItbWVhc3VyZSdcbiAgICB0aGlzLiRib2R5LmFwcGVuZChzY3JvbGxEaXYpXG4gICAgdmFyIHNjcm9sbGJhcldpZHRoID0gc2Nyb2xsRGl2Lm9mZnNldFdpZHRoIC0gc2Nyb2xsRGl2LmNsaWVudFdpZHRoXG4gICAgdGhpcy4kYm9keVswXS5yZW1vdmVDaGlsZChzY3JvbGxEaXYpXG4gICAgcmV0dXJuIHNjcm9sbGJhcldpZHRoXG4gIH1cblxuXG4gIC8vIE1PREFMIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbiwgX3JlbGF0ZWRUYXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgICAgPSAkdGhpcy5kYXRhKCdicy5tb2RhbCcpXG4gICAgICB2YXIgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBNb2RhbC5ERUZBVUxUUywgJHRoaXMuZGF0YSgpLCB0eXBlb2Ygb3B0aW9uID09ICdvYmplY3QnICYmIG9wdGlvbilcblxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy5tb2RhbCcsIChkYXRhID0gbmV3IE1vZGFsKHRoaXMsIG9wdGlvbnMpKSlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0oX3JlbGF0ZWRUYXJnZXQpXG4gICAgICBlbHNlIGlmIChvcHRpb25zLnNob3cpIGRhdGEuc2hvdyhfcmVsYXRlZFRhcmdldClcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4ubW9kYWxcblxuICAkLmZuLm1vZGFsICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4ubW9kYWwuQ29uc3RydWN0b3IgPSBNb2RhbFxuXG5cbiAgLy8gTU9EQUwgTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT1cblxuICAkLmZuLm1vZGFsLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi5tb2RhbCA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIE1PREFMIERBVEEtQVBJXG4gIC8vID09PT09PT09PT09PT09XG5cbiAgJChkb2N1bWVudCkub24oJ2NsaWNrLmJzLm1vZGFsLmRhdGEtYXBpJywgJ1tkYXRhLXRvZ2dsZT1cIm1vZGFsXCJdJywgZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICB2YXIgaHJlZiAgICA9ICR0aGlzLmF0dHIoJ2hyZWYnKVxuICAgIHZhciAkdGFyZ2V0ID0gJCgkdGhpcy5hdHRyKCdkYXRhLXRhcmdldCcpIHx8IChocmVmICYmIGhyZWYucmVwbGFjZSgvLiooPz0jW15cXHNdKyQpLywgJycpKSkgLy8gc3RyaXAgZm9yIGllN1xuICAgIHZhciBvcHRpb24gID0gJHRhcmdldC5kYXRhKCdicy5tb2RhbCcpID8gJ3RvZ2dsZScgOiAkLmV4dGVuZCh7IHJlbW90ZTogIS8jLy50ZXN0KGhyZWYpICYmIGhyZWYgfSwgJHRhcmdldC5kYXRhKCksICR0aGlzLmRhdGEoKSlcblxuICAgIGlmICgkdGhpcy5pcygnYScpKSBlLnByZXZlbnREZWZhdWx0KClcblxuICAgICR0YXJnZXQub25lKCdzaG93LmJzLm1vZGFsJywgZnVuY3Rpb24gKHNob3dFdmVudCkge1xuICAgICAgaWYgKHNob3dFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuIC8vIG9ubHkgcmVnaXN0ZXIgZm9jdXMgcmVzdG9yZXIgaWYgbW9kYWwgd2lsbCBhY3R1YWxseSBnZXQgc2hvd25cbiAgICAgICR0YXJnZXQub25lKCdoaWRkZW4uYnMubW9kYWwnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICR0aGlzLmlzKCc6dmlzaWJsZScpICYmICR0aGlzLnRyaWdnZXIoJ2ZvY3VzJylcbiAgICAgIH0pXG4gICAgfSlcbiAgICBQbHVnaW4uY2FsbCgkdGFyZ2V0LCBvcHRpb24sIHRoaXMpXG4gIH0pXG5cbn0oalF1ZXJ5KTtcbiIsIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBwb3BvdmVyLmpzIHYzLjMuNFxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jcG9wb3ZlcnNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNSBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBQT1BPVkVSIFBVQkxJQyBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgUG9wb3ZlciA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy5pbml0KCdwb3BvdmVyJywgZWxlbWVudCwgb3B0aW9ucylcbiAgfVxuXG4gIGlmICghJC5mbi50b29sdGlwKSB0aHJvdyBuZXcgRXJyb3IoJ1BvcG92ZXIgcmVxdWlyZXMgdG9vbHRpcC5qcycpXG5cbiAgUG9wb3Zlci5WRVJTSU9OICA9ICczLjMuNCdcblxuICBQb3BvdmVyLkRFRkFVTFRTID0gJC5leHRlbmQoe30sICQuZm4udG9vbHRpcC5Db25zdHJ1Y3Rvci5ERUZBVUxUUywge1xuICAgIHBsYWNlbWVudDogJ3JpZ2h0JyxcbiAgICB0cmlnZ2VyOiAnY2xpY2snLFxuICAgIGNvbnRlbnQ6ICcnLFxuICAgIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cInBvcG92ZXJcIiByb2xlPVwidG9vbHRpcFwiPjxkaXYgY2xhc3M9XCJhcnJvd1wiPjwvZGl2PjxoMyBjbGFzcz1cInBvcG92ZXItdGl0bGVcIj48L2gzPjxkaXYgY2xhc3M9XCJwb3BvdmVyLWNvbnRlbnRcIj48L2Rpdj48L2Rpdj4nXG4gIH0pXG5cblxuICAvLyBOT1RFOiBQT1BPVkVSIEVYVEVORFMgdG9vbHRpcC5qc1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIFBvcG92ZXIucHJvdG90eXBlID0gJC5leHRlbmQoe30sICQuZm4udG9vbHRpcC5Db25zdHJ1Y3Rvci5wcm90b3R5cGUpXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb3BvdmVyXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuZ2V0RGVmYXVsdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFBvcG92ZXIuREVGQVVMVFNcbiAgfVxuXG4gIFBvcG92ZXIucHJvdG90eXBlLnNldENvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyICR0aXAgICAgPSB0aGlzLnRpcCgpXG4gICAgdmFyIHRpdGxlICAgPSB0aGlzLmdldFRpdGxlKClcbiAgICB2YXIgY29udGVudCA9IHRoaXMuZ2V0Q29udGVudCgpXG5cbiAgICAkdGlwLmZpbmQoJy5wb3BvdmVyLXRpdGxlJylbdGhpcy5vcHRpb25zLmh0bWwgPyAnaHRtbCcgOiAndGV4dCddKHRpdGxlKVxuICAgICR0aXAuZmluZCgnLnBvcG92ZXItY29udGVudCcpLmNoaWxkcmVuKCkuZGV0YWNoKCkuZW5kKClbIC8vIHdlIHVzZSBhcHBlbmQgZm9yIGh0bWwgb2JqZWN0cyB0byBtYWludGFpbiBqcyBldmVudHNcbiAgICAgIHRoaXMub3B0aW9ucy5odG1sID8gKHR5cGVvZiBjb250ZW50ID09ICdzdHJpbmcnID8gJ2h0bWwnIDogJ2FwcGVuZCcpIDogJ3RleHQnXG4gICAgXShjb250ZW50KVxuXG4gICAgJHRpcC5yZW1vdmVDbGFzcygnZmFkZSB0b3AgYm90dG9tIGxlZnQgcmlnaHQgaW4nKVxuXG4gICAgLy8gSUU4IGRvZXNuJ3QgYWNjZXB0IGhpZGluZyB2aWEgdGhlIGA6ZW1wdHlgIHBzZXVkbyBzZWxlY3Rvciwgd2UgaGF2ZSB0byBkb1xuICAgIC8vIHRoaXMgbWFudWFsbHkgYnkgY2hlY2tpbmcgdGhlIGNvbnRlbnRzLlxuICAgIGlmICghJHRpcC5maW5kKCcucG9wb3Zlci10aXRsZScpLmh0bWwoKSkgJHRpcC5maW5kKCcucG9wb3Zlci10aXRsZScpLmhpZGUoKVxuICB9XG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuaGFzQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUaXRsZSgpIHx8IHRoaXMuZ2V0Q29udGVudCgpXG4gIH1cblxuICBQb3BvdmVyLnByb3RvdHlwZS5nZXRDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciAkZSA9IHRoaXMuJGVsZW1lbnRcbiAgICB2YXIgbyAgPSB0aGlzLm9wdGlvbnNcblxuICAgIHJldHVybiAkZS5hdHRyKCdkYXRhLWNvbnRlbnQnKVxuICAgICAgfHwgKHR5cGVvZiBvLmNvbnRlbnQgPT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICBvLmNvbnRlbnQuY2FsbCgkZVswXSkgOlxuICAgICAgICAgICAgby5jb250ZW50KVxuICB9XG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuYXJyb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLiRhcnJvdyA9IHRoaXMuJGFycm93IHx8IHRoaXMudGlwKCkuZmluZCgnLmFycm93JykpXG4gIH1cblxuXG4gIC8vIFBPUE9WRVIgUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgICAgPSAkdGhpcy5kYXRhKCdicy5wb3BvdmVyJylcbiAgICAgIHZhciBvcHRpb25zID0gdHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0JyAmJiBvcHRpb25cblxuICAgICAgaWYgKCFkYXRhICYmIC9kZXN0cm95fGhpZGUvLnRlc3Qob3B0aW9uKSkgcmV0dXJuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLnBvcG92ZXInLCAoZGF0YSA9IG5ldyBQb3BvdmVyKHRoaXMsIG9wdGlvbnMpKSlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0oKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5wb3BvdmVyXG5cbiAgJC5mbi5wb3BvdmVyICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4ucG9wb3Zlci5Db25zdHJ1Y3RvciA9IFBvcG92ZXJcblxuXG4gIC8vIFBPUE9WRVIgTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT09PVxuXG4gICQuZm4ucG9wb3Zlci5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4ucG9wb3ZlciA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxufShqUXVlcnkpO1xuIiwiLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IHNjcm9sbHNweS5qcyB2My4zLjRcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI3Njcm9sbHNweVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE1IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIFNDUk9MTFNQWSBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gU2Nyb2xsU3B5KGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRib2R5ICAgICAgICAgID0gJChkb2N1bWVudC5ib2R5KVxuICAgIHRoaXMuJHNjcm9sbEVsZW1lbnQgPSAkKGVsZW1lbnQpLmlzKGRvY3VtZW50LmJvZHkpID8gJCh3aW5kb3cpIDogJChlbGVtZW50KVxuICAgIHRoaXMub3B0aW9ucyAgICAgICAgPSAkLmV4dGVuZCh7fSwgU2Nyb2xsU3B5LkRFRkFVTFRTLCBvcHRpb25zKVxuICAgIHRoaXMuc2VsZWN0b3IgICAgICAgPSAodGhpcy5vcHRpb25zLnRhcmdldCB8fCAnJykgKyAnIC5uYXYgbGkgPiBhJ1xuICAgIHRoaXMub2Zmc2V0cyAgICAgICAgPSBbXVxuICAgIHRoaXMudGFyZ2V0cyAgICAgICAgPSBbXVxuICAgIHRoaXMuYWN0aXZlVGFyZ2V0ICAgPSBudWxsXG4gICAgdGhpcy5zY3JvbGxIZWlnaHQgICA9IDBcblxuICAgIHRoaXMuJHNjcm9sbEVsZW1lbnQub24oJ3Njcm9sbC5icy5zY3JvbGxzcHknLCAkLnByb3h5KHRoaXMucHJvY2VzcywgdGhpcykpXG4gICAgdGhpcy5yZWZyZXNoKClcbiAgICB0aGlzLnByb2Nlc3MoKVxuICB9XG5cbiAgU2Nyb2xsU3B5LlZFUlNJT04gID0gJzMuMy40J1xuXG4gIFNjcm9sbFNweS5ERUZBVUxUUyA9IHtcbiAgICBvZmZzZXQ6IDEwXG4gIH1cblxuICBTY3JvbGxTcHkucHJvdG90eXBlLmdldFNjcm9sbEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy4kc2Nyb2xsRWxlbWVudFswXS5zY3JvbGxIZWlnaHQgfHwgTWF0aC5tYXgodGhpcy4kYm9keVswXS5zY3JvbGxIZWlnaHQsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQpXG4gIH1cblxuICBTY3JvbGxTcHkucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRoYXQgICAgICAgICAgPSB0aGlzXG4gICAgdmFyIG9mZnNldE1ldGhvZCAgPSAnb2Zmc2V0J1xuICAgIHZhciBvZmZzZXRCYXNlICAgID0gMFxuXG4gICAgdGhpcy5vZmZzZXRzICAgICAgPSBbXVxuICAgIHRoaXMudGFyZ2V0cyAgICAgID0gW11cbiAgICB0aGlzLnNjcm9sbEhlaWdodCA9IHRoaXMuZ2V0U2Nyb2xsSGVpZ2h0KClcblxuICAgIGlmICghJC5pc1dpbmRvdyh0aGlzLiRzY3JvbGxFbGVtZW50WzBdKSkge1xuICAgICAgb2Zmc2V0TWV0aG9kID0gJ3Bvc2l0aW9uJ1xuICAgICAgb2Zmc2V0QmFzZSAgID0gdGhpcy4kc2Nyb2xsRWxlbWVudC5zY3JvbGxUb3AoKVxuICAgIH1cblxuICAgIHRoaXMuJGJvZHlcbiAgICAgIC5maW5kKHRoaXMuc2VsZWN0b3IpXG4gICAgICAubWFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICRlbCAgID0gJCh0aGlzKVxuICAgICAgICB2YXIgaHJlZiAgPSAkZWwuZGF0YSgndGFyZ2V0JykgfHwgJGVsLmF0dHIoJ2hyZWYnKVxuICAgICAgICB2YXIgJGhyZWYgPSAvXiMuLy50ZXN0KGhyZWYpICYmICQoaHJlZilcblxuICAgICAgICByZXR1cm4gKCRocmVmXG4gICAgICAgICAgJiYgJGhyZWYubGVuZ3RoXG4gICAgICAgICAgJiYgJGhyZWYuaXMoJzp2aXNpYmxlJylcbiAgICAgICAgICAmJiBbWyRocmVmW29mZnNldE1ldGhvZF0oKS50b3AgKyBvZmZzZXRCYXNlLCBocmVmXV0pIHx8IG51bGxcbiAgICAgIH0pXG4gICAgICAuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYVswXSAtIGJbMF0gfSlcbiAgICAgIC5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhhdC5vZmZzZXRzLnB1c2godGhpc1swXSlcbiAgICAgICAgdGhhdC50YXJnZXRzLnB1c2godGhpc1sxXSlcbiAgICAgIH0pXG4gIH1cblxuICBTY3JvbGxTcHkucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNjcm9sbFRvcCAgICA9IHRoaXMuJHNjcm9sbEVsZW1lbnQuc2Nyb2xsVG9wKCkgKyB0aGlzLm9wdGlvbnMub2Zmc2V0XG4gICAgdmFyIHNjcm9sbEhlaWdodCA9IHRoaXMuZ2V0U2Nyb2xsSGVpZ2h0KClcbiAgICB2YXIgbWF4U2Nyb2xsICAgID0gdGhpcy5vcHRpb25zLm9mZnNldCArIHNjcm9sbEhlaWdodCAtIHRoaXMuJHNjcm9sbEVsZW1lbnQuaGVpZ2h0KClcbiAgICB2YXIgb2Zmc2V0cyAgICAgID0gdGhpcy5vZmZzZXRzXG4gICAgdmFyIHRhcmdldHMgICAgICA9IHRoaXMudGFyZ2V0c1xuICAgIHZhciBhY3RpdmVUYXJnZXQgPSB0aGlzLmFjdGl2ZVRhcmdldFxuICAgIHZhciBpXG5cbiAgICBpZiAodGhpcy5zY3JvbGxIZWlnaHQgIT0gc2Nyb2xsSGVpZ2h0KSB7XG4gICAgICB0aGlzLnJlZnJlc2goKVxuICAgIH1cblxuICAgIGlmIChzY3JvbGxUb3AgPj0gbWF4U2Nyb2xsKSB7XG4gICAgICByZXR1cm4gYWN0aXZlVGFyZ2V0ICE9IChpID0gdGFyZ2V0c1t0YXJnZXRzLmxlbmd0aCAtIDFdKSAmJiB0aGlzLmFjdGl2YXRlKGkpXG4gICAgfVxuXG4gICAgaWYgKGFjdGl2ZVRhcmdldCAmJiBzY3JvbGxUb3AgPCBvZmZzZXRzWzBdKSB7XG4gICAgICB0aGlzLmFjdGl2ZVRhcmdldCA9IG51bGxcbiAgICAgIHJldHVybiB0aGlzLmNsZWFyKClcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBvZmZzZXRzLmxlbmd0aDsgaS0tOykge1xuICAgICAgYWN0aXZlVGFyZ2V0ICE9IHRhcmdldHNbaV1cbiAgICAgICAgJiYgc2Nyb2xsVG9wID49IG9mZnNldHNbaV1cbiAgICAgICAgJiYgKG9mZnNldHNbaSArIDFdID09PSB1bmRlZmluZWQgfHwgc2Nyb2xsVG9wIDwgb2Zmc2V0c1tpICsgMV0pXG4gICAgICAgICYmIHRoaXMuYWN0aXZhdGUodGFyZ2V0c1tpXSlcbiAgICB9XG4gIH1cblxuICBTY3JvbGxTcHkucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHRoaXMuYWN0aXZlVGFyZ2V0ID0gdGFyZ2V0XG5cbiAgICB0aGlzLmNsZWFyKClcblxuICAgIHZhciBzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3IgK1xuICAgICAgJ1tkYXRhLXRhcmdldD1cIicgKyB0YXJnZXQgKyAnXCJdLCcgK1xuICAgICAgdGhpcy5zZWxlY3RvciArICdbaHJlZj1cIicgKyB0YXJnZXQgKyAnXCJdJ1xuXG4gICAgdmFyIGFjdGl2ZSA9ICQoc2VsZWN0b3IpXG4gICAgICAucGFyZW50cygnbGknKVxuICAgICAgLmFkZENsYXNzKCdhY3RpdmUnKVxuXG4gICAgaWYgKGFjdGl2ZS5wYXJlbnQoJy5kcm9wZG93bi1tZW51JykubGVuZ3RoKSB7XG4gICAgICBhY3RpdmUgPSBhY3RpdmVcbiAgICAgICAgLmNsb3Nlc3QoJ2xpLmRyb3Bkb3duJylcbiAgICAgICAgLmFkZENsYXNzKCdhY3RpdmUnKVxuICAgIH1cblxuICAgIGFjdGl2ZS50cmlnZ2VyKCdhY3RpdmF0ZS5icy5zY3JvbGxzcHknKVxuICB9XG5cbiAgU2Nyb2xsU3B5LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAkKHRoaXMuc2VsZWN0b3IpXG4gICAgICAucGFyZW50c1VudGlsKHRoaXMub3B0aW9ucy50YXJnZXQsICcuYWN0aXZlJylcbiAgICAgIC5yZW1vdmVDbGFzcygnYWN0aXZlJylcbiAgfVxuXG5cbiAgLy8gU0NST0xMU1BZIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgICAgPSAkdGhpcy5kYXRhKCdicy5zY3JvbGxzcHknKVxuICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uID09ICdvYmplY3QnICYmIG9wdGlvblxuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLnNjcm9sbHNweScsIChkYXRhID0gbmV3IFNjcm9sbFNweSh0aGlzLCBvcHRpb25zKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dKClcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4uc2Nyb2xsc3B5XG5cbiAgJC5mbi5zY3JvbGxzcHkgICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi5zY3JvbGxzcHkuQ29uc3RydWN0b3IgPSBTY3JvbGxTcHlcblxuXG4gIC8vIFNDUk9MTFNQWSBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PT09PT1cblxuICAkLmZuLnNjcm9sbHNweS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4uc2Nyb2xsc3B5ID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gU0NST0xMU1BZIERBVEEtQVBJXG4gIC8vID09PT09PT09PT09PT09PT09PVxuXG4gICQod2luZG93KS5vbignbG9hZC5icy5zY3JvbGxzcHkuZGF0YS1hcGknLCBmdW5jdGlvbiAoKSB7XG4gICAgJCgnW2RhdGEtc3B5PVwic2Nyb2xsXCJdJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHNweSA9ICQodGhpcylcbiAgICAgIFBsdWdpbi5jYWxsKCRzcHksICRzcHkuZGF0YSgpKVxuICAgIH0pXG4gIH0pXG5cbn0oalF1ZXJ5KTtcbiIsIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiB0YWIuanMgdjMuMy40XG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyN0YWJzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTUgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gVEFCIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgVGFiID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSAkKGVsZW1lbnQpXG4gIH1cblxuICBUYWIuVkVSU0lPTiA9ICczLjMuNCdcblxuICBUYWIuVFJBTlNJVElPTl9EVVJBVElPTiA9IDE1MFxuXG4gIFRhYi5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgJHRoaXMgICAgPSB0aGlzLmVsZW1lbnRcbiAgICB2YXIgJHVsICAgICAgPSAkdGhpcy5jbG9zZXN0KCd1bDpub3QoLmRyb3Bkb3duLW1lbnUpJylcbiAgICB2YXIgc2VsZWN0b3IgPSAkdGhpcy5kYXRhKCd0YXJnZXQnKVxuXG4gICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgc2VsZWN0b3IgPSAkdGhpcy5hdHRyKCdocmVmJylcbiAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IgJiYgc2VsZWN0b3IucmVwbGFjZSgvLiooPz0jW15cXHNdKiQpLywgJycpIC8vIHN0cmlwIGZvciBpZTdcbiAgICB9XG5cbiAgICBpZiAoJHRoaXMucGFyZW50KCdsaScpLmhhc0NsYXNzKCdhY3RpdmUnKSkgcmV0dXJuXG5cbiAgICB2YXIgJHByZXZpb3VzID0gJHVsLmZpbmQoJy5hY3RpdmU6bGFzdCBhJylcbiAgICB2YXIgaGlkZUV2ZW50ID0gJC5FdmVudCgnaGlkZS5icy50YWInLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiAkdGhpc1swXVxuICAgIH0pXG4gICAgdmFyIHNob3dFdmVudCA9ICQuRXZlbnQoJ3Nob3cuYnMudGFiJywge1xuICAgICAgcmVsYXRlZFRhcmdldDogJHByZXZpb3VzWzBdXG4gICAgfSlcblxuICAgICRwcmV2aW91cy50cmlnZ2VyKGhpZGVFdmVudClcbiAgICAkdGhpcy50cmlnZ2VyKHNob3dFdmVudClcblxuICAgIGlmIChzaG93RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgaGlkZUV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgIHZhciAkdGFyZ2V0ID0gJChzZWxlY3RvcilcblxuICAgIHRoaXMuYWN0aXZhdGUoJHRoaXMuY2xvc2VzdCgnbGknKSwgJHVsKVxuICAgIHRoaXMuYWN0aXZhdGUoJHRhcmdldCwgJHRhcmdldC5wYXJlbnQoKSwgZnVuY3Rpb24gKCkge1xuICAgICAgJHByZXZpb3VzLnRyaWdnZXIoe1xuICAgICAgICB0eXBlOiAnaGlkZGVuLmJzLnRhYicsXG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6ICR0aGlzWzBdXG4gICAgICB9KVxuICAgICAgJHRoaXMudHJpZ2dlcih7XG4gICAgICAgIHR5cGU6ICdzaG93bi5icy50YWInLFxuICAgICAgICByZWxhdGVkVGFyZ2V0OiAkcHJldmlvdXNbMF1cbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIFRhYi5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIHZhciAkYWN0aXZlICAgID0gY29udGFpbmVyLmZpbmQoJz4gLmFjdGl2ZScpXG4gICAgdmFyIHRyYW5zaXRpb24gPSBjYWxsYmFja1xuICAgICAgJiYgJC5zdXBwb3J0LnRyYW5zaXRpb25cbiAgICAgICYmICgoJGFjdGl2ZS5sZW5ndGggJiYgJGFjdGl2ZS5oYXNDbGFzcygnZmFkZScpKSB8fCAhIWNvbnRhaW5lci5maW5kKCc+IC5mYWRlJykubGVuZ3RoKVxuXG4gICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICRhY3RpdmVcbiAgICAgICAgLnJlbW92ZUNsYXNzKCdhY3RpdmUnKVxuICAgICAgICAuZmluZCgnPiAuZHJvcGRvd24tbWVudSA+IC5hY3RpdmUnKVxuICAgICAgICAgIC5yZW1vdmVDbGFzcygnYWN0aXZlJylcbiAgICAgICAgLmVuZCgpXG4gICAgICAgIC5maW5kKCdbZGF0YS10b2dnbGU9XCJ0YWJcIl0nKVxuICAgICAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgZmFsc2UpXG5cbiAgICAgIGVsZW1lbnRcbiAgICAgICAgLmFkZENsYXNzKCdhY3RpdmUnKVxuICAgICAgICAuZmluZCgnW2RhdGEtdG9nZ2xlPVwidGFiXCJdJylcbiAgICAgICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIHRydWUpXG5cbiAgICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICAgIGVsZW1lbnRbMF0ub2Zmc2V0V2lkdGggLy8gcmVmbG93IGZvciB0cmFuc2l0aW9uXG4gICAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoJ2luJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2ZhZGUnKVxuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudC5wYXJlbnQoJy5kcm9wZG93bi1tZW51JykubGVuZ3RoKSB7XG4gICAgICAgIGVsZW1lbnRcbiAgICAgICAgICAuY2xvc2VzdCgnbGkuZHJvcGRvd24nKVxuICAgICAgICAgICAgLmFkZENsYXNzKCdhY3RpdmUnKVxuICAgICAgICAgIC5lbmQoKVxuICAgICAgICAgIC5maW5kKCdbZGF0YS10b2dnbGU9XCJ0YWJcIl0nKVxuICAgICAgICAgICAgLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKVxuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpXG4gICAgfVxuXG4gICAgJGFjdGl2ZS5sZW5ndGggJiYgdHJhbnNpdGlvbiA/XG4gICAgICAkYWN0aXZlXG4gICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIG5leHQpXG4gICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChUYWIuVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgbmV4dCgpXG5cbiAgICAkYWN0aXZlLnJlbW92ZUNsYXNzKCdpbicpXG4gIH1cblxuXG4gIC8vIFRBQiBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgPSAkdGhpcy5kYXRhKCdicy50YWInKVxuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLnRhYicsIChkYXRhID0gbmV3IFRhYih0aGlzKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dKClcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4udGFiXG5cbiAgJC5mbi50YWIgICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi50YWIuQ29uc3RydWN0b3IgPSBUYWJcblxuXG4gIC8vIFRBQiBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT1cblxuICAkLmZuLnRhYi5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4udGFiID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gVEFCIERBVEEtQVBJXG4gIC8vID09PT09PT09PT09PVxuXG4gIHZhciBjbGlja0hhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIFBsdWdpbi5jYWxsKCQodGhpcyksICdzaG93JylcbiAgfVxuXG4gICQoZG9jdW1lbnQpXG4gICAgLm9uKCdjbGljay5icy50YWIuZGF0YS1hcGknLCAnW2RhdGEtdG9nZ2xlPVwidGFiXCJdJywgY2xpY2tIYW5kbGVyKVxuICAgIC5vbignY2xpY2suYnMudGFiLmRhdGEtYXBpJywgJ1tkYXRhLXRvZ2dsZT1cInBpbGxcIl0nLCBjbGlja0hhbmRsZXIpXG5cbn0oalF1ZXJ5KTtcbiIsIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiB0b29sdGlwLmpzIHYzLjMuNFxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jdG9vbHRpcFxuICogSW5zcGlyZWQgYnkgdGhlIG9yaWdpbmFsIGpRdWVyeS50aXBzeSBieSBKYXNvbiBGcmFtZVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE1IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIFRPT0xUSVAgUFVCTElDIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBUb29sdGlwID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnR5cGUgICAgICAgPSBudWxsXG4gICAgdGhpcy5vcHRpb25zICAgID0gbnVsbFxuICAgIHRoaXMuZW5hYmxlZCAgICA9IG51bGxcbiAgICB0aGlzLnRpbWVvdXQgICAgPSBudWxsXG4gICAgdGhpcy5ob3ZlclN0YXRlID0gbnVsbFxuICAgIHRoaXMuJGVsZW1lbnQgICA9IG51bGxcblxuICAgIHRoaXMuaW5pdCgndG9vbHRpcCcsIGVsZW1lbnQsIG9wdGlvbnMpXG4gIH1cblxuICBUb29sdGlwLlZFUlNJT04gID0gJzMuMy40J1xuXG4gIFRvb2x0aXAuVFJBTlNJVElPTl9EVVJBVElPTiA9IDE1MFxuXG4gIFRvb2x0aXAuREVGQVVMVFMgPSB7XG4gICAgYW5pbWF0aW9uOiB0cnVlLFxuICAgIHBsYWNlbWVudDogJ3RvcCcsXG4gICAgc2VsZWN0b3I6IGZhbHNlLFxuICAgIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cInRvb2x0aXBcIiByb2xlPVwidG9vbHRpcFwiPjxkaXYgY2xhc3M9XCJ0b29sdGlwLWFycm93XCI+PC9kaXY+PGRpdiBjbGFzcz1cInRvb2x0aXAtaW5uZXJcIj48L2Rpdj48L2Rpdj4nLFxuICAgIHRyaWdnZXI6ICdob3ZlciBmb2N1cycsXG4gICAgdGl0bGU6ICcnLFxuICAgIGRlbGF5OiAwLFxuICAgIGh0bWw6IGZhbHNlLFxuICAgIGNvbnRhaW5lcjogZmFsc2UsXG4gICAgdmlld3BvcnQ6IHtcbiAgICAgIHNlbGVjdG9yOiAnYm9keScsXG4gICAgICBwYWRkaW5nOiAwXG4gICAgfVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICh0eXBlLCBlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy5lbmFibGVkICAgPSB0cnVlXG4gICAgdGhpcy50eXBlICAgICAgPSB0eXBlXG4gICAgdGhpcy4kZWxlbWVudCAgPSAkKGVsZW1lbnQpXG4gICAgdGhpcy5vcHRpb25zICAgPSB0aGlzLmdldE9wdGlvbnMob3B0aW9ucylcbiAgICB0aGlzLiR2aWV3cG9ydCA9IHRoaXMub3B0aW9ucy52aWV3cG9ydCAmJiAkKHRoaXMub3B0aW9ucy52aWV3cG9ydC5zZWxlY3RvciB8fCB0aGlzLm9wdGlvbnMudmlld3BvcnQpXG5cbiAgICBpZiAodGhpcy4kZWxlbWVudFswXSBpbnN0YW5jZW9mIGRvY3VtZW50LmNvbnN0cnVjdG9yICYmICF0aGlzLm9wdGlvbnMuc2VsZWN0b3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHNlbGVjdG9yYCBvcHRpb24gbXVzdCBiZSBzcGVjaWZpZWQgd2hlbiBpbml0aWFsaXppbmcgJyArIHRoaXMudHlwZSArICcgb24gdGhlIHdpbmRvdy5kb2N1bWVudCBvYmplY3QhJylcbiAgICB9XG5cbiAgICB2YXIgdHJpZ2dlcnMgPSB0aGlzLm9wdGlvbnMudHJpZ2dlci5zcGxpdCgnICcpXG5cbiAgICBmb3IgKHZhciBpID0gdHJpZ2dlcnMubGVuZ3RoOyBpLS07KSB7XG4gICAgICB2YXIgdHJpZ2dlciA9IHRyaWdnZXJzW2ldXG5cbiAgICAgIGlmICh0cmlnZ2VyID09ICdjbGljaycpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbignY2xpY2suJyArIHRoaXMudHlwZSwgdGhpcy5vcHRpb25zLnNlbGVjdG9yLCAkLnByb3h5KHRoaXMudG9nZ2xlLCB0aGlzKSlcbiAgICAgIH0gZWxzZSBpZiAodHJpZ2dlciAhPSAnbWFudWFsJykge1xuICAgICAgICB2YXIgZXZlbnRJbiAgPSB0cmlnZ2VyID09ICdob3ZlcicgPyAnbW91c2VlbnRlcicgOiAnZm9jdXNpbidcbiAgICAgICAgdmFyIGV2ZW50T3V0ID0gdHJpZ2dlciA9PSAnaG92ZXInID8gJ21vdXNlbGVhdmUnIDogJ2ZvY3Vzb3V0J1xuXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oZXZlbnRJbiAgKyAnLicgKyB0aGlzLnR5cGUsIHRoaXMub3B0aW9ucy5zZWxlY3RvciwgJC5wcm94eSh0aGlzLmVudGVyLCB0aGlzKSlcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbihldmVudE91dCArICcuJyArIHRoaXMudHlwZSwgdGhpcy5vcHRpb25zLnNlbGVjdG9yLCAkLnByb3h5KHRoaXMubGVhdmUsIHRoaXMpKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucy5zZWxlY3RvciA/XG4gICAgICAodGhpcy5fb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIHsgdHJpZ2dlcjogJ21hbnVhbCcsIHNlbGVjdG9yOiAnJyB9KSkgOlxuICAgICAgdGhpcy5maXhUaXRsZSgpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXREZWZhdWx0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVG9vbHRpcC5ERUZBVUxUU1xuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCB0aGlzLmdldERlZmF1bHRzKCksIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKVxuXG4gICAgaWYgKG9wdGlvbnMuZGVsYXkgJiYgdHlwZW9mIG9wdGlvbnMuZGVsYXkgPT0gJ251bWJlcicpIHtcbiAgICAgIG9wdGlvbnMuZGVsYXkgPSB7XG4gICAgICAgIHNob3c6IG9wdGlvbnMuZGVsYXksXG4gICAgICAgIGhpZGU6IG9wdGlvbnMuZGVsYXlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3B0aW9uc1xuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZ2V0RGVsZWdhdGVPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHRpb25zICA9IHt9XG4gICAgdmFyIGRlZmF1bHRzID0gdGhpcy5nZXREZWZhdWx0cygpXG5cbiAgICB0aGlzLl9vcHRpb25zICYmICQuZWFjaCh0aGlzLl9vcHRpb25zLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKGRlZmF1bHRzW2tleV0gIT0gdmFsdWUpIG9wdGlvbnNba2V5XSA9IHZhbHVlXG4gICAgfSlcblxuICAgIHJldHVybiBvcHRpb25zXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5lbnRlciA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgc2VsZiA9IG9iaiBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3IgP1xuICAgICAgb2JqIDogJChvYmouY3VycmVudFRhcmdldCkuZGF0YSgnYnMuJyArIHRoaXMudHlwZSlcblxuICAgIGlmIChzZWxmICYmIHNlbGYuJHRpcCAmJiBzZWxmLiR0aXAuaXMoJzp2aXNpYmxlJykpIHtcbiAgICAgIHNlbGYuaG92ZXJTdGF0ZSA9ICdpbidcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghc2VsZikge1xuICAgICAgc2VsZiA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKG9iai5jdXJyZW50VGFyZ2V0LCB0aGlzLmdldERlbGVnYXRlT3B0aW9ucygpKVxuICAgICAgJChvYmouY3VycmVudFRhcmdldCkuZGF0YSgnYnMuJyArIHRoaXMudHlwZSwgc2VsZilcbiAgICB9XG5cbiAgICBjbGVhclRpbWVvdXQoc2VsZi50aW1lb3V0KVxuXG4gICAgc2VsZi5ob3ZlclN0YXRlID0gJ2luJ1xuXG4gICAgaWYgKCFzZWxmLm9wdGlvbnMuZGVsYXkgfHwgIXNlbGYub3B0aW9ucy5kZWxheS5zaG93KSByZXR1cm4gc2VsZi5zaG93KClcblxuICAgIHNlbGYudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuaG92ZXJTdGF0ZSA9PSAnaW4nKSBzZWxmLnNob3coKVxuICAgIH0sIHNlbGYub3B0aW9ucy5kZWxheS5zaG93KVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUubGVhdmUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHNlbGYgPSBvYmogaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yID9cbiAgICAgIG9iaiA6ICQob2JqLmN1cnJlbnRUYXJnZXQpLmRhdGEoJ2JzLicgKyB0aGlzLnR5cGUpXG5cbiAgICBpZiAoIXNlbGYpIHtcbiAgICAgIHNlbGYgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihvYmouY3VycmVudFRhcmdldCwgdGhpcy5nZXREZWxlZ2F0ZU9wdGlvbnMoKSlcbiAgICAgICQob2JqLmN1cnJlbnRUYXJnZXQpLmRhdGEoJ2JzLicgKyB0aGlzLnR5cGUsIHNlbGYpXG4gICAgfVxuXG4gICAgY2xlYXJUaW1lb3V0KHNlbGYudGltZW91dClcblxuICAgIHNlbGYuaG92ZXJTdGF0ZSA9ICdvdXQnXG5cbiAgICBpZiAoIXNlbGYub3B0aW9ucy5kZWxheSB8fCAhc2VsZi5vcHRpb25zLmRlbGF5LmhpZGUpIHJldHVybiBzZWxmLmhpZGUoKVxuXG4gICAgc2VsZi50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5ob3ZlclN0YXRlID09ICdvdXQnKSBzZWxmLmhpZGUoKVxuICAgIH0sIHNlbGYub3B0aW9ucy5kZWxheS5oaWRlKVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZSA9ICQuRXZlbnQoJ3Nob3cuYnMuJyArIHRoaXMudHlwZSlcblxuICAgIGlmICh0aGlzLmhhc0NvbnRlbnQoKSAmJiB0aGlzLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihlKVxuXG4gICAgICB2YXIgaW5Eb20gPSAkLmNvbnRhaW5zKHRoaXMuJGVsZW1lbnRbMF0ub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHRoaXMuJGVsZW1lbnRbMF0pXG4gICAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCAhaW5Eb20pIHJldHVyblxuICAgICAgdmFyIHRoYXQgPSB0aGlzXG5cbiAgICAgIHZhciAkdGlwID0gdGhpcy50aXAoKVxuXG4gICAgICB2YXIgdGlwSWQgPSB0aGlzLmdldFVJRCh0aGlzLnR5cGUpXG5cbiAgICAgIHRoaXMuc2V0Q29udGVudCgpXG4gICAgICAkdGlwLmF0dHIoJ2lkJywgdGlwSWQpXG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ2FyaWEtZGVzY3JpYmVkYnknLCB0aXBJZClcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbmltYXRpb24pICR0aXAuYWRkQ2xhc3MoJ2ZhZGUnKVxuXG4gICAgICB2YXIgcGxhY2VtZW50ID0gdHlwZW9mIHRoaXMub3B0aW9ucy5wbGFjZW1lbnQgPT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgIHRoaXMub3B0aW9ucy5wbGFjZW1lbnQuY2FsbCh0aGlzLCAkdGlwWzBdLCB0aGlzLiRlbGVtZW50WzBdKSA6XG4gICAgICAgIHRoaXMub3B0aW9ucy5wbGFjZW1lbnRcblxuICAgICAgdmFyIGF1dG9Ub2tlbiA9IC9cXHM/YXV0bz9cXHM/L2lcbiAgICAgIHZhciBhdXRvUGxhY2UgPSBhdXRvVG9rZW4udGVzdChwbGFjZW1lbnQpXG4gICAgICBpZiAoYXV0b1BsYWNlKSBwbGFjZW1lbnQgPSBwbGFjZW1lbnQucmVwbGFjZShhdXRvVG9rZW4sICcnKSB8fCAndG9wJ1xuXG4gICAgICAkdGlwXG4gICAgICAgIC5kZXRhY2goKVxuICAgICAgICAuY3NzKHsgdG9wOiAwLCBsZWZ0OiAwLCBkaXNwbGF5OiAnYmxvY2snIH0pXG4gICAgICAgIC5hZGRDbGFzcyhwbGFjZW1lbnQpXG4gICAgICAgIC5kYXRhKCdicy4nICsgdGhpcy50eXBlLCB0aGlzKVxuXG4gICAgICB0aGlzLm9wdGlvbnMuY29udGFpbmVyID8gJHRpcC5hcHBlbmRUbyh0aGlzLm9wdGlvbnMuY29udGFpbmVyKSA6ICR0aXAuaW5zZXJ0QWZ0ZXIodGhpcy4kZWxlbWVudClcblxuICAgICAgdmFyIHBvcyAgICAgICAgICA9IHRoaXMuZ2V0UG9zaXRpb24oKVxuICAgICAgdmFyIGFjdHVhbFdpZHRoICA9ICR0aXBbMF0ub2Zmc2V0V2lkdGhcbiAgICAgIHZhciBhY3R1YWxIZWlnaHQgPSAkdGlwWzBdLm9mZnNldEhlaWdodFxuXG4gICAgICBpZiAoYXV0b1BsYWNlKSB7XG4gICAgICAgIHZhciBvcmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRcbiAgICAgICAgdmFyICRjb250YWluZXIgICA9IHRoaXMub3B0aW9ucy5jb250YWluZXIgPyAkKHRoaXMub3B0aW9ucy5jb250YWluZXIpIDogdGhpcy4kZWxlbWVudC5wYXJlbnQoKVxuICAgICAgICB2YXIgY29udGFpbmVyRGltID0gdGhpcy5nZXRQb3NpdGlvbigkY29udGFpbmVyKVxuXG4gICAgICAgIHBsYWNlbWVudCA9IHBsYWNlbWVudCA9PSAnYm90dG9tJyAmJiBwb3MuYm90dG9tICsgYWN0dWFsSGVpZ2h0ID4gY29udGFpbmVyRGltLmJvdHRvbSA/ICd0b3AnICAgIDpcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID09ICd0b3AnICAgICYmIHBvcy50b3AgICAgLSBhY3R1YWxIZWlnaHQgPCBjb250YWluZXJEaW0udG9wICAgID8gJ2JvdHRvbScgOlxuICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPT0gJ3JpZ2h0JyAgJiYgcG9zLnJpZ2h0ICArIGFjdHVhbFdpZHRoICA+IGNvbnRhaW5lckRpbS53aWR0aCAgPyAnbGVmdCcgICA6XG4gICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9PSAnbGVmdCcgICAmJiBwb3MubGVmdCAgIC0gYWN0dWFsV2lkdGggIDwgY29udGFpbmVyRGltLmxlZnQgICA/ICdyaWdodCcgIDpcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50XG5cbiAgICAgICAgJHRpcFxuICAgICAgICAgIC5yZW1vdmVDbGFzcyhvcmdQbGFjZW1lbnQpXG4gICAgICAgICAgLmFkZENsYXNzKHBsYWNlbWVudClcbiAgICAgIH1cblxuICAgICAgdmFyIGNhbGN1bGF0ZWRPZmZzZXQgPSB0aGlzLmdldENhbGN1bGF0ZWRPZmZzZXQocGxhY2VtZW50LCBwb3MsIGFjdHVhbFdpZHRoLCBhY3R1YWxIZWlnaHQpXG5cbiAgICAgIHRoaXMuYXBwbHlQbGFjZW1lbnQoY2FsY3VsYXRlZE9mZnNldCwgcGxhY2VtZW50KVxuXG4gICAgICB2YXIgY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcmV2SG92ZXJTdGF0ZSA9IHRoYXQuaG92ZXJTdGF0ZVxuICAgICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ3Nob3duLmJzLicgKyB0aGF0LnR5cGUpXG4gICAgICAgIHRoYXQuaG92ZXJTdGF0ZSA9IG51bGxcblxuICAgICAgICBpZiAocHJldkhvdmVyU3RhdGUgPT0gJ291dCcpIHRoYXQubGVhdmUodGhhdClcbiAgICAgIH1cblxuICAgICAgJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgdGhpcy4kdGlwLmhhc0NsYXNzKCdmYWRlJykgP1xuICAgICAgICAkdGlwXG4gICAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgY29tcGxldGUpXG4gICAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKFRvb2x0aXAuVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgICBjb21wbGV0ZSgpXG4gICAgfVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuYXBwbHlQbGFjZW1lbnQgPSBmdW5jdGlvbiAob2Zmc2V0LCBwbGFjZW1lbnQpIHtcbiAgICB2YXIgJHRpcCAgID0gdGhpcy50aXAoKVxuICAgIHZhciB3aWR0aCAgPSAkdGlwWzBdLm9mZnNldFdpZHRoXG4gICAgdmFyIGhlaWdodCA9ICR0aXBbMF0ub2Zmc2V0SGVpZ2h0XG5cbiAgICAvLyBtYW51YWxseSByZWFkIG1hcmdpbnMgYmVjYXVzZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaW5jbHVkZXMgZGlmZmVyZW5jZVxuICAgIHZhciBtYXJnaW5Ub3AgPSBwYXJzZUludCgkdGlwLmNzcygnbWFyZ2luLXRvcCcpLCAxMClcbiAgICB2YXIgbWFyZ2luTGVmdCA9IHBhcnNlSW50KCR0aXAuY3NzKCdtYXJnaW4tbGVmdCcpLCAxMClcblxuICAgIC8vIHdlIG11c3QgY2hlY2sgZm9yIE5hTiBmb3IgaWUgOC85XG4gICAgaWYgKGlzTmFOKG1hcmdpblRvcCkpICBtYXJnaW5Ub3AgID0gMFxuICAgIGlmIChpc05hTihtYXJnaW5MZWZ0KSkgbWFyZ2luTGVmdCA9IDBcblxuICAgIG9mZnNldC50b3AgID0gb2Zmc2V0LnRvcCAgKyBtYXJnaW5Ub3BcbiAgICBvZmZzZXQubGVmdCA9IG9mZnNldC5sZWZ0ICsgbWFyZ2luTGVmdFxuXG4gICAgLy8gJC5mbi5vZmZzZXQgZG9lc24ndCByb3VuZCBwaXhlbCB2YWx1ZXNcbiAgICAvLyBzbyB3ZSB1c2Ugc2V0T2Zmc2V0IGRpcmVjdGx5IHdpdGggb3VyIG93biBmdW5jdGlvbiBCLTBcbiAgICAkLm9mZnNldC5zZXRPZmZzZXQoJHRpcFswXSwgJC5leHRlbmQoe1xuICAgICAgdXNpbmc6IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICAkdGlwLmNzcyh7XG4gICAgICAgICAgdG9wOiBNYXRoLnJvdW5kKHByb3BzLnRvcCksXG4gICAgICAgICAgbGVmdDogTWF0aC5yb3VuZChwcm9wcy5sZWZ0KVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0sIG9mZnNldCksIDApXG5cbiAgICAkdGlwLmFkZENsYXNzKCdpbicpXG5cbiAgICAvLyBjaGVjayB0byBzZWUgaWYgcGxhY2luZyB0aXAgaW4gbmV3IG9mZnNldCBjYXVzZWQgdGhlIHRpcCB0byByZXNpemUgaXRzZWxmXG4gICAgdmFyIGFjdHVhbFdpZHRoICA9ICR0aXBbMF0ub2Zmc2V0V2lkdGhcbiAgICB2YXIgYWN0dWFsSGVpZ2h0ID0gJHRpcFswXS5vZmZzZXRIZWlnaHRcblxuICAgIGlmIChwbGFjZW1lbnQgPT0gJ3RvcCcgJiYgYWN0dWFsSGVpZ2h0ICE9IGhlaWdodCkge1xuICAgICAgb2Zmc2V0LnRvcCA9IG9mZnNldC50b3AgKyBoZWlnaHQgLSBhY3R1YWxIZWlnaHRcbiAgICB9XG5cbiAgICB2YXIgZGVsdGEgPSB0aGlzLmdldFZpZXdwb3J0QWRqdXN0ZWREZWx0YShwbGFjZW1lbnQsIG9mZnNldCwgYWN0dWFsV2lkdGgsIGFjdHVhbEhlaWdodClcblxuICAgIGlmIChkZWx0YS5sZWZ0KSBvZmZzZXQubGVmdCArPSBkZWx0YS5sZWZ0XG4gICAgZWxzZSBvZmZzZXQudG9wICs9IGRlbHRhLnRvcFxuXG4gICAgdmFyIGlzVmVydGljYWwgICAgICAgICAgPSAvdG9wfGJvdHRvbS8udGVzdChwbGFjZW1lbnQpXG4gICAgdmFyIGFycm93RGVsdGEgICAgICAgICAgPSBpc1ZlcnRpY2FsID8gZGVsdGEubGVmdCAqIDIgLSB3aWR0aCArIGFjdHVhbFdpZHRoIDogZGVsdGEudG9wICogMiAtIGhlaWdodCArIGFjdHVhbEhlaWdodFxuICAgIHZhciBhcnJvd09mZnNldFBvc2l0aW9uID0gaXNWZXJ0aWNhbCA/ICdvZmZzZXRXaWR0aCcgOiAnb2Zmc2V0SGVpZ2h0J1xuXG4gICAgJHRpcC5vZmZzZXQob2Zmc2V0KVxuICAgIHRoaXMucmVwbGFjZUFycm93KGFycm93RGVsdGEsICR0aXBbMF1bYXJyb3dPZmZzZXRQb3NpdGlvbl0sIGlzVmVydGljYWwpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5yZXBsYWNlQXJyb3cgPSBmdW5jdGlvbiAoZGVsdGEsIGRpbWVuc2lvbiwgaXNWZXJ0aWNhbCkge1xuICAgIHRoaXMuYXJyb3coKVxuICAgICAgLmNzcyhpc1ZlcnRpY2FsID8gJ2xlZnQnIDogJ3RvcCcsIDUwICogKDEgLSBkZWx0YSAvIGRpbWVuc2lvbikgKyAnJScpXG4gICAgICAuY3NzKGlzVmVydGljYWwgPyAndG9wJyA6ICdsZWZ0JywgJycpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciAkdGlwICA9IHRoaXMudGlwKClcbiAgICB2YXIgdGl0bGUgPSB0aGlzLmdldFRpdGxlKClcblxuICAgICR0aXAuZmluZCgnLnRvb2x0aXAtaW5uZXInKVt0aGlzLm9wdGlvbnMuaHRtbCA/ICdodG1sJyA6ICd0ZXh0J10odGl0bGUpXG4gICAgJHRpcC5yZW1vdmVDbGFzcygnZmFkZSBpbiB0b3AgYm90dG9tIGxlZnQgcmlnaHQnKVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIHZhciAkdGlwID0gJCh0aGlzLiR0aXApXG4gICAgdmFyIGUgICAgPSAkLkV2ZW50KCdoaWRlLmJzLicgKyB0aGlzLnR5cGUpXG5cbiAgICBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICAgIGlmICh0aGF0LmhvdmVyU3RhdGUgIT0gJ2luJykgJHRpcC5kZXRhY2goKVxuICAgICAgdGhhdC4kZWxlbWVudFxuICAgICAgICAucmVtb3ZlQXR0cignYXJpYS1kZXNjcmliZWRieScpXG4gICAgICAgIC50cmlnZ2VyKCdoaWRkZW4uYnMuJyArIHRoYXQudHlwZSlcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbiAgICB9XG5cbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoZSlcblxuICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgICR0aXAucmVtb3ZlQ2xhc3MoJ2luJylcblxuICAgICQuc3VwcG9ydC50cmFuc2l0aW9uICYmICR0aXAuaGFzQ2xhc3MoJ2ZhZGUnKSA/XG4gICAgICAkdGlwXG4gICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGNvbXBsZXRlKVxuICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoVG9vbHRpcC5UUkFOU0lUSU9OX0RVUkFUSU9OKSA6XG4gICAgICBjb21wbGV0ZSgpXG5cbiAgICB0aGlzLmhvdmVyU3RhdGUgPSBudWxsXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZml4VGl0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyICRlID0gdGhpcy4kZWxlbWVudFxuICAgIGlmICgkZS5hdHRyKCd0aXRsZScpIHx8IHR5cGVvZiAoJGUuYXR0cignZGF0YS1vcmlnaW5hbC10aXRsZScpKSAhPSAnc3RyaW5nJykge1xuICAgICAgJGUuYXR0cignZGF0YS1vcmlnaW5hbC10aXRsZScsICRlLmF0dHIoJ3RpdGxlJykgfHwgJycpLmF0dHIoJ3RpdGxlJywgJycpXG4gICAgfVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuaGFzQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUaXRsZSgpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICgkZWxlbWVudCkge1xuICAgICRlbGVtZW50ICAgPSAkZWxlbWVudCB8fCB0aGlzLiRlbGVtZW50XG5cbiAgICB2YXIgZWwgICAgID0gJGVsZW1lbnRbMF1cbiAgICB2YXIgaXNCb2R5ID0gZWwudGFnTmFtZSA9PSAnQk9EWSdcblxuICAgIHZhciBlbFJlY3QgICAgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIGlmIChlbFJlY3Qud2lkdGggPT0gbnVsbCkge1xuICAgICAgLy8gd2lkdGggYW5kIGhlaWdodCBhcmUgbWlzc2luZyBpbiBJRTgsIHNvIGNvbXB1dGUgdGhlbSBtYW51YWxseTsgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9pc3N1ZXMvMTQwOTNcbiAgICAgIGVsUmVjdCA9ICQuZXh0ZW5kKHt9LCBlbFJlY3QsIHsgd2lkdGg6IGVsUmVjdC5yaWdodCAtIGVsUmVjdC5sZWZ0LCBoZWlnaHQ6IGVsUmVjdC5ib3R0b20gLSBlbFJlY3QudG9wIH0pXG4gICAgfVxuICAgIHZhciBlbE9mZnNldCAgPSBpc0JvZHkgPyB7IHRvcDogMCwgbGVmdDogMCB9IDogJGVsZW1lbnQub2Zmc2V0KClcbiAgICB2YXIgc2Nyb2xsICAgID0geyBzY3JvbGw6IGlzQm9keSA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgOiAkZWxlbWVudC5zY3JvbGxUb3AoKSB9XG4gICAgdmFyIG91dGVyRGltcyA9IGlzQm9keSA/IHsgd2lkdGg6ICQod2luZG93KS53aWR0aCgpLCBoZWlnaHQ6ICQod2luZG93KS5oZWlnaHQoKSB9IDogbnVsbFxuXG4gICAgcmV0dXJuICQuZXh0ZW5kKHt9LCBlbFJlY3QsIHNjcm9sbCwgb3V0ZXJEaW1zLCBlbE9mZnNldClcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmdldENhbGN1bGF0ZWRPZmZzZXQgPSBmdW5jdGlvbiAocGxhY2VtZW50LCBwb3MsIGFjdHVhbFdpZHRoLCBhY3R1YWxIZWlnaHQpIHtcbiAgICByZXR1cm4gcGxhY2VtZW50ID09ICdib3R0b20nID8geyB0b3A6IHBvcy50b3AgKyBwb3MuaGVpZ2h0LCAgIGxlZnQ6IHBvcy5sZWZ0ICsgcG9zLndpZHRoIC8gMiAtIGFjdHVhbFdpZHRoIC8gMiB9IDpcbiAgICAgICAgICAgcGxhY2VtZW50ID09ICd0b3AnICAgID8geyB0b3A6IHBvcy50b3AgLSBhY3R1YWxIZWlnaHQsIGxlZnQ6IHBvcy5sZWZ0ICsgcG9zLndpZHRoIC8gMiAtIGFjdHVhbFdpZHRoIC8gMiB9IDpcbiAgICAgICAgICAgcGxhY2VtZW50ID09ICdsZWZ0JyAgID8geyB0b3A6IHBvcy50b3AgKyBwb3MuaGVpZ2h0IC8gMiAtIGFjdHVhbEhlaWdodCAvIDIsIGxlZnQ6IHBvcy5sZWZ0IC0gYWN0dWFsV2lkdGggfSA6XG4gICAgICAgIC8qIHBsYWNlbWVudCA9PSAncmlnaHQnICovIHsgdG9wOiBwb3MudG9wICsgcG9zLmhlaWdodCAvIDIgLSBhY3R1YWxIZWlnaHQgLyAyLCBsZWZ0OiBwb3MubGVmdCArIHBvcy53aWR0aCB9XG5cbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmdldFZpZXdwb3J0QWRqdXN0ZWREZWx0YSA9IGZ1bmN0aW9uIChwbGFjZW1lbnQsIHBvcywgYWN0dWFsV2lkdGgsIGFjdHVhbEhlaWdodCkge1xuICAgIHZhciBkZWx0YSA9IHsgdG9wOiAwLCBsZWZ0OiAwIH1cbiAgICBpZiAoIXRoaXMuJHZpZXdwb3J0KSByZXR1cm4gZGVsdGFcblxuICAgIHZhciB2aWV3cG9ydFBhZGRpbmcgPSB0aGlzLm9wdGlvbnMudmlld3BvcnQgJiYgdGhpcy5vcHRpb25zLnZpZXdwb3J0LnBhZGRpbmcgfHwgMFxuICAgIHZhciB2aWV3cG9ydERpbWVuc2lvbnMgPSB0aGlzLmdldFBvc2l0aW9uKHRoaXMuJHZpZXdwb3J0KVxuXG4gICAgaWYgKC9yaWdodHxsZWZ0Ly50ZXN0KHBsYWNlbWVudCkpIHtcbiAgICAgIHZhciB0b3BFZGdlT2Zmc2V0ICAgID0gcG9zLnRvcCAtIHZpZXdwb3J0UGFkZGluZyAtIHZpZXdwb3J0RGltZW5zaW9ucy5zY3JvbGxcbiAgICAgIHZhciBib3R0b21FZGdlT2Zmc2V0ID0gcG9zLnRvcCArIHZpZXdwb3J0UGFkZGluZyAtIHZpZXdwb3J0RGltZW5zaW9ucy5zY3JvbGwgKyBhY3R1YWxIZWlnaHRcbiAgICAgIGlmICh0b3BFZGdlT2Zmc2V0IDwgdmlld3BvcnREaW1lbnNpb25zLnRvcCkgeyAvLyB0b3Agb3ZlcmZsb3dcbiAgICAgICAgZGVsdGEudG9wID0gdmlld3BvcnREaW1lbnNpb25zLnRvcCAtIHRvcEVkZ2VPZmZzZXRcbiAgICAgIH0gZWxzZSBpZiAoYm90dG9tRWRnZU9mZnNldCA+IHZpZXdwb3J0RGltZW5zaW9ucy50b3AgKyB2aWV3cG9ydERpbWVuc2lvbnMuaGVpZ2h0KSB7IC8vIGJvdHRvbSBvdmVyZmxvd1xuICAgICAgICBkZWx0YS50b3AgPSB2aWV3cG9ydERpbWVuc2lvbnMudG9wICsgdmlld3BvcnREaW1lbnNpb25zLmhlaWdodCAtIGJvdHRvbUVkZ2VPZmZzZXRcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxlZnRFZGdlT2Zmc2V0ICA9IHBvcy5sZWZ0IC0gdmlld3BvcnRQYWRkaW5nXG4gICAgICB2YXIgcmlnaHRFZGdlT2Zmc2V0ID0gcG9zLmxlZnQgKyB2aWV3cG9ydFBhZGRpbmcgKyBhY3R1YWxXaWR0aFxuICAgICAgaWYgKGxlZnRFZGdlT2Zmc2V0IDwgdmlld3BvcnREaW1lbnNpb25zLmxlZnQpIHsgLy8gbGVmdCBvdmVyZmxvd1xuICAgICAgICBkZWx0YS5sZWZ0ID0gdmlld3BvcnREaW1lbnNpb25zLmxlZnQgLSBsZWZ0RWRnZU9mZnNldFxuICAgICAgfSBlbHNlIGlmIChyaWdodEVkZ2VPZmZzZXQgPiB2aWV3cG9ydERpbWVuc2lvbnMud2lkdGgpIHsgLy8gcmlnaHQgb3ZlcmZsb3dcbiAgICAgICAgZGVsdGEubGVmdCA9IHZpZXdwb3J0RGltZW5zaW9ucy5sZWZ0ICsgdmlld3BvcnREaW1lbnNpb25zLndpZHRoIC0gcmlnaHRFZGdlT2Zmc2V0XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlbHRhXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGl0bGVcbiAgICB2YXIgJGUgPSB0aGlzLiRlbGVtZW50XG4gICAgdmFyIG8gID0gdGhpcy5vcHRpb25zXG5cbiAgICB0aXRsZSA9ICRlLmF0dHIoJ2RhdGEtb3JpZ2luYWwtdGl0bGUnKVxuICAgICAgfHwgKHR5cGVvZiBvLnRpdGxlID09ICdmdW5jdGlvbicgPyBvLnRpdGxlLmNhbGwoJGVbMF0pIDogIG8udGl0bGUpXG5cbiAgICByZXR1cm4gdGl0bGVcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmdldFVJRCA9IGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICBkbyBwcmVmaXggKz0gfn4oTWF0aC5yYW5kb20oKSAqIDEwMDAwMDApXG4gICAgd2hpbGUgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHByZWZpeCkpXG4gICAgcmV0dXJuIHByZWZpeFxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUudGlwID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy4kdGlwID0gdGhpcy4kdGlwIHx8ICQodGhpcy5vcHRpb25zLnRlbXBsYXRlKSlcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmFycm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy4kYXJyb3cgPSB0aGlzLiRhcnJvdyB8fCB0aGlzLnRpcCgpLmZpbmQoJy50b29sdGlwLWFycm93JykpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUudG9nZ2xlRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSAhdGhpcy5lbmFibGVkXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIGlmIChlKSB7XG4gICAgICBzZWxmID0gJChlLmN1cnJlbnRUYXJnZXQpLmRhdGEoJ2JzLicgKyB0aGlzLnR5cGUpXG4gICAgICBpZiAoIXNlbGYpIHtcbiAgICAgICAgc2VsZiA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKGUuY3VycmVudFRhcmdldCwgdGhpcy5nZXREZWxlZ2F0ZU9wdGlvbnMoKSlcbiAgICAgICAgJChlLmN1cnJlbnRUYXJnZXQpLmRhdGEoJ2JzLicgKyB0aGlzLnR5cGUsIHNlbGYpXG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZi50aXAoKS5oYXNDbGFzcygnaW4nKSA/IHNlbGYubGVhdmUoc2VsZikgOiBzZWxmLmVudGVyKHNlbGYpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpXG4gICAgdGhpcy5oaWRlKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoYXQuJGVsZW1lbnQub2ZmKCcuJyArIHRoYXQudHlwZSkucmVtb3ZlRGF0YSgnYnMuJyArIHRoYXQudHlwZSlcbiAgICB9KVxuICB9XG5cblxuICAvLyBUT09MVElQIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICAgID0gJHRoaXMuZGF0YSgnYnMudG9vbHRpcCcpXG4gICAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uXG5cbiAgICAgIGlmICghZGF0YSAmJiAvZGVzdHJveXxoaWRlLy50ZXN0KG9wdGlvbikpIHJldHVyblxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy50b29sdGlwJywgKGRhdGEgPSBuZXcgVG9vbHRpcCh0aGlzLCBvcHRpb25zKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dKClcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4udG9vbHRpcFxuXG4gICQuZm4udG9vbHRpcCAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLnRvb2x0aXAuQ29uc3RydWN0b3IgPSBUb29sdGlwXG5cblxuICAvLyBUT09MVElQIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09PT1cblxuICAkLmZuLnRvb2x0aXAubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLnRvb2x0aXAgPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbn0oalF1ZXJ5KTtcbiIsIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiB0cmFuc2l0aW9uLmpzIHYzLjMuNFxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jdHJhbnNpdGlvbnNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNSBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBDU1MgVFJBTlNJVElPTiBTVVBQT1JUIChTaG91dG91dDogaHR0cDovL3d3dy5tb2Rlcm5penIuY29tLylcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gdHJhbnNpdGlvbkVuZCgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdib290c3RyYXAnKVxuXG4gICAgdmFyIHRyYW5zRW5kRXZlbnROYW1lcyA9IHtcbiAgICAgIFdlYmtpdFRyYW5zaXRpb24gOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICAgICBNb3pUcmFuc2l0aW9uICAgIDogJ3RyYW5zaXRpb25lbmQnLFxuICAgICAgT1RyYW5zaXRpb24gICAgICA6ICdvVHJhbnNpdGlvbkVuZCBvdHJhbnNpdGlvbmVuZCcsXG4gICAgICB0cmFuc2l0aW9uICAgICAgIDogJ3RyYW5zaXRpb25lbmQnXG4gICAgfVxuXG4gICAgZm9yICh2YXIgbmFtZSBpbiB0cmFuc0VuZEV2ZW50TmFtZXMpIHtcbiAgICAgIGlmIChlbC5zdHlsZVtuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7IGVuZDogdHJhbnNFbmRFdmVudE5hbWVzW25hbWVdIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2UgLy8gZXhwbGljaXQgZm9yIGllOCAoICAuXy4pXG4gIH1cblxuICAvLyBodHRwOi8vYmxvZy5hbGV4bWFjY2F3LmNvbS9jc3MtdHJhbnNpdGlvbnNcbiAgJC5mbi5lbXVsYXRlVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uIChkdXJhdGlvbikge1xuICAgIHZhciBjYWxsZWQgPSBmYWxzZVxuICAgIHZhciAkZWwgPSB0aGlzXG4gICAgJCh0aGlzKS5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGZ1bmN0aW9uICgpIHsgY2FsbGVkID0gdHJ1ZSB9KVxuICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHsgaWYgKCFjYWxsZWQpICQoJGVsKS50cmlnZ2VyKCQuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCkgfVxuICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIGR1cmF0aW9uKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAkKGZ1bmN0aW9uICgpIHtcbiAgICAkLnN1cHBvcnQudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25FbmQoKVxuXG4gICAgaWYgKCEkLnN1cHBvcnQudHJhbnNpdGlvbikgcmV0dXJuXG5cbiAgICAkLmV2ZW50LnNwZWNpYWwuYnNUcmFuc2l0aW9uRW5kID0ge1xuICAgICAgYmluZFR5cGU6ICQuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCxcbiAgICAgIGRlbGVnYXRlVHlwZTogJC5zdXBwb3J0LnRyYW5zaXRpb24uZW5kLFxuICAgICAgaGFuZGxlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoJChlLnRhcmdldCkuaXModGhpcykpIHJldHVybiBlLmhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbn0oalF1ZXJ5KTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudFF1ZXVlO1xuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB2YXIgaSA9IC0xO1xuICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICBjdXJyZW50UXVldWVbaV0oKTtcbiAgICAgICAgfVxuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG59XG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHF1ZXVlLnB1c2goZnVuKTtcbiAgICBpZiAoIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvLyBpMThuZXh0LCB2MS44LjFcbi8vIENvcHlyaWdodCAoYykyMDE1IEphbiBNw7xobGVtYW5uIChqYW11aGwpLlxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgTUlUIGxpY2Vuc2Vcbi8vIGh0dHA6Ly9pMThuZXh0LmNvbVxuKGZ1bmN0aW9uKHJvb3QpIHtcblxuICAgIC8vIGFkZCBpbmRleE9mIHRvIG5vbiBFQ01BLTI2MiBzdGFuZGFyZCBjb21wbGlhbnQgYnJvd3NlcnNcbiAgICBpZiAoIUFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gKHNlYXJjaEVsZW1lbnQgLyosIGZyb21JbmRleCAqLyApIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgaWYgKHRoaXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xuICAgICAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG4gPSBOdW1iZXIoYXJndW1lbnRzWzFdKTtcbiAgICAgICAgICAgICAgICBpZiAobiAhPSBuKSB7IC8vIHNob3J0Y3V0IGZvciB2ZXJpZnlpbmcgaWYgaXQncyBOYU5cbiAgICAgICAgICAgICAgICAgICAgbiA9IDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuICE9IDAgJiYgbiAhPSBJbmZpbml0eSAmJiBuICE9IC1JbmZpbml0eSkge1xuICAgICAgICAgICAgICAgICAgICBuID0gKG4gPiAwIHx8IC0xKSAqIE1hdGguZmxvb3IoTWF0aC5hYnMobikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuID49IGxlbikge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBrID0gbiA+PSAwID8gbiA6IE1hdGgubWF4KGxlbiAtIE1hdGguYWJzKG4pLCAwKTtcbiAgICAgICAgICAgIGZvciAoOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoayBpbiB0ICYmIHRba10gPT09IHNlYXJjaEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRkIGxhc3RJbmRleE9mIHRvIG5vbiBFQ01BLTI2MiBzdGFuZGFyZCBjb21wbGlhbnQgYnJvd3NlcnNcbiAgICBpZiAoIUFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZikge1xuICAgICAgICBBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbihzZWFyY2hFbGVtZW50IC8qLCBmcm9tSW5kZXgqLykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBpZiAodGhpcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHQgPSBPYmplY3QodGhpcyk7XG4gICAgICAgICAgICB2YXIgbGVuID0gdC5sZW5ndGggPj4+IDA7XG4gICAgICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG4gPSBsZW47XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBuID0gTnVtYmVyKGFyZ3VtZW50c1sxXSk7XG4gICAgICAgICAgICAgICAgaWYgKG4gIT0gbikge1xuICAgICAgICAgICAgICAgICAgICBuID0gMDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG4gIT0gMCAmJiBuICE9ICgxIC8gMCkgJiYgbiAhPSAtKDEgLyAwKSkge1xuICAgICAgICAgICAgICAgICAgICBuID0gKG4gPiAwIHx8IC0xKSAqIE1hdGguZmxvb3IoTWF0aC5hYnMobikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBrID0gbiA+PSAwID8gTWF0aC5taW4obiwgbGVuIC0gMSkgOiBsZW4gLSBNYXRoLmFicyhuKTtcbiAgICAgICAgICAgIGZvciAoOyBrID49IDA7IGstLSkge1xuICAgICAgICAgICAgICAgIGlmIChrIGluIHQgJiYgdFtrXSA9PT0gc2VhcmNoRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQWRkIHN0cmluZyB0cmltIGZvciBJRTguXG4gICAgaWYgKHR5cGVvZiBTdHJpbmcucHJvdG90eXBlLnRyaW0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgU3RyaW5nLnByb3RvdHlwZS50cmltID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgJCA9IHJvb3QualF1ZXJ5IHx8IHJvb3QuWmVwdG9cbiAgICAgICwgaTE4biA9IHt9XG4gICAgICAsIHJlc1N0b3JlID0ge31cbiAgICAgICwgY3VycmVudExuZ1xuICAgICAgLCByZXBsYWNlbWVudENvdW50ZXIgPSAwXG4gICAgICAsIGxhbmd1YWdlcyA9IFtdXG4gICAgICAsIGluaXRpYWxpemVkID0gZmFsc2VcbiAgICAgICwgc3luYyA9IHt9O1xuXG5cblxuICAgIC8vIEV4cG9ydCB0aGUgaTE4bmV4dCBvYmplY3QgZm9yICoqQ29tbW9uSlMqKi5cbiAgICAvLyBJZiB3ZSdyZSBub3QgaW4gQ29tbW9uSlMsIGFkZCBgaTE4bmAgdG8gdGhlXG4gICAgLy8gZ2xvYmFsIG9iamVjdCBvciB0byBqcXVlcnkuXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gaTE4bjtcbiAgICAgICAgaWYgKCEkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICQgPSByZXF1aXJlKCdqcXVlcnknKTtcbiAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgIC8vIGp1c3QgaWdub3JlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuaTE4biA9IHJvb3QuaTE4biB8fCBpMThuO1xuICAgIH1cblxuICAgIGlmICgkKSB7XG4gICAgICAgICQuaTE4biA9ICQuaTE4biB8fCBpMThuO1xuICAgIH1cbiAgICBzeW5jID0ge1xuXG4gICAgICAgIGxvYWQ6IGZ1bmN0aW9uKGxuZ3MsIG9wdGlvbnMsIGNiKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy51c2VMb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICBzeW5jLl9sb2FkTG9jYWwobG5ncywgb3B0aW9ucywgZnVuY3Rpb24oZXJyLCBzdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWlzc2luZ0xuZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3RvcmVbbG5nc1tpXV0pIG1pc3NpbmdMbmdzLnB1c2gobG5nc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAobWlzc2luZ0xuZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3luYy5fZmV0Y2gobWlzc2luZ0xuZ3MsIG9wdGlvbnMsIGZ1bmN0aW9uKGVyciwgZmV0Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYuZXh0ZW5kKHN0b3JlLCBmZXRjaGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW5jLl9zdG9yZUxvY2FsKGZldGNoZWQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IobnVsbCwgc3RvcmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYihudWxsLCBzdG9yZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3luYy5fZmV0Y2gobG5ncywgb3B0aW9ucywgZnVuY3Rpb24oZXJyLCBzdG9yZSl7XG4gICAgICAgICAgICAgICAgICAgIGNiKG51bGwsIHN0b3JlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfbG9hZExvY2FsOiBmdW5jdGlvbihsbmdzLCBvcHRpb25zLCBjYikge1xuICAgICAgICAgICAgdmFyIHN0b3JlID0ge31cbiAgICAgICAgICAgICAgLCBub3dNUyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgICAgICAgICBpZih3aW5kb3cubG9jYWxTdG9yYWdlKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgdG9kbyA9IGxuZ3MubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgZi5lYWNoKGxuZ3MsIGZ1bmN0aW9uKGtleSwgbG5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsb2NhbCA9IGYubG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3Jlc18nICsgbG5nKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsID0gSlNPTi5wYXJzZShsb2NhbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbC5pMThuU3RhbXAgJiYgbG9jYWwuaTE4blN0YW1wICsgb3B0aW9ucy5sb2NhbFN0b3JhZ2VFeHBpcmF0aW9uVGltZSA+IG5vd01TKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVbbG5nXSA9IGxvY2FsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdG9kby0tOyAvLyB3YWl0IGZvciBhbGwgZG9uZSBiZWZvciBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9kbyA9PT0gMCkgY2IobnVsbCwgc3RvcmUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9zdG9yZUxvY2FsOiBmdW5jdGlvbihzdG9yZSkge1xuICAgICAgICAgICAgaWYod2luZG93LmxvY2FsU3RvcmFnZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG0gaW4gc3RvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmVbbV0uaTE4blN0YW1wID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgICAgIGYubG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3Jlc18nICsgbSwgSlNPTi5zdHJpbmdpZnkoc3RvcmVbbV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2ZldGNoOiBmdW5jdGlvbihsbmdzLCBvcHRpb25zLCBjYikge1xuICAgICAgICAgICAgdmFyIG5zID0gb3B0aW9ucy5uc1xuICAgICAgICAgICAgICAsIHN0b3JlID0ge307XG5cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5keW5hbWljTG9hZCkge1xuICAgICAgICAgICAgICAgIHZhciB0b2RvID0gbnMubmFtZXNwYWNlcy5sZW5ndGggKiBsbmdzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgLCBlcnJvcnM7XG5cbiAgICAgICAgICAgICAgICAvLyBsb2FkIGVhY2ggZmlsZSBpbmRpdmlkdWFsXG4gICAgICAgICAgICAgICAgZi5lYWNoKG5zLm5hbWVzcGFjZXMsIGZ1bmN0aW9uKG5zSW5kZXgsIG5zVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZi5lYWNoKGxuZ3MsIGZ1bmN0aW9uKGxuZ0luZGV4LCBsbmdWYWx1ZSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIHRoaXMgb25jZSBvdXIgdHJhbnNsYXRpb24gaGFzIHJldHVybmVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZVtsbmdWYWx1ZV0gPSBzdG9yZVtsbmdWYWx1ZV0gfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVbbG5nVmFsdWVdW25zVmFsdWVdID0gZGF0YTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvZG8tLTsgLy8gd2FpdCBmb3IgYWxsIGRvbmUgYmVmb3IgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9kbyA9PT0gMCkgY2IoZXJyb3JzLCBzdG9yZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2Ygb3B0aW9ucy5jdXN0b21Mb2FkID09ICdmdW5jdGlvbicpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgc3BlY2lmaWVkIGN1c3RvbSBjYWxsYmFjay5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmN1c3RvbUxvYWQobG5nVmFsdWUsIG5zVmFsdWUsIG9wdGlvbnMsIGxvYWRDb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfiAvLyBVc2Ugb3VyIGluYnVpbHQgc3luYy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW5jLl9mZXRjaE9uZShsbmdWYWx1ZSwgbnNWYWx1ZSwgb3B0aW9ucywgbG9hZENvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIENhbGwgdGhpcyBvbmNlIG91ciB0cmFuc2xhdGlvbiBoYXMgcmV0dXJuZWQuXG4gICAgICAgICAgICAgICAgdmFyIGxvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBjYihudWxsLCBkYXRhKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYodHlwZW9mIG9wdGlvbnMuY3VzdG9tTG9hZCA9PSAnZnVuY3Rpb24nKXtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBzcGVjaWZpZWQgY3VzdG9tIGNhbGxiYWNrLlxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmN1c3RvbUxvYWQobG5ncywgbnMubmFtZXNwYWNlcywgb3B0aW9ucywgbG9hZENvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdXJsID0gYXBwbHlSZXBsYWNlbWVudChvcHRpb25zLnJlc0dldFBhdGgsIHsgbG5nOiBsbmdzLmpvaW4oJysnKSwgbnM6IG5zLm5hbWVzcGFjZXMuam9pbignKycpIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBsb2FkIGFsbCBuZWVkZWQgc3R1ZmYgb25jZVxuICAgICAgICAgICAgICAgICAgICBmLmFqYXgoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihkYXRhLCBzdGF0dXMsIHhocikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYubG9nKCdsb2FkZWQ6ICcgKyB1cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRDb21wbGV0ZShudWxsLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA6IGZ1bmN0aW9uKHhociwgc3RhdHVzLCBlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYubG9nKCdmYWlsZWQgbG9hZGluZzogJyArIHVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZENvbXBsZXRlKCdmYWlsZWQgbG9hZGluZyByZXNvdXJjZS5qc29uIGVycm9yOiAnICsgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlOiBcImpzb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jIDogb3B0aW9ucy5nZXRBc3luY1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2ZldGNoT25lOiBmdW5jdGlvbihsbmcsIG5zLCBvcHRpb25zLCBkb25lKSB7XG4gICAgICAgICAgICB2YXIgdXJsID0gYXBwbHlSZXBsYWNlbWVudChvcHRpb25zLnJlc0dldFBhdGgsIHsgbG5nOiBsbmcsIG5zOiBucyB9KTtcbiAgICAgICAgICAgIGYuYWpheCh7XG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oZGF0YSwgc3RhdHVzLCB4aHIpIHtcbiAgICAgICAgICAgICAgICAgICAgZi5sb2coJ2xvYWRlZDogJyArIHVybCk7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUobnVsbCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvciA6IGZ1bmN0aW9uKHhociwgc3RhdHVzLCBlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHN0YXR1cyAmJiBzdGF0dXMgPT0gMjAwKSB8fCAoeGhyICYmIHhoci5zdGF0dXMgJiYgeGhyLnN0YXR1cyA9PSAyMDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmaWxlIGxvYWRlZCBidXQgaW52YWxpZCBqc29uLCBzdG9wIHdhc3RlIHRpbWUgIVxuICAgICAgICAgICAgICAgICAgICAgICAgZi5lcnJvcignVGhlcmUgaXMgYSB0eXBvIGluOiAnICsgdXJsKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgoc3RhdHVzICYmIHN0YXR1cyA9PSA0MDQpIHx8ICh4aHIgJiYgeGhyLnN0YXR1cyAmJiB4aHIuc3RhdHVzID09IDQwNCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGYubG9nKCdEb2VzIG5vdCBleGlzdDogJyArIHVybCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhlU3RhdHVzID0gc3RhdHVzID8gc3RhdHVzIDogKCh4aHIgJiYgeGhyLnN0YXR1cykgPyB4aHIuc3RhdHVzIDogbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmLmxvZyh0aGVTdGF0dXMgKyAnIHdoZW4gbG9hZGluZyAnICsgdXJsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyb3IsIHt9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiBcImpzb25cIixcbiAgICAgICAgICAgICAgICBhc3luYyA6IG9wdGlvbnMuZ2V0QXN5bmNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBvc3RNaXNzaW5nOiBmdW5jdGlvbihsbmcsIG5zLCBrZXksIGRlZmF1bHRWYWx1ZSwgbG5ncykge1xuICAgICAgICAgICAgdmFyIHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIHBheWxvYWRba2V5XSA9IGRlZmF1bHRWYWx1ZTtcblxuICAgICAgICAgICAgdmFyIHVybHMgPSBbXTtcblxuICAgICAgICAgICAgaWYgKG8uc2VuZE1pc3NpbmdUbyA9PT0gJ2ZhbGxiYWNrJyAmJiBvLmZhbGxiYWNrTG5nWzBdICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgby5mYWxsYmFja0xuZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB1cmxzLnB1c2goe2xuZzogby5mYWxsYmFja0xuZ1tpXSwgdXJsOiBhcHBseVJlcGxhY2VtZW50KG8ucmVzUG9zdFBhdGgsIHsgbG5nOiBvLmZhbGxiYWNrTG5nW2ldLCBuczogbnMgfSl9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG8uc2VuZE1pc3NpbmdUbyA9PT0gJ2N1cnJlbnQnIHx8IChvLnNlbmRNaXNzaW5nVG8gPT09ICdmYWxsYmFjaycgJiYgby5mYWxsYmFja0xuZ1swXSA9PT0gZmFsc2UpICkge1xuICAgICAgICAgICAgICAgIHVybHMucHVzaCh7bG5nOiBsbmcsIHVybDogYXBwbHlSZXBsYWNlbWVudChvLnJlc1Bvc3RQYXRoLCB7IGxuZzogbG5nLCBuczogbnMgfSl9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoby5zZW5kTWlzc2luZ1RvID09PSAnYWxsJykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbG5ncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdXJscy5wdXNoKHtsbmc6IGxuZ3NbaV0sIHVybDogYXBwbHlSZXBsYWNlbWVudChvLnJlc1Bvc3RQYXRoLCB7IGxuZzogbG5nc1tpXSwgbnM6IG5zIH0pfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gMCwgbGVuID0gdXJscy5sZW5ndGg7IHkgPCBsZW47IHkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gdXJsc1t5XTtcbiAgICAgICAgICAgICAgICBmLmFqYXgoe1xuICAgICAgICAgICAgICAgICAgICB1cmw6IGl0ZW0udXJsLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBvLnNlbmRUeXBlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBwYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihkYXRhLCBzdGF0dXMsIHhocikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZi5sb2coJ3Bvc3RlZCBtaXNzaW5nIGtleSBcXCcnICsga2V5ICsgJ1xcJyB0bzogJyArIGl0ZW0udXJsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGtleSB0byByZXNTdG9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHJlc1N0b3JlW2l0ZW0ubG5nXVtuc107XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoa2V5c1t4XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4ID09PSBrZXlzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVtrZXlzW3hdXSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlW2tleXNbeF1dID0gdmFsdWVba2V5c1t4XV0gfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgOiBmdW5jdGlvbih4aHIsIHN0YXR1cywgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGYubG9nKCdmYWlsZWQgcG9zdGluZyBtaXNzaW5nIGtleSBcXCcnICsga2V5ICsgJ1xcJyB0bzogJyArIGl0ZW0udXJsKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGU6IFwianNvblwiLFxuICAgICAgICAgICAgICAgICAgICBhc3luYyA6IG8ucG9zdEFzeW5jXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVsb2FkOiByZWxvYWRcbiAgICB9O1xuICAgIC8vIGRlZmF1bHRzXG4gICAgdmFyIG8gPSB7XG4gICAgICAgIGxuZzogdW5kZWZpbmVkLFxuICAgICAgICBsb2FkOiAnYWxsJyxcbiAgICAgICAgcHJlbG9hZDogW10sXG4gICAgICAgIGxvd2VyQ2FzZUxuZzogZmFsc2UsXG4gICAgICAgIHJldHVybk9iamVjdFRyZWVzOiBmYWxzZSxcbiAgICAgICAgZmFsbGJhY2tMbmc6IFsnZGV2J10sXG4gICAgICAgIGZhbGxiYWNrTlM6IFtdLFxuICAgICAgICBkZXRlY3RMbmdRUzogJ3NldExuZycsXG4gICAgICAgIGRldGVjdExuZ0Zyb21Mb2NhbFN0b3JhZ2U6IGZhbHNlLFxuICAgICAgICBuczogJ3RyYW5zbGF0aW9uJyxcbiAgICAgICAgZmFsbGJhY2tPbk51bGw6IHRydWUsXG4gICAgICAgIGZhbGxiYWNrT25FbXB0eTogZmFsc2UsXG4gICAgICAgIGZhbGxiYWNrVG9EZWZhdWx0TlM6IGZhbHNlLFxuICAgICAgICBuc3NlcGFyYXRvcjogJzonLFxuICAgICAgICBrZXlzZXBhcmF0b3I6ICcuJyxcbiAgICAgICAgc2VsZWN0b3JBdHRyOiAnZGF0YS1pMThuJyxcbiAgICAgICAgZGVidWc6IGZhbHNlLFxuXG4gICAgICAgIHJlc0dldFBhdGg6ICdsb2NhbGVzL19fbG5nX18vX19uc19fLmpzb24nLFxuICAgICAgICByZXNQb3N0UGF0aDogJ2xvY2FsZXMvYWRkL19fbG5nX18vX19uc19fJyxcblxuICAgICAgICBnZXRBc3luYzogdHJ1ZSxcbiAgICAgICAgcG9zdEFzeW5jOiB0cnVlLFxuXG4gICAgICAgIHJlc1N0b3JlOiB1bmRlZmluZWQsXG4gICAgICAgIHVzZUxvY2FsU3RvcmFnZTogZmFsc2UsXG4gICAgICAgIGxvY2FsU3RvcmFnZUV4cGlyYXRpb25UaW1lOiA3KjI0KjYwKjYwKjEwMDAsXG5cbiAgICAgICAgZHluYW1pY0xvYWQ6IGZhbHNlLFxuICAgICAgICBzZW5kTWlzc2luZzogZmFsc2UsXG4gICAgICAgIHNlbmRNaXNzaW5nVG86ICdmYWxsYmFjaycsIC8vIGN1cnJlbnQgfCBhbGxcbiAgICAgICAgc2VuZFR5cGU6ICdQT1NUJyxcblxuICAgICAgICBpbnRlcnBvbGF0aW9uUHJlZml4OiAnX18nLFxuICAgICAgICBpbnRlcnBvbGF0aW9uU3VmZml4OiAnX18nLFxuICAgICAgICBkZWZhdWx0VmFyaWFibGVzOiBmYWxzZSxcbiAgICAgICAgcmV1c2VQcmVmaXg6ICckdCgnLFxuICAgICAgICByZXVzZVN1ZmZpeDogJyknLFxuICAgICAgICBwbHVyYWxTdWZmaXg6ICdfcGx1cmFsJyxcbiAgICAgICAgcGx1cmFsTm90Rm91bmQ6IFsncGx1cmFsX25vdF9mb3VuZCcsIE1hdGgucmFuZG9tKCldLmpvaW4oJycpLFxuICAgICAgICBjb250ZXh0Tm90Rm91bmQ6IFsnY29udGV4dF9ub3RfZm91bmQnLCBNYXRoLnJhbmRvbSgpXS5qb2luKCcnKSxcbiAgICAgICAgZXNjYXBlSW50ZXJwb2xhdGlvbjogZmFsc2UsXG4gICAgICAgIGluZGVmaW5pdGVTdWZmaXg6ICdfaW5kZWZpbml0ZScsXG4gICAgICAgIGluZGVmaW5pdGVOb3RGb3VuZDogWydpbmRlZmluaXRlX25vdF9mb3VuZCcsIE1hdGgucmFuZG9tKCldLmpvaW4oJycpLFxuXG4gICAgICAgIHNldEpxdWVyeUV4dDogdHJ1ZSxcbiAgICAgICAgZGVmYXVsdFZhbHVlRnJvbUNvbnRlbnQ6IHRydWUsXG4gICAgICAgIHVzZURhdGFBdHRyT3B0aW9uczogZmFsc2UsXG4gICAgICAgIGNvb2tpZUV4cGlyYXRpb25UaW1lOiB1bmRlZmluZWQsXG4gICAgICAgIHVzZUNvb2tpZTogdHJ1ZSxcbiAgICAgICAgY29va2llTmFtZTogJ2kxOG5leHQnLFxuICAgICAgICBjb29raWVEb21haW46IHVuZGVmaW5lZCxcblxuICAgICAgICBvYmplY3RUcmVlS2V5SGFuZGxlcjogdW5kZWZpbmVkLFxuICAgICAgICBwb3N0UHJvY2VzczogdW5kZWZpbmVkLFxuICAgICAgICBwYXJzZU1pc3NpbmdLZXk6IHVuZGVmaW5lZCxcbiAgICAgICAgbWlzc2luZ0tleUhhbmRsZXI6IHN5bmMucG9zdE1pc3NpbmcsXG5cbiAgICAgICAgc2hvcnRjdXRGdW5jdGlvbjogJ3NwcmludGYnIC8vIG9yOiBkZWZhdWx0VmFsdWVcbiAgICB9O1xuICAgIGZ1bmN0aW9uIF9leHRlbmQodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgaWYgKCFzb3VyY2UgfHwgdHlwZW9mIHNvdXJjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGF0dHIgaW4gc291cmNlKSB7IHRhcmdldFthdHRyXSA9IHNvdXJjZVthdHRyXTsgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9kZWVwRXh0ZW5kKHRhcmdldCwgc291cmNlKSB7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKVxuICAgICAgICAgICAgaWYgKHByb3AgaW4gdGFyZ2V0KVxuICAgICAgICAgICAgICAgIF9kZWVwRXh0ZW5kKHRhcmdldFtwcm9wXSwgc291cmNlW3Byb3BdKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2VhY2gob2JqZWN0LCBjYWxsYmFjaywgYXJncykge1xuICAgICAgICB2YXIgbmFtZSwgaSA9IDAsXG4gICAgICAgICAgICBsZW5ndGggPSBvYmplY3QubGVuZ3RoLFxuICAgICAgICAgICAgaXNPYmogPSBsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KG9iamVjdCkgIT09ICdbb2JqZWN0IEFycmF5XScgfHwgdHlwZW9mIG9iamVjdCA9PT0gXCJmdW5jdGlvblwiO1xuXG4gICAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgICAgICBpZiAoaXNPYmopIHtcbiAgICAgICAgICAgICAgICBmb3IgKG5hbWUgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjay5hcHBseShvYmplY3RbbmFtZV0sIGFyZ3MpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IGxlbmd0aDsgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjay5hcHBseShvYmplY3RbaSsrXSwgYXJncykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAvLyBBIHNwZWNpYWwsIGZhc3QsIGNhc2UgZm9yIHRoZSBtb3N0IGNvbW1vbiB1c2Ugb2YgZWFjaFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzT2JqKSB7XG4gICAgICAgICAgICAgICAgZm9yIChuYW1lIGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2suY2FsbChvYmplY3RbbmFtZV0sIG5hbWUsIG9iamVjdFtuYW1lXSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuZ3RoOyApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmNhbGwob2JqZWN0W2ldLCBpLCBvYmplY3RbaSsrXSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgdmFyIF9lbnRpdHlNYXAgPSB7XG4gICAgICAgIFwiJlwiOiBcIiZhbXA7XCIsXG4gICAgICAgIFwiPFwiOiBcIiZsdDtcIixcbiAgICAgICAgXCI+XCI6IFwiJmd0O1wiLFxuICAgICAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICAgICAgXCInXCI6ICcmIzM5OycsXG4gICAgICAgIFwiL1wiOiAnJiN4MkY7J1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfZXNjYXBlKGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEucmVwbGFjZSgvWyY8PlwiJ1xcL10vZywgZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2VudGl0eU1hcFtzXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2FqYXgob3B0aW9ucykge1xuXG4gICAgICAgIC8vIHYwLjUuMCBvZiBodHRwczovL2dpdGh1Yi5jb20vZ29sb3JvZGVuL2h0dHAuanNcbiAgICAgICAgdmFyIGdldFhociA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBuYXRpdmUgWEhSIG9iamVjdCBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBpdC5cbiAgICAgICAgICAgIGlmICh3aW5kb3cuWE1MSHR0cFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbmV3IFhNTEh0dHBSZXF1ZXN0KCkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh3aW5kb3cuQWN0aXZlWE9iamVjdCkge1xuICAgICAgICAgICAgICAgIC8vIEluIEludGVybmV0IEV4cGxvcmVyIGNoZWNrIGZvciBBY3RpdmVYIHZlcnNpb25zIG9mIHRoZSBYSFIgb2JqZWN0LlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBuZXcgQWN0aXZlWE9iamVjdChcIk1zeG1sMi5YTUxIVFRQXCIpKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBuZXcgQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxIVFRQXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIG5vIFhIUiBzdXBwb3J0IHdhcyBmb3VuZCwgdGhyb3cgYW4gZXJyb3IuXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBlbmNvZGVVc2luZ1VybEVuY29kaW5nID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIGlmKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IodmFyIGRhdGFJdGVtIGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZihkYXRhLmhhc093blByb3BlcnR5KGRhdGFJdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGVVUklDb21wb25lbnQoZGF0YUl0ZW0pICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGRhdGFbZGF0YUl0ZW1dKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJyYnKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdXRmOCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgICAgICAgICAgaWYoYyA8IDEyOCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKChjID4gMTI3KSAmJiAoYyA8IDIwNDgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyA+PiA2KSB8IDE5Mik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyAmIDYzKSB8IDEyOCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjID4+IDEyKSB8IDIyNCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMgPj4gNikgJiA2MykgfCAxMjgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgJiA2MykgfCAxMjgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYmFzZTY0ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICAgIHZhciBrZXlTdHIgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xuXG4gICAgICAgICAgICB0ZXh0ID0gdXRmOCh0ZXh0KTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSAnJyxcbiAgICAgICAgICAgICAgICAgICAgY2hyMSwgY2hyMiwgY2hyMyxcbiAgICAgICAgICAgICAgICAgICAgZW5jMSwgZW5jMiwgZW5jMywgZW5jNCxcbiAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBjaHIxID0gdGV4dC5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgICAgICAgICAgY2hyMiA9IHRleHQuY2hhckNvZGVBdChpKyspO1xuICAgICAgICAgICAgICAgIGNocjMgPSB0ZXh0LmNoYXJDb2RlQXQoaSsrKTtcblxuICAgICAgICAgICAgICAgIGVuYzEgPSBjaHIxID4+IDI7XG4gICAgICAgICAgICAgICAgZW5jMiA9ICgoY2hyMSAmIDMpIDw8IDQpIHwgKGNocjIgPj4gNCk7XG4gICAgICAgICAgICAgICAgZW5jMyA9ICgoY2hyMiAmIDE1KSA8PCAyKSB8IChjaHIzID4+IDYpO1xuICAgICAgICAgICAgICAgIGVuYzQgPSBjaHIzICYgNjM7XG5cbiAgICAgICAgICAgICAgICBpZihpc05hTihjaHIyKSkge1xuICAgICAgICAgICAgICAgICAgICBlbmMzID0gZW5jNCA9IDY0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihpc05hTihjaHIzKSkge1xuICAgICAgICAgICAgICAgICAgICBlbmM0ID0gNjQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9XG4gICAgICAgICAgICAgICAgICAgIGtleVN0ci5jaGFyQXQoZW5jMSkgK1xuICAgICAgICAgICAgICAgICAgICBrZXlTdHIuY2hhckF0KGVuYzIpICtcbiAgICAgICAgICAgICAgICAgICAga2V5U3RyLmNoYXJBdChlbmMzKSArXG4gICAgICAgICAgICAgICAgICAgIGtleVN0ci5jaGFyQXQoZW5jNCk7XG4gICAgICAgICAgICAgICAgY2hyMSA9IGNocjIgPSBjaHIzID0gJyc7XG4gICAgICAgICAgICAgICAgZW5jMSA9IGVuYzIgPSBlbmMzID0gZW5jNCA9ICcnO1xuICAgICAgICAgICAgfSB3aGlsZShpIDwgdGV4dC5sZW5ndGgpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBtZXJnZUhlYWRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIGZpcnN0IGhlYWRlciBvYmplY3QgYXMgYmFzZS5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBhcmd1bWVudHNbMF07XG5cbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgcmVtYWluaW5nIGhlYWRlciBvYmplY3RzIGFuZCBhZGQgdGhlbS5cbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudEhlYWRlcnMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgZm9yKHZhciBoZWFkZXIgaW4gY3VycmVudEhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoY3VycmVudEhlYWRlcnMuaGFzT3duUHJvcGVydHkoaGVhZGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2hlYWRlcl0gPSBjdXJyZW50SGVhZGVyc1toZWFkZXJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIG1lcmdlZCBoZWFkZXJzLlxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYWpheCA9IGZ1bmN0aW9uIChtZXRob2QsIHVybCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIEFkanVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgICAgaWYodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXQgZGVmYXVsdCBwYXJhbWV0ZXIgdmFsdWVzLlxuICAgICAgICAgICAgb3B0aW9ucy5jYWNoZSA9IG9wdGlvbnMuY2FjaGUgfHwgZmFsc2U7XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBvcHRpb25zLmRhdGEgfHwge307XG4gICAgICAgICAgICBvcHRpb25zLmhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgfHwge307XG4gICAgICAgICAgICBvcHRpb25zLmpzb25wID0gb3B0aW9ucy5qc29ucCB8fCBmYWxzZTtcbiAgICAgICAgICAgIG9wdGlvbnMuYXN5bmMgPSBvcHRpb25zLmFzeW5jID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy5hc3luYztcblxuICAgICAgICAgICAgLy8gTWVyZ2UgdGhlIHZhcmlvdXMgaGVhZGVyIG9iamVjdHMuXG4gICAgICAgICAgICB2YXIgaGVhZGVycyA9IG1lcmdlSGVhZGVycyh7XG4gICAgICAgICAgICAgICAgJ2FjY2VwdCc6ICcqLyonLFxuICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnXG4gICAgICAgICAgICB9LCBhamF4LmhlYWRlcnMsIG9wdGlvbnMuaGVhZGVycyk7XG5cbiAgICAgICAgICAgIC8vIEVuY29kZSB0aGUgZGF0YSBhY2NvcmRpbmcgdG8gdGhlIGNvbnRlbnQtdHlwZS5cbiAgICAgICAgICAgIHZhciBwYXlsb2FkO1xuICAgICAgICAgICAgaWYgKGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID09PSAnYXBwbGljYXRpb24vanNvbicpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5kYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IGVuY29kZVVzaW5nVXJsRW5jb2Rpbmcob3B0aW9ucy5kYXRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3BlY2lhbGx5IHByZXBhcmUgR0VUIHJlcXVlc3RzOiBTZXR1cCB0aGUgcXVlcnkgc3RyaW5nLCBoYW5kbGUgY2FjaGluZyBhbmQgbWFrZSBhIEpTT05QIGNhbGxcbiAgICAgICAgICAgIC8vIGlmIG5lY2Nlc3NhcnkuXG4gICAgICAgICAgICBpZihtZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICAgICAgICAgICAgLy8gU2V0dXAgdGhlIHF1ZXJ5IHN0cmluZy5cbiAgICAgICAgICAgICAgICB2YXIgcXVlcnlTdHJpbmcgPSBbXTtcbiAgICAgICAgICAgICAgICBpZihwYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5U3RyaW5nLnB1c2gocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBjYWNoaW5nLlxuICAgICAgICAgICAgICAgIGlmKCFvcHRpb25zLmNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5U3RyaW5nLnB1c2goJ189JyArIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIG5lY2Nlc3NhcnkgcHJlcGFyZSB0aGUgcXVlcnkgc3RyaW5nIGZvciBhIEpTT05QIGNhbGwuXG4gICAgICAgICAgICAgICAgaWYob3B0aW9ucy5qc29ucCkge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeVN0cmluZy5wdXNoKCdjYWxsYmFjaz0nICsgb3B0aW9ucy5qc29ucCk7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5U3RyaW5nLnB1c2goJ2pzb25wPScgKyBvcHRpb25zLmpzb25wKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBNZXJnZSB0aGUgcXVlcnkgc3RyaW5nIGFuZCBhdHRhY2ggaXQgdG8gdGhlIHVybC5cbiAgICAgICAgICAgICAgICBxdWVyeVN0cmluZyA9IHF1ZXJ5U3RyaW5nLmpvaW4oJyYnKTtcbiAgICAgICAgICAgICAgICBpZiAocXVlcnlTdHJpbmcubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodXJsLmluZGV4T2YoJz8nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gJyYnICsgcXVlcnlTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgcXVlcnlTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBNYWtlIGEgSlNPTlAgY2FsbCBpZiBuZWNjZXNzYXJ5LlxuICAgICAgICAgICAgICAgIGlmKG9wdGlvbnMuanNvbnApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdC5zcmMgPSB1cmw7XG4gICAgICAgICAgICAgICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2luY2Ugd2UgZ290IGhlcmUsIGl0IGlzIG5vIEpTT05QIHJlcXVlc3QsIHNvIG1ha2UgYSBub3JtYWwgWEhSIHJlcXVlc3QuXG4gICAgICAgICAgICBnZXRYaHIoZnVuY3Rpb24gKGVyciwgeGhyKSB7XG4gICAgICAgICAgICAgICAgaWYoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcblxuICAgICAgICAgICAgICAgIC8vIE9wZW4gdGhlIHJlcXVlc3QuXG4gICAgICAgICAgICAgICAgeGhyLm9wZW4obWV0aG9kLCB1cmwsIG9wdGlvbnMuYXN5bmMpO1xuXG4gICAgICAgICAgICAgICAgLy8gU2V0IHRoZSByZXF1ZXN0IGhlYWRlcnMuXG4gICAgICAgICAgICAgICAgZm9yKHZhciBoZWFkZXIgaW4gaGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICBpZihoZWFkZXJzLmhhc093blByb3BlcnR5KGhlYWRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlciwgaGVhZGVyc1toZWFkZXJdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgcmVxdWVzdCBldmVudHMuXG4gICAgICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0geGhyLnJlc3BvbnNlVGV4dCB8fCAnJztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgaXMgZ2l2ZW4sIHJldHVybi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIGFuIG9iamVjdCB0aGF0IHByb3ZpZGVzIGFjY2VzcyB0byB0aGUgZGF0YSBhcyB0ZXh0IGFuZCBKU09OLlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soeGhyLnN0YXR1cywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYuZXJyb3IoJ0NhbiBub3QgcGFyc2UgSlNPTi4gVVJMOiAnICsgdXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIEFjdHVhbGx5IHNlbmQgdGhlIFhIUiByZXF1ZXN0LlxuICAgICAgICAgICAgICAgIHhoci5zZW5kKHBheWxvYWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRGVmaW5lIHRoZSBleHRlcm5hbCBpbnRlcmZhY2UuXG4gICAgICAgIHZhciBodHRwID0ge1xuICAgICAgICAgICAgYXV0aEJhc2ljOiBmdW5jdGlvbiAodXNlcm5hbWUsIHBhc3N3b3JkKSB7XG4gICAgICAgICAgICAgICAgYWpheC5oZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSAnQmFzaWMgJyArIGJhc2U2NCh1c2VybmFtZSArICc6JyArIHBhc3N3b3JkKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNvbm5lY3Q6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFqYXgoJ0NPTk5FQ1QnLCB1cmwsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGRlbDogZnVuY3Rpb24gKHVybCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWpheCgnREVMRVRFJywgdXJsLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFqYXgoJ0dFVCcsIHVybCwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaGVhZDogZnVuY3Rpb24gKHVybCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWpheCgnSEVBRCcsIHVybCwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaGVhZGVyczogZnVuY3Rpb24gKGhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICBhamF4LmhlYWRlcnMgPSBoZWFkZXJzIHx8IHt9O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaXNBbGxvd2VkOiBmdW5jdGlvbiAodXJsLCB2ZXJiLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucyh1cmwsIGZ1bmN0aW9uIChzdGF0dXMsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZGF0YS50ZXh0KCkuaW5kZXhPZih2ZXJiKSAhPT0gLTEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb3B0aW9uczogZnVuY3Rpb24gKHVybCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWpheCgnT1BUSU9OUycsIHVybCwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcGF0Y2g6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFqYXgoJ1BBVENIJywgdXJsLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBwb3N0OiBmdW5jdGlvbiAodXJsLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhamF4KCdQT1NUJywgdXJsLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBwdXQ6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFqYXgoJ1BVVCcsIHVybCwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdHJhY2U6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFqYXgoJ1RSQUNFJywgdXJsLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cblxuICAgICAgICB2YXIgbWV0aG9kZSA9IG9wdGlvbnMudHlwZSA/IG9wdGlvbnMudHlwZS50b0xvd2VyQ2FzZSgpIDogJ2dldCc7XG5cbiAgICAgICAgaHR0cFttZXRob2RlXShvcHRpb25zLnVybCwgb3B0aW9ucywgZnVuY3Rpb24gKHN0YXR1cywgZGF0YSkge1xuICAgICAgICAgICAgLy8gZmlsZTogcHJvdG9jb2wgYWx3YXlzIGdpdmVzIHN0YXR1cyBjb2RlIDAsIHNvIGNoZWNrIGZvciBkYXRhXG4gICAgICAgICAgICBpZiAoc3RhdHVzID09PSAyMDAgfHwgKHN0YXR1cyA9PT0gMCAmJiBkYXRhLnRleHQoKSkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnN1Y2Nlc3MoZGF0YS5qc29uKCksIHN0YXR1cywgbnVsbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZXJyb3IoZGF0YS50ZXh0KCksIHN0YXR1cywgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBfY29va2llID0ge1xuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uKG5hbWUsdmFsdWUsbWludXRlcyxkb21haW4pIHtcbiAgICAgICAgICAgIHZhciBleHBpcmVzO1xuICAgICAgICAgICAgaWYgKG1pbnV0ZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpKyhtaW51dGVzKjYwKjEwMDApKTtcbiAgICAgICAgICAgICAgICBleHBpcmVzID0gXCI7IGV4cGlyZXM9XCIrZGF0ZS50b0dNVFN0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBleHBpcmVzID0gXCJcIjtcbiAgICAgICAgICAgIGRvbWFpbiA9IChkb21haW4pPyBcImRvbWFpbj1cIitkb21haW4rXCI7XCIgOiBcIlwiO1xuICAgICAgICAgICAgZG9jdW1lbnQuY29va2llID0gbmFtZStcIj1cIit2YWx1ZStleHBpcmVzK1wiO1wiK2RvbWFpbitcInBhdGg9L1wiO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBuYW1lRVEgPSBuYW1lICsgXCI9XCI7XG4gICAgICAgICAgICB2YXIgY2EgPSBkb2N1bWVudC5jb29raWUuc3BsaXQoJzsnKTtcbiAgICAgICAgICAgIGZvcih2YXIgaT0wO2kgPCBjYS5sZW5ndGg7aSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBjYVtpXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoYy5jaGFyQXQoMCk9PScgJykgYyA9IGMuc3Vic3RyaW5nKDEsYy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChjLmluZGV4T2YobmFtZUVRKSA9PT0gMCkgcmV0dXJuIGMuc3Vic3RyaW5nKG5hbWVFUS5sZW5ndGgsYy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZShuYW1lLFwiXCIsLTEpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBjb29raWVfbm9vcCA9IHtcbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbihuYW1lLHZhbHVlLG1pbnV0ZXMsZG9tYWluKSB7fSxcbiAgICAgICAgcmVhZDogZnVuY3Rpb24obmFtZSkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihuYW1lKSB7fVxuICAgIH07XG5cblxuXG4gICAgLy8gbW92ZSBkZXBlbmRlbnQgZnVuY3Rpb25zIHRvIGEgY29udGFpbmVyIHNvIHRoYXRcbiAgICAvLyB0aGV5IGNhbiBiZSBvdmVycmlkZW4gZWFzaWVyIGluIG5vIGpxdWVyeSBlbnZpcm9ubWVudCAobm9kZS5qcylcbiAgICB2YXIgZiA9IHtcbiAgICAgICAgZXh0ZW5kOiAkID8gJC5leHRlbmQgOiBfZXh0ZW5kLFxuICAgICAgICBkZWVwRXh0ZW5kOiBfZGVlcEV4dGVuZCxcbiAgICAgICAgZWFjaDogJCA/ICQuZWFjaCA6IF9lYWNoLFxuICAgICAgICBhamF4OiAkID8gJC5hamF4IDogKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBfYWpheCA6IGZ1bmN0aW9uKCkge30pLFxuICAgICAgICBjb29raWU6IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBfY29va2llIDogY29va2llX25vb3AsXG4gICAgICAgIGRldGVjdExhbmd1YWdlOiBkZXRlY3RMYW5ndWFnZSxcbiAgICAgICAgZXNjYXBlOiBfZXNjYXBlLFxuICAgICAgICBsb2c6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgaWYgKG8uZGVidWcgJiYgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIpIGNvbnNvbGUubG9nKHN0cik7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikgY29uc29sZS5lcnJvcihzdHIpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRDb3VudHlJbmRleE9mTG5nOiBmdW5jdGlvbihsbmcpIHtcbiAgICAgICAgICAgIHZhciBsbmdfaW5kZXggPSAwO1xuICAgICAgICAgICAgaWYgKGxuZyA9PT0gJ25iLU5PJyB8fCBsbmcgPT09ICdubi1OTycgfHwgbG5nID09PSAnbmItbm8nIHx8IGxuZyA9PT0gJ25uLW5vJykgbG5nX2luZGV4ID0gMTtcbiAgICAgICAgICAgIHJldHVybiBsbmdfaW5kZXg7XG4gICAgICAgIH0sXG4gICAgICAgIHRvTGFuZ3VhZ2VzOiBmdW5jdGlvbihsbmcpIHtcbiAgICAgICAgICAgIHZhciBsb2cgPSB0aGlzLmxvZztcblxuICAgICAgICAgICAgZnVuY3Rpb24gYXBwbHlDYXNlKGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gbDtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbCA9PT0gJ3N0cmluZycgJiYgbC5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBsLnNwbGl0KCctJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gby5sb3dlckNhc2VMbmcgP1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHNbMF0udG9Mb3dlckNhc2UoKSArICAnLScgKyBwYXJ0c1sxXS50b0xvd2VyQ2FzZSgpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzWzBdLnRvTG93ZXJDYXNlKCkgKyAgJy0nICsgcGFydHNbMV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXQgPSBvLmxvd2VyQ2FzZUxuZyA/IGwudG9Mb3dlckNhc2UoKSA6IGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxhbmd1YWdlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIHdoaXRlbGlzdCA9IG8ubG5nV2hpdGVsaXN0IHx8IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGFkZExhbmd1YWdlID0gZnVuY3Rpb24obGFuZ3VhZ2Upe1xuICAgICAgICAgICAgICAvL3JlamVjdCBsYW5ncyBub3Qgd2hpdGVsaXN0ZWRcbiAgICAgICAgICAgICAgaWYoIXdoaXRlbGlzdCB8fCB3aGl0ZWxpc3QuaW5kZXhPZihsYW5ndWFnZSkgPiAtMSl7XG4gICAgICAgICAgICAgICAgbGFuZ3VhZ2VzLnB1c2gobGFuZ3VhZ2UpO1xuICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICBsb2coJ3JlamVjdGluZyBub24td2hpdGVsaXN0ZWQgbGFuZ3VhZ2U6ICcgKyBsYW5ndWFnZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxuZyA9PT0gJ3N0cmluZycgJiYgbG5nLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gbG5nLnNwbGl0KCctJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoby5sb2FkICE9PSAndW5zcGVjaWZpYycpIGFkZExhbmd1YWdlKGFwcGx5Q2FzZShsbmcpKTtcbiAgICAgICAgICAgICAgICBpZiAoby5sb2FkICE9PSAnY3VycmVudCcpIGFkZExhbmd1YWdlKGFwcGx5Q2FzZShwYXJ0c1t0aGlzLmdldENvdW50eUluZGV4T2ZMbmcobG5nKV0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkTGFuZ3VhZ2UoYXBwbHlDYXNlKGxuZykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG8uZmFsbGJhY2tMbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobGFuZ3VhZ2VzLmluZGV4T2Yoby5mYWxsYmFja0xuZ1tpXSkgPT09IC0xICYmIG8uZmFsbGJhY2tMbmdbaV0pIGxhbmd1YWdlcy5wdXNoKGFwcGx5Q2FzZShvLmZhbGxiYWNrTG5nW2ldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGFuZ3VhZ2VzO1xuICAgICAgICB9LFxuICAgICAgICByZWdleEVzY2FwZTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1tcXC1cXFtcXF1cXC9cXHtcXH1cXChcXClcXCpcXCtcXD9cXC5cXFxcXFxeXFwkXFx8XS9nLCBcIlxcXFwkJlwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVnZXhSZXBsYWNlbWVudEVzY2FwZTogZnVuY3Rpb24oc3RyT3JGbikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHJPckZuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJPckZuLnJlcGxhY2UoL1xcJC9nLCBcIiQkJCRcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJPckZuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsb2NhbFN0b3JhZ2U6IHtcbiAgICAgICAgICAgIHNldEl0ZW06IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAod2luZG93LmxvY2FsU3RvcmFnZSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmLmxvZygnZmFpbGVkIHRvIHNldCB2YWx1ZSBmb3Iga2V5IFwiJyArIGtleSArICdcIiB0byBsb2NhbFN0b3JhZ2UuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0SXRlbTogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh3aW5kb3cubG9jYWxTdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmLmxvZygnZmFpbGVkIHRvIGdldCB2YWx1ZSBmb3Iga2V5IFwiJyArIGtleSArICdcIiBmcm9tIGxvY2FsU3RvcmFnZS4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGluaXQob3B0aW9ucywgY2IpIHtcblxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNiID0gb3B0aW9ucztcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAvLyBvdmVycmlkZSBkZWZhdWx0cyB3aXRoIHBhc3NlZCBpbiBvcHRpb25zXG4gICAgICAgIGYuZXh0ZW5kKG8sIG9wdGlvbnMpO1xuICAgICAgICBkZWxldGUgby5maXhMbmc7IC8qIHBhc3NlZCBpbiBlYWNoIHRpbWUgKi9cblxuICAgICAgICAvLyBvdmVycmlkZSBmdW5jdGlvbnM6IC5sb2coKSwgLmRldGVjdExhbmd1YWdlKCksIGV0Y1xuICAgICAgICBpZiAoby5mdW5jdGlvbnMpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvLmZ1bmN0aW9ucztcbiAgICAgICAgICAgIGYuZXh0ZW5kKGYsIG9wdGlvbnMuZnVuY3Rpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSBuYW1lc3BhY2Ugb2JqZWN0IGlmIG5hbWVzcGFjZSBpcyBwYXNzZWQgaW4gYXMgc3RyaW5nXG4gICAgICAgIGlmICh0eXBlb2Ygby5ucyA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgby5ucyA9IHsgbmFtZXNwYWNlczogW28ubnNdLCBkZWZhdWx0TnM6IG8ubnN9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmFsbGJhY2sgbmFtZXNwYWNlc1xuICAgICAgICBpZiAodHlwZW9mIG8uZmFsbGJhY2tOUyA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgby5mYWxsYmFja05TID0gW28uZmFsbGJhY2tOU107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmYWxsYmFjayBsYW5ndWFnZXNcbiAgICAgICAgaWYgKHR5cGVvZiBvLmZhbGxiYWNrTG5nID09ICdzdHJpbmcnIHx8IHR5cGVvZiBvLmZhbGxiYWNrTG5nID09ICdib29sZWFuJykge1xuICAgICAgICAgICAgby5mYWxsYmFja0xuZyA9IFtvLmZhbGxiYWNrTG5nXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVzY2FwZSBwcmVmaXgvc3VmZml4XG4gICAgICAgIG8uaW50ZXJwb2xhdGlvblByZWZpeEVzY2FwZWQgPSBmLnJlZ2V4RXNjYXBlKG8uaW50ZXJwb2xhdGlvblByZWZpeCk7XG4gICAgICAgIG8uaW50ZXJwb2xhdGlvblN1ZmZpeEVzY2FwZWQgPSBmLnJlZ2V4RXNjYXBlKG8uaW50ZXJwb2xhdGlvblN1ZmZpeCk7XG5cbiAgICAgICAgaWYgKCFvLmxuZykgby5sbmcgPSBmLmRldGVjdExhbmd1YWdlKCk7XG5cbiAgICAgICAgbGFuZ3VhZ2VzID0gZi50b0xhbmd1YWdlcyhvLmxuZyk7XG4gICAgICAgIGN1cnJlbnRMbmcgPSBsYW5ndWFnZXNbMF07XG4gICAgICAgIGYubG9nKCdjdXJyZW50TG5nIHNldCB0bzogJyArIGN1cnJlbnRMbmcpO1xuXG4gICAgICAgIGlmIChvLnVzZUNvb2tpZSAmJiBmLmNvb2tpZS5yZWFkKG8uY29va2llTmFtZSkgIT09IGN1cnJlbnRMbmcpeyAvL2Nvb2tpZSBpcyB1bnNldCBvciBpbnZhbGlkXG4gICAgICAgICAgICBmLmNvb2tpZS5jcmVhdGUoby5jb29raWVOYW1lLCBjdXJyZW50TG5nLCBvLmNvb2tpZUV4cGlyYXRpb25UaW1lLCBvLmNvb2tpZURvbWFpbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG8uZGV0ZWN0TG5nRnJvbUxvY2FsU3RvcmFnZSAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgICAgIGYubG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2kxOG5leHRfbG5nJywgY3VycmVudExuZyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG5nVHJhbnNsYXRlID0gdHJhbnNsYXRlO1xuICAgICAgICBpZiAob3B0aW9ucy5maXhMbmcpIHtcbiAgICAgICAgICAgIGxuZ1RyYW5zbGF0ZSA9IGZ1bmN0aW9uKGtleSwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubG5nID0gb3B0aW9ucy5sbmcgfHwgbG5nVHJhbnNsYXRlLmxuZztcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNsYXRlKGtleSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbG5nVHJhbnNsYXRlLmxuZyA9IGN1cnJlbnRMbmc7XG4gICAgICAgIH1cblxuICAgICAgICBwbHVyYWxFeHRlbnNpb25zLnNldEN1cnJlbnRMbmcoY3VycmVudExuZyk7XG5cbiAgICAgICAgLy8gYWRkIEpRdWVyeSBleHRlbnNpb25zXG4gICAgICAgIGlmICgkICYmIG8uc2V0SnF1ZXJ5RXh0KSBhZGRKcXVlcnlGdW5jdCgpO1xuXG4gICAgICAgIC8vIGpRdWVyeSBkZWZlcnJlZFxuICAgICAgICB2YXIgZGVmZXJyZWQ7XG4gICAgICAgIGlmICgkICYmICQuRGVmZXJyZWQpIHtcbiAgICAgICAgICAgIGRlZmVycmVkID0gJC5EZWZlcnJlZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV0dXJuIGltbWlkaWF0bHkgaWYgcmVzIGFyZSBwYXNzZWQgaW5cbiAgICAgICAgaWYgKG8ucmVzU3RvcmUpIHtcbiAgICAgICAgICAgIHJlc1N0b3JlID0gby5yZXNTdG9yZTtcbiAgICAgICAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChjYikgY2IobG5nVHJhbnNsYXRlKTtcbiAgICAgICAgICAgIGlmIChkZWZlcnJlZCkgZGVmZXJyZWQucmVzb2x2ZShsbmdUcmFuc2xhdGUpO1xuICAgICAgICAgICAgaWYgKGRlZmVycmVkKSByZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGFuZ3VhZ2VzIHRvIGxvYWRcbiAgICAgICAgdmFyIGxuZ3NUb0xvYWQgPSBmLnRvTGFuZ3VhZ2VzKG8ubG5nKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvLnByZWxvYWQgPT09ICdzdHJpbmcnKSBvLnByZWxvYWQgPSBbby5wcmVsb2FkXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvLnByZWxvYWQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcHJlcyA9IGYudG9MYW5ndWFnZXMoby5wcmVsb2FkW2ldKTtcbiAgICAgICAgICAgIGZvciAodmFyIHkgPSAwLCBsZW4gPSBwcmVzLmxlbmd0aDsgeSA8IGxlbjsgeSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxuZ3NUb0xvYWQuaW5kZXhPZihwcmVzW3ldKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbG5nc1RvTG9hZC5wdXNoKHByZXNbeV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVsc2UgbG9hZCB0aGVtXG4gICAgICAgIGkxOG4uc3luYy5sb2FkKGxuZ3NUb0xvYWQsIG8sIGZ1bmN0aW9uKGVyciwgc3RvcmUpIHtcbiAgICAgICAgICAgIHJlc1N0b3JlID0gc3RvcmU7XG4gICAgICAgICAgICBpbml0aWFsaXplZCA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmIChjYikgY2IobG5nVHJhbnNsYXRlKTtcbiAgICAgICAgICAgIGlmIChkZWZlcnJlZCkgZGVmZXJyZWQucmVzb2x2ZShsbmdUcmFuc2xhdGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZGVmZXJyZWQpIHJldHVybiBkZWZlcnJlZC5wcm9taXNlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZWxvYWQobG5ncywgY2IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsbmdzID09PSAnc3RyaW5nJykgbG5ncyA9IFtsbmdzXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsbmdzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKG8ucHJlbG9hZC5pbmRleE9mKGxuZ3NbaV0pIDwgMCkge1xuICAgICAgICAgICAgICAgIG8ucHJlbG9hZC5wdXNoKGxuZ3NbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbml0KGNiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRSZXNvdXJjZUJ1bmRsZShsbmcsIG5zLCByZXNvdXJjZXMsIGRlZXApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBucyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJlc291cmNlcyA9IG5zO1xuICAgICAgICAgICAgbnMgPSBvLm5zLmRlZmF1bHROcztcbiAgICAgICAgfSBlbHNlIGlmIChvLm5zLm5hbWVzcGFjZXMuaW5kZXhPZihucykgPCAwKSB7XG4gICAgICAgICAgICBvLm5zLm5hbWVzcGFjZXMucHVzaChucyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXNTdG9yZVtsbmddID0gcmVzU3RvcmVbbG5nXSB8fCB7fTtcbiAgICAgICAgcmVzU3RvcmVbbG5nXVtuc10gPSByZXNTdG9yZVtsbmddW25zXSB8fCB7fTtcblxuICAgICAgICBpZiAoZGVlcCkge1xuICAgICAgICAgICAgZi5kZWVwRXh0ZW5kKHJlc1N0b3JlW2xuZ11bbnNdLCByZXNvdXJjZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZi5leHRlbmQocmVzU3RvcmVbbG5nXVtuc10sIHJlc291cmNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG8udXNlTG9jYWxTdG9yYWdlKSB7XG4gICAgICAgICAgICBzeW5jLl9zdG9yZUxvY2FsKHJlc1N0b3JlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc1Jlc291cmNlQnVuZGxlKGxuZywgbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBucyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG5zID0gby5ucy5kZWZhdWx0TnM7XG4gICAgICAgIH1cblxuICAgICAgICByZXNTdG9yZVtsbmddID0gcmVzU3RvcmVbbG5nXSB8fCB7fTtcbiAgICAgICAgdmFyIHJlcyA9IHJlc1N0b3JlW2xuZ11bbnNdIHx8IHt9O1xuXG4gICAgICAgIHZhciBoYXNWYWx1ZXMgPSBmYWxzZTtcbiAgICAgICAgZm9yKHZhciBwcm9wIGluIHJlcykge1xuICAgICAgICAgICAgaWYgKHJlcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgIGhhc1ZhbHVlcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGFzVmFsdWVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFJlc291cmNlQnVuZGxlKGxuZywgbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBucyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG5zID0gby5ucy5kZWZhdWx0TnM7XG4gICAgICAgIH1cblxuICAgICAgICByZXNTdG9yZVtsbmddID0gcmVzU3RvcmVbbG5nXSB8fCB7fTtcbiAgICAgICAgcmV0dXJuIGYuZXh0ZW5kKHt9LCByZXNTdG9yZVtsbmddW25zXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlUmVzb3VyY2VCdW5kbGUobG5nLCBucykge1xuICAgICAgICBpZiAodHlwZW9mIG5zICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbnMgPSBvLm5zLmRlZmF1bHROcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc1N0b3JlW2xuZ10gPSByZXNTdG9yZVtsbmddIHx8IHt9O1xuICAgICAgICByZXNTdG9yZVtsbmddW25zXSA9IHt9O1xuICAgICAgICBpZiAoby51c2VMb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgICAgIHN5bmMuX3N0b3JlTG9jYWwocmVzU3RvcmUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkUmVzb3VyY2UobG5nLCBucywga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5zICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmVzb3VyY2UgPSBucztcbiAgICAgICAgICAgIG5zID0gby5ucy5kZWZhdWx0TnM7XG4gICAgICAgIH0gZWxzZSBpZiAoby5ucy5uYW1lc3BhY2VzLmluZGV4T2YobnMpIDwgMCkge1xuICAgICAgICAgICAgby5ucy5uYW1lc3BhY2VzLnB1c2gobnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzU3RvcmVbbG5nXSA9IHJlc1N0b3JlW2xuZ10gfHwge307XG4gICAgICAgIHJlc1N0b3JlW2xuZ11bbnNdID0gcmVzU3RvcmVbbG5nXVtuc10gfHwge307XG5cbiAgICAgICAgdmFyIGtleXMgPSBrZXkuc3BsaXQoby5rZXlzZXBhcmF0b3IpO1xuICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgIHZhciBub2RlID0gcmVzU3RvcmVbbG5nXVtuc107XG4gICAgICAgIHZhciBvcmlnUmVmID0gbm9kZTtcblxuICAgICAgICB3aGlsZSAoa2V5c1t4XSkge1xuICAgICAgICAgICAgaWYgKHggPT0ga2V5cy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICAgIG5vZGVba2V5c1t4XV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChub2RlW2tleXNbeF1dID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIG5vZGVba2V5c1t4XV0gPSB7fTtcblxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlW2tleXNbeF1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvLnVzZUxvY2FsU3RvcmFnZSkge1xuICAgICAgICAgICAgc3luYy5fc3RvcmVMb2NhbChyZXNTdG9yZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRSZXNvdXJjZXMobG5nLCBucywgcmVzb3VyY2VzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbnMgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXNvdXJjZSA9IG5zO1xuICAgICAgICAgICAgbnMgPSBvLm5zLmRlZmF1bHROcztcbiAgICAgICAgfSBlbHNlIGlmIChvLm5zLm5hbWVzcGFjZXMuaW5kZXhPZihucykgPCAwKSB7XG4gICAgICAgICAgICBvLm5zLm5hbWVzcGFjZXMucHVzaChucyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBtIGluIHJlc291cmNlcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNvdXJjZXNbbV0gPT09ICdzdHJpbmcnKSBhZGRSZXNvdXJjZShsbmcsIG5zLCBtLCByZXNvdXJjZXNbbV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0RGVmYXVsdE5hbWVzcGFjZShucykge1xuICAgICAgICBvLm5zLmRlZmF1bHROcyA9IG5zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWROYW1lc3BhY2UobmFtZXNwYWNlLCBjYikge1xuICAgICAgICBsb2FkTmFtZXNwYWNlcyhbbmFtZXNwYWNlXSwgY2IpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWROYW1lc3BhY2VzKG5hbWVzcGFjZXMsIGNiKSB7XG4gICAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICAgICAgZHluYW1pY0xvYWQ6IG8uZHluYW1pY0xvYWQsXG4gICAgICAgICAgICByZXNHZXRQYXRoOiBvLnJlc0dldFBhdGgsXG4gICAgICAgICAgICBnZXRBc3luYzogby5nZXRBc3luYyxcbiAgICAgICAgICAgIGN1c3RvbUxvYWQ6IG8uY3VzdG9tTG9hZCxcbiAgICAgICAgICAgIG5zOiB7IG5hbWVzcGFjZXM6IG5hbWVzcGFjZXMsIGRlZmF1bHROczogJyd9IC8qIG5ldyBuYW1lc3BhY2VzIHRvIGxvYWQgKi9cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBsYW5ndWFnZXMgdG8gbG9hZFxuICAgICAgICB2YXIgbG5nc1RvTG9hZCA9IGYudG9MYW5ndWFnZXMoby5sbmcpO1xuICAgICAgICBpZiAodHlwZW9mIG8ucHJlbG9hZCA9PT0gJ3N0cmluZycpIG8ucHJlbG9hZCA9IFtvLnByZWxvYWRdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG8ucHJlbG9hZC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwcmVzID0gZi50b0xhbmd1YWdlcyhvLnByZWxvYWRbaV0pO1xuICAgICAgICAgICAgZm9yICh2YXIgeSA9IDAsIGxlbiA9IHByZXMubGVuZ3RoOyB5IDwgbGVuOyB5KyspIHtcbiAgICAgICAgICAgICAgICBpZiAobG5nc1RvTG9hZC5pbmRleE9mKHByZXNbeV0pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBsbmdzVG9Mb2FkLnB1c2gocHJlc1t5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgaGF2ZSB0byBsb2FkXG4gICAgICAgIHZhciBsbmdOZWVkTG9hZCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBhID0gMCwgbGVuQSA9IGxuZ3NUb0xvYWQubGVuZ3RoOyBhIDwgbGVuQTsgYSsrKSB7XG4gICAgICAgICAgICB2YXIgbmVlZExvYWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciByZXNTZXQgPSByZXNTdG9yZVtsbmdzVG9Mb2FkW2FdXTtcbiAgICAgICAgICAgIGlmIChyZXNTZXQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBiID0gMCwgbGVuQiA9IG5hbWVzcGFjZXMubGVuZ3RoOyBiIDwgbGVuQjsgYisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzU2V0W25hbWVzcGFjZXNbYl1dKSBuZWVkTG9hZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZWVkTG9hZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuZWVkTG9hZCkgbG5nTmVlZExvYWQucHVzaChsbmdzVG9Mb2FkW2FdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsbmdOZWVkTG9hZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGkxOG4uc3luYy5fZmV0Y2gobG5nTmVlZExvYWQsIG9wdHMsIGZ1bmN0aW9uKGVyciwgc3RvcmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9kbyA9IG5hbWVzcGFjZXMubGVuZ3RoICogbG5nTmVlZExvYWQubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgLy8gbG9hZCBlYWNoIGZpbGUgaW5kaXZpZHVhbFxuICAgICAgICAgICAgICAgIGYuZWFjaChuYW1lc3BhY2VzLCBmdW5jdGlvbihuc0luZGV4LCBuc1ZhbHVlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYXBwZW5kIG5hbWVzcGFjZSB0byBuYW1lc3BhY2UgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8ubnMubmFtZXNwYWNlcy5pbmRleE9mKG5zVmFsdWUpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgby5ucy5uYW1lc3BhY2VzLnB1c2gobnNWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmLmVhY2gobG5nTmVlZExvYWQsIGZ1bmN0aW9uKGxuZ0luZGV4LCBsbmdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzU3RvcmVbbG5nVmFsdWVdID0gcmVzU3RvcmVbbG5nVmFsdWVdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzU3RvcmVbbG5nVmFsdWVdW25zVmFsdWVdID0gc3RvcmVbbG5nVmFsdWVdW25zVmFsdWVdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2RvLS07IC8vIHdhaXQgZm9yIGFsbCBkb25lIGJlZm9yIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9kbyA9PT0gMCAmJiBjYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLnVzZUxvY2FsU3RvcmFnZSkgaTE4bi5zeW5jLl9zdG9yZUxvY2FsKHJlc1N0b3JlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNiKSBjYigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0TG5nKGxuZywgb3B0aW9ucywgY2IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYiA9IG9wdGlvbnM7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH0gZWxzZSBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMubG5nID0gbG5nO1xuICAgICAgICByZXR1cm4gaW5pdChvcHRpb25zLCBjYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG5nKCkge1xuICAgICAgICByZXR1cm4gY3VycmVudExuZztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWxvYWQoY2IpIHtcbiAgICAgICAgcmVzU3RvcmUgPSB7fTtcbiAgICAgICAgc2V0TG5nKGN1cnJlbnRMbmcsIGNiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkSnF1ZXJ5RnVuY3QoKSB7XG4gICAgICAgIC8vICQudCBzaG9ydGN1dFxuICAgICAgICAkLnQgPSAkLnQgfHwgdHJhbnNsYXRlO1xuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlKGVsZSwga2V5LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoa2V5Lmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgICAgICAgICB2YXIgYXR0ciA9ICd0ZXh0JztcblxuICAgICAgICAgICAgaWYgKGtleS5pbmRleE9mKCdbJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBrZXkuc3BsaXQoJ10nKTtcbiAgICAgICAgICAgICAgICBrZXkgPSBwYXJ0c1sxXTtcbiAgICAgICAgICAgICAgICBhdHRyID0gcGFydHNbMF0uc3Vic3RyKDEsIHBhcnRzWzBdLmxlbmd0aC0xKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGtleS5pbmRleE9mKCc7JykgPT09IGtleS5sZW5ndGgtMSkge1xuICAgICAgICAgICAgICAgIGtleSA9IGtleS5zdWJzdHIoMCwga2V5Lmxlbmd0aC0yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9wdGlvbnNUb1VzZTtcbiAgICAgICAgICAgIGlmIChhdHRyID09PSAnaHRtbCcpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zVG9Vc2UgPSBvLmRlZmF1bHRWYWx1ZUZyb21Db250ZW50ID8gJC5leHRlbmQoeyBkZWZhdWx0VmFsdWU6IGVsZS5odG1sKCkgfSwgb3B0aW9ucykgOiBvcHRpb25zO1xuICAgICAgICAgICAgICAgIGVsZS5odG1sKCQudChrZXksIG9wdGlvbnNUb1VzZSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhdHRyID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zVG9Vc2UgPSBvLmRlZmF1bHRWYWx1ZUZyb21Db250ZW50ID8gJC5leHRlbmQoeyBkZWZhdWx0VmFsdWU6IGVsZS50ZXh0KCkgfSwgb3B0aW9ucykgOiBvcHRpb25zO1xuICAgICAgICAgICAgICAgIGVsZS50ZXh0KCQudChrZXksIG9wdGlvbnNUb1VzZSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhdHRyID09PSAncHJlcGVuZCcpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zVG9Vc2UgPSBvLmRlZmF1bHRWYWx1ZUZyb21Db250ZW50ID8gJC5leHRlbmQoeyBkZWZhdWx0VmFsdWU6IGVsZS5odG1sKCkgfSwgb3B0aW9ucykgOiBvcHRpb25zO1xuICAgICAgICAgICAgICAgIGVsZS5wcmVwZW5kKCQudChrZXksIG9wdGlvbnNUb1VzZSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhdHRyID09PSAnYXBwZW5kJykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnNUb1VzZSA9IG8uZGVmYXVsdFZhbHVlRnJvbUNvbnRlbnQgPyAkLmV4dGVuZCh7IGRlZmF1bHRWYWx1ZTogZWxlLmh0bWwoKSB9LCBvcHRpb25zKSA6IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgZWxlLmFwcGVuZCgkLnQoa2V5LCBvcHRpb25zVG9Vc2UpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXR0ci5pbmRleE9mKFwiZGF0YS1cIikgPT09IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YUF0dHIgPSBhdHRyLnN1YnN0cigoXCJkYXRhLVwiKS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIG9wdGlvbnNUb1VzZSA9IG8uZGVmYXVsdFZhbHVlRnJvbUNvbnRlbnQgPyAkLmV4dGVuZCh7IGRlZmF1bHRWYWx1ZTogZWxlLmRhdGEoZGF0YUF0dHIpIH0sIG9wdGlvbnMpIDogb3B0aW9ucztcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNsYXRlZCA9ICQudChrZXksIG9wdGlvbnNUb1VzZSk7XG4gICAgICAgICAgICAgICAgLy93ZSBjaGFuZ2UgaW50byB0aGUgZGF0YSBjYWNoZVxuICAgICAgICAgICAgICAgIGVsZS5kYXRhKGRhdGFBdHRyLCB0cmFuc2xhdGVkKTtcbiAgICAgICAgICAgICAgICAvL3dlIGNoYW5nZSBpbnRvIHRoZSBkb21cbiAgICAgICAgICAgICAgICBlbGUuYXR0cihhdHRyLCB0cmFuc2xhdGVkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1RvVXNlID0gby5kZWZhdWx0VmFsdWVGcm9tQ29udGVudCA/ICQuZXh0ZW5kKHsgZGVmYXVsdFZhbHVlOiBlbGUuYXR0cihhdHRyKSB9LCBvcHRpb25zKSA6IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgZWxlLmF0dHIoYXR0ciwgJC50KGtleSwgb3B0aW9uc1RvVXNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBsb2NhbGl6ZShlbGUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBlbGUuYXR0cihvLnNlbGVjdG9yQXR0cik7XG4gICAgICAgICAgICBpZiAoIWtleSAmJiB0eXBlb2Yga2V5ICE9PSAndW5kZWZpbmVkJyAmJiBrZXkgIT09IGZhbHNlKSBrZXkgPSBlbGUudGV4dCgpIHx8IGVsZS52YWwoKTtcbiAgICAgICAgICAgIGlmICgha2V5KSByZXR1cm47XG5cbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlbGVcbiAgICAgICAgICAgICAgLCB0YXJnZXRTZWxlY3RvciA9IGVsZS5kYXRhKFwiaTE4bi10YXJnZXRcIik7XG4gICAgICAgICAgICBpZiAodGFyZ2V0U2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBlbGUuZmluZCh0YXJnZXRTZWxlY3RvcikgfHwgZWxlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMgJiYgby51c2VEYXRhQXR0ck9wdGlvbnMgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gZWxlLmRhdGEoXCJpMThuLW9wdGlvbnNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAgICAgaWYgKGtleS5pbmRleE9mKCc7JykgPj0gMCkge1xuICAgICAgICAgICAgICAgIHZhciBrZXlzID0ga2V5LnNwbGl0KCc7Jyk7XG5cbiAgICAgICAgICAgICAgICAkLmVhY2goa2V5cywgZnVuY3Rpb24obSwgaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoayAhPT0gJycpIHBhcnNlKHRhcmdldCwgaywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyc2UodGFyZ2V0LCBrZXksIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoby51c2VEYXRhQXR0ck9wdGlvbnMgPT09IHRydWUpIGVsZS5kYXRhKFwiaTE4bi1vcHRpb25zXCIsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZm5cbiAgICAgICAgJC5mbi5pMThuID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gbG9jYWxpemUgZWxlbWVudCBpdHNlbGZcbiAgICAgICAgICAgICAgICBsb2NhbGl6ZSgkKHRoaXMpLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgIC8vIGxvY2FsaXplIGNoaWxkc1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50cyA9ICAkKHRoaXMpLmZpbmQoJ1snICsgby5zZWxlY3RvckF0dHIgKyAnXScpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsaXplKCQodGhpcyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcGx5UmVwbGFjZW1lbnQoc3RyLCByZXBsYWNlbWVudEhhc2gsIG5lc3RlZEtleSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIXN0cikgcmV0dXJuIHN0cjtcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCByZXBsYWNlbWVudEhhc2g7IC8vIGZpcnN0IGNhbGwgdXNlcyByZXBsYWNlbWVudCBoYXNoIGNvbWJpbmVkIHdpdGggb3B0aW9uc1xuICAgICAgICBpZiAoc3RyLmluZGV4T2Yob3B0aW9ucy5pbnRlcnBvbGF0aW9uUHJlZml4IHx8IG8uaW50ZXJwb2xhdGlvblByZWZpeCkgPCAwKSByZXR1cm4gc3RyO1xuXG4gICAgICAgIHZhciBwcmVmaXggPSBvcHRpb25zLmludGVycG9sYXRpb25QcmVmaXggPyBmLnJlZ2V4RXNjYXBlKG9wdGlvbnMuaW50ZXJwb2xhdGlvblByZWZpeCkgOiBvLmludGVycG9sYXRpb25QcmVmaXhFc2NhcGVkXG4gICAgICAgICAgLCBzdWZmaXggPSBvcHRpb25zLmludGVycG9sYXRpb25TdWZmaXggPyBmLnJlZ2V4RXNjYXBlKG9wdGlvbnMuaW50ZXJwb2xhdGlvblN1ZmZpeCkgOiBvLmludGVycG9sYXRpb25TdWZmaXhFc2NhcGVkXG4gICAgICAgICAgLCB1bkVzY2FwaW5nU3VmZml4ID0gJ0hUTUwnK3N1ZmZpeDtcblxuICAgICAgICB2YXIgaGFzaCA9IHJlcGxhY2VtZW50SGFzaC5yZXBsYWNlICYmIHR5cGVvZiByZXBsYWNlbWVudEhhc2gucmVwbGFjZSA9PT0gJ29iamVjdCcgPyByZXBsYWNlbWVudEhhc2gucmVwbGFjZSA6IHJlcGxhY2VtZW50SGFzaDtcbiAgICAgICAgZi5lYWNoKGhhc2gsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBuZXh0S2V5ID0gbmVzdGVkS2V5ID8gbmVzdGVkS2V5ICsgby5rZXlzZXBhcmF0b3IgKyBrZXkgOiBrZXk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN0ciA9IGFwcGx5UmVwbGFjZW1lbnQoc3RyLCB2YWx1ZSwgbmV4dEtleSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmVzY2FwZUludGVycG9sYXRpb24gfHwgby5lc2NhcGVJbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoW3ByZWZpeCwgbmV4dEtleSwgdW5Fc2NhcGluZ1N1ZmZpeF0uam9pbignJyksICdnJyksIGYucmVnZXhSZXBsYWNlbWVudEVzY2FwZSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShuZXcgUmVnRXhwKFtwcmVmaXgsIG5leHRLZXksIHN1ZmZpeF0uam9pbignJyksICdnJyksIGYucmVnZXhSZXBsYWNlbWVudEVzY2FwZShmLmVzY2FwZSh2YWx1ZSkpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShuZXcgUmVnRXhwKFtwcmVmaXgsIG5leHRLZXksIHN1ZmZpeF0uam9pbignJyksICdnJyksIGYucmVnZXhSZXBsYWNlbWVudEVzY2FwZSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzdHIgPSBvcHRpb25zLmVzY2FwZUludGVycG9sYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIC8vIGFwcGVuZCBpdCB0byBmdW5jdGlvbnNcbiAgICBmLmFwcGx5UmVwbGFjZW1lbnQgPSBhcHBseVJlcGxhY2VtZW50O1xuXG4gICAgZnVuY3Rpb24gYXBwbHlSZXVzZSh0cmFuc2xhdGVkLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBjb21tYSA9ICcsJztcbiAgICAgICAgdmFyIG9wdGlvbnNfb3BlbiA9ICd7JztcbiAgICAgICAgdmFyIG9wdGlvbnNfY2xvc2UgPSAnfSc7XG5cbiAgICAgICAgdmFyIG9wdHMgPSBmLmV4dGVuZCh7fSwgb3B0aW9ucyk7XG4gICAgICAgIGRlbGV0ZSBvcHRzLnBvc3RQcm9jZXNzO1xuXG4gICAgICAgIHdoaWxlICh0cmFuc2xhdGVkLmluZGV4T2Yoby5yZXVzZVByZWZpeCkgIT0gLTEpIHtcbiAgICAgICAgICAgIHJlcGxhY2VtZW50Q291bnRlcisrO1xuICAgICAgICAgICAgaWYgKHJlcGxhY2VtZW50Q291bnRlciA+IG8ubWF4UmVjdXJzaW9uKSB7IGJyZWFrOyB9IC8vIHNhZmV0eSBuZXQgZm9yIHRvbyBtdWNoIHJlY3Vyc2lvblxuICAgICAgICAgICAgdmFyIGluZGV4X29mX29wZW5pbmcgPSB0cmFuc2xhdGVkLmxhc3RJbmRleE9mKG8ucmV1c2VQcmVmaXgpO1xuICAgICAgICAgICAgdmFyIGluZGV4X29mX2VuZF9vZl9jbG9zaW5nID0gdHJhbnNsYXRlZC5pbmRleE9mKG8ucmV1c2VTdWZmaXgsIGluZGV4X29mX29wZW5pbmcpICsgby5yZXVzZVN1ZmZpeC5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSB0cmFuc2xhdGVkLnN1YnN0cmluZyhpbmRleF9vZl9vcGVuaW5nLCBpbmRleF9vZl9lbmRfb2ZfY2xvc2luZyk7XG4gICAgICAgICAgICB2YXIgdG9rZW5fd2l0aG91dF9zeW1ib2xzID0gdG9rZW4ucmVwbGFjZShvLnJldXNlUHJlZml4LCAnJykucmVwbGFjZShvLnJldXNlU3VmZml4LCAnJyk7XG5cbiAgICAgICAgICAgIGlmIChpbmRleF9vZl9lbmRfb2ZfY2xvc2luZyA8PSBpbmRleF9vZl9vcGVuaW5nKSB7XG4gICAgICAgICAgICAgICAgZi5lcnJvcigndGhlcmUgaXMgYW4gbWlzc2luZyBjbG9zaW5nIGluIGZvbGxvd2luZyB0cmFuc2xhdGlvbiB2YWx1ZScsIHRyYW5zbGF0ZWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRva2VuX3dpdGhvdXRfc3ltYm9scy5pbmRleE9mKGNvbW1hKSAhPSAtMSkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleF9vZl90b2tlbl9lbmRfb2ZfY2xvc2luZyA9IHRva2VuX3dpdGhvdXRfc3ltYm9scy5pbmRleE9mKGNvbW1hKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5fd2l0aG91dF9zeW1ib2xzLmluZGV4T2Yob3B0aW9uc19vcGVuLCBpbmRleF9vZl90b2tlbl9lbmRfb2ZfY2xvc2luZykgIT0gLTEgJiYgdG9rZW5fd2l0aG91dF9zeW1ib2xzLmluZGV4T2Yob3B0aW9uc19jbG9zZSwgaW5kZXhfb2ZfdG9rZW5fZW5kX29mX2Nsb3NpbmcpICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleF9vZl9vcHRzX29wZW5pbmcgPSB0b2tlbl93aXRob3V0X3N5bWJvbHMuaW5kZXhPZihvcHRpb25zX29wZW4sIGluZGV4X29mX3Rva2VuX2VuZF9vZl9jbG9zaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4X29mX29wdHNfZW5kX29mX2Nsb3NpbmcgPSB0b2tlbl93aXRob3V0X3N5bWJvbHMuaW5kZXhPZihvcHRpb25zX2Nsb3NlLCBpbmRleF9vZl9vcHRzX29wZW5pbmcpICsgb3B0aW9uc19jbG9zZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRzID0gZi5leHRlbmQob3B0cywgSlNPTi5wYXJzZSh0b2tlbl93aXRob3V0X3N5bWJvbHMuc3Vic3RyaW5nKGluZGV4X29mX29wdHNfb3BlbmluZywgaW5kZXhfb2Zfb3B0c19lbmRfb2ZfY2xvc2luZykpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuX3dpdGhvdXRfc3ltYm9scyA9IHRva2VuX3dpdGhvdXRfc3ltYm9scy5zdWJzdHJpbmcoMCwgaW5kZXhfb2ZfdG9rZW5fZW5kX29mX2Nsb3NpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0cmFuc2xhdGVkX3Rva2VuID0gX3RyYW5zbGF0ZSh0b2tlbl93aXRob3V0X3N5bWJvbHMsIG9wdHMpO1xuICAgICAgICAgICAgdHJhbnNsYXRlZCA9IHRyYW5zbGF0ZWQucmVwbGFjZSh0b2tlbiwgZi5yZWdleFJlcGxhY2VtZW50RXNjYXBlKHRyYW5zbGF0ZWRfdG9rZW4pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhbnNsYXRlZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNDb250ZXh0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLmNvbnRleHQgJiYgKHR5cGVvZiBvcHRpb25zLmNvbnRleHQgPT0gJ3N0cmluZycgfHwgdHlwZW9mIG9wdGlvbnMuY29udGV4dCA9PSAnbnVtYmVyJykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5lZWRzUGx1cmFsKG9wdGlvbnMsIGxuZykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnMuY291bnQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucy5jb3VudCAhPSAnc3RyaW5nJy8qICYmIHBsdXJhbEV4dGVuc2lvbnMubmVlZHNQbHVyYWwobG5nLCBvcHRpb25zLmNvdW50KSovKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBuZWVkc0luZGVmaW5pdGVBcnRpY2xlKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLmluZGVmaW5pdGVfYXJ0aWNsZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvcHRpb25zLmluZGVmaW5pdGVfYXJ0aWNsZSAhPSAnc3RyaW5nJyAmJiBvcHRpb25zLmluZGVmaW5pdGVfYXJ0aWNsZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhpc3RzKGtleSwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB2YXIgbm90Rm91bmQgPSBfZ2V0RGVmYXVsdFZhbHVlKGtleSwgb3B0aW9ucylcbiAgICAgICAgICAgICwgZm91bmQgPSBfZmluZChrZXksIG9wdGlvbnMpO1xuXG4gICAgICAgIHJldHVybiBmb3VuZCAhPT0gdW5kZWZpbmVkIHx8IGZvdW5kID09PSBub3RGb3VuZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGUoa2V5LCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIGlmICghaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIGYubG9nKCdpMThuZXh0IG5vdCBmaW5pc2hlZCBpbml0aWFsaXphdGlvbi4geW91IG1pZ2h0IGhhdmUgY2FsbGVkIHQgZnVuY3Rpb24gYmVmb3JlIGxvYWRpbmcgcmVzb3VyY2VzIGZpbmlzaGVkLicpXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kZWZhdWx0VmFsdWUgfHwgJyc7XG4gICAgICAgIH07XG4gICAgICAgIHJlcGxhY2VtZW50Q291bnRlciA9IDA7XG4gICAgICAgIHJldHVybiBfdHJhbnNsYXRlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2dldERlZmF1bHRWYWx1ZShrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMuZGVmYXVsdFZhbHVlIDoga2V5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9pbmplY3RTcHJpbnRmUHJvY2Vzc29yKCkge1xuXG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcblxuICAgICAgICAvLyBtaDogYnVpbGQgYXJyYXkgZnJvbSBzZWNvbmQgYXJndW1lbnQgb253YXJkc1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb3N0UHJvY2VzczogJ3NwcmludGYnLFxuICAgICAgICAgICAgc3ByaW50ZjogICAgIHZhbHVlc1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF90cmFuc2xhdGUocG90ZW50aWFsS2V5cywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmIChvLnNob3J0Y3V0RnVuY3Rpb24gPT09ICdzcHJpbnRmJykge1xuICAgICAgICAgICAgICAgIC8vIG1oOiBnZXR0ZXh0IGxpa2Ugc3ByaW50ZiBzeW50YXggZm91bmQsIGF1dG9tYXRpY2FsbHkgY3JlYXRlIHNwcmludGYgcHJvY2Vzc29yXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IF9pbmplY3RTcHJpbnRmUHJvY2Vzc29yLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG8uc2hvcnRjdXRGdW5jdGlvbiA9PT0gJ2RlZmF1bHRWYWx1ZScpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IG9wdGlvbnNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygby5kZWZhdWx0VmFyaWFibGVzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGYuZXh0ZW5kKHt9LCBvLmRlZmF1bHRWYXJpYWJsZXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvdGVudGlhbEtleXMgPT09IHVuZGVmaW5lZCB8fCBwb3RlbnRpYWxLZXlzID09PSBudWxsIHx8IHBvdGVudGlhbEtleXMgPT09ICcnKSByZXR1cm4gJyc7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwb3RlbnRpYWxLZXlzID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcG90ZW50aWFsS2V5cyA9IFN0cmluZyhwb3RlbnRpYWxLZXlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcG90ZW50aWFsS2V5cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHBvdGVudGlhbEtleXMgPSBbcG90ZW50aWFsS2V5c107XG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2V5ID0gcG90ZW50aWFsS2V5c1swXTtcblxuICAgICAgICBpZiAocG90ZW50aWFsS2V5cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvdGVudGlhbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBwb3RlbnRpYWxLZXlzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdHMoa2V5LCBvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm90Rm91bmQgPSBfZ2V0RGVmYXVsdFZhbHVlKGtleSwgb3B0aW9ucylcbiAgICAgICAgICAgICwgZm91bmQgPSBfZmluZChrZXksIG9wdGlvbnMpXG4gICAgICAgICAgICAsIGxuZ3MgPSBvcHRpb25zLmxuZyA/IGYudG9MYW5ndWFnZXMob3B0aW9ucy5sbmcsIG9wdGlvbnMuZmFsbGJhY2tMbmcpIDogbGFuZ3VhZ2VzXG4gICAgICAgICAgICAsIG5zID0gb3B0aW9ucy5ucyB8fCBvLm5zLmRlZmF1bHROc1xuICAgICAgICAgICAgLCBwYXJ0cztcblxuICAgICAgICAvLyBzcGxpdCBucyBhbmQga2V5XG4gICAgICAgIGlmIChrZXkuaW5kZXhPZihvLm5zc2VwYXJhdG9yKSA+IC0xKSB7XG4gICAgICAgICAgICBwYXJ0cyA9IGtleS5zcGxpdChvLm5zc2VwYXJhdG9yKTtcbiAgICAgICAgICAgIG5zID0gcGFydHNbMF07XG4gICAgICAgICAgICBrZXkgPSBwYXJ0c1sxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb3VuZCA9PT0gdW5kZWZpbmVkICYmIG8uc2VuZE1pc3NpbmcgJiYgdHlwZW9mIG8ubWlzc2luZ0tleUhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxuZykge1xuICAgICAgICAgICAgICAgIG8ubWlzc2luZ0tleUhhbmRsZXIobG5nc1swXSwgbnMsIGtleSwgbm90Rm91bmQsIGxuZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvLm1pc3NpbmdLZXlIYW5kbGVyKG8ubG5nLCBucywga2V5LCBub3RGb3VuZCwgbG5ncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcG9zdFByb2Nlc3NvcnNUb0FwcGx5O1xuICAgICAgICBpZiAodHlwZW9mIG8ucG9zdFByb2Nlc3MgPT09ICdzdHJpbmcnICYmIG8ucG9zdFByb2Nlc3MgIT09ICcnKSB7XG4gICAgICAgICAgICBwb3N0UHJvY2Vzc29yc1RvQXBwbHkgPSBbby5wb3N0UHJvY2Vzc107XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG8ucG9zdFByb2Nlc3MgPT09ICdhcnJheScgfHwgdHlwZW9mIG8ucG9zdFByb2Nlc3MgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBwb3N0UHJvY2Vzc29yc1RvQXBwbHkgPSBvLnBvc3RQcm9jZXNzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zdFByb2Nlc3NvcnNUb0FwcGx5ID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMucG9zdFByb2Nlc3MgPT09ICdzdHJpbmcnICYmIG9wdGlvbnMucG9zdFByb2Nlc3MgIT09ICcnKSB7XG4gICAgICAgICAgICBwb3N0UHJvY2Vzc29yc1RvQXBwbHkgPSBwb3N0UHJvY2Vzc29yc1RvQXBwbHkuY29uY2F0KFtvcHRpb25zLnBvc3RQcm9jZXNzXSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMucG9zdFByb2Nlc3MgPT09ICdhcnJheScgfHwgdHlwZW9mIG9wdGlvbnMucG9zdFByb2Nlc3MgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBwb3N0UHJvY2Vzc29yc1RvQXBwbHkgPSBwb3N0UHJvY2Vzc29yc1RvQXBwbHkuY29uY2F0KG9wdGlvbnMucG9zdFByb2Nlc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvdW5kICE9PSB1bmRlZmluZWQgJiYgcG9zdFByb2Nlc3NvcnNUb0FwcGx5Lmxlbmd0aCkge1xuICAgICAgICAgICAgcG9zdFByb2Nlc3NvcnNUb0FwcGx5LmZvckVhY2goZnVuY3Rpb24ocG9zdFByb2Nlc3Nvcikge1xuICAgICAgICAgICAgICAgIGlmIChwb3N0UHJvY2Vzc29yc1twb3N0UHJvY2Vzc29yXSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHBvc3RQcm9jZXNzb3JzW3Bvc3RQcm9jZXNzb3JdKGZvdW5kLCBrZXksIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHJvY2VzcyBub3RGb3VuZCBpZiBmdW5jdGlvbiBleGlzdHNcbiAgICAgICAgdmFyIHNwbGl0Tm90Rm91bmQgPSBub3RGb3VuZDtcbiAgICAgICAgaWYgKG5vdEZvdW5kLmluZGV4T2Yoby5uc3NlcGFyYXRvcikgPiAtMSkge1xuICAgICAgICAgICAgcGFydHMgPSBub3RGb3VuZC5zcGxpdChvLm5zc2VwYXJhdG9yKTtcbiAgICAgICAgICAgIHNwbGl0Tm90Rm91bmQgPSBwYXJ0c1sxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3BsaXROb3RGb3VuZCA9PT0ga2V5ICYmIG8ucGFyc2VNaXNzaW5nS2V5KSB7XG4gICAgICAgICAgICBub3RGb3VuZCA9IG8ucGFyc2VNaXNzaW5nS2V5KG5vdEZvdW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb3VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBub3RGb3VuZCA9IGFwcGx5UmVwbGFjZW1lbnQobm90Rm91bmQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgbm90Rm91bmQgPSBhcHBseVJldXNlKG5vdEZvdW5kLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgaWYgKHBvc3RQcm9jZXNzb3JzVG9BcHBseS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gX2dldERlZmF1bHRWYWx1ZShrZXksIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHBvc3RQcm9jZXNzb3JzVG9BcHBseS5mb3JFYWNoKGZ1bmN0aW9uKHBvc3RQcm9jZXNzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc3RQcm9jZXNzb3JzW3Bvc3RQcm9jZXNzb3JdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHBvc3RQcm9jZXNzb3JzW3Bvc3RQcm9jZXNzb3JdKHZhbCwga2V5LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChmb3VuZCAhPT0gdW5kZWZpbmVkKSA/IGZvdW5kIDogbm90Rm91bmQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2ZpbmQoa2V5LCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHZhciBvcHRpb25XaXRob3V0Q291bnQsIHRyYW5zbGF0ZWRcbiAgICAgICAgICAgICwgbm90Rm91bmQgPSBfZ2V0RGVmYXVsdFZhbHVlKGtleSwgb3B0aW9ucylcbiAgICAgICAgICAgICwgbG5ncyA9IGxhbmd1YWdlcztcblxuICAgICAgICBpZiAoIXJlc1N0b3JlKSB7IHJldHVybiBub3RGb3VuZDsgfSAvLyBubyByZXNTdG9yZSB0byB0cmFuc2xhdGUgZnJvbVxuXG4gICAgICAgIC8vIENJIG1vZGVcbiAgICAgICAgaWYgKGxuZ3NbMF0udG9Mb3dlckNhc2UoKSA9PT0gJ2NpbW9kZScpIHJldHVybiBub3RGb3VuZDtcblxuICAgICAgICAvLyBwYXNzZWQgaW4gbG5nXG4gICAgICAgIGlmIChvcHRpb25zLmxuZ3MpIGxuZ3MgPSBvcHRpb25zLmxuZ3M7XG4gICAgICAgIGlmIChvcHRpb25zLmxuZykge1xuICAgICAgICAgICAgbG5ncyA9IGYudG9MYW5ndWFnZXMob3B0aW9ucy5sbmcsIG9wdGlvbnMuZmFsbGJhY2tMbmcpO1xuXG4gICAgICAgICAgICBpZiAoIXJlc1N0b3JlW2xuZ3NbMF1dKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZEFzeW5jID0gby5nZXRBc3luYztcbiAgICAgICAgICAgICAgICBvLmdldEFzeW5jID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBpMThuLnN5bmMubG9hZChsbmdzLCBvLCBmdW5jdGlvbihlcnIsIHN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIGYuZXh0ZW5kKHJlc1N0b3JlLCBzdG9yZSk7XG4gICAgICAgICAgICAgICAgICAgIG8uZ2V0QXN5bmMgPSBvbGRBc3luYztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBucyA9IG9wdGlvbnMubnMgfHwgby5ucy5kZWZhdWx0TnM7XG4gICAgICAgIGlmIChrZXkuaW5kZXhPZihvLm5zc2VwYXJhdG9yKSA+IC0xKSB7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBrZXkuc3BsaXQoby5uc3NlcGFyYXRvcik7XG4gICAgICAgICAgICBucyA9IHBhcnRzWzBdO1xuICAgICAgICAgICAga2V5ID0gcGFydHNbMV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzQ29udGV4dChvcHRpb25zKSkge1xuICAgICAgICAgICAgb3B0aW9uV2l0aG91dENvdW50ID0gZi5leHRlbmQoe30sIG9wdGlvbnMpO1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbldpdGhvdXRDb3VudC5jb250ZXh0O1xuICAgICAgICAgICAgb3B0aW9uV2l0aG91dENvdW50LmRlZmF1bHRWYWx1ZSA9IG8uY29udGV4dE5vdEZvdW5kO1xuXG4gICAgICAgICAgICB2YXIgY29udGV4dEtleSA9IG5zICsgby5uc3NlcGFyYXRvciArIGtleSArICdfJyArIG9wdGlvbnMuY29udGV4dDtcblxuICAgICAgICAgICAgdHJhbnNsYXRlZCA9IHRyYW5zbGF0ZShjb250ZXh0S2V5LCBvcHRpb25XaXRob3V0Q291bnQpO1xuICAgICAgICAgICAgaWYgKHRyYW5zbGF0ZWQgIT0gby5jb250ZXh0Tm90Rm91bmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwbHlSZXBsYWNlbWVudCh0cmFuc2xhdGVkLCB7IGNvbnRleHQ6IG9wdGlvbnMuY29udGV4dCB9KTsgLy8gYXBwbHkgcmVwbGFjZW1lbnQgZm9yIGNvbnRleHQgb25seVxuICAgICAgICAgICAgfSAvLyBlbHNlIGNvbnRpbnVlIHRyYW5zbGF0aW9uIHdpdGggb3JpZ2luYWwvbm9uQ29udGV4dCBrZXlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZWVkc1BsdXJhbChvcHRpb25zLCBsbmdzWzBdKSkge1xuICAgICAgICAgICAgb3B0aW9uV2l0aG91dENvdW50ID0gZi5leHRlbmQoeyBsbmdzOiBbbG5nc1swXV19LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25XaXRob3V0Q291bnQuY291bnQ7XG4gICAgICAgICAgICBvcHRpb25XaXRob3V0Q291bnQuX29yaWdMbmcgPSBvcHRpb25XaXRob3V0Q291bnQuX29yaWdMbmcgfHwgb3B0aW9uV2l0aG91dENvdW50LmxuZyB8fCBsbmdzWzBdO1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbldpdGhvdXRDb3VudC5sbmc7XG4gICAgICAgICAgICBvcHRpb25XaXRob3V0Q291bnQuZGVmYXVsdFZhbHVlID0gby5wbHVyYWxOb3RGb3VuZDtcblxuICAgICAgICAgICAgdmFyIHBsdXJhbEtleTtcbiAgICAgICAgICAgIGlmICghcGx1cmFsRXh0ZW5zaW9ucy5uZWVkc1BsdXJhbChsbmdzWzBdLCBvcHRpb25zLmNvdW50KSkge1xuICAgICAgICAgICAgICAgIHBsdXJhbEtleSA9IG5zICsgby5uc3NlcGFyYXRvciArIGtleTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGx1cmFsS2V5ID0gbnMgKyBvLm5zc2VwYXJhdG9yICsga2V5ICsgby5wbHVyYWxTdWZmaXg7XG4gICAgICAgICAgICAgICAgdmFyIHBsdXJhbEV4dGVuc2lvbiA9IHBsdXJhbEV4dGVuc2lvbnMuZ2V0KGxuZ3NbMF0sIG9wdGlvbnMuY291bnQpO1xuICAgICAgICAgICAgICAgIGlmIChwbHVyYWxFeHRlbnNpb24gPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBwbHVyYWxLZXkgPSBwbHVyYWxLZXkgKyAnXycgKyBwbHVyYWxFeHRlbnNpb247XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwbHVyYWxFeHRlbnNpb24gPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGx1cmFsS2V5ID0gbnMgKyBvLm5zc2VwYXJhdG9yICsga2V5OyAvLyBzaW5ndWxhclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJhbnNsYXRlZCA9IHRyYW5zbGF0ZShwbHVyYWxLZXksIG9wdGlvbldpdGhvdXRDb3VudCk7XG5cbiAgICAgICAgICAgIGlmICh0cmFuc2xhdGVkICE9IG8ucGx1cmFsTm90Rm91bmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwbHlSZXBsYWNlbWVudCh0cmFuc2xhdGVkLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiBvcHRpb25zLmNvdW50LFxuICAgICAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uUHJlZml4OiBvcHRpb25zLmludGVycG9sYXRpb25QcmVmaXgsXG4gICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRpb25TdWZmaXg6IG9wdGlvbnMuaW50ZXJwb2xhdGlvblN1ZmZpeFxuICAgICAgICAgICAgICAgIH0pOyAvLyBhcHBseSByZXBsYWNlbWVudCBmb3IgY291bnQgb25seVxuICAgICAgICAgICAgfSBlbHNlIGlmIChsbmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgZmFpbGVkIGxuZ1xuICAgICAgICAgICAgICAgIHZhciBjbG9uZSA9IGxuZ3Muc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBjbG9uZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBmLmV4dGVuZChvcHRpb25zLCB7IGxuZ3M6IGNsb25lIH0pO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuX29yaWdMbmcgPSBvcHRpb25XaXRob3V0Q291bnQuX29yaWdMbmc7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMubG5nO1xuICAgICAgICAgICAgICAgIC8vIHJldHJ5IHdpdGggZmFsbGJhY2tzXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlZCA9IHRyYW5zbGF0ZShucyArIG8ubnNzZXBhcmF0b3IgKyBrZXksIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc2xhdGVkICE9IG8ucGx1cmFsTm90Rm91bmQpIHJldHVybiB0cmFuc2xhdGVkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25XaXRob3V0Q291bnQubG5nID0gb3B0aW9uV2l0aG91dENvdW50Ll9vcmlnTG5nO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25XaXRob3V0Q291bnQuX29yaWdMbmc7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlZCA9IHRyYW5zbGF0ZShucyArIG8ubnNzZXBhcmF0b3IgKyBrZXksIG9wdGlvbldpdGhvdXRDb3VudCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwbHlSZXBsYWNlbWVudCh0cmFuc2xhdGVkLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiBvcHRpb25zLmNvdW50LFxuICAgICAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uUHJlZml4OiBvcHRpb25zLmludGVycG9sYXRpb25QcmVmaXgsXG4gICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRpb25TdWZmaXg6IG9wdGlvbnMuaW50ZXJwb2xhdGlvblN1ZmZpeFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5lZWRzSW5kZWZpbml0ZUFydGljbGUob3B0aW9ucykpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zV2l0aG91dEluZGVmID0gZi5leHRlbmQoe30sIG9wdGlvbnMpO1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnNXaXRob3V0SW5kZWYuaW5kZWZpbml0ZV9hcnRpY2xlO1xuICAgICAgICAgICAgb3B0aW9uc1dpdGhvdXRJbmRlZi5kZWZhdWx0VmFsdWUgPSBvLmluZGVmaW5pdGVOb3RGb3VuZDtcbiAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjb3VudCwgd2Ugd2FudCB0aGUgaW5kZWZpbml0ZSwgaWYgd2UgZG8gaGF2ZSBhIGNvdW50LCBhbmQgbmVlZHNQbHVyYWwgaXMgZmFsc2VcbiAgICAgICAgICAgIHZhciBpbmRlZmluaXRlS2V5ID0gbnMgKyBvLm5zc2VwYXJhdG9yICsga2V5ICsgKCgob3B0aW9ucy5jb3VudCAmJiAhbmVlZHNQbHVyYWwob3B0aW9ucywgbG5nc1swXSkpIHx8ICFvcHRpb25zLmNvdW50KSA/IG8uaW5kZWZpbml0ZVN1ZmZpeCA6IFwiXCIpO1xuICAgICAgICAgICAgdHJhbnNsYXRlZCA9IHRyYW5zbGF0ZShpbmRlZmluaXRlS2V5LCBvcHRpb25zV2l0aG91dEluZGVmKTtcbiAgICAgICAgICAgIGlmICh0cmFuc2xhdGVkICE9IG8uaW5kZWZpbml0ZU5vdEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zbGF0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZm91bmQ7XG4gICAgICAgIHZhciBrZXlzID0ga2V5LnNwbGl0KG8ua2V5c2VwYXJhdG9yKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICBpZiAoZm91bmQgIT09IHVuZGVmaW5lZCkgYnJlYWs7XG5cbiAgICAgICAgICAgIHZhciBsID0gbG5nc1tpXTtcblxuICAgICAgICAgICAgdmFyIHggPSAwO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gcmVzU3RvcmVbbF0gJiYgcmVzU3RvcmVbbF1bbnNdO1xuICAgICAgICAgICAgd2hpbGUgKGtleXNbeF0pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICYmIHZhbHVlW2tleXNbeF1dO1xuICAgICAgICAgICAgICAgIHgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlVHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYXBwbHlSZXBsYWNlbWVudCh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYXBwbHlSZXVzZSh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVR5cGUgPT09ICdbb2JqZWN0IEFycmF5XScgJiYgIW8ucmV0dXJuT2JqZWN0VHJlZXMgJiYgIW9wdGlvbnMucmV0dXJuT2JqZWN0VHJlZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhcHBseVJlcGxhY2VtZW50KHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhcHBseVJldXNlKHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBudWxsICYmIG8uZmFsbGJhY2tPbk51bGwgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW8ucmV0dXJuT2JqZWN0VHJlZXMgJiYgIW9wdGlvbnMucmV0dXJuT2JqZWN0VHJlZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLm9iamVjdFRyZWVLZXlIYW5kbGVyICYmIHR5cGVvZiBvLm9iamVjdFRyZWVLZXlIYW5kbGVyID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG8ub2JqZWN0VHJlZUtleUhhbmRsZXIoa2V5LCB2YWx1ZSwgbCwgbnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICdrZXkgXFwnJyArIG5zICsgJzonICsga2V5ICsgJyAoJyArIGwgKyAnKVxcJyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JldHVybmVkIGFuIG9iamVjdCBpbnN0ZWFkIG9mIHN0cmluZy4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYubG9nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVR5cGUgIT09ICdbb2JqZWN0IE51bWJlcl0nICYmIHZhbHVlVHlwZSAhPT0gJ1tvYmplY3QgRnVuY3Rpb25dJyAmJiB2YWx1ZVR5cGUgIT09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29weSA9ICh2YWx1ZVR5cGUgPT09ICdbb2JqZWN0IEFycmF5XScpID8gW10gOiB7fTsgLy8gYXBwbHkgY2hpbGQgdHJhbnNsYXRpb24gb24gYSBjb3B5XG4gICAgICAgICAgICAgICAgICAgICAgICBmLmVhY2godmFsdWUsIGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5W21dID0gX3RyYW5zbGF0ZShucyArIG8ubnNzZXBhcmF0b3IgKyBrZXkgKyBvLmtleXNlcGFyYXRvciArIG0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvcHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS50cmltKCkgPT09ICcnICYmIG8uZmFsbGJhY2tPbkVtcHR5ID09PSB0cnVlKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgIGZvdW5kID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm91bmQgPT09IHVuZGVmaW5lZCAmJiAhb3B0aW9ucy5pc0ZhbGxiYWNrTG9va3VwICYmIChvLmZhbGxiYWNrVG9EZWZhdWx0TlMgPT09IHRydWUgfHwgKG8uZmFsbGJhY2tOUyAmJiBvLmZhbGxiYWNrTlMubGVuZ3RoID4gMCkpKSB7XG4gICAgICAgICAgICAvLyBzZXQgZmxhZyBmb3IgZmFsbGJhY2sgbG9va3VwIC0gYXZvaWQgcmVjdXJzaW9uXG4gICAgICAgICAgICBvcHRpb25zLmlzRmFsbGJhY2tMb29rdXAgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoby5mYWxsYmFja05TLmxlbmd0aCkge1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IDAsIGxlblkgPSBvLmZhbGxiYWNrTlMubGVuZ3RoOyB5IDwgbGVuWTsgeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gX2ZpbmQoby5mYWxsYmFja05TW3ldICsgby5uc3NlcGFyYXRvciArIGtleSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kIHx8IChmb3VuZD09PVwiXCIgJiYgby5mYWxsYmFja09uRW1wdHkgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogY29tcGFyZSB2YWx1ZSB3aXRob3V0IG5hbWVzcGFjZSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZvdW5kVmFsdWUgPSBmb3VuZC5pbmRleE9mKG8ubnNzZXBhcmF0b3IpID4gLTEgPyBmb3VuZC5zcGxpdChvLm5zc2VwYXJhdG9yKVsxXSA6IGZvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICwgbm90Rm91bmRWYWx1ZSA9IG5vdEZvdW5kLmluZGV4T2Yoby5uc3NlcGFyYXRvcikgPiAtMSA/IG5vdEZvdW5kLnNwbGl0KG8ubnNzZXBhcmF0b3IpWzFdIDogbm90Rm91bmQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZFZhbHVlICE9PSBub3RGb3VuZFZhbHVlKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm91bmQgPSBfZmluZChrZXksIG9wdGlvbnMpOyAvLyBmYWxsYmFjayB0byBkZWZhdWx0IE5TXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zLmlzRmFsbGJhY2tMb29rdXAgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGV0ZWN0TGFuZ3VhZ2UoKSB7XG4gICAgICAgIHZhciBkZXRlY3RlZExuZztcbiAgICAgICAgdmFyIHdoaXRlbGlzdCA9IG8ubG5nV2hpdGVsaXN0IHx8IFtdO1xuICAgICAgICB2YXIgdXNlckxuZ0Nob2ljZXMgPSBbXTtcblxuICAgICAgICAvLyBnZXQgZnJvbSBxc1xuICAgICAgICB2YXIgcXNQYXJtID0gW107XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBxdWVyeSA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSBxdWVyeS5zcGxpdCgnJicpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxwYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IHBhcmFtc1tpXS5pbmRleE9mKCc9Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gcGFyYW1zW2ldLnN1YnN0cmluZygwLHBvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09IG8uZGV0ZWN0TG5nUVMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyTG5nQ2hvaWNlcy5wdXNoKHBhcmFtc1tpXS5zdWJzdHJpbmcocG9zKzEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgZnJvbSBjb29raWVcbiAgICAgICAgaWYgKG8udXNlQ29va2llICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHZhciBjID0gZi5jb29raWUucmVhZChvLmNvb2tpZU5hbWUpO1xuICAgICAgICAgICAgaWYgKGMpIHVzZXJMbmdDaG9pY2VzLnB1c2goYyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgZnJvbSBsb2NhbFN0b3JhZ2VcbiAgICAgICAgaWYgKG8uZGV0ZWN0TG5nRnJvbUxvY2FsU3RvcmFnZSAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubG9jYWxTdG9yYWdlKSB7XG4gICAgICAgICAgICB1c2VyTG5nQ2hvaWNlcy5wdXNoKGYubG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2kxOG5leHRfbG5nJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IGZyb20gbmF2aWdhdG9yXG4gICAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKG5hdmlnYXRvci5sYW5ndWFnZXMpIHsgLy8gY2hyb21lIG9ubHk7IG5vdCBhbiBhcnJheSwgc28gY2FuJ3QgdXNlIC5wdXNoLmFwcGx5IGluc3RlYWQgb2YgaXRlcmF0aW5nXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wO2k8bmF2aWdhdG9yLmxhbmd1YWdlcy5sZW5ndGg7aSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZXJMbmdDaG9pY2VzLnB1c2gobmF2aWdhdG9yLmxhbmd1YWdlc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hdmlnYXRvci51c2VyTGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgICAgICB1c2VyTG5nQ2hvaWNlcy5wdXNoKG5hdmlnYXRvci51c2VyTGFuZ3VhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hdmlnYXRvci5sYW5ndWFnZSkge1xuICAgICAgICAgICAgICAgIHVzZXJMbmdDaG9pY2VzLnB1c2gobmF2aWdhdG9yLmxhbmd1YWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDtpPHVzZXJMbmdDaG9pY2VzLmxlbmd0aDtpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbG5nID0gdXNlckxuZ0Nob2ljZXNbaV07XG5cbiAgICAgICAgICAgICAgICBpZiAobG5nLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IGxuZy5zcGxpdCgnLScpO1xuICAgICAgICAgICAgICAgICAgICBsbmcgPSBvLmxvd2VyQ2FzZUxuZyA/XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0c1swXS50b0xvd2VyQ2FzZSgpICsgICctJyArIHBhcnRzWzFdLnRvTG93ZXJDYXNlKCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHNbMF0udG9Mb3dlckNhc2UoKSArICAnLScgKyBwYXJ0c1sxXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh3aGl0ZWxpc3QubGVuZ3RoID09PSAwIHx8IHdoaXRlbGlzdC5pbmRleE9mKGxuZykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBkZXRlY3RlZExuZyA9IGxuZztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuXG4gICAgICAgIC8vZmFsbGJhY2tcbiAgICAgICAgaWYgKCFkZXRlY3RlZExuZyl7XG4gICAgICAgICAgZGV0ZWN0ZWRMbmcgPSBvLmZhbGxiYWNrTG5nWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRldGVjdGVkTG5nO1xuICAgIH1cbiAgICAvLyBkZWZpbml0aW9uIGh0dHA6Ly90cmFuc2xhdGUuc291cmNlZm9yZ2UubmV0L3dpa2kvbDEwbi9wbHVyYWxmb3Jtc1xuXG4gICAgLyogW2NvZGUsIG5hbWUsIG51bWJlcnMsIHBsdXJhbHNUeXBlXSAqL1xuICAgIHZhciBfcnVsZXMgPSBbXG4gICAgICAgIFtcImFjaFwiLCBcIkFjaG9saVwiLCBbMSwyXSwgMV0sXG4gICAgICAgIFtcImFmXCIsIFwiQWZyaWthYW5zXCIsWzEsMl0sIDJdLFxuICAgICAgICBbXCJha1wiLCBcIkFrYW5cIiwgWzEsMl0sIDFdLFxuICAgICAgICBbXCJhbVwiLCBcIkFtaGFyaWNcIiwgWzEsMl0sIDFdLFxuICAgICAgICBbXCJhblwiLCBcIkFyYWdvbmVzZVwiLFsxLDJdLCAyXSxcbiAgICAgICAgW1wiYXJcIiwgXCJBcmFiaWNcIiwgWzAsMSwyLDMsMTEsMTAwXSw1XSxcbiAgICAgICAgW1wiYXJuXCIsIFwiTWFwdWR1bmd1blwiLFsxLDJdLCAxXSxcbiAgICAgICAgW1wiYXN0XCIsIFwiQXN0dXJpYW5cIiwgWzEsMl0sIDJdLFxuICAgICAgICBbXCJheVwiLCBcIkF5bWFyw6FcIiwgWzFdLCAzXSxcbiAgICAgICAgW1wiYXpcIiwgXCJBemVyYmFpamFuaVwiLFsxLDJdLDJdLFxuICAgICAgICBbXCJiZVwiLCBcIkJlbGFydXNpYW5cIixbMSwyLDVdLDRdLFxuICAgICAgICBbXCJiZ1wiLCBcIkJ1bGdhcmlhblwiLFsxLDJdLCAyXSxcbiAgICAgICAgW1wiYm5cIiwgXCJCZW5nYWxpXCIsIFsxLDJdLCAyXSxcbiAgICAgICAgW1wiYm9cIiwgXCJUaWJldGFuXCIsIFsxXSwgM10sXG4gICAgICAgIFtcImJyXCIsIFwiQnJldG9uXCIsIFsxLDJdLCAxXSxcbiAgICAgICAgW1wiYnNcIiwgXCJCb3NuaWFuXCIsIFsxLDIsNV0sNF0sXG4gICAgICAgIFtcImNhXCIsIFwiQ2F0YWxhblwiLCBbMSwyXSwgMl0sXG4gICAgICAgIFtcImNnZ1wiLCBcIkNoaWdhXCIsIFsxXSwgM10sXG4gICAgICAgIFtcImNzXCIsIFwiQ3plY2hcIiwgWzEsMiw1XSw2XSxcbiAgICAgICAgW1wiY3NiXCIsIFwiS2FzaHViaWFuXCIsWzEsMiw1XSw3XSxcbiAgICAgICAgW1wiY3lcIiwgXCJXZWxzaFwiLCBbMSwyLDMsOF0sOF0sXG4gICAgICAgIFtcImRhXCIsIFwiRGFuaXNoXCIsIFsxLDJdLCAyXSxcbiAgICAgICAgW1wiZGVcIiwgXCJHZXJtYW5cIiwgWzEsMl0sIDJdLFxuICAgICAgICBbXCJkZXZcIiwgXCJEZXZlbG9wbWVudCBGYWxsYmFja1wiLCBbMSwyXSwgMl0sXG4gICAgICAgIFtcImR6XCIsIFwiRHpvbmdraGFcIiwgWzFdLCAzXSxcbiAgICAgICAgW1wiZWxcIiwgXCJHcmVla1wiLCBbMSwyXSwgMl0sXG4gICAgICAgIFtcImVuXCIsIFwiRW5nbGlzaFwiLCBbMSwyXSwgMl0sXG4gICAgICAgIFtcImVvXCIsIFwiRXNwZXJhbnRvXCIsWzEsMl0sIDJdLFxuICAgICAgICBbXCJlc1wiLCBcIlNwYW5pc2hcIiwgWzEsMl0sIDJdLFxuICAgICAgICBbXCJlc19hclwiLFwiQXJnZW50aW5lYW4gU3BhbmlzaFwiLCBbMSwyXSwgMl0sXG4gICAgICAgIFtcImV0XCIsIFwiRXN0b25pYW5cIiwgWzEsMl0sIDJdLFxuICAgICAgICBbXCJldVwiLCBcIkJhc3F1ZVwiLCBbMSwyXSwgMl0sXG4gICAgICAgIFtcImZhXCIsIFwiUGVyc2lhblwiLCBbMV0sIDNdLFxuICAgICAgICBbXCJmaVwiLCBcIkZpbm5pc2hcIiwgWzEsMl0sIDJdLFxuICAgICAgICBbXCJmaWxcIiwgXCJGaWxpcGlub1wiLCBbMSwyXSwgMV0sXG4gICAgICAgIFtcImZvXCIsIFwiRmFyb2VzZVwiLCBbMSwyXSwgMl0sXG4gICAgICAgIFtcImZyXCIsIFwiRnJlbmNoXCIsIFsxLDJdLCA5XSxcbiAgICAgICAgW1wiZnVyXCIsIFwiRnJpdWxpYW5cIiwgWzEsMl0sIDJdLFxuICAgICAgICBbXCJmeVwiLCBcIkZyaXNpYW5cIiwgWzEsMl0sIDJdLFxuICAgICAgICBbXCJnYVwiLCBcIklyaXNoXCIsIFsxLDIsMyw3LDExXSwxMF0sXG4gICAgICAgIFtcImdkXCIsIFwiU2NvdHRpc2ggR2FlbGljXCIsWzEsMiwzLDIwXSwxMV0sXG4gICAgICAgIFtcImdsXCIsIFwiR2FsaWNpYW5cIiwgWzEsMl0sIDJdLFxuICAgICAgICBbXCJndVwiLCBcIkd1amFyYXRpXCIsIFsxLDJdLCAyXSxcbiAgICAgICAgW1wiZ3VuXCIsIFwiR3VuXCIsIFsxLDJdLCAxXSxcbiAgICAgICAgW1wiaGFcIiwgXCJIYXVzYVwiLCBbMSwyXSwgMl0sXG4gICAgICAgIFtcImhlXCIsIFwiSGVicmV3XCIsIFsxLDJdLCAyXSxcbiAgICAgICAgW1wiaGlcIiwgXCJIaW5kaVwiLCBbMSwyXSwgMl0sXG4gICAgICAgIFtcImhyXCIsIFwiQ3JvYXRpYW5cIiwgWzEsMiw1XSw0XSxcbiAgICAgICAgW1wiaHVcIiwgXCJIdW5nYXJpYW5cIixbMSwyXSwgMl0sXG4gICAgICAgIFtcImh5XCIsIFwiQXJtZW5pYW5cIiwgWzEsMl0sIDJdLFxuICAgICAgICBbXCJpYVwiLCBcIkludGVybGluZ3VhXCIsWzEsMl0sMl0sXG4gICAgICAgIFtcImlkXCIsIFwiSW5kb25lc2lhblwiLFsxXSwgM10sXG4gICAgICAgIFtcImlzXCIsIFwiSWNlbGFuZGljXCIsWzEsMl0sIDEyXSxcbiAgICAgICAgW1wiaXRcIiwgXCJJdGFsaWFuXCIsIFsxLDJdLCAyXSxcbiAgICAgICAgW1wiamFcIiwgXCJKYXBhbmVzZVwiLCBbMV0sIDNdLFxuICAgICAgICBbXCJqYm9cIiwgXCJMb2piYW5cIiwgWzFdLCAzXSxcbiAgICAgICAgW1wianZcIiwgXCJKYXZhbmVzZVwiLCBbMCwxXSwgMTNdLFxuICAgICAgICBbXCJrYVwiLCBcIkdlb3JnaWFuXCIsIFsxXSwgM10sXG4gICAgICAgIFtcImtrXCIsIFwiS2F6YWtoXCIsIFsxXSwgM10sXG4gICAgICAgIFtcImttXCIsIFwiS2htZXJcIiwgWzFdLCAzXSxcbiAgICAgICAgW1wia25cIiwgXCJLYW5uYWRhXCIsIFsxLDJdLCAyXSxcbiAgICAgICAgW1wia29cIiwgXCJLb3JlYW5cIiwgWzFdLCAzXSxcbiAgICAgICAgW1wia3VcIiwgXCJLdXJkaXNoXCIsIFsxLDJdLCAyXSxcbiAgICAgICAgW1wia3dcIiwgXCJDb3JuaXNoXCIsIFsxLDIsMyw0XSwxNF0sXG4gICAgICAgIFtcImt5XCIsIFwiS3lyZ3l6XCIsIFsxXSwgM10sXG4gICAgICAgIFtcImxiXCIsIFwiTGV0emVidXJnZXNjaFwiLFsxLDJdLDJdLFxuICAgICAgICBbXCJsblwiLCBcIkxpbmdhbGFcIiwgWzEsMl0sIDFdLFxuICAgICAgICBbXCJsb1wiLCBcIkxhb1wiLCBbMV0sIDNdLFxuICAgICAgICBbXCJsdFwiLCBcIkxpdGh1YW5pYW5cIixbMSwyLDEwXSwxNV0sXG4gICAgICAgIFtcImx2XCIsIFwiTGF0dmlhblwiLCBbMSwyLDBdLDE2XSxcbiAgICAgICAgW1wibWFpXCIsIFwiTWFpdGhpbGlcIiwgWzEsMl0sIDJdLFxuICAgICAgICBbXCJtZmVcIiwgXCJNYXVyaXRpYW4gQ3Jlb2xlXCIsWzEsMl0sMV0sXG4gICAgICAgIFtcIm1nXCIsIFwiTWFsYWdhc3lcIiwgWzEsMl0sIDFdLFxuICAgICAgICBbXCJtaVwiLCBcIk1hb3JpXCIsIFsxLDJdLCAxXSxcbiAgICAgICAgW1wibWtcIiwgXCJNYWNlZG9uaWFuXCIsWzEsMl0sMTddLFxuICAgICAgICBbXCJtbFwiLCBcIk1hbGF5YWxhbVwiLFsxLDJdLCAyXSxcbiAgICAgICAgW1wibW5cIiwgXCJNb25nb2xpYW5cIixbMSwyXSwgMl0sXG4gICAgICAgIFtcIm1ua1wiLCBcIk1hbmRpbmthXCIsIFswLDEsMl0sMThdLFxuICAgICAgICBbXCJtclwiLCBcIk1hcmF0aGlcIiwgWzEsMl0sIDJdLFxuICAgICAgICBbXCJtc1wiLCBcIk1hbGF5XCIsIFsxXSwgM10sXG4gICAgICAgIFtcIm10XCIsIFwiTWFsdGVzZVwiLCBbMSwyLDExLDIwXSwxOV0sXG4gICAgICAgIFtcIm5haFwiLCBcIk5haHVhdGxcIiwgWzEsMl0sIDJdLFxuICAgICAgICBbXCJuYXBcIiwgXCJOZWFwb2xpdGFuXCIsWzEsMl0sIDJdLFxuICAgICAgICBbXCJuYlwiLCBcIk5vcndlZ2lhbiBCb2ttYWxcIixbMSwyXSwyXSxcbiAgICAgICAgW1wibmVcIiwgXCJOZXBhbGlcIiwgWzEsMl0sIDJdLFxuICAgICAgICBbXCJubFwiLCBcIkR1dGNoXCIsIFsxLDJdLCAyXSxcbiAgICAgICAgW1wibm5cIiwgXCJOb3J3ZWdpYW4gTnlub3Jza1wiLFsxLDJdLDJdLFxuICAgICAgICBbXCJub1wiLCBcIk5vcndlZ2lhblwiLFsxLDJdLCAyXSxcbiAgICAgICAgW1wibnNvXCIsIFwiTm9ydGhlcm4gU290aG9cIixbMSwyXSwyXSxcbiAgICAgICAgW1wib2NcIiwgXCJPY2NpdGFuXCIsIFsxLDJdLCAxXSxcbiAgICAgICAgW1wib3JcIiwgXCJPcml5YVwiLCBbMiwxXSwgMl0sXG4gICAgICAgIFtcInBhXCIsIFwiUHVuamFiaVwiLCBbMSwyXSwgMl0sXG4gICAgICAgIFtcInBhcFwiLCBcIlBhcGlhbWVudG9cIixbMSwyXSwgMl0sXG4gICAgICAgIFtcInBsXCIsIFwiUG9saXNoXCIsIFsxLDIsNV0sN10sXG4gICAgICAgIFtcInBtc1wiLCBcIlBpZW1vbnRlc2VcIixbMSwyXSwgMl0sXG4gICAgICAgIFtcInBzXCIsIFwiUGFzaHRvXCIsIFsxLDJdLCAyXSxcbiAgICAgICAgW1wicHRcIiwgXCJQb3J0dWd1ZXNlXCIsWzEsMl0sIDJdLFxuICAgICAgICBbXCJwdF9iclwiLFwiQnJhemlsaWFuIFBvcnR1Z3Vlc2VcIixbMSwyXSwgMl0sXG4gICAgICAgIFtcInJtXCIsIFwiUm9tYW5zaFwiLCBbMSwyXSwgMl0sXG4gICAgICAgIFtcInJvXCIsIFwiUm9tYW5pYW5cIiwgWzEsMiwyMF0sMjBdLFxuICAgICAgICBbXCJydVwiLCBcIlJ1c3NpYW5cIiwgWzEsMiw1XSw0XSxcbiAgICAgICAgW1wic2FoXCIsIFwiWWFrdXRcIiwgWzFdLCAzXSxcbiAgICAgICAgW1wic2NvXCIsIFwiU2NvdHNcIiwgWzEsMl0sIDJdLFxuICAgICAgICBbXCJzZVwiLCBcIk5vcnRoZXJuIFNhbWlcIixbMSwyXSwgMl0sXG4gICAgICAgIFtcInNpXCIsIFwiU2luaGFsYVwiLCBbMSwyXSwgMl0sXG4gICAgICAgIFtcInNrXCIsIFwiU2xvdmFrXCIsIFsxLDIsNV0sNl0sXG4gICAgICAgIFtcInNsXCIsIFwiU2xvdmVuaWFuXCIsWzUsMSwyLDNdLDIxXSxcbiAgICAgICAgW1wic29cIiwgXCJTb21hbGlcIiwgWzEsMl0sIDJdLFxuICAgICAgICBbXCJzb25cIiwgXCJTb25naGF5XCIsIFsxLDJdLCAyXSxcbiAgICAgICAgW1wic3FcIiwgXCJBbGJhbmlhblwiLCBbMSwyXSwgMl0sXG4gICAgICAgIFtcInNyXCIsIFwiU2VyYmlhblwiLCBbMSwyLDVdLDRdLFxuICAgICAgICBbXCJzdVwiLCBcIlN1bmRhbmVzZVwiLFsxXSwgM10sXG4gICAgICAgIFtcInN2XCIsIFwiU3dlZGlzaFwiLCBbMSwyXSwgMl0sXG4gICAgICAgIFtcInN3XCIsIFwiU3dhaGlsaVwiLCBbMSwyXSwgMl0sXG4gICAgICAgIFtcInRhXCIsIFwiVGFtaWxcIiwgWzEsMl0sIDJdLFxuICAgICAgICBbXCJ0ZVwiLCBcIlRlbHVndVwiLCBbMSwyXSwgMl0sXG4gICAgICAgIFtcInRnXCIsIFwiVGFqaWtcIiwgWzEsMl0sIDFdLFxuICAgICAgICBbXCJ0aFwiLCBcIlRoYWlcIiwgWzFdLCAzXSxcbiAgICAgICAgW1widGlcIiwgXCJUaWdyaW55YVwiLCBbMSwyXSwgMV0sXG4gICAgICAgIFtcInRrXCIsIFwiVHVya21lblwiLCBbMSwyXSwgMl0sXG4gICAgICAgIFtcInRyXCIsIFwiVHVya2lzaFwiLCBbMSwyXSwgMV0sXG4gICAgICAgIFtcInR0XCIsIFwiVGF0YXJcIiwgWzFdLCAzXSxcbiAgICAgICAgW1widWdcIiwgXCJVeWdodXJcIiwgWzFdLCAzXSxcbiAgICAgICAgW1widWtcIiwgXCJVa3JhaW5pYW5cIixbMSwyLDVdLDRdLFxuICAgICAgICBbXCJ1clwiLCBcIlVyZHVcIiwgWzEsMl0sIDJdLFxuICAgICAgICBbXCJ1elwiLCBcIlV6YmVrXCIsIFsxLDJdLCAxXSxcbiAgICAgICAgW1widmlcIiwgXCJWaWV0bmFtZXNlXCIsWzFdLCAzXSxcbiAgICAgICAgW1wid2FcIiwgXCJXYWxsb29uXCIsIFsxLDJdLCAxXSxcbiAgICAgICAgW1wid29cIiwgXCJXb2xvZlwiLCBbMV0sIDNdLFxuICAgICAgICBbXCJ5b1wiLCBcIllvcnViYVwiLCBbMSwyXSwgMl0sXG4gICAgICAgIFtcInpoXCIsIFwiQ2hpbmVzZVwiLCBbMV0sIDNdXG4gICAgXTtcblxuICAgIHZhciBfcnVsZXNQbHVyYWxzVHlwZXMgPSB7XG4gICAgICAgIDE6IGZ1bmN0aW9uKG4pIHtyZXR1cm4gTnVtYmVyKG4gPiAxKTt9LFxuICAgICAgICAyOiBmdW5jdGlvbihuKSB7cmV0dXJuIE51bWJlcihuICE9IDEpO30sXG4gICAgICAgIDM6IGZ1bmN0aW9uKG4pIHtyZXR1cm4gMDt9LFxuICAgICAgICA0OiBmdW5jdGlvbihuKSB7cmV0dXJuIE51bWJlcihuJTEwPT0xICYmIG4lMTAwIT0xMSA/IDAgOiBuJTEwPj0yICYmIG4lMTA8PTQgJiYgKG4lMTAwPDEwIHx8IG4lMTAwPj0yMCkgPyAxIDogMik7fSxcbiAgICAgICAgNTogZnVuY3Rpb24obikge3JldHVybiBOdW1iZXIobj09PTAgPyAwIDogbj09MSA/IDEgOiBuPT0yID8gMiA6IG4lMTAwPj0zICYmIG4lMTAwPD0xMCA/IDMgOiBuJTEwMD49MTEgPyA0IDogNSk7fSxcbiAgICAgICAgNjogZnVuY3Rpb24obikge3JldHVybiBOdW1iZXIoKG49PTEpID8gMCA6IChuPj0yICYmIG48PTQpID8gMSA6IDIpO30sXG4gICAgICAgIDc6IGZ1bmN0aW9uKG4pIHtyZXR1cm4gTnVtYmVyKG49PTEgPyAwIDogbiUxMD49MiAmJiBuJTEwPD00ICYmIChuJTEwMDwxMCB8fCBuJTEwMD49MjApID8gMSA6IDIpO30sXG4gICAgICAgIDg6IGZ1bmN0aW9uKG4pIHtyZXR1cm4gTnVtYmVyKChuPT0xKSA/IDAgOiAobj09MikgPyAxIDogKG4gIT0gOCAmJiBuICE9IDExKSA/IDIgOiAzKTt9LFxuICAgICAgICA5OiBmdW5jdGlvbihuKSB7cmV0dXJuIE51bWJlcihuID49IDIpO30sXG4gICAgICAgIDEwOiBmdW5jdGlvbihuKSB7cmV0dXJuIE51bWJlcihuPT0xID8gMCA6IG49PTIgPyAxIDogbjw3ID8gMiA6IG48MTEgPyAzIDogNCkgO30sXG4gICAgICAgIDExOiBmdW5jdGlvbihuKSB7cmV0dXJuIE51bWJlcigobj09MSB8fCBuPT0xMSkgPyAwIDogKG49PTIgfHwgbj09MTIpID8gMSA6IChuID4gMiAmJiBuIDwgMjApID8gMiA6IDMpO30sXG4gICAgICAgIDEyOiBmdW5jdGlvbihuKSB7cmV0dXJuIE51bWJlcihuJTEwIT0xIHx8IG4lMTAwPT0xMSk7fSxcbiAgICAgICAgMTM6IGZ1bmN0aW9uKG4pIHtyZXR1cm4gTnVtYmVyKG4gIT09IDApO30sXG4gICAgICAgIDE0OiBmdW5jdGlvbihuKSB7cmV0dXJuIE51bWJlcigobj09MSkgPyAwIDogKG49PTIpID8gMSA6IChuID09IDMpID8gMiA6IDMpO30sXG4gICAgICAgIDE1OiBmdW5jdGlvbihuKSB7cmV0dXJuIE51bWJlcihuJTEwPT0xICYmIG4lMTAwIT0xMSA/IDAgOiBuJTEwPj0yICYmIChuJTEwMDwxMCB8fCBuJTEwMD49MjApID8gMSA6IDIpO30sXG4gICAgICAgIDE2OiBmdW5jdGlvbihuKSB7cmV0dXJuIE51bWJlcihuJTEwPT0xICYmIG4lMTAwIT0xMSA/IDAgOiBuICE9PSAwID8gMSA6IDIpO30sXG4gICAgICAgIDE3OiBmdW5jdGlvbihuKSB7cmV0dXJuIE51bWJlcihuPT0xIHx8IG4lMTA9PTEgPyAwIDogMSk7fSxcbiAgICAgICAgMTg6IGZ1bmN0aW9uKG4pIHtyZXR1cm4gTnVtYmVyKDAgPyAwIDogbj09MSA/IDEgOiAyKTt9LFxuICAgICAgICAxOTogZnVuY3Rpb24obikge3JldHVybiBOdW1iZXIobj09MSA/IDAgOiBuPT09MCB8fCAoIG4lMTAwPjEgJiYgbiUxMDA8MTEpID8gMSA6IChuJTEwMD4xMCAmJiBuJTEwMDwyMCApID8gMiA6IDMpO30sXG4gICAgICAgIDIwOiBmdW5jdGlvbihuKSB7cmV0dXJuIE51bWJlcihuPT0xID8gMCA6IChuPT09MCB8fCAobiUxMDAgPiAwICYmIG4lMTAwIDwgMjApKSA/IDEgOiAyKTt9LFxuICAgICAgICAyMTogZnVuY3Rpb24obikge3JldHVybiBOdW1iZXIobiUxMDA9PTEgPyAxIDogbiUxMDA9PTIgPyAyIDogbiUxMDA9PTMgfHwgbiUxMDA9PTQgPyAzIDogMCk7IH1cbiAgICB9O1xuXG4gICAgdmFyIHBsdXJhbEV4dGVuc2lvbnMgPSB7XG5cbiAgICAgICAgcnVsZXM6IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbCwgcnVsZXMgPSB7fTtcbiAgICAgICAgICAgIGZvciAobD1fcnVsZXMubGVuZ3RoOyBsLS0gOykge1xuICAgICAgICAgICAgICAgIHJ1bGVzW19ydWxlc1tsXVswXV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IF9ydWxlc1tsXVsxXSxcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyczogX3J1bGVzW2xdWzJdLFxuICAgICAgICAgICAgICAgICAgICBwbHVyYWxzOiBfcnVsZXNQbHVyYWxzVHlwZXNbX3J1bGVzW2xdWzNdXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydWxlcztcbiAgICAgICAgfSgpKSxcblxuICAgICAgICAvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBwbHVyYWxFeHRlbnNpb25zXG4gICAgICAgIGFkZFJ1bGU6IGZ1bmN0aW9uKGxuZywgb2JqKSB7XG4gICAgICAgICAgICBwbHVyYWxFeHRlbnNpb25zLnJ1bGVzW2xuZ10gPSBvYmo7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0Q3VycmVudExuZzogZnVuY3Rpb24obG5nKSB7XG4gICAgICAgICAgICBpZiAoIXBsdXJhbEV4dGVuc2lvbnMuY3VycmVudFJ1bGUgfHwgcGx1cmFsRXh0ZW5zaW9ucy5jdXJyZW50UnVsZS5sbmcgIT09IGxuZykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IGxuZy5zcGxpdCgnLScpO1xuXG4gICAgICAgICAgICAgICAgcGx1cmFsRXh0ZW5zaW9ucy5jdXJyZW50UnVsZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbG5nOiBsbmcsXG4gICAgICAgICAgICAgICAgICAgIHJ1bGU6IHBsdXJhbEV4dGVuc2lvbnMucnVsZXNbcGFydHNbMF1dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBuZWVkc1BsdXJhbDogZnVuY3Rpb24obG5nLCBjb3VudCkge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gbG5nLnNwbGl0KCctJyk7XG5cbiAgICAgICAgICAgIHZhciBleHQ7XG4gICAgICAgICAgICBpZiAocGx1cmFsRXh0ZW5zaW9ucy5jdXJyZW50UnVsZSAmJiBwbHVyYWxFeHRlbnNpb25zLmN1cnJlbnRSdWxlLmxuZyA9PT0gbG5nKSB7XG4gICAgICAgICAgICAgICAgZXh0ID0gcGx1cmFsRXh0ZW5zaW9ucy5jdXJyZW50UnVsZS5ydWxlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHQgPSBwbHVyYWxFeHRlbnNpb25zLnJ1bGVzW3BhcnRzW2YuZ2V0Q291bnR5SW5kZXhPZkxuZyhsbmcpXV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleHQgJiYgZXh0Lm51bWJlcnMubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChsbmcsIGNvdW50KSAhPT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKGxuZywgY291bnQpIHtcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IGxuZy5zcGxpdCgnLScpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRSZXN1bHQobCwgYykge1xuICAgICAgICAgICAgICAgIHZhciBleHQ7XG4gICAgICAgICAgICAgICAgaWYgKHBsdXJhbEV4dGVuc2lvbnMuY3VycmVudFJ1bGUgJiYgcGx1cmFsRXh0ZW5zaW9ucy5jdXJyZW50UnVsZS5sbmcgPT09IGxuZykge1xuICAgICAgICAgICAgICAgICAgICBleHQgPSBwbHVyYWxFeHRlbnNpb25zLmN1cnJlbnRSdWxlLnJ1bGU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0ID0gcGx1cmFsRXh0ZW5zaW9ucy5ydWxlc1tsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dC5ub0Ficykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGV4dC5wbHVyYWxzKGMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGV4dC5wbHVyYWxzKE1hdGguYWJzKGMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBudW1iZXIgPSBleHQubnVtYmVyc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dC5udW1iZXJzLmxlbmd0aCA9PT0gMiAmJiBleHQubnVtYmVyc1swXSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bWJlciA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlciA9IC0xOyAvLyByZWd1bGFyIHBsdXJhbFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW1iZXIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXIgPSAxOyAvLyBzaW5ndWxhclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9Ly9jb25zb2xlLmxvZyhjb3VudCArICctJyArIG51bWJlcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMgPT09IDEgPyAnMScgOiAnLTEnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGdldFJlc3VsdChwYXJ0c1tmLmdldENvdW50eUluZGV4T2ZMbmcobG5nKV0sIGNvdW50KTtcbiAgICAgICAgfVxuXG4gICAgfTtcbiAgICB2YXIgcG9zdFByb2Nlc3NvcnMgPSB7fTtcbiAgICB2YXIgYWRkUG9zdFByb2Nlc3NvciA9IGZ1bmN0aW9uKG5hbWUsIGZjKSB7XG4gICAgICAgIHBvc3RQcm9jZXNzb3JzW25hbWVdID0gZmM7XG4gICAgfTtcbiAgICAvLyBzcHJpbnRmIHN1cHBvcnRcbiAgICB2YXIgc3ByaW50ZiA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gZ2V0X3R5cGUodmFyaWFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFyaWFibGUpLnNsaWNlKDgsIC0xKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHN0cl9yZXBlYXQoaW5wdXQsIG11bHRpcGxpZXIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIG91dHB1dCA9IFtdOyBtdWx0aXBsaWVyID4gMDsgb3V0cHV0Wy0tbXVsdGlwbGllcl0gPSBpbnB1dCkgey8qIGRvIG5vdGhpbmcgKi99XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0cl9mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghc3RyX2Zvcm1hdC5jYWNoZS5oYXNPd25Qcm9wZXJ0eShhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgICAgICAgICAgc3RyX2Zvcm1hdC5jYWNoZVthcmd1bWVudHNbMF1dID0gc3RyX2Zvcm1hdC5wYXJzZShhcmd1bWVudHNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0cl9mb3JtYXQuZm9ybWF0LmNhbGwobnVsbCwgc3RyX2Zvcm1hdC5jYWNoZVthcmd1bWVudHNbMF1dLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHN0cl9mb3JtYXQuZm9ybWF0ID0gZnVuY3Rpb24ocGFyc2VfdHJlZSwgYXJndikge1xuICAgICAgICAgICAgdmFyIGN1cnNvciA9IDEsIHRyZWVfbGVuZ3RoID0gcGFyc2VfdHJlZS5sZW5ndGgsIG5vZGVfdHlwZSA9ICcnLCBhcmcsIG91dHB1dCA9IFtdLCBpLCBrLCBtYXRjaCwgcGFkLCBwYWRfY2hhcmFjdGVyLCBwYWRfbGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRyZWVfbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBub2RlX3R5cGUgPSBnZXRfdHlwZShwYXJzZV90cmVlW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZV90eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChwYXJzZV90cmVlW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZV90eXBlID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gcGFyc2VfdHJlZVtpXTsgLy8gY29udmVuaWVuY2UgcHVycG9zZXMgb25seVxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hbMl0pIHsgLy8ga2V5d29yZCBhcmd1bWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJndltjdXJzb3JdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IG1hdGNoWzJdLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhcmcuaGFzT3duUHJvcGVydHkobWF0Y2hbMl1ba10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93KHNwcmludGYoJ1tzcHJpbnRmXSBwcm9wZXJ0eSBcIiVzXCIgZG9lcyBub3QgZXhpc3QnLCBtYXRjaFsyXVtrXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmdbbWF0Y2hbMl1ba11dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoWzFdKSB7IC8vIHBvc2l0aW9uYWwgYXJndW1lbnQgKGV4cGxpY2l0KVxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJndlttYXRjaFsxXV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7IC8vIHBvc2l0aW9uYWwgYXJndW1lbnQgKGltcGxpY2l0KVxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJndltjdXJzb3IrK107XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoL1tec10vLnRlc3QobWF0Y2hbOF0pICYmIChnZXRfdHlwZShhcmcpICE9ICdudW1iZXInKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3coc3ByaW50ZignW3NwcmludGZdIGV4cGVjdGluZyBudW1iZXIgYnV0IGZvdW5kICVzJywgZ2V0X3R5cGUoYXJnKSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobWF0Y2hbOF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2InOiBhcmcgPSBhcmcudG9TdHJpbmcoMik7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYyc6IGFyZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYXJnKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdkJzogYXJnID0gcGFyc2VJbnQoYXJnLCAxMCk7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZSc6IGFyZyA9IG1hdGNoWzddID8gYXJnLnRvRXhwb25lbnRpYWwobWF0Y2hbN10pIDogYXJnLnRvRXhwb25lbnRpYWwoKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmJzogYXJnID0gbWF0Y2hbN10gPyBwYXJzZUZsb2F0KGFyZykudG9GaXhlZChtYXRjaFs3XSkgOiBwYXJzZUZsb2F0KGFyZyk7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbyc6IGFyZyA9IGFyZy50b1N0cmluZyg4KTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzJzogYXJnID0gKChhcmcgPSBTdHJpbmcoYXJnKSkgJiYgbWF0Y2hbN10gPyBhcmcuc3Vic3RyaW5nKDAsIG1hdGNoWzddKSA6IGFyZyk7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndSc6IGFyZyA9IE1hdGguYWJzKGFyZyk7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAneCc6IGFyZyA9IGFyZy50b1N0cmluZygxNik7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnWCc6IGFyZyA9IGFyZy50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXJnID0gKC9bZGVmXS8udGVzdChtYXRjaFs4XSkgJiYgbWF0Y2hbM10gJiYgYXJnID49IDAgPyAnKycrIGFyZyA6IGFyZyk7XG4gICAgICAgICAgICAgICAgICAgIHBhZF9jaGFyYWN0ZXIgPSBtYXRjaFs0XSA/IG1hdGNoWzRdID09ICcwJyA/ICcwJyA6IG1hdGNoWzRdLmNoYXJBdCgxKSA6ICcgJztcbiAgICAgICAgICAgICAgICAgICAgcGFkX2xlbmd0aCA9IG1hdGNoWzZdIC0gU3RyaW5nKGFyZykubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBwYWQgPSBtYXRjaFs2XSA/IHN0cl9yZXBlYXQocGFkX2NoYXJhY3RlciwgcGFkX2xlbmd0aCkgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gobWF0Y2hbNV0gPyBhcmcgKyBwYWQgOiBwYWQgKyBhcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQuam9pbignJyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc3RyX2Zvcm1hdC5jYWNoZSA9IHt9O1xuXG4gICAgICAgIHN0cl9mb3JtYXQucGFyc2UgPSBmdW5jdGlvbihmbXQpIHtcbiAgICAgICAgICAgIHZhciBfZm10ID0gZm10LCBtYXRjaCA9IFtdLCBwYXJzZV90cmVlID0gW10sIGFyZ19uYW1lcyA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoX2ZtdCkge1xuICAgICAgICAgICAgICAgIGlmICgobWF0Y2ggPSAvXlteXFx4MjVdKy8uZXhlYyhfZm10KSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VfdHJlZS5wdXNoKG1hdGNoWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKG1hdGNoID0gL15cXHgyNXsyfS8uZXhlYyhfZm10KSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VfdHJlZS5wdXNoKCclJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChtYXRjaCA9IC9eXFx4MjUoPzooWzEtOV1cXGQqKVxcJHxcXCgoW15cXCldKylcXCkpPyhcXCspPygwfCdbXiRdKT8oLSk/KFxcZCspPyg/OlxcLihcXGQrKSk/KFtiLWZvc3V4WF0pLy5leGVjKF9mbXQpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ19uYW1lcyB8PSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkX2xpc3QgPSBbXSwgcmVwbGFjZW1lbnRfZmllbGQgPSBtYXRjaFsyXSwgZmllbGRfbWF0Y2ggPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZmllbGRfbWF0Y2ggPSAvXihbYS16X11bYS16X1xcZF0qKS9pLmV4ZWMocmVwbGFjZW1lbnRfZmllbGQpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkX2xpc3QucHVzaChmaWVsZF9tYXRjaFsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChyZXBsYWNlbWVudF9maWVsZCA9IHJlcGxhY2VtZW50X2ZpZWxkLnN1YnN0cmluZyhmaWVsZF9tYXRjaFswXS5sZW5ndGgpKSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChmaWVsZF9tYXRjaCA9IC9eXFwuKFthLXpfXVthLXpfXFxkXSopL2kuZXhlYyhyZXBsYWNlbWVudF9maWVsZCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZF9saXN0LnB1c2goZmllbGRfbWF0Y2hbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKChmaWVsZF9tYXRjaCA9IC9eXFxbKFxcZCspXFxdLy5leGVjKHJlcGxhY2VtZW50X2ZpZWxkKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkX2xpc3QucHVzaChmaWVsZF9tYXRjaFsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdygnW3NwcmludGZdIGh1aD8nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93KCdbc3ByaW50Zl0gaHVoPycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMl0gPSBmaWVsZF9saXN0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnX25hbWVzIHw9IDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ19uYW1lcyA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3coJ1tzcHJpbnRmXSBtaXhpbmcgcG9zaXRpb25hbCBhbmQgbmFtZWQgcGxhY2Vob2xkZXJzIGlzIG5vdCAoeWV0KSBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXJzZV90cmVlLnB1c2gobWF0Y2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3coJ1tzcHJpbnRmXSBodWg/Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9mbXQgPSBfZm10LnN1YnN0cmluZyhtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlX3RyZWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHN0cl9mb3JtYXQ7XG4gICAgfSkoKTtcblxuICAgIHZhciB2c3ByaW50ZiA9IGZ1bmN0aW9uKGZtdCwgYXJndikge1xuICAgICAgICBhcmd2LnVuc2hpZnQoZm10KTtcbiAgICAgICAgcmV0dXJuIHNwcmludGYuYXBwbHkobnVsbCwgYXJndik7XG4gICAgfTtcblxuICAgIGFkZFBvc3RQcm9jZXNzb3IoXCJzcHJpbnRmXCIsIGZ1bmN0aW9uKHZhbCwga2V5LCBvcHRzKSB7XG4gICAgICAgIGlmICghb3B0cy5zcHJpbnRmKSByZXR1cm4gdmFsO1xuXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KG9wdHMuc3ByaW50ZikgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgIHJldHVybiB2c3ByaW50Zih2YWwsIG9wdHMuc3ByaW50Zik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdHMuc3ByaW50ZiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBzcHJpbnRmKHZhbCwgb3B0cy5zcHJpbnRmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSk7XG4gICAgLy8gcHVibGljIGFwaSBpbnRlcmZhY2VcbiAgICBpMThuLmluaXQgPSBpbml0O1xuICAgIGkxOG4uc2V0TG5nID0gc2V0TG5nO1xuICAgIGkxOG4ucHJlbG9hZCA9IHByZWxvYWQ7XG4gICAgaTE4bi5hZGRSZXNvdXJjZUJ1bmRsZSA9IGFkZFJlc291cmNlQnVuZGxlO1xuICAgIGkxOG4uaGFzUmVzb3VyY2VCdW5kbGUgPSBoYXNSZXNvdXJjZUJ1bmRsZTtcbiAgICBpMThuLmdldFJlc291cmNlQnVuZGxlID0gZ2V0UmVzb3VyY2VCdW5kbGU7XG4gICAgaTE4bi5hZGRSZXNvdXJjZSA9IGFkZFJlc291cmNlO1xuICAgIGkxOG4uYWRkUmVzb3VyY2VzID0gYWRkUmVzb3VyY2VzO1xuICAgIGkxOG4ucmVtb3ZlUmVzb3VyY2VCdW5kbGUgPSByZW1vdmVSZXNvdXJjZUJ1bmRsZTtcbiAgICBpMThuLmxvYWROYW1lc3BhY2UgPSBsb2FkTmFtZXNwYWNlO1xuICAgIGkxOG4ubG9hZE5hbWVzcGFjZXMgPSBsb2FkTmFtZXNwYWNlcztcbiAgICBpMThuLnNldERlZmF1bHROYW1lc3BhY2UgPSBzZXREZWZhdWx0TmFtZXNwYWNlO1xuICAgIGkxOG4udCA9IHRyYW5zbGF0ZTtcbiAgICBpMThuLnRyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcbiAgICBpMThuLmV4aXN0cyA9IGV4aXN0cztcbiAgICBpMThuLmRldGVjdExhbmd1YWdlID0gZi5kZXRlY3RMYW5ndWFnZTtcbiAgICBpMThuLnBsdXJhbEV4dGVuc2lvbnMgPSBwbHVyYWxFeHRlbnNpb25zO1xuICAgIGkxOG4uc3luYyA9IHN5bmM7XG4gICAgaTE4bi5mdW5jdGlvbnMgPSBmO1xuICAgIGkxOG4ubG5nID0gbG5nO1xuICAgIGkxOG4uYWRkUG9zdFByb2Nlc3NvciA9IGFkZFBvc3RQcm9jZXNzb3I7XG4gICAgaTE4bi5hcHBseVJlcGxhY2VtZW50ID0gZi5hcHBseVJlcGxhY2VtZW50O1xuICAgIGkxOG4ub3B0aW9ucyA9IG87XG5cbn0pKHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGV4cG9ydHMpO1xuIiwiLyohIGpxdWVyeS5hdHdobyAtIHYwLjQuNyAtIDIwMTQtMDItMjJcbiogQ29weXJpZ2h0IChjKSAyMDE0IGNob3JkLmx1byA8Y2hvcmQubHVvQGdtYWlsLmNvbT47IFxuKiBob21lcGFnZTogaHR0cDovL2ljaG9yZC5naXRodWIuY29tL0F0LmpzIFxuKiBMaWNlbnNlZCBNSVRcbiovXG5cbihmdW5jdGlvbigpIHtcbiAgKGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICByZXR1cm4gZGVmaW5lKFsnanF1ZXJ5J10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFjdG9yeSh3aW5kb3cualF1ZXJ5KTtcbiAgICB9XG4gIH0pKGZ1bmN0aW9uKCQpIHtcblxudmFyICRDT05UQUlORVIsIEFwaSwgQXBwLCBBdHdobywgQ29udHJvbGxlciwgREVGQVVMVF9DQUxMQkFDS1MsIEtFWV9DT0RFLCBNb2RlbCwgVmlldyxcbiAgX19zbGljZSA9IFtdLnNsaWNlO1xuXG5BcHAgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIEFwcChpbnB1dG9yKSB7XG4gICAgdGhpcy5jdXJyZW50X2ZsYWcgPSBudWxsO1xuICAgIHRoaXMuY29udHJvbGxlcnMgPSB7fTtcbiAgICB0aGlzLmFsaWFzX21hcHMgPSB7fTtcbiAgICB0aGlzLiRpbnB1dG9yID0gJChpbnB1dG9yKTtcbiAgICB0aGlzLmxpc3RlbigpO1xuICB9XG5cbiAgQXBwLnByb3RvdHlwZS5jb250cm9sbGVyID0gZnVuY3Rpb24oYXQpIHtcbiAgICByZXR1cm4gdGhpcy5jb250cm9sbGVyc1t0aGlzLmFsaWFzX21hcHNbYXRdIHx8IGF0IHx8IHRoaXMuY3VycmVudF9mbGFnXTtcbiAgfTtcblxuICBBcHAucHJvdG90eXBlLnNldF9jb250ZXh0X2ZvciA9IGZ1bmN0aW9uKGF0KSB7XG4gICAgdGhpcy5jdXJyZW50X2ZsYWcgPSBhdDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBBcHAucHJvdG90eXBlLnJlZyA9IGZ1bmN0aW9uKGZsYWcsIHNldHRpbmcpIHtcbiAgICB2YXIgY29udHJvbGxlciwgX2Jhc2U7XG4gICAgY29udHJvbGxlciA9IChfYmFzZSA9IHRoaXMuY29udHJvbGxlcnMpW2ZsYWddIHx8IChfYmFzZVtmbGFnXSA9IG5ldyBDb250cm9sbGVyKHRoaXMsIGZsYWcpKTtcbiAgICBpZiAoc2V0dGluZy5hbGlhcykge1xuICAgICAgdGhpcy5hbGlhc19tYXBzW3NldHRpbmcuYWxpYXNdID0gZmxhZztcbiAgICB9XG4gICAgY29udHJvbGxlci5pbml0KHNldHRpbmcpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFwcC5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuJGlucHV0b3Iub24oJ2tleXVwLmF0d2hvSW5uZXInLCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5vbl9rZXl1cChlKTtcbiAgICAgIH07XG4gICAgfSkodGhpcykpLm9uKCdrZXlkb3duLmF0d2hvSW5uZXInLCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5vbl9rZXlkb3duKGUpO1xuICAgICAgfTtcbiAgICB9KSh0aGlzKSkub24oJ3Njcm9sbC5hdHdob0lubmVyJywgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgX3JlZjtcbiAgICAgICAgcmV0dXJuIChfcmVmID0gX3RoaXMuY29udHJvbGxlcigpKSAhPSBudWxsID8gX3JlZi52aWV3LmhpZGUoKSA6IHZvaWQgMDtcbiAgICAgIH07XG4gICAgfSkodGhpcykpLm9uKCdibHVyLmF0d2hvSW5uZXInLCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBjO1xuICAgICAgICBpZiAoYyA9IF90aGlzLmNvbnRyb2xsZXIoKSkge1xuICAgICAgICAgIHJldHVybiBjLnZpZXcuaGlkZShjLmdldF9vcHQoXCJkaXNwbGF5X3RpbWVvdXRcIikpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pKHRoaXMpKTtcbiAgfTtcblxuICBBcHAucHJvdG90eXBlLnNodXRkb3duID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGMsIF8sIF9yZWY7XG4gICAgX3JlZiA9IHRoaXMuY29udHJvbGxlcnM7XG4gICAgZm9yIChfIGluIF9yZWYpIHtcbiAgICAgIGMgPSBfcmVmW19dO1xuICAgICAgYy5kZXN0cm95KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiRpbnB1dG9yLm9mZignLmF0d2hvSW5uZXInKTtcbiAgfTtcblxuICBBcHAucHJvdG90eXBlLmRpc3BhdGNoID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICQubWFwKHRoaXMuY29udHJvbGxlcnMsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgaWYgKGMubG9va191cCgpKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnNldF9jb250ZXh0X2ZvcihjLmF0KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KSh0aGlzKSk7XG4gIH07XG5cbiAgQXBwLnByb3RvdHlwZS5vbl9rZXl1cCA9IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgX3JlZjtcbiAgICBzd2l0Y2ggKGUua2V5Q29kZSkge1xuICAgICAgY2FzZSBLRVlfQ09ERS5FU0M6XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKChfcmVmID0gdGhpcy5jb250cm9sbGVyKCkpICE9IG51bGwpIHtcbiAgICAgICAgICBfcmVmLnZpZXcuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBLRVlfQ09ERS5ET1dOOlxuICAgICAgY2FzZSBLRVlfQ09ERS5VUDpcbiAgICAgICAgJC5ub29wKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5kaXNwYXRjaCgpO1xuICAgIH1cbiAgfTtcblxuICBBcHAucHJvdG90eXBlLm9uX2tleWRvd24gPSBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHZpZXcsIF9yZWY7XG4gICAgdmlldyA9IChfcmVmID0gdGhpcy5jb250cm9sbGVyKCkpICE9IG51bGwgPyBfcmVmLnZpZXcgOiB2b2lkIDA7XG4gICAgaWYgKCEodmlldyAmJiB2aWV3LnZpc2libGUoKSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoIChlLmtleUNvZGUpIHtcbiAgICAgIGNhc2UgS0VZX0NPREUuRVNDOlxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZpZXcuaGlkZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgS0VZX0NPREUuVVA6XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmlldy5wcmV2KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBLRVlfQ09ERS5ET1dOOlxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZpZXcubmV4dCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgS0VZX0NPREUuVEFCOlxuICAgICAgY2FzZSBLRVlfQ09ERS5FTlRFUjpcbiAgICAgICAgaWYgKCF2aWV3LnZpc2libGUoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZpZXcuY2hvb3NlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgJC5ub29wKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBBcHA7XG5cbn0pKCk7XG5cbkNvbnRyb2xsZXIgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1dWlkLCBfdXVpZDtcblxuICBfdXVpZCA9IDA7XG5cbiAgdXVpZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfdXVpZCArPSAxO1xuICB9O1xuXG4gIGZ1bmN0aW9uIENvbnRyb2xsZXIoYXBwLCBhdCkge1xuICAgIHRoaXMuYXBwID0gYXBwO1xuICAgIHRoaXMuYXQgPSBhdDtcbiAgICB0aGlzLiRpbnB1dG9yID0gdGhpcy5hcHAuJGlucHV0b3I7XG4gICAgdGhpcy5vRG9jdW1lbnQgPSB0aGlzLiRpbnB1dG9yWzBdLm93bmVyRG9jdW1lbnQ7XG4gICAgdGhpcy5vV2luZG93ID0gdGhpcy5vRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgdGhpcy5vRG9jdW1lbnQucGFyZW50V2luZG93O1xuICAgIHRoaXMuaWQgPSB0aGlzLiRpbnB1dG9yWzBdLmlkIHx8IHV1aWQoKTtcbiAgICB0aGlzLnNldHRpbmcgPSBudWxsO1xuICAgIHRoaXMucXVlcnkgPSBudWxsO1xuICAgIHRoaXMucG9zID0gMDtcbiAgICB0aGlzLmN1cl9yZWN0ID0gbnVsbDtcbiAgICB0aGlzLnJhbmdlID0gbnVsbDtcbiAgICAkQ09OVEFJTkVSLmFwcGVuZCh0aGlzLiRlbCA9ICQoXCI8ZGl2IGlkPSdhdHdoby1ncm91bmQtXCIgKyB0aGlzLmlkICsgXCInPjwvZGl2PlwiKSk7XG4gICAgdGhpcy5tb2RlbCA9IG5ldyBNb2RlbCh0aGlzKTtcbiAgICB0aGlzLnZpZXcgPSBuZXcgVmlldyh0aGlzKTtcbiAgfVxuXG4gIENvbnRyb2xsZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihzZXR0aW5nKSB7XG4gICAgdGhpcy5zZXR0aW5nID0gJC5leHRlbmQoe30sIHRoaXMuc2V0dGluZyB8fCAkLmZuLmF0d2hvW1wiZGVmYXVsdFwiXSwgc2V0dGluZyk7XG4gICAgdGhpcy52aWV3LmluaXQoKTtcbiAgICByZXR1cm4gdGhpcy5tb2RlbC5yZWxvYWQodGhpcy5zZXR0aW5nLmRhdGEpO1xuICB9O1xuXG4gIENvbnRyb2xsZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ2JlZm9yZURlc3Ryb3knKTtcbiAgICB0aGlzLm1vZGVsLmRlc3Ryb3koKTtcbiAgICByZXR1cm4gdGhpcy52aWV3LmRlc3Ryb3koKTtcbiAgfTtcblxuICBDb250cm9sbGVyLnByb3RvdHlwZS5jYWxsX2RlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncywgZXJyb3IsIGZ1bmNfbmFtZTtcbiAgICBmdW5jX25hbWUgPSBhcmd1bWVudHNbMF0sIGFyZ3MgPSAyIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBfX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSA6IFtdO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gREVGQVVMVF9DQUxMQkFDS1NbZnVuY19uYW1lXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgIGVycm9yID0gX2Vycm9yO1xuICAgICAgcmV0dXJuICQuZXJyb3IoXCJcIiArIGVycm9yICsgXCIgT3IgbWF5YmUgQXQuanMgZG9lc24ndCBoYXZlIGZ1bmN0aW9uIFwiICsgZnVuY19uYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgQ29udHJvbGxlci5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uKG5hbWUsIGRhdGEpIHtcbiAgICB2YXIgYWxpYXMsIGV2ZW50X25hbWU7XG4gICAgaWYgKGRhdGEgPT0gbnVsbCkge1xuICAgICAgZGF0YSA9IFtdO1xuICAgIH1cbiAgICBkYXRhLnB1c2godGhpcyk7XG4gICAgYWxpYXMgPSB0aGlzLmdldF9vcHQoJ2FsaWFzJyk7XG4gICAgZXZlbnRfbmFtZSA9IGFsaWFzID8gXCJcIiArIG5hbWUgKyBcIi1cIiArIGFsaWFzICsgXCIuYXR3aG9cIiA6IFwiXCIgKyBuYW1lICsgXCIuYXR3aG9cIjtcbiAgICByZXR1cm4gdGhpcy4kaW5wdXRvci50cmlnZ2VyKGV2ZW50X25hbWUsIGRhdGEpO1xuICB9O1xuXG4gIENvbnRyb2xsZXIucHJvdG90eXBlLmNhbGxiYWNrcyA9IGZ1bmN0aW9uKGZ1bmNfbmFtZSkge1xuICAgIHJldHVybiB0aGlzLmdldF9vcHQoXCJjYWxsYmFja3NcIilbZnVuY19uYW1lXSB8fCBERUZBVUxUX0NBTExCQUNLU1tmdW5jX25hbWVdO1xuICB9O1xuXG4gIENvbnRyb2xsZXIucHJvdG90eXBlLmdldF9vcHQgPSBmdW5jdGlvbihhdCwgZGVmYXVsdF92YWx1ZSkge1xuICAgIHZhciBlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0aW5nW2F0XTtcbiAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgIGUgPSBfZXJyb3I7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgQ29udHJvbGxlci5wcm90b3R5cGUuY29udGVudCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLiRpbnB1dG9yLmlzKCd0ZXh0YXJlYSwgaW5wdXQnKSkge1xuICAgICAgcmV0dXJuIHRoaXMuJGlucHV0b3IudmFsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLiRpbnB1dG9yLnRleHQoKTtcbiAgICB9XG4gIH07XG5cbiAgQ29udHJvbGxlci5wcm90b3R5cGUuY2F0Y2hfcXVlcnkgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2FyZXRfcG9zLCBjb250ZW50LCBlbmQsIHF1ZXJ5LCBzdGFydCwgc3VidGV4dDtcbiAgICBjb250ZW50ID0gdGhpcy5jb250ZW50KCk7XG4gICAgY2FyZXRfcG9zID0gdGhpcy4kaW5wdXRvci5jYXJldCgncG9zJyk7XG4gICAgc3VidGV4dCA9IGNvbnRlbnQuc2xpY2UoMCwgY2FyZXRfcG9zKTtcbiAgICBxdWVyeSA9IHRoaXMuY2FsbGJhY2tzKFwibWF0Y2hlclwiKS5jYWxsKHRoaXMsIHRoaXMuYXQsIHN1YnRleHQsIHRoaXMuZ2V0X29wdCgnc3RhcnRfd2l0aF9zcGFjZScpKTtcbiAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSBcInN0cmluZ1wiICYmIHF1ZXJ5Lmxlbmd0aCA8PSB0aGlzLmdldF9vcHQoJ21heF9sZW4nLCAyMCkpIHtcbiAgICAgIHN0YXJ0ID0gY2FyZXRfcG9zIC0gcXVlcnkubGVuZ3RoO1xuICAgICAgZW5kID0gc3RhcnQgKyBxdWVyeS5sZW5ndGg7XG4gICAgICB0aGlzLnBvcyA9IHN0YXJ0O1xuICAgICAgcXVlcnkgPSB7XG4gICAgICAgICd0ZXh0JzogcXVlcnkudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgJ2hlYWRfcG9zJzogc3RhcnQsXG4gICAgICAgICdlbmRfcG9zJzogZW5kXG4gICAgICB9O1xuICAgICAgdGhpcy50cmlnZ2VyKFwibWF0Y2hlZFwiLCBbdGhpcy5hdCwgcXVlcnkudGV4dF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZpZXcuaGlkZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICB9O1xuXG4gIENvbnRyb2xsZXIucHJvdG90eXBlLnJlY3QgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYywgc2NhbGVfYm90dG9tO1xuICAgIGlmICghKGMgPSB0aGlzLiRpbnB1dG9yLmNhcmV0KCdvZmZzZXQnLCB0aGlzLnBvcyAtIDEpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4kaW5wdXRvci5hdHRyKCdjb250ZW50RWRpdGFibGUnKSA9PT0gJ3RydWUnKSB7XG4gICAgICBjID0gKHRoaXMuY3VyX3JlY3QgfHwgKHRoaXMuY3VyX3JlY3QgPSBjKSkgfHwgYztcbiAgICB9XG4gICAgc2NhbGVfYm90dG9tID0gZG9jdW1lbnQuc2VsZWN0aW9uID8gMCA6IDI7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IGMubGVmdCxcbiAgICAgIHRvcDogYy50b3AsXG4gICAgICBib3R0b206IGMudG9wICsgYy5oZWlnaHQgKyBzY2FsZV9ib3R0b21cbiAgICB9O1xuICB9O1xuXG4gIENvbnRyb2xsZXIucHJvdG90eXBlLnJlc2V0X3JlY3QgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy4kaW5wdXRvci5hdHRyKCdjb250ZW50RWRpdGFibGUnKSA9PT0gJ3RydWUnKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJfcmVjdCA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIENvbnRyb2xsZXIucHJvdG90eXBlLm1hcmtfcmFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy4kaW5wdXRvci5hdHRyKCdjb250ZW50RWRpdGFibGUnKSA9PT0gJ3RydWUnKSB7XG4gICAgICBpZiAodGhpcy5vV2luZG93LmdldFNlbGVjdGlvbikge1xuICAgICAgICB0aGlzLnJhbmdlID0gdGhpcy5vV2luZG93LmdldFNlbGVjdGlvbigpLmdldFJhbmdlQXQoMCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vRG9jdW1lbnQuc2VsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmllOF9yYW5nZSA9IHRoaXMub0RvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBDb250cm9sbGVyLnByb3RvdHlwZS5pbnNlcnRfY29udGVudF9mb3IgPSBmdW5jdGlvbigkbGkpIHtcbiAgICB2YXIgZGF0YSwgZGF0YV92YWx1ZSwgdHBsO1xuICAgIGRhdGFfdmFsdWUgPSAkbGkuZGF0YSgndmFsdWUnKTtcbiAgICB0cGwgPSB0aGlzLmdldF9vcHQoJ2luc2VydF90cGwnKTtcbiAgICBpZiAodGhpcy4kaW5wdXRvci5pcygndGV4dGFyZWEsIGlucHV0JykgfHwgIXRwbCkge1xuICAgICAgcmV0dXJuIGRhdGFfdmFsdWU7XG4gICAgfVxuICAgIGRhdGEgPSAkLmV4dGVuZCh7fSwgJGxpLmRhdGEoJ2l0ZW0tZGF0YScpLCB7XG4gICAgICAnYXR3aG8tZGF0YS12YWx1ZSc6IGRhdGFfdmFsdWUsXG4gICAgICAnYXR3aG8tYXQnOiB0aGlzLmF0XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuY2FsbGJhY2tzKFwidHBsX2V2YWxcIikuY2FsbCh0aGlzLCB0cGwsIGRhdGEpO1xuICB9O1xuXG4gIENvbnRyb2xsZXIucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKGNvbnRlbnQsICRsaSkge1xuICAgIHZhciAkaW5wdXRvciwgJGluc2VydF9ub2RlLCBjbGFzc19uYW1lLCBjb250ZW50X25vZGUsIGluc2VydF9ub2RlLCBwb3MsIHJhbmdlLCBzZWwsIHNvdXJjZSwgc3RhcnRfc3RyLCB0ZXh0O1xuICAgICRpbnB1dG9yID0gdGhpcy4kaW5wdXRvcjtcbiAgICBpZiAoJGlucHV0b3IuYXR0cignY29udGVudEVkaXRhYmxlJykgPT09ICd0cnVlJykge1xuICAgICAgY2xhc3NfbmFtZSA9IFwiYXR3aG8tdmlldy1mbGFnIGF0d2hvLXZpZXctZmxhZy1cIiArICh0aGlzLmdldF9vcHQoJ2FsaWFzJykgfHwgdGhpcy5hdCk7XG4gICAgICBjb250ZW50X25vZGUgPSBcIlwiICsgY29udGVudCArIFwiPHNwYW4gY29udGVudGVkaXRhYmxlPSdmYWxzZSc+Jm5ic3A7PHNwYW4+XCI7XG4gICAgICBpbnNlcnRfbm9kZSA9IFwiPHNwYW4gY29udGVudGVkaXRhYmxlPSdmYWxzZScgY2xhc3M9J1wiICsgY2xhc3NfbmFtZSArIFwiJz5cIiArIGNvbnRlbnRfbm9kZSArIFwiPC9zcGFuPlwiO1xuICAgICAgJGluc2VydF9ub2RlID0gJChpbnNlcnRfbm9kZSwgdGhpcy5vRG9jdW1lbnQpLmRhdGEoJ2F0d2hvLWRhdGEtaXRlbScsICRsaS5kYXRhKCdpdGVtLWRhdGEnKSk7XG4gICAgICBpZiAodGhpcy5vRG9jdW1lbnQuc2VsZWN0aW9uKSB7XG4gICAgICAgICRpbnNlcnRfbm9kZSA9ICQoXCI8c3BhbiBjb250ZW50ZWRpdGFibGU9J3RydWUnPjwvc3Bhbj5cIiwgdGhpcy5vRG9jdW1lbnQpLmh0bWwoJGluc2VydF9ub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCRpbnB1dG9yLmlzKCd0ZXh0YXJlYSwgaW5wdXQnKSkge1xuICAgICAgY29udGVudCA9ICcnICsgY29udGVudDtcbiAgICAgIHNvdXJjZSA9ICRpbnB1dG9yLnZhbCgpO1xuICAgICAgc3RhcnRfc3RyID0gc291cmNlLnNsaWNlKDAsIE1hdGgubWF4KHRoaXMucXVlcnkuaGVhZF9wb3MgLSB0aGlzLmF0Lmxlbmd0aCwgMCkpO1xuICAgICAgdGV4dCA9IFwiXCIgKyBzdGFydF9zdHIgKyBjb250ZW50ICsgXCIgXCIgKyAoc291cmNlLnNsaWNlKHRoaXMucXVlcnlbJ2VuZF9wb3MnXSB8fCAwKSk7XG4gICAgICAkaW5wdXRvci52YWwodGV4dCk7XG4gICAgICAkaW5wdXRvci5jYXJldCgncG9zJywgc3RhcnRfc3RyLmxlbmd0aCArIGNvbnRlbnQubGVuZ3RoICsgMSk7XG4gICAgfSBlbHNlIGlmIChyYW5nZSA9IHRoaXMucmFuZ2UpIHtcbiAgICAgIHBvcyA9IHJhbmdlLnN0YXJ0T2Zmc2V0IC0gKHRoaXMucXVlcnkuZW5kX3BvcyAtIHRoaXMucXVlcnkuaGVhZF9wb3MpIC0gdGhpcy5hdC5sZW5ndGg7XG4gICAgICByYW5nZS5zZXRTdGFydChyYW5nZS5lbmRDb250YWluZXIsIE1hdGgubWF4KHBvcywgMCkpO1xuICAgICAgcmFuZ2Uuc2V0RW5kKHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0KTtcbiAgICAgIHJhbmdlLmRlbGV0ZUNvbnRlbnRzKCk7XG4gICAgICByYW5nZS5pbnNlcnROb2RlKCRpbnNlcnRfbm9kZVswXSk7XG4gICAgICByYW5nZS5jb2xsYXBzZShmYWxzZSk7XG4gICAgICBzZWwgPSB0aGlzLm9XaW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICBzZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAgIH0gZWxzZSBpZiAocmFuZ2UgPSB0aGlzLmllOF9yYW5nZSkge1xuICAgICAgcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCB0aGlzLnF1ZXJ5LmVuZF9wb3MgLSB0aGlzLnF1ZXJ5LmhlYWRfcG9zIC0gdGhpcy5hdC5sZW5ndGgpO1xuICAgICAgcmFuZ2UucGFzdGVIVE1MKGNvbnRlbnRfbm9kZSk7XG4gICAgICByYW5nZS5jb2xsYXBzZShmYWxzZSk7XG4gICAgICByYW5nZS5zZWxlY3QoKTtcbiAgICB9XG4gICAgaWYgKCEkaW5wdXRvci5pcygnOmZvY3VzJykpIHtcbiAgICAgICRpbnB1dG9yLmZvY3VzKCk7XG4gICAgfVxuICAgIHJldHVybiAkaW5wdXRvci5jaGFuZ2UoKTtcbiAgfTtcblxuICBDb250cm9sbGVyLnByb3RvdHlwZS5yZW5kZXJfdmlldyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXIgc2VhcmNoX2tleTtcbiAgICBzZWFyY2hfa2V5ID0gdGhpcy5nZXRfb3B0KFwic2VhcmNoX2tleVwiKTtcbiAgICBkYXRhID0gdGhpcy5jYWxsYmFja3MoXCJzb3J0ZXJcIikuY2FsbCh0aGlzLCB0aGlzLnF1ZXJ5LnRleHQsIGRhdGEuc2xpY2UoMCwgMTAwMSksIHNlYXJjaF9rZXkpO1xuICAgIHJldHVybiB0aGlzLnZpZXcucmVuZGVyKGRhdGEuc2xpY2UoMCwgdGhpcy5nZXRfb3B0KCdsaW1pdCcpKSk7XG4gIH07XG5cbiAgQ29udHJvbGxlci5wcm90b3R5cGUubG9va191cCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBxdWVyeSwgX2NhbGxiYWNrO1xuICAgIGlmICghKHF1ZXJ5ID0gdGhpcy5jYXRjaF9xdWVyeSgpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBfY2FsbGJhY2sgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICBpZiAoZGF0YSAmJiBkYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyX3ZpZXcoZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmhpZGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMubW9kZWwucXVlcnkocXVlcnkudGV4dCwgJC5wcm94eShfY2FsbGJhY2ssIHRoaXMpKTtcbiAgICByZXR1cm4gcXVlcnk7XG4gIH07XG5cbiAgcmV0dXJuIENvbnRyb2xsZXI7XG5cbn0pKCk7XG5cbk1vZGVsID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBNb2RlbChjb250ZXh0KSB7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLmF0ID0gdGhpcy5jb250ZXh0LmF0O1xuICAgIHRoaXMuc3RvcmFnZSA9IHRoaXMuY29udGV4dC4kaW5wdXRvcjtcbiAgfVxuXG4gIE1vZGVsLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5kYXRhKHRoaXMuYXQsIG51bGwpO1xuICB9O1xuXG4gIE1vZGVsLnByb3RvdHlwZS5zYXZlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmZldGNoKCkgPiAwO1xuICB9O1xuXG4gIE1vZGVsLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uKHF1ZXJ5LCBjYWxsYmFjaykge1xuICAgIHZhciBkYXRhLCBzZWFyY2hfa2V5LCBfcmVtb3RlX2ZpbHRlcjtcbiAgICBkYXRhID0gdGhpcy5mZXRjaCgpO1xuICAgIHNlYXJjaF9rZXkgPSB0aGlzLmNvbnRleHQuZ2V0X29wdChcInNlYXJjaF9rZXlcIik7XG4gICAgZGF0YSA9IHRoaXMuY29udGV4dC5jYWxsYmFja3MoJ2ZpbHRlcicpLmNhbGwodGhpcy5jb250ZXh0LCBxdWVyeSwgZGF0YSwgc2VhcmNoX2tleSkgfHwgW107XG4gICAgX3JlbW90ZV9maWx0ZXIgPSB0aGlzLmNvbnRleHQuY2FsbGJhY2tzKCdyZW1vdGVfZmlsdGVyJyk7XG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMCB8fCAoIV9yZW1vdGVfZmlsdGVyICYmIGRhdGEubGVuZ3RoID09PSAwKSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gX3JlbW90ZV9maWx0ZXIuY2FsbCh0aGlzLmNvbnRleHQsIHF1ZXJ5LCBjYWxsYmFjayk7XG4gICAgfVxuICB9O1xuXG4gIE1vZGVsLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnN0b3JhZ2UuZGF0YSh0aGlzLmF0KSB8fCBbXTtcbiAgfTtcblxuICBNb2RlbC5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlLmRhdGEodGhpcy5hdCwgdGhpcy5jb250ZXh0LmNhbGxiYWNrcyhcImJlZm9yZV9zYXZlXCIpLmNhbGwodGhpcy5jb250ZXh0LCBkYXRhIHx8IFtdKSk7XG4gIH07XG5cbiAgTW9kZWwucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgaWYgKCEodGhpcy5zYXZlZCgpIHx8ICFkYXRhKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xvYWQoZGF0YSk7XG4gICAgfVxuICB9O1xuXG4gIE1vZGVsLnByb3RvdHlwZS5yZWxvYWQgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvYWQoZGF0YSk7XG4gIH07XG5cbiAgTW9kZWwucHJvdG90eXBlLl9sb2FkID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuICQuYWpheChkYXRhLCB7XG4gICAgICAgIGRhdGFUeXBlOiBcImpzb25cIlxuICAgICAgfSkuZG9uZSgoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuc2F2ZShkYXRhKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuc2F2ZShkYXRhKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIE1vZGVsO1xuXG59KSgpO1xuXG5WaWV3ID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBWaWV3KGNvbnRleHQpIHtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuJGVsID0gJChcIjxkaXYgY2xhc3M9J2F0d2hvLXZpZXcnPjx1bCBjbGFzcz0nYXR3aG8tdmlldy11bCc+PC91bD48L2Rpdj5cIik7XG4gICAgdGhpcy50aW1lb3V0X2lkID0gbnVsbDtcbiAgICB0aGlzLmNvbnRleHQuJGVsLmFwcGVuZCh0aGlzLiRlbCk7XG4gICAgdGhpcy5iaW5kX2V2ZW50KCk7XG4gIH1cblxuICBWaWV3LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlkO1xuICAgIGlkID0gdGhpcy5jb250ZXh0LmdldF9vcHQoXCJhbGlhc1wiKSB8fCB0aGlzLmNvbnRleHQuYXQuY2hhckNvZGVBdCgwKTtcbiAgICByZXR1cm4gdGhpcy4kZWwuYXR0cih7XG4gICAgICAnaWQnOiBcImF0LXZpZXctXCIgKyBpZFxuICAgIH0pO1xuICB9O1xuXG4gIFZpZXcucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4kZWwucmVtb3ZlKCk7XG4gIH07XG5cbiAgVmlldy5wcm90b3R5cGUuYmluZF9ldmVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciAkbWVudTtcbiAgICAkbWVudSA9IHRoaXMuJGVsLmZpbmQoJ3VsJyk7XG4gICAgcmV0dXJuICRtZW51Lm9uKCdtb3VzZWVudGVyLmF0d2hvLXZpZXcnLCAnbGknLCBmdW5jdGlvbihlKSB7XG4gICAgICAkbWVudS5maW5kKCcuY3VyJykucmVtb3ZlQ2xhc3MoJ2N1cicpO1xuICAgICAgcmV0dXJuICQoZS5jdXJyZW50VGFyZ2V0KS5hZGRDbGFzcygnY3VyJyk7XG4gICAgfSkub24oJ2NsaWNrJywgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgICBfdGhpcy5jaG9vc2UoKTtcbiAgICAgICAgcmV0dXJuIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH07XG4gICAgfSkodGhpcykpO1xuICB9O1xuXG4gIFZpZXcucHJvdG90eXBlLnZpc2libGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4kZWwuaXMoXCI6dmlzaWJsZVwiKTtcbiAgfTtcblxuICBWaWV3LnByb3RvdHlwZS5jaG9vc2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgJGxpLCBjb250ZW50O1xuICAgICRsaSA9IHRoaXMuJGVsLmZpbmQoXCIuY3VyXCIpO1xuICAgIGNvbnRlbnQgPSB0aGlzLmNvbnRleHQuaW5zZXJ0X2NvbnRlbnRfZm9yKCRsaSk7XG4gICAgdGhpcy5jb250ZXh0Lmluc2VydCh0aGlzLmNvbnRleHQuY2FsbGJhY2tzKFwiYmVmb3JlX2luc2VydFwiKS5jYWxsKHRoaXMuY29udGV4dCwgY29udGVudCwgJGxpKSwgJGxpKTtcbiAgICB0aGlzLmNvbnRleHQudHJpZ2dlcihcImluc2VydGVkXCIsIFskbGldKTtcbiAgICByZXR1cm4gdGhpcy5oaWRlKCk7XG4gIH07XG5cbiAgVmlldy5wcm90b3R5cGUucmVwb3NpdGlvbiA9IGZ1bmN0aW9uKHJlY3QpIHtcbiAgICB2YXIgb2Zmc2V0O1xuICAgIGlmIChyZWN0LmJvdHRvbSArIHRoaXMuJGVsLmhlaWdodCgpIC0gJCh3aW5kb3cpLnNjcm9sbFRvcCgpID4gJCh3aW5kb3cpLmhlaWdodCgpKSB7XG4gICAgICByZWN0LmJvdHRvbSA9IHJlY3QudG9wIC0gdGhpcy4kZWwuaGVpZ2h0KCk7XG4gICAgfVxuICAgIG9mZnNldCA9IHtcbiAgICAgIGxlZnQ6IHJlY3QubGVmdCxcbiAgICAgIHRvcDogcmVjdC5ib3R0b21cbiAgICB9O1xuICAgIHRoaXMuJGVsLm9mZnNldChvZmZzZXQpO1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQudHJpZ2dlcihcInJlcG9zaXRpb25cIiwgW29mZnNldF0pO1xuICB9O1xuXG4gIFZpZXcucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3VyLCBuZXh0O1xuICAgIGN1ciA9IHRoaXMuJGVsLmZpbmQoJy5jdXInKS5yZW1vdmVDbGFzcygnY3VyJyk7XG4gICAgbmV4dCA9IGN1ci5uZXh0KCk7XG4gICAgaWYgKCFuZXh0Lmxlbmd0aCkge1xuICAgICAgbmV4dCA9IHRoaXMuJGVsLmZpbmQoJ2xpOmZpcnN0Jyk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0LmFkZENsYXNzKCdjdXInKTtcbiAgfTtcblxuICBWaWV3LnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN1ciwgcHJldjtcbiAgICBjdXIgPSB0aGlzLiRlbC5maW5kKCcuY3VyJykucmVtb3ZlQ2xhc3MoJ2N1cicpO1xuICAgIHByZXYgPSBjdXIucHJldigpO1xuICAgIGlmICghcHJldi5sZW5ndGgpIHtcbiAgICAgIHByZXYgPSB0aGlzLiRlbC5maW5kKCdsaTpsYXN0Jyk7XG4gICAgfVxuICAgIHJldHVybiBwcmV2LmFkZENsYXNzKCdjdXInKTtcbiAgfTtcblxuICBWaWV3LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlY3Q7XG4gICAgdGhpcy5jb250ZXh0Lm1hcmtfcmFuZ2UoKTtcbiAgICBpZiAoIXRoaXMudmlzaWJsZSgpKSB7XG4gICAgICB0aGlzLiRlbC5zaG93KCk7XG4gICAgfVxuICAgIGlmIChyZWN0ID0gdGhpcy5jb250ZXh0LnJlY3QoKSkge1xuICAgICAgcmV0dXJuIHRoaXMucmVwb3NpdGlvbihyZWN0KTtcbiAgICB9XG4gIH07XG5cbiAgVmlldy5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKHRpbWUpIHtcbiAgICB2YXIgY2FsbGJhY2s7XG4gICAgaWYgKGlzTmFOKHRpbWUgJiYgdGhpcy52aXNpYmxlKCkpKSB7XG4gICAgICB0aGlzLmNvbnRleHQucmVzZXRfcmVjdCgpO1xuICAgICAgcmV0dXJuIHRoaXMuJGVsLmhpZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sgPSAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5oaWRlKCk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKTtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRfaWQpO1xuICAgICAgcmV0dXJuIHRoaXMudGltZW91dF9pZCA9IHNldFRpbWVvdXQoY2FsbGJhY2ssIHRpbWUpO1xuICAgIH1cbiAgfTtcblxuICBWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihsaXN0KSB7XG4gICAgdmFyICRsaSwgJHVsLCBpdGVtLCBsaSwgdHBsLCBfaSwgX2xlbjtcbiAgICBpZiAoISgkLmlzQXJyYXkobGlzdCkgJiYgbGlzdC5sZW5ndGggPiAwKSkge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuJGVsLmZpbmQoJ3VsJykuZW1wdHkoKTtcbiAgICAkdWwgPSB0aGlzLiRlbC5maW5kKCd1bCcpO1xuICAgIHRwbCA9IHRoaXMuY29udGV4dC5nZXRfb3B0KCd0cGwnKTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGxpc3QubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIGl0ZW0gPSBsaXN0W19pXTtcbiAgICAgIGl0ZW0gPSAkLmV4dGVuZCh7fSwgaXRlbSwge1xuICAgICAgICAnYXR3aG8tYXQnOiB0aGlzLmNvbnRleHQuYXRcbiAgICAgIH0pO1xuICAgICAgbGkgPSB0aGlzLmNvbnRleHQuY2FsbGJhY2tzKFwidHBsX2V2YWxcIikuY2FsbCh0aGlzLmNvbnRleHQsIHRwbCwgaXRlbSk7XG4gICAgICAkbGkgPSAkKHRoaXMuY29udGV4dC5jYWxsYmFja3MoXCJoaWdobGlnaHRlclwiKS5jYWxsKHRoaXMuY29udGV4dCwgbGksIHRoaXMuY29udGV4dC5xdWVyeS50ZXh0KSk7XG4gICAgICAkbGkuZGF0YShcIml0ZW0tZGF0YVwiLCBpdGVtKTtcbiAgICAgICR1bC5hcHBlbmQoJGxpKTtcbiAgICB9XG4gICAgdGhpcy5zaG93KCk7XG4gICAgcmV0dXJuICR1bC5maW5kKFwibGk6Zmlyc3RcIikuYWRkQ2xhc3MoXCJjdXJcIik7XG4gIH07XG5cbiAgcmV0dXJuIFZpZXc7XG5cbn0pKCk7XG5cbktFWV9DT0RFID0ge1xuICBET1dOOiA0MCxcbiAgVVA6IDM4LFxuICBFU0M6IDI3LFxuICBUQUI6IDksXG4gIEVOVEVSOiAxM1xufTtcblxuREVGQVVMVF9DQUxMQkFDS1MgPSB7XG4gIGJlZm9yZV9zYXZlOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIGl0ZW0sIF9pLCBfbGVuLCBfcmVzdWx0cztcbiAgICBpZiAoISQuaXNBcnJheShkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIF9yZXN1bHRzID0gW107XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBkYXRhLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBpdGVtID0gZGF0YVtfaV07XG4gICAgICBpZiAoJC5pc1BsYWluT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgIF9yZXN1bHRzLnB1c2goaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBpdGVtXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX3Jlc3VsdHM7XG4gIH0sXG4gIG1hdGNoZXI6IGZ1bmN0aW9uKGZsYWcsIHN1YnRleHQsIHNob3VsZF9zdGFydF93aXRoX3NwYWNlKSB7XG4gICAgdmFyIG1hdGNoLCByZWdleHA7XG4gICAgZmxhZyA9IGZsYWcucmVwbGFjZSgvW1xcLVxcW1xcXVxcL1xce1xcfVxcKFxcKVxcKlxcK1xcP1xcLlxcXFxcXF5cXCRcXHxdL2csIFwiXFxcXCQmXCIpO1xuICAgIGlmIChzaG91bGRfc3RhcnRfd2l0aF9zcGFjZSkge1xuICAgICAgZmxhZyA9ICcoPzpefFxcXFxzKScgKyBmbGFnO1xuICAgIH1cbiAgICByZWdleHAgPSBuZXcgUmVnRXhwKGZsYWcgKyAnKFtBLVphLXowLTlfXFwrXFwtXSopJHwnICsgZmxhZyArICcoW15cXFxceDAwLVxcXFx4ZmZdKikkJywgJ2dpJyk7XG4gICAgbWF0Y2ggPSByZWdleHAuZXhlYyhzdWJ0ZXh0KTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHJldHVybiBtYXRjaFsyXSB8fCBtYXRjaFsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LFxuICBmaWx0ZXI6IGZ1bmN0aW9uKHF1ZXJ5LCBkYXRhLCBzZWFyY2hfa2V5KSB7XG4gICAgdmFyIGl0ZW0sIF9pLCBfbGVuLCBfcmVzdWx0cztcbiAgICBfcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gZGF0YS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgaXRlbSA9IGRhdGFbX2ldO1xuICAgICAgaWYgKH5pdGVtW3NlYXJjaF9rZXldLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihxdWVyeSkpIHtcbiAgICAgICAgX3Jlc3VsdHMucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF9yZXN1bHRzO1xuICB9LFxuICByZW1vdGVfZmlsdGVyOiBudWxsLFxuICBzb3J0ZXI6IGZ1bmN0aW9uKHF1ZXJ5LCBpdGVtcywgc2VhcmNoX2tleSkge1xuICAgIHZhciBpdGVtLCBfaSwgX2xlbiwgX3Jlc3VsdHM7XG4gICAgaWYgKCFxdWVyeSkge1xuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH1cbiAgICBfcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gaXRlbXMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIGl0ZW0gPSBpdGVtc1tfaV07XG4gICAgICBpdGVtLmF0d2hvX29yZGVyID0gaXRlbVtzZWFyY2hfa2V5XS50b0xvd2VyQ2FzZSgpLmluZGV4T2YocXVlcnkpO1xuICAgICAgaWYgKGl0ZW0uYXR3aG9fb3JkZXIgPiAtMSkge1xuICAgICAgICBfcmVzdWx0cy5wdXNoKGl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX3Jlc3VsdHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gYS5hdHdob19vcmRlciAtIGIuYXR3aG9fb3JkZXI7XG4gICAgfSk7XG4gIH0sXG4gIHRwbF9ldmFsOiBmdW5jdGlvbih0cGwsIG1hcCkge1xuICAgIHZhciBlcnJvcjtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRwbC5yZXBsYWNlKC9cXCRcXHsoW15cXH1dKilcXH0vZywgZnVuY3Rpb24odGFnLCBrZXksIHBvcykge1xuICAgICAgICByZXR1cm4gbWFwW2tleV07XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgIGVycm9yID0gX2Vycm9yO1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICB9LFxuICBoaWdobGlnaHRlcjogZnVuY3Rpb24obGksIHF1ZXJ5KSB7XG4gICAgdmFyIHJlZ2V4cDtcbiAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICByZXR1cm4gbGk7XG4gICAgfVxuICAgIHJlZ2V4cCA9IG5ldyBSZWdFeHAoXCI+XFxcXHMqKFxcXFx3KikoXCIgKyBxdWVyeS5yZXBsYWNlKFwiK1wiLCBcIlxcXFwrXCIpICsgXCIpKFxcXFx3KilcXFxccyo8XCIsICdpZycpO1xuICAgIHJldHVybiBsaS5yZXBsYWNlKHJlZ2V4cCwgZnVuY3Rpb24oc3RyLCAkMSwgJDIsICQzKSB7XG4gICAgICByZXR1cm4gJz4gJyArICQxICsgJzxzdHJvbmc+JyArICQyICsgJzwvc3Ryb25nPicgKyAkMyArICcgPCc7XG4gICAgfSk7XG4gIH0sXG4gIGJlZm9yZV9pbnNlcnQ6IGZ1bmN0aW9uKHZhbHVlLCAkbGkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn07XG5cbkFwaSA9IHtcbiAgbG9hZDogZnVuY3Rpb24oYXQsIGRhdGEpIHtcbiAgICB2YXIgYztcbiAgICBpZiAoYyA9IHRoaXMuY29udHJvbGxlcihhdCkpIHtcbiAgICAgIHJldHVybiBjLm1vZGVsLmxvYWQoZGF0YSk7XG4gICAgfVxuICB9LFxuICBnZXRJbnNlcnRlZEl0ZW1zV2l0aElEczogZnVuY3Rpb24oYXQpIHtcbiAgICB2YXIgYywgaWRzLCBpdGVtcztcbiAgICBpZiAoIShjID0gdGhpcy5jb250cm9sbGVyKGF0KSkpIHtcbiAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgfVxuICAgIGlmIChhdCkge1xuICAgICAgYXQgPSBcIi1cIiArIChjLmdldF9vcHQoJ2FsaWFzJykgfHwgYy5hdCk7XG4gICAgfVxuICAgIGlkcyA9IFtdO1xuICAgIGl0ZW1zID0gJC5tYXAodGhpcy4kaW5wdXRvci5maW5kKFwic3Bhbi5hdHdoby12aWV3LWZsYWdcIiArIChhdCB8fCBcIlwiKSksIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHZhciBkYXRhO1xuICAgICAgZGF0YSA9ICQoaXRlbSkuZGF0YSgnYXR3aG8tZGF0YS1pdGVtJyk7XG4gICAgICBpZiAoaWRzLmluZGV4T2YoZGF0YS5pZCkgPiAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS5pZCkge1xuICAgICAgICBpZHMucHVzaCA9IGRhdGEuaWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9KTtcbiAgICByZXR1cm4gW2lkcywgaXRlbXNdO1xuICB9LFxuICBnZXRJbnNlcnRlZEl0ZW1zOiBmdW5jdGlvbihhdCkge1xuICAgIHJldHVybiBBcGkuZ2V0SW5zZXJ0ZWRJdGVtc1dpdGhJRHMuYXBwbHkodGhpcywgW2F0XSlbMV07XG4gIH0sXG4gIGdldEluc2VydGVkSURzOiBmdW5jdGlvbihhdCkge1xuICAgIHJldHVybiBBcGkuZ2V0SW5zZXJ0ZWRJdGVtc1dpdGhJRHMuYXBwbHkodGhpcywgW2F0XSlbMF07XG4gIH0sXG4gIHJ1bjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goKTtcbiAgfSxcbiAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zaHV0ZG93bigpO1xuICAgIHJldHVybiB0aGlzLiRpbnB1dG9yLmRhdGEoJ2F0d2hvJywgbnVsbCk7XG4gIH1cbn07XG5cbkF0d2hvID0ge1xuICBpbml0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyICR0aGlzLCBhcHA7XG4gICAgYXBwID0gKCR0aGlzID0gJCh0aGlzKSkuZGF0YShcImF0d2hvXCIpO1xuICAgIGlmICghYXBwKSB7XG4gICAgICAkdGhpcy5kYXRhKCdhdHdobycsIChhcHAgPSBuZXcgQXBwKHRoaXMpKSk7XG4gICAgfVxuICAgIGFwcC5yZWcob3B0aW9ucy5hdCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cbiRDT05UQUlORVIgPSAkKFwiPGRpdiBpZD0nYXR3aG8tY29udGFpbmVyJz48L2Rpdj5cIik7XG5cbiQuZm4uYXR3aG8gPSBmdW5jdGlvbihtZXRob2QpIHtcbiAgdmFyIHJlc3VsdCwgX2FyZ3M7XG4gIF9hcmdzID0gYXJndW1lbnRzO1xuICAkKCdib2R5JykuYXBwZW5kKCRDT05UQUlORVIpO1xuICByZXN1bHQgPSBudWxsO1xuICB0aGlzLmZpbHRlcigndGV4dGFyZWEsIGlucHV0LCBbY29udGVudGVkaXRhYmxlPXRydWVdJykuZWFjaChmdW5jdGlvbigpIHtcbiAgICB2YXIgYXBwO1xuICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSAnb2JqZWN0JyB8fCAhbWV0aG9kKSB7XG4gICAgICByZXR1cm4gQXR3aG8uaW5pdC5hcHBseSh0aGlzLCBfYXJncyk7XG4gICAgfSBlbHNlIGlmIChBcGlbbWV0aG9kXSkge1xuICAgICAgaWYgKGFwcCA9ICQodGhpcykuZGF0YSgnYXR3aG8nKSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0ID0gQXBpW21ldGhvZF0uYXBwbHkoYXBwLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChfYXJncywgMSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJC5lcnJvcihcIk1ldGhvZCBcIiArIG1ldGhvZCArIFwiIGRvZXMgbm90IGV4aXN0IG9uIGpRdWVyeS5jYXJldFwiKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0IHx8IHRoaXM7XG59O1xuXG4kLmZuLmF0d2hvW1wiZGVmYXVsdFwiXSA9IHtcbiAgYXQ6IHZvaWQgMCxcbiAgYWxpYXM6IHZvaWQgMCxcbiAgZGF0YTogbnVsbCxcbiAgdHBsOiBcIjxsaSBkYXRhLXZhbHVlPScke2F0d2hvLWF0fSR7bmFtZX0nPiR7bmFtZX08L2xpPlwiLFxuICBpbnNlcnRfdHBsOiBcIjxzcGFuPiR7YXR3aG8tZGF0YS12YWx1ZX08L3NwYW4+XCIsXG4gIGNhbGxiYWNrczogREVGQVVMVF9DQUxMQkFDS1MsXG4gIHNlYXJjaF9rZXk6IFwibmFtZVwiLFxuICBzdGFydF93aXRoX3NwYWNlOiB0cnVlLFxuICBsaW1pdDogNSxcbiAgbWF4X2xlbjogMjAsXG4gIGRpc3BsYXlfdGltZW91dDogMzAwXG59O1xuXG4gIH0pO1xufSkuY2FsbCh0aGlzKTtcbiIsIi8qISBqcXVlcnkuY2FyZXQgMjAxNC0wMy0xNCAqL1xuKGZ1bmN0aW9uKCl7IWZ1bmN0aW9uKGEpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wianF1ZXJ5XCJdLGEpOmEod2luZG93LmpRdWVyeSl9KGZ1bmN0aW9uKGEpe1widXNlIHN0cmljdFwiO3ZhciBiLGMsZCxlLGYsZyxoLGksajtyZXR1cm4gaj1cImNhcmV0XCIsYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYSl7dGhpcy4kaW5wdXRvcj1hLHRoaXMuZG9tSW5wdXRvcj10aGlzLiRpbnB1dG9yWzBdfXJldHVybiBiLnByb3RvdHlwZS5zZXRQb3M9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kb21JbnB1dG9yfSxiLnByb3RvdHlwZS5nZXRJRVBvc2l0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIGEubm9vcCgpfSxiLnByb3RvdHlwZS5nZXRQb3NpdGlvbj1mdW5jdGlvbigpe3JldHVybiBhLm5vb3AoKX0sYi5wcm90b3R5cGUuZ2V0T2xkSUVQb3M9ZnVuY3Rpb24oKXt2YXIgYSxiO3JldHVybiBiPWcuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCksYT1nLmJvZHkuY3JlYXRlVGV4dFJhbmdlKCksYS5tb3ZlVG9FbGVtZW50VGV4dCh0aGlzLmRvbUlucHV0b3IpLGEuc2V0RW5kUG9pbnQoXCJFbmRUb0VuZFwiLGIpLGEudGV4dC5sZW5ndGh9LGIucHJvdG90eXBlLmdldFBvcz1mdW5jdGlvbigpe3ZhciBhLGIsYztyZXR1cm4oYz10aGlzLnJhbmdlKCkpPyhhPWMuY2xvbmVSYW5nZSgpLGEuc2VsZWN0Tm9kZUNvbnRlbnRzKHRoaXMuZG9tSW5wdXRvciksYS5zZXRFbmQoYy5lbmRDb250YWluZXIsYy5lbmRPZmZzZXQpLGI9YS50b1N0cmluZygpLmxlbmd0aCxhLmRldGFjaCgpLGIpOmcuc2VsZWN0aW9uP3RoaXMuZ2V0T2xkSUVQb3MoKTp2b2lkIDB9LGIucHJvdG90eXBlLmdldE9sZElFT2Zmc2V0PWZ1bmN0aW9uKCl7dmFyIGEsYjtyZXR1cm4gYT1nLnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpLmR1cGxpY2F0ZSgpLGEubW92ZVN0YXJ0KFwiY2hhcmFjdGVyXCIsLTEpLGI9YS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSx7aGVpZ2h0OmIuYm90dG9tLWIudG9wLGxlZnQ6Yi5sZWZ0LHRvcDpiLnRvcH19LGIucHJvdG90eXBlLmdldE9mZnNldD1mdW5jdGlvbigpe3ZhciBiLGMsZCxlO2lmKGkuZ2V0U2VsZWN0aW9uJiYoZD10aGlzLnJhbmdlKCkpKXtpZihkLmVuZE9mZnNldC0xPDApcmV0dXJuIG51bGw7Yj1kLmNsb25lUmFuZ2UoKSxiLnNldFN0YXJ0KGQuZW5kQ29udGFpbmVyLGQuZW5kT2Zmc2V0LTEpLGIuc2V0RW5kKGQuZW5kQ29udGFpbmVyLGQuZW5kT2Zmc2V0KSxlPWIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksYz17aGVpZ2h0OmUuaGVpZ2h0LGxlZnQ6ZS5sZWZ0K2Uud2lkdGgsdG9wOmUudG9wfSxiLmRldGFjaCgpfWVsc2UgZy5zZWxlY3Rpb24mJihjPXRoaXMuZ2V0T2xkSUVPZmZzZXQoKSk7cmV0dXJuIGMmJiFoJiYoYy50b3ArPWEoaSkuc2Nyb2xsVG9wKCksYy5sZWZ0Kz1hKGkpLnNjcm9sbExlZnQoKSksY30sYi5wcm90b3R5cGUucmFuZ2U9ZnVuY3Rpb24oKXt2YXIgYTtpZihpLmdldFNlbGVjdGlvbilyZXR1cm4gYT1pLmdldFNlbGVjdGlvbigpLGEucmFuZ2VDb3VudD4wP2EuZ2V0UmFuZ2VBdCgwKTpudWxsfSxifSgpLGM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGEpe3RoaXMuJGlucHV0b3I9YSx0aGlzLmRvbUlucHV0b3I9dGhpcy4kaW5wdXRvclswXX1yZXR1cm4gYi5wcm90b3R5cGUuZ2V0SUVQb3M9ZnVuY3Rpb24oKXt2YXIgYSxiLGMsZCxlLGYsaDtyZXR1cm4gYj10aGlzLmRvbUlucHV0b3IsZj1nLnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpLGU9MCxmJiZmLnBhcmVudEVsZW1lbnQoKT09PWImJihkPWIudmFsdWUucmVwbGFjZSgvXFxyXFxuL2csXCJcXG5cIiksYz1kLmxlbmd0aCxoPWIuY3JlYXRlVGV4dFJhbmdlKCksaC5tb3ZlVG9Cb29rbWFyayhmLmdldEJvb2ttYXJrKCkpLGE9Yi5jcmVhdGVUZXh0UmFuZ2UoKSxhLmNvbGxhcHNlKCExKSxlPWguY29tcGFyZUVuZFBvaW50cyhcIlN0YXJ0VG9FbmRcIixhKT4tMT9jOi1oLm1vdmVTdGFydChcImNoYXJhY3RlclwiLC1jKSksZX0sYi5wcm90b3R5cGUuZ2V0UG9zPWZ1bmN0aW9uKCl7cmV0dXJuIGcuc2VsZWN0aW9uP3RoaXMuZ2V0SUVQb3MoKTp0aGlzLmRvbUlucHV0b3Iuc2VsZWN0aW9uU3RhcnR9LGIucHJvdG90eXBlLnNldFBvcz1mdW5jdGlvbihhKXt2YXIgYixjO3JldHVybiBiPXRoaXMuZG9tSW5wdXRvcixnLnNlbGVjdGlvbj8oYz1iLmNyZWF0ZVRleHRSYW5nZSgpLGMubW92ZShcImNoYXJhY3RlclwiLGEpLGMuc2VsZWN0KCkpOmIuc2V0U2VsZWN0aW9uUmFuZ2UmJmIuc2V0U2VsZWN0aW9uUmFuZ2UoYSxhKSxifSxiLnByb3RvdHlwZS5nZXRJRU9mZnNldD1mdW5jdGlvbihhKXt2YXIgYixjLGQsZTtyZXR1cm4gYz10aGlzLmRvbUlucHV0b3IuY3JlYXRlVGV4dFJhbmdlKCksYXx8KGE9dGhpcy5nZXRQb3MoKSksYy5tb3ZlKFwiY2hhcmFjdGVyXCIsYSksZD1jLmJvdW5kaW5nTGVmdCxlPWMuYm91bmRpbmdUb3AsYj1jLmJvdW5kaW5nSGVpZ2h0LHtsZWZ0OmQsdG9wOmUsaGVpZ2h0OmJ9fSxiLnByb3RvdHlwZS5nZXRPZmZzZXQ9ZnVuY3Rpb24oYil7dmFyIGMsZCxlO3JldHVybiBjPXRoaXMuJGlucHV0b3IsZy5zZWxlY3Rpb24/KGQ9dGhpcy5nZXRJRU9mZnNldChiKSxkLnRvcCs9YShpKS5zY3JvbGxUb3AoKStjLnNjcm9sbFRvcCgpLGQubGVmdCs9YShpKS5zY3JvbGxMZWZ0KCkrYy5zY3JvbGxMZWZ0KCksZCk6KGQ9Yy5vZmZzZXQoKSxlPXRoaXMuZ2V0UG9zaXRpb24oYiksZD17bGVmdDpkLmxlZnQrZS5sZWZ0LWMuc2Nyb2xsTGVmdCgpLHRvcDpkLnRvcCtlLnRvcC1jLnNjcm9sbFRvcCgpLGhlaWdodDplLmhlaWdodH0pfSxiLnByb3RvdHlwZS5nZXRQb3NpdGlvbj1mdW5jdGlvbihhKXt2YXIgYixjLGUsZixnLGg7cmV0dXJuIGI9dGhpcy4kaW5wdXRvcixlPWZ1bmN0aW9uKGEpe3JldHVybiBhLnJlcGxhY2UoLzwvZyxcIiZsdFwiKS5yZXBsYWNlKC8+L2csXCImZ3RcIikucmVwbGFjZSgvYC9nLFwiJiM5NlwiKS5yZXBsYWNlKC9cIi9nLFwiJnF1b3RcIikucmVwbGFjZSgvXFxyXFxufFxccnxcXG4vZyxcIjxiciAvPlwiKX0sdm9pZCAwPT09YSYmKGE9dGhpcy5nZXRQb3MoKSksaD1iLnZhbCgpLnNsaWNlKDAsYSksZj1cIjxzcGFuPlwiK2UoaCkrXCI8L3NwYW4+XCIsZis9XCI8c3BhbiBpZD0nY2FyZXQnPnw8L3NwYW4+XCIsZz1uZXcgZChiKSxjPWcuY3JlYXRlKGYpLnJlY3QoKX0sYi5wcm90b3R5cGUuZ2V0SUVQb3NpdGlvbj1mdW5jdGlvbihhKXt2YXIgYixjLGQsZSxmO3JldHVybiBkPXRoaXMuZ2V0SUVPZmZzZXQoYSksYz10aGlzLiRpbnB1dG9yLm9mZnNldCgpLGU9ZC5sZWZ0LWMubGVmdCxmPWQudG9wLWMudG9wLGI9ZC5oZWlnaHQse2xlZnQ6ZSx0b3A6ZixoZWlnaHQ6Yn19LGJ9KCksZD1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYSl7dGhpcy4kaW5wdXRvcj1hfXJldHVybiBiLnByb3RvdHlwZS5jc3NfYXR0cj1bXCJvdmVyZmxvd1lcIixcImhlaWdodFwiLFwid2lkdGhcIixcInBhZGRpbmdUb3BcIixcInBhZGRpbmdMZWZ0XCIsXCJwYWRkaW5nUmlnaHRcIixcInBhZGRpbmdCb3R0b21cIixcIm1hcmdpblRvcFwiLFwibWFyZ2luTGVmdFwiLFwibWFyZ2luUmlnaHRcIixcIm1hcmdpbkJvdHRvbVwiLFwiZm9udEZhbWlseVwiLFwiYm9yZGVyU3R5bGVcIixcImJvcmRlcldpZHRoXCIsXCJ3b3JkV3JhcFwiLFwiZm9udFNpemVcIixcImxpbmVIZWlnaHRcIixcIm92ZXJmbG93WFwiLFwidGV4dC1hbGlnblwiXSxiLnByb3RvdHlwZS5taXJyb3JDc3M9ZnVuY3Rpb24oKXt2YXIgYixjPXRoaXM7cmV0dXJuIGI9e3Bvc2l0aW9uOlwiYWJzb2x1dGVcIixsZWZ0Oi05OTk5LHRvcDowLHpJbmRleDotMmU0LFwid2hpdGUtc3BhY2VcIjpcInByZS13cmFwXCJ9LGEuZWFjaCh0aGlzLmNzc19hdHRyLGZ1bmN0aW9uKGEsZCl7cmV0dXJuIGJbZF09Yy4kaW5wdXRvci5jc3MoZCl9KSxifSxiLnByb3RvdHlwZS5jcmVhdGU9ZnVuY3Rpb24oYil7cmV0dXJuIHRoaXMuJG1pcnJvcj1hKFwiPGRpdj48L2Rpdj5cIiksdGhpcy4kbWlycm9yLmNzcyh0aGlzLm1pcnJvckNzcygpKSx0aGlzLiRtaXJyb3IuaHRtbChiKSx0aGlzLiRpbnB1dG9yLmFmdGVyKHRoaXMuJG1pcnJvciksdGhpc30sYi5wcm90b3R5cGUucmVjdD1mdW5jdGlvbigpe3ZhciBhLGIsYztyZXR1cm4gYT10aGlzLiRtaXJyb3IuZmluZChcIiNjYXJldFwiKSxiPWEucG9zaXRpb24oKSxjPXtsZWZ0OmIubGVmdCx0b3A6Yi50b3AsaGVpZ2h0OmEuaGVpZ2h0KCl9LHRoaXMuJG1pcnJvci5yZW1vdmUoKSxjfSxifSgpLGU9e2NvbnRlbnRFZGl0YWJsZTpmdW5jdGlvbihhKXtyZXR1cm4hKCFhWzBdLmNvbnRlbnRFZGl0YWJsZXx8XCJ0cnVlXCIhPT1hWzBdLmNvbnRlbnRFZGl0YWJsZSl9fSxmPXtwb3M6ZnVuY3Rpb24oYSl7cmV0dXJuIGF8fDA9PT1hP3RoaXMuc2V0UG9zKGEpOnRoaXMuZ2V0UG9zKCl9LHBvc2l0aW9uOmZ1bmN0aW9uKGEpe3JldHVybiBnLnNlbGVjdGlvbj90aGlzLmdldElFUG9zaXRpb24oYSk6dGhpcy5nZXRQb3NpdGlvbihhKX0sb2Zmc2V0OmZ1bmN0aW9uKGIpe3ZhciBjLGQ7cmV0dXJuIGQ9dGhpcy5nZXRPZmZzZXQoYiksaCYmKGM9YShoKS5vZmZzZXQoKSxkLnRvcCs9Yy50b3AsZC5sZWZ0Kz1jLmxlZnQpLGR9fSxnPW51bGwsaT1udWxsLGg9bnVsbCxhLmZuLmNhcmV0PWZ1bmN0aW9uKGQpe3ZhciBqLGs7Zz10aGlzWzBdLm93bmVyRG9jdW1lbnQsaT1nLmRlZmF1bHRWaWV3fHxnLnBhcmVudFdpbmRvdzt0cnl7aD1pLmZyYW1lRWxlbWVudH1jYXRjaChsKXtrPWx9cmV0dXJuIGo9ZS5jb250ZW50RWRpdGFibGUodGhpcyk/bmV3IGIodGhpcyk6bmV3IGModGhpcyksZltkXT9mW2RdLmFwcGx5KGosQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpKTphLmVycm9yKFwiTWV0aG9kIFwiK2QrXCIgZG9lcyBub3QgZXhpc3Qgb24galF1ZXJ5LmNhcmV0XCIpfSxhLmZuLmNhcmV0LkVkaXRhYmxlQ2FyZXQ9YixhLmZuLmNhcmV0LklucHV0Q2FyZXQ9YyxhLmZuLmNhcmV0LlV0aWxzPWUsYS5mbi5jYXJldC5hcGlzPWZ9KX0pLmNhbGwodGhpcyk7IiwiLyoqXG4gKiBtYXJrZWQgLSBhIG1hcmtkb3duIHBhcnNlclxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTQsIENocmlzdG9waGVyIEplZmZyZXkuIChNSVQgTGljZW5zZWQpXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2hqai9tYXJrZWRcbiAqL1xuXG47KGZ1bmN0aW9uKCkge1xuXG4vKipcbiAqIEJsb2NrLUxldmVsIEdyYW1tYXJcbiAqL1xuXG52YXIgYmxvY2sgPSB7XG4gIG5ld2xpbmU6IC9eXFxuKy8sXG4gIGNvZGU6IC9eKCB7NH1bXlxcbl0rXFxuKikrLyxcbiAgZmVuY2VzOiBub29wLFxuICBocjogL14oICpbLSpfXSl7Myx9ICooPzpcXG4rfCQpLyxcbiAgaGVhZGluZzogL14gKigjezEsNn0pICooW15cXG5dKz8pICojKiAqKD86XFxuK3wkKS8sXG4gIG5wdGFibGU6IG5vb3AsXG4gIGxoZWFkaW5nOiAvXihbXlxcbl0rKVxcbiAqKD18LSl7Mix9ICooPzpcXG4rfCQpLyxcbiAgYmxvY2txdW90ZTogL14oICo+W15cXG5dKyhcXG4oPyFkZWYpW15cXG5dKykqXFxuKikrLyxcbiAgbGlzdDogL14oICopKGJ1bGwpIFtcXHNcXFNdKz8oPzpocnxkZWZ8XFxuezIsfSg/ISApKD8hXFwxYnVsbCApXFxuKnxcXHMqJCkvLFxuICBodG1sOiAvXiAqKD86Y29tbWVudCAqKD86XFxufFxccyokKXxjbG9zZWQgKig/OlxcbnsyLH18XFxzKiQpfGNsb3NpbmcgKig/OlxcbnsyLH18XFxzKiQpKS8sXG4gIGRlZjogL14gKlxcWyhbXlxcXV0rKVxcXTogKjw/KFteXFxzPl0rKT4/KD86ICtbXCIoXShbXlxcbl0rKVtcIildKT8gKig/Olxcbit8JCkvLFxuICB0YWJsZTogbm9vcCxcbiAgcGFyYWdyYXBoOiAvXigoPzpbXlxcbl0rXFxuPyg/IWhyfGhlYWRpbmd8bGhlYWRpbmd8YmxvY2txdW90ZXx0YWd8ZGVmKSkrKVxcbiovLFxuICB0ZXh0OiAvXlteXFxuXSsvXG59O1xuXG5ibG9jay5idWxsZXQgPSAvKD86WyorLV18XFxkK1xcLikvO1xuYmxvY2suaXRlbSA9IC9eKCAqKShidWxsKSBbXlxcbl0qKD86XFxuKD8hXFwxYnVsbCApW15cXG5dKikqLztcbmJsb2NrLml0ZW0gPSByZXBsYWNlKGJsb2NrLml0ZW0sICdnbScpXG4gICgvYnVsbC9nLCBibG9jay5idWxsZXQpXG4gICgpO1xuXG5ibG9jay5saXN0ID0gcmVwbGFjZShibG9jay5saXN0KVxuICAoL2J1bGwvZywgYmxvY2suYnVsbGV0KVxuICAoJ2hyJywgJ1xcXFxuKyg/PVxcXFwxPyg/OlstKl9dICopezMsfSg/OlxcXFxuK3wkKSknKVxuICAoJ2RlZicsICdcXFxcbisoPz0nICsgYmxvY2suZGVmLnNvdXJjZSArICcpJylcbiAgKCk7XG5cbmJsb2NrLmJsb2NrcXVvdGUgPSByZXBsYWNlKGJsb2NrLmJsb2NrcXVvdGUpXG4gICgnZGVmJywgYmxvY2suZGVmKVxuICAoKTtcblxuYmxvY2suX3RhZyA9ICcoPyEoPzonXG4gICsgJ2F8ZW18c3Ryb25nfHNtYWxsfHN8Y2l0ZXxxfGRmbnxhYmJyfGRhdGF8dGltZXxjb2RlJ1xuICArICd8dmFyfHNhbXB8a2JkfHN1YnxzdXB8aXxifHV8bWFya3xydWJ5fHJ0fHJwfGJkaXxiZG8nXG4gICsgJ3xzcGFufGJyfHdicnxpbnN8ZGVsfGltZylcXFxcYilcXFxcdysoPyE6L3xbXlxcXFx3XFxcXHNAXSpAKVxcXFxiJztcblxuYmxvY2suaHRtbCA9IHJlcGxhY2UoYmxvY2suaHRtbClcbiAgKCdjb21tZW50JywgLzwhLS1bXFxzXFxTXSo/LS0+LylcbiAgKCdjbG9zZWQnLCAvPCh0YWcpW1xcc1xcU10rPzxcXC9cXDE+LylcbiAgKCdjbG9zaW5nJywgLzx0YWcoPzpcIlteXCJdKlwifCdbXiddKid8W14nXCI+XSkqPz4vKVxuICAoL3RhZy9nLCBibG9jay5fdGFnKVxuICAoKTtcblxuYmxvY2sucGFyYWdyYXBoID0gcmVwbGFjZShibG9jay5wYXJhZ3JhcGgpXG4gICgnaHInLCBibG9jay5ocilcbiAgKCdoZWFkaW5nJywgYmxvY2suaGVhZGluZylcbiAgKCdsaGVhZGluZycsIGJsb2NrLmxoZWFkaW5nKVxuICAoJ2Jsb2NrcXVvdGUnLCBibG9jay5ibG9ja3F1b3RlKVxuICAoJ3RhZycsICc8JyArIGJsb2NrLl90YWcpXG4gICgnZGVmJywgYmxvY2suZGVmKVxuICAoKTtcblxuLyoqXG4gKiBOb3JtYWwgQmxvY2sgR3JhbW1hclxuICovXG5cbmJsb2NrLm5vcm1hbCA9IG1lcmdlKHt9LCBibG9jayk7XG5cbi8qKlxuICogR0ZNIEJsb2NrIEdyYW1tYXJcbiAqL1xuXG5ibG9jay5nZm0gPSBtZXJnZSh7fSwgYmxvY2subm9ybWFsLCB7XG4gIGZlbmNlczogL14gKihgezMsfXx+ezMsfSkgKihcXFMrKT8gKlxcbihbXFxzXFxTXSs/KVxccypcXDEgKig/Olxcbit8JCkvLFxuICBwYXJhZ3JhcGg6IC9eL1xufSk7XG5cbmJsb2NrLmdmbS5wYXJhZ3JhcGggPSByZXBsYWNlKGJsb2NrLnBhcmFncmFwaClcbiAgKCcoPyEnLCAnKD8hJ1xuICAgICsgYmxvY2suZ2ZtLmZlbmNlcy5zb3VyY2UucmVwbGFjZSgnXFxcXDEnLCAnXFxcXDInKSArICd8J1xuICAgICsgYmxvY2subGlzdC5zb3VyY2UucmVwbGFjZSgnXFxcXDEnLCAnXFxcXDMnKSArICd8JylcbiAgKCk7XG5cbi8qKlxuICogR0ZNICsgVGFibGVzIEJsb2NrIEdyYW1tYXJcbiAqL1xuXG5ibG9jay50YWJsZXMgPSBtZXJnZSh7fSwgYmxvY2suZ2ZtLCB7XG4gIG5wdGFibGU6IC9eICooXFxTLipcXHwuKilcXG4gKihbLTpdKyAqXFx8Wy18IDpdKilcXG4oKD86LipcXHwuKig/OlxcbnwkKSkqKVxcbiovLFxuICB0YWJsZTogL14gKlxcfCguKylcXG4gKlxcfCggKlstOl0rWy18IDpdKilcXG4oKD86ICpcXHwuKig/OlxcbnwkKSkqKVxcbiovXG59KTtcblxuLyoqXG4gKiBCbG9jayBMZXhlclxuICovXG5cbmZ1bmN0aW9uIExleGVyKG9wdGlvbnMpIHtcbiAgdGhpcy50b2tlbnMgPSBbXTtcbiAgdGhpcy50b2tlbnMubGlua3MgPSB7fTtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBtYXJrZWQuZGVmYXVsdHM7XG4gIHRoaXMucnVsZXMgPSBibG9jay5ub3JtYWw7XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5nZm0pIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRhYmxlcykge1xuICAgICAgdGhpcy5ydWxlcyA9IGJsb2NrLnRhYmxlcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ydWxlcyA9IGJsb2NrLmdmbTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBFeHBvc2UgQmxvY2sgUnVsZXNcbiAqL1xuXG5MZXhlci5ydWxlcyA9IGJsb2NrO1xuXG4vKipcbiAqIFN0YXRpYyBMZXggTWV0aG9kXG4gKi9cblxuTGV4ZXIubGV4ID0gZnVuY3Rpb24oc3JjLCBvcHRpb25zKSB7XG4gIHZhciBsZXhlciA9IG5ldyBMZXhlcihvcHRpb25zKTtcbiAgcmV0dXJuIGxleGVyLmxleChzcmMpO1xufTtcblxuLyoqXG4gKiBQcmVwcm9jZXNzaW5nXG4gKi9cblxuTGV4ZXIucHJvdG90eXBlLmxleCA9IGZ1bmN0aW9uKHNyYykge1xuICBzcmMgPSBzcmNcbiAgICAucmVwbGFjZSgvXFxyXFxufFxcci9nLCAnXFxuJylcbiAgICAucmVwbGFjZSgvXFx0L2csICcgICAgJylcbiAgICAucmVwbGFjZSgvXFx1MDBhMC9nLCAnICcpXG4gICAgLnJlcGxhY2UoL1xcdTI0MjQvZywgJ1xcbicpO1xuXG4gIHJldHVybiB0aGlzLnRva2VuKHNyYywgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIExleGluZ1xuICovXG5cbkxleGVyLnByb3RvdHlwZS50b2tlbiA9IGZ1bmN0aW9uKHNyYywgdG9wLCBicSkge1xuICB2YXIgc3JjID0gc3JjLnJlcGxhY2UoL14gKyQvZ20sICcnKVxuICAgICwgbmV4dFxuICAgICwgbG9vc2VcbiAgICAsIGNhcFxuICAgICwgYnVsbFxuICAgICwgYlxuICAgICwgaXRlbVxuICAgICwgc3BhY2VcbiAgICAsIGlcbiAgICAsIGw7XG5cbiAgd2hpbGUgKHNyYykge1xuICAgIC8vIG5ld2xpbmVcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5uZXdsaW5lLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIGlmIChjYXBbMF0ubGVuZ3RoID4gMSkge1xuICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnc3BhY2UnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNvZGVcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5jb2RlLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIGNhcCA9IGNhcFswXS5yZXBsYWNlKC9eIHs0fS9nbSwgJycpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdjb2RlJyxcbiAgICAgICAgdGV4dDogIXRoaXMub3B0aW9ucy5wZWRhbnRpY1xuICAgICAgICAgID8gY2FwLnJlcGxhY2UoL1xcbiskLywgJycpXG4gICAgICAgICAgOiBjYXBcbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZmVuY2VzIChnZm0pXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuZmVuY2VzLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnY29kZScsXG4gICAgICAgIGxhbmc6IGNhcFsyXSxcbiAgICAgICAgdGV4dDogY2FwWzNdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGhlYWRpbmdcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5oZWFkaW5nLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAgIGRlcHRoOiBjYXBbMV0ubGVuZ3RoLFxuICAgICAgICB0ZXh0OiBjYXBbMl1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdGFibGUgbm8gbGVhZGluZyBwaXBlIChnZm0pXG4gICAgaWYgKHRvcCAmJiAoY2FwID0gdGhpcy5ydWxlcy5ucHRhYmxlLmV4ZWMoc3JjKSkpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG5cbiAgICAgIGl0ZW0gPSB7XG4gICAgICAgIHR5cGU6ICd0YWJsZScsXG4gICAgICAgIGhlYWRlcjogY2FwWzFdLnJlcGxhY2UoL14gKnwgKlxcfCAqJC9nLCAnJykuc3BsaXQoLyAqXFx8ICovKSxcbiAgICAgICAgYWxpZ246IGNhcFsyXS5yZXBsYWNlKC9eICp8XFx8ICokL2csICcnKS5zcGxpdCgvICpcXHwgKi8pLFxuICAgICAgICBjZWxsczogY2FwWzNdLnJlcGxhY2UoL1xcbiQvLCAnJykuc3BsaXQoJ1xcbicpXG4gICAgICB9O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbS5hbGlnbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoL14gKi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSs6ICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdjZW50ZXInO1xuICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSsgKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtLmNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZW0uY2VsbHNbaV0gPSBpdGVtLmNlbGxzW2ldLnNwbGl0KC8gKlxcfCAqLyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudG9rZW5zLnB1c2goaXRlbSk7XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGxoZWFkaW5nXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMubGhlYWRpbmcuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdoZWFkaW5nJyxcbiAgICAgICAgZGVwdGg6IGNhcFsyXSA9PT0gJz0nID8gMSA6IDIsXG4gICAgICAgIHRleHQ6IGNhcFsxXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBoclxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmhyLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnaHInXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGJsb2NrcXVvdGVcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5ibG9ja3F1b3RlLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcblxuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdibG9ja3F1b3RlX3N0YXJ0J1xuICAgICAgfSk7XG5cbiAgICAgIGNhcCA9IGNhcFswXS5yZXBsYWNlKC9eICo+ID8vZ20sICcnKTtcblxuICAgICAgLy8gUGFzcyBgdG9wYCB0byBrZWVwIHRoZSBjdXJyZW50XG4gICAgICAvLyBcInRvcGxldmVsXCIgc3RhdGUuIFRoaXMgaXMgZXhhY3RseVxuICAgICAgLy8gaG93IG1hcmtkb3duLnBsIHdvcmtzLlxuICAgICAgdGhpcy50b2tlbihjYXAsIHRvcCwgdHJ1ZSk7XG5cbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnYmxvY2txdW90ZV9lbmQnXG4gICAgICB9KTtcblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gbGlzdFxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmxpc3QuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgYnVsbCA9IGNhcFsyXTtcblxuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdsaXN0X3N0YXJ0JyxcbiAgICAgICAgb3JkZXJlZDogYnVsbC5sZW5ndGggPiAxXG4gICAgICB9KTtcblxuICAgICAgLy8gR2V0IGVhY2ggdG9wLWxldmVsIGl0ZW0uXG4gICAgICBjYXAgPSBjYXBbMF0ubWF0Y2godGhpcy5ydWxlcy5pdGVtKTtcblxuICAgICAgbmV4dCA9IGZhbHNlO1xuICAgICAgbCA9IGNhcC5sZW5ndGg7XG4gICAgICBpID0gMDtcblxuICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IGNhcFtpXTtcblxuICAgICAgICAvLyBSZW1vdmUgdGhlIGxpc3QgaXRlbSdzIGJ1bGxldFxuICAgICAgICAvLyBzbyBpdCBpcyBzZWVuIGFzIHRoZSBuZXh0IHRva2VuLlxuICAgICAgICBzcGFjZSA9IGl0ZW0ubGVuZ3RoO1xuICAgICAgICBpdGVtID0gaXRlbS5yZXBsYWNlKC9eICooWyorLV18XFxkK1xcLikgKy8sICcnKTtcblxuICAgICAgICAvLyBPdXRkZW50IHdoYXRldmVyIHRoZVxuICAgICAgICAvLyBsaXN0IGl0ZW0gY29udGFpbnMuIEhhY2t5LlxuICAgICAgICBpZiAofml0ZW0uaW5kZXhPZignXFxuICcpKSB7XG4gICAgICAgICAgc3BhY2UgLT0gaXRlbS5sZW5ndGg7XG4gICAgICAgICAgaXRlbSA9ICF0aGlzLm9wdGlvbnMucGVkYW50aWNcbiAgICAgICAgICAgID8gaXRlbS5yZXBsYWNlKG5ldyBSZWdFeHAoJ14gezEsJyArIHNwYWNlICsgJ30nLCAnZ20nKSwgJycpXG4gICAgICAgICAgICA6IGl0ZW0ucmVwbGFjZSgvXiB7MSw0fS9nbSwgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIG5leHQgbGlzdCBpdGVtIGJlbG9uZ3MgaGVyZS5cbiAgICAgICAgLy8gQmFja3BlZGFsIGlmIGl0IGRvZXMgbm90IGJlbG9uZyBpbiB0aGlzIGxpc3QuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc21hcnRMaXN0cyAmJiBpICE9PSBsIC0gMSkge1xuICAgICAgICAgIGIgPSBibG9jay5idWxsZXQuZXhlYyhjYXBbaSArIDFdKVswXTtcbiAgICAgICAgICBpZiAoYnVsbCAhPT0gYiAmJiAhKGJ1bGwubGVuZ3RoID4gMSAmJiBiLmxlbmd0aCA+IDEpKSB7XG4gICAgICAgICAgICBzcmMgPSBjYXAuc2xpY2UoaSArIDEpLmpvaW4oJ1xcbicpICsgc3JjO1xuICAgICAgICAgICAgaSA9IGwgLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZSB3aGV0aGVyIGl0ZW0gaXMgbG9vc2Ugb3Igbm90LlxuICAgICAgICAvLyBVc2U6IC8oXnxcXG4pKD8hIClbXlxcbl0rXFxuXFxuKD8hXFxzKiQpL1xuICAgICAgICAvLyBmb3IgZGlzY291bnQgYmVoYXZpb3IuXG4gICAgICAgIGxvb3NlID0gbmV4dCB8fCAvXFxuXFxuKD8hXFxzKiQpLy50ZXN0KGl0ZW0pO1xuICAgICAgICBpZiAoaSAhPT0gbCAtIDEpIHtcbiAgICAgICAgICBuZXh0ID0gaXRlbS5jaGFyQXQoaXRlbS5sZW5ndGggLSAxKSA9PT0gJ1xcbic7XG4gICAgICAgICAgaWYgKCFsb29zZSkgbG9vc2UgPSBuZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogbG9vc2VcbiAgICAgICAgICAgID8gJ2xvb3NlX2l0ZW1fc3RhcnQnXG4gICAgICAgICAgICA6ICdsaXN0X2l0ZW1fc3RhcnQnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFJlY3Vyc2UuXG4gICAgICAgIHRoaXMudG9rZW4oaXRlbSwgZmFsc2UsIGJxKTtcblxuICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnbGlzdF9pdGVtX2VuZCdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnbGlzdF9lbmQnXG4gICAgICB9KTtcblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gaHRtbFxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmh0bWwuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6IHRoaXMub3B0aW9ucy5zYW5pdGl6ZVxuICAgICAgICAgID8gJ3BhcmFncmFwaCdcbiAgICAgICAgICA6ICdodG1sJyxcbiAgICAgICAgcHJlOiBjYXBbMV0gPT09ICdwcmUnIHx8IGNhcFsxXSA9PT0gJ3NjcmlwdCcgfHwgY2FwWzFdID09PSAnc3R5bGUnLFxuICAgICAgICB0ZXh0OiBjYXBbMF1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZGVmXG4gICAgaWYgKCghYnEgJiYgdG9wKSAmJiAoY2FwID0gdGhpcy5ydWxlcy5kZWYuZXhlYyhzcmMpKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLmxpbmtzW2NhcFsxXS50b0xvd2VyQ2FzZSgpXSA9IHtcbiAgICAgICAgaHJlZjogY2FwWzJdLFxuICAgICAgICB0aXRsZTogY2FwWzNdXG4gICAgICB9O1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdGFibGUgKGdmbSlcbiAgICBpZiAodG9wICYmIChjYXAgPSB0aGlzLnJ1bGVzLnRhYmxlLmV4ZWMoc3JjKSkpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG5cbiAgICAgIGl0ZW0gPSB7XG4gICAgICAgIHR5cGU6ICd0YWJsZScsXG4gICAgICAgIGhlYWRlcjogY2FwWzFdLnJlcGxhY2UoL14gKnwgKlxcfCAqJC9nLCAnJykuc3BsaXQoLyAqXFx8ICovKSxcbiAgICAgICAgYWxpZ246IGNhcFsyXS5yZXBsYWNlKC9eICp8XFx8ICokL2csICcnKS5zcGxpdCgvICpcXHwgKi8pLFxuICAgICAgICBjZWxsczogY2FwWzNdLnJlcGxhY2UoLyg/OiAqXFx8ICopP1xcbiQvLCAnJykuc3BsaXQoJ1xcbicpXG4gICAgICB9O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbS5hbGlnbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoL14gKi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSs6ICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdjZW50ZXInO1xuICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSsgKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtLmNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZW0uY2VsbHNbaV0gPSBpdGVtLmNlbGxzW2ldXG4gICAgICAgICAgLnJlcGxhY2UoL14gKlxcfCAqfCAqXFx8ICokL2csICcnKVxuICAgICAgICAgIC5zcGxpdCgvICpcXHwgKi8pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRva2Vucy5wdXNoKGl0ZW0pO1xuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0b3AtbGV2ZWwgcGFyYWdyYXBoXG4gICAgaWYgKHRvcCAmJiAoY2FwID0gdGhpcy5ydWxlcy5wYXJhZ3JhcGguZXhlYyhzcmMpKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAncGFyYWdyYXBoJyxcbiAgICAgICAgdGV4dDogY2FwWzFdLmNoYXJBdChjYXBbMV0ubGVuZ3RoIC0gMSkgPT09ICdcXG4nXG4gICAgICAgICAgPyBjYXBbMV0uc2xpY2UoMCwgLTEpXG4gICAgICAgICAgOiBjYXBbMV1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdGV4dFxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLnRleHQuZXhlYyhzcmMpKSB7XG4gICAgICAvLyBUb3AtbGV2ZWwgc2hvdWxkIG5ldmVyIHJlYWNoIGhlcmUuXG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgdGV4dDogY2FwWzBdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChzcmMpIHtcbiAgICAgIHRocm93IG5ld1xuICAgICAgICBFcnJvcignSW5maW5pdGUgbG9vcCBvbiBieXRlOiAnICsgc3JjLmNoYXJDb2RlQXQoMCkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzLnRva2Vucztcbn07XG5cbi8qKlxuICogSW5saW5lLUxldmVsIEdyYW1tYXJcbiAqL1xuXG52YXIgaW5saW5lID0ge1xuICBlc2NhcGU6IC9eXFxcXChbXFxcXGAqe31cXFtcXF0oKSMrXFwtLiFfPl0pLyxcbiAgYXV0b2xpbms6IC9ePChbXiA+XSsoQHw6XFwvKVteID5dKyk+LyxcbiAgdXJsOiBub29wLFxuICB0YWc6IC9ePCEtLVtcXHNcXFNdKj8tLT58XjxcXC8/XFx3Kyg/OlwiW15cIl0qXCJ8J1teJ10qJ3xbXidcIj5dKSo/Pi8sXG4gIGxpbms6IC9eIT9cXFsoaW5zaWRlKVxcXVxcKGhyZWZcXCkvLFxuICByZWZsaW5rOiAvXiE/XFxbKGluc2lkZSlcXF1cXHMqXFxbKFteXFxdXSopXFxdLyxcbiAgbm9saW5rOiAvXiE/XFxbKCg/OlxcW1teXFxdXSpcXF18W15cXFtcXF1dKSopXFxdLyxcbiAgc3Ryb25nOiAvXl9fKFtcXHNcXFNdKz8pX18oPyFfKXxeXFwqXFwqKFtcXHNcXFNdKz8pXFwqXFwqKD8hXFwqKS8sXG4gIGVtOiAvXlxcYl8oKD86X198W1xcc1xcU10pKz8pX1xcYnxeXFwqKCg/OlxcKlxcKnxbXFxzXFxTXSkrPylcXCooPyFcXCopLyxcbiAgY29kZTogL14oYCspXFxzKihbXFxzXFxTXSo/W15gXSlcXHMqXFwxKD8hYCkvLFxuICBicjogL14gezIsfVxcbig/IVxccyokKS8sXG4gIGRlbDogbm9vcCxcbiAgdGV4dDogL15bXFxzXFxTXSs/KD89W1xcXFw8IVxcW18qYF18IHsyLH1cXG58JCkvXG59O1xuXG5pbmxpbmUuX2luc2lkZSA9IC8oPzpcXFtbXlxcXV0qXFxdfFteXFxbXFxdXXxcXF0oPz1bXlxcW10qXFxdKSkqLztcbmlubGluZS5faHJlZiA9IC9cXHMqPD8oW1xcc1xcU10qPyk+Pyg/OlxccytbJ1wiXShbXFxzXFxTXSo/KVsnXCJdKT9cXHMqLztcblxuaW5saW5lLmxpbmsgPSByZXBsYWNlKGlubGluZS5saW5rKVxuICAoJ2luc2lkZScsIGlubGluZS5faW5zaWRlKVxuICAoJ2hyZWYnLCBpbmxpbmUuX2hyZWYpXG4gICgpO1xuXG5pbmxpbmUucmVmbGluayA9IHJlcGxhY2UoaW5saW5lLnJlZmxpbmspXG4gICgnaW5zaWRlJywgaW5saW5lLl9pbnNpZGUpXG4gICgpO1xuXG4vKipcbiAqIE5vcm1hbCBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5ub3JtYWwgPSBtZXJnZSh7fSwgaW5saW5lKTtcblxuLyoqXG4gKiBQZWRhbnRpYyBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5wZWRhbnRpYyA9IG1lcmdlKHt9LCBpbmxpbmUubm9ybWFsLCB7XG4gIHN0cm9uZzogL15fXyg/PVxcUykoW1xcc1xcU10qP1xcUylfXyg/IV8pfF5cXCpcXCooPz1cXFMpKFtcXHNcXFNdKj9cXFMpXFwqXFwqKD8hXFwqKS8sXG4gIGVtOiAvXl8oPz1cXFMpKFtcXHNcXFNdKj9cXFMpXyg/IV8pfF5cXCooPz1cXFMpKFtcXHNcXFNdKj9cXFMpXFwqKD8hXFwqKS9cbn0pO1xuXG4vKipcbiAqIEdGTSBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5nZm0gPSBtZXJnZSh7fSwgaW5saW5lLm5vcm1hbCwge1xuICBlc2NhcGU6IHJlcGxhY2UoaW5saW5lLmVzY2FwZSkoJ10pJywgJ358XSknKSgpLFxuICB1cmw6IC9eKGh0dHBzPzpcXC9cXC9bXlxcczxdK1tePC4sOjtcIicpXFxdXFxzXSkvLFxuICBkZWw6IC9efn4oPz1cXFMpKFtcXHNcXFNdKj9cXFMpfn4vLFxuICB0ZXh0OiByZXBsYWNlKGlubGluZS50ZXh0KVxuICAgICgnXXwnLCAnfl18JylcbiAgICAoJ3wnLCAnfGh0dHBzPzovL3wnKVxuICAgICgpXG59KTtcblxuLyoqXG4gKiBHRk0gKyBMaW5lIEJyZWFrcyBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5icmVha3MgPSBtZXJnZSh7fSwgaW5saW5lLmdmbSwge1xuICBicjogcmVwbGFjZShpbmxpbmUuYnIpKCd7Mix9JywgJyonKSgpLFxuICB0ZXh0OiByZXBsYWNlKGlubGluZS5nZm0udGV4dCkoJ3syLH0nLCAnKicpKClcbn0pO1xuXG4vKipcbiAqIElubGluZSBMZXhlciAmIENvbXBpbGVyXG4gKi9cblxuZnVuY3Rpb24gSW5saW5lTGV4ZXIobGlua3MsIG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBtYXJrZWQuZGVmYXVsdHM7XG4gIHRoaXMubGlua3MgPSBsaW5rcztcbiAgdGhpcy5ydWxlcyA9IGlubGluZS5ub3JtYWw7XG4gIHRoaXMucmVuZGVyZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgbmV3IFJlbmRlcmVyO1xuICB0aGlzLnJlbmRlcmVyLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgaWYgKCF0aGlzLmxpbmtzKSB7XG4gICAgdGhyb3cgbmV3XG4gICAgICBFcnJvcignVG9rZW5zIGFycmF5IHJlcXVpcmVzIGEgYGxpbmtzYCBwcm9wZXJ0eS4nKTtcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMuZ2ZtKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5icmVha3MpIHtcbiAgICAgIHRoaXMucnVsZXMgPSBpbmxpbmUuYnJlYWtzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJ1bGVzID0gaW5saW5lLmdmbTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgdGhpcy5ydWxlcyA9IGlubGluZS5wZWRhbnRpYztcbiAgfVxufVxuXG4vKipcbiAqIEV4cG9zZSBJbmxpbmUgUnVsZXNcbiAqL1xuXG5JbmxpbmVMZXhlci5ydWxlcyA9IGlubGluZTtcblxuLyoqXG4gKiBTdGF0aWMgTGV4aW5nL0NvbXBpbGluZyBNZXRob2RcbiAqL1xuXG5JbmxpbmVMZXhlci5vdXRwdXQgPSBmdW5jdGlvbihzcmMsIGxpbmtzLCBvcHRpb25zKSB7XG4gIHZhciBpbmxpbmUgPSBuZXcgSW5saW5lTGV4ZXIobGlua3MsIG9wdGlvbnMpO1xuICByZXR1cm4gaW5saW5lLm91dHB1dChzcmMpO1xufTtcblxuLyoqXG4gKiBMZXhpbmcvQ29tcGlsaW5nXG4gKi9cblxuSW5saW5lTGV4ZXIucHJvdG90eXBlLm91dHB1dCA9IGZ1bmN0aW9uKHNyYykge1xuICB2YXIgb3V0ID0gJydcbiAgICAsIGxpbmtcbiAgICAsIHRleHRcbiAgICAsIGhyZWZcbiAgICAsIGNhcDtcblxuICB3aGlsZSAoc3JjKSB7XG4gICAgLy8gZXNjYXBlXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuZXNjYXBlLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSBjYXBbMV07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBhdXRvbGlua1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmF1dG9saW5rLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIGlmIChjYXBbMl0gPT09ICdAJykge1xuICAgICAgICB0ZXh0ID0gY2FwWzFdLmNoYXJBdCg2KSA9PT0gJzonXG4gICAgICAgICAgPyB0aGlzLm1hbmdsZShjYXBbMV0uc3Vic3RyaW5nKDcpKVxuICAgICAgICAgIDogdGhpcy5tYW5nbGUoY2FwWzFdKTtcbiAgICAgICAgaHJlZiA9IHRoaXMubWFuZ2xlKCdtYWlsdG86JykgKyB0ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dCA9IGVzY2FwZShjYXBbMV0pO1xuICAgICAgICBocmVmID0gdGV4dDtcbiAgICAgIH1cbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmxpbmsoaHJlZiwgbnVsbCwgdGV4dCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB1cmwgKGdmbSlcbiAgICBpZiAoIXRoaXMuaW5MaW5rICYmIChjYXAgPSB0aGlzLnJ1bGVzLnVybC5leGVjKHNyYykpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGV4dCA9IGVzY2FwZShjYXBbMV0pO1xuICAgICAgaHJlZiA9IHRleHQ7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5saW5rKGhyZWYsIG51bGwsIHRleHQpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdGFnXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMudGFnLmV4ZWMoc3JjKSkge1xuICAgICAgaWYgKCF0aGlzLmluTGluayAmJiAvXjxhIC9pLnRlc3QoY2FwWzBdKSkge1xuICAgICAgICB0aGlzLmluTGluayA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaW5MaW5rICYmIC9ePFxcL2E+L2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgIHRoaXMuaW5MaW5rID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMub3B0aW9ucy5zYW5pdGl6ZVxuICAgICAgICA/IGVzY2FwZShjYXBbMF0pXG4gICAgICAgIDogY2FwWzBdO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gbGlua1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmxpbmsuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy5pbkxpbmsgPSB0cnVlO1xuICAgICAgb3V0ICs9IHRoaXMub3V0cHV0TGluayhjYXAsIHtcbiAgICAgICAgaHJlZjogY2FwWzJdLFxuICAgICAgICB0aXRsZTogY2FwWzNdXG4gICAgICB9KTtcbiAgICAgIHRoaXMuaW5MaW5rID0gZmFsc2U7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyByZWZsaW5rLCBub2xpbmtcbiAgICBpZiAoKGNhcCA9IHRoaXMucnVsZXMucmVmbGluay5leGVjKHNyYykpXG4gICAgICAgIHx8IChjYXAgPSB0aGlzLnJ1bGVzLm5vbGluay5leGVjKHNyYykpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgbGluayA9IChjYXBbMl0gfHwgY2FwWzFdKS5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG4gICAgICBsaW5rID0gdGhpcy5saW5rc1tsaW5rLnRvTG93ZXJDYXNlKCldO1xuICAgICAgaWYgKCFsaW5rIHx8ICFsaW5rLmhyZWYpIHtcbiAgICAgICAgb3V0ICs9IGNhcFswXS5jaGFyQXQoMCk7XG4gICAgICAgIHNyYyA9IGNhcFswXS5zdWJzdHJpbmcoMSkgKyBzcmM7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5pbkxpbmsgPSB0cnVlO1xuICAgICAgb3V0ICs9IHRoaXMub3V0cHV0TGluayhjYXAsIGxpbmspO1xuICAgICAgdGhpcy5pbkxpbmsgPSBmYWxzZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHN0cm9uZ1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLnN0cm9uZy5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5zdHJvbmcodGhpcy5vdXRwdXQoY2FwWzJdIHx8IGNhcFsxXSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZW1cbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5lbS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5lbSh0aGlzLm91dHB1dChjYXBbMl0gfHwgY2FwWzFdKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBjb2RlXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuY29kZS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5jb2Rlc3Bhbihlc2NhcGUoY2FwWzJdLCB0cnVlKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBiclxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmJyLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmJyKCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBkZWwgKGdmbSlcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5kZWwuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuZGVsKHRoaXMub3V0cHV0KGNhcFsxXSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdGV4dFxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLnRleHQuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IGVzY2FwZSh0aGlzLnNtYXJ0eXBhbnRzKGNhcFswXSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHNyYykge1xuICAgICAgdGhyb3cgbmV3XG4gICAgICAgIEVycm9yKCdJbmZpbml0ZSBsb29wIG9uIGJ5dGU6ICcgKyBzcmMuY2hhckNvZGVBdCgwKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29tcGlsZSBMaW5rXG4gKi9cblxuSW5saW5lTGV4ZXIucHJvdG90eXBlLm91dHB1dExpbmsgPSBmdW5jdGlvbihjYXAsIGxpbmspIHtcbiAgdmFyIGhyZWYgPSBlc2NhcGUobGluay5ocmVmKVxuICAgICwgdGl0bGUgPSBsaW5rLnRpdGxlID8gZXNjYXBlKGxpbmsudGl0bGUpIDogbnVsbDtcblxuICByZXR1cm4gY2FwWzBdLmNoYXJBdCgwKSAhPT0gJyEnXG4gICAgPyB0aGlzLnJlbmRlcmVyLmxpbmsoaHJlZiwgdGl0bGUsIHRoaXMub3V0cHV0KGNhcFsxXSkpXG4gICAgOiB0aGlzLnJlbmRlcmVyLmltYWdlKGhyZWYsIHRpdGxlLCBlc2NhcGUoY2FwWzFdKSk7XG59O1xuXG4vKipcbiAqIFNtYXJ0eXBhbnRzIFRyYW5zZm9ybWF0aW9uc1xuICovXG5cbklubGluZUxleGVyLnByb3RvdHlwZS5zbWFydHlwYW50cyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgaWYgKCF0aGlzLm9wdGlvbnMuc21hcnR5cGFudHMpIHJldHVybiB0ZXh0O1xuICByZXR1cm4gdGV4dFxuICAgIC8vIGVtLWRhc2hlc1xuICAgIC5yZXBsYWNlKC8tLS9nLCAnXFx1MjAxNCcpXG4gICAgLy8gb3BlbmluZyBzaW5nbGVzXG4gICAgLnJlcGxhY2UoLyhefFstXFx1MjAxNC8oXFxbe1wiXFxzXSknL2csICckMVxcdTIwMTgnKVxuICAgIC8vIGNsb3Npbmcgc2luZ2xlcyAmIGFwb3N0cm9waGVzXG4gICAgLnJlcGxhY2UoLycvZywgJ1xcdTIwMTknKVxuICAgIC8vIG9wZW5pbmcgZG91Ymxlc1xuICAgIC5yZXBsYWNlKC8oXnxbLVxcdTIwMTQvKFxcW3tcXHUyMDE4XFxzXSlcIi9nLCAnJDFcXHUyMDFjJylcbiAgICAvLyBjbG9zaW5nIGRvdWJsZXNcbiAgICAucmVwbGFjZSgvXCIvZywgJ1xcdTIwMWQnKVxuICAgIC8vIGVsbGlwc2VzXG4gICAgLnJlcGxhY2UoL1xcLnszfS9nLCAnXFx1MjAyNicpO1xufTtcblxuLyoqXG4gKiBNYW5nbGUgTGlua3NcbiAqL1xuXG5JbmxpbmVMZXhlci5wcm90b3R5cGUubWFuZ2xlID0gZnVuY3Rpb24odGV4dCkge1xuICB2YXIgb3V0ID0gJydcbiAgICAsIGwgPSB0ZXh0Lmxlbmd0aFxuICAgICwgaSA9IDBcbiAgICAsIGNoO1xuXG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgY2ggPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjUpIHtcbiAgICAgIGNoID0gJ3gnICsgY2gudG9TdHJpbmcoMTYpO1xuICAgIH1cbiAgICBvdXQgKz0gJyYjJyArIGNoICsgJzsnO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmVuZGVyZXJcbiAqL1xuXG5mdW5jdGlvbiBSZW5kZXJlcihvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG59XG5cblJlbmRlcmVyLnByb3RvdHlwZS5jb2RlID0gZnVuY3Rpb24oY29kZSwgbGFuZywgZXNjYXBlZCkge1xuICBpZiAodGhpcy5vcHRpb25zLmhpZ2hsaWdodCkge1xuICAgIHZhciBvdXQgPSB0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0KGNvZGUsIGxhbmcpO1xuICAgIGlmIChvdXQgIT0gbnVsbCAmJiBvdXQgIT09IGNvZGUpIHtcbiAgICAgIGVzY2FwZWQgPSB0cnVlO1xuICAgICAgY29kZSA9IG91dDtcbiAgICB9XG4gIH1cblxuICBpZiAoIWxhbmcpIHtcbiAgICByZXR1cm4gJzxwcmU+PGNvZGU+J1xuICAgICAgKyAoZXNjYXBlZCA/IGNvZGUgOiBlc2NhcGUoY29kZSwgdHJ1ZSkpXG4gICAgICArICdcXG48L2NvZGU+PC9wcmU+JztcbiAgfVxuXG4gIHJldHVybiAnPHByZT48Y29kZSBjbGFzcz1cIidcbiAgICArIHRoaXMub3B0aW9ucy5sYW5nUHJlZml4XG4gICAgKyBlc2NhcGUobGFuZywgdHJ1ZSlcbiAgICArICdcIj4nXG4gICAgKyAoZXNjYXBlZCA/IGNvZGUgOiBlc2NhcGUoY29kZSwgdHJ1ZSkpXG4gICAgKyAnXFxuPC9jb2RlPjwvcHJlPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuYmxvY2txdW90ZSA9IGZ1bmN0aW9uKHF1b3RlKSB7XG4gIHJldHVybiAnPGJsb2NrcXVvdGU+XFxuJyArIHF1b3RlICsgJzwvYmxvY2txdW90ZT5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmh0bWwgPSBmdW5jdGlvbihodG1sKSB7XG4gIHJldHVybiBodG1sO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmhlYWRpbmcgPSBmdW5jdGlvbih0ZXh0LCBsZXZlbCwgcmF3KSB7XG4gIHJldHVybiAnPGgnXG4gICAgKyBsZXZlbFxuICAgICsgJyBpZD1cIidcbiAgICArIHRoaXMub3B0aW9ucy5oZWFkZXJQcmVmaXhcbiAgICArIHJhdy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1teXFx3XSsvZywgJy0nKVxuICAgICsgJ1wiPidcbiAgICArIHRleHRcbiAgICArICc8L2gnXG4gICAgKyBsZXZlbFxuICAgICsgJz5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmhyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm9wdGlvbnMueGh0bWwgPyAnPGhyLz5cXG4nIDogJzxocj5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmxpc3QgPSBmdW5jdGlvbihib2R5LCBvcmRlcmVkKSB7XG4gIHZhciB0eXBlID0gb3JkZXJlZCA/ICdvbCcgOiAndWwnO1xuICByZXR1cm4gJzwnICsgdHlwZSArICc+XFxuJyArIGJvZHkgKyAnPC8nICsgdHlwZSArICc+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5saXN0aXRlbSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8bGk+JyArIHRleHQgKyAnPC9saT5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnBhcmFncmFwaCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8cD4nICsgdGV4dCArICc8L3A+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS50YWJsZSA9IGZ1bmN0aW9uKGhlYWRlciwgYm9keSkge1xuICByZXR1cm4gJzx0YWJsZT5cXG4nXG4gICAgKyAnPHRoZWFkPlxcbidcbiAgICArIGhlYWRlclxuICAgICsgJzwvdGhlYWQ+XFxuJ1xuICAgICsgJzx0Ym9keT5cXG4nXG4gICAgKyBib2R5XG4gICAgKyAnPC90Ym9keT5cXG4nXG4gICAgKyAnPC90YWJsZT5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnRhYmxlcm93ID0gZnVuY3Rpb24oY29udGVudCkge1xuICByZXR1cm4gJzx0cj5cXG4nICsgY29udGVudCArICc8L3RyPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUudGFibGVjZWxsID0gZnVuY3Rpb24oY29udGVudCwgZmxhZ3MpIHtcbiAgdmFyIHR5cGUgPSBmbGFncy5oZWFkZXIgPyAndGgnIDogJ3RkJztcbiAgdmFyIHRhZyA9IGZsYWdzLmFsaWduXG4gICAgPyAnPCcgKyB0eXBlICsgJyBzdHlsZT1cInRleHQtYWxpZ246JyArIGZsYWdzLmFsaWduICsgJ1wiPidcbiAgICA6ICc8JyArIHR5cGUgKyAnPic7XG4gIHJldHVybiB0YWcgKyBjb250ZW50ICsgJzwvJyArIHR5cGUgKyAnPlxcbic7XG59O1xuXG4vLyBzcGFuIGxldmVsIHJlbmRlcmVyXG5SZW5kZXJlci5wcm90b3R5cGUuc3Ryb25nID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxzdHJvbmc+JyArIHRleHQgKyAnPC9zdHJvbmc+Jztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5lbSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8ZW0+JyArIHRleHQgKyAnPC9lbT4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmNvZGVzcGFuID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxjb2RlPicgKyB0ZXh0ICsgJzwvY29kZT4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmJyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm9wdGlvbnMueGh0bWwgPyAnPGJyLz4nIDogJzxicj4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8ZGVsPicgKyB0ZXh0ICsgJzwvZGVsPic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUubGluayA9IGZ1bmN0aW9uKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuc2FuaXRpemUpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHByb3QgPSBkZWNvZGVVUklDb21wb25lbnQodW5lc2NhcGUoaHJlZikpXG4gICAgICAgIC5yZXBsYWNlKC9bXlxcdzpdL2csICcnKVxuICAgICAgICAudG9Mb3dlckNhc2UoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGlmIChwcm90LmluZGV4T2YoJ2phdmFzY3JpcHQ6JykgPT09IDAgfHwgcHJvdC5pbmRleE9mKCd2YnNjcmlwdDonKSA9PT0gMCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfVxuICB2YXIgb3V0ID0gJzxhIGhyZWY9XCInICsgaHJlZiArICdcIic7XG4gIGlmICh0aXRsZSkge1xuICAgIG91dCArPSAnIHRpdGxlPVwiJyArIHRpdGxlICsgJ1wiJztcbiAgfVxuICBvdXQgKz0gJz4nICsgdGV4dCArICc8L2E+JztcbiAgcmV0dXJuIG91dDtcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5pbWFnZSA9IGZ1bmN0aW9uKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gIHZhciBvdXQgPSAnPGltZyBzcmM9XCInICsgaHJlZiArICdcIiBhbHQ9XCInICsgdGV4dCArICdcIic7XG4gIGlmICh0aXRsZSkge1xuICAgIG91dCArPSAnIHRpdGxlPVwiJyArIHRpdGxlICsgJ1wiJztcbiAgfVxuICBvdXQgKz0gdGhpcy5vcHRpb25zLnhodG1sID8gJy8+JyA6ICc+JztcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGFyc2luZyAmIENvbXBpbGluZ1xuICovXG5cbmZ1bmN0aW9uIFBhcnNlcihvcHRpb25zKSB7XG4gIHRoaXMudG9rZW5zID0gW107XG4gIHRoaXMudG9rZW4gPSBudWxsO1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IG1hcmtlZC5kZWZhdWx0cztcbiAgdGhpcy5vcHRpb25zLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyIHx8IG5ldyBSZW5kZXJlcjtcbiAgdGhpcy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlcjtcbiAgdGhpcy5yZW5kZXJlci5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xufVxuXG4vKipcbiAqIFN0YXRpYyBQYXJzZSBNZXRob2RcbiAqL1xuXG5QYXJzZXIucGFyc2UgPSBmdW5jdGlvbihzcmMsIG9wdGlvbnMsIHJlbmRlcmVyKSB7XG4gIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMsIHJlbmRlcmVyKTtcbiAgcmV0dXJuIHBhcnNlci5wYXJzZShzcmMpO1xufTtcblxuLyoqXG4gKiBQYXJzZSBMb29wXG4gKi9cblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHNyYykge1xuICB0aGlzLmlubGluZSA9IG5ldyBJbmxpbmVMZXhlcihzcmMubGlua3MsIHRoaXMub3B0aW9ucywgdGhpcy5yZW5kZXJlcik7XG4gIHRoaXMudG9rZW5zID0gc3JjLnJldmVyc2UoKTtcblxuICB2YXIgb3V0ID0gJyc7XG4gIHdoaWxlICh0aGlzLm5leHQoKSkge1xuICAgIG91dCArPSB0aGlzLnRvaygpO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTmV4dCBUb2tlblxuICovXG5cblBhcnNlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50b2tlbiA9IHRoaXMudG9rZW5zLnBvcCgpO1xufTtcblxuLyoqXG4gKiBQcmV2aWV3IE5leHQgVG9rZW5cbiAqL1xuXG5QYXJzZXIucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9rZW5zW3RoaXMudG9rZW5zLmxlbmd0aCAtIDFdIHx8IDA7XG59O1xuXG4vKipcbiAqIFBhcnNlIFRleHQgVG9rZW5zXG4gKi9cblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRleHQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJvZHkgPSB0aGlzLnRva2VuLnRleHQ7XG5cbiAgd2hpbGUgKHRoaXMucGVlaygpLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgIGJvZHkgKz0gJ1xcbicgKyB0aGlzLm5leHQoKS50ZXh0O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuaW5saW5lLm91dHB1dChib2R5KTtcbn07XG5cbi8qKlxuICogUGFyc2UgQ3VycmVudCBUb2tlblxuICovXG5cblBhcnNlci5wcm90b3R5cGUudG9rID0gZnVuY3Rpb24oKSB7XG4gIHN3aXRjaCAodGhpcy50b2tlbi50eXBlKSB7XG4gICAgY2FzZSAnc3BhY2UnOiB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGNhc2UgJ2hyJzoge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuaHIoKTtcbiAgICB9XG4gICAgY2FzZSAnaGVhZGluZyc6IHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmhlYWRpbmcoXG4gICAgICAgIHRoaXMuaW5saW5lLm91dHB1dCh0aGlzLnRva2VuLnRleHQpLFxuICAgICAgICB0aGlzLnRva2VuLmRlcHRoLFxuICAgICAgICB0aGlzLnRva2VuLnRleHQpO1xuICAgIH1cbiAgICBjYXNlICdjb2RlJzoge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuY29kZSh0aGlzLnRva2VuLnRleHQsXG4gICAgICAgIHRoaXMudG9rZW4ubGFuZyxcbiAgICAgICAgdGhpcy50b2tlbi5lc2NhcGVkKTtcbiAgICB9XG4gICAgY2FzZSAndGFibGUnOiB7XG4gICAgICB2YXIgaGVhZGVyID0gJydcbiAgICAgICAgLCBib2R5ID0gJydcbiAgICAgICAgLCBpXG4gICAgICAgICwgcm93XG4gICAgICAgICwgY2VsbFxuICAgICAgICAsIGZsYWdzXG4gICAgICAgICwgajtcblxuICAgICAgLy8gaGVhZGVyXG4gICAgICBjZWxsID0gJyc7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy50b2tlbi5oZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZmxhZ3MgPSB7IGhlYWRlcjogdHJ1ZSwgYWxpZ246IHRoaXMudG9rZW4uYWxpZ25baV0gfTtcbiAgICAgICAgY2VsbCArPSB0aGlzLnJlbmRlcmVyLnRhYmxlY2VsbChcbiAgICAgICAgICB0aGlzLmlubGluZS5vdXRwdXQodGhpcy50b2tlbi5oZWFkZXJbaV0pLFxuICAgICAgICAgIHsgaGVhZGVyOiB0cnVlLCBhbGlnbjogdGhpcy50b2tlbi5hbGlnbltpXSB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBoZWFkZXIgKz0gdGhpcy5yZW5kZXJlci50YWJsZXJvdyhjZWxsKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMudG9rZW4uY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcm93ID0gdGhpcy50b2tlbi5jZWxsc1tpXTtcblxuICAgICAgICBjZWxsID0gJyc7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCByb3cubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjZWxsICs9IHRoaXMucmVuZGVyZXIudGFibGVjZWxsKFxuICAgICAgICAgICAgdGhpcy5pbmxpbmUub3V0cHV0KHJvd1tqXSksXG4gICAgICAgICAgICB7IGhlYWRlcjogZmFsc2UsIGFsaWduOiB0aGlzLnRva2VuLmFsaWduW2pdIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgYm9keSArPSB0aGlzLnJlbmRlcmVyLnRhYmxlcm93KGNlbGwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIudGFibGUoaGVhZGVyLCBib2R5KTtcbiAgICB9XG4gICAgY2FzZSAnYmxvY2txdW90ZV9zdGFydCc6IHtcbiAgICAgIHZhciBib2R5ID0gJyc7XG5cbiAgICAgIHdoaWxlICh0aGlzLm5leHQoKS50eXBlICE9PSAnYmxvY2txdW90ZV9lbmQnKSB7XG4gICAgICAgIGJvZHkgKz0gdGhpcy50b2soKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuYmxvY2txdW90ZShib2R5KTtcbiAgICB9XG4gICAgY2FzZSAnbGlzdF9zdGFydCc6IHtcbiAgICAgIHZhciBib2R5ID0gJydcbiAgICAgICAgLCBvcmRlcmVkID0gdGhpcy50b2tlbi5vcmRlcmVkO1xuXG4gICAgICB3aGlsZSAodGhpcy5uZXh0KCkudHlwZSAhPT0gJ2xpc3RfZW5kJykge1xuICAgICAgICBib2R5ICs9IHRoaXMudG9rKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmxpc3QoYm9keSwgb3JkZXJlZCk7XG4gICAgfVxuICAgIGNhc2UgJ2xpc3RfaXRlbV9zdGFydCc6IHtcbiAgICAgIHZhciBib2R5ID0gJyc7XG5cbiAgICAgIHdoaWxlICh0aGlzLm5leHQoKS50eXBlICE9PSAnbGlzdF9pdGVtX2VuZCcpIHtcbiAgICAgICAgYm9keSArPSB0aGlzLnRva2VuLnR5cGUgPT09ICd0ZXh0J1xuICAgICAgICAgID8gdGhpcy5wYXJzZVRleHQoKVxuICAgICAgICAgIDogdGhpcy50b2soKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIubGlzdGl0ZW0oYm9keSk7XG4gICAgfVxuICAgIGNhc2UgJ2xvb3NlX2l0ZW1fc3RhcnQnOiB7XG4gICAgICB2YXIgYm9keSA9ICcnO1xuXG4gICAgICB3aGlsZSAodGhpcy5uZXh0KCkudHlwZSAhPT0gJ2xpc3RfaXRlbV9lbmQnKSB7XG4gICAgICAgIGJvZHkgKz0gdGhpcy50b2soKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIubGlzdGl0ZW0oYm9keSk7XG4gICAgfVxuICAgIGNhc2UgJ2h0bWwnOiB7XG4gICAgICB2YXIgaHRtbCA9ICF0aGlzLnRva2VuLnByZSAmJiAhdGhpcy5vcHRpb25zLnBlZGFudGljXG4gICAgICAgID8gdGhpcy5pbmxpbmUub3V0cHV0KHRoaXMudG9rZW4udGV4dClcbiAgICAgICAgOiB0aGlzLnRva2VuLnRleHQ7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5odG1sKGh0bWwpO1xuICAgIH1cbiAgICBjYXNlICdwYXJhZ3JhcGgnOiB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5wYXJhZ3JhcGgodGhpcy5pbmxpbmUub3V0cHV0KHRoaXMudG9rZW4udGV4dCkpO1xuICAgIH1cbiAgICBjYXNlICd0ZXh0Jzoge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIucGFyYWdyYXBoKHRoaXMucGFyc2VUZXh0KCkpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBIZWxwZXJzXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlKGh0bWwsIGVuY29kZSkge1xuICByZXR1cm4gaHRtbFxuICAgIC5yZXBsYWNlKCFlbmNvZGUgPyAvJig/ISM/XFx3KzspL2cgOiAvJi9nLCAnJmFtcDsnKVxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKVxuICAgIC5yZXBsYWNlKC8nL2csICcmIzM5OycpO1xufVxuXG5mdW5jdGlvbiB1bmVzY2FwZShodG1sKSB7XG4gIHJldHVybiBodG1sLnJlcGxhY2UoLyYoWyNcXHddKyk7L2csIGZ1bmN0aW9uKF8sIG4pIHtcbiAgICBuID0gbi50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChuID09PSAnY29sb24nKSByZXR1cm4gJzonO1xuICAgIGlmIChuLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICByZXR1cm4gbi5jaGFyQXQoMSkgPT09ICd4J1xuICAgICAgICA/IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQobi5zdWJzdHJpbmcoMiksIDE2KSlcbiAgICAgICAgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKCtuLnN1YnN0cmluZygxKSk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2UocmVnZXgsIG9wdCkge1xuICByZWdleCA9IHJlZ2V4LnNvdXJjZTtcbiAgb3B0ID0gb3B0IHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb24gc2VsZihuYW1lLCB2YWwpIHtcbiAgICBpZiAoIW5hbWUpIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4LCBvcHQpO1xuICAgIHZhbCA9IHZhbC5zb3VyY2UgfHwgdmFsO1xuICAgIHZhbCA9IHZhbC5yZXBsYWNlKC8oXnxbXlxcW10pXFxeL2csICckMScpO1xuICAgIHJlZ2V4ID0gcmVnZXgucmVwbGFjZShuYW1lLCB2YWwpO1xuICAgIHJldHVybiBzZWxmO1xuICB9O1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cbm5vb3AuZXhlYyA9IG5vb3A7XG5cbmZ1bmN0aW9uIG1lcmdlKG9iaikge1xuICB2YXIgaSA9IDFcbiAgICAsIHRhcmdldFxuICAgICwga2V5O1xuXG4gIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGFyZ2V0ID0gYXJndW1lbnRzW2ldO1xuICAgIGZvciAoa2V5IGluIHRhcmdldCkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkpIHtcbiAgICAgICAgb2JqW2tleV0gPSB0YXJnZXRba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5cbi8qKlxuICogTWFya2VkXG4gKi9cblxuZnVuY3Rpb24gbWFya2VkKHNyYywgb3B0LCBjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2sgfHwgdHlwZW9mIG9wdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0O1xuICAgICAgb3B0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBvcHQgPSBtZXJnZSh7fSwgbWFya2VkLmRlZmF1bHRzLCBvcHQgfHwge30pO1xuXG4gICAgdmFyIGhpZ2hsaWdodCA9IG9wdC5oaWdobGlnaHRcbiAgICAgICwgdG9rZW5zXG4gICAgICAsIHBlbmRpbmdcbiAgICAgICwgaSA9IDA7XG5cbiAgICB0cnkge1xuICAgICAgdG9rZW5zID0gTGV4ZXIubGV4KHNyYywgb3B0KVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlKTtcbiAgICB9XG5cbiAgICBwZW5kaW5nID0gdG9rZW5zLmxlbmd0aDtcblxuICAgIHZhciBkb25lID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIG9wdC5oaWdobGlnaHQgPSBoaWdobGlnaHQ7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3V0O1xuXG4gICAgICB0cnkge1xuICAgICAgICBvdXQgPSBQYXJzZXIucGFyc2UodG9rZW5zLCBvcHQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnIgPSBlO1xuICAgICAgfVxuXG4gICAgICBvcHQuaGlnaGxpZ2h0ID0gaGlnaGxpZ2h0O1xuXG4gICAgICByZXR1cm4gZXJyXG4gICAgICAgID8gY2FsbGJhY2soZXJyKVxuICAgICAgICA6IGNhbGxiYWNrKG51bGwsIG91dCk7XG4gICAgfTtcblxuICAgIGlmICghaGlnaGxpZ2h0IHx8IGhpZ2hsaWdodC5sZW5ndGggPCAzKSB7XG4gICAgICByZXR1cm4gZG9uZSgpO1xuICAgIH1cblxuICAgIGRlbGV0ZSBvcHQuaGlnaGxpZ2h0O1xuXG4gICAgaWYgKCFwZW5kaW5nKSByZXR1cm4gZG9uZSgpO1xuXG4gICAgZm9yICg7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIChmdW5jdGlvbih0b2tlbikge1xuICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gJ2NvZGUnKSB7XG4gICAgICAgICAgcmV0dXJuIC0tcGVuZGluZyB8fCBkb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhpZ2hsaWdodCh0b2tlbi50ZXh0LCB0b2tlbi5sYW5nLCBmdW5jdGlvbihlcnIsIGNvZGUpIHtcbiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gZG9uZShlcnIpO1xuICAgICAgICAgIGlmIChjb2RlID09IG51bGwgfHwgY29kZSA9PT0gdG9rZW4udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIC0tcGVuZGluZyB8fCBkb25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRva2VuLnRleHQgPSBjb2RlO1xuICAgICAgICAgIHRva2VuLmVzY2FwZWQgPSB0cnVlO1xuICAgICAgICAgIC0tcGVuZGluZyB8fCBkb25lKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSkodG9rZW5zW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cbiAgdHJ5IHtcbiAgICBpZiAob3B0KSBvcHQgPSBtZXJnZSh7fSwgbWFya2VkLmRlZmF1bHRzLCBvcHQpO1xuICAgIHJldHVybiBQYXJzZXIucGFyc2UoTGV4ZXIubGV4KHNyYywgb3B0KSwgb3B0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGUubWVzc2FnZSArPSAnXFxuUGxlYXNlIHJlcG9ydCB0aGlzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGpqL21hcmtlZC4nO1xuICAgIGlmICgob3B0IHx8IG1hcmtlZC5kZWZhdWx0cykuc2lsZW50KSB7XG4gICAgICByZXR1cm4gJzxwPkFuIGVycm9yIG9jY3VyZWQ6PC9wPjxwcmU+J1xuICAgICAgICArIGVzY2FwZShlLm1lc3NhZ2UgKyAnJywgdHJ1ZSlcbiAgICAgICAgKyAnPC9wcmU+JztcbiAgICB9XG4gICAgdGhyb3cgZTtcbiAgfVxufVxuXG4vKipcbiAqIE9wdGlvbnNcbiAqL1xuXG5tYXJrZWQub3B0aW9ucyA9XG5tYXJrZWQuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdCkge1xuICBtZXJnZShtYXJrZWQuZGVmYXVsdHMsIG9wdCk7XG4gIHJldHVybiBtYXJrZWQ7XG59O1xuXG5tYXJrZWQuZGVmYXVsdHMgPSB7XG4gIGdmbTogdHJ1ZSxcbiAgdGFibGVzOiB0cnVlLFxuICBicmVha3M6IGZhbHNlLFxuICBwZWRhbnRpYzogZmFsc2UsXG4gIHNhbml0aXplOiBmYWxzZSxcbiAgc21hcnRMaXN0czogZmFsc2UsXG4gIHNpbGVudDogZmFsc2UsXG4gIGhpZ2hsaWdodDogbnVsbCxcbiAgbGFuZ1ByZWZpeDogJ2xhbmctJyxcbiAgc21hcnR5cGFudHM6IGZhbHNlLFxuICBoZWFkZXJQcmVmaXg6ICcnLFxuICByZW5kZXJlcjogbmV3IFJlbmRlcmVyLFxuICB4aHRtbDogZmFsc2Vcbn07XG5cbi8qKlxuICogRXhwb3NlXG4gKi9cblxubWFya2VkLlBhcnNlciA9IFBhcnNlcjtcbm1hcmtlZC5wYXJzZXIgPSBQYXJzZXIucGFyc2U7XG5cbm1hcmtlZC5SZW5kZXJlciA9IFJlbmRlcmVyO1xuXG5tYXJrZWQuTGV4ZXIgPSBMZXhlcjtcbm1hcmtlZC5sZXhlciA9IExleGVyLmxleDtcblxubWFya2VkLklubGluZUxleGVyID0gSW5saW5lTGV4ZXI7XG5tYXJrZWQuaW5saW5lTGV4ZXIgPSBJbmxpbmVMZXhlci5vdXRwdXQ7XG5cbm1hcmtlZC5wYXJzZSA9IG1hcmtlZDtcblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICBtb2R1bGUuZXhwb3J0cyA9IG1hcmtlZDtcbn0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIG1hcmtlZDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLm1hcmtlZCA9IG1hcmtlZDtcbn1cblxufSkuY2FsbChmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMgfHwgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsKTtcbn0oKSk7XG4iLCIvLyEgbW9tZW50LmpzXG4vLyEgdmVyc2lvbiA6IDIuNS4wXG4vLyEgYXV0aG9ycyA6IFRpbSBXb29kLCBJc2tyZW4gQ2hlcm5ldiwgTW9tZW50LmpzIGNvbnRyaWJ1dG9yc1xuLy8hIGxpY2Vuc2UgOiBNSVRcbi8vISBtb21lbnRqcy5jb21cblxuKGZ1bmN0aW9uICh1bmRlZmluZWQpIHtcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgQ29uc3RhbnRzXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgdmFyIG1vbWVudCxcbiAgICAgICAgVkVSU0lPTiA9IFwiMi41LjBcIixcbiAgICAgICAgZ2xvYmFsID0gdGhpcyxcbiAgICAgICAgcm91bmQgPSBNYXRoLnJvdW5kLFxuICAgICAgICBpLFxuXG4gICAgICAgIFlFQVIgPSAwLFxuICAgICAgICBNT05USCA9IDEsXG4gICAgICAgIERBVEUgPSAyLFxuICAgICAgICBIT1VSID0gMyxcbiAgICAgICAgTUlOVVRFID0gNCxcbiAgICAgICAgU0VDT05EID0gNSxcbiAgICAgICAgTUlMTElTRUNPTkQgPSA2LFxuXG4gICAgICAgIC8vIGludGVybmFsIHN0b3JhZ2UgZm9yIGxhbmd1YWdlIGNvbmZpZyBmaWxlc1xuICAgICAgICBsYW5ndWFnZXMgPSB7fSxcblxuICAgICAgICAvLyBjaGVjayBmb3Igbm9kZUpTXG4gICAgICAgIGhhc01vZHVsZSA9ICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cyAmJiB0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpLFxuXG4gICAgICAgIC8vIEFTUC5ORVQganNvbiBkYXRlIGZvcm1hdCByZWdleFxuICAgICAgICBhc3BOZXRKc29uUmVnZXggPSAvXlxcLz9EYXRlXFwoKFxcLT9cXGQrKS9pLFxuICAgICAgICBhc3BOZXRUaW1lU3Bhbkpzb25SZWdleCA9IC8oXFwtKT8oPzooXFxkKilcXC4pPyhcXGQrKVxcOihcXGQrKSg/OlxcOihcXGQrKVxcLj8oXFxkezN9KT8pPy8sXG5cbiAgICAgICAgLy8gZnJvbSBodHRwOi8vZG9jcy5jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0L2Nsb3N1cmVfZ29vZ19kYXRlX2RhdGUuanMuc291cmNlLmh0bWxcbiAgICAgICAgLy8gc29tZXdoYXQgbW9yZSBpbiBsaW5lIHdpdGggNC40LjMuMiAyMDA0IHNwZWMsIGJ1dCBhbGxvd3MgZGVjaW1hbCBhbnl3aGVyZVxuICAgICAgICBpc29EdXJhdGlvblJlZ2V4ID0gL14oLSk/UCg/Oig/OihbMC05LC5dKilZKT8oPzooWzAtOSwuXSopTSk/KD86KFswLTksLl0qKUQpPyg/OlQoPzooWzAtOSwuXSopSCk/KD86KFswLTksLl0qKU0pPyg/OihbMC05LC5dKilTKT8pP3woWzAtOSwuXSopVykkLyxcblxuICAgICAgICAvLyBmb3JtYXQgdG9rZW5zXG4gICAgICAgIGZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oTW98TU0/TT9NP3xEb3xERERvfEREP0Q/RD98ZGRkP2Q/fGRvP3x3W298d10/fFdbb3xXXT98WVlZWVlZfFlZWVlZfFlZWVl8WVl8Z2coZ2dnPyk/fEdHKEdHRz8pP3xlfEV8YXxBfGhoP3xISD98bW0/fHNzP3xTezEsNH18WHx6ej98Wlo/fC4pL2csXG4gICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhMVHxMTD9MP0w/fGx7MSw0fSkvZyxcblxuICAgICAgICAvLyBwYXJzaW5nIHRva2VuIHJlZ2V4ZXNcbiAgICAgICAgcGFyc2VUb2tlbk9uZU9yVHdvRGlnaXRzID0gL1xcZFxcZD8vLCAvLyAwIC0gOTlcbiAgICAgICAgcGFyc2VUb2tlbk9uZVRvVGhyZWVEaWdpdHMgPSAvXFxkezEsM30vLCAvLyAwIC0gOTk5XG4gICAgICAgIHBhcnNlVG9rZW5PbmVUb0ZvdXJEaWdpdHMgPSAvXFxkezEsNH0vLCAvLyAwIC0gOTk5OVxuICAgICAgICBwYXJzZVRva2VuT25lVG9TaXhEaWdpdHMgPSAvWytcXC1dP1xcZHsxLDZ9LywgLy8gLTk5OSw5OTkgLSA5OTksOTk5XG4gICAgICAgIHBhcnNlVG9rZW5EaWdpdHMgPSAvXFxkKy8sIC8vIG5vbnplcm8gbnVtYmVyIG9mIGRpZ2l0c1xuICAgICAgICBwYXJzZVRva2VuV29yZCA9IC9bMC05XSpbJ2EtelxcdTAwQTAtXFx1MDVGRlxcdTA3MDAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0rfFtcXHUwNjAwLVxcdTA2RkZcXC9dKyhcXHMqP1tcXHUwNjAwLVxcdTA2RkZdKyl7MSwyfS9pLCAvLyBhbnkgd29yZCAob3IgdHdvKSBjaGFyYWN0ZXJzIG9yIG51bWJlcnMgaW5jbHVkaW5nIHR3by90aHJlZSB3b3JkIG1vbnRoIGluIGFyYWJpYy5cbiAgICAgICAgcGFyc2VUb2tlblRpbWV6b25lID0gL1p8W1xcK1xcLV1cXGRcXGQ6P1xcZFxcZC9naSwgLy8gKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG4gICAgICAgIHBhcnNlVG9rZW5UID0gL1QvaSwgLy8gVCAoSVNPIHNlcGFyYXRvcilcbiAgICAgICAgcGFyc2VUb2tlblRpbWVzdGFtcE1zID0gL1tcXCtcXC1dP1xcZCsoXFwuXFxkezEsM30pPy8sIC8vIDEyMzQ1Njc4OSAxMjM0NTY3ODkuMTIzXG5cbiAgICAgICAgLy9zdHJpY3QgcGFyc2luZyByZWdleGVzXG4gICAgICAgIHBhcnNlVG9rZW5PbmVEaWdpdCA9IC9cXGQvLCAvLyAwIC0gOVxuICAgICAgICBwYXJzZVRva2VuVHdvRGlnaXRzID0gL1xcZFxcZC8sIC8vIDAwIC0gOTlcbiAgICAgICAgcGFyc2VUb2tlblRocmVlRGlnaXRzID0gL1xcZHszfS8sIC8vIDAwMCAtIDk5OVxuICAgICAgICBwYXJzZVRva2VuRm91ckRpZ2l0cyA9IC9cXGR7NH0vLCAvLyAwMDAwIC0gOTk5OVxuICAgICAgICBwYXJzZVRva2VuU2l4RGlnaXRzID0gL1srXFwtXT9cXGR7Nn0vLCAvLyAtOTk5LDk5OSAtIDk5OSw5OTlcblxuICAgICAgICAvLyBpc28gODYwMSByZWdleFxuICAgICAgICAvLyAwMDAwLTAwLTAwIDAwMDAtVzAwIG9yIDAwMDAtVzAwLTAgKyBUICsgMDAgb3IgMDA6MDAgb3IgMDA6MDA6MDAgb3IgMDA6MDA6MDAuMDAwICsgKzAwOjAwIG9yICswMDAwIG9yICswMClcbiAgICAgICAgaXNvUmVnZXggPSAvXlxccypcXGR7NH0tKD86KFxcZFxcZC1cXGRcXGQpfChXXFxkXFxkJCl8KFdcXGRcXGQtXFxkKXwoXFxkXFxkXFxkKSkoKFR8ICkoXFxkXFxkKDpcXGRcXGQoOlxcZFxcZChcXC5cXGQrKT8pPyk/KT8oW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPyQvLFxuXG4gICAgICAgIGlzb0Zvcm1hdCA9ICdZWVlZLU1NLUREVEhIOm1tOnNzWicsXG5cbiAgICAgICAgaXNvRGF0ZXMgPSBbXG4gICAgICAgICAgICAnWVlZWS1NTS1ERCcsXG4gICAgICAgICAgICAnR0dHRy1bV11XVycsXG4gICAgICAgICAgICAnR0dHRy1bV11XVy1FJyxcbiAgICAgICAgICAgICdZWVlZLURERCdcbiAgICAgICAgXSxcblxuICAgICAgICAvLyBpc28gdGltZSBmb3JtYXRzIGFuZCByZWdleGVzXG4gICAgICAgIGlzb1RpbWVzID0gW1xuICAgICAgICAgICAgWydISDptbTpzcy5TU1NTJywgLyhUfCApXFxkXFxkOlxcZFxcZDpcXGRcXGRcXC5cXGR7MSwzfS9dLFxuICAgICAgICAgICAgWydISDptbTpzcycsIC8oVHwgKVxcZFxcZDpcXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgICAgICBbJ0hIOm1tJywgLyhUfCApXFxkXFxkOlxcZFxcZC9dLFxuICAgICAgICAgICAgWydISCcsIC8oVHwgKVxcZFxcZC9dXG4gICAgICAgIF0sXG5cbiAgICAgICAgLy8gdGltZXpvbmUgY2h1bmtlciBcIisxMDowMFwiID4gW1wiMTBcIiwgXCIwMFwiXSBvciBcIi0xNTMwXCIgPiBbXCItMTVcIiwgXCIzMFwiXVxuICAgICAgICBwYXJzZVRpbWV6b25lQ2h1bmtlciA9IC8oW1xcK1xcLV18XFxkXFxkKS9naSxcblxuICAgICAgICAvLyBnZXR0ZXIgYW5kIHNldHRlciBuYW1lc1xuICAgICAgICBwcm94eUdldHRlcnNBbmRTZXR0ZXJzID0gJ0RhdGV8SG91cnN8TWludXRlc3xTZWNvbmRzfE1pbGxpc2Vjb25kcycuc3BsaXQoJ3wnKSxcbiAgICAgICAgdW5pdE1pbGxpc2Vjb25kRmFjdG9ycyA9IHtcbiAgICAgICAgICAgICdNaWxsaXNlY29uZHMnIDogMSxcbiAgICAgICAgICAgICdTZWNvbmRzJyA6IDFlMyxcbiAgICAgICAgICAgICdNaW51dGVzJyA6IDZlNCxcbiAgICAgICAgICAgICdIb3VycycgOiAzNmU1LFxuICAgICAgICAgICAgJ0RheXMnIDogODY0ZTUsXG4gICAgICAgICAgICAnTW9udGhzJyA6IDI1OTJlNixcbiAgICAgICAgICAgICdZZWFycycgOiAzMTUzNmU2XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5pdEFsaWFzZXMgPSB7XG4gICAgICAgICAgICBtcyA6ICdtaWxsaXNlY29uZCcsXG4gICAgICAgICAgICBzIDogJ3NlY29uZCcsXG4gICAgICAgICAgICBtIDogJ21pbnV0ZScsXG4gICAgICAgICAgICBoIDogJ2hvdXInLFxuICAgICAgICAgICAgZCA6ICdkYXknLFxuICAgICAgICAgICAgRCA6ICdkYXRlJyxcbiAgICAgICAgICAgIHcgOiAnd2VlaycsXG4gICAgICAgICAgICBXIDogJ2lzb1dlZWsnLFxuICAgICAgICAgICAgTSA6ICdtb250aCcsXG4gICAgICAgICAgICB5IDogJ3llYXInLFxuICAgICAgICAgICAgREREIDogJ2RheU9mWWVhcicsXG4gICAgICAgICAgICBlIDogJ3dlZWtkYXknLFxuICAgICAgICAgICAgRSA6ICdpc29XZWVrZGF5JyxcbiAgICAgICAgICAgIGdnOiAnd2Vla1llYXInLFxuICAgICAgICAgICAgR0c6ICdpc29XZWVrWWVhcidcbiAgICAgICAgfSxcblxuICAgICAgICBjYW1lbEZ1bmN0aW9ucyA9IHtcbiAgICAgICAgICAgIGRheW9meWVhciA6ICdkYXlPZlllYXInLFxuICAgICAgICAgICAgaXNvd2Vla2RheSA6ICdpc29XZWVrZGF5JyxcbiAgICAgICAgICAgIGlzb3dlZWsgOiAnaXNvV2VlaycsXG4gICAgICAgICAgICB3ZWVreWVhciA6ICd3ZWVrWWVhcicsXG4gICAgICAgICAgICBpc293ZWVreWVhciA6ICdpc29XZWVrWWVhcidcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBmb3JtYXQgZnVuY3Rpb24gc3RyaW5nc1xuICAgICAgICBmb3JtYXRGdW5jdGlvbnMgPSB7fSxcblxuICAgICAgICAvLyB0b2tlbnMgdG8gb3JkaW5hbGl6ZSBhbmQgcGFkXG4gICAgICAgIG9yZGluYWxpemVUb2tlbnMgPSAnREREIHcgVyBNIEQgZCcuc3BsaXQoJyAnKSxcbiAgICAgICAgcGFkZGVkVG9rZW5zID0gJ00gRCBIIGggbSBzIHcgVycuc3BsaXQoJyAnKSxcblxuICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9ucyA9IHtcbiAgICAgICAgICAgIE0gICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9udGgoKSArIDE7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgTU1NICA6IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sYW5nKCkubW9udGhzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBNTU1NIDogZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxhbmcoKS5tb250aHModGhpcywgZm9ybWF0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBEICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBEREQgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRheU9mWWVhcigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGQgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF5KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGQgICA6IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sYW5nKCkud2Vla2RheXNNaW4odGhpcywgZm9ybWF0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZGQgIDogZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxhbmcoKS53ZWVrZGF5c1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGRkZCA6IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sYW5nKCkud2Vla2RheXModGhpcywgZm9ybWF0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3ICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndlZWsoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBXICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzb1dlZWsoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBZWSAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0WmVyb0ZpbGwodGhpcy55ZWFyKCkgJSAxMDAsIDIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFlZWVkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbCh0aGlzLnllYXIoKSwgNCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgWVlZWVkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbCh0aGlzLnllYXIoKSwgNSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgWVlZWVlZIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB5ID0gdGhpcy55ZWFyKCksIHNpZ24gPSB5ID49IDAgPyAnKycgOiAnLSc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZ24gKyBsZWZ0WmVyb0ZpbGwoTWF0aC5hYnMoeSksIDYpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdnICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbCh0aGlzLndlZWtZZWFyKCkgJSAxMDAsIDIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdnZ2cgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud2Vla1llYXIoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZ2dnZyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdFplcm9GaWxsKHRoaXMud2Vla1llYXIoKSwgNSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgR0cgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdFplcm9GaWxsKHRoaXMuaXNvV2Vla1llYXIoKSAlIDEwMCwgMik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgR0dHRyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc29XZWVrWWVhcigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEdHR0dHIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0WmVyb0ZpbGwodGhpcy5pc29XZWVrWWVhcigpLCA1KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndlZWtkYXkoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBFIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzb1dlZWtkYXkoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxhbmcoKS5tZXJpZGllbSh0aGlzLmhvdXJzKCksIHRoaXMubWludXRlcygpLCB0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBBICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxhbmcoKS5tZXJpZGllbSh0aGlzLmhvdXJzKCksIHRoaXMubWludXRlcygpLCBmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgSCAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGggICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKSAlIDEyIHx8IDEyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG0gICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWludXRlcygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHMgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Vjb25kcygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFMgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvSW50KHRoaXMubWlsbGlzZWNvbmRzKCkgLyAxMDApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFNTICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbCh0b0ludCh0aGlzLm1pbGxpc2Vjb25kcygpIC8gMTApLCAyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBTU1MgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0WmVyb0ZpbGwodGhpcy5taWxsaXNlY29uZHMoKSwgMyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgU1NTUyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdFplcm9GaWxsKHRoaXMubWlsbGlzZWNvbmRzKCksIDMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFogICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSAtdGhpcy56b25lKCksXG4gICAgICAgICAgICAgICAgICAgIGIgPSBcIitcIjtcbiAgICAgICAgICAgICAgICBpZiAoYSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYSA9IC1hO1xuICAgICAgICAgICAgICAgICAgICBiID0gXCItXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBiICsgbGVmdFplcm9GaWxsKHRvSW50KGEgLyA2MCksIDIpICsgXCI6XCIgKyBsZWZ0WmVyb0ZpbGwodG9JbnQoYSkgJSA2MCwgMik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgWlogICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IC10aGlzLnpvbmUoKSxcbiAgICAgICAgICAgICAgICAgICAgYiA9IFwiK1wiO1xuICAgICAgICAgICAgICAgIGlmIChhIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBhID0gLWE7XG4gICAgICAgICAgICAgICAgICAgIGIgPSBcIi1cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGIgKyBsZWZ0WmVyb0ZpbGwodG9JbnQoYSAvIDYwKSwgMikgKyBsZWZ0WmVyb0ZpbGwodG9JbnQoYSkgJSA2MCwgMik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeiA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy56b25lQWJicigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHp6IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnpvbmVOYW1lKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgWCAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bml4KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgUSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5xdWFydGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbGlzdHMgPSBbJ21vbnRocycsICdtb250aHNTaG9ydCcsICd3ZWVrZGF5cycsICd3ZWVrZGF5c1Nob3J0JywgJ3dlZWtkYXlzTWluJ107XG5cbiAgICBmdW5jdGlvbiBwYWRUb2tlbihmdW5jLCBjb3VudCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHJldHVybiBsZWZ0WmVyb0ZpbGwoZnVuYy5jYWxsKHRoaXMsIGEpLCBjb3VudCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9yZGluYWxpemVUb2tlbihmdW5jLCBwZXJpb2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYW5nKCkub3JkaW5hbChmdW5jLmNhbGwodGhpcywgYSksIHBlcmlvZCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgd2hpbGUgKG9yZGluYWxpemVUb2tlbnMubGVuZ3RoKSB7XG4gICAgICAgIGkgPSBvcmRpbmFsaXplVG9rZW5zLnBvcCgpO1xuICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1tpICsgJ28nXSA9IG9yZGluYWxpemVUb2tlbihmb3JtYXRUb2tlbkZ1bmN0aW9uc1tpXSwgaSk7XG4gICAgfVxuICAgIHdoaWxlIChwYWRkZWRUb2tlbnMubGVuZ3RoKSB7XG4gICAgICAgIGkgPSBwYWRkZWRUb2tlbnMucG9wKCk7XG4gICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW2kgKyBpXSA9IHBhZFRva2VuKGZvcm1hdFRva2VuRnVuY3Rpb25zW2ldLCAyKTtcbiAgICB9XG4gICAgZm9ybWF0VG9rZW5GdW5jdGlvbnMuRERERCA9IHBhZFRva2VuKGZvcm1hdFRva2VuRnVuY3Rpb25zLkRERCwgMyk7XG5cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgQ29uc3RydWN0b3JzXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgZnVuY3Rpb24gTGFuZ3VhZ2UoKSB7XG5cbiAgICB9XG5cbiAgICAvLyBNb21lbnQgcHJvdG90eXBlIG9iamVjdFxuICAgIGZ1bmN0aW9uIE1vbWVudChjb25maWcpIHtcbiAgICAgICAgY2hlY2tPdmVyZmxvdyhjb25maWcpO1xuICAgICAgICBleHRlbmQodGhpcywgY29uZmlnKTtcbiAgICB9XG5cbiAgICAvLyBEdXJhdGlvbiBDb25zdHJ1Y3RvclxuICAgIGZ1bmN0aW9uIER1cmF0aW9uKGR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSBub3JtYWxpemVPYmplY3RVbml0cyhkdXJhdGlvbiksXG4gICAgICAgICAgICB5ZWFycyA9IG5vcm1hbGl6ZWRJbnB1dC55ZWFyIHx8IDAsXG4gICAgICAgICAgICBtb250aHMgPSBub3JtYWxpemVkSW5wdXQubW9udGggfHwgMCxcbiAgICAgICAgICAgIHdlZWtzID0gbm9ybWFsaXplZElucHV0LndlZWsgfHwgMCxcbiAgICAgICAgICAgIGRheXMgPSBub3JtYWxpemVkSW5wdXQuZGF5IHx8IDAsXG4gICAgICAgICAgICBob3VycyA9IG5vcm1hbGl6ZWRJbnB1dC5ob3VyIHx8IDAsXG4gICAgICAgICAgICBtaW51dGVzID0gbm9ybWFsaXplZElucHV0Lm1pbnV0ZSB8fCAwLFxuICAgICAgICAgICAgc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5zZWNvbmQgfHwgMCxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5taWxsaXNlY29uZCB8fCAwO1xuXG4gICAgICAgIC8vIHJlcHJlc2VudGF0aW9uIGZvciBkYXRlQWRkUmVtb3ZlXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9ICttaWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgc2Vjb25kcyAqIDFlMyArIC8vIDEwMDBcbiAgICAgICAgICAgIG1pbnV0ZXMgKiA2ZTQgKyAvLyAxMDAwICogNjBcbiAgICAgICAgICAgIGhvdXJzICogMzZlNTsgLy8gMTAwMCAqIDYwICogNjBcbiAgICAgICAgLy8gQmVjYXVzZSBvZiBkYXRlQWRkUmVtb3ZlIHRyZWF0cyAyNCBob3VycyBhcyBkaWZmZXJlbnQgZnJvbSBhXG4gICAgICAgIC8vIGRheSB3aGVuIHdvcmtpbmcgYXJvdW5kIERTVCwgd2UgbmVlZCB0byBzdG9yZSB0aGVtIHNlcGFyYXRlbHlcbiAgICAgICAgdGhpcy5fZGF5cyA9ICtkYXlzICtcbiAgICAgICAgICAgIHdlZWtzICogNztcbiAgICAgICAgLy8gSXQgaXMgaW1wb3NzaWJsZSB0cmFuc2xhdGUgbW9udGhzIGludG8gZGF5cyB3aXRob3V0IGtub3dpbmdcbiAgICAgICAgLy8gd2hpY2ggbW9udGhzIHlvdSBhcmUgYXJlIHRhbGtpbmcgYWJvdXQsIHNvIHdlIGhhdmUgdG8gc3RvcmVcbiAgICAgICAgLy8gaXQgc2VwYXJhdGVseS5cbiAgICAgICAgdGhpcy5fbW9udGhzID0gK21vbnRocyArXG4gICAgICAgICAgICB5ZWFycyAqIDEyO1xuXG4gICAgICAgIHRoaXMuX2RhdGEgPSB7fTtcblxuICAgICAgICB0aGlzLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIEhlbHBlcnNcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgIGZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gYikge1xuICAgICAgICAgICAgaWYgKGIuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICBhW2ldID0gYltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiLmhhc093blByb3BlcnR5KFwidG9TdHJpbmdcIikpIHtcbiAgICAgICAgICAgIGEudG9TdHJpbmcgPSBiLnRvU3RyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGIuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZU9mXCIpKSB7XG4gICAgICAgICAgICBhLnZhbHVlT2YgPSBiLnZhbHVlT2Y7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNSb3VuZChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBsZWZ0IHplcm8gZmlsbCBhIG51bWJlclxuICAgIC8vIHNlZSBodHRwOi8vanNwZXJmLmNvbS9sZWZ0LXplcm8tZmlsbGluZyBmb3IgcGVyZm9ybWFuY2UgY29tcGFyaXNvblxuICAgIGZ1bmN0aW9uIGxlZnRaZXJvRmlsbChudW1iZXIsIHRhcmdldExlbmd0aCwgZm9yY2VTaWduKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSBNYXRoLmFicyhudW1iZXIpICsgJycsXG4gICAgICAgICAgICBzaWduID0gbnVtYmVyID49IDA7XG5cbiAgICAgICAgd2hpbGUgKG91dHB1dC5sZW5ndGggPCB0YXJnZXRMZW5ndGgpIHtcbiAgICAgICAgICAgIG91dHB1dCA9ICcwJyArIG91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHNpZ24gPyAoZm9yY2VTaWduID8gJysnIDogJycpIDogJy0nKSArIG91dHB1dDtcbiAgICB9XG5cbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gZm9yIF8uYWRkVGltZSBhbmQgXy5zdWJ0cmFjdFRpbWVcbiAgICBmdW5jdGlvbiBhZGRPclN1YnRyYWN0RHVyYXRpb25Gcm9tTW9tZW50KG1vbSwgZHVyYXRpb24sIGlzQWRkaW5nLCBpZ25vcmVVcGRhdGVPZmZzZXQpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IGR1cmF0aW9uLl9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICBkYXlzID0gZHVyYXRpb24uX2RheXMsXG4gICAgICAgICAgICBtb250aHMgPSBkdXJhdGlvbi5fbW9udGhzLFxuICAgICAgICAgICAgbWludXRlcyxcbiAgICAgICAgICAgIGhvdXJzO1xuXG4gICAgICAgIGlmIChtaWxsaXNlY29uZHMpIHtcbiAgICAgICAgICAgIG1vbS5fZC5zZXRUaW1lKCttb20uX2QgKyBtaWxsaXNlY29uZHMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RvcmUgdGhlIG1pbnV0ZXMgYW5kIGhvdXJzIHNvIHdlIGNhbiByZXN0b3JlIHRoZW1cbiAgICAgICAgaWYgKGRheXMgfHwgbW9udGhzKSB7XG4gICAgICAgICAgICBtaW51dGVzID0gbW9tLm1pbnV0ZSgpO1xuICAgICAgICAgICAgaG91cnMgPSBtb20uaG91cigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXlzKSB7XG4gICAgICAgICAgICBtb20uZGF0ZShtb20uZGF0ZSgpICsgZGF5cyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9udGhzKSB7XG4gICAgICAgICAgICBtb20ubW9udGgobW9tLm1vbnRoKCkgKyBtb250aHMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbGxpc2Vjb25kcyAmJiAhaWdub3JlVXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgICAgICBtb21lbnQudXBkYXRlT2Zmc2V0KG1vbSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzdG9yZSB0aGUgbWludXRlcyBhbmQgaG91cnMgYWZ0ZXIgcG9zc2libHkgY2hhbmdpbmcgZHN0XG4gICAgICAgIGlmIChkYXlzIHx8IG1vbnRocykge1xuICAgICAgICAgICAgbW9tLm1pbnV0ZShtaW51dGVzKTtcbiAgICAgICAgICAgIG1vbS5ob3VyKGhvdXJzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIGlzIGFuIGFycmF5XG4gICAgZnVuY3Rpb24gaXNBcnJheShpbnB1dCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RhdGUoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXScgfHxcbiAgICAgICAgICAgICAgICBpbnB1dCBpbnN0YW5jZW9mIERhdGU7XG4gICAgfVxuXG4gICAgLy8gY29tcGFyZSB0d28gYXJyYXlzLCByZXR1cm4gdGhlIG51bWJlciBvZiBkaWZmZXJlbmNlc1xuICAgIGZ1bmN0aW9uIGNvbXBhcmVBcnJheXMoYXJyYXkxLCBhcnJheTIsIGRvbnRDb252ZXJ0KSB7XG4gICAgICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcnJheTEubGVuZ3RoLCBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgIGxlbmd0aERpZmYgPSBNYXRoLmFicyhhcnJheTEubGVuZ3RoIC0gYXJyYXkyLmxlbmd0aCksXG4gICAgICAgICAgICBkaWZmcyA9IDAsXG4gICAgICAgICAgICBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICgoZG9udENvbnZlcnQgJiYgYXJyYXkxW2ldICE9PSBhcnJheTJbaV0pIHx8XG4gICAgICAgICAgICAgICAgKCFkb250Q29udmVydCAmJiB0b0ludChhcnJheTFbaV0pICE9PSB0b0ludChhcnJheTJbaV0pKSkge1xuICAgICAgICAgICAgICAgIGRpZmZzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpZmZzICsgbGVuZ3RoRGlmZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVVbml0cyh1bml0cykge1xuICAgICAgICBpZiAodW5pdHMpIHtcbiAgICAgICAgICAgIHZhciBsb3dlcmVkID0gdW5pdHMudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8oLilzJC8sICckMScpO1xuICAgICAgICAgICAgdW5pdHMgPSB1bml0QWxpYXNlc1t1bml0c10gfHwgY2FtZWxGdW5jdGlvbnNbbG93ZXJlZF0gfHwgbG93ZXJlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5pdHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplT2JqZWN0VW5pdHMoaW5wdXRPYmplY3QpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IHt9LFxuICAgICAgICAgICAgbm9ybWFsaXplZFByb3AsXG4gICAgICAgICAgICBwcm9wO1xuXG4gICAgICAgIGZvciAocHJvcCBpbiBpbnB1dE9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGlucHV0T2JqZWN0Lmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFByb3AgPSBub3JtYWxpemVVbml0cyhwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZFByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZElucHV0W25vcm1hbGl6ZWRQcm9wXSA9IGlucHV0T2JqZWN0W3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkSW5wdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUxpc3QoZmllbGQpIHtcbiAgICAgICAgdmFyIGNvdW50LCBzZXR0ZXI7XG5cbiAgICAgICAgaWYgKGZpZWxkLmluZGV4T2YoJ3dlZWsnKSA9PT0gMCkge1xuICAgICAgICAgICAgY291bnQgPSA3O1xuICAgICAgICAgICAgc2V0dGVyID0gJ2RheSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmllbGQuaW5kZXhPZignbW9udGgnKSA9PT0gMCkge1xuICAgICAgICAgICAgY291bnQgPSAxMjtcbiAgICAgICAgICAgIHNldHRlciA9ICdtb250aCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBtb21lbnRbZmllbGRdID0gZnVuY3Rpb24gKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBpLCBnZXR0ZXIsXG4gICAgICAgICAgICAgICAgbWV0aG9kID0gbW9tZW50LmZuLl9sYW5nW2ZpZWxkXSxcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gW107XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm9ybWF0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2V0dGVyID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbSA9IG1vbWVudCgpLnV0YygpLnNldChzZXR0ZXIsIGkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2QuY2FsbChtb21lbnQuZm4uX2xhbmcsIG0sIGZvcm1hdCB8fCAnJyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXR0ZXIoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGdldHRlcihpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSW50KGFyZ3VtZW50Rm9yQ29lcmNpb24pIHtcbiAgICAgICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcbiAgICAgICAgICAgIHZhbHVlID0gMDtcblxuICAgICAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xuICAgICAgICAgICAgaWYgKGNvZXJjZWROdW1iZXIgPj0gMCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gTWF0aC5mbG9vcihjb2VyY2VkTnVtYmVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBNYXRoLmNlaWwoY29lcmNlZE51bWJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoICsgMSwgMCkpLmdldFVUQ0RhdGUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlzSW5ZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIoeWVhcikgPyAzNjYgOiAzNjU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCkgfHwgeWVhciAlIDQwMCA9PT0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja092ZXJmbG93KG0pIHtcbiAgICAgICAgdmFyIG92ZXJmbG93O1xuICAgICAgICBpZiAobS5fYSAmJiBtLl9wZi5vdmVyZmxvdyA9PT0gLTIpIHtcbiAgICAgICAgICAgIG92ZXJmbG93ID1cbiAgICAgICAgICAgICAgICBtLl9hW01PTlRIXSA8IDAgfHwgbS5fYVtNT05USF0gPiAxMSA/IE1PTlRIIDpcbiAgICAgICAgICAgICAgICBtLl9hW0RBVEVdIDwgMSB8fCBtLl9hW0RBVEVdID4gZGF5c0luTW9udGgobS5fYVtZRUFSXSwgbS5fYVtNT05USF0pID8gREFURSA6XG4gICAgICAgICAgICAgICAgbS5fYVtIT1VSXSA8IDAgfHwgbS5fYVtIT1VSXSA+IDIzID8gSE9VUiA6XG4gICAgICAgICAgICAgICAgbS5fYVtNSU5VVEVdIDwgMCB8fCBtLl9hW01JTlVURV0gPiA1OSA/IE1JTlVURSA6XG4gICAgICAgICAgICAgICAgbS5fYVtTRUNPTkRdIDwgMCB8fCBtLl9hW1NFQ09ORF0gPiA1OSA/IFNFQ09ORCA6XG4gICAgICAgICAgICAgICAgbS5fYVtNSUxMSVNFQ09ORF0gPCAwIHx8IG0uX2FbTUlMTElTRUNPTkRdID4gOTk5ID8gTUlMTElTRUNPTkQgOlxuICAgICAgICAgICAgICAgIC0xO1xuXG4gICAgICAgICAgICBpZiAobS5fcGYuX292ZXJmbG93RGF5T2ZZZWFyICYmIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gREFURTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbS5fcGYub3ZlcmZsb3cgPSBvdmVyZmxvdztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXRpYWxpemVQYXJzaW5nRmxhZ3MoY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fcGYgPSB7XG4gICAgICAgICAgICBlbXB0eSA6IGZhbHNlLFxuICAgICAgICAgICAgdW51c2VkVG9rZW5zIDogW10sXG4gICAgICAgICAgICB1bnVzZWRJbnB1dCA6IFtdLFxuICAgICAgICAgICAgb3ZlcmZsb3cgOiAtMixcbiAgICAgICAgICAgIGNoYXJzTGVmdE92ZXIgOiAwLFxuICAgICAgICAgICAgbnVsbElucHV0IDogZmFsc2UsXG4gICAgICAgICAgICBpbnZhbGlkTW9udGggOiBudWxsLFxuICAgICAgICAgICAgaW52YWxpZEZvcm1hdCA6IGZhbHNlLFxuICAgICAgICAgICAgdXNlckludmFsaWRhdGVkIDogZmFsc2UsXG4gICAgICAgICAgICBpc286IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWxpZChtKSB7XG4gICAgICAgIGlmIChtLl9pc1ZhbGlkID09IG51bGwpIHtcbiAgICAgICAgICAgIG0uX2lzVmFsaWQgPSAhaXNOYU4obS5fZC5nZXRUaW1lKCkpICYmXG4gICAgICAgICAgICAgICAgbS5fcGYub3ZlcmZsb3cgPCAwICYmXG4gICAgICAgICAgICAgICAgIW0uX3BmLmVtcHR5ICYmXG4gICAgICAgICAgICAgICAgIW0uX3BmLmludmFsaWRNb250aCAmJlxuICAgICAgICAgICAgICAgICFtLl9wZi5udWxsSW5wdXQgJiZcbiAgICAgICAgICAgICAgICAhbS5fcGYuaW52YWxpZEZvcm1hdCAmJlxuICAgICAgICAgICAgICAgICFtLl9wZi51c2VySW52YWxpZGF0ZWQ7XG5cbiAgICAgICAgICAgIGlmIChtLl9zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBtLl9pc1ZhbGlkID0gbS5faXNWYWxpZCAmJlxuICAgICAgICAgICAgICAgICAgICBtLl9wZi5jaGFyc0xlZnRPdmVyID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIG0uX3BmLnVudXNlZFRva2Vucy5sZW5ndGggPT09IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0uX2lzVmFsaWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplTGFuZ3VhZ2Uoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgPyBrZXkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdfJywgJy0nKSA6IGtleTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYSBtb21lbnQgZnJvbSBpbnB1dCwgdGhhdCBpcyBsb2NhbC91dGMvem9uZSBlcXVpdmFsZW50IHRvIG1vZGVsLlxuICAgIGZ1bmN0aW9uIG1ha2VBcyhpbnB1dCwgbW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIG1vZGVsLl9pc1VUQyA/IG1vbWVudChpbnB1dCkuem9uZShtb2RlbC5fb2Zmc2V0IHx8IDApIDpcbiAgICAgICAgICAgIG1vbWVudChpbnB1dCkubG9jYWwoKTtcbiAgICB9XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIExhbmd1YWdlc1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgZXh0ZW5kKExhbmd1YWdlLnByb3RvdHlwZSwge1xuXG4gICAgICAgIHNldCA6IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIHZhciBwcm9wLCBpO1xuICAgICAgICAgICAgZm9yIChpIGluIGNvbmZpZykge1xuICAgICAgICAgICAgICAgIHByb3AgPSBjb25maWdbaV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbaV0gPSBwcm9wO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbJ18nICsgaV0gPSBwcm9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfbW9udGhzIDogXCJKYW51YXJ5X0ZlYnJ1YXJ5X01hcmNoX0FwcmlsX01heV9KdW5lX0p1bHlfQXVndXN0X1NlcHRlbWJlcl9PY3RvYmVyX05vdmVtYmVyX0RlY2VtYmVyXCIuc3BsaXQoXCJfXCIpLFxuICAgICAgICBtb250aHMgOiBmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1ttLm1vbnRoKCldO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9tb250aHNTaG9ydCA6IFwiSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWNcIi5zcGxpdChcIl9cIiksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFttLm1vbnRoKCldO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1vbnRoc1BhcnNlIDogZnVuY3Rpb24gKG1vbnRoTmFtZSkge1xuICAgICAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbW9tID0gbW9tZW50LnV0YyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgICAgICAgICByZWdleCA9ICdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF93ZWVrZGF5cyA6IFwiU3VuZGF5X01vbmRheV9UdWVzZGF5X1dlZG5lc2RheV9UaHVyc2RheV9GcmlkYXlfU2F0dXJkYXlcIi5zcGxpdChcIl9cIiksXG4gICAgICAgIHdlZWtkYXlzIDogZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1ttLmRheSgpXTtcbiAgICAgICAgfSxcblxuICAgICAgICBfd2Vla2RheXNTaG9ydCA6IFwiU3VuX01vbl9UdWVfV2VkX1RodV9GcmlfU2F0XCIuc3BsaXQoXCJfXCIpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0W20uZGF5KCldO1xuICAgICAgICB9LFxuXG4gICAgICAgIF93ZWVrZGF5c01pbiA6IFwiU3VfTW9fVHVfV2VfVGhfRnJfU2FcIi5zcGxpdChcIl9cIiksXG4gICAgICAgIHdlZWtkYXlzTWluIDogZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblttLmRheSgpXTtcbiAgICAgICAgfSxcblxuICAgICAgICB3ZWVrZGF5c1BhcnNlIDogZnVuY3Rpb24gKHdlZWtkYXlOYW1lKSB7XG4gICAgICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vbSA9IG1vbWVudChbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6IFwiaDptbSBBXCIsXG4gICAgICAgICAgICBMIDogXCJNTS9ERC9ZWVlZXCIsXG4gICAgICAgICAgICBMTCA6IFwiTU1NTSBEIFlZWVlcIixcbiAgICAgICAgICAgIExMTCA6IFwiTU1NTSBEIFlZWVkgTFRcIixcbiAgICAgICAgICAgIExMTEwgOiBcImRkZGQsIE1NTU0gRCBZWVlZIExUXCJcbiAgICAgICAgfSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XTtcbiAgICAgICAgICAgIGlmICghb3V0cHV0ICYmIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleS50b1VwcGVyQ2FzZSgpXSkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleS50b1VwcGVyQ2FzZSgpXS5yZXBsYWNlKC9NTU1NfE1NfEREfGRkZGQvZywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0gPSBvdXRwdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzUE0gOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIC8vIElFOCBRdWlya3MgTW9kZSAmIElFNyBTdGFuZGFyZHMgTW9kZSBkbyBub3QgYWxsb3cgYWNjZXNzaW5nIHN0cmluZ3MgbGlrZSBhcnJheXNcbiAgICAgICAgICAgIC8vIFVzaW5nIGNoYXJBdCBzaG91bGQgYmUgbW9yZSBjb21wYXRpYmxlLlxuICAgICAgICAgICAgcmV0dXJuICgoaW5wdXQgKyAnJykudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09ICdwJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX21lcmlkaWVtUGFyc2UgOiAvW2FwXVxcLj9tP1xcLj8vaSxcbiAgICAgICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgICAgIGlmIChob3VycyA+IDExKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAncG0nIDogJ1BNJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAnYW0nIDogJ0FNJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1tUb2RheSBhdF0gTFQnLFxuICAgICAgICAgICAgbmV4dERheSA6ICdbVG9tb3Jyb3cgYXRdIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW2F0XSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1tZZXN0ZXJkYXkgYXRdIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiBmdW5jdGlvbiAoa2V5LCBtb20pIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9jYWxlbmRhcltrZXldO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvdXRwdXQgPT09ICdmdW5jdGlvbicgPyBvdXRwdXQuYXBwbHkobW9tKSA6IG91dHB1dDtcbiAgICAgICAgfSxcblxuICAgICAgICBfcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogXCJpbiAlc1wiLFxuICAgICAgICAgICAgcGFzdCA6IFwiJXMgYWdvXCIsXG4gICAgICAgICAgICBzIDogXCJhIGZldyBzZWNvbmRzXCIsXG4gICAgICAgICAgICBtIDogXCJhIG1pbnV0ZVwiLFxuICAgICAgICAgICAgbW0gOiBcIiVkIG1pbnV0ZXNcIixcbiAgICAgICAgICAgIGggOiBcImFuIGhvdXJcIixcbiAgICAgICAgICAgIGhoIDogXCIlZCBob3Vyc1wiLFxuICAgICAgICAgICAgZCA6IFwiYSBkYXlcIixcbiAgICAgICAgICAgIGRkIDogXCIlZCBkYXlzXCIsXG4gICAgICAgICAgICBNIDogXCJhIG1vbnRoXCIsXG4gICAgICAgICAgICBNTSA6IFwiJWQgbW9udGhzXCIsXG4gICAgICAgICAgICB5IDogXCJhIHllYXJcIixcbiAgICAgICAgICAgIHl5IDogXCIlZCB5ZWFyc1wiXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IGZ1bmN0aW9uIChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcbiAgICAgICAgICAgIHJldHVybiAodHlwZW9mIG91dHB1dCA9PT0gJ2Z1bmN0aW9uJykgP1xuICAgICAgICAgICAgICAgIG91dHB1dChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIDpcbiAgICAgICAgICAgICAgICBvdXRwdXQucmVwbGFjZSgvJWQvaSwgbnVtYmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFzdEZ1dHVyZSA6IGZ1bmN0aW9uIChkaWZmLCBvdXRwdXQpIHtcbiAgICAgICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbZGlmZiA+IDAgPyAnZnV0dXJlJyA6ICdwYXN0J107XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGZvcm1hdCA9PT0gJ2Z1bmN0aW9uJyA/IGZvcm1hdChvdXRwdXQpIDogZm9ybWF0LnJlcGxhY2UoLyVzL2ksIG91dHB1dCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcmRpbmFsLnJlcGxhY2UoXCIlZFwiLCBudW1iZXIpO1xuICAgICAgICB9LFxuICAgICAgICBfb3JkaW5hbCA6IFwiJWRcIixcblxuICAgICAgICBwcmVwYXJzZSA6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9zdGZvcm1hdCA6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgd2VlayA6IGZ1bmN0aW9uIChtb20pIHtcbiAgICAgICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKG1vbSwgdGhpcy5fd2Vlay5kb3csIHRoaXMuX3dlZWsuZG95KS53ZWVrO1xuICAgICAgICB9LFxuXG4gICAgICAgIF93ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH0sXG5cbiAgICAgICAgX2ludmFsaWREYXRlOiAnSW52YWxpZCBkYXRlJyxcbiAgICAgICAgaW52YWxpZERhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnZhbGlkRGF0ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTG9hZHMgYSBsYW5ndWFnZSBkZWZpbml0aW9uIGludG8gdGhlIGBsYW5ndWFnZXNgIGNhY2hlLiAgVGhlIGZ1bmN0aW9uXG4gICAgLy8gdGFrZXMgYSBrZXkgYW5kIG9wdGlvbmFsbHkgdmFsdWVzLiAgSWYgbm90IGluIHRoZSBicm93c2VyIGFuZCBubyB2YWx1ZXNcbiAgICAvLyBhcmUgcHJvdmlkZWQsIGl0IHdpbGwgbG9hZCB0aGUgbGFuZ3VhZ2UgZmlsZSBtb2R1bGUuICBBcyBhIGNvbnZlbmllbmNlLFxuICAgIC8vIHRoaXMgZnVuY3Rpb24gYWxzbyByZXR1cm5zIHRoZSBsYW5ndWFnZSB2YWx1ZXMuXG4gICAgZnVuY3Rpb24gbG9hZExhbmcoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgdmFsdWVzLmFiYnIgPSBrZXk7XG4gICAgICAgIGlmICghbGFuZ3VhZ2VzW2tleV0pIHtcbiAgICAgICAgICAgIGxhbmd1YWdlc1trZXldID0gbmV3IExhbmd1YWdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGFuZ3VhZ2VzW2tleV0uc2V0KHZhbHVlcyk7XG4gICAgICAgIHJldHVybiBsYW5ndWFnZXNba2V5XTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgYSBsYW5ndWFnZSBmcm9tIHRoZSBgbGFuZ3VhZ2VzYCBjYWNoZS4gTW9zdGx5IHVzZWZ1bCBpbiB0ZXN0cy5cbiAgICBmdW5jdGlvbiB1bmxvYWRMYW5nKGtleSkge1xuICAgICAgICBkZWxldGUgbGFuZ3VhZ2VzW2tleV07XG4gICAgfVxuXG4gICAgLy8gRGV0ZXJtaW5lcyB3aGljaCBsYW5ndWFnZSBkZWZpbml0aW9uIHRvIHVzZSBhbmQgcmV0dXJucyBpdC5cbiAgICAvL1xuICAgIC8vIFdpdGggbm8gcGFyYW1ldGVycywgaXQgd2lsbCByZXR1cm4gdGhlIGdsb2JhbCBsYW5ndWFnZS4gIElmIHlvdVxuICAgIC8vIHBhc3MgaW4gYSBsYW5ndWFnZSBrZXksIHN1Y2ggYXMgJ2VuJywgaXQgd2lsbCByZXR1cm4gdGhlXG4gICAgLy8gZGVmaW5pdGlvbiBmb3IgJ2VuJywgc28gbG9uZyBhcyAnZW4nIGhhcyBhbHJlYWR5IGJlZW4gbG9hZGVkIHVzaW5nXG4gICAgLy8gbW9tZW50LmxhbmcuXG4gICAgZnVuY3Rpb24gZ2V0TGFuZ0RlZmluaXRpb24oa2V5KSB7XG4gICAgICAgIHZhciBpID0gMCwgaiwgbGFuZywgbmV4dCwgc3BsaXQsXG4gICAgICAgICAgICBnZXQgPSBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICAgIGlmICghbGFuZ3VhZ2VzW2tdICYmIGhhc01vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9sYW5nLycgKyBrKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBsYW5ndWFnZXNba107XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gbW9tZW50LmZuLl9sYW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0FycmF5KGtleSkpIHtcbiAgICAgICAgICAgIC8vc2hvcnQtY2lyY3VpdCBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgICAgIGxhbmcgPSBnZXQoa2V5KTtcbiAgICAgICAgICAgIGlmIChsYW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrZXkgPSBba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vcGljayB0aGUgbGFuZ3VhZ2UgZnJvbSB0aGUgYXJyYXlcbiAgICAgICAgLy90cnkgWydlbi1hdScsICdlbi1nYiddIGFzICdlbi1hdScsICdlbi1nYicsICdlbicsIGFzIGluIG1vdmUgdGhyb3VnaCB0aGUgbGlzdCB0cnlpbmcgZWFjaFxuICAgICAgICAvL3N1YnN0cmluZyBmcm9tIG1vc3Qgc3BlY2lmaWMgdG8gbGVhc3QsIGJ1dCBtb3ZlIHRvIHRoZSBuZXh0IGFycmF5IGl0ZW0gaWYgaXQncyBhIG1vcmUgc3BlY2lmaWMgdmFyaWFudCB0aGFuIHRoZSBjdXJyZW50IHJvb3RcbiAgICAgICAgd2hpbGUgKGkgPCBrZXkubGVuZ3RoKSB7XG4gICAgICAgICAgICBzcGxpdCA9IG5vcm1hbGl6ZUxhbmd1YWdlKGtleVtpXSkuc3BsaXQoJy0nKTtcbiAgICAgICAgICAgIGogPSBzcGxpdC5sZW5ndGg7XG4gICAgICAgICAgICBuZXh0ID0gbm9ybWFsaXplTGFuZ3VhZ2Uoa2V5W2kgKyAxXSk7XG4gICAgICAgICAgICBuZXh0ID0gbmV4dCA/IG5leHQuc3BsaXQoJy0nKSA6IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICBsYW5nID0gZ2V0KHNwbGl0LnNsaWNlKDAsIGopLmpvaW4oJy0nKSk7XG4gICAgICAgICAgICAgICAgaWYgKGxhbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQubGVuZ3RoID49IGogJiYgY29tcGFyZUFycmF5cyhzcGxpdCwgbmV4dCwgdHJ1ZSkgPj0gaiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy90aGUgbmV4dCBhcnJheSBpdGVtIGlzIGJldHRlciB0aGFuIGEgc2hhbGxvd2VyIHN1YnN0cmluZyBvZiB0aGlzIG9uZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb21lbnQuZm4uX2xhbmc7XG4gICAgfVxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBGb3JtYXR0aW5nXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgICBmdW5jdGlvbiByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dC5tYXRjaCgvXFxbW1xcc1xcU10vKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL15cXFt8XFxdJC9nLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXFxcXC9nLCBcIlwiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgIHZhciBhcnJheSA9IGZvcm1hdC5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSwgaSwgbGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1vbSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IFwiXCI7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gYXJyYXlbaV0gaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGFycmF5W2ldLmNhbGwobW9tLCBmb3JtYXQpIDogYXJyYXlbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIGZvcm1hdCBkYXRlIHVzaW5nIG5hdGl2ZSBkYXRlIG9iamVjdFxuICAgIGZ1bmN0aW9uIGZvcm1hdE1vbWVudChtLCBmb3JtYXQpIHtcblxuICAgICAgICBpZiAoIW0uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbS5sYW5nKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGV4cGFuZEZvcm1hdChmb3JtYXQsIG0ubGFuZygpKTtcblxuICAgICAgICBpZiAoIWZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdKSB7XG4gICAgICAgICAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSA9IG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdKG0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cGFuZEZvcm1hdChmb3JtYXQsIGxhbmcpIHtcbiAgICAgICAgdmFyIGkgPSA1O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2VucyhpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGxhbmcubG9uZ0RhdGVGb3JtYXQoaW5wdXQpIHx8IGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLnRlc3QoZm9ybWF0KSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UobG9jYWxGb3JtYXR0aW5nVG9rZW5zLCByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMpO1xuICAgICAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICBpIC09IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH1cblxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBQYXJzaW5nXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgICAvLyBnZXQgdGhlIHJlZ2V4IHRvIGZpbmQgdGhlIG5leHQgdG9rZW5cbiAgICBmdW5jdGlvbiBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykge1xuICAgICAgICB2YXIgYSwgc3RyaWN0ID0gY29uZmlnLl9zdHJpY3Q7XG4gICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgY2FzZSAnRERERCc6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlblRocmVlRGlnaXRzO1xuICAgICAgICBjYXNlICdZWVlZJzpcbiAgICAgICAgY2FzZSAnR0dHRyc6XG4gICAgICAgIGNhc2UgJ2dnZ2cnOlxuICAgICAgICAgICAgcmV0dXJuIHN0cmljdCA/IHBhcnNlVG9rZW5Gb3VyRGlnaXRzIDogcGFyc2VUb2tlbk9uZVRvRm91ckRpZ2l0cztcbiAgICAgICAgY2FzZSAnWVlZWVlZJzpcbiAgICAgICAgY2FzZSAnWVlZWVknOlxuICAgICAgICBjYXNlICdHR0dHRyc6XG4gICAgICAgIGNhc2UgJ2dnZ2dnJzpcbiAgICAgICAgICAgIHJldHVybiBzdHJpY3QgPyBwYXJzZVRva2VuU2l4RGlnaXRzIDogcGFyc2VUb2tlbk9uZVRvU2l4RGlnaXRzO1xuICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAgIGlmIChzdHJpY3QpIHsgcmV0dXJuIHBhcnNlVG9rZW5PbmVEaWdpdDsgfVxuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdTUyc6XG4gICAgICAgICAgICBpZiAoc3RyaWN0KSB7IHJldHVybiBwYXJzZVRva2VuVHdvRGlnaXRzOyB9XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ1NTUyc6XG4gICAgICAgIGNhc2UgJ0RERCc6XG4gICAgICAgICAgICByZXR1cm4gc3RyaWN0ID8gcGFyc2VUb2tlblRocmVlRGlnaXRzIDogcGFyc2VUb2tlbk9uZVRvVGhyZWVEaWdpdHM7XG4gICAgICAgIGNhc2UgJ01NTSc6XG4gICAgICAgIGNhc2UgJ01NTU0nOlxuICAgICAgICBjYXNlICdkZCc6XG4gICAgICAgIGNhc2UgJ2RkZCc6XG4gICAgICAgIGNhc2UgJ2RkZGQnOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5Xb3JkO1xuICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICByZXR1cm4gZ2V0TGFuZ0RlZmluaXRpb24oY29uZmlnLl9sKS5fbWVyaWRpZW1QYXJzZTtcbiAgICAgICAgY2FzZSAnWCc6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlblRpbWVzdGFtcE1zO1xuICAgICAgICBjYXNlICdaJzpcbiAgICAgICAgY2FzZSAnWlonOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5UaW1lem9uZTtcbiAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlblQ7XG4gICAgICAgIGNhc2UgJ1NTU1MnOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5EaWdpdHM7XG4gICAgICAgIGNhc2UgJ01NJzpcbiAgICAgICAgY2FzZSAnREQnOlxuICAgICAgICBjYXNlICdZWSc6XG4gICAgICAgIGNhc2UgJ0dHJzpcbiAgICAgICAgY2FzZSAnZ2cnOlxuICAgICAgICBjYXNlICdISCc6XG4gICAgICAgIGNhc2UgJ2hoJzpcbiAgICAgICAgY2FzZSAnbW0nOlxuICAgICAgICBjYXNlICdzcyc6XG4gICAgICAgIGNhc2UgJ3d3JzpcbiAgICAgICAgY2FzZSAnV1cnOlxuICAgICAgICAgICAgcmV0dXJuIHN0cmljdCA/IHBhcnNlVG9rZW5Ud29EaWdpdHMgOiBwYXJzZVRva2VuT25lT3JUd29EaWdpdHM7XG4gICAgICAgIGNhc2UgJ00nOlxuICAgICAgICBjYXNlICdEJzpcbiAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICBjYXNlICd3JzpcbiAgICAgICAgY2FzZSAnVyc6XG4gICAgICAgIGNhc2UgJ2UnOlxuICAgICAgICBjYXNlICdFJzpcbiAgICAgICAgICAgIHJldHVybiBzdHJpY3QgPyBwYXJzZVRva2VuT25lRGlnaXQgOiBwYXJzZVRva2VuT25lT3JUd29EaWdpdHM7XG4gICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgYSA9IG5ldyBSZWdFeHAocmVnZXhwRXNjYXBlKHVuZXNjYXBlRm9ybWF0KHRva2VuLnJlcGxhY2UoJ1xcXFwnLCAnJykpLCBcImlcIikpO1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0aW1lem9uZU1pbnV0ZXNGcm9tU3RyaW5nKHN0cmluZykge1xuICAgICAgICBzdHJpbmcgPSBzdHJpbmcgfHwgXCJcIjtcbiAgICAgICAgdmFyIHBvc3NpYmxlVHpNYXRjaGVzID0gKHN0cmluZy5tYXRjaChwYXJzZVRva2VuVGltZXpvbmUpIHx8IFtdKSxcbiAgICAgICAgICAgIHR6Q2h1bmsgPSBwb3NzaWJsZVR6TWF0Y2hlc1twb3NzaWJsZVR6TWF0Y2hlcy5sZW5ndGggLSAxXSB8fCBbXSxcbiAgICAgICAgICAgIHBhcnRzID0gKHR6Q2h1bmsgKyAnJykubWF0Y2gocGFyc2VUaW1lem9uZUNodW5rZXIpIHx8IFsnLScsIDAsIDBdLFxuICAgICAgICAgICAgbWludXRlcyA9ICsocGFydHNbMV0gKiA2MCkgKyB0b0ludChwYXJ0c1syXSk7XG5cbiAgICAgICAgcmV0dXJuIHBhcnRzWzBdID09PSAnKycgPyAtbWludXRlcyA6IG1pbnV0ZXM7XG4gICAgfVxuXG4gICAgLy8gZnVuY3Rpb24gdG8gY29udmVydCBzdHJpbmcgaW5wdXQgdG8gZGF0ZVxuICAgIGZ1bmN0aW9uIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBpbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIHZhciBhLCBkYXRlUGFydEFycmF5ID0gY29uZmlnLl9hO1xuXG4gICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgLy8gTU9OVEhcbiAgICAgICAgY2FzZSAnTScgOiAvLyBmYWxsIHRocm91Z2ggdG8gTU1cbiAgICAgICAgY2FzZSAnTU0nIDpcbiAgICAgICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGF0ZVBhcnRBcnJheVtNT05USF0gPSB0b0ludChpbnB1dCkgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ01NTScgOiAvLyBmYWxsIHRocm91Z2ggdG8gTU1NTVxuICAgICAgICBjYXNlICdNTU1NJyA6XG4gICAgICAgICAgICBhID0gZ2V0TGFuZ0RlZmluaXRpb24oY29uZmlnLl9sKS5tb250aHNQYXJzZShpbnB1dCk7XG4gICAgICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZmluZCBhIG1vbnRoIG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZC5cbiAgICAgICAgICAgIGlmIChhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkYXRlUGFydEFycmF5W01PTlRIXSA9IGE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5fcGYuaW52YWxpZE1vbnRoID0gaW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gREFZIE9GIE1PTlRIXG4gICAgICAgIGNhc2UgJ0QnIDogLy8gZmFsbCB0aHJvdWdoIHRvIEREXG4gICAgICAgIGNhc2UgJ0REJyA6XG4gICAgICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRhdGVQYXJ0QXJyYXlbREFURV0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gREFZIE9GIFlFQVJcbiAgICAgICAgY2FzZSAnREREJyA6IC8vIGZhbGwgdGhyb3VnaCB0byBEREREXG4gICAgICAgIGNhc2UgJ0REREQnIDpcbiAgICAgICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0b0ludChpbnB1dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBZRUFSXG4gICAgICAgIGNhc2UgJ1lZJyA6XG4gICAgICAgICAgICBkYXRlUGFydEFycmF5W1lFQVJdID0gdG9JbnQoaW5wdXQpICsgKHRvSW50KGlucHV0KSA+IDY4ID8gMTkwMCA6IDIwMDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1lZWVknIDpcbiAgICAgICAgY2FzZSAnWVlZWVknIDpcbiAgICAgICAgY2FzZSAnWVlZWVlZJyA6XG4gICAgICAgICAgICBkYXRlUGFydEFycmF5W1lFQVJdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIEFNIC8gUE1cbiAgICAgICAgY2FzZSAnYScgOiAvLyBmYWxsIHRocm91Z2ggdG8gQVxuICAgICAgICBjYXNlICdBJyA6XG4gICAgICAgICAgICBjb25maWcuX2lzUG0gPSBnZXRMYW5nRGVmaW5pdGlvbihjb25maWcuX2wpLmlzUE0oaW5wdXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIDI0IEhPVVJcbiAgICAgICAgY2FzZSAnSCcgOiAvLyBmYWxsIHRocm91Z2ggdG8gaGhcbiAgICAgICAgY2FzZSAnSEgnIDogLy8gZmFsbCB0aHJvdWdoIHRvIGhoXG4gICAgICAgIGNhc2UgJ2gnIDogLy8gZmFsbCB0aHJvdWdoIHRvIGhoXG4gICAgICAgIGNhc2UgJ2hoJyA6XG4gICAgICAgICAgICBkYXRlUGFydEFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIE1JTlVURVxuICAgICAgICBjYXNlICdtJyA6IC8vIGZhbGwgdGhyb3VnaCB0byBtbVxuICAgICAgICBjYXNlICdtbScgOlxuICAgICAgICAgICAgZGF0ZVBhcnRBcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFNFQ09ORFxuICAgICAgICBjYXNlICdzJyA6IC8vIGZhbGwgdGhyb3VnaCB0byBzc1xuICAgICAgICBjYXNlICdzcycgOlxuICAgICAgICAgICAgZGF0ZVBhcnRBcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIE1JTExJU0VDT05EXG4gICAgICAgIGNhc2UgJ1MnIDpcbiAgICAgICAgY2FzZSAnU1MnIDpcbiAgICAgICAgY2FzZSAnU1NTJyA6XG4gICAgICAgIGNhc2UgJ1NTU1MnIDpcbiAgICAgICAgICAgIGRhdGVQYXJ0QXJyYXlbTUlMTElTRUNPTkRdID0gdG9JbnQoKCcwLicgKyBpbnB1dCkgKiAxMDAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBVTklYIFRJTUVTVEFNUCBXSVRIIE1TXG4gICAgICAgIGNhc2UgJ1gnOlxuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUocGFyc2VGbG9hdChpbnB1dCkgKiAxMDAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBUSU1FWk9ORVxuICAgICAgICBjYXNlICdaJyA6IC8vIGZhbGwgdGhyb3VnaCB0byBaWlxuICAgICAgICBjYXNlICdaWicgOlxuICAgICAgICAgICAgY29uZmlnLl91c2VVVEMgPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl90em0gPSB0aW1lem9uZU1pbnV0ZXNGcm9tU3RyaW5nKGlucHV0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd3JzpcbiAgICAgICAgY2FzZSAnd3cnOlxuICAgICAgICBjYXNlICdXJzpcbiAgICAgICAgY2FzZSAnV1cnOlxuICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgY2FzZSAnZGQnOlxuICAgICAgICBjYXNlICdkZGQnOlxuICAgICAgICBjYXNlICdkZGRkJzpcbiAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgIGNhc2UgJ0UnOlxuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbi5zdWJzdHIoMCwgMSk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ2dnJzpcbiAgICAgICAgY2FzZSAnZ2dnZyc6XG4gICAgICAgIGNhc2UgJ0dHJzpcbiAgICAgICAgY2FzZSAnR0dHRyc6XG4gICAgICAgIGNhc2UgJ0dHR0dHJzpcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW4uc3Vic3RyKDAsIDIpO1xuICAgICAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl93ID0gY29uZmlnLl93IHx8IHt9O1xuICAgICAgICAgICAgICAgIGNvbmZpZy5fd1t0b2tlbl0gPSBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29udmVydCBhbiBhcnJheSB0byBhIGRhdGUuXG4gICAgLy8gdGhlIGFycmF5IHNob3VsZCBtaXJyb3IgdGhlIHBhcmFtZXRlcnMgYmVsb3dcbiAgICAvLyBub3RlOiBhbGwgdmFsdWVzIHBhc3QgdGhlIHllYXIgYXJlIG9wdGlvbmFsIGFuZCB3aWxsIGRlZmF1bHQgdG8gdGhlIGxvd2VzdCBwb3NzaWJsZSB2YWx1ZS5cbiAgICAvLyBbeWVhciwgbW9udGgsIGRheSAsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZF1cbiAgICBmdW5jdGlvbiBkYXRlRnJvbUNvbmZpZyhjb25maWcpIHtcbiAgICAgICAgdmFyIGksIGRhdGUsIGlucHV0ID0gW10sIGN1cnJlbnREYXRlLFxuICAgICAgICAgICAgeWVhclRvVXNlLCBmaXhZZWFyLCB3LCB0ZW1wLCBsYW5nLCB3ZWVrZGF5LCB3ZWVrO1xuXG4gICAgICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnREYXRlID0gY3VycmVudERhdGVBcnJheShjb25maWcpO1xuXG4gICAgICAgIC8vY29tcHV0ZSBkYXkgb2YgdGhlIHllYXIgZnJvbSB3ZWVrcyBhbmQgd2Vla2RheXNcbiAgICAgICAgaWYgKGNvbmZpZy5fdyAmJiBjb25maWcuX2FbREFURV0gPT0gbnVsbCAmJiBjb25maWcuX2FbTU9OVEhdID09IG51bGwpIHtcbiAgICAgICAgICAgIGZpeFllYXIgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGludF92YWwgPSBwYXJzZUludCh2YWwsIDEwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsID9cbiAgICAgICAgICAgICAgICAgICh2YWwubGVuZ3RoIDwgMyA/IChpbnRfdmFsID4gNjggPyAxOTAwICsgaW50X3ZhbCA6IDIwMDAgKyBpbnRfdmFsKSA6IGludF92YWwpIDpcbiAgICAgICAgICAgICAgICAgIChjb25maWcuX2FbWUVBUl0gPT0gbnVsbCA/IG1vbWVudCgpLndlZWtZZWFyKCkgOiBjb25maWcuX2FbWUVBUl0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdyA9IGNvbmZpZy5fdztcbiAgICAgICAgICAgIGlmICh3LkdHICE9IG51bGwgfHwgdy5XICE9IG51bGwgfHwgdy5FICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0ZW1wID0gZGF5T2ZZZWFyRnJvbVdlZWtzKGZpeFllYXIody5HRyksIHcuVyB8fCAxLCB3LkUsIDQsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFuZyA9IGdldExhbmdEZWZpbml0aW9uKGNvbmZpZy5fbCk7XG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IHcuZCAhPSBudWxsID8gIHBhcnNlV2Vla2RheSh3LmQsIGxhbmcpIDpcbiAgICAgICAgICAgICAgICAgICh3LmUgIT0gbnVsbCA/ICBwYXJzZUludCh3LmUsIDEwKSArIGxhbmcuX3dlZWsuZG93IDogMCk7XG5cbiAgICAgICAgICAgICAgICB3ZWVrID0gcGFyc2VJbnQody53LCAxMCkgfHwgMTtcblxuICAgICAgICAgICAgICAgIC8vaWYgd2UncmUgcGFyc2luZyAnZCcsIHRoZW4gdGhlIGxvdyBkYXkgbnVtYmVycyBtYXkgYmUgbmV4dCB3ZWVrXG4gICAgICAgICAgICAgICAgaWYgKHcuZCAhPSBudWxsICYmIHdlZWtkYXkgPCBsYW5nLl93ZWVrLmRvdykge1xuICAgICAgICAgICAgICAgICAgICB3ZWVrKys7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGVtcCA9IGRheU9mWWVhckZyb21XZWVrcyhmaXhZZWFyKHcuZ2cpLCB3ZWVrLCB3ZWVrZGF5LCBsYW5nLl93ZWVrLmRveSwgbGFuZy5fd2Vlay5kb3cpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25maWcuX2FbWUVBUl0gPSB0ZW1wLnllYXI7XG4gICAgICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRlbXAuZGF5T2ZZZWFyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pZiB0aGUgZGF5IG9mIHRoZSB5ZWFyIGlzIHNldCwgZmlndXJlIG91dCB3aGF0IGl0IGlzXG4gICAgICAgIGlmIChjb25maWcuX2RheU9mWWVhcikge1xuICAgICAgICAgICAgeWVhclRvVXNlID0gY29uZmlnLl9hW1lFQVJdID09IG51bGwgPyBjdXJyZW50RGF0ZVtZRUFSXSA6IGNvbmZpZy5fYVtZRUFSXTtcblxuICAgICAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyVG9Vc2UpKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9wZi5fb3ZlcmZsb3dEYXlPZlllYXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRlID0gbWFrZVVUQ0RhdGUoeWVhclRvVXNlLCAwLCBjb25maWcuX2RheU9mWWVhcik7XG4gICAgICAgICAgICBjb25maWcuX2FbTU9OVEhdID0gZGF0ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgY29uZmlnLl9hW0RBVEVdID0gZGF0ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgZGF0ZS5cbiAgICAgICAgLy8gKiBpZiBubyB5ZWFyLCBtb250aCwgZGF5IG9mIG1vbnRoIGFyZSBnaXZlbiwgZGVmYXVsdCB0byB0b2RheVxuICAgICAgICAvLyAqIGlmIGRheSBvZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBtb250aCBhbmQgeWVhclxuICAgICAgICAvLyAqIGlmIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG9ubHkgeWVhclxuICAgICAgICAvLyAqIGlmIHllYXIgaXMgZ2l2ZW4sIGRvbid0IGRlZmF1bHQgYW55dGhpbmdcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDMgJiYgY29uZmlnLl9hW2ldID09IG51bGw7ICsraSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSBjdXJyZW50RGF0ZVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFplcm8gb3V0IHdoYXRldmVyIHdhcyBub3QgZGVmYXVsdGVkLCBpbmNsdWRpbmcgdGltZVxuICAgICAgICBmb3IgKDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSAoY29uZmlnLl9hW2ldID09IG51bGwpID8gKGkgPT09IDIgPyAxIDogMCkgOiBjb25maWcuX2FbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgdGhlIG9mZnNldHMgdG8gdGhlIHRpbWUgdG8gYmUgcGFyc2VkIHNvIHRoYXQgd2UgY2FuIGhhdmUgYSBjbGVhbiBhcnJheSBmb3IgY2hlY2tpbmcgaXNWYWxpZFxuICAgICAgICBpbnB1dFtIT1VSXSArPSB0b0ludCgoY29uZmlnLl90em0gfHwgMCkgLyA2MCk7XG4gICAgICAgIGlucHV0W01JTlVURV0gKz0gdG9JbnQoKGNvbmZpZy5fdHptIHx8IDApICUgNjApO1xuXG4gICAgICAgIGNvbmZpZy5fZCA9IChjb25maWcuX3VzZVVUQyA/IG1ha2VVVENEYXRlIDogbWFrZURhdGUpLmFwcGx5KG51bGwsIGlucHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXRlRnJvbU9iamVjdChjb25maWcpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dDtcblxuICAgICAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBub3JtYWxpemVkSW5wdXQgPSBub3JtYWxpemVPYmplY3RVbml0cyhjb25maWcuX2kpO1xuICAgICAgICBjb25maWcuX2EgPSBbXG4gICAgICAgICAgICBub3JtYWxpemVkSW5wdXQueWVhcixcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dC5tb250aCxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dC5kYXksXG4gICAgICAgICAgICBub3JtYWxpemVkSW5wdXQuaG91cixcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dC5taW51dGUsXG4gICAgICAgICAgICBub3JtYWxpemVkSW5wdXQuc2Vjb25kLFxuICAgICAgICAgICAgbm9ybWFsaXplZElucHV0Lm1pbGxpc2Vjb25kXG4gICAgICAgIF07XG5cbiAgICAgICAgZGF0ZUZyb21Db25maWcoY29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZykge1xuICAgICAgICB2YXIgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIG5vdy5nZXRVVENGdWxsWWVhcigpLFxuICAgICAgICAgICAgICAgIG5vdy5nZXRVVENNb250aCgpLFxuICAgICAgICAgICAgICAgIG5vdy5nZXRVVENEYXRlKClcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW25vdy5nZXRGdWxsWWVhcigpLCBub3cuZ2V0TW9udGgoKSwgbm93LmdldERhdGUoKV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBmb3JtYXQgc3RyaW5nXG4gICAgZnVuY3Rpb24gbWFrZURhdGVGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZykge1xuXG4gICAgICAgIGNvbmZpZy5fYSA9IFtdO1xuICAgICAgICBjb25maWcuX3BmLmVtcHR5ID0gdHJ1ZTtcblxuICAgICAgICAvLyBUaGlzIGFycmF5IGlzIHVzZWQgdG8gbWFrZSBhIERhdGUsIGVpdGhlciB3aXRoIGBuZXcgRGF0ZWAgb3IgYERhdGUuVVRDYFxuICAgICAgICB2YXIgbGFuZyA9IGdldExhbmdEZWZpbml0aW9uKGNvbmZpZy5fbCksXG4gICAgICAgICAgICBzdHJpbmcgPSAnJyArIGNvbmZpZy5faSxcbiAgICAgICAgICAgIGksIHBhcnNlZElucHV0LCB0b2tlbnMsIHRva2VuLCBza2lwcGVkLFxuICAgICAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggPSAwO1xuXG4gICAgICAgIHRva2VucyA9IGV4cGFuZEZvcm1hdChjb25maWcuX2YsIGxhbmcpLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpIHx8IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgcGFyc2VkSW5wdXQgPSAoc3RyaW5nLm1hdGNoKGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSkgfHwgW10pWzBdO1xuICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgc2tpcHBlZCA9IHN0cmluZy5zdWJzdHIoMCwgc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcHBlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5fcGYudW51c2VkSW5wdXQucHVzaChza2lwcGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSArIHBhcnNlZElucHV0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCArPSBwYXJzZWRJbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkb24ndCBwYXJzZSBpZiBpdCdzIG5vdCBhIGtub3duIHRva2VuXG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5fcGYuZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5fcGYudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgcGFyc2VkSW5wdXQsIGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb25maWcuX3N0cmljdCAmJiAhcGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX3BmLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCByZW1haW5pbmcgdW5wYXJzZWQgaW5wdXQgbGVuZ3RoIHRvIHRoZSBzdHJpbmdcbiAgICAgICAgY29uZmlnLl9wZi5jaGFyc0xlZnRPdmVyID0gc3RyaW5nTGVuZ3RoIC0gdG90YWxQYXJzZWRJbnB1dExlbmd0aDtcbiAgICAgICAgaWYgKHN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25maWcuX3BmLnVudXNlZElucHV0LnB1c2goc3RyaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSBhbSBwbVxuICAgICAgICBpZiAoY29uZmlnLl9pc1BtICYmIGNvbmZpZy5fYVtIT1VSXSA8IDEyKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gKz0gMTI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgaXMgMTIgYW0sIGNoYW5nZSBob3VycyB0byAwXG4gICAgICAgIGlmIChjb25maWcuX2lzUG0gPT09IGZhbHNlICYmIGNvbmZpZy5fYVtIT1VSXSA9PT0gMTIpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRlRnJvbUNvbmZpZyhjb25maWcpO1xuICAgICAgICBjaGVja092ZXJmbG93KGNvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5lc2NhcGVGb3JtYXQocykge1xuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKC9cXFxcKFxcWyl8XFxcXChcXF0pfFxcWyhbXlxcXVxcW10qKVxcXXxcXFxcKC4pL2csIGZ1bmN0aW9uIChtYXRjaGVkLCBwMSwgcDIsIHAzLCBwNCkge1xuICAgICAgICAgICAgcmV0dXJuIHAxIHx8IHAyIHx8IHAzIHx8IHA0O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBDb2RlIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNTYxNDkzL2lzLXRoZXJlLWEtcmVnZXhwLWVzY2FwZS1mdW5jdGlvbi1pbi1qYXZhc2NyaXB0XG4gICAgZnVuY3Rpb24gcmVnZXhwRXNjYXBlKHMpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgYXJyYXkgb2YgZm9ybWF0IHN0cmluZ3NcbiAgICBmdW5jdGlvbiBtYWtlRGF0ZUZyb21TdHJpbmdBbmRBcnJheShjb25maWcpIHtcbiAgICAgICAgdmFyIHRlbXBDb25maWcsXG4gICAgICAgICAgICBiZXN0TW9tZW50LFxuXG4gICAgICAgICAgICBzY29yZVRvQmVhdCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbmZpZy5fcGYuaW52YWxpZEZvcm1hdCA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbmZpZy5fZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3VycmVudFNjb3JlID0gMDtcbiAgICAgICAgICAgIHRlbXBDb25maWcgPSBleHRlbmQoe30sIGNvbmZpZyk7XG4gICAgICAgICAgICBpbml0aWFsaXplUGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpO1xuICAgICAgICAgICAgdGVtcENvbmZpZy5fZiA9IGNvbmZpZy5fZltpXTtcbiAgICAgICAgICAgIG1ha2VEYXRlRnJvbVN0cmluZ0FuZEZvcm1hdCh0ZW1wQ29uZmlnKTtcblxuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKHRlbXBDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFueSBpbnB1dCB0aGF0IHdhcyBub3QgcGFyc2VkIGFkZCBhIHBlbmFsdHkgZm9yIHRoYXQgZm9ybWF0XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gdGVtcENvbmZpZy5fcGYuY2hhcnNMZWZ0T3ZlcjtcblxuICAgICAgICAgICAgLy9vciB0b2tlbnNcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSB0ZW1wQ29uZmlnLl9wZi51bnVzZWRUb2tlbnMubGVuZ3RoICogMTA7XG5cbiAgICAgICAgICAgIHRlbXBDb25maWcuX3BmLnNjb3JlID0gY3VycmVudFNjb3JlO1xuXG4gICAgICAgICAgICBpZiAoc2NvcmVUb0JlYXQgPT0gbnVsbCB8fCBjdXJyZW50U2NvcmUgPCBzY29yZVRvQmVhdCkge1xuICAgICAgICAgICAgICAgIHNjb3JlVG9CZWF0ID0gY3VycmVudFNjb3JlO1xuICAgICAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXh0ZW5kKGNvbmZpZywgYmVzdE1vbWVudCB8fCB0ZW1wQ29uZmlnKTtcbiAgICB9XG5cbiAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdFxuICAgIGZ1bmN0aW9uIG1ha2VEYXRlRnJvbVN0cmluZyhjb25maWcpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBzdHJpbmcgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBtYXRjaCA9IGlzb1JlZ2V4LmV4ZWMoc3RyaW5nKTtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fcGYuaXNvID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoaSA9IDQ7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hbNV0gc2hvdWxkIGJlIFwiVFwiIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2YgPSBpc29EYXRlc1tpIC0gMV0gKyAobWF0Y2hbNl0gfHwgXCIgXCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzb1RpbWVzW2ldWzFdLmV4ZWMoc3RyaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2YgKz0gaXNvVGltZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHJpbmcubWF0Y2gocGFyc2VUb2tlblRpbWV6b25lKSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5fZiArPSBcIlpcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1ha2VEYXRlRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoc3RyaW5nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VEYXRlRnJvbUlucHV0KGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBtYXRjaGVkID0gYXNwTmV0SnNvblJlZ2V4LmV4ZWMoaW5wdXQpO1xuXG4gICAgICAgIGlmIChpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCttYXRjaGVkWzFdKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBtYWtlRGF0ZUZyb21TdHJpbmcoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9hID0gaW5wdXQuc2xpY2UoMCk7XG4gICAgICAgICAgICBkYXRlRnJvbUNvbmZpZyhjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCtpbnB1dCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKGlucHV0KSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGRhdGVGcm9tT2JqZWN0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlRGF0ZSh5LCBtLCBkLCBoLCBNLCBzLCBtcykge1xuICAgICAgICAvL2Nhbid0IGp1c3QgYXBwbHkoKSB0byBjcmVhdGUgYSBkYXRlOlxuICAgICAgICAvL2h0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTgxMzQ4L2luc3RhbnRpYXRpbmctYS1qYXZhc2NyaXB0LW9iamVjdC1ieS1jYWxsaW5nLXByb3RvdHlwZS1jb25zdHJ1Y3Rvci1hcHBseVxuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHksIG0sIGQsIGgsIE0sIHMsIG1zKTtcblxuICAgICAgICAvL3RoZSBkYXRlIGNvbnN0cnVjdG9yIGRvZXNuJ3QgYWNjZXB0IHllYXJzIDwgMTk3MFxuICAgICAgICBpZiAoeSA8IDE5NzApIHtcbiAgICAgICAgICAgIGRhdGUuc2V0RnVsbFllYXIoeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZVVUQ0RhdGUoeSkge1xuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgICAgICBpZiAoeSA8IDE5NzApIHtcbiAgICAgICAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGlucHV0LCBsYW5ndWFnZSkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKCFpc05hTihpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGxhbmd1YWdlLndlZWtkYXlzUGFyc2UoaW5wdXQpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBSZWxhdGl2ZSBUaW1lXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gZm9yIG1vbWVudC5mbi5mcm9tLCBtb21lbnQuZm4uZnJvbU5vdywgYW5kIG1vbWVudC5kdXJhdGlvbi5mbi5odW1hbml6ZVxuICAgIGZ1bmN0aW9uIHN1YnN0aXR1dGVUaW1lQWdvKHN0cmluZywgbnVtYmVyLCB3aXRob3V0U3VmZml4LCBpc0Z1dHVyZSwgbGFuZykge1xuICAgICAgICByZXR1cm4gbGFuZy5yZWxhdGl2ZVRpbWUobnVtYmVyIHx8IDEsICEhd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVsYXRpdmVUaW1lKG1pbGxpc2Vjb25kcywgd2l0aG91dFN1ZmZpeCwgbGFuZykge1xuICAgICAgICB2YXIgc2Vjb25kcyA9IHJvdW5kKE1hdGguYWJzKG1pbGxpc2Vjb25kcykgLyAxMDAwKSxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSByb3VuZChzZWNvbmRzIC8gNjApLFxuICAgICAgICAgICAgaG91cnMgPSByb3VuZChtaW51dGVzIC8gNjApLFxuICAgICAgICAgICAgZGF5cyA9IHJvdW5kKGhvdXJzIC8gMjQpLFxuICAgICAgICAgICAgeWVhcnMgPSByb3VuZChkYXlzIC8gMzY1KSxcbiAgICAgICAgICAgIGFyZ3MgPSBzZWNvbmRzIDwgNDUgJiYgWydzJywgc2Vjb25kc10gfHxcbiAgICAgICAgICAgICAgICBtaW51dGVzID09PSAxICYmIFsnbSddIHx8XG4gICAgICAgICAgICAgICAgbWludXRlcyA8IDQ1ICYmIFsnbW0nLCBtaW51dGVzXSB8fFxuICAgICAgICAgICAgICAgIGhvdXJzID09PSAxICYmIFsnaCddIHx8XG4gICAgICAgICAgICAgICAgaG91cnMgPCAyMiAmJiBbJ2hoJywgaG91cnNdIHx8XG4gICAgICAgICAgICAgICAgZGF5cyA9PT0gMSAmJiBbJ2QnXSB8fFxuICAgICAgICAgICAgICAgIGRheXMgPD0gMjUgJiYgWydkZCcsIGRheXNdIHx8XG4gICAgICAgICAgICAgICAgZGF5cyA8PSA0NSAmJiBbJ00nXSB8fFxuICAgICAgICAgICAgICAgIGRheXMgPCAzNDUgJiYgWydNTScsIHJvdW5kKGRheXMgLyAzMCldIHx8XG4gICAgICAgICAgICAgICAgeWVhcnMgPT09IDEgJiYgWyd5J10gfHwgWyd5eScsIHllYXJzXTtcbiAgICAgICAgYXJnc1syXSA9IHdpdGhvdXRTdWZmaXg7XG4gICAgICAgIGFyZ3NbM10gPSBtaWxsaXNlY29uZHMgPiAwO1xuICAgICAgICBhcmdzWzRdID0gbGFuZztcbiAgICAgICAgcmV0dXJuIHN1YnN0aXR1dGVUaW1lQWdvLmFwcGx5KHt9LCBhcmdzKTtcbiAgICB9XG5cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgV2VlayBvZiBZZWFyXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgICAvLyBmaXJzdERheU9mV2VlayAgICAgICAwID0gc3VuLCA2ID0gc2F0XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgdGhlIGRheSBvZiB0aGUgd2VlayB0aGF0IHN0YXJ0cyB0aGUgd2Vla1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICh1c3VhbGx5IHN1bmRheSBvciBtb25kYXkpXG4gICAgLy8gZmlyc3REYXlPZldlZWtPZlllYXIgMCA9IHN1biwgNiA9IHNhdFxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgIHRoZSBmaXJzdCB3ZWVrIGlzIHRoZSB3ZWVrIHRoYXQgY29udGFpbnMgdGhlIGZpcnN0XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgb2YgdGhpcyBkYXkgb2YgdGhlIHdlZWtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAoZWcuIElTTyB3ZWVrcyB1c2UgdGh1cnNkYXkgKDQpKVxuICAgIGZ1bmN0aW9uIHdlZWtPZlllYXIobW9tLCBmaXJzdERheU9mV2VlaywgZmlyc3REYXlPZldlZWtPZlllYXIpIHtcbiAgICAgICAgdmFyIGVuZCA9IGZpcnN0RGF5T2ZXZWVrT2ZZZWFyIC0gZmlyc3REYXlPZldlZWssXG4gICAgICAgICAgICBkYXlzVG9EYXlPZldlZWsgPSBmaXJzdERheU9mV2Vla09mWWVhciAtIG1vbS5kYXkoKSxcbiAgICAgICAgICAgIGFkanVzdGVkTW9tZW50O1xuXG5cbiAgICAgICAgaWYgKGRheXNUb0RheU9mV2VlayA+IGVuZCkge1xuICAgICAgICAgICAgZGF5c1RvRGF5T2ZXZWVrIC09IDc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF5c1RvRGF5T2ZXZWVrIDwgZW5kIC0gNykge1xuICAgICAgICAgICAgZGF5c1RvRGF5T2ZXZWVrICs9IDc7XG4gICAgICAgIH1cblxuICAgICAgICBhZGp1c3RlZE1vbWVudCA9IG1vbWVudChtb20pLmFkZCgnZCcsIGRheXNUb0RheU9mV2Vlayk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3ZWVrOiBNYXRoLmNlaWwoYWRqdXN0ZWRNb21lbnQuZGF5T2ZZZWFyKCkgLyA3KSxcbiAgICAgICAgICAgIHllYXI6IGFkanVzdGVkTW9tZW50LnllYXIoKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlI0NhbGN1bGF0aW5nX2FfZGF0ZV9naXZlbl90aGVfeWVhci4yQ193ZWVrX251bWJlcl9hbmRfd2Vla2RheVxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrcyh5ZWFyLCB3ZWVrLCB3ZWVrZGF5LCBmaXJzdERheU9mV2Vla09mWWVhciwgZmlyc3REYXlPZldlZWspIHtcbiAgICAgICAgLy8gVGhlIG9ubHkgc29saWQgd2F5IHRvIGNyZWF0ZSBhbiBpc28gZGF0ZSBmcm9tIHllYXIgaXMgdG8gdXNlXG4gICAgICAgIC8vIGEgc3RyaW5nIGZvcm1hdCAoRGF0ZS5VVEMgaGFuZGxlcyBvbmx5IHllYXJzID4gMTkwMCkuIERvbid0IGFzayB3aHlcbiAgICAgICAgLy8gaXQgZG9lc24ndCBuZWVkIFogYXQgdGhlIGVuZC5cbiAgICAgICAgdmFyIGQgPSBuZXcgRGF0ZShsZWZ0WmVyb0ZpbGwoeWVhciwgNiwgdHJ1ZSkgKyAnLTAxLTAxJykuZ2V0VVRDRGF5KCksXG4gICAgICAgICAgICBkYXlzVG9BZGQsIGRheU9mWWVhcjtcblxuICAgICAgICB3ZWVrZGF5ID0gd2Vla2RheSAhPSBudWxsID8gd2Vla2RheSA6IGZpcnN0RGF5T2ZXZWVrO1xuICAgICAgICBkYXlzVG9BZGQgPSBmaXJzdERheU9mV2VlayAtIGQgKyAoZCA+IGZpcnN0RGF5T2ZXZWVrT2ZZZWFyID8gNyA6IDApO1xuICAgICAgICBkYXlPZlllYXIgPSA3ICogKHdlZWsgLSAxKSArICh3ZWVrZGF5IC0gZmlyc3REYXlPZldlZWspICsgZGF5c1RvQWRkICsgMTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcjogZGF5T2ZZZWFyID4gMCA/IHllYXIgOiB5ZWFyIC0gMSxcbiAgICAgICAgICAgIGRheU9mWWVhcjogZGF5T2ZZZWFyID4gMCA/ICBkYXlPZlllYXIgOiBkYXlzSW5ZZWFyKHllYXIgLSAxKSArIGRheU9mWWVhclxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgVG9wIExldmVsIEZ1bmN0aW9uc1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIGZ1bmN0aW9uIG1ha2VNb21lbnQoY29uZmlnKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGNvbmZpZy5fZjtcblxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy5fcGYgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpbml0aWFsaXplUGFyc2luZ0ZsYWdzKGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBtb21lbnQuaW52YWxpZCh7bnVsbElucHV0OiB0cnVlfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uZmlnLl9pID0gaW5wdXQgPSBnZXRMYW5nRGVmaW5pdGlvbigpLnByZXBhcnNlKGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb21lbnQuaXNNb21lbnQoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcgPSBleHRlbmQoe30sIGlucHV0KTtcblxuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoK2lucHV0Ll9kKTtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQpIHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICBtYWtlRGF0ZUZyb21TdHJpbmdBbmRBcnJheShjb25maWcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYWtlRGF0ZUZyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1ha2VEYXRlRnJvbUlucHV0KGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IE1vbWVudChjb25maWcpO1xuICAgIH1cblxuICAgIG1vbWVudCA9IGZ1bmN0aW9uIChpbnB1dCwgZm9ybWF0LCBsYW5nLCBzdHJpY3QpIHtcbiAgICAgICAgaWYgKHR5cGVvZihsYW5nKSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHN0cmljdCA9IGxhbmc7XG4gICAgICAgICAgICBsYW5nID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYWtlTW9tZW50KHtcbiAgICAgICAgICAgIF9pIDogaW5wdXQsXG4gICAgICAgICAgICBfZiA6IGZvcm1hdCxcbiAgICAgICAgICAgIF9sIDogbGFuZyxcbiAgICAgICAgICAgIF9zdHJpY3QgOiBzdHJpY3QsXG4gICAgICAgICAgICBfaXNVVEMgOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gY3JlYXRpbmcgd2l0aCB1dGNcbiAgICBtb21lbnQudXRjID0gZnVuY3Rpb24gKGlucHV0LCBmb3JtYXQsIGxhbmcsIHN0cmljdCkge1xuICAgICAgICB2YXIgbTtcblxuICAgICAgICBpZiAodHlwZW9mKGxhbmcpID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgc3RyaWN0ID0gbGFuZztcbiAgICAgICAgICAgIGxhbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbSA9IG1ha2VNb21lbnQoe1xuICAgICAgICAgICAgX3VzZVVUQyA6IHRydWUsXG4gICAgICAgICAgICBfaXNVVEMgOiB0cnVlLFxuICAgICAgICAgICAgX2wgOiBsYW5nLFxuICAgICAgICAgICAgX2kgOiBpbnB1dCxcbiAgICAgICAgICAgIF9mIDogZm9ybWF0LFxuICAgICAgICAgICAgX3N0cmljdCA6IHN0cmljdFxuICAgICAgICB9KS51dGMoKTtcblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9O1xuXG4gICAgLy8gY3JlYXRpbmcgd2l0aCB1bml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcylcbiAgICBtb21lbnQudW5peCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gbW9tZW50KGlucHV0ICogMTAwMCk7XG4gICAgfTtcblxuICAgIC8vIGR1cmF0aW9uXG4gICAgbW9tZW50LmR1cmF0aW9uID0gZnVuY3Rpb24gKGlucHV0LCBrZXkpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gaW5wdXQsXG4gICAgICAgICAgICAvLyBtYXRjaGluZyBhZ2FpbnN0IHJlZ2V4cCBpcyBleHBlbnNpdmUsIGRvIGl0IG9uIGRlbWFuZFxuICAgICAgICAgICAgbWF0Y2ggPSBudWxsLFxuICAgICAgICAgICAgc2lnbixcbiAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgIHBhcnNlSXNvO1xuXG4gICAgICAgIGlmIChtb21lbnQuaXNEdXJhdGlvbihpbnB1dCkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIG1zOiBpbnB1dC5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgICAgIGQ6IGlucHV0Ll9kYXlzLFxuICAgICAgICAgICAgICAgIE06IGlucHV0Ll9tb250aHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbltrZXldID0gaW5wdXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uLm1pbGxpc2Vjb25kcyA9IGlucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gYXNwTmV0VGltZVNwYW5Kc29uUmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSBcIi1cIikgPyAtMSA6IDE7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgIGQ6IHRvSW50KG1hdGNoW0RBVEVdKSAqIHNpZ24sXG4gICAgICAgICAgICAgICAgaDogdG9JbnQobWF0Y2hbSE9VUl0pICogc2lnbixcbiAgICAgICAgICAgICAgICBtOiB0b0ludChtYXRjaFtNSU5VVEVdKSAqIHNpZ24sXG4gICAgICAgICAgICAgICAgczogdG9JbnQobWF0Y2hbU0VDT05EXSkgKiBzaWduLFxuICAgICAgICAgICAgICAgIG1zOiB0b0ludChtYXRjaFtNSUxMSVNFQ09ORF0pICogc2lnblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGlzb0R1cmF0aW9uUmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSBcIi1cIikgPyAtMSA6IDE7XG4gICAgICAgICAgICBwYXJzZUlzbyA9IGZ1bmN0aW9uIChpbnApIHtcbiAgICAgICAgICAgICAgICAvLyBXZSdkIG5vcm1hbGx5IHVzZSB+fmlucCBmb3IgdGhpcywgYnV0IHVuZm9ydHVuYXRlbHkgaXQgYWxzb1xuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnRzIGZsb2F0cyB0byBpbnRzLlxuICAgICAgICAgICAgICAgIC8vIGlucCBtYXkgYmUgdW5kZWZpbmVkLCBzbyBjYXJlZnVsIGNhbGxpbmcgcmVwbGFjZSBvbiBpdC5cbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gaW5wICYmIHBhcnNlRmxvYXQoaW5wLnJlcGxhY2UoJywnLCAnLicpKTtcbiAgICAgICAgICAgICAgICAvLyBhcHBseSBzaWduIHdoaWxlIHdlJ3JlIGF0IGl0XG4gICAgICAgICAgICAgICAgcmV0dXJuIChpc05hTihyZXMpID8gMCA6IHJlcykgKiBzaWduO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHk6IHBhcnNlSXNvKG1hdGNoWzJdKSxcbiAgICAgICAgICAgICAgICBNOiBwYXJzZUlzbyhtYXRjaFszXSksXG4gICAgICAgICAgICAgICAgZDogcGFyc2VJc28obWF0Y2hbNF0pLFxuICAgICAgICAgICAgICAgIGg6IHBhcnNlSXNvKG1hdGNoWzVdKSxcbiAgICAgICAgICAgICAgICBtOiBwYXJzZUlzbyhtYXRjaFs2XSksXG4gICAgICAgICAgICAgICAgczogcGFyc2VJc28obWF0Y2hbN10pLFxuICAgICAgICAgICAgICAgIHc6IHBhcnNlSXNvKG1hdGNoWzhdKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldCA9IG5ldyBEdXJhdGlvbihkdXJhdGlvbik7XG5cbiAgICAgICAgaWYgKG1vbWVudC5pc0R1cmF0aW9uKGlucHV0KSAmJiBpbnB1dC5oYXNPd25Qcm9wZXJ0eSgnX2xhbmcnKSkge1xuICAgICAgICAgICAgcmV0Ll9sYW5nID0gaW5wdXQuX2xhbmc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICAvLyB2ZXJzaW9uIG51bWJlclxuICAgIG1vbWVudC52ZXJzaW9uID0gVkVSU0lPTjtcblxuICAgIC8vIGRlZmF1bHQgZm9ybWF0XG4gICAgbW9tZW50LmRlZmF1bHRGb3JtYXQgPSBpc29Gb3JtYXQ7XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIGEgbW9tZW50IGlzIG11dGF0ZWQuXG4gICAgLy8gSXQgaXMgaW50ZW5kZWQgdG8ga2VlcCB0aGUgb2Zmc2V0IGluIHN5bmMgd2l0aCB0aGUgdGltZXpvbmUuXG4gICAgbW9tZW50LnVwZGF0ZU9mZnNldCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbGFuZ3VhZ2VzIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxhbmd1YWdlLiAgSWZcbiAgICAvLyBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbiwgaXQgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50IGdsb2JhbFxuICAgIC8vIGxhbmd1YWdlIGtleS5cbiAgICBtb21lbnQubGFuZyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlcykge1xuICAgICAgICB2YXIgcjtcbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBtb21lbnQuZm4uX2xhbmcuX2FiYnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAgICAgbG9hZExhbmcobm9ybWFsaXplTGFuZ3VhZ2Uoa2V5KSwgdmFsdWVzKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHVubG9hZExhbmcoa2V5KTtcbiAgICAgICAgICAgIGtleSA9ICdlbic7XG4gICAgICAgIH0gZWxzZSBpZiAoIWxhbmd1YWdlc1trZXldKSB7XG4gICAgICAgICAgICBnZXRMYW5nRGVmaW5pdGlvbihrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHIgPSBtb21lbnQuZHVyYXRpb24uZm4uX2xhbmcgPSBtb21lbnQuZm4uX2xhbmcgPSBnZXRMYW5nRGVmaW5pdGlvbihrZXkpO1xuICAgICAgICByZXR1cm4gci5fYWJicjtcbiAgICB9O1xuXG4gICAgLy8gcmV0dXJucyBsYW5ndWFnZSBkYXRhXG4gICAgbW9tZW50LmxhbmdEYXRhID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoa2V5ICYmIGtleS5fbGFuZyAmJiBrZXkuX2xhbmcuX2FiYnIpIHtcbiAgICAgICAgICAgIGtleSA9IGtleS5fbGFuZy5fYWJicjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0TGFuZ0RlZmluaXRpb24oa2V5KTtcbiAgICB9O1xuXG4gICAgLy8gY29tcGFyZSBtb21lbnQgb2JqZWN0XG4gICAgbW9tZW50LmlzTW9tZW50ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgTW9tZW50O1xuICAgIH07XG5cbiAgICAvLyBmb3IgdHlwZWNoZWNraW5nIER1cmF0aW9uIG9iamVjdHNcbiAgICBtb21lbnQuaXNEdXJhdGlvbiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIER1cmF0aW9uO1xuICAgIH07XG5cbiAgICBmb3IgKGkgPSBsaXN0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBtYWtlTGlzdChsaXN0c1tpXSk7XG4gICAgfVxuXG4gICAgbW9tZW50Lm5vcm1hbGl6ZVVuaXRzID0gZnVuY3Rpb24gKHVuaXRzKSB7XG4gICAgICAgIHJldHVybiBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgfTtcblxuICAgIG1vbWVudC5pbnZhbGlkID0gZnVuY3Rpb24gKGZsYWdzKSB7XG4gICAgICAgIHZhciBtID0gbW9tZW50LnV0YyhOYU4pO1xuICAgICAgICBpZiAoZmxhZ3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgZXh0ZW5kKG0uX3BmLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtLl9wZi51c2VySW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfTtcblxuICAgIG1vbWVudC5wYXJzZVpvbmUgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG1vbWVudChpbnB1dCkucGFyc2Vab25lKCk7XG4gICAgfTtcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgTW9tZW50IFByb3RvdHlwZVxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgZXh0ZW5kKG1vbWVudC5mbiA9IE1vbWVudC5wcm90b3R5cGUsIHtcblxuICAgICAgICBjbG9uZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBtb21lbnQodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdmFsdWVPZiA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiArdGhpcy5fZCArICgodGhpcy5fb2Zmc2V0IHx8IDApICogNjAwMDApO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVuaXggOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigrdGhpcyAvIDEwMDApO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRvU3RyaW5nIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5sYW5nKCdlbicpLmZvcm1hdChcImRkZCBNTU0gREQgWVlZWSBISDptbTpzcyBbR01UXVpaXCIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRvRGF0ZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vZmZzZXQgPyBuZXcgRGF0ZSgrdGhpcykgOiB0aGlzLl9kO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRvSVNPU3RyaW5nIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG0gPSBtb21lbnQodGhpcykudXRjKCk7XG4gICAgICAgICAgICBpZiAoMCA8IG0ueWVhcigpICYmIG0ueWVhcigpIDw9IDk5OTkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHRvQXJyYXkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIG0ueWVhcigpLFxuICAgICAgICAgICAgICAgIG0ubW9udGgoKSxcbiAgICAgICAgICAgICAgICBtLmRhdGUoKSxcbiAgICAgICAgICAgICAgICBtLmhvdXJzKCksXG4gICAgICAgICAgICAgICAgbS5taW51dGVzKCksXG4gICAgICAgICAgICAgICAgbS5zZWNvbmRzKCksXG4gICAgICAgICAgICAgICAgbS5taWxsaXNlY29uZHMoKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc1ZhbGlkIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWQodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNEU1RTaGlmdGVkIDogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSAmJiBjb21wYXJlQXJyYXlzKHRoaXMuX2EsICh0aGlzLl9pc1VUQyA/IG1vbWVudC51dGModGhpcy5fYSkgOiBtb21lbnQodGhpcy5fYSkpLnRvQXJyYXkoKSkgPiAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFyc2luZ0ZsYWdzIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dGVuZCh7fSwgdGhpcy5fcGYpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGludmFsaWRBdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BmLm92ZXJmbG93O1xuICAgICAgICB9LFxuXG4gICAgICAgIHV0YyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnpvbmUoMCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbG9jYWwgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnpvbmUoMCk7XG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZm9ybWF0IDogZnVuY3Rpb24gKGlucHV0U3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gZm9ybWF0TW9tZW50KHRoaXMsIGlucHV0U3RyaW5nIHx8IG1vbWVudC5kZWZhdWx0Rm9ybWF0KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhbmcoKS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkIDogZnVuY3Rpb24gKGlucHV0LCB2YWwpIHtcbiAgICAgICAgICAgIHZhciBkdXI7XG4gICAgICAgICAgICAvLyBzd2l0Y2ggYXJncyB0byBzdXBwb3J0IGFkZCgncycsIDEpIGFuZCBhZGQoMSwgJ3MnKVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBkdXIgPSBtb21lbnQuZHVyYXRpb24oK3ZhbCwgaW5wdXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkdXIgPSBtb21lbnQuZHVyYXRpb24oaW5wdXQsIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRPclN1YnRyYWN0RHVyYXRpb25Gcm9tTW9tZW50KHRoaXMsIGR1ciwgMSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBzdWJ0cmFjdCA6IGZ1bmN0aW9uIChpbnB1dCwgdmFsKSB7XG4gICAgICAgICAgICB2YXIgZHVyO1xuICAgICAgICAgICAgLy8gc3dpdGNoIGFyZ3MgdG8gc3VwcG9ydCBzdWJ0cmFjdCgncycsIDEpIGFuZCBzdWJ0cmFjdCgxLCAncycpXG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGR1ciA9IG1vbWVudC5kdXJhdGlvbigrdmFsLCBpbnB1dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGR1ciA9IG1vbWVudC5kdXJhdGlvbihpbnB1dCwgdmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZE9yU3VidHJhY3REdXJhdGlvbkZyb21Nb21lbnQodGhpcywgZHVyLCAtMSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBkaWZmIDogZnVuY3Rpb24gKGlucHV0LCB1bml0cywgYXNGbG9hdCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSBtYWtlQXMoaW5wdXQsIHRoaXMpLFxuICAgICAgICAgICAgICAgIHpvbmVEaWZmID0gKHRoaXMuem9uZSgpIC0gdGhhdC56b25lKCkpICogNmU0LFxuICAgICAgICAgICAgICAgIGRpZmYsIG91dHB1dDtcblxuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgICAgIGlmICh1bml0cyA9PT0gJ3llYXInIHx8IHVuaXRzID09PSAnbW9udGgnKSB7XG4gICAgICAgICAgICAgICAgLy8gYXZlcmFnZSBudW1iZXIgb2YgZGF5cyBpbiB0aGUgbW9udGhzIGluIHRoZSBnaXZlbiBkYXRlc1xuICAgICAgICAgICAgICAgIGRpZmYgPSAodGhpcy5kYXlzSW5Nb250aCgpICsgdGhhdC5kYXlzSW5Nb250aCgpKSAqIDQzMmU1OyAvLyAyNCAqIDYwICogNjAgKiAxMDAwIC8gMlxuICAgICAgICAgICAgICAgIC8vIGRpZmZlcmVuY2UgaW4gbW9udGhzXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKCh0aGlzLnllYXIoKSAtIHRoYXQueWVhcigpKSAqIDEyKSArICh0aGlzLm1vbnRoKCkgLSB0aGF0Lm1vbnRoKCkpO1xuICAgICAgICAgICAgICAgIC8vIGFkanVzdCBieSB0YWtpbmcgZGlmZmVyZW5jZSBpbiBkYXlzLCBhdmVyYWdlIG51bWJlciBvZiBkYXlzXG4gICAgICAgICAgICAgICAgLy8gYW5kIGRzdCBpbiB0aGUgZ2l2ZW4gbW9udGhzLlxuICAgICAgICAgICAgICAgIG91dHB1dCArPSAoKHRoaXMgLSBtb21lbnQodGhpcykuc3RhcnRPZignbW9udGgnKSkgLVxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoYXQgLSBtb21lbnQodGhhdCkuc3RhcnRPZignbW9udGgnKSkpIC8gZGlmZjtcbiAgICAgICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aXRoIHpvbmVzLCB0byBuZWdhdGUgYWxsIGRzdFxuICAgICAgICAgICAgICAgIG91dHB1dCAtPSAoKHRoaXMuem9uZSgpIC0gbW9tZW50KHRoaXMpLnN0YXJ0T2YoJ21vbnRoJykuem9uZSgpKSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhhdC56b25lKCkgLSBtb21lbnQodGhhdCkuc3RhcnRPZignbW9udGgnKS56b25lKCkpKSAqIDZlNCAvIGRpZmY7XG4gICAgICAgICAgICAgICAgaWYgKHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0IC8gMTI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaWZmID0gKHRoaXMgLSB0aGF0KTtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB1bml0cyA9PT0gJ3NlY29uZCcgPyBkaWZmIC8gMWUzIDogLy8gMTAwMFxuICAgICAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ21pbnV0ZScgPyBkaWZmIC8gNmU0IDogLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICAgICAgICAgIHVuaXRzID09PSAnaG91cicgPyBkaWZmIC8gMzZlNSA6IC8vIDEwMDAgKiA2MCAqIDYwXG4gICAgICAgICAgICAgICAgICAgIHVuaXRzID09PSAnZGF5JyA/IChkaWZmIC0gem9uZURpZmYpIC8gODY0ZTUgOiAvLyAxMDAwICogNjAgKiA2MCAqIDI0LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICAgICAgICAgIHVuaXRzID09PSAnd2VlaycgPyAoZGlmZiAtIHpvbmVEaWZmKSAvIDYwNDhlNSA6IC8vIDEwMDAgKiA2MCAqIDYwICogMjQgKiA3LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICAgICAgICAgIGRpZmY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXNGbG9hdCA/IG91dHB1dCA6IGFic1JvdW5kKG91dHB1dCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZnJvbSA6IGZ1bmN0aW9uICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgICAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKHRoaXMuZGlmZih0aW1lKSkubGFuZyh0aGlzLmxhbmcoKS5fYWJicikuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZyb21Ob3cgOiBmdW5jdGlvbiAod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbShtb21lbnQoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2FsZW5kYXIgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBXZSB3YW50IHRvIGNvbXBhcmUgdGhlIHN0YXJ0IG9mIHRvZGF5LCB2cyB0aGlzLlxuICAgICAgICAgICAgLy8gR2V0dGluZyBzdGFydC1vZi10b2RheSBkZXBlbmRzIG9uIHdoZXRoZXIgd2UncmUgem9uZSdkIG9yIG5vdC5cbiAgICAgICAgICAgIHZhciBzb2QgPSBtYWtlQXMobW9tZW50KCksIHRoaXMpLnN0YXJ0T2YoJ2RheScpLFxuICAgICAgICAgICAgICAgIGRpZmYgPSB0aGlzLmRpZmYoc29kLCAnZGF5cycsIHRydWUpLFxuICAgICAgICAgICAgICAgIGZvcm1hdCA9IGRpZmYgPCAtNiA/ICdzYW1lRWxzZScgOlxuICAgICAgICAgICAgICAgICAgICBkaWZmIDwgLTEgPyAnbGFzdFdlZWsnIDpcbiAgICAgICAgICAgICAgICAgICAgZGlmZiA8IDAgPyAnbGFzdERheScgOlxuICAgICAgICAgICAgICAgICAgICBkaWZmIDwgMSA/ICdzYW1lRGF5JyA6XG4gICAgICAgICAgICAgICAgICAgIGRpZmYgPCAyID8gJ25leHREYXknIDpcbiAgICAgICAgICAgICAgICAgICAgZGlmZiA8IDcgPyAnbmV4dFdlZWsnIDogJ3NhbWVFbHNlJztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdCh0aGlzLmxhbmcoKS5jYWxlbmRhcihmb3JtYXQsIHRoaXMpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc0xlYXBZZWFyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIodGhpcy55ZWFyKCkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzRFNUIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnpvbmUoKSA8IHRoaXMuY2xvbmUoKS5tb250aCgwKS56b25lKCkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnpvbmUoKSA8IHRoaXMuY2xvbmUoKS5tb250aCg1KS56b25lKCkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRheSA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgdmFyIGRheSA9IHRoaXMuX2lzVVRDID8gdGhpcy5fZC5nZXRVVENEYXkoKSA6IHRoaXMuX2QuZ2V0RGF5KCk7XG4gICAgICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gcGFyc2VXZWVrZGF5KGlucHV0LCB0aGlzLmxhbmcoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKHsgZCA6IGlucHV0IC0gZGF5IH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1vbnRoIDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgdXRjID0gdGhpcy5faXNVVEMgPyAnVVRDJyA6ICcnLFxuICAgICAgICAgICAgICAgIGRheU9mTW9udGg7XG5cbiAgICAgICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQgPSB0aGlzLmxhbmcoKS5tb250aHNQYXJzZShpbnB1dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRheU9mTW9udGggPSB0aGlzLmRhdGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGUoMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZFsnc2V0JyArIHV0YyArICdNb250aCddKGlucHV0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGUoTWF0aC5taW4oZGF5T2ZNb250aCwgdGhpcy5kYXlzSW5Nb250aCgpKSk7XG5cbiAgICAgICAgICAgICAgICBtb21lbnQudXBkYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZFsnZ2V0JyArIHV0YyArICdNb250aCddKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RhcnRPZjogZnVuY3Rpb24gKHVuaXRzKSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIC8vIHRoZSBmb2xsb3dpbmcgc3dpdGNoIGludGVudGlvbmFsbHkgb21pdHMgYnJlYWsga2V5d29yZHNcbiAgICAgICAgICAgIC8vIHRvIHV0aWxpemUgZmFsbGluZyB0aHJvdWdoIHRoZSBjYXNlcy5cbiAgICAgICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIHRoaXMubW9udGgoMCk7XG4gICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSgxKTtcbiAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgIGNhc2UgJ2lzb1dlZWsnOlxuICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgICAgICB0aGlzLmhvdXJzKDApO1xuICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgIHRoaXMubWludXRlcygwKTtcbiAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgICAgIHRoaXMuc2Vjb25kcygwKTtcbiAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgIHRoaXMubWlsbGlzZWNvbmRzKDApO1xuICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gd2Vla3MgYXJlIGEgc3BlY2lhbCBjYXNlXG4gICAgICAgICAgICBpZiAodW5pdHMgPT09ICd3ZWVrJykge1xuICAgICAgICAgICAgICAgIHRoaXMud2Vla2RheSgwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodW5pdHMgPT09ICdpc29XZWVrJykge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNvV2Vla2RheSgxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZW5kT2Y6IGZ1bmN0aW9uICh1bml0cykge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydE9mKHVuaXRzKS5hZGQoKHVuaXRzID09PSAnaXNvV2VlaycgPyAnd2VlaycgOiB1bml0cyksIDEpLnN1YnRyYWN0KCdtcycsIDEpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzQWZ0ZXI6IGZ1bmN0aW9uIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgICAgIHVuaXRzID0gdHlwZW9mIHVuaXRzICE9PSAndW5kZWZpbmVkJyA/IHVuaXRzIDogJ21pbGxpc2Vjb25kJztcbiAgICAgICAgICAgIHJldHVybiArdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpID4gK21vbWVudChpbnB1dCkuc3RhcnRPZih1bml0cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNCZWZvcmU6IGZ1bmN0aW9uIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgICAgIHVuaXRzID0gdHlwZW9mIHVuaXRzICE9PSAndW5kZWZpbmVkJyA/IHVuaXRzIDogJ21pbGxpc2Vjb25kJztcbiAgICAgICAgICAgIHJldHVybiArdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpIDwgK21vbWVudChpbnB1dCkuc3RhcnRPZih1bml0cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNTYW1lOiBmdW5jdGlvbiAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgICAgICB1bml0cyA9IHVuaXRzIHx8ICdtcyc7XG4gICAgICAgICAgICByZXR1cm4gK3RoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKSA9PT0gK21ha2VBcyhpbnB1dCwgdGhpcykuc3RhcnRPZih1bml0cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWluOiBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgICAgIG90aGVyID0gbW9tZW50LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gb3RoZXIgPCB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1heDogZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgICAgICBvdGhlciA9IG1vbWVudC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIG90aGVyID4gdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgfSxcblxuICAgICAgICB6b25lIDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0IHx8IDA7XG4gICAgICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQgPSB0aW1lem9uZU1pbnV0ZXNGcm9tU3RyaW5nKGlucHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGlucHV0KSA8IDE2KSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQgKiA2MDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5wdXQ7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNVVEMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgIT09IGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZE9yU3VidHJhY3REdXJhdGlvbkZyb21Nb21lbnQodGhpcywgbW9tZW50LmR1cmF0aW9uKG9mZnNldCAtIGlucHV0LCAnbScpLCAxLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/IG9mZnNldCA6IHRoaXMuX2QuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHpvbmVBYmJyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gXCJVVENcIiA6IFwiXCI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgem9uZU5hbWUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyBcIkNvb3JkaW5hdGVkIFVuaXZlcnNhbCBUaW1lXCIgOiBcIlwiO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlWm9uZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl90em0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnpvbmUodGhpcy5fdHptKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX2kgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy56b25lKHRoaXMuX2kpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFzQWxpZ25lZEhvdXJPZmZzZXQgOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IG1vbWVudChpbnB1dCkuem9uZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuem9uZSgpIC0gaW5wdXQpICUgNjAgPT09IDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGF5c0luTW9udGggOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGF5T2ZZZWFyIDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgZGF5T2ZZZWFyID0gcm91bmQoKG1vbWVudCh0aGlzKS5zdGFydE9mKCdkYXknKSAtIG1vbWVudCh0aGlzKS5zdGFydE9mKCd5ZWFyJykpIC8gODY0ZTUpICsgMTtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gZGF5T2ZZZWFyIDogdGhpcy5hZGQoXCJkXCIsIChpbnB1dCAtIGRheU9mWWVhcikpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHF1YXJ0ZXIgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKCh0aGlzLm1vbnRoKCkgKyAxLjApIC8gMy4wKTtcbiAgICAgICAgfSxcblxuICAgICAgICB3ZWVrWWVhciA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgdmFyIHllYXIgPSB3ZWVrT2ZZZWFyKHRoaXMsIHRoaXMubGFuZygpLl93ZWVrLmRvdywgdGhpcy5sYW5nKCkuX3dlZWsuZG95KS55ZWFyO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB5ZWFyIDogdGhpcy5hZGQoXCJ5XCIsIChpbnB1dCAtIHllYXIpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc29XZWVrWWVhciA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgdmFyIHllYXIgPSB3ZWVrT2ZZZWFyKHRoaXMsIDEsIDQpLnllYXI7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHllYXIgOiB0aGlzLmFkZChcInlcIiwgKGlucHV0IC0geWVhcikpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHdlZWsgOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciB3ZWVrID0gdGhpcy5sYW5nKCkud2Vlayh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKFwiZFwiLCAoaW5wdXQgLSB3ZWVrKSAqIDcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzb1dlZWsgOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciB3ZWVrID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS53ZWVrO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoXCJkXCIsIChpbnB1dCAtIHdlZWspICogNyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgd2Vla2RheSA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgdmFyIHdlZWtkYXkgPSAodGhpcy5kYXkoKSArIDcgLSB0aGlzLmxhbmcoKS5fd2Vlay5kb3cpICUgNztcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2Vla2RheSA6IHRoaXMuYWRkKFwiZFwiLCBpbnB1dCAtIHdlZWtkYXkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzb1dlZWtkYXkgOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIC8vIGJlaGF2ZXMgdGhlIHNhbWUgYXMgbW9tZW50I2RheSBleGNlcHRcbiAgICAgICAgICAgIC8vIGFzIGEgZ2V0dGVyLCByZXR1cm5zIDcgaW5zdGVhZCBvZiAwICgxLTcgcmFuZ2UgaW5zdGVhZCBvZiAwLTYpXG4gICAgICAgICAgICAvLyBhcyBhIHNldHRlciwgc3VuZGF5IHNob3VsZCBiZWxvbmcgdG8gdGhlIHByZXZpb3VzIHdlZWsuXG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHRoaXMuZGF5KCkgfHwgNyA6IHRoaXMuZGF5KHRoaXMuZGF5KCkgJSA3ID8gaW5wdXQgOiBpbnB1dCAtIDcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCA6IGZ1bmN0aW9uICh1bml0cykge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10oKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQgOiBmdW5jdGlvbiAodW5pdHMsIHZhbHVlKSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpc1t1bml0c10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzW3VuaXRzXSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBJZiBwYXNzZWQgYSBsYW5ndWFnZSBrZXksIGl0IHdpbGwgc2V0IHRoZSBsYW5ndWFnZSBmb3IgdGhpc1xuICAgICAgICAvLyBpbnN0YW5jZS4gIE90aGVyd2lzZSwgaXQgd2lsbCByZXR1cm4gdGhlIGxhbmd1YWdlIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgLy8gdmFyaWFibGVzIGZvciB0aGlzIGluc3RhbmNlLlxuICAgICAgICBsYW5nIDogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xhbmc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhbmcgPSBnZXRMYW5nRGVmaW5pdGlvbihrZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBoZWxwZXIgZm9yIGFkZGluZyBzaG9ydGN1dHNcbiAgICBmdW5jdGlvbiBtYWtlR2V0dGVyQW5kU2V0dGVyKG5hbWUsIGtleSkge1xuICAgICAgICBtb21lbnQuZm5bbmFtZV0gPSBtb21lbnQuZm5bbmFtZSArICdzJ10gPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciB1dGMgPSB0aGlzLl9pc1VUQyA/ICdVVEMnIDogJyc7XG4gICAgICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RbJ3NldCcgKyB1dGMgKyBrZXldKGlucHV0KTtcbiAgICAgICAgICAgICAgICBtb21lbnQudXBkYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZFsnZ2V0JyArIHV0YyArIGtleV0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBsb29wIHRocm91Z2ggYW5kIGFkZCBzaG9ydGN1dHMgKE1vbnRoLCBEYXRlLCBIb3VycywgTWludXRlcywgU2Vjb25kcywgTWlsbGlzZWNvbmRzKVxuICAgIGZvciAoaSA9IDA7IGkgPCBwcm94eUdldHRlcnNBbmRTZXR0ZXJzLmxlbmd0aDsgaSArKykge1xuICAgICAgICBtYWtlR2V0dGVyQW5kU2V0dGVyKHByb3h5R2V0dGVyc0FuZFNldHRlcnNbaV0udG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9zJC8sICcnKSwgcHJveHlHZXR0ZXJzQW5kU2V0dGVyc1tpXSk7XG4gICAgfVxuXG4gICAgLy8gYWRkIHNob3J0Y3V0IGZvciB5ZWFyICh1c2VzIGRpZmZlcmVudCBzeW50YXggdGhhbiB0aGUgZ2V0dGVyL3NldHRlciAneWVhcicgPT0gJ0Z1bGxZZWFyJylcbiAgICBtYWtlR2V0dGVyQW5kU2V0dGVyKCd5ZWFyJywgJ0Z1bGxZZWFyJyk7XG5cbiAgICAvLyBhZGQgcGx1cmFsIG1ldGhvZHNcbiAgICBtb21lbnQuZm4uZGF5cyA9IG1vbWVudC5mbi5kYXk7XG4gICAgbW9tZW50LmZuLm1vbnRocyA9IG1vbWVudC5mbi5tb250aDtcbiAgICBtb21lbnQuZm4ud2Vla3MgPSBtb21lbnQuZm4ud2VlaztcbiAgICBtb21lbnQuZm4uaXNvV2Vla3MgPSBtb21lbnQuZm4uaXNvV2VlaztcblxuICAgIC8vIGFkZCBhbGlhc2VkIGZvcm1hdCBtZXRob2RzXG4gICAgbW9tZW50LmZuLnRvSlNPTiA9IG1vbWVudC5mbi50b0lTT1N0cmluZztcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgRHVyYXRpb24gUHJvdG90eXBlXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgICBleHRlbmQobW9tZW50LmR1cmF0aW9uLmZuID0gRHVyYXRpb24ucHJvdG90eXBlLCB7XG5cbiAgICAgICAgX2J1YmJsZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMsXG4gICAgICAgICAgICAgICAgbW9udGhzID0gdGhpcy5fbW9udGhzLFxuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9kYXRhLFxuICAgICAgICAgICAgICAgIHNlY29uZHMsIG1pbnV0ZXMsIGhvdXJzLCB5ZWFycztcblxuICAgICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGJ1YmJsZXMgdXAgdmFsdWVzLCBzZWUgdGhlIHRlc3RzIGZvclxuICAgICAgICAgICAgLy8gZXhhbXBsZXMgb2Ygd2hhdCB0aGF0IG1lYW5zLlxuICAgICAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHMgJSAxMDAwO1xuXG4gICAgICAgICAgICBzZWNvbmRzID0gYWJzUm91bmQobWlsbGlzZWNvbmRzIC8gMTAwMCk7XG4gICAgICAgICAgICBkYXRhLnNlY29uZHMgPSBzZWNvbmRzICUgNjA7XG5cbiAgICAgICAgICAgIG1pbnV0ZXMgPSBhYnNSb3VuZChzZWNvbmRzIC8gNjApO1xuICAgICAgICAgICAgZGF0YS5taW51dGVzID0gbWludXRlcyAlIDYwO1xuXG4gICAgICAgICAgICBob3VycyA9IGFic1JvdW5kKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgICAgICBkYXRhLmhvdXJzID0gaG91cnMgJSAyNDtcblxuICAgICAgICAgICAgZGF5cyArPSBhYnNSb3VuZChob3VycyAvIDI0KTtcbiAgICAgICAgICAgIGRhdGEuZGF5cyA9IGRheXMgJSAzMDtcblxuICAgICAgICAgICAgbW9udGhzICs9IGFic1JvdW5kKGRheXMgLyAzMCk7XG4gICAgICAgICAgICBkYXRhLm1vbnRocyA9IG1vbnRocyAlIDEyO1xuXG4gICAgICAgICAgICB5ZWFycyA9IGFic1JvdW5kKG1vbnRocyAvIDEyKTtcbiAgICAgICAgICAgIGRhdGEueWVhcnMgPSB5ZWFycztcbiAgICAgICAgfSxcblxuICAgICAgICB3ZWVrcyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBhYnNSb3VuZCh0aGlzLmRheXMoKSAvIDcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHZhbHVlT2YgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgICAgdGhpcy5fZGF5cyAqIDg2NGU1ICtcbiAgICAgICAgICAgICAgKHRoaXMuX21vbnRocyAlIDEyKSAqIDI1OTJlNiArXG4gICAgICAgICAgICAgIHRvSW50KHRoaXMuX21vbnRocyAvIDEyKSAqIDMxNTM2ZTY7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaHVtYW5pemUgOiBmdW5jdGlvbiAod2l0aFN1ZmZpeCkge1xuICAgICAgICAgICAgdmFyIGRpZmZlcmVuY2UgPSArdGhpcyxcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSByZWxhdGl2ZVRpbWUoZGlmZmVyZW5jZSwgIXdpdGhTdWZmaXgsIHRoaXMubGFuZygpKTtcblxuICAgICAgICAgICAgaWYgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB0aGlzLmxhbmcoKS5wYXN0RnV0dXJlKGRpZmZlcmVuY2UsIG91dHB1dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhbmcoKS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkIDogZnVuY3Rpb24gKGlucHV0LCB2YWwpIHtcbiAgICAgICAgICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIGFkZCgxLCAncycpIG9yIGFkZChtb21lbnQpXG4gICAgICAgICAgICB2YXIgZHVyID0gbW9tZW50LmR1cmF0aW9uKGlucHV0LCB2YWwpO1xuXG4gICAgICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgKz0gZHVyLl9taWxsaXNlY29uZHM7XG4gICAgICAgICAgICB0aGlzLl9kYXlzICs9IGR1ci5fZGF5cztcbiAgICAgICAgICAgIHRoaXMuX21vbnRocyArPSBkdXIuX21vbnRocztcblxuICAgICAgICAgICAgdGhpcy5fYnViYmxlKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN1YnRyYWN0IDogZnVuY3Rpb24gKGlucHV0LCB2YWwpIHtcbiAgICAgICAgICAgIHZhciBkdXIgPSBtb21lbnQuZHVyYXRpb24oaW5wdXQsIHZhbCk7XG5cbiAgICAgICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyAtPSBkdXIuX21pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIHRoaXMuX2RheXMgLT0gZHVyLl9kYXlzO1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzIC09IGR1ci5fbW9udGhzO1xuXG4gICAgICAgICAgICB0aGlzLl9idWJibGUoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0IDogZnVuY3Rpb24gKHVuaXRzKSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzLnRvTG93ZXJDYXNlKCkgKyAncyddKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXMgOiBmdW5jdGlvbiAodW5pdHMpIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbJ2FzJyArIHVuaXRzLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdW5pdHMuc2xpY2UoMSkgKyAncyddKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbGFuZyA6IG1vbWVudC5mbi5sYW5nLFxuXG4gICAgICAgIHRvSXNvU3RyaW5nIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gaW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2RvcmRpbGxlL21vbWVudC1pc29kdXJhdGlvbi9ibG9iL21hc3Rlci9tb21lbnQuaXNvZHVyYXRpb24uanNcbiAgICAgICAgICAgIHZhciB5ZWFycyA9IE1hdGguYWJzKHRoaXMueWVhcnMoKSksXG4gICAgICAgICAgICAgICAgbW9udGhzID0gTWF0aC5hYnModGhpcy5tb250aHMoKSksXG4gICAgICAgICAgICAgICAgZGF5cyA9IE1hdGguYWJzKHRoaXMuZGF5cygpKSxcbiAgICAgICAgICAgICAgICBob3VycyA9IE1hdGguYWJzKHRoaXMuaG91cnMoKSksXG4gICAgICAgICAgICAgICAgbWludXRlcyA9IE1hdGguYWJzKHRoaXMubWludXRlcygpKSxcbiAgICAgICAgICAgICAgICBzZWNvbmRzID0gTWF0aC5hYnModGhpcy5zZWNvbmRzKCkgKyB0aGlzLm1pbGxpc2Vjb25kcygpIC8gMTAwMCk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5hc1NlY29uZHMoKSkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIHNhbWUgYXMgQyMncyAoTm9kYSkgYW5kIHB5dGhvbiAoaXNvZGF0ZSkuLi5cbiAgICAgICAgICAgICAgICAvLyBidXQgbm90IG90aGVyIEpTIChnb29nLmRhdGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuICdQMEQnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuYXNTZWNvbmRzKCkgPCAwID8gJy0nIDogJycpICtcbiAgICAgICAgICAgICAgICAnUCcgK1xuICAgICAgICAgICAgICAgICh5ZWFycyA/IHllYXJzICsgJ1knIDogJycpICtcbiAgICAgICAgICAgICAgICAobW9udGhzID8gbW9udGhzICsgJ00nIDogJycpICtcbiAgICAgICAgICAgICAgICAoZGF5cyA/IGRheXMgKyAnRCcgOiAnJykgK1xuICAgICAgICAgICAgICAgICgoaG91cnMgfHwgbWludXRlcyB8fCBzZWNvbmRzKSA/ICdUJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgKGhvdXJzID8gaG91cnMgKyAnSCcgOiAnJykgK1xuICAgICAgICAgICAgICAgIChtaW51dGVzID8gbWludXRlcyArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgKHNlY29uZHMgPyBzZWNvbmRzICsgJ1MnIDogJycpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBtYWtlRHVyYXRpb25HZXR0ZXIobmFtZSkge1xuICAgICAgICBtb21lbnQuZHVyYXRpb24uZm5bbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVtuYW1lXTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlRHVyYXRpb25Bc0dldHRlcihuYW1lLCBmYWN0b3IpIHtcbiAgICAgICAgbW9tZW50LmR1cmF0aW9uLmZuWydhcycgKyBuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiArdGhpcyAvIGZhY3RvcjtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmb3IgKGkgaW4gdW5pdE1pbGxpc2Vjb25kRmFjdG9ycykge1xuICAgICAgICBpZiAodW5pdE1pbGxpc2Vjb25kRmFjdG9ycy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgbWFrZUR1cmF0aW9uQXNHZXR0ZXIoaSwgdW5pdE1pbGxpc2Vjb25kRmFjdG9yc1tpXSk7XG4gICAgICAgICAgICBtYWtlRHVyYXRpb25HZXR0ZXIoaS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1ha2VEdXJhdGlvbkFzR2V0dGVyKCdXZWVrcycsIDYwNDhlNSk7XG4gICAgbW9tZW50LmR1cmF0aW9uLmZuLmFzTW9udGhzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKCt0aGlzIC0gdGhpcy55ZWFycygpICogMzE1MzZlNikgLyAyNTkyZTYgKyB0aGlzLnllYXJzKCkgKiAxMjtcbiAgICB9O1xuXG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIERlZmF1bHQgTGFuZ1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgLy8gU2V0IGRlZmF1bHQgbGFuZ3VhZ2UsIG90aGVyIGxhbmd1YWdlcyB3aWxsIGluaGVyaXQgZnJvbSBFbmdsaXNoLlxuICAgIG1vbWVudC5sYW5nKCdlbicsIHtcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRvSW50KG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qIEVNQkVEX0xBTkdVQUdFUyAqL1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBFeHBvc2luZyBNb21lbnRcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBmdW5jdGlvbiBtYWtlR2xvYmFsKGRlcHJlY2F0ZSkge1xuICAgICAgICB2YXIgd2FybmVkID0gZmFsc2UsIGxvY2FsX21vbWVudCA9IG1vbWVudDtcbiAgICAgICAgLypnbG9iYWwgZW5kZXI6ZmFsc2UgKi9cbiAgICAgICAgaWYgKHR5cGVvZiBlbmRlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBoZXJlLCBgdGhpc2AgbWVhbnMgYHdpbmRvd2AgaW4gdGhlIGJyb3dzZXIsIG9yIGBnbG9iYWxgIG9uIHRoZSBzZXJ2ZXJcbiAgICAgICAgLy8gYWRkIGBtb21lbnRgIGFzIGEgZ2xvYmFsIG9iamVjdCB2aWEgYSBzdHJpbmcgaWRlbnRpZmllcixcbiAgICAgICAgLy8gZm9yIENsb3N1cmUgQ29tcGlsZXIgXCJhZHZhbmNlZFwiIG1vZGVcbiAgICAgICAgaWYgKGRlcHJlY2F0ZSkge1xuICAgICAgICAgICAgZ2xvYmFsLm1vbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXdhcm5lZCAmJiBjb25zb2xlICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgICAgICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJBY2Nlc3NpbmcgTW9tZW50IHRocm91Z2ggdGhlIGdsb2JhbCBzY29wZSBpcyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkZXByZWNhdGVkLCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGFuIHVwY29taW5nIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInJlbGVhc2UuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxfbW9tZW50LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXh0ZW5kKGdsb2JhbC5tb21lbnQsIGxvY2FsX21vbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWxbJ21vbWVudCddID0gbW9tZW50O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29tbW9uSlMgbW9kdWxlIGlzIGRlZmluZWRcbiAgICBpZiAoaGFzTW9kdWxlKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gbW9tZW50O1xuICAgICAgICBtYWtlR2xvYmFsKHRydWUpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFwibW9tZW50XCIsIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcbiAgICAgICAgICAgIGlmIChtb2R1bGUuY29uZmlnICYmIG1vZHVsZS5jb25maWcoKSAmJiBtb2R1bGUuY29uZmlnKCkubm9HbG9iYWwgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB1c2VyIHByb3ZpZGVkIG5vR2xvYmFsLCBoZSBpcyBhd2FyZSBvZiBnbG9iYWxcbiAgICAgICAgICAgICAgICBtYWtlR2xvYmFsKG1vZHVsZS5jb25maWcoKS5ub0dsb2JhbCA9PT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1vbWVudDtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbWFrZUdsb2JhbCgpO1xuICAgIH1cbn0pLmNhbGwodGhpcyk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTIgSWdvciBWYXluYmVyZ1xuXG5WZXJzaW9uOiAzLjUuMiBUaW1lc3RhbXA6IFNhdCBOb3YgIDEgMTQ6NDM6MzYgRURUIDIwMTRcblxuVGhpcyBzb2Z0d2FyZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJBcGFjaGUgTGljZW5zZVwiKSBvciB0aGUgR05VXG5HZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMiAodGhlIFwiR1BMIExpY2Vuc2VcIikuIFlvdSBtYXkgY2hvb3NlIGVpdGhlciBsaWNlbnNlIHRvIGdvdmVybiB5b3VyXG51c2Ugb2YgdGhpcyBzb2Z0d2FyZSBvbmx5IHVwb24gdGhlIGNvbmRpdGlvbiB0aGF0IHlvdSBhY2NlcHQgYWxsIG9mIHRoZSB0ZXJtcyBvZiBlaXRoZXIgdGhlIEFwYWNoZVxuTGljZW5zZSBvciB0aGUgR1BMIExpY2Vuc2UuXG5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgQXBhY2hlIExpY2Vuc2UgYW5kIHRoZSBHUEwgTGljZW5zZSBhdDpcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgIGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy9ncGwtMi4wLmh0bWxcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGVcbkFwYWNoZSBMaWNlbnNlIG9yIHRoZSBHUEwgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUlxuQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBBcGFjaGUgTGljZW5zZSBhbmQgdGhlIEdQTCBMaWNlbnNlIGZvclxudGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlIGFuZCB0aGUgR1BMIExpY2Vuc2UuXG4qL1xuKGZ1bmN0aW9uICgkKSB7XG4gICAgaWYodHlwZW9mICQuZm4uZWFjaDIgPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAkLmV4dGVuZCgkLmZuLCB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgKiA0LTEwIHRpbWVzIGZhc3RlciAuZWFjaCByZXBsYWNlbWVudFxuICAgICAgICAgICAgKiB1c2UgaXQgY2FyZWZ1bGx5LCBhcyBpdCBvdmVycmlkZXMgalF1ZXJ5IGNvbnRleHQgb2YgZWxlbWVudCBvbiBlYWNoIGl0ZXJhdGlvblxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGVhY2gyIDogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaiA9ICQoWzBdKSwgaSA9IC0xLCBsID0gdGhpcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICAgICAgICAgICArK2kgPCBsXG4gICAgICAgICAgICAgICAgICAgICYmIChqLmNvbnRleHQgPSBqWzBdID0gdGhpc1tpXSlcbiAgICAgICAgICAgICAgICAgICAgJiYgYy5jYWxsKGpbMF0sIGksIGopICE9PSBmYWxzZSAvL1widGhpc1wiPURPTSwgaT1pbmRleCwgaj1qUXVlcnkgb2JqZWN0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufSkoalF1ZXJ5KTtcblxuKGZ1bmN0aW9uICgkLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAvKmdsb2JhbCBkb2N1bWVudCwgd2luZG93LCBqUXVlcnksIGNvbnNvbGUgKi9cblxuICAgIGlmICh3aW5kb3cuU2VsZWN0MiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgQWJzdHJhY3RTZWxlY3QyLCBTaW5nbGVTZWxlY3QyLCBNdWx0aVNlbGVjdDIsIG5leHRVaWQsIHNpemVyLFxuICAgICAgICBsYXN0TW91c2VQb3NpdGlvbj17eDowLHk6MH0sICRkb2N1bWVudCwgc2Nyb2xsQmFyRGltZW5zaW9ucyxcblxuICAgIEtFWSA9IHtcbiAgICAgICAgVEFCOiA5LFxuICAgICAgICBFTlRFUjogMTMsXG4gICAgICAgIEVTQzogMjcsXG4gICAgICAgIFNQQUNFOiAzMixcbiAgICAgICAgTEVGVDogMzcsXG4gICAgICAgIFVQOiAzOCxcbiAgICAgICAgUklHSFQ6IDM5LFxuICAgICAgICBET1dOOiA0MCxcbiAgICAgICAgU0hJRlQ6IDE2LFxuICAgICAgICBDVFJMOiAxNyxcbiAgICAgICAgQUxUOiAxOCxcbiAgICAgICAgUEFHRV9VUDogMzMsXG4gICAgICAgIFBBR0VfRE9XTjogMzQsXG4gICAgICAgIEhPTUU6IDM2LFxuICAgICAgICBFTkQ6IDM1LFxuICAgICAgICBCQUNLU1BBQ0U6IDgsXG4gICAgICAgIERFTEVURTogNDYsXG4gICAgICAgIGlzQXJyb3c6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBrID0gay53aGljaCA/IGsud2hpY2ggOiBrO1xuICAgICAgICAgICAgc3dpdGNoIChrKSB7XG4gICAgICAgICAgICBjYXNlIEtFWS5MRUZUOlxuICAgICAgICAgICAgY2FzZSBLRVkuUklHSFQ6XG4gICAgICAgICAgICBjYXNlIEtFWS5VUDpcbiAgICAgICAgICAgIGNhc2UgS0VZLkRPV046XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGlzQ29udHJvbDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBrID0gZS53aGljaDtcbiAgICAgICAgICAgIHN3aXRjaCAoaykge1xuICAgICAgICAgICAgY2FzZSBLRVkuU0hJRlQ6XG4gICAgICAgICAgICBjYXNlIEtFWS5DVFJMOlxuICAgICAgICAgICAgY2FzZSBLRVkuQUxUOlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZS5tZXRhS2V5KSByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBpc0Z1bmN0aW9uS2V5OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgayA9IGsud2hpY2ggPyBrLndoaWNoIDogaztcbiAgICAgICAgICAgIHJldHVybiBrID49IDExMiAmJiBrIDw9IDEyMztcbiAgICAgICAgfVxuICAgIH0sXG4gICAgTUVBU1VSRV9TQ1JPTExCQVJfVEVNUExBVEUgPSBcIjxkaXYgY2xhc3M9J3NlbGVjdDItbWVhc3VyZS1zY3JvbGxiYXInPjwvZGl2PlwiLFxuXG4gICAgRElBQ1JJVElDUyA9IHtcIlxcdTI0QjZcIjpcIkFcIixcIlxcdUZGMjFcIjpcIkFcIixcIlxcdTAwQzBcIjpcIkFcIixcIlxcdTAwQzFcIjpcIkFcIixcIlxcdTAwQzJcIjpcIkFcIixcIlxcdTFFQTZcIjpcIkFcIixcIlxcdTFFQTRcIjpcIkFcIixcIlxcdTFFQUFcIjpcIkFcIixcIlxcdTFFQThcIjpcIkFcIixcIlxcdTAwQzNcIjpcIkFcIixcIlxcdTAxMDBcIjpcIkFcIixcIlxcdTAxMDJcIjpcIkFcIixcIlxcdTFFQjBcIjpcIkFcIixcIlxcdTFFQUVcIjpcIkFcIixcIlxcdTFFQjRcIjpcIkFcIixcIlxcdTFFQjJcIjpcIkFcIixcIlxcdTAyMjZcIjpcIkFcIixcIlxcdTAxRTBcIjpcIkFcIixcIlxcdTAwQzRcIjpcIkFcIixcIlxcdTAxREVcIjpcIkFcIixcIlxcdTFFQTJcIjpcIkFcIixcIlxcdTAwQzVcIjpcIkFcIixcIlxcdTAxRkFcIjpcIkFcIixcIlxcdTAxQ0RcIjpcIkFcIixcIlxcdTAyMDBcIjpcIkFcIixcIlxcdTAyMDJcIjpcIkFcIixcIlxcdTFFQTBcIjpcIkFcIixcIlxcdTFFQUNcIjpcIkFcIixcIlxcdTFFQjZcIjpcIkFcIixcIlxcdTFFMDBcIjpcIkFcIixcIlxcdTAxMDRcIjpcIkFcIixcIlxcdTAyM0FcIjpcIkFcIixcIlxcdTJDNkZcIjpcIkFcIixcIlxcdUE3MzJcIjpcIkFBXCIsXCJcXHUwMEM2XCI6XCJBRVwiLFwiXFx1MDFGQ1wiOlwiQUVcIixcIlxcdTAxRTJcIjpcIkFFXCIsXCJcXHVBNzM0XCI6XCJBT1wiLFwiXFx1QTczNlwiOlwiQVVcIixcIlxcdUE3MzhcIjpcIkFWXCIsXCJcXHVBNzNBXCI6XCJBVlwiLFwiXFx1QTczQ1wiOlwiQVlcIixcIlxcdTI0QjdcIjpcIkJcIixcIlxcdUZGMjJcIjpcIkJcIixcIlxcdTFFMDJcIjpcIkJcIixcIlxcdTFFMDRcIjpcIkJcIixcIlxcdTFFMDZcIjpcIkJcIixcIlxcdTAyNDNcIjpcIkJcIixcIlxcdTAxODJcIjpcIkJcIixcIlxcdTAxODFcIjpcIkJcIixcIlxcdTI0QjhcIjpcIkNcIixcIlxcdUZGMjNcIjpcIkNcIixcIlxcdTAxMDZcIjpcIkNcIixcIlxcdTAxMDhcIjpcIkNcIixcIlxcdTAxMEFcIjpcIkNcIixcIlxcdTAxMENcIjpcIkNcIixcIlxcdTAwQzdcIjpcIkNcIixcIlxcdTFFMDhcIjpcIkNcIixcIlxcdTAxODdcIjpcIkNcIixcIlxcdTAyM0JcIjpcIkNcIixcIlxcdUE3M0VcIjpcIkNcIixcIlxcdTI0QjlcIjpcIkRcIixcIlxcdUZGMjRcIjpcIkRcIixcIlxcdTFFMEFcIjpcIkRcIixcIlxcdTAxMEVcIjpcIkRcIixcIlxcdTFFMENcIjpcIkRcIixcIlxcdTFFMTBcIjpcIkRcIixcIlxcdTFFMTJcIjpcIkRcIixcIlxcdTFFMEVcIjpcIkRcIixcIlxcdTAxMTBcIjpcIkRcIixcIlxcdTAxOEJcIjpcIkRcIixcIlxcdTAxOEFcIjpcIkRcIixcIlxcdTAxODlcIjpcIkRcIixcIlxcdUE3NzlcIjpcIkRcIixcIlxcdTAxRjFcIjpcIkRaXCIsXCJcXHUwMUM0XCI6XCJEWlwiLFwiXFx1MDFGMlwiOlwiRHpcIixcIlxcdTAxQzVcIjpcIkR6XCIsXCJcXHUyNEJBXCI6XCJFXCIsXCJcXHVGRjI1XCI6XCJFXCIsXCJcXHUwMEM4XCI6XCJFXCIsXCJcXHUwMEM5XCI6XCJFXCIsXCJcXHUwMENBXCI6XCJFXCIsXCJcXHUxRUMwXCI6XCJFXCIsXCJcXHUxRUJFXCI6XCJFXCIsXCJcXHUxRUM0XCI6XCJFXCIsXCJcXHUxRUMyXCI6XCJFXCIsXCJcXHUxRUJDXCI6XCJFXCIsXCJcXHUwMTEyXCI6XCJFXCIsXCJcXHUxRTE0XCI6XCJFXCIsXCJcXHUxRTE2XCI6XCJFXCIsXCJcXHUwMTE0XCI6XCJFXCIsXCJcXHUwMTE2XCI6XCJFXCIsXCJcXHUwMENCXCI6XCJFXCIsXCJcXHUxRUJBXCI6XCJFXCIsXCJcXHUwMTFBXCI6XCJFXCIsXCJcXHUwMjA0XCI6XCJFXCIsXCJcXHUwMjA2XCI6XCJFXCIsXCJcXHUxRUI4XCI6XCJFXCIsXCJcXHUxRUM2XCI6XCJFXCIsXCJcXHUwMjI4XCI6XCJFXCIsXCJcXHUxRTFDXCI6XCJFXCIsXCJcXHUwMTE4XCI6XCJFXCIsXCJcXHUxRTE4XCI6XCJFXCIsXCJcXHUxRTFBXCI6XCJFXCIsXCJcXHUwMTkwXCI6XCJFXCIsXCJcXHUwMThFXCI6XCJFXCIsXCJcXHUyNEJCXCI6XCJGXCIsXCJcXHVGRjI2XCI6XCJGXCIsXCJcXHUxRTFFXCI6XCJGXCIsXCJcXHUwMTkxXCI6XCJGXCIsXCJcXHVBNzdCXCI6XCJGXCIsXCJcXHUyNEJDXCI6XCJHXCIsXCJcXHVGRjI3XCI6XCJHXCIsXCJcXHUwMUY0XCI6XCJHXCIsXCJcXHUwMTFDXCI6XCJHXCIsXCJcXHUxRTIwXCI6XCJHXCIsXCJcXHUwMTFFXCI6XCJHXCIsXCJcXHUwMTIwXCI6XCJHXCIsXCJcXHUwMUU2XCI6XCJHXCIsXCJcXHUwMTIyXCI6XCJHXCIsXCJcXHUwMUU0XCI6XCJHXCIsXCJcXHUwMTkzXCI6XCJHXCIsXCJcXHVBN0EwXCI6XCJHXCIsXCJcXHVBNzdEXCI6XCJHXCIsXCJcXHVBNzdFXCI6XCJHXCIsXCJcXHUyNEJEXCI6XCJIXCIsXCJcXHVGRjI4XCI6XCJIXCIsXCJcXHUwMTI0XCI6XCJIXCIsXCJcXHUxRTIyXCI6XCJIXCIsXCJcXHUxRTI2XCI6XCJIXCIsXCJcXHUwMjFFXCI6XCJIXCIsXCJcXHUxRTI0XCI6XCJIXCIsXCJcXHUxRTI4XCI6XCJIXCIsXCJcXHUxRTJBXCI6XCJIXCIsXCJcXHUwMTI2XCI6XCJIXCIsXCJcXHUyQzY3XCI6XCJIXCIsXCJcXHUyQzc1XCI6XCJIXCIsXCJcXHVBNzhEXCI6XCJIXCIsXCJcXHUyNEJFXCI6XCJJXCIsXCJcXHVGRjI5XCI6XCJJXCIsXCJcXHUwMENDXCI6XCJJXCIsXCJcXHUwMENEXCI6XCJJXCIsXCJcXHUwMENFXCI6XCJJXCIsXCJcXHUwMTI4XCI6XCJJXCIsXCJcXHUwMTJBXCI6XCJJXCIsXCJcXHUwMTJDXCI6XCJJXCIsXCJcXHUwMTMwXCI6XCJJXCIsXCJcXHUwMENGXCI6XCJJXCIsXCJcXHUxRTJFXCI6XCJJXCIsXCJcXHUxRUM4XCI6XCJJXCIsXCJcXHUwMUNGXCI6XCJJXCIsXCJcXHUwMjA4XCI6XCJJXCIsXCJcXHUwMjBBXCI6XCJJXCIsXCJcXHUxRUNBXCI6XCJJXCIsXCJcXHUwMTJFXCI6XCJJXCIsXCJcXHUxRTJDXCI6XCJJXCIsXCJcXHUwMTk3XCI6XCJJXCIsXCJcXHUyNEJGXCI6XCJKXCIsXCJcXHVGRjJBXCI6XCJKXCIsXCJcXHUwMTM0XCI6XCJKXCIsXCJcXHUwMjQ4XCI6XCJKXCIsXCJcXHUyNEMwXCI6XCJLXCIsXCJcXHVGRjJCXCI6XCJLXCIsXCJcXHUxRTMwXCI6XCJLXCIsXCJcXHUwMUU4XCI6XCJLXCIsXCJcXHUxRTMyXCI6XCJLXCIsXCJcXHUwMTM2XCI6XCJLXCIsXCJcXHUxRTM0XCI6XCJLXCIsXCJcXHUwMTk4XCI6XCJLXCIsXCJcXHUyQzY5XCI6XCJLXCIsXCJcXHVBNzQwXCI6XCJLXCIsXCJcXHVBNzQyXCI6XCJLXCIsXCJcXHVBNzQ0XCI6XCJLXCIsXCJcXHVBN0EyXCI6XCJLXCIsXCJcXHUyNEMxXCI6XCJMXCIsXCJcXHVGRjJDXCI6XCJMXCIsXCJcXHUwMTNGXCI6XCJMXCIsXCJcXHUwMTM5XCI6XCJMXCIsXCJcXHUwMTNEXCI6XCJMXCIsXCJcXHUxRTM2XCI6XCJMXCIsXCJcXHUxRTM4XCI6XCJMXCIsXCJcXHUwMTNCXCI6XCJMXCIsXCJcXHUxRTNDXCI6XCJMXCIsXCJcXHUxRTNBXCI6XCJMXCIsXCJcXHUwMTQxXCI6XCJMXCIsXCJcXHUwMjNEXCI6XCJMXCIsXCJcXHUyQzYyXCI6XCJMXCIsXCJcXHUyQzYwXCI6XCJMXCIsXCJcXHVBNzQ4XCI6XCJMXCIsXCJcXHVBNzQ2XCI6XCJMXCIsXCJcXHVBNzgwXCI6XCJMXCIsXCJcXHUwMUM3XCI6XCJMSlwiLFwiXFx1MDFDOFwiOlwiTGpcIixcIlxcdTI0QzJcIjpcIk1cIixcIlxcdUZGMkRcIjpcIk1cIixcIlxcdTFFM0VcIjpcIk1cIixcIlxcdTFFNDBcIjpcIk1cIixcIlxcdTFFNDJcIjpcIk1cIixcIlxcdTJDNkVcIjpcIk1cIixcIlxcdTAxOUNcIjpcIk1cIixcIlxcdTI0QzNcIjpcIk5cIixcIlxcdUZGMkVcIjpcIk5cIixcIlxcdTAxRjhcIjpcIk5cIixcIlxcdTAxNDNcIjpcIk5cIixcIlxcdTAwRDFcIjpcIk5cIixcIlxcdTFFNDRcIjpcIk5cIixcIlxcdTAxNDdcIjpcIk5cIixcIlxcdTFFNDZcIjpcIk5cIixcIlxcdTAxNDVcIjpcIk5cIixcIlxcdTFFNEFcIjpcIk5cIixcIlxcdTFFNDhcIjpcIk5cIixcIlxcdTAyMjBcIjpcIk5cIixcIlxcdTAxOURcIjpcIk5cIixcIlxcdUE3OTBcIjpcIk5cIixcIlxcdUE3QTRcIjpcIk5cIixcIlxcdTAxQ0FcIjpcIk5KXCIsXCJcXHUwMUNCXCI6XCJOalwiLFwiXFx1MjRDNFwiOlwiT1wiLFwiXFx1RkYyRlwiOlwiT1wiLFwiXFx1MDBEMlwiOlwiT1wiLFwiXFx1MDBEM1wiOlwiT1wiLFwiXFx1MDBENFwiOlwiT1wiLFwiXFx1MUVEMlwiOlwiT1wiLFwiXFx1MUVEMFwiOlwiT1wiLFwiXFx1MUVENlwiOlwiT1wiLFwiXFx1MUVENFwiOlwiT1wiLFwiXFx1MDBENVwiOlwiT1wiLFwiXFx1MUU0Q1wiOlwiT1wiLFwiXFx1MDIyQ1wiOlwiT1wiLFwiXFx1MUU0RVwiOlwiT1wiLFwiXFx1MDE0Q1wiOlwiT1wiLFwiXFx1MUU1MFwiOlwiT1wiLFwiXFx1MUU1MlwiOlwiT1wiLFwiXFx1MDE0RVwiOlwiT1wiLFwiXFx1MDIyRVwiOlwiT1wiLFwiXFx1MDIzMFwiOlwiT1wiLFwiXFx1MDBENlwiOlwiT1wiLFwiXFx1MDIyQVwiOlwiT1wiLFwiXFx1MUVDRVwiOlwiT1wiLFwiXFx1MDE1MFwiOlwiT1wiLFwiXFx1MDFEMVwiOlwiT1wiLFwiXFx1MDIwQ1wiOlwiT1wiLFwiXFx1MDIwRVwiOlwiT1wiLFwiXFx1MDFBMFwiOlwiT1wiLFwiXFx1MUVEQ1wiOlwiT1wiLFwiXFx1MUVEQVwiOlwiT1wiLFwiXFx1MUVFMFwiOlwiT1wiLFwiXFx1MUVERVwiOlwiT1wiLFwiXFx1MUVFMlwiOlwiT1wiLFwiXFx1MUVDQ1wiOlwiT1wiLFwiXFx1MUVEOFwiOlwiT1wiLFwiXFx1MDFFQVwiOlwiT1wiLFwiXFx1MDFFQ1wiOlwiT1wiLFwiXFx1MDBEOFwiOlwiT1wiLFwiXFx1MDFGRVwiOlwiT1wiLFwiXFx1MDE4NlwiOlwiT1wiLFwiXFx1MDE5RlwiOlwiT1wiLFwiXFx1QTc0QVwiOlwiT1wiLFwiXFx1QTc0Q1wiOlwiT1wiLFwiXFx1MDFBMlwiOlwiT0lcIixcIlxcdUE3NEVcIjpcIk9PXCIsXCJcXHUwMjIyXCI6XCJPVVwiLFwiXFx1MjRDNVwiOlwiUFwiLFwiXFx1RkYzMFwiOlwiUFwiLFwiXFx1MUU1NFwiOlwiUFwiLFwiXFx1MUU1NlwiOlwiUFwiLFwiXFx1MDFBNFwiOlwiUFwiLFwiXFx1MkM2M1wiOlwiUFwiLFwiXFx1QTc1MFwiOlwiUFwiLFwiXFx1QTc1MlwiOlwiUFwiLFwiXFx1QTc1NFwiOlwiUFwiLFwiXFx1MjRDNlwiOlwiUVwiLFwiXFx1RkYzMVwiOlwiUVwiLFwiXFx1QTc1NlwiOlwiUVwiLFwiXFx1QTc1OFwiOlwiUVwiLFwiXFx1MDI0QVwiOlwiUVwiLFwiXFx1MjRDN1wiOlwiUlwiLFwiXFx1RkYzMlwiOlwiUlwiLFwiXFx1MDE1NFwiOlwiUlwiLFwiXFx1MUU1OFwiOlwiUlwiLFwiXFx1MDE1OFwiOlwiUlwiLFwiXFx1MDIxMFwiOlwiUlwiLFwiXFx1MDIxMlwiOlwiUlwiLFwiXFx1MUU1QVwiOlwiUlwiLFwiXFx1MUU1Q1wiOlwiUlwiLFwiXFx1MDE1NlwiOlwiUlwiLFwiXFx1MUU1RVwiOlwiUlwiLFwiXFx1MDI0Q1wiOlwiUlwiLFwiXFx1MkM2NFwiOlwiUlwiLFwiXFx1QTc1QVwiOlwiUlwiLFwiXFx1QTdBNlwiOlwiUlwiLFwiXFx1QTc4MlwiOlwiUlwiLFwiXFx1MjRDOFwiOlwiU1wiLFwiXFx1RkYzM1wiOlwiU1wiLFwiXFx1MUU5RVwiOlwiU1wiLFwiXFx1MDE1QVwiOlwiU1wiLFwiXFx1MUU2NFwiOlwiU1wiLFwiXFx1MDE1Q1wiOlwiU1wiLFwiXFx1MUU2MFwiOlwiU1wiLFwiXFx1MDE2MFwiOlwiU1wiLFwiXFx1MUU2NlwiOlwiU1wiLFwiXFx1MUU2MlwiOlwiU1wiLFwiXFx1MUU2OFwiOlwiU1wiLFwiXFx1MDIxOFwiOlwiU1wiLFwiXFx1MDE1RVwiOlwiU1wiLFwiXFx1MkM3RVwiOlwiU1wiLFwiXFx1QTdBOFwiOlwiU1wiLFwiXFx1QTc4NFwiOlwiU1wiLFwiXFx1MjRDOVwiOlwiVFwiLFwiXFx1RkYzNFwiOlwiVFwiLFwiXFx1MUU2QVwiOlwiVFwiLFwiXFx1MDE2NFwiOlwiVFwiLFwiXFx1MUU2Q1wiOlwiVFwiLFwiXFx1MDIxQVwiOlwiVFwiLFwiXFx1MDE2MlwiOlwiVFwiLFwiXFx1MUU3MFwiOlwiVFwiLFwiXFx1MUU2RVwiOlwiVFwiLFwiXFx1MDE2NlwiOlwiVFwiLFwiXFx1MDFBQ1wiOlwiVFwiLFwiXFx1MDFBRVwiOlwiVFwiLFwiXFx1MDIzRVwiOlwiVFwiLFwiXFx1QTc4NlwiOlwiVFwiLFwiXFx1QTcyOFwiOlwiVFpcIixcIlxcdTI0Q0FcIjpcIlVcIixcIlxcdUZGMzVcIjpcIlVcIixcIlxcdTAwRDlcIjpcIlVcIixcIlxcdTAwREFcIjpcIlVcIixcIlxcdTAwREJcIjpcIlVcIixcIlxcdTAxNjhcIjpcIlVcIixcIlxcdTFFNzhcIjpcIlVcIixcIlxcdTAxNkFcIjpcIlVcIixcIlxcdTFFN0FcIjpcIlVcIixcIlxcdTAxNkNcIjpcIlVcIixcIlxcdTAwRENcIjpcIlVcIixcIlxcdTAxREJcIjpcIlVcIixcIlxcdTAxRDdcIjpcIlVcIixcIlxcdTAxRDVcIjpcIlVcIixcIlxcdTAxRDlcIjpcIlVcIixcIlxcdTFFRTZcIjpcIlVcIixcIlxcdTAxNkVcIjpcIlVcIixcIlxcdTAxNzBcIjpcIlVcIixcIlxcdTAxRDNcIjpcIlVcIixcIlxcdTAyMTRcIjpcIlVcIixcIlxcdTAyMTZcIjpcIlVcIixcIlxcdTAxQUZcIjpcIlVcIixcIlxcdTFFRUFcIjpcIlVcIixcIlxcdTFFRThcIjpcIlVcIixcIlxcdTFFRUVcIjpcIlVcIixcIlxcdTFFRUNcIjpcIlVcIixcIlxcdTFFRjBcIjpcIlVcIixcIlxcdTFFRTRcIjpcIlVcIixcIlxcdTFFNzJcIjpcIlVcIixcIlxcdTAxNzJcIjpcIlVcIixcIlxcdTFFNzZcIjpcIlVcIixcIlxcdTFFNzRcIjpcIlVcIixcIlxcdTAyNDRcIjpcIlVcIixcIlxcdTI0Q0JcIjpcIlZcIixcIlxcdUZGMzZcIjpcIlZcIixcIlxcdTFFN0NcIjpcIlZcIixcIlxcdTFFN0VcIjpcIlZcIixcIlxcdTAxQjJcIjpcIlZcIixcIlxcdUE3NUVcIjpcIlZcIixcIlxcdTAyNDVcIjpcIlZcIixcIlxcdUE3NjBcIjpcIlZZXCIsXCJcXHUyNENDXCI6XCJXXCIsXCJcXHVGRjM3XCI6XCJXXCIsXCJcXHUxRTgwXCI6XCJXXCIsXCJcXHUxRTgyXCI6XCJXXCIsXCJcXHUwMTc0XCI6XCJXXCIsXCJcXHUxRTg2XCI6XCJXXCIsXCJcXHUxRTg0XCI6XCJXXCIsXCJcXHUxRTg4XCI6XCJXXCIsXCJcXHUyQzcyXCI6XCJXXCIsXCJcXHUyNENEXCI6XCJYXCIsXCJcXHVGRjM4XCI6XCJYXCIsXCJcXHUxRThBXCI6XCJYXCIsXCJcXHUxRThDXCI6XCJYXCIsXCJcXHUyNENFXCI6XCJZXCIsXCJcXHVGRjM5XCI6XCJZXCIsXCJcXHUxRUYyXCI6XCJZXCIsXCJcXHUwMEREXCI6XCJZXCIsXCJcXHUwMTc2XCI6XCJZXCIsXCJcXHUxRUY4XCI6XCJZXCIsXCJcXHUwMjMyXCI6XCJZXCIsXCJcXHUxRThFXCI6XCJZXCIsXCJcXHUwMTc4XCI6XCJZXCIsXCJcXHUxRUY2XCI6XCJZXCIsXCJcXHUxRUY0XCI6XCJZXCIsXCJcXHUwMUIzXCI6XCJZXCIsXCJcXHUwMjRFXCI6XCJZXCIsXCJcXHUxRUZFXCI6XCJZXCIsXCJcXHUyNENGXCI6XCJaXCIsXCJcXHVGRjNBXCI6XCJaXCIsXCJcXHUwMTc5XCI6XCJaXCIsXCJcXHUxRTkwXCI6XCJaXCIsXCJcXHUwMTdCXCI6XCJaXCIsXCJcXHUwMTdEXCI6XCJaXCIsXCJcXHUxRTkyXCI6XCJaXCIsXCJcXHUxRTk0XCI6XCJaXCIsXCJcXHUwMUI1XCI6XCJaXCIsXCJcXHUwMjI0XCI6XCJaXCIsXCJcXHUyQzdGXCI6XCJaXCIsXCJcXHUyQzZCXCI6XCJaXCIsXCJcXHVBNzYyXCI6XCJaXCIsXCJcXHUyNEQwXCI6XCJhXCIsXCJcXHVGRjQxXCI6XCJhXCIsXCJcXHUxRTlBXCI6XCJhXCIsXCJcXHUwMEUwXCI6XCJhXCIsXCJcXHUwMEUxXCI6XCJhXCIsXCJcXHUwMEUyXCI6XCJhXCIsXCJcXHUxRUE3XCI6XCJhXCIsXCJcXHUxRUE1XCI6XCJhXCIsXCJcXHUxRUFCXCI6XCJhXCIsXCJcXHUxRUE5XCI6XCJhXCIsXCJcXHUwMEUzXCI6XCJhXCIsXCJcXHUwMTAxXCI6XCJhXCIsXCJcXHUwMTAzXCI6XCJhXCIsXCJcXHUxRUIxXCI6XCJhXCIsXCJcXHUxRUFGXCI6XCJhXCIsXCJcXHUxRUI1XCI6XCJhXCIsXCJcXHUxRUIzXCI6XCJhXCIsXCJcXHUwMjI3XCI6XCJhXCIsXCJcXHUwMUUxXCI6XCJhXCIsXCJcXHUwMEU0XCI6XCJhXCIsXCJcXHUwMURGXCI6XCJhXCIsXCJcXHUxRUEzXCI6XCJhXCIsXCJcXHUwMEU1XCI6XCJhXCIsXCJcXHUwMUZCXCI6XCJhXCIsXCJcXHUwMUNFXCI6XCJhXCIsXCJcXHUwMjAxXCI6XCJhXCIsXCJcXHUwMjAzXCI6XCJhXCIsXCJcXHUxRUExXCI6XCJhXCIsXCJcXHUxRUFEXCI6XCJhXCIsXCJcXHUxRUI3XCI6XCJhXCIsXCJcXHUxRTAxXCI6XCJhXCIsXCJcXHUwMTA1XCI6XCJhXCIsXCJcXHUyQzY1XCI6XCJhXCIsXCJcXHUwMjUwXCI6XCJhXCIsXCJcXHVBNzMzXCI6XCJhYVwiLFwiXFx1MDBFNlwiOlwiYWVcIixcIlxcdTAxRkRcIjpcImFlXCIsXCJcXHUwMUUzXCI6XCJhZVwiLFwiXFx1QTczNVwiOlwiYW9cIixcIlxcdUE3MzdcIjpcImF1XCIsXCJcXHVBNzM5XCI6XCJhdlwiLFwiXFx1QTczQlwiOlwiYXZcIixcIlxcdUE3M0RcIjpcImF5XCIsXCJcXHUyNEQxXCI6XCJiXCIsXCJcXHVGRjQyXCI6XCJiXCIsXCJcXHUxRTAzXCI6XCJiXCIsXCJcXHUxRTA1XCI6XCJiXCIsXCJcXHUxRTA3XCI6XCJiXCIsXCJcXHUwMTgwXCI6XCJiXCIsXCJcXHUwMTgzXCI6XCJiXCIsXCJcXHUwMjUzXCI6XCJiXCIsXCJcXHUyNEQyXCI6XCJjXCIsXCJcXHVGRjQzXCI6XCJjXCIsXCJcXHUwMTA3XCI6XCJjXCIsXCJcXHUwMTA5XCI6XCJjXCIsXCJcXHUwMTBCXCI6XCJjXCIsXCJcXHUwMTBEXCI6XCJjXCIsXCJcXHUwMEU3XCI6XCJjXCIsXCJcXHUxRTA5XCI6XCJjXCIsXCJcXHUwMTg4XCI6XCJjXCIsXCJcXHUwMjNDXCI6XCJjXCIsXCJcXHVBNzNGXCI6XCJjXCIsXCJcXHUyMTg0XCI6XCJjXCIsXCJcXHUyNEQzXCI6XCJkXCIsXCJcXHVGRjQ0XCI6XCJkXCIsXCJcXHUxRTBCXCI6XCJkXCIsXCJcXHUwMTBGXCI6XCJkXCIsXCJcXHUxRTBEXCI6XCJkXCIsXCJcXHUxRTExXCI6XCJkXCIsXCJcXHUxRTEzXCI6XCJkXCIsXCJcXHUxRTBGXCI6XCJkXCIsXCJcXHUwMTExXCI6XCJkXCIsXCJcXHUwMThDXCI6XCJkXCIsXCJcXHUwMjU2XCI6XCJkXCIsXCJcXHUwMjU3XCI6XCJkXCIsXCJcXHVBNzdBXCI6XCJkXCIsXCJcXHUwMUYzXCI6XCJkelwiLFwiXFx1MDFDNlwiOlwiZHpcIixcIlxcdTI0RDRcIjpcImVcIixcIlxcdUZGNDVcIjpcImVcIixcIlxcdTAwRThcIjpcImVcIixcIlxcdTAwRTlcIjpcImVcIixcIlxcdTAwRUFcIjpcImVcIixcIlxcdTFFQzFcIjpcImVcIixcIlxcdTFFQkZcIjpcImVcIixcIlxcdTFFQzVcIjpcImVcIixcIlxcdTFFQzNcIjpcImVcIixcIlxcdTFFQkRcIjpcImVcIixcIlxcdTAxMTNcIjpcImVcIixcIlxcdTFFMTVcIjpcImVcIixcIlxcdTFFMTdcIjpcImVcIixcIlxcdTAxMTVcIjpcImVcIixcIlxcdTAxMTdcIjpcImVcIixcIlxcdTAwRUJcIjpcImVcIixcIlxcdTFFQkJcIjpcImVcIixcIlxcdTAxMUJcIjpcImVcIixcIlxcdTAyMDVcIjpcImVcIixcIlxcdTAyMDdcIjpcImVcIixcIlxcdTFFQjlcIjpcImVcIixcIlxcdTFFQzdcIjpcImVcIixcIlxcdTAyMjlcIjpcImVcIixcIlxcdTFFMURcIjpcImVcIixcIlxcdTAxMTlcIjpcImVcIixcIlxcdTFFMTlcIjpcImVcIixcIlxcdTFFMUJcIjpcImVcIixcIlxcdTAyNDdcIjpcImVcIixcIlxcdTAyNUJcIjpcImVcIixcIlxcdTAxRERcIjpcImVcIixcIlxcdTI0RDVcIjpcImZcIixcIlxcdUZGNDZcIjpcImZcIixcIlxcdTFFMUZcIjpcImZcIixcIlxcdTAxOTJcIjpcImZcIixcIlxcdUE3N0NcIjpcImZcIixcIlxcdTI0RDZcIjpcImdcIixcIlxcdUZGNDdcIjpcImdcIixcIlxcdTAxRjVcIjpcImdcIixcIlxcdTAxMURcIjpcImdcIixcIlxcdTFFMjFcIjpcImdcIixcIlxcdTAxMUZcIjpcImdcIixcIlxcdTAxMjFcIjpcImdcIixcIlxcdTAxRTdcIjpcImdcIixcIlxcdTAxMjNcIjpcImdcIixcIlxcdTAxRTVcIjpcImdcIixcIlxcdTAyNjBcIjpcImdcIixcIlxcdUE3QTFcIjpcImdcIixcIlxcdTFENzlcIjpcImdcIixcIlxcdUE3N0ZcIjpcImdcIixcIlxcdTI0RDdcIjpcImhcIixcIlxcdUZGNDhcIjpcImhcIixcIlxcdTAxMjVcIjpcImhcIixcIlxcdTFFMjNcIjpcImhcIixcIlxcdTFFMjdcIjpcImhcIixcIlxcdTAyMUZcIjpcImhcIixcIlxcdTFFMjVcIjpcImhcIixcIlxcdTFFMjlcIjpcImhcIixcIlxcdTFFMkJcIjpcImhcIixcIlxcdTFFOTZcIjpcImhcIixcIlxcdTAxMjdcIjpcImhcIixcIlxcdTJDNjhcIjpcImhcIixcIlxcdTJDNzZcIjpcImhcIixcIlxcdTAyNjVcIjpcImhcIixcIlxcdTAxOTVcIjpcImh2XCIsXCJcXHUyNEQ4XCI6XCJpXCIsXCJcXHVGRjQ5XCI6XCJpXCIsXCJcXHUwMEVDXCI6XCJpXCIsXCJcXHUwMEVEXCI6XCJpXCIsXCJcXHUwMEVFXCI6XCJpXCIsXCJcXHUwMTI5XCI6XCJpXCIsXCJcXHUwMTJCXCI6XCJpXCIsXCJcXHUwMTJEXCI6XCJpXCIsXCJcXHUwMEVGXCI6XCJpXCIsXCJcXHUxRTJGXCI6XCJpXCIsXCJcXHUxRUM5XCI6XCJpXCIsXCJcXHUwMUQwXCI6XCJpXCIsXCJcXHUwMjA5XCI6XCJpXCIsXCJcXHUwMjBCXCI6XCJpXCIsXCJcXHUxRUNCXCI6XCJpXCIsXCJcXHUwMTJGXCI6XCJpXCIsXCJcXHUxRTJEXCI6XCJpXCIsXCJcXHUwMjY4XCI6XCJpXCIsXCJcXHUwMTMxXCI6XCJpXCIsXCJcXHUyNEQ5XCI6XCJqXCIsXCJcXHVGRjRBXCI6XCJqXCIsXCJcXHUwMTM1XCI6XCJqXCIsXCJcXHUwMUYwXCI6XCJqXCIsXCJcXHUwMjQ5XCI6XCJqXCIsXCJcXHUyNERBXCI6XCJrXCIsXCJcXHVGRjRCXCI6XCJrXCIsXCJcXHUxRTMxXCI6XCJrXCIsXCJcXHUwMUU5XCI6XCJrXCIsXCJcXHUxRTMzXCI6XCJrXCIsXCJcXHUwMTM3XCI6XCJrXCIsXCJcXHUxRTM1XCI6XCJrXCIsXCJcXHUwMTk5XCI6XCJrXCIsXCJcXHUyQzZBXCI6XCJrXCIsXCJcXHVBNzQxXCI6XCJrXCIsXCJcXHVBNzQzXCI6XCJrXCIsXCJcXHVBNzQ1XCI6XCJrXCIsXCJcXHVBN0EzXCI6XCJrXCIsXCJcXHUyNERCXCI6XCJsXCIsXCJcXHVGRjRDXCI6XCJsXCIsXCJcXHUwMTQwXCI6XCJsXCIsXCJcXHUwMTNBXCI6XCJsXCIsXCJcXHUwMTNFXCI6XCJsXCIsXCJcXHUxRTM3XCI6XCJsXCIsXCJcXHUxRTM5XCI6XCJsXCIsXCJcXHUwMTNDXCI6XCJsXCIsXCJcXHUxRTNEXCI6XCJsXCIsXCJcXHUxRTNCXCI6XCJsXCIsXCJcXHUwMTdGXCI6XCJsXCIsXCJcXHUwMTQyXCI6XCJsXCIsXCJcXHUwMTlBXCI6XCJsXCIsXCJcXHUwMjZCXCI6XCJsXCIsXCJcXHUyQzYxXCI6XCJsXCIsXCJcXHVBNzQ5XCI6XCJsXCIsXCJcXHVBNzgxXCI6XCJsXCIsXCJcXHVBNzQ3XCI6XCJsXCIsXCJcXHUwMUM5XCI6XCJsalwiLFwiXFx1MjREQ1wiOlwibVwiLFwiXFx1RkY0RFwiOlwibVwiLFwiXFx1MUUzRlwiOlwibVwiLFwiXFx1MUU0MVwiOlwibVwiLFwiXFx1MUU0M1wiOlwibVwiLFwiXFx1MDI3MVwiOlwibVwiLFwiXFx1MDI2RlwiOlwibVwiLFwiXFx1MjRERFwiOlwiblwiLFwiXFx1RkY0RVwiOlwiblwiLFwiXFx1MDFGOVwiOlwiblwiLFwiXFx1MDE0NFwiOlwiblwiLFwiXFx1MDBGMVwiOlwiblwiLFwiXFx1MUU0NVwiOlwiblwiLFwiXFx1MDE0OFwiOlwiblwiLFwiXFx1MUU0N1wiOlwiblwiLFwiXFx1MDE0NlwiOlwiblwiLFwiXFx1MUU0QlwiOlwiblwiLFwiXFx1MUU0OVwiOlwiblwiLFwiXFx1MDE5RVwiOlwiblwiLFwiXFx1MDI3MlwiOlwiblwiLFwiXFx1MDE0OVwiOlwiblwiLFwiXFx1QTc5MVwiOlwiblwiLFwiXFx1QTdBNVwiOlwiblwiLFwiXFx1MDFDQ1wiOlwibmpcIixcIlxcdTI0REVcIjpcIm9cIixcIlxcdUZGNEZcIjpcIm9cIixcIlxcdTAwRjJcIjpcIm9cIixcIlxcdTAwRjNcIjpcIm9cIixcIlxcdTAwRjRcIjpcIm9cIixcIlxcdTFFRDNcIjpcIm9cIixcIlxcdTFFRDFcIjpcIm9cIixcIlxcdTFFRDdcIjpcIm9cIixcIlxcdTFFRDVcIjpcIm9cIixcIlxcdTAwRjVcIjpcIm9cIixcIlxcdTFFNERcIjpcIm9cIixcIlxcdTAyMkRcIjpcIm9cIixcIlxcdTFFNEZcIjpcIm9cIixcIlxcdTAxNERcIjpcIm9cIixcIlxcdTFFNTFcIjpcIm9cIixcIlxcdTFFNTNcIjpcIm9cIixcIlxcdTAxNEZcIjpcIm9cIixcIlxcdTAyMkZcIjpcIm9cIixcIlxcdTAyMzFcIjpcIm9cIixcIlxcdTAwRjZcIjpcIm9cIixcIlxcdTAyMkJcIjpcIm9cIixcIlxcdTFFQ0ZcIjpcIm9cIixcIlxcdTAxNTFcIjpcIm9cIixcIlxcdTAxRDJcIjpcIm9cIixcIlxcdTAyMERcIjpcIm9cIixcIlxcdTAyMEZcIjpcIm9cIixcIlxcdTAxQTFcIjpcIm9cIixcIlxcdTFFRERcIjpcIm9cIixcIlxcdTFFREJcIjpcIm9cIixcIlxcdTFFRTFcIjpcIm9cIixcIlxcdTFFREZcIjpcIm9cIixcIlxcdTFFRTNcIjpcIm9cIixcIlxcdTFFQ0RcIjpcIm9cIixcIlxcdTFFRDlcIjpcIm9cIixcIlxcdTAxRUJcIjpcIm9cIixcIlxcdTAxRURcIjpcIm9cIixcIlxcdTAwRjhcIjpcIm9cIixcIlxcdTAxRkZcIjpcIm9cIixcIlxcdTAyNTRcIjpcIm9cIixcIlxcdUE3NEJcIjpcIm9cIixcIlxcdUE3NERcIjpcIm9cIixcIlxcdTAyNzVcIjpcIm9cIixcIlxcdTAxQTNcIjpcIm9pXCIsXCJcXHUwMjIzXCI6XCJvdVwiLFwiXFx1QTc0RlwiOlwib29cIixcIlxcdTI0REZcIjpcInBcIixcIlxcdUZGNTBcIjpcInBcIixcIlxcdTFFNTVcIjpcInBcIixcIlxcdTFFNTdcIjpcInBcIixcIlxcdTAxQTVcIjpcInBcIixcIlxcdTFEN0RcIjpcInBcIixcIlxcdUE3NTFcIjpcInBcIixcIlxcdUE3NTNcIjpcInBcIixcIlxcdUE3NTVcIjpcInBcIixcIlxcdTI0RTBcIjpcInFcIixcIlxcdUZGNTFcIjpcInFcIixcIlxcdTAyNEJcIjpcInFcIixcIlxcdUE3NTdcIjpcInFcIixcIlxcdUE3NTlcIjpcInFcIixcIlxcdTI0RTFcIjpcInJcIixcIlxcdUZGNTJcIjpcInJcIixcIlxcdTAxNTVcIjpcInJcIixcIlxcdTFFNTlcIjpcInJcIixcIlxcdTAxNTlcIjpcInJcIixcIlxcdTAyMTFcIjpcInJcIixcIlxcdTAyMTNcIjpcInJcIixcIlxcdTFFNUJcIjpcInJcIixcIlxcdTFFNURcIjpcInJcIixcIlxcdTAxNTdcIjpcInJcIixcIlxcdTFFNUZcIjpcInJcIixcIlxcdTAyNERcIjpcInJcIixcIlxcdTAyN0RcIjpcInJcIixcIlxcdUE3NUJcIjpcInJcIixcIlxcdUE3QTdcIjpcInJcIixcIlxcdUE3ODNcIjpcInJcIixcIlxcdTI0RTJcIjpcInNcIixcIlxcdUZGNTNcIjpcInNcIixcIlxcdTAwREZcIjpcInNcIixcIlxcdTAxNUJcIjpcInNcIixcIlxcdTFFNjVcIjpcInNcIixcIlxcdTAxNURcIjpcInNcIixcIlxcdTFFNjFcIjpcInNcIixcIlxcdTAxNjFcIjpcInNcIixcIlxcdTFFNjdcIjpcInNcIixcIlxcdTFFNjNcIjpcInNcIixcIlxcdTFFNjlcIjpcInNcIixcIlxcdTAyMTlcIjpcInNcIixcIlxcdTAxNUZcIjpcInNcIixcIlxcdTAyM0ZcIjpcInNcIixcIlxcdUE3QTlcIjpcInNcIixcIlxcdUE3ODVcIjpcInNcIixcIlxcdTFFOUJcIjpcInNcIixcIlxcdTI0RTNcIjpcInRcIixcIlxcdUZGNTRcIjpcInRcIixcIlxcdTFFNkJcIjpcInRcIixcIlxcdTFFOTdcIjpcInRcIixcIlxcdTAxNjVcIjpcInRcIixcIlxcdTFFNkRcIjpcInRcIixcIlxcdTAyMUJcIjpcInRcIixcIlxcdTAxNjNcIjpcInRcIixcIlxcdTFFNzFcIjpcInRcIixcIlxcdTFFNkZcIjpcInRcIixcIlxcdTAxNjdcIjpcInRcIixcIlxcdTAxQURcIjpcInRcIixcIlxcdTAyODhcIjpcInRcIixcIlxcdTJDNjZcIjpcInRcIixcIlxcdUE3ODdcIjpcInRcIixcIlxcdUE3MjlcIjpcInR6XCIsXCJcXHUyNEU0XCI6XCJ1XCIsXCJcXHVGRjU1XCI6XCJ1XCIsXCJcXHUwMEY5XCI6XCJ1XCIsXCJcXHUwMEZBXCI6XCJ1XCIsXCJcXHUwMEZCXCI6XCJ1XCIsXCJcXHUwMTY5XCI6XCJ1XCIsXCJcXHUxRTc5XCI6XCJ1XCIsXCJcXHUwMTZCXCI6XCJ1XCIsXCJcXHUxRTdCXCI6XCJ1XCIsXCJcXHUwMTZEXCI6XCJ1XCIsXCJcXHUwMEZDXCI6XCJ1XCIsXCJcXHUwMURDXCI6XCJ1XCIsXCJcXHUwMUQ4XCI6XCJ1XCIsXCJcXHUwMUQ2XCI6XCJ1XCIsXCJcXHUwMURBXCI6XCJ1XCIsXCJcXHUxRUU3XCI6XCJ1XCIsXCJcXHUwMTZGXCI6XCJ1XCIsXCJcXHUwMTcxXCI6XCJ1XCIsXCJcXHUwMUQ0XCI6XCJ1XCIsXCJcXHUwMjE1XCI6XCJ1XCIsXCJcXHUwMjE3XCI6XCJ1XCIsXCJcXHUwMUIwXCI6XCJ1XCIsXCJcXHUxRUVCXCI6XCJ1XCIsXCJcXHUxRUU5XCI6XCJ1XCIsXCJcXHUxRUVGXCI6XCJ1XCIsXCJcXHUxRUVEXCI6XCJ1XCIsXCJcXHUxRUYxXCI6XCJ1XCIsXCJcXHUxRUU1XCI6XCJ1XCIsXCJcXHUxRTczXCI6XCJ1XCIsXCJcXHUwMTczXCI6XCJ1XCIsXCJcXHUxRTc3XCI6XCJ1XCIsXCJcXHUxRTc1XCI6XCJ1XCIsXCJcXHUwMjg5XCI6XCJ1XCIsXCJcXHUyNEU1XCI6XCJ2XCIsXCJcXHVGRjU2XCI6XCJ2XCIsXCJcXHUxRTdEXCI6XCJ2XCIsXCJcXHUxRTdGXCI6XCJ2XCIsXCJcXHUwMjhCXCI6XCJ2XCIsXCJcXHVBNzVGXCI6XCJ2XCIsXCJcXHUwMjhDXCI6XCJ2XCIsXCJcXHVBNzYxXCI6XCJ2eVwiLFwiXFx1MjRFNlwiOlwid1wiLFwiXFx1RkY1N1wiOlwid1wiLFwiXFx1MUU4MVwiOlwid1wiLFwiXFx1MUU4M1wiOlwid1wiLFwiXFx1MDE3NVwiOlwid1wiLFwiXFx1MUU4N1wiOlwid1wiLFwiXFx1MUU4NVwiOlwid1wiLFwiXFx1MUU5OFwiOlwid1wiLFwiXFx1MUU4OVwiOlwid1wiLFwiXFx1MkM3M1wiOlwid1wiLFwiXFx1MjRFN1wiOlwieFwiLFwiXFx1RkY1OFwiOlwieFwiLFwiXFx1MUU4QlwiOlwieFwiLFwiXFx1MUU4RFwiOlwieFwiLFwiXFx1MjRFOFwiOlwieVwiLFwiXFx1RkY1OVwiOlwieVwiLFwiXFx1MUVGM1wiOlwieVwiLFwiXFx1MDBGRFwiOlwieVwiLFwiXFx1MDE3N1wiOlwieVwiLFwiXFx1MUVGOVwiOlwieVwiLFwiXFx1MDIzM1wiOlwieVwiLFwiXFx1MUU4RlwiOlwieVwiLFwiXFx1MDBGRlwiOlwieVwiLFwiXFx1MUVGN1wiOlwieVwiLFwiXFx1MUU5OVwiOlwieVwiLFwiXFx1MUVGNVwiOlwieVwiLFwiXFx1MDFCNFwiOlwieVwiLFwiXFx1MDI0RlwiOlwieVwiLFwiXFx1MUVGRlwiOlwieVwiLFwiXFx1MjRFOVwiOlwielwiLFwiXFx1RkY1QVwiOlwielwiLFwiXFx1MDE3QVwiOlwielwiLFwiXFx1MUU5MVwiOlwielwiLFwiXFx1MDE3Q1wiOlwielwiLFwiXFx1MDE3RVwiOlwielwiLFwiXFx1MUU5M1wiOlwielwiLFwiXFx1MUU5NVwiOlwielwiLFwiXFx1MDFCNlwiOlwielwiLFwiXFx1MDIyNVwiOlwielwiLFwiXFx1MDI0MFwiOlwielwiLFwiXFx1MkM2Q1wiOlwielwiLFwiXFx1QTc2M1wiOlwielwiLFwiXFx1MDM4NlwiOlwiXFx1MDM5MVwiLFwiXFx1MDM4OFwiOlwiXFx1MDM5NVwiLFwiXFx1MDM4OVwiOlwiXFx1MDM5N1wiLFwiXFx1MDM4QVwiOlwiXFx1MDM5OVwiLFwiXFx1MDNBQVwiOlwiXFx1MDM5OVwiLFwiXFx1MDM4Q1wiOlwiXFx1MDM5RlwiLFwiXFx1MDM4RVwiOlwiXFx1MDNBNVwiLFwiXFx1MDNBQlwiOlwiXFx1MDNBNVwiLFwiXFx1MDM4RlwiOlwiXFx1MDNBOVwiLFwiXFx1MDNBQ1wiOlwiXFx1MDNCMVwiLFwiXFx1MDNBRFwiOlwiXFx1MDNCNVwiLFwiXFx1MDNBRVwiOlwiXFx1MDNCN1wiLFwiXFx1MDNBRlwiOlwiXFx1MDNCOVwiLFwiXFx1MDNDQVwiOlwiXFx1MDNCOVwiLFwiXFx1MDM5MFwiOlwiXFx1MDNCOVwiLFwiXFx1MDNDQ1wiOlwiXFx1MDNCRlwiLFwiXFx1MDNDRFwiOlwiXFx1MDNDNVwiLFwiXFx1MDNDQlwiOlwiXFx1MDNDNVwiLFwiXFx1MDNCMFwiOlwiXFx1MDNDNVwiLFwiXFx1MDNDOVwiOlwiXFx1MDNDOVwiLFwiXFx1MDNDMlwiOlwiXFx1MDNDM1wifTtcblxuICAgICRkb2N1bWVudCA9ICQoZG9jdW1lbnQpO1xuXG4gICAgbmV4dFVpZD0oZnVuY3Rpb24oKSB7IHZhciBjb3VudGVyPTE7IHJldHVybiBmdW5jdGlvbigpIHsgcmV0dXJuIGNvdW50ZXIrKzsgfTsgfSgpKTtcblxuXG4gICAgZnVuY3Rpb24gcmVpbnNlcnRFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gJChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJykpO1xuXG4gICAgICAgIGVsZW1lbnQuYmVmb3JlKHBsYWNlaG9sZGVyKTtcbiAgICAgICAgcGxhY2Vob2xkZXIuYmVmb3JlKGVsZW1lbnQpO1xuICAgICAgICBwbGFjZWhvbGRlci5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdHJpcERpYWNyaXRpY3Moc3RyKSB7XG4gICAgICAgIC8vIFVzZWQgJ3VuaSByYW5nZSArIG5hbWVkIGZ1bmN0aW9uJyBmcm9tIGh0dHA6Ly9qc3BlcmYuY29tL2RpYWNyaXRpY3MvMThcbiAgICAgICAgZnVuY3Rpb24gbWF0Y2goYSkge1xuICAgICAgICAgICAgcmV0dXJuIERJQUNSSVRJQ1NbYV0gfHwgYTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvW15cXHUwMDAwLVxcdTAwN0VdL2csIG1hdGNoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbmRleE9mKHZhbHVlLCBhcnJheSkge1xuICAgICAgICB2YXIgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIGZvciAoOyBpIDwgbDsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICBpZiAoZXF1YWwodmFsdWUsIGFycmF5W2ldKSkgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lYXN1cmVTY3JvbGxiYXIgKCkge1xuICAgICAgICB2YXIgJHRlbXBsYXRlID0gJCggTUVBU1VSRV9TQ1JPTExCQVJfVEVNUExBVEUgKTtcbiAgICAgICAgJHRlbXBsYXRlLmFwcGVuZFRvKGRvY3VtZW50LmJvZHkpO1xuXG4gICAgICAgIHZhciBkaW0gPSB7XG4gICAgICAgICAgICB3aWR0aDogJHRlbXBsYXRlLndpZHRoKCkgLSAkdGVtcGxhdGVbMF0uY2xpZW50V2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6ICR0ZW1wbGF0ZS5oZWlnaHQoKSAtICR0ZW1wbGF0ZVswXS5jbGllbnRIZWlnaHRcbiAgICAgICAgfTtcbiAgICAgICAgJHRlbXBsYXRlLnJlbW92ZSgpO1xuXG4gICAgICAgIHJldHVybiBkaW07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgZXF1YWxpdHkgb2YgYSBhbmQgYlxuICAgICAqIEBwYXJhbSBhXG4gICAgICogQHBhcmFtIGJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbChhLCBiKSB7XG4gICAgICAgIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGEgPT09IHVuZGVmaW5lZCB8fCBiID09PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGEgPT09IG51bGwgfHwgYiA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBDaGVjayB3aGV0aGVyICdhJyBvciAnYicgaXMgYSBzdHJpbmcgKHByaW1pdGl2ZSBvciBvYmplY3QpLlxuICAgICAgICAvLyBUaGUgY29uY2F0ZW5hdGlvbiBvZiBhbiBlbXB0eSBzdHJpbmcgKCsnJykgY29udmVydHMgaXRzIGFyZ3VtZW50IHRvIGEgc3RyaW5nJ3MgcHJpbWl0aXZlLlxuICAgICAgICBpZiAoYS5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSByZXR1cm4gYSsnJyA9PT0gYisnJzsgLy8gYSsnJyAtIGluIGNhc2UgJ2EnIGlzIGEgU3RyaW5nIG9iamVjdFxuICAgICAgICBpZiAoYi5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSByZXR1cm4gYisnJyA9PT0gYSsnJzsgLy8gYisnJyAtIGluIGNhc2UgJ2InIGlzIGEgU3RyaW5nIG9iamVjdFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3BsaXRzIHRoZSBzdHJpbmcgaW50byBhbiBhcnJheSBvZiB2YWx1ZXMsIHRyYW5zZm9ybWluZyBlYWNoIHZhbHVlLiBBbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZCBmb3IgbnVsbHMgb3IgZW1wdHlcbiAgICAgKiBzdHJpbmdzXG4gICAgICogQHBhcmFtIHN0cmluZ1xuICAgICAqIEBwYXJhbSBzZXBhcmF0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzcGxpdFZhbChzdHJpbmcsIHNlcGFyYXRvciwgdHJhbnNmb3JtKSB7XG4gICAgICAgIHZhciB2YWwsIGksIGw7XG4gICAgICAgIGlmIChzdHJpbmcgPT09IG51bGwgfHwgc3RyaW5nLmxlbmd0aCA8IDEpIHJldHVybiBbXTtcbiAgICAgICAgdmFsID0gc3RyaW5nLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSA9IGkgKyAxKSB2YWxbaV0gPSB0cmFuc2Zvcm0odmFsW2ldKTtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTaWRlQm9yZGVyUGFkZGluZyhlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50Lm91dGVyV2lkdGgoZmFsc2UpIC0gZWxlbWVudC53aWR0aCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxLZXlVcENoYW5nZUV2ZW50KGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGtleT1cImtleXVwLWNoYW5nZS12YWx1ZVwiO1xuICAgICAgICBlbGVtZW50Lm9uKFwia2V5ZG93blwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoJC5kYXRhKGVsZW1lbnQsIGtleSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICQuZGF0YShlbGVtZW50LCBrZXksIGVsZW1lbnQudmFsKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZWxlbWVudC5vbihcImtleXVwXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YWw9ICQuZGF0YShlbGVtZW50LCBrZXkpO1xuICAgICAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkICYmIGVsZW1lbnQudmFsKCkgIT09IHZhbCkge1xuICAgICAgICAgICAgICAgICQucmVtb3ZlRGF0YShlbGVtZW50LCBrZXkpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQudHJpZ2dlcihcImtleXVwLWNoYW5nZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBmaWx0ZXJzIG1vdXNlIGV2ZW50cyBzbyBhbiBldmVudCBpcyBmaXJlZCBvbmx5IGlmIHRoZSBtb3VzZSBtb3ZlZC5cbiAgICAgKlxuICAgICAqIGZpbHRlcnMgb3V0IG1vdXNlIGV2ZW50cyB0aGF0IG9jY3VyIHdoZW4gbW91c2UgaXMgc3RhdGlvbmFyeSBidXRcbiAgICAgKiB0aGUgZWxlbWVudHMgdW5kZXIgdGhlIHBvaW50ZXIgYXJlIHNjcm9sbGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc3RhbGxGaWx0ZXJlZE1vdXNlTW92ZShlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQub24oXCJtb3VzZW1vdmVcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBsYXN0cG9zID0gbGFzdE1vdXNlUG9zaXRpb247XG4gICAgICAgICAgICBpZiAobGFzdHBvcyA9PT0gdW5kZWZpbmVkIHx8IGxhc3Rwb3MueCAhPT0gZS5wYWdlWCB8fCBsYXN0cG9zLnkgIT09IGUucGFnZVkpIHtcbiAgICAgICAgICAgICAgICAkKGUudGFyZ2V0KS50cmlnZ2VyKFwibW91c2Vtb3ZlLWZpbHRlcmVkXCIsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWJvdW5jZXMgYSBmdW5jdGlvbi4gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY2FsbHMgdGhlIG9yaWdpbmFsIGZuIGZ1bmN0aW9uIG9ubHkgaWYgbm8gaW52b2NhdGlvbnMgaGF2ZSBiZWVuIG1hZGVcbiAgICAgKiB3aXRoaW4gdGhlIGxhc3QgcXVpZXRNaWxsaXMgbWlsbGlzZWNvbmRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHF1aWV0TWlsbGlzIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmUgaW52b2tpbmcgZm5cbiAgICAgKiBAcGFyYW0gZm4gZnVuY3Rpb24gdG8gYmUgZGVib3VuY2VkXG4gICAgICogQHBhcmFtIGN0eCBvYmplY3QgdG8gYmUgdXNlZCBhcyB0aGlzIHJlZmVyZW5jZSB3aXRoaW4gZm5cbiAgICAgKiBAcmV0dXJuIGRlYm91bmNlZCB2ZXJzaW9uIG9mIGZuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVib3VuY2UocXVpZXRNaWxsaXMsIGZuLCBjdHgpIHtcbiAgICAgICAgY3R4ID0gY3R4IHx8IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZm4uYXBwbHkoY3R4LCBhcmdzKTtcbiAgICAgICAgICAgIH0sIHF1aWV0TWlsbGlzKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsRGVib3VuY2VkU2Nyb2xsKHRocmVzaG9sZCwgZWxlbWVudCkge1xuICAgICAgICB2YXIgbm90aWZ5ID0gZGVib3VuY2UodGhyZXNob2xkLCBmdW5jdGlvbiAoZSkgeyBlbGVtZW50LnRyaWdnZXIoXCJzY3JvbGwtZGVib3VuY2VkXCIsIGUpO30pO1xuICAgICAgICBlbGVtZW50Lm9uKFwic2Nyb2xsXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXhPZihlLnRhcmdldCwgZWxlbWVudC5nZXQoKSkgPj0gMCkgbm90aWZ5KGUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb2N1cygkZWwpIHtcbiAgICAgICAgaWYgKCRlbFswXSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkgcmV0dXJuO1xuXG4gICAgICAgIC8qIHNldCB0aGUgZm9jdXMgaW4gYSAwIHRpbWVvdXQgLSB0aGF0IHdheSB0aGUgZm9jdXMgaXMgc2V0IGFmdGVyIHRoZSBwcm9jZXNzaW5nXG4gICAgICAgICAgICBvZiB0aGUgY3VycmVudCBldmVudCBoYXMgZmluaXNoZWQgLSB3aGljaCBzZWVtcyBsaWtlIHRoZSBvbmx5IHJlbGlhYmxlIHdheVxuICAgICAgICAgICAgdG8gc2V0IGZvY3VzICovXG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGVsPSRlbFswXSwgcG9zPSRlbC52YWwoKS5sZW5ndGgsIHJhbmdlO1xuXG4gICAgICAgICAgICAkZWwuZm9jdXMoKTtcblxuICAgICAgICAgICAgLyogbWFrZSBzdXJlIGVsIHJlY2VpdmVkIGZvY3VzIHNvIHdlIGRvIG5vdCBlcnJvciBvdXQgd2hlbiB0cnlpbmcgdG8gbWFuaXB1bGF0ZSB0aGUgY2FyZXQuXG4gICAgICAgICAgICAgICAgc29tZXRpbWVzIG1vZGFscyBvciBvdGhlcnMgbGlzdGVuZXJzIG1heSBzdGVhbCBpdCBhZnRlciBpdHMgc2V0ICovXG4gICAgICAgICAgICB2YXIgaXNWaXNpYmxlID0gKGVsLm9mZnNldFdpZHRoID4gMCB8fCBlbC5vZmZzZXRIZWlnaHQgPiAwKTtcbiAgICAgICAgICAgIGlmIChpc1Zpc2libGUgJiYgZWwgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcblxuICAgICAgICAgICAgICAgIC8qIGFmdGVyIHRoZSBmb2N1cyBpcyBzZXQgbW92ZSB0aGUgY2FyZXQgdG8gdGhlIGVuZCwgbmVjZXNzYXJ5IHdoZW4gd2UgdmFsKClcbiAgICAgICAgICAgICAgICAgICAganVzdCBiZWZvcmUgc2V0dGluZyBmb2N1cyAqL1xuICAgICAgICAgICAgICAgIGlmKGVsLnNldFNlbGVjdGlvblJhbmdlKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuc2V0U2VsZWN0aW9uUmFuZ2UocG9zLCBwb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlbC5jcmVhdGVUZXh0UmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBlbC5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UuY29sbGFwc2UoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZWxlY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEN1cnNvckluZm8oZWwpIHtcbiAgICAgICAgZWwgPSAkKGVsKVswXTtcbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgIHZhciBsZW5ndGggPSAwO1xuICAgICAgICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBlbCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gZWwuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgICAgICBsZW5ndGggPSBlbC5zZWxlY3Rpb25FbmQgLSBvZmZzZXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoJ3NlbGVjdGlvbicgaW4gZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIGVsLmZvY3VzKCk7XG4gICAgICAgICAgICB2YXIgc2VsID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICBsZW5ndGggPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKS50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIHNlbC5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIC1lbC52YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gc2VsLnRleHQubGVuZ3RoIC0gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG9mZnNldDogb2Zmc2V0LCBsZW5ndGg6IGxlbmd0aCB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGtpbGxFdmVudChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gICAgZnVuY3Rpb24ga2lsbEV2ZW50SW1tZWRpYXRlbHkoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVhc3VyZVRleHRXaWR0aChlKSB7XG4gICAgICAgIGlmICghc2l6ZXIpe1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gZVswXS5jdXJyZW50U3R5bGUgfHwgd2luZG93LmdldENvbXB1dGVkU3R5bGUoZVswXSwgbnVsbCk7XG4gICAgICAgICAgICBzaXplciA9ICQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSkuY3NzKHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgICAgIGxlZnQ6IFwiLTEwMDAwcHhcIixcbiAgICAgICAgICAgICAgICB0b3A6IFwiLTEwMDAwcHhcIixcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogc3R5bGUuZm9udFNpemUsXG4gICAgICAgICAgICAgICAgZm9udEZhbWlseTogc3R5bGUuZm9udEZhbWlseSxcbiAgICAgICAgICAgICAgICBmb250U3R5bGU6IHN0eWxlLmZvbnRTdHlsZSxcbiAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiBzdHlsZS5mb250V2VpZ2h0LFxuICAgICAgICAgICAgICAgIGxldHRlclNwYWNpbmc6IHN0eWxlLmxldHRlclNwYWNpbmcsXG4gICAgICAgICAgICAgICAgdGV4dFRyYW5zZm9ybTogc3R5bGUudGV4dFRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICB3aGl0ZVNwYWNlOiBcIm5vd3JhcFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNpemVyLmF0dHIoXCJjbGFzc1wiLFwic2VsZWN0Mi1zaXplclwiKTtcbiAgICAgICAgICAgICQoZG9jdW1lbnQuYm9keSkuYXBwZW5kKHNpemVyKTtcbiAgICAgICAgfVxuICAgICAgICBzaXplci50ZXh0KGUudmFsKCkpO1xuICAgICAgICByZXR1cm4gc2l6ZXIud2lkdGgoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzeW5jQ3NzQ2xhc3NlcyhkZXN0LCBzcmMsIGFkYXB0ZXIpIHtcbiAgICAgICAgdmFyIGNsYXNzZXMsIHJlcGxhY2VtZW50cyA9IFtdLCBhZGFwdGVkO1xuXG4gICAgICAgIGNsYXNzZXMgPSAkLnRyaW0oZGVzdC5hdHRyKFwiY2xhc3NcIikpO1xuXG4gICAgICAgIGlmIChjbGFzc2VzKSB7XG4gICAgICAgICAgICBjbGFzc2VzID0gJycgKyBjbGFzc2VzOyAvLyBmb3IgSUUgd2hpY2ggcmV0dXJucyBvYmplY3RcblxuICAgICAgICAgICAgJChjbGFzc2VzLnNwbGl0KC9cXHMrLykpLmVhY2gyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZGV4T2YoXCJzZWxlY3QyLVwiKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudHMucHVzaCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsYXNzZXMgPSAkLnRyaW0oc3JjLmF0dHIoXCJjbGFzc1wiKSk7XG5cbiAgICAgICAgaWYgKGNsYXNzZXMpIHtcbiAgICAgICAgICAgIGNsYXNzZXMgPSAnJyArIGNsYXNzZXM7IC8vIGZvciBJRSB3aGljaCByZXR1cm5zIG9iamVjdFxuXG4gICAgICAgICAgICAkKGNsYXNzZXMuc3BsaXQoL1xccysvKSkuZWFjaDIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXhPZihcInNlbGVjdDItXCIpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkYXB0ZWQgPSBhZGFwdGVyKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGFwdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudHMucHVzaChhZGFwdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVzdC5hdHRyKFwiY2xhc3NcIiwgcmVwbGFjZW1lbnRzLmpvaW4oXCIgXCIpKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIG1hcmtNYXRjaCh0ZXh0LCB0ZXJtLCBtYXJrdXAsIGVzY2FwZU1hcmt1cCkge1xuICAgICAgICB2YXIgbWF0Y2g9c3RyaXBEaWFjcml0aWNzKHRleHQudG9VcHBlckNhc2UoKSkuaW5kZXhPZihzdHJpcERpYWNyaXRpY3ModGVybS50b1VwcGVyQ2FzZSgpKSksXG4gICAgICAgICAgICB0bD10ZXJtLmxlbmd0aDtcblxuICAgICAgICBpZiAobWF0Y2g8MCkge1xuICAgICAgICAgICAgbWFya3VwLnB1c2goZXNjYXBlTWFya3VwKHRleHQpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hcmt1cC5wdXNoKGVzY2FwZU1hcmt1cCh0ZXh0LnN1YnN0cmluZygwLCBtYXRjaCkpKTtcbiAgICAgICAgbWFya3VwLnB1c2goXCI8c3BhbiBjbGFzcz0nc2VsZWN0Mi1tYXRjaCc+XCIpO1xuICAgICAgICBtYXJrdXAucHVzaChlc2NhcGVNYXJrdXAodGV4dC5zdWJzdHJpbmcobWF0Y2gsIG1hdGNoICsgdGwpKSk7XG4gICAgICAgIG1hcmt1cC5wdXNoKFwiPC9zcGFuPlwiKTtcbiAgICAgICAgbWFya3VwLnB1c2goZXNjYXBlTWFya3VwKHRleHQuc3Vic3RyaW5nKG1hdGNoICsgdGwsIHRleHQubGVuZ3RoKSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRFc2NhcGVNYXJrdXAobWFya3VwKSB7XG4gICAgICAgIHZhciByZXBsYWNlX21hcCA9IHtcbiAgICAgICAgICAgICdcXFxcJzogJyYjOTI7JyxcbiAgICAgICAgICAgICcmJzogJyZhbXA7JyxcbiAgICAgICAgICAgICc8JzogJyZsdDsnLFxuICAgICAgICAgICAgJz4nOiAnJmd0OycsXG4gICAgICAgICAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICAgICAgICAgIFwiJ1wiOiAnJiMzOTsnLFxuICAgICAgICAgICAgXCIvXCI6ICcmIzQ3OydcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gU3RyaW5nKG1hcmt1cCkucmVwbGFjZSgvWyY8PlwiJ1xcL1xcXFxdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VfbWFwW21hdGNoXTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYW4gYWpheC1iYXNlZCBxdWVyeSBmdW5jdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IGNvbnRhaW5pbmcgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIG9wdGlvbnMucGFyYW1zIHBhcmFtZXRlciBtYXAgZm9yIHRoZSB0cmFuc3BvcnQgYWpheCBjYWxsLCBjYW4gY29udGFpbiBzdWNoIG9wdGlvbnMgYXMgY2FjaGUsIGpzb25wQ2FsbGJhY2ssIGV0Yy4gc2VlICQuYWpheFxuICAgICAqIEBwYXJhbSBvcHRpb25zLnRyYW5zcG9ydCBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgdXNlZCB0byBleGVjdXRlIHRoZSBhamF4IHJlcXVlc3QuIG11c3QgYmUgY29tcGF0aWJsZSB3aXRoIHBhcmFtZXRlcnMgc3VwcG9ydGVkIGJ5ICQuYWpheFxuICAgICAqIEBwYXJhbSBvcHRpb25zLnVybCB1cmwgZm9yIHRoZSBkYXRhXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZGF0YSBhIGZ1bmN0aW9uKHNlYXJjaFRlcm0sIHBhZ2VOdW1iZXIsIGNvbnRleHQpIHRoYXQgc2hvdWxkIHJldHVybiBhbiBvYmplY3QgY29udGFpbmluZyBxdWVyeSBzdHJpbmcgcGFyYW1ldGVycyBmb3IgdGhlIGFib3ZlIHVybC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kYXRhVHlwZSByZXF1ZXN0IGRhdGEgdHlwZTogYWpheCwganNvbnAsIG90aGVyIGRhdGF0eXBlcyBzdXBwb3J0ZWQgYnkgalF1ZXJ5J3MgJC5hamF4IGZ1bmN0aW9uIG9yIHRoZSB0cmFuc3BvcnQgZnVuY3Rpb24gaWYgc3BlY2lmaWVkXG4gICAgICogQHBhcmFtIG9wdGlvbnMucXVpZXRNaWxsaXMgKG9wdGlvbmFsKSBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmUgbWFraW5nIHRoZSBhamF4UmVxdWVzdCwgaGVscHMgZGVib3VuY2UgdGhlIGFqYXggZnVuY3Rpb24gaWYgaW52b2tlZCB0b28gb2Z0ZW5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5yZXN1bHRzIGEgZnVuY3Rpb24ocmVtb3RlRGF0YSwgcGFnZU51bWJlciwgcXVlcnkpIHRoYXQgY29udmVydHMgZGF0YSByZXR1cm5lZCBmb3JtIHRoZSByZW1vdGUgcmVxdWVzdCB0byB0aGUgZm9ybWF0IGV4cGVjdGVkIGJ5IFNlbGVjdDIuXG4gICAgICogICAgICBUaGUgZXhwZWN0ZWQgZm9ybWF0IGlzIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcga2V5czpcbiAgICAgKiAgICAgIHJlc3VsdHMgYXJyYXkgb2Ygb2JqZWN0cyB0aGF0IHdpbGwgYmUgdXNlZCBhcyBjaG9pY2VzXG4gICAgICogICAgICBtb3JlIChvcHRpb25hbCkgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlcmUgYXJlIG1vcmUgcmVzdWx0cyBhdmFpbGFibGVcbiAgICAgKiAgICAgIEV4YW1wbGU6IHtyZXN1bHRzOlt7aWQ6MSwgdGV4dDonUmVkJ30se2lkOjIsIHRleHQ6J0JsdWUnfV0sIG1vcmU6dHJ1ZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhamF4KG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRpbWVvdXQsIC8vIGN1cnJlbnQgc2NoZWR1bGVkIGJ1dCBub3QgeWV0IGV4ZWN1dGVkIHJlcXVlc3RcbiAgICAgICAgICAgIGhhbmRsZXIgPSBudWxsLFxuICAgICAgICAgICAgcXVpZXRNaWxsaXMgPSBvcHRpb25zLnF1aWV0TWlsbGlzIHx8IDEwMCxcbiAgICAgICAgICAgIGFqYXhVcmwgPSBvcHRpb25zLnVybCxcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gb3B0aW9ucy5kYXRhLCAvLyBhamF4IGRhdGEgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgdXJsID0gYWpheFVybCwgLy8gYWpheCB1cmwgc3RyaW5nIG9yIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydCA9IG9wdGlvbnMudHJhbnNwb3J0IHx8ICQuZm4uc2VsZWN0Mi5hamF4RGVmYXVsdHMudHJhbnNwb3J0LFxuICAgICAgICAgICAgICAgICAgICAvLyBkZXByZWNhdGVkIC0gdG8gYmUgcmVtb3ZlZCBpbiA0LjAgIC0gdXNlIHBhcmFtcyBpbnN0ZWFkXG4gICAgICAgICAgICAgICAgICAgIGRlcHJlY2F0ZWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBvcHRpb25zLnR5cGUgfHwgJ0dFVCcsIC8vIHNldCB0eXBlIG9mIHJlcXVlc3QgKEdFVCBvciBQT1NUKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IG9wdGlvbnMuY2FjaGUgfHwgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBqc29ucENhbGxiYWNrOiBvcHRpb25zLmpzb25wQ2FsbGJhY2t8fHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlOiBvcHRpb25zLmRhdGFUeXBlfHxcImpzb25cIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSAkLmV4dGVuZCh7fSwgJC5mbi5zZWxlY3QyLmFqYXhEZWZhdWx0cy5wYXJhbXMsIGRlcHJlY2F0ZWQpO1xuXG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEgPyBkYXRhLmNhbGwoc2VsZiwgcXVlcnkudGVybSwgcXVlcnkucGFnZSwgcXVlcnkuY29udGV4dCkgOiBudWxsO1xuICAgICAgICAgICAgICAgIHVybCA9ICh0eXBlb2YgdXJsID09PSAnZnVuY3Rpb24nKSA/IHVybC5jYWxsKHNlbGYsIHF1ZXJ5LnRlcm0sIHF1ZXJ5LnBhZ2UsIHF1ZXJ5LmNvbnRleHQpIDogdXJsO1xuXG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIgJiYgdHlwZW9mIGhhbmRsZXIuYWJvcnQgPT09IFwiZnVuY3Rpb25cIikgeyBoYW5kbGVyLmFib3J0KCk7IH1cblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoJC5pc0Z1bmN0aW9uKG9wdGlvbnMucGFyYW1zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJC5leHRlbmQocGFyYW1zLCBvcHRpb25zLnBhcmFtcy5jYWxsKHNlbGYpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQuZXh0ZW5kKHBhcmFtcywgb3B0aW9ucy5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgJC5leHRlbmQocGFyYW1zLCB7XG4gICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogb3B0aW9ucy5kYXRhVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gLSByZXBsYWNlIHF1ZXJ5LnBhZ2Ugd2l0aCBxdWVyeSBzbyB1c2VycyBoYXZlIGFjY2VzcyB0byB0ZXJtLCBwYWdlLCBldGMuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGRlZCBxdWVyeSBhcyB0aGlyZCBwYXJhbXRlciB0byBrZWVwIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0cyA9IG9wdGlvbnMucmVzdWx0cyhkYXRhLCBxdWVyeS5wYWdlLCBxdWVyeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5jYWxsYmFjayhyZXN1bHRzKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKGpxWEhSLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bil7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNFcnJvcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcVhIUjoganFYSFIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFN0YXR1czogdGV4dFN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvclRocm93bjogZXJyb3JUaHJvd25cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5LmNhbGxiYWNrKHJlc3VsdHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaGFuZGxlciA9IHRyYW5zcG9ydC5jYWxsKHNlbGYsIHBhcmFtcyk7XG4gICAgICAgICAgICB9LCBxdWlldE1pbGxpcyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYSBxdWVyeSBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggYSBsb2NhbCBhcnJheVxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IGNvbnRhaW5pbmcgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzLiBUaGUgb3B0aW9ucyBwYXJhbWV0ZXIgY2FuIGVpdGhlciBiZSBhbiBhcnJheSBvciBhblxuICAgICAqIG9iamVjdC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBhcnJheSBmb3JtIGlzIHVzZWQgaXQgaXMgYXNzdW1lZCB0aGF0IGl0IGNvbnRhaW5zIG9iamVjdHMgd2l0aCAnaWQnIGFuZCAndGV4dCcga2V5cy5cbiAgICAgKlxuICAgICAqIElmIHRoZSBvYmplY3QgZm9ybSBpcyB1c2VkIGl0IGlzIGFzc3VtZWQgdGhhdCBpdCBjb250YWlucyAnZGF0YScgYW5kICd0ZXh0JyBrZXlzLiBUaGUgJ2RhdGEnIGtleSBzaG91bGQgY29udGFpblxuICAgICAqIGFuIGFycmF5IG9mIG9iamVjdHMgdGhhdCB3aWxsIGJlIHVzZWQgYXMgY2hvaWNlcy4gVGhlc2Ugb2JqZWN0cyBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgYW4gJ2lkJyBrZXkuIFRoZSAndGV4dCdcbiAgICAgKiBrZXkgY2FuIGVpdGhlciBiZSBhIFN0cmluZyBpbiB3aGljaCBjYXNlIGl0IGlzIGV4cGVjdGVkIHRoYXQgZWFjaCBlbGVtZW50IGluIHRoZSAnZGF0YScgYXJyYXkgaGFzIGEga2V5IHdpdGggdGhlXG4gICAgICogdmFsdWUgb2YgJ3RleHQnIHdoaWNoIHdpbGwgYmUgdXNlZCB0byBtYXRjaCBjaG9pY2VzLiBBbHRlcm5hdGl2ZWx5LCB0ZXh0IGNhbiBiZSBhIGZ1bmN0aW9uKGl0ZW0pIHRoYXQgY2FuIGV4dHJhY3RcbiAgICAgKiB0aGUgdGV4dC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2NhbChvcHRpb25zKSB7XG4gICAgICAgIHZhciBkYXRhID0gb3B0aW9ucywgLy8gZGF0YSBlbGVtZW50c1xuICAgICAgICAgICAgZGF0YVRleHQsXG4gICAgICAgICAgICB0bXAsXG4gICAgICAgICAgICB0ZXh0ID0gZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIFwiXCIraXRlbS50ZXh0OyB9OyAvLyBmdW5jdGlvbiB1c2VkIHRvIHJldHJpZXZlIHRoZSB0ZXh0IHBvcnRpb24gb2YgYSBkYXRhIGl0ZW0gdGhhdCBpcyBtYXRjaGVkIGFnYWluc3QgdGhlIHNlYXJjaFxuXG4gICAgICAgICBpZiAoJC5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICB0bXAgPSBkYXRhO1xuICAgICAgICAgICAgZGF0YSA9IHsgcmVzdWx0czogdG1wIH07XG4gICAgICAgIH1cblxuICAgICAgICAgaWYgKCQuaXNGdW5jdGlvbihkYXRhKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRtcCA9IGRhdGE7XG4gICAgICAgICAgICBkYXRhID0gZnVuY3Rpb24oKSB7IHJldHVybiB0bXA7IH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YUl0ZW0gPSBkYXRhKCk7XG4gICAgICAgIGlmIChkYXRhSXRlbS50ZXh0KSB7XG4gICAgICAgICAgICB0ZXh0ID0gZGF0YUl0ZW0udGV4dDtcbiAgICAgICAgICAgIC8vIGlmIHRleHQgaXMgbm90IGEgZnVuY3Rpb24gd2UgYXNzdW1lIGl0IHRvIGJlIGEga2V5IG5hbWVcbiAgICAgICAgICAgIGlmICghJC5pc0Z1bmN0aW9uKHRleHQpKSB7XG4gICAgICAgICAgICAgICAgZGF0YVRleHQgPSBkYXRhSXRlbS50ZXh0OyAvLyB3ZSBuZWVkIHRvIHN0b3JlIHRoaXMgaW4gYSBzZXBhcmF0ZSB2YXJpYWJsZSBiZWNhdXNlIGluIHRoZSBuZXh0IHN0ZXAgZGF0YSBnZXRzIHJlc2V0IGFuZCBkYXRhLnRleHQgaXMgbm8gbG9uZ2VyIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgIHRleHQgPSBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbVtkYXRhVGV4dF07IH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgICAgICAgICB2YXIgdCA9IHF1ZXJ5LnRlcm0sIGZpbHRlcmVkID0geyByZXN1bHRzOiBbXSB9LCBwcm9jZXNzO1xuICAgICAgICAgICAgaWYgKHQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBxdWVyeS5jYWxsYmFjayhkYXRhKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvY2VzcyA9IGZ1bmN0aW9uKGRhdHVtLCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwLCBhdHRyO1xuICAgICAgICAgICAgICAgIGRhdHVtID0gZGF0dW1bMF07XG4gICAgICAgICAgICAgICAgaWYgKGRhdHVtLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwID0ge307XG4gICAgICAgICAgICAgICAgICAgIGZvciAoYXR0ciBpbiBkYXR1bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdHVtLmhhc093blByb3BlcnR5KGF0dHIpKSBncm91cFthdHRyXT1kYXR1bVthdHRyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBncm91cC5jaGlsZHJlbj1bXTtcbiAgICAgICAgICAgICAgICAgICAgJChkYXR1bS5jaGlsZHJlbikuZWFjaDIoZnVuY3Rpb24oaSwgY2hpbGREYXR1bSkgeyBwcm9jZXNzKGNoaWxkRGF0dW0sIGdyb3VwLmNoaWxkcmVuKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChncm91cC5jaGlsZHJlbi5sZW5ndGggfHwgcXVlcnkubWF0Y2hlcih0LCB0ZXh0KGdyb3VwKSwgZGF0dW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLnB1c2goZ3JvdXApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHF1ZXJ5Lm1hdGNoZXIodCwgdGV4dChkYXR1bSksIGRhdHVtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbi5wdXNoKGRhdHVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICQoZGF0YSgpLnJlc3VsdHMpLmVhY2gyKGZ1bmN0aW9uKGksIGRhdHVtKSB7IHByb2Nlc3MoZGF0dW0sIGZpbHRlcmVkLnJlc3VsdHMpOyB9KTtcbiAgICAgICAgICAgIHF1ZXJ5LmNhbGxiYWNrKGZpbHRlcmVkKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBUT0RPIGphdmFkb2NcbiAgICBmdW5jdGlvbiB0YWdzKGRhdGEpIHtcbiAgICAgICAgdmFyIGlzRnVuYyA9ICQuaXNGdW5jdGlvbihkYXRhKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChxdWVyeSkge1xuICAgICAgICAgICAgdmFyIHQgPSBxdWVyeS50ZXJtLCBmaWx0ZXJlZCA9IHtyZXN1bHRzOiBbXX07XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gaXNGdW5jID8gZGF0YShxdWVyeSkgOiBkYXRhO1xuICAgICAgICAgICAgaWYgKCQuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgJChyZXN1bHQpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNPYmplY3QgPSB0aGlzLnRleHQgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSBpc09iamVjdCA/IHRoaXMudGV4dCA6IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ID09PSBcIlwiIHx8IHF1ZXJ5Lm1hdGNoZXIodCwgdGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkLnJlc3VsdHMucHVzaChpc09iamVjdCA/IHRoaXMgOiB7aWQ6IHRoaXMsIHRleHQ6IHRoaXN9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHF1ZXJ5LmNhbGxiYWNrKGZpbHRlcmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGZvcm1hdHRlciBmdW5jdGlvbiBzaG91bGQgYmUgdXNlZC5cbiAgICAgKlxuICAgICAqIFRocm93cyBhbiBlcnJvciBpZiBpdCBpcyBub3QgYSBmdW5jdGlvbi4gUmV0dXJucyB0cnVlIGlmIGl0IHNob3VsZCBiZSB1c2VkLFxuICAgICAqIGZhbHNlIGlmIG5vIGZvcm1hdHRpbmcgc2hvdWxkIGJlIHBlcmZvcm1lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmb3JtYXR0ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGVja0Zvcm1hdHRlcihmb3JtYXR0ZXIsIGZvcm1hdHRlck5hbWUpIHtcbiAgICAgICAgaWYgKCQuaXNGdW5jdGlvbihmb3JtYXR0ZXIpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKCFmb3JtYXR0ZXIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZihmb3JtYXR0ZXIpID09PSAnc3RyaW5nJykgcmV0dXJuIHRydWU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXR0ZXJOYW1lICtcIiBtdXN0IGJlIGEgc3RyaW5nLCBmdW5jdGlvbiwgb3IgZmFsc3kgdmFsdWVcIik7XG4gICAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZ2l2ZW4gdmFsdWVcbiAgICogSWYgZ2l2ZW4gYSBmdW5jdGlvbiwgcmV0dXJucyBpdHMgb3V0cHV0XG4gICAqXG4gICAqIEBwYXJhbSB2YWwgc3RyaW5nfGZ1bmN0aW9uXG4gICAqIEBwYXJhbSBjb250ZXh0IHZhbHVlIG9mIFwidGhpc1wiIHRvIGJlIHBhc3NlZCB0byBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gICAgZnVuY3Rpb24gZXZhbHVhdGUodmFsLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICgkLmlzRnVuY3Rpb24odmFsKSkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbC5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvdW50UmVzdWx0cyhyZXN1bHRzKSB7XG4gICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICQuZWFjaChyZXN1bHRzLCBmdW5jdGlvbihpLCBpdGVtKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGNvdW50ICs9IGNvdW50UmVzdWx0cyhpdGVtLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHRva2VuaXplci4gVGhpcyBmdW5jdGlvbiB1c2VzIGJyZWFrcyB0aGUgaW5wdXQgb24gc3Vic3RyaW5nIG1hdGNoIG9mIGFueSBzdHJpbmcgZnJvbSB0aGVcbiAgICAgKiBvcHRzLnRva2VuU2VwYXJhdG9ycyBhcnJheSBhbmQgdXNlcyBvcHRzLmNyZWF0ZVNlYXJjaENob2ljZSB0byBjcmVhdGUgdGhlIGNob2ljZSBvYmplY3QuIEJvdGggb2YgdGhvc2VcbiAgICAgKiB0d28gb3B0aW9ucyBoYXZlIHRvIGJlIGRlZmluZWQgaW4gb3JkZXIgZm9yIHRoZSB0b2tlbml6ZXIgdG8gd29yay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCB0ZXh0IHVzZXIgaGFzIHR5cGVkIHNvIGZhciBvciBwYXN0ZWQgaW50byB0aGUgc2VhcmNoIGZpZWxkXG4gICAgICogQHBhcmFtIHNlbGVjdGlvbiBjdXJyZW50bHkgc2VsZWN0ZWQgY2hvaWNlc1xuICAgICAqIEBwYXJhbSBzZWxlY3RDYWxsYmFjayBmdW5jdGlvbihjaG9pY2UpIGNhbGxiYWNrIHRobyBhZGQgdGhlIGNob2ljZSB0byBzZWxlY3Rpb25cbiAgICAgKiBAcGFyYW0gb3B0cyBzZWxlY3QyJ3Mgb3B0c1xuICAgICAqIEByZXR1cm4gdW5kZWZpbmVkL251bGwgdG8gbGVhdmUgdGhlIGN1cnJlbnQgaW5wdXQgdW5jaGFuZ2VkLCBvciBhIHN0cmluZyB0byBjaGFuZ2UgdGhlIGlucHV0IHRvIHRoZSByZXR1cm5lZCB2YWx1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZmF1bHRUb2tlbml6ZXIoaW5wdXQsIHNlbGVjdGlvbiwgc2VsZWN0Q2FsbGJhY2ssIG9wdHMpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsID0gaW5wdXQsIC8vIHN0b3JlIHRoZSBvcmlnaW5hbCBzbyB3ZSBjYW4gY29tcGFyZSBhbmQga25vdyBpZiB3ZSBuZWVkIHRvIHRlbGwgdGhlIHNlYXJjaCB0byB1cGRhdGUgaXRzIHRleHRcbiAgICAgICAgICAgIGR1cGUgPSBmYWxzZSwgLy8gY2hlY2sgZm9yIHdoZXRoZXIgYSB0b2tlbiB3ZSBleHRyYWN0ZWQgcmVwcmVzZW50cyBhIGR1cGxpY2F0ZSBzZWxlY3RlZCBjaG9pY2VcbiAgICAgICAgICAgIHRva2VuLCAvLyB0b2tlblxuICAgICAgICAgICAgaW5kZXgsIC8vIHBvc2l0aW9uIGF0IHdoaWNoIHRoZSBzZXBhcmF0b3Igd2FzIGZvdW5kXG4gICAgICAgICAgICBpLCBsLCAvLyBsb29waW5nIHZhcmlhYmxlc1xuICAgICAgICAgICAgc2VwYXJhdG9yOyAvLyB0aGUgbWF0Y2hlZCBzZXBhcmF0b3JcblxuICAgICAgICBpZiAoIW9wdHMuY3JlYXRlU2VhcmNoQ2hvaWNlIHx8ICFvcHRzLnRva2VuU2VwYXJhdG9ycyB8fCBvcHRzLnRva2VuU2VwYXJhdG9ycy5sZW5ndGggPCAxKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpbmRleCA9IC0xO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gb3B0cy50b2tlblNlcGFyYXRvcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yID0gb3B0cy50b2tlblNlcGFyYXRvcnNbaV07XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpbnB1dC5pbmRleE9mKHNlcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW5kZXggPCAwKSBicmVhazsgLy8gZGlkIG5vdCBmaW5kIGFueSB0b2tlbiBzZXBhcmF0b3IgaW4gdGhlIGlucHV0IHN0cmluZywgYmFpbFxuXG4gICAgICAgICAgICB0b2tlbiA9IGlucHV0LnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0LnN1YnN0cmluZyhpbmRleCArIHNlcGFyYXRvci5sZW5ndGgpO1xuXG4gICAgICAgICAgICBpZiAodG9rZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRva2VuID0gb3B0cy5jcmVhdGVTZWFyY2hDaG9pY2UuY2FsbCh0aGlzLCB0b2tlbiwgc2VsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IHVuZGVmaW5lZCAmJiB0b2tlbiAhPT0gbnVsbCAmJiBvcHRzLmlkKHRva2VuKSAhPT0gdW5kZWZpbmVkICYmIG9wdHMuaWQodG9rZW4pICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGR1cGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IHNlbGVjdGlvbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcXVhbChvcHRzLmlkKHRva2VuKSwgb3B0cy5pZChzZWxlY3Rpb25baV0pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cGUgPSB0cnVlOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghZHVwZSkgc2VsZWN0Q2FsbGJhY2sodG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcmlnaW5hbCE9PWlucHV0KSByZXR1cm4gaW5wdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYW51cEpRdWVyeUVsZW1lbnRzKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgJC5lYWNoKGFyZ3VtZW50cywgZnVuY3Rpb24gKGksIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHNlbGZbZWxlbWVudF0ucmVtb3ZlKCk7XG4gICAgICAgICAgICBzZWxmW2VsZW1lbnRdID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjbGFzc1xuICAgICAqXG4gICAgICogQHBhcmFtIHN1cGVyQ2xhc3NcbiAgICAgKiBAcGFyYW0gbWV0aG9kc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsYXp6KFN1cGVyQ2xhc3MsIG1ldGhvZHMpIHtcbiAgICAgICAgdmFyIGNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IG5ldyBTdXBlckNsYXNzO1xuICAgICAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjb25zdHJ1Y3RvcjtcbiAgICAgICAgY29uc3RydWN0b3IucHJvdG90eXBlLnBhcmVudCA9IFN1cGVyQ2xhc3MucHJvdG90eXBlO1xuICAgICAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSAkLmV4dGVuZChjb25zdHJ1Y3Rvci5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICAgICAgICByZXR1cm4gY29uc3RydWN0b3I7XG4gICAgfVxuXG4gICAgQWJzdHJhY3RTZWxlY3QyID0gY2xhenooT2JqZWN0LCB7XG5cbiAgICAgICAgLy8gYWJzdHJhY3RcbiAgICAgICAgYmluZDogZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuYy5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBhYnN0cmFjdFxuICAgICAgICBpbml0OiBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMsIHNlYXJjaCwgcmVzdWx0c1NlbGVjdG9yID0gXCIuc2VsZWN0Mi1yZXN1bHRzXCI7XG5cbiAgICAgICAgICAgIC8vIHByZXBhcmUgb3B0aW9uc1xuICAgICAgICAgICAgdGhpcy5vcHRzID0gb3B0cyA9IHRoaXMucHJlcGFyZU9wdHMob3B0cyk7XG5cbiAgICAgICAgICAgIHRoaXMuaWQ9b3B0cy5pZDtcblxuICAgICAgICAgICAgLy8gZGVzdHJveSBpZiBjYWxsZWQgb24gYW4gZXhpc3RpbmcgY29tcG9uZW50XG4gICAgICAgICAgICBpZiAob3B0cy5lbGVtZW50LmRhdGEoXCJzZWxlY3QyXCIpICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBvcHRzLmVsZW1lbnQuZGF0YShcInNlbGVjdDJcIikgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvcHRzLmVsZW1lbnQuZGF0YShcInNlbGVjdDJcIikuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMuY3JlYXRlQ29udGFpbmVyKCk7XG5cbiAgICAgICAgICAgIHRoaXMubGl2ZVJlZ2lvbiA9ICQoJy5zZWxlY3QyLWhpZGRlbi1hY2Nlc3NpYmxlJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5saXZlUmVnaW9uLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXZlUmVnaW9uID0gJChcIjxzcGFuPlwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb2xlOiBcInN0YXR1c1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJhcmlhLWxpdmVcIjogXCJwb2xpdGVcIlxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJzZWxlY3QyLWhpZGRlbi1hY2Nlc3NpYmxlXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbyhkb2N1bWVudC5ib2R5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jb250YWluZXJJZD1cInMyaWRfXCIrKG9wdHMuZWxlbWVudC5hdHRyKFwiaWRcIikgfHwgXCJhdXRvZ2VuXCIrbmV4dFVpZCgpKTtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyRXZlbnROYW1lPSB0aGlzLmNvbnRhaW5lcklkXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoLyhbLl0pL2csICdfJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvKFs7JixcXC1cXC5cXCtcXCpcXH4nOlwiXFwhXFxeIyQlQFxcW1xcXVxcKFxcKT0+XFx8XSkvZywgJ1xcXFwkMScpO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYXR0cihcImlkXCIsIHRoaXMuY29udGFpbmVySWQpO1xuXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hdHRyKFwidGl0bGVcIiwgb3B0cy5lbGVtZW50LmF0dHIoXCJ0aXRsZVwiKSk7XG5cbiAgICAgICAgICAgIHRoaXMuYm9keSA9ICQoZG9jdW1lbnQuYm9keSk7XG5cbiAgICAgICAgICAgIHN5bmNDc3NDbGFzc2VzKHRoaXMuY29udGFpbmVyLCB0aGlzLm9wdHMuZWxlbWVudCwgdGhpcy5vcHRzLmFkYXB0Q29udGFpbmVyQ3NzQ2xhc3MpO1xuXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hdHRyKFwic3R5bGVcIiwgb3B0cy5lbGVtZW50LmF0dHIoXCJzdHlsZVwiKSk7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5jc3MoZXZhbHVhdGUob3B0cy5jb250YWluZXJDc3MsIHRoaXMub3B0cy5lbGVtZW50KSk7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRDbGFzcyhldmFsdWF0ZShvcHRzLmNvbnRhaW5lckNzc0NsYXNzLCB0aGlzLm9wdHMuZWxlbWVudCkpO1xuXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRUYWJJbmRleCA9IHRoaXMub3B0cy5lbGVtZW50LmF0dHIoXCJ0YWJpbmRleFwiKTtcblxuICAgICAgICAgICAgLy8gc3dhcCBjb250YWluZXIgZm9yIHRoZSBlbGVtZW50XG4gICAgICAgICAgICB0aGlzLm9wdHMuZWxlbWVudFxuICAgICAgICAgICAgICAgIC5kYXRhKFwic2VsZWN0MlwiLCB0aGlzKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwidGFiaW5kZXhcIiwgXCItMVwiKVxuICAgICAgICAgICAgICAgIC5iZWZvcmUodGhpcy5jb250YWluZXIpXG4gICAgICAgICAgICAgICAgLm9uKFwiY2xpY2suc2VsZWN0MlwiLCBraWxsRXZlbnQpOyAvLyBkbyBub3QgbGVhayBjbGljayBldmVudHNcblxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuZGF0YShcInNlbGVjdDJcIiwgdGhpcyk7XG5cbiAgICAgICAgICAgIHRoaXMuZHJvcGRvd24gPSB0aGlzLmNvbnRhaW5lci5maW5kKFwiLnNlbGVjdDItZHJvcFwiKTtcblxuICAgICAgICAgICAgc3luY0Nzc0NsYXNzZXModGhpcy5kcm9wZG93biwgdGhpcy5vcHRzLmVsZW1lbnQsIHRoaXMub3B0cy5hZGFwdERyb3Bkb3duQ3NzQ2xhc3MpO1xuXG4gICAgICAgICAgICB0aGlzLmRyb3Bkb3duLmFkZENsYXNzKGV2YWx1YXRlKG9wdHMuZHJvcGRvd25Dc3NDbGFzcywgdGhpcy5vcHRzLmVsZW1lbnQpKTtcbiAgICAgICAgICAgIHRoaXMuZHJvcGRvd24uZGF0YShcInNlbGVjdDJcIiwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLmRyb3Bkb3duLm9uKFwiY2xpY2tcIiwga2lsbEV2ZW50KTtcblxuICAgICAgICAgICAgdGhpcy5yZXN1bHRzID0gcmVzdWx0cyA9IHRoaXMuY29udGFpbmVyLmZpbmQocmVzdWx0c1NlbGVjdG9yKTtcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoID0gc2VhcmNoID0gdGhpcy5jb250YWluZXIuZmluZChcImlucHV0LnNlbGVjdDItaW5wdXRcIik7XG5cbiAgICAgICAgICAgIHRoaXMucXVlcnlDb3VudCA9IDA7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdHNQYWdlID0gMDtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIGluaXRpYWxpemUgdGhlIGNvbnRhaW5lclxuICAgICAgICAgICAgdGhpcy5pbml0Q29udGFpbmVyKCk7XG5cbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLm9uKFwiY2xpY2tcIiwga2lsbEV2ZW50KTtcblxuICAgICAgICAgICAgaW5zdGFsbEZpbHRlcmVkTW91c2VNb3ZlKHRoaXMucmVzdWx0cyk7XG5cbiAgICAgICAgICAgIHRoaXMuZHJvcGRvd24ub24oXCJtb3VzZW1vdmUtZmlsdGVyZWRcIiwgcmVzdWx0c1NlbGVjdG9yLCB0aGlzLmJpbmQodGhpcy5oaWdobGlnaHRVbmRlckV2ZW50KSk7XG4gICAgICAgICAgICB0aGlzLmRyb3Bkb3duLm9uKFwidG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmRcIiwgcmVzdWx0c1NlbGVjdG9yLCB0aGlzLmJpbmQoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG91Y2hFdmVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRVbmRlckV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHRoaXMuZHJvcGRvd24ub24oXCJ0b3VjaG1vdmVcIiwgcmVzdWx0c1NlbGVjdG9yLCB0aGlzLmJpbmQodGhpcy50b3VjaE1vdmVkKSk7XG4gICAgICAgICAgICB0aGlzLmRyb3Bkb3duLm9uKFwidG91Y2hzdGFydCB0b3VjaGVuZFwiLCByZXN1bHRzU2VsZWN0b3IsIHRoaXMuYmluZCh0aGlzLmNsZWFyVG91Y2hNb3ZlZCkpO1xuXG4gICAgICAgICAgICAvLyBXYWl0aW5nIGZvciBhIGNsaWNrIGV2ZW50IG9uIHRvdWNoIGRldmljZXMgdG8gc2VsZWN0IG9wdGlvbiBhbmQgaGlkZSBkcm9wZG93blxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGNsaWNrIHdpbGwgYmUgdHJpZ2dlcmVkIG9uIGFuIHVuZGVybHlpbmcgZWxlbWVudFxuICAgICAgICAgICAgdGhpcy5kcm9wZG93bi5vbignY2xpY2snLCB0aGlzLmJpbmQoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RvdWNoRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG91Y2hFdmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdEhpZ2hsaWdodGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICBpbnN0YWxsRGVib3VuY2VkU2Nyb2xsKDgwLCB0aGlzLnJlc3VsdHMpO1xuICAgICAgICAgICAgdGhpcy5kcm9wZG93bi5vbihcInNjcm9sbC1kZWJvdW5jZWRcIiwgcmVzdWx0c1NlbGVjdG9yLCB0aGlzLmJpbmQodGhpcy5sb2FkTW9yZUlmTmVlZGVkKSk7XG5cbiAgICAgICAgICAgIC8vIGRvIG5vdCBwcm9wYWdhdGUgY2hhbmdlIGV2ZW50IGZyb20gdGhlIHNlYXJjaCBmaWVsZCBvdXQgb2YgdGhlIGNvbXBvbmVudFxuICAgICAgICAgICAgJCh0aGlzLmNvbnRhaW5lcikub24oXCJjaGFuZ2VcIiwgXCIuc2VsZWN0Mi1pbnB1dFwiLCBmdW5jdGlvbihlKSB7ZS5zdG9wUHJvcGFnYXRpb24oKTt9KTtcbiAgICAgICAgICAgICQodGhpcy5kcm9wZG93bikub24oXCJjaGFuZ2VcIiwgXCIuc2VsZWN0Mi1pbnB1dFwiLCBmdW5jdGlvbihlKSB7ZS5zdG9wUHJvcGFnYXRpb24oKTt9KTtcblxuICAgICAgICAgICAgLy8gaWYganF1ZXJ5Lm1vdXNld2hlZWwgcGx1Z2luIGlzIGluc3RhbGxlZCB3ZSBjYW4gcHJldmVudCBvdXQtb2YtYm91bmRzIHNjcm9sbGluZyBvZiByZXN1bHRzIHZpYSBtb3VzZXdoZWVsXG4gICAgICAgICAgICBpZiAoJC5mbi5tb3VzZXdoZWVsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5tb3VzZXdoZWVsKGZ1bmN0aW9uIChlLCBkZWx0YSwgZGVsdGFYLCBkZWx0YVkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvcCA9IHJlc3VsdHMuc2Nyb2xsVG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWx0YVkgPiAwICYmIHRvcCAtIGRlbHRhWSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnNjcm9sbFRvcCgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbGxFdmVudChlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkZWx0YVkgPCAwICYmIHJlc3VsdHMuZ2V0KDApLnNjcm9sbEhlaWdodCAtIHJlc3VsdHMuc2Nyb2xsVG9wKCkgKyBkZWx0YVkgPD0gcmVzdWx0cy5oZWlnaHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5zY3JvbGxUb3AocmVzdWx0cy5nZXQoMCkuc2Nyb2xsSGVpZ2h0IC0gcmVzdWx0cy5oZWlnaHQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBraWxsRXZlbnQoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5zdGFsbEtleVVwQ2hhbmdlRXZlbnQoc2VhcmNoKTtcbiAgICAgICAgICAgIHNlYXJjaC5vbihcImtleXVwLWNoYW5nZSBpbnB1dCBwYXN0ZVwiLCB0aGlzLmJpbmQodGhpcy51cGRhdGVSZXN1bHRzKSk7XG4gICAgICAgICAgICBzZWFyY2gub24oXCJmb2N1c1wiLCBmdW5jdGlvbiAoKSB7IHNlYXJjaC5hZGRDbGFzcyhcInNlbGVjdDItZm9jdXNlZFwiKTsgfSk7XG4gICAgICAgICAgICBzZWFyY2gub24oXCJibHVyXCIsIGZ1bmN0aW9uICgpIHsgc2VhcmNoLnJlbW92ZUNsYXNzKFwic2VsZWN0Mi1mb2N1c2VkXCIpO30pO1xuXG4gICAgICAgICAgICB0aGlzLmRyb3Bkb3duLm9uKFwibW91c2V1cFwiLCByZXN1bHRzU2VsZWN0b3IsIHRoaXMuYmluZChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmICgkKGUudGFyZ2V0KS5jbG9zZXN0KFwiLnNlbGVjdDItcmVzdWx0LXNlbGVjdGFibGVcIikubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodFVuZGVyRXZlbnQoZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0SGlnaGxpZ2h0ZWQoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAvLyB0cmFwIGFsbCBtb3VzZSBldmVudHMgZnJvbSBsZWF2aW5nIHRoZSBkcm9wZG93bi4gc29tZXRpbWVzIHRoZXJlIG1heSBiZSBhIG1vZGFsIHRoYXQgaXMgbGlzdGVuaW5nXG4gICAgICAgICAgICAvLyBmb3IgbW91c2UgZXZlbnRzIG91dHNpZGUgb2YgaXRzZWxmIHNvIGl0IGNhbiBjbG9zZSBpdHNlbGYuIHNpbmNlIHRoZSBkcm9wZG93biBpcyBub3cgb3V0c2lkZSB0aGUgc2VsZWN0MidzXG4gICAgICAgICAgICAvLyBkb20gaXQgd2lsbCB0cmlnZ2VyIHRoZSBwb3B1cCBjbG9zZSwgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudFxuICAgICAgICAgICAgLy8gZm9jdXNpbiBjYW4gY2F1c2UgZm9jdXMgd2FycyBiZXR3ZWVuIG1vZGFscyBhbmQgc2VsZWN0MiBzaW5jZSB0aGUgZHJvcGRvd24gaXMgb3V0c2lkZSB0aGUgbW9kYWwuXG4gICAgICAgICAgICB0aGlzLmRyb3Bkb3duLm9uKFwiY2xpY2sgbW91c2V1cCBtb3VzZWRvd24gdG91Y2hzdGFydCB0b3VjaGVuZCBmb2N1c2luXCIsIGZ1bmN0aW9uIChlKSB7IGUuc3RvcFByb3BhZ2F0aW9uKCk7IH0pO1xuXG4gICAgICAgICAgICB0aGlzLm5leHRTZWFyY2hUZXJtID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICBpZiAoJC5pc0Z1bmN0aW9uKHRoaXMub3B0cy5pbml0U2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIC8vIGluaXRpYWxpemUgc2VsZWN0aW9uIGJhc2VkIG9uIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBzb3VyY2UgZWxlbWVudFxuICAgICAgICAgICAgICAgIHRoaXMuaW5pdFNlbGVjdGlvbigpO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHVzZXIgaGFzIHByb3ZpZGVkIGEgZnVuY3Rpb24gdGhhdCBjYW4gc2V0IHNlbGVjdGlvbiBiYXNlZCBvbiB0aGUgdmFsdWUgb2YgdGhlIHNvdXJjZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gd2UgbW9uaXRvciB0aGUgY2hhbmdlIGV2ZW50IG9uIHRoZSBlbGVtZW50IGFuZCB0cmlnZ2VyIGl0LCBhbGxvd2luZyBmb3IgdHdvIHdheSBzeW5jaHJvbml6YXRpb25cbiAgICAgICAgICAgICAgICB0aGlzLm1vbml0b3JTb3VyY2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdHMubWF4aW11bUlucHV0TGVuZ3RoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWFyY2guYXR0cihcIm1heGxlbmd0aFwiLCBvcHRzLm1heGltdW1JbnB1dExlbmd0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkaXNhYmxlZCA9IG9wdHMuZWxlbWVudC5wcm9wKFwiZGlzYWJsZWRcIik7XG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQgPT09IHVuZGVmaW5lZCkgZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlKCFkaXNhYmxlZCk7XG5cbiAgICAgICAgICAgIHZhciByZWFkb25seSA9IG9wdHMuZWxlbWVudC5wcm9wKFwicmVhZG9ubHlcIik7XG4gICAgICAgICAgICBpZiAocmVhZG9ubHkgPT09IHVuZGVmaW5lZCkgcmVhZG9ubHkgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucmVhZG9ubHkocmVhZG9ubHkpO1xuXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgc2l6ZSBvZiBzY3JvbGxiYXJcbiAgICAgICAgICAgIHNjcm9sbEJhckRpbWVuc2lvbnMgPSBzY3JvbGxCYXJEaW1lbnNpb25zIHx8IG1lYXN1cmVTY3JvbGxiYXIoKTtcblxuICAgICAgICAgICAgdGhpcy5hdXRvZm9jdXMgPSBvcHRzLmVsZW1lbnQucHJvcChcImF1dG9mb2N1c1wiKTtcbiAgICAgICAgICAgIG9wdHMuZWxlbWVudC5wcm9wKFwiYXV0b2ZvY3VzXCIsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9mb2N1cykgdGhpcy5mb2N1cygpO1xuXG4gICAgICAgICAgICB0aGlzLnNlYXJjaC5hdHRyKFwicGxhY2Vob2xkZXJcIiwgb3B0cy5zZWFyY2hJbnB1dFBsYWNlaG9sZGVyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBhYnN0cmFjdFxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudD10aGlzLm9wdHMuZWxlbWVudCwgc2VsZWN0MiA9IGVsZW1lbnQuZGF0YShcInNlbGVjdDJcIiksIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG5cbiAgICAgICAgICAgIGlmIChlbGVtZW50Lmxlbmd0aCAmJiBlbGVtZW50WzBdLmRldGFjaEV2ZW50ICYmIHNlbGYuX3N5bmMpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fc3luYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXRhY2hFdmVudChcIm9ucHJvcGVydHljaGFuZ2VcIiwgc2VsZi5fc3luYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BlcnR5T2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnR5T2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydHlPYnNlcnZlciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zeW5jID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdDIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdDIuY29udGFpbmVyLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHNlbGVjdDIubGl2ZVJlZ2lvbi5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBzZWxlY3QyLmRyb3Bkb3duLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgLnNob3coKVxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlRGF0YShcInNlbGVjdDJcIilcbiAgICAgICAgICAgICAgICAgICAgLm9mZihcIi5zZWxlY3QyXCIpXG4gICAgICAgICAgICAgICAgICAgIC5wcm9wKFwiYXV0b2ZvY3VzXCIsIHRoaXMuYXV0b2ZvY3VzIHx8IGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lbGVtZW50VGFiSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hdHRyKHt0YWJpbmRleDogdGhpcy5lbGVtZW50VGFiSW5kZXh9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHIoXCJ0YWJpbmRleFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zaG93KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNsZWFudXBKUXVlcnlFbGVtZW50cy5jYWxsKHRoaXMsXG4gICAgICAgICAgICAgICAgXCJjb250YWluZXJcIixcbiAgICAgICAgICAgICAgICBcImxpdmVSZWdpb25cIixcbiAgICAgICAgICAgICAgICBcImRyb3Bkb3duXCIsXG4gICAgICAgICAgICAgICAgXCJyZXN1bHRzXCIsXG4gICAgICAgICAgICAgICAgXCJzZWFyY2hcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBhYnN0cmFjdFxuICAgICAgICBvcHRpb25Ub0RhdGE6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmlzKFwib3B0aW9uXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ZWxlbWVudC5wcm9wKFwidmFsdWVcIiksXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6ZWxlbWVudC50ZXh0KCksXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQuZ2V0KCksXG4gICAgICAgICAgICAgICAgICAgIGNzczogZWxlbWVudC5hdHRyKFwiY2xhc3NcIiksXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiBlbGVtZW50LnByb3AoXCJkaXNhYmxlZFwiKSxcbiAgICAgICAgICAgICAgICAgICAgbG9ja2VkOiBlcXVhbChlbGVtZW50LmF0dHIoXCJsb2NrZWRcIiksIFwibG9ja2VkXCIpIHx8IGVxdWFsKGVsZW1lbnQuZGF0YShcImxvY2tlZFwiKSwgdHJ1ZSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LmlzKFwib3B0Z3JvdXBcIikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OmVsZW1lbnQuYXR0cihcImxhYmVsXCIpLFxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjpbXSxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudC5nZXQoKSxcbiAgICAgICAgICAgICAgICAgICAgY3NzOiBlbGVtZW50LmF0dHIoXCJjbGFzc1wiKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gYWJzdHJhY3RcbiAgICAgICAgcHJlcGFyZU9wdHM6IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCwgc2VsZWN0LCBpZEtleSwgYWpheFVybCwgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIGVsZW1lbnQgPSBvcHRzLmVsZW1lbnQ7XG5cbiAgICAgICAgICAgIGlmIChlbGVtZW50LmdldCgwKS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwic2VsZWN0XCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdCA9IHNlbGVjdCA9IG9wdHMuZWxlbWVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlbGVjdCkge1xuICAgICAgICAgICAgICAgIC8vIHRoZXNlIG9wdGlvbnMgYXJlIG5vdCBhbGxvd2VkIHdoZW4gYXR0YWNoZWQgdG8gYSBzZWxlY3QgYmVjYXVzZSB0aGV5IGFyZSBwaWNrZWQgdXAgb2ZmIHRoZSBlbGVtZW50IGl0c2VsZlxuICAgICAgICAgICAgICAgICQuZWFjaChbXCJpZFwiLCBcIm11bHRpcGxlXCIsIFwiYWpheFwiLCBcInF1ZXJ5XCIsIFwiY3JlYXRlU2VhcmNoQ2hvaWNlXCIsIFwiaW5pdFNlbGVjdGlvblwiLCBcImRhdGFcIiwgXCJ0YWdzXCJdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzIGluIG9wdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9wdGlvbiAnXCIgKyB0aGlzICsgXCInIGlzIG5vdCBhbGxvd2VkIGZvciBTZWxlY3QyIHdoZW4gYXR0YWNoZWQgdG8gYSA8c2VsZWN0PiBlbGVtZW50LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvcHRzID0gJC5leHRlbmQoe30sIHtcbiAgICAgICAgICAgICAgICBwb3B1bGF0ZVJlc3VsdHM6IGZ1bmN0aW9uKGNvbnRhaW5lciwgcmVzdWx0cywgcXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvcHVsYXRlLCBpZD10aGlzLm9wdHMuaWQsIGxpdmVSZWdpb249dGhpcy5saXZlUmVnaW9uO1xuXG4gICAgICAgICAgICAgICAgICAgIHBvcHVsYXRlPWZ1bmN0aW9uKHJlc3VsdHMsIGNvbnRhaW5lciwgZGVwdGgpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGksIGwsIHJlc3VsdCwgc2VsZWN0YWJsZSwgZGlzYWJsZWQsIGNvbXBvdW5kLCBub2RlLCBsYWJlbCwgaW5uZXJDb250YWluZXIsIGZvcm1hdHRlZDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IG9wdHMuc29ydFJlc3VsdHMocmVzdWx0cywgY29udGFpbmVyLCBxdWVyeSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbGxlY3QgdGhlIGNyZWF0ZWQgbm9kZXMgZm9yIGJ1bGsgYXBwZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSByZXN1bHRzLmxlbmd0aDsgaSA8IGw7IGkgPSBpICsgMSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0PXJlc3VsdHNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZCA9IChyZXN1bHQuZGlzYWJsZWQgPT09IHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGFibGUgPSAoIWRpc2FibGVkKSAmJiAoaWQocmVzdWx0KSAhPT0gdW5kZWZpbmVkKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvdW5kPXJlc3VsdC5jaGlsZHJlbiAmJiByZXN1bHQuY2hpbGRyZW4ubGVuZ3RoID4gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU9JChcIjxsaT48L2xpPlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmFkZENsYXNzKFwic2VsZWN0Mi1yZXN1bHRzLWRlcHQtXCIrZGVwdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYWRkQ2xhc3MoXCJzZWxlY3QyLXJlc3VsdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmFkZENsYXNzKHNlbGVjdGFibGUgPyBcInNlbGVjdDItcmVzdWx0LXNlbGVjdGFibGVcIiA6IFwic2VsZWN0Mi1yZXN1bHQtdW5zZWxlY3RhYmxlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXNhYmxlZCkgeyBub2RlLmFkZENsYXNzKFwic2VsZWN0Mi1kaXNhYmxlZFwiKTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wb3VuZCkgeyBub2RlLmFkZENsYXNzKFwic2VsZWN0Mi1yZXN1bHQtd2l0aC1jaGlsZHJlblwiKTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYWRkQ2xhc3Moc2VsZi5vcHRzLmZvcm1hdFJlc3VsdENzc0NsYXNzKHJlc3VsdCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYXR0cihcInJvbGVcIiwgXCJwcmVzZW50YXRpb25cIik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD0kKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsLmFkZENsYXNzKFwic2VsZWN0Mi1yZXN1bHQtbGFiZWxcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWwuYXR0cihcImlkXCIsIFwic2VsZWN0Mi1yZXN1bHQtbGFiZWwtXCIgKyBuZXh0VWlkKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsLmF0dHIoXCJyb2xlXCIsIFwib3B0aW9uXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkPW9wdHMuZm9ybWF0UmVzdWx0KHJlc3VsdCwgbGFiZWwsIHF1ZXJ5LCBzZWxmLm9wdHMuZXNjYXBlTWFya3VwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9ybWF0dGVkIT09dW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsLmh0bWwoZm9ybWF0dGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hcHBlbmQobGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvdW5kKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJDb250YWluZXI9JChcIjx1bD48L3VsPlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJDb250YWluZXIuYWRkQ2xhc3MoXCJzZWxlY3QyLXJlc3VsdC1zdWJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcHVsYXRlKHJlc3VsdC5jaGlsZHJlbiwgaW5uZXJDb250YWluZXIsIGRlcHRoKzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmFwcGVuZChpbm5lckNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5kYXRhKFwic2VsZWN0Mi1kYXRhXCIsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChub2RlWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnVsayBhcHBlbmQgdGhlIGNyZWF0ZWQgbm9kZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmQobm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGl2ZVJlZ2lvbi50ZXh0KG9wdHMuZm9ybWF0TWF0Y2hlcyhyZXN1bHRzLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHBvcHVsYXRlKHJlc3VsdHMsIGNvbnRhaW5lciwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgJC5mbi5zZWxlY3QyLmRlZmF1bHRzLCBvcHRzKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZihvcHRzLmlkKSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaWRLZXkgPSBvcHRzLmlkO1xuICAgICAgICAgICAgICAgIG9wdHMuaWQgPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZVtpZEtleV07IH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgkLmlzQXJyYXkob3B0cy5lbGVtZW50LmRhdGEoXCJzZWxlY3QyVGFnc1wiKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoXCJ0YWdzXCIgaW4gb3B0cykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcInRhZ3Mgc3BlY2lmaWVkIGFzIGJvdGggYW4gYXR0cmlidXRlICdkYXRhLXNlbGVjdDItdGFncycgYW5kIGluIG9wdGlvbnMgb2YgU2VsZWN0MiBcIiArIG9wdHMuZWxlbWVudC5hdHRyKFwiaWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdHMudGFncz1vcHRzLmVsZW1lbnQuZGF0YShcInNlbGVjdDJUYWdzXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgb3B0cy5xdWVyeSA9IHRoaXMuYmluZChmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7IHJlc3VsdHM6IFtdLCBtb3JlOiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVybSA9IHF1ZXJ5LnRlcm0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiwgcGxhY2Vob2xkZXJPcHRpb24sIHByb2Nlc3M7XG5cbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcz1mdW5jdGlvbihlbGVtZW50LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5pcyhcIm9wdGlvblwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxdWVyeS5tYXRjaGVyKHRlcm0sIGVsZW1lbnQudGV4dCgpLCBlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLnB1c2goc2VsZi5vcHRpb25Ub0RhdGEoZWxlbWVudCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5pcyhcIm9wdGdyb3VwXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXA9c2VsZi5vcHRpb25Ub0RhdGEoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jaGlsZHJlbigpLmVhY2gyKGZ1bmN0aW9uKGksIGVsbSkgeyBwcm9jZXNzKGVsbSwgZ3JvdXAuY2hpbGRyZW4pOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXAuY2hpbGRyZW4ubGVuZ3RoPjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbi5wdXNoKGdyb3VwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW49ZWxlbWVudC5jaGlsZHJlbigpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSB0aGUgcGxhY2Vob2xkZXIgb3B0aW9uIGlmIHRoZXJlIGlzIG9uZVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRQbGFjZWhvbGRlcigpICE9PSB1bmRlZmluZWQgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJPcHRpb24gPSB0aGlzLmdldFBsYWNlaG9sZGVyT3B0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGxhY2Vob2xkZXJPcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbj1jaGlsZHJlbi5ub3QocGxhY2Vob2xkZXJPcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4uZWFjaDIoZnVuY3Rpb24oaSwgZWxtKSB7IHByb2Nlc3MoZWxtLCBkYXRhLnJlc3VsdHMpOyB9KTtcblxuICAgICAgICAgICAgICAgICAgICBxdWVyeS5jYWxsYmFjayhkYXRhKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIG5lZWRlZCBiZWNhdXNlIGluc2lkZSB2YWwoKSB3ZSBjb25zdHJ1Y3QgY2hvaWNlcyBmcm9tIG9wdGlvbnMgYW5kIHRoZWlyIGlkIGlzIGhhcmRjb2RlZFxuICAgICAgICAgICAgICAgIG9wdHMuaWQ9ZnVuY3Rpb24oZSkgeyByZXR1cm4gZS5pZDsgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoXCJxdWVyeVwiIGluIG9wdHMpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiYWpheFwiIGluIG9wdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFqYXhVcmwgPSBvcHRzLmVsZW1lbnQuZGF0YShcImFqYXgtdXJsXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFqYXhVcmwgJiYgYWpheFVybC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cy5hamF4LnVybCA9IGFqYXhVcmw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRzLnF1ZXJ5ID0gYWpheC5jYWxsKG9wdHMuZWxlbWVudCwgb3B0cy5hamF4KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcImRhdGFcIiBpbiBvcHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRzLnF1ZXJ5ID0gbG9jYWwob3B0cy5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcInRhZ3NcIiBpbiBvcHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRzLnF1ZXJ5ID0gdGFncyhvcHRzLnRhZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMuY3JlYXRlU2VhcmNoQ2hvaWNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRzLmNyZWF0ZVNlYXJjaENob2ljZSA9IGZ1bmN0aW9uICh0ZXJtKSB7IHJldHVybiB7aWQ6ICQudHJpbSh0ZXJtKSwgdGV4dDogJC50cmltKHRlcm0pfTsgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLmluaXRTZWxlY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMuaW5pdFNlbGVjdGlvbiA9IGZ1bmN0aW9uIChlbGVtZW50LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHNwbGl0VmFsKGVsZW1lbnQudmFsKCksIG9wdHMuc2VwYXJhdG9yLCBvcHRzLnRyYW5zZm9ybVZhbCkpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IHsgaWQ6IHRoaXMsIHRleHQ6IHRoaXMgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdzID0gb3B0cy50YWdzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCQuaXNGdW5jdGlvbih0YWdzKSkgdGFncz10YWdzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHRhZ3MpLmVhY2goZnVuY3Rpb24oKSB7IGlmIChlcXVhbCh0aGlzLmlkLCBvYmouaWQpKSB7IG9iaiA9IHRoaXM7IHJldHVybiBmYWxzZTsgfSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucHVzaChvYmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZihvcHRzLnF1ZXJ5KSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJxdWVyeSBmdW5jdGlvbiBub3QgZGVmaW5lZCBmb3IgU2VsZWN0MiBcIiArIG9wdHMuZWxlbWVudC5hdHRyKFwiaWRcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHRzLmNyZWF0ZVNlYXJjaENob2ljZVBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgICAgICAgICAgIG9wdHMuY3JlYXRlU2VhcmNoQ2hvaWNlUG9zaXRpb24gPSBmdW5jdGlvbihsaXN0LCBpdGVtKSB7IGxpc3QudW5zaGlmdChpdGVtKTsgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdHMuY3JlYXRlU2VhcmNoQ2hvaWNlUG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5jcmVhdGVTZWFyY2hDaG9pY2VQb3NpdGlvbiA9IGZ1bmN0aW9uKGxpc3QsIGl0ZW0pIHsgbGlzdC5wdXNoKGl0ZW0pOyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mKG9wdHMuY3JlYXRlU2VhcmNoQ2hvaWNlUG9zaXRpb24pICE9PSBcImZ1bmN0aW9uXCIpICB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJpbnZhbGlkIGNyZWF0ZVNlYXJjaENob2ljZVBvc2l0aW9uIG9wdGlvbiBtdXN0IGJlICd0b3AnLCAnYm90dG9tJyBvciBhIGN1c3RvbSBmdW5jdGlvblwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3B0cztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTW9uaXRvciB0aGUgb3JpZ2luYWwgZWxlbWVudCBmb3IgY2hhbmdlcyBhbmQgdXBkYXRlIHNlbGVjdDIgYWNjb3JkaW5nbHlcbiAgICAgICAgICovXG4gICAgICAgIC8vIGFic3RyYWN0XG4gICAgICAgIG1vbml0b3JTb3VyY2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXMub3B0cy5lbGVtZW50LCBvYnNlcnZlciwgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIGVsLm9uKFwiY2hhbmdlLnNlbGVjdDJcIiwgdGhpcy5iaW5kKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5lbGVtZW50LmRhdGEoXCJzZWxlY3QyLWNoYW5nZS10cmlnZ2VyZWRcIikgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICB0aGlzLl9zeW5jID0gdGhpcy5iaW5kKGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgIC8vIHN5bmMgZW5hYmxlZCBzdGF0ZVxuICAgICAgICAgICAgICAgIHZhciBkaXNhYmxlZCA9IGVsLnByb3AoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlzYWJsZWQgPT09IHVuZGVmaW5lZCkgZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZSghZGlzYWJsZWQpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlYWRvbmx5ID0gZWwucHJvcChcInJlYWRvbmx5XCIpO1xuICAgICAgICAgICAgICAgIGlmIChyZWFkb25seSA9PT0gdW5kZWZpbmVkKSByZWFkb25seSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVhZG9ubHkocmVhZG9ubHkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHN5bmNDc3NDbGFzc2VzKHRoaXMuY29udGFpbmVyLCB0aGlzLm9wdHMuZWxlbWVudCwgdGhpcy5vcHRzLmFkYXB0Q29udGFpbmVyQ3NzQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRDbGFzcyhldmFsdWF0ZSh0aGlzLm9wdHMuY29udGFpbmVyQ3NzQ2xhc3MsIHRoaXMub3B0cy5lbGVtZW50KSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZHJvcGRvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgc3luY0Nzc0NsYXNzZXModGhpcy5kcm9wZG93biwgdGhpcy5vcHRzLmVsZW1lbnQsIHRoaXMub3B0cy5hZGFwdERyb3Bkb3duQ3NzQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3Bkb3duLmFkZENsYXNzKGV2YWx1YXRlKHRoaXMub3B0cy5kcm9wZG93bkNzc0NsYXNzLCB0aGlzLm9wdHMuZWxlbWVudCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIElFOC0xMCAoSUU5LzEwIHdvbid0IGZpcmUgcHJvcGVydHlDaGFuZ2UgdmlhIGF0dGFjaEV2ZW50TGlzdGVuZXIpXG4gICAgICAgICAgICBpZiAoZWwubGVuZ3RoICYmIGVsWzBdLmF0dGFjaEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZWwuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hFdmVudChcIm9ucHJvcGVydHljaGFuZ2VcIiwgc2VsZi5fc3luYyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNhZmFyaSwgY2hyb21lLCBmaXJlZm94LCBJRTExXG4gICAgICAgICAgICBvYnNlcnZlciA9IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyIHx8IHdpbmRvdy5XZWJLaXRNdXRhdGlvbk9ic2VydmVyfHwgd2luZG93Lk1vek11dGF0aW9uT2JzZXJ2ZXI7XG4gICAgICAgICAgICBpZiAob2JzZXJ2ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3BlcnR5T2JzZXJ2ZXIpIHsgZGVsZXRlIHRoaXMucHJvcGVydHlPYnNlcnZlcjsgdGhpcy5wcm9wZXJ0eU9ic2VydmVyID0gbnVsbDsgfVxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydHlPYnNlcnZlciA9IG5ldyBvYnNlcnZlcihmdW5jdGlvbiAobXV0YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICQuZWFjaChtdXRhdGlvbnMsIHNlbGYuX3N5bmMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydHlPYnNlcnZlci5vYnNlcnZlKGVsLmdldCgwKSwgeyBhdHRyaWJ1dGVzOnRydWUsIHN1YnRyZWU6ZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gYWJzdHJhY3RcbiAgICAgICAgdHJpZ2dlclNlbGVjdDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGV2dCA9ICQuRXZlbnQoXCJzZWxlY3QyLXNlbGVjdGluZ1wiLCB7IHZhbDogdGhpcy5pZChkYXRhKSwgb2JqZWN0OiBkYXRhLCBjaG9pY2U6IGRhdGEgfSk7XG4gICAgICAgICAgICB0aGlzLm9wdHMuZWxlbWVudC50cmlnZ2VyKGV2dCk7XG4gICAgICAgICAgICByZXR1cm4gIWV2dC5pc0RlZmF1bHRQcmV2ZW50ZWQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVHJpZ2dlcnMgdGhlIGNoYW5nZSBldmVudCBvbiB0aGUgc291cmNlIGVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIC8vIGFic3RyYWN0XG4gICAgICAgIHRyaWdnZXJDaGFuZ2U6IGZ1bmN0aW9uIChkZXRhaWxzKSB7XG5cbiAgICAgICAgICAgIGRldGFpbHMgPSBkZXRhaWxzIHx8IHt9O1xuICAgICAgICAgICAgZGV0YWlscz0gJC5leHRlbmQoe30sIGRldGFpbHMsIHsgdHlwZTogXCJjaGFuZ2VcIiwgdmFsOiB0aGlzLnZhbCgpIH0pO1xuICAgICAgICAgICAgLy8gcHJldmVudHMgcmVjdXJzaXZlIHRyaWdnZXJpbmdcbiAgICAgICAgICAgIHRoaXMub3B0cy5lbGVtZW50LmRhdGEoXCJzZWxlY3QyLWNoYW5nZS10cmlnZ2VyZWRcIiwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLm9wdHMuZWxlbWVudC50cmlnZ2VyKGRldGFpbHMpO1xuICAgICAgICAgICAgdGhpcy5vcHRzLmVsZW1lbnQuZGF0YShcInNlbGVjdDItY2hhbmdlLXRyaWdnZXJlZFwiLCBmYWxzZSk7XG5cbiAgICAgICAgICAgIC8vIHNvbWUgdmFsaWRhdGlvbiBmcmFtZXdvcmtzIGlnbm9yZSB0aGUgY2hhbmdlIGV2ZW50IGFuZCBsaXN0ZW4gaW5zdGVhZCB0byBrZXl1cCwgY2xpY2sgZm9yIHNlbGVjdHNcbiAgICAgICAgICAgIC8vIHNvIGhlcmUgd2UgdHJpZ2dlciB0aGUgY2xpY2sgZXZlbnQgbWFudWFsbHlcbiAgICAgICAgICAgIHRoaXMub3B0cy5lbGVtZW50LmNsaWNrKCk7XG5cbiAgICAgICAgICAgIC8vIFZhbGlkYXRpb25FbmdpbmUgaWdub3JlcyB0aGUgY2hhbmdlIGV2ZW50IGFuZCBsaXN0ZW5zIGluc3RlYWQgdG8gYmx1clxuICAgICAgICAgICAgLy8gc28gaGVyZSB3ZSB0cmlnZ2VyIHRoZSBibHVyIGV2ZW50IG1hbnVhbGx5IGlmIHNvIGRlc2lyZWRcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuYmx1ck9uQ2hhbmdlKVxuICAgICAgICAgICAgICAgIHRoaXMub3B0cy5lbGVtZW50LmJsdXIoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvL2Fic3RyYWN0XG4gICAgICAgIGlzSW50ZXJmYWNlRW5hYmxlZDogZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmFibGVkSW50ZXJmYWNlID09PSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGFic3RyYWN0XG4gICAgICAgIGVuYWJsZUludGVyZmFjZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZW5hYmxlZCA9IHRoaXMuX2VuYWJsZWQgJiYgIXRoaXMuX3JlYWRvbmx5LFxuICAgICAgICAgICAgICAgIGRpc2FibGVkID0gIWVuYWJsZWQ7XG5cbiAgICAgICAgICAgIGlmIChlbmFibGVkID09PSB0aGlzLmVuYWJsZWRJbnRlcmZhY2UpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIudG9nZ2xlQ2xhc3MoXCJzZWxlY3QyLWNvbnRhaW5lci1kaXNhYmxlZFwiLCBkaXNhYmxlZCk7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZWRJbnRlcmZhY2UgPSBlbmFibGVkO1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBhYnN0cmFjdFxuICAgICAgICBlbmFibGU6IGZ1bmN0aW9uKGVuYWJsZWQpIHtcbiAgICAgICAgICAgIGlmIChlbmFibGVkID09PSB1bmRlZmluZWQpIGVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VuYWJsZWQgPT09IGVuYWJsZWQpIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuX2VuYWJsZWQgPSBlbmFibGVkO1xuXG4gICAgICAgICAgICB0aGlzLm9wdHMuZWxlbWVudC5wcm9wKFwiZGlzYWJsZWRcIiwgIWVuYWJsZWQpO1xuICAgICAgICAgICAgdGhpcy5lbmFibGVJbnRlcmZhY2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBhYnN0cmFjdFxuICAgICAgICBkaXNhYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlKGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBhYnN0cmFjdFxuICAgICAgICByZWFkb25seTogZnVuY3Rpb24oZW5hYmxlZCkge1xuICAgICAgICAgICAgaWYgKGVuYWJsZWQgPT09IHVuZGVmaW5lZCkgZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JlYWRvbmx5ID09PSBlbmFibGVkKSByZXR1cm47XG4gICAgICAgICAgICB0aGlzLl9yZWFkb25seSA9IGVuYWJsZWQ7XG5cbiAgICAgICAgICAgIHRoaXMub3B0cy5lbGVtZW50LnByb3AoXCJyZWFkb25seVwiLCBlbmFibGVkKTtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlSW50ZXJmYWNlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gYWJzdHJhY3RcbiAgICAgICAgb3BlbmVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuY29udGFpbmVyKSA/IHRoaXMuY29udGFpbmVyLmhhc0NsYXNzKFwic2VsZWN0Mi1kcm9wZG93bi1vcGVuXCIpIDogZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gYWJzdHJhY3RcbiAgICAgICAgcG9zaXRpb25Ecm9wZG93bjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgJGRyb3Bkb3duID0gdGhpcy5kcm9wZG93bixcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcixcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBjb250YWluZXIub2Zmc2V0KCksXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gY29udGFpbmVyLm91dGVySGVpZ2h0KGZhbHNlKSxcbiAgICAgICAgICAgICAgICB3aWR0aCA9IGNvbnRhaW5lci5vdXRlcldpZHRoKGZhbHNlKSxcbiAgICAgICAgICAgICAgICBkcm9wSGVpZ2h0ID0gJGRyb3Bkb3duLm91dGVySGVpZ2h0KGZhbHNlKSxcbiAgICAgICAgICAgICAgICAkd2luZG93ID0gJCh3aW5kb3cpLFxuICAgICAgICAgICAgICAgIHdpbmRvd1dpZHRoID0gJHdpbmRvdy53aWR0aCgpLFxuICAgICAgICAgICAgICAgIHdpbmRvd0hlaWdodCA9ICR3aW5kb3cuaGVpZ2h0KCksXG4gICAgICAgICAgICAgICAgdmlld1BvcnRSaWdodCA9ICR3aW5kb3cuc2Nyb2xsTGVmdCgpICsgd2luZG93V2lkdGgsXG4gICAgICAgICAgICAgICAgdmlld3BvcnRCb3R0b20gPSAkd2luZG93LnNjcm9sbFRvcCgpICsgd2luZG93SGVpZ2h0LFxuICAgICAgICAgICAgICAgIGRyb3BUb3AgPSBvZmZzZXQudG9wICsgaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGRyb3BMZWZ0ID0gb2Zmc2V0LmxlZnQsXG4gICAgICAgICAgICAgICAgZW5vdWdoUm9vbUJlbG93ID0gZHJvcFRvcCArIGRyb3BIZWlnaHQgPD0gdmlld3BvcnRCb3R0b20sXG4gICAgICAgICAgICAgICAgZW5vdWdoUm9vbUFib3ZlID0gKG9mZnNldC50b3AgLSBkcm9wSGVpZ2h0KSA+PSAkd2luZG93LnNjcm9sbFRvcCgpLFxuICAgICAgICAgICAgICAgIGRyb3BXaWR0aCA9ICRkcm9wZG93bi5vdXRlcldpZHRoKGZhbHNlKSxcbiAgICAgICAgICAgICAgICBlbm91Z2hSb29tT25SaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHJvcExlZnQgKyBkcm9wV2lkdGggPD0gdmlld1BvcnRSaWdodDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVub3VnaFJvb21PbkxlZnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mZnNldC5sZWZ0ICsgdmlld1BvcnRSaWdodCArIGNvbnRhaW5lci5vdXRlcldpZHRoKGZhbHNlKSAgPiBkcm9wV2lkdGg7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhYm92ZU5vdyA9ICRkcm9wZG93bi5oYXNDbGFzcyhcInNlbGVjdDItZHJvcC1hYm92ZVwiKSxcbiAgICAgICAgICAgICAgICBib2R5T2Zmc2V0LFxuICAgICAgICAgICAgICAgIGFib3ZlLFxuICAgICAgICAgICAgICAgIGNoYW5nZURpcmVjdGlvbixcbiAgICAgICAgICAgICAgICBjc3MsXG4gICAgICAgICAgICAgICAgcmVzdWx0c0xpc3ROb2RlO1xuXG4gICAgICAgICAgICAvLyBhbHdheXMgcHJlZmVyIHRoZSBjdXJyZW50IGFib3ZlL2JlbG93IGFsaWdubWVudCwgdW5sZXNzIHRoZXJlIGlzIG5vdCBlbm91Z2ggcm9vbVxuICAgICAgICAgICAgaWYgKGFib3ZlTm93KSB7XG4gICAgICAgICAgICAgICAgYWJvdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICghZW5vdWdoUm9vbUFib3ZlICYmIGVub3VnaFJvb21CZWxvdykge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VEaXJlY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBhYm92ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWJvdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoIWVub3VnaFJvb21CZWxvdyAmJiBlbm91Z2hSb29tQWJvdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRGlyZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYWJvdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9pZiB3ZSBhcmUgY2hhbmdpbmcgZGlyZWN0aW9uIHdlIG5lZWQgdG8gZ2V0IHBvc2l0aW9ucyB3aGVuIGRyb3Bkb3duIGlzIGhpZGRlbjtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAkZHJvcGRvd24uaGlkZSgpO1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuY29udGFpbmVyLm9mZnNldCgpO1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuY29udGFpbmVyLm91dGVySGVpZ2h0KGZhbHNlKTtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHRoaXMuY29udGFpbmVyLm91dGVyV2lkdGgoZmFsc2UpO1xuICAgICAgICAgICAgICAgIGRyb3BIZWlnaHQgPSAkZHJvcGRvd24ub3V0ZXJIZWlnaHQoZmFsc2UpO1xuICAgICAgICAgICAgICAgIHZpZXdQb3J0UmlnaHQgPSAkd2luZG93LnNjcm9sbExlZnQoKSArIHdpbmRvd1dpZHRoO1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0Qm90dG9tID0gJHdpbmRvdy5zY3JvbGxUb3AoKSArIHdpbmRvd0hlaWdodDtcbiAgICAgICAgICAgICAgICBkcm9wVG9wID0gb2Zmc2V0LnRvcCArIGhlaWdodDtcbiAgICAgICAgICAgICAgICBkcm9wTGVmdCA9IG9mZnNldC5sZWZ0O1xuICAgICAgICAgICAgICAgIGRyb3BXaWR0aCA9ICRkcm9wZG93bi5vdXRlcldpZHRoKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAkZHJvcGRvd24uc2hvdygpO1xuXG4gICAgICAgICAgICAgICAgLy8gZml4IHNvIHRoZSBjdXJzb3IgZG9lcyBub3QgbW92ZSB0byB0aGUgbGVmdCB3aXRoaW4gdGhlIHNlYXJjaC10ZXh0Ym94IGluIElFXG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c1NlYXJjaCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLmRyb3Bkb3duQXV0b1dpZHRoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0c0xpc3ROb2RlID0gJCgnLnNlbGVjdDItcmVzdWx0cycsICRkcm9wZG93bilbMF07XG4gICAgICAgICAgICAgICAgJGRyb3Bkb3duLmFkZENsYXNzKCdzZWxlY3QyLWRyb3AtYXV0by13aWR0aCcpO1xuICAgICAgICAgICAgICAgICRkcm9wZG93bi5jc3MoJ3dpZHRoJywgJycpO1xuICAgICAgICAgICAgICAgIC8vIEFkZCBzY3JvbGxiYXIgd2lkdGggdG8gZHJvcGRvd24gaWYgdmVydGljYWwgc2Nyb2xsYmFyIGlzIHByZXNlbnRcbiAgICAgICAgICAgICAgICBkcm9wV2lkdGggPSAkZHJvcGRvd24ub3V0ZXJXaWR0aChmYWxzZSkgKyAocmVzdWx0c0xpc3ROb2RlLnNjcm9sbEhlaWdodCA9PT0gcmVzdWx0c0xpc3ROb2RlLmNsaWVudEhlaWdodCA/IDAgOiBzY3JvbGxCYXJEaW1lbnNpb25zLndpZHRoKTtcbiAgICAgICAgICAgICAgICBkcm9wV2lkdGggPiB3aWR0aCA/IHdpZHRoID0gZHJvcFdpZHRoIDogZHJvcFdpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgZHJvcEhlaWdodCA9ICRkcm9wZG93bi5vdXRlckhlaWdodChmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDbGFzcygnc2VsZWN0Mi1kcm9wLWF1dG8td2lkdGgnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcImJlbG93LyBkcm9wdG9wOlwiLCBkcm9wVG9wLCBcImRyb3BIZWlnaHRcIiwgZHJvcEhlaWdodCwgXCJzdW1cIiwgKGRyb3BUb3ArZHJvcEhlaWdodCkrXCIgdmlld3BvcnQgYm90dG9tXCIsIHZpZXdwb3J0Qm90dG9tLCBcImVub3VnaD9cIiwgZW5vdWdoUm9vbUJlbG93KTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJhYm92ZS8gb2Zmc2V0LnRvcFwiLCBvZmZzZXQudG9wLCBcImRyb3BIZWlnaHRcIiwgZHJvcEhlaWdodCwgXCJ0b3BcIiwgKG9mZnNldC50b3AtZHJvcEhlaWdodCksIFwic2Nyb2xsVG9wXCIsIHRoaXMuYm9keS5zY3JvbGxUb3AoKSwgXCJlbm91Z2g/XCIsIGVub3VnaFJvb21BYm92ZSk7XG5cbiAgICAgICAgICAgIC8vIGZpeCBwb3NpdGlvbmluZyB3aGVuIGJvZHkgaGFzIGFuIG9mZnNldCBhbmQgaXMgbm90IHBvc2l0aW9uOiBzdGF0aWNcbiAgICAgICAgICAgIGlmICh0aGlzLmJvZHkuY3NzKCdwb3NpdGlvbicpICE9PSAnc3RhdGljJykge1xuICAgICAgICAgICAgICAgIGJvZHlPZmZzZXQgPSB0aGlzLmJvZHkub2Zmc2V0KCk7XG4gICAgICAgICAgICAgICAgZHJvcFRvcCAtPSBib2R5T2Zmc2V0LnRvcDtcbiAgICAgICAgICAgICAgICBkcm9wTGVmdCAtPSBib2R5T2Zmc2V0LmxlZnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZW5vdWdoUm9vbU9uUmlnaHQoKSAmJiBlbm91Z2hSb29tT25MZWZ0KCkpIHtcbiAgICAgICAgICAgICAgICBkcm9wTGVmdCA9IG9mZnNldC5sZWZ0ICsgdGhpcy5jb250YWluZXIub3V0ZXJXaWR0aChmYWxzZSkgLSBkcm9wV2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNzcyA9ICB7XG4gICAgICAgICAgICAgICAgbGVmdDogZHJvcExlZnQsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoYWJvdmUpIHtcbiAgICAgICAgICAgICAgICBjc3MudG9wID0gb2Zmc2V0LnRvcCAtIGRyb3BIZWlnaHQ7XG4gICAgICAgICAgICAgICAgY3NzLmJvdHRvbSA9ICdhdXRvJztcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRDbGFzcyhcInNlbGVjdDItZHJvcC1hYm92ZVwiKTtcbiAgICAgICAgICAgICAgICAkZHJvcGRvd24uYWRkQ2xhc3MoXCJzZWxlY3QyLWRyb3AtYWJvdmVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjc3MudG9wID0gZHJvcFRvcDtcbiAgICAgICAgICAgICAgICBjc3MuYm90dG9tID0gJ2F1dG8nO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUNsYXNzKFwic2VsZWN0Mi1kcm9wLWFib3ZlXCIpO1xuICAgICAgICAgICAgICAgICRkcm9wZG93bi5yZW1vdmVDbGFzcyhcInNlbGVjdDItZHJvcC1hYm92ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNzcyA9ICQuZXh0ZW5kKGNzcywgZXZhbHVhdGUodGhpcy5vcHRzLmRyb3Bkb3duQ3NzLCB0aGlzLm9wdHMuZWxlbWVudCkpO1xuXG4gICAgICAgICAgICAkZHJvcGRvd24uY3NzKGNzcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gYWJzdHJhY3RcbiAgICAgICAgc2hvdWxkT3BlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9wZW5lZCgpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9lbmFibGVkID09PSBmYWxzZSB8fCB0aGlzLl9yZWFkb25seSA9PT0gdHJ1ZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICBldmVudCA9ICQuRXZlbnQoXCJzZWxlY3QyLW9wZW5pbmdcIik7XG4gICAgICAgICAgICB0aGlzLm9wdHMuZWxlbWVudC50cmlnZ2VyKGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gYWJzdHJhY3RcbiAgICAgICAgY2xlYXJEcm9wZG93bkFsaWdubWVudFByZWZlcmVuY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gY2xlYXIgdGhlIGNsYXNzZXMgdXNlZCB0byBmaWd1cmUgb3V0IHRoZSBwcmVmZXJlbmNlIG9mIHdoZXJlIHRoZSBkcm9wZG93biBzaG91bGQgYmUgb3BlbmVkXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDbGFzcyhcInNlbGVjdDItZHJvcC1hYm92ZVwiKTtcbiAgICAgICAgICAgIHRoaXMuZHJvcGRvd24ucmVtb3ZlQ2xhc3MoXCJzZWxlY3QyLWRyb3AtYWJvdmVcIik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wZW5zIHRoZSBkcm9wZG93blxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCBkcm9wZG93biB3YXMgb3BlbmVkLiBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBmYWxzZSBpZiwgZm9yIGV4YW1wbGUsXG4gICAgICAgICAqIHRoZSBkcm9wZG93biBpcyBhbHJlYWR5IG9wZW4sIG9yIGlmIHRoZSAnb3BlbicgZXZlbnQgbGlzdGVuZXIgb24gdGhlIGVsZW1lbnQgY2FsbGVkIHByZXZlbnREZWZhdWx0KCkuXG4gICAgICAgICAqL1xuICAgICAgICAvLyBhYnN0cmFjdFxuICAgICAgICBvcGVuOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5zaG91bGRPcGVuKCkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgdGhpcy5vcGVuaW5nKCk7XG5cbiAgICAgICAgICAgIC8vIE9ubHkgYmluZCB0aGUgZG9jdW1lbnQgbW91c2Vtb3ZlIHdoZW4gdGhlIGRyb3Bkb3duIGlzIHZpc2libGVcbiAgICAgICAgICAgICRkb2N1bWVudC5vbihcIm1vdXNlbW92ZS5zZWxlY3QyRXZlbnRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBsYXN0TW91c2VQb3NpdGlvbi54ID0gZS5wYWdlWDtcbiAgICAgICAgICAgICAgICBsYXN0TW91c2VQb3NpdGlvbi55ID0gZS5wYWdlWTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGVyZm9ybXMgdGhlIG9wZW5pbmcgb2YgdGhlIGRyb3Bkb3duXG4gICAgICAgICAqL1xuICAgICAgICAvLyBhYnN0cmFjdFxuICAgICAgICBvcGVuaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjaWQgPSB0aGlzLmNvbnRhaW5lckV2ZW50TmFtZSxcbiAgICAgICAgICAgICAgICBzY3JvbGwgPSBcInNjcm9sbC5cIiArIGNpZCxcbiAgICAgICAgICAgICAgICByZXNpemUgPSBcInJlc2l6ZS5cIitjaWQsXG4gICAgICAgICAgICAgICAgb3JpZW50ID0gXCJvcmllbnRhdGlvbmNoYW5nZS5cIitjaWQsXG4gICAgICAgICAgICAgICAgbWFzaztcblxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2xhc3MoXCJzZWxlY3QyLWRyb3Bkb3duLW9wZW5cIikuYWRkQ2xhc3MoXCJzZWxlY3QyLWNvbnRhaW5lci1hY3RpdmVcIik7XG5cbiAgICAgICAgICAgIHRoaXMuY2xlYXJEcm9wZG93bkFsaWdubWVudFByZWZlcmVuY2UoKTtcblxuICAgICAgICAgICAgaWYodGhpcy5kcm9wZG93blswXSAhPT0gdGhpcy5ib2R5LmNoaWxkcmVuKCkubGFzdCgpWzBdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcm9wZG93bi5kZXRhY2goKS5hcHBlbmRUbyh0aGlzLmJvZHkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjcmVhdGUgdGhlIGRyb3Bkb3duIG1hc2sgaWYgZG9lc24ndCBhbHJlYWR5IGV4aXN0XG4gICAgICAgICAgICBtYXNrID0gJChcIiNzZWxlY3QyLWRyb3AtbWFza1wiKTtcbiAgICAgICAgICAgIGlmIChtYXNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG1hc2sgPSAkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgICAgICAgICAgICAgIG1hc2suYXR0cihcImlkXCIsXCJzZWxlY3QyLWRyb3AtbWFza1wiKS5hdHRyKFwiY2xhc3NcIixcInNlbGVjdDItZHJvcC1tYXNrXCIpO1xuICAgICAgICAgICAgICAgIG1hc2suaGlkZSgpO1xuICAgICAgICAgICAgICAgIG1hc2suYXBwZW5kVG8odGhpcy5ib2R5KTtcbiAgICAgICAgICAgICAgICBtYXNrLm9uKFwibW91c2Vkb3duIHRvdWNoc3RhcnQgY2xpY2tcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBJRSBmcm9tIGdlbmVyYXRpbmcgYSBjbGljayBldmVudCBvbiB0aGUgYm9keVxuICAgICAgICAgICAgICAgICAgICByZWluc2VydEVsZW1lbnQobWFzayk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRyb3Bkb3duID0gJChcIiNzZWxlY3QyLWRyb3BcIiksIHNlbGY7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkcm9wZG93bi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmPWRyb3Bkb3duLmRhdGEoXCJzZWxlY3QyXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYub3B0cy5zZWxlY3RPbkJsdXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdEhpZ2hsaWdodGVkKHtub0ZvY3VzOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGVuc3VyZSB0aGUgbWFzayBpcyBhbHdheXMgcmlnaHQgYmVmb3JlIHRoZSBkcm9wZG93blxuICAgICAgICAgICAgaWYgKHRoaXMuZHJvcGRvd24ucHJldigpWzBdICE9PSBtYXNrWzBdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcm9wZG93bi5iZWZvcmUobWFzayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG1vdmUgdGhlIGdsb2JhbCBpZCB0byB0aGUgY29ycmVjdCBkcm9wZG93blxuICAgICAgICAgICAgJChcIiNzZWxlY3QyLWRyb3BcIikucmVtb3ZlQXR0cihcImlkXCIpO1xuICAgICAgICAgICAgdGhpcy5kcm9wZG93bi5hdHRyKFwiaWRcIiwgXCJzZWxlY3QyLWRyb3BcIik7XG5cbiAgICAgICAgICAgIC8vIHNob3cgdGhlIGVsZW1lbnRzXG4gICAgICAgICAgICBtYXNrLnNob3coKTtcblxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbkRyb3Bkb3duKCk7XG4gICAgICAgICAgICB0aGlzLmRyb3Bkb3duLnNob3coKTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25Ecm9wZG93bigpO1xuXG4gICAgICAgICAgICB0aGlzLmRyb3Bkb3duLmFkZENsYXNzKFwic2VsZWN0Mi1kcm9wLWFjdGl2ZVwiKTtcblxuICAgICAgICAgICAgLy8gYXR0YWNoIGxpc3RlbmVycyB0byBldmVudHMgdGhhdCBjYW4gY2hhbmdlIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udGFpbmVyIGFuZCB0aHVzIHJlcXVpcmVcbiAgICAgICAgICAgIC8vIHRoZSBwb3NpdGlvbiBvZiB0aGUgZHJvcGRvd24gdG8gYmUgdXBkYXRlZCBhcyB3ZWxsIHNvIGl0IGRvZXMgbm90IGNvbWUgdW5nbHVlZCBmcm9tIHRoZSBjb250YWluZXJcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnBhcmVudHMoKS5hZGQod2luZG93KS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLm9uKHJlc2l6ZStcIiBcIitzY3JvbGwrXCIgXCIrb3JpZW50LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5vcGVuZWQoKSkgdGhhdC5wb3NpdGlvbkRyb3Bkb3duKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gYWJzdHJhY3RcbiAgICAgICAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5vcGVuZWQoKSkgcmV0dXJuO1xuXG4gICAgICAgICAgICB2YXIgY2lkID0gdGhpcy5jb250YWluZXJFdmVudE5hbWUsXG4gICAgICAgICAgICAgICAgc2Nyb2xsID0gXCJzY3JvbGwuXCIgKyBjaWQsXG4gICAgICAgICAgICAgICAgcmVzaXplID0gXCJyZXNpemUuXCIrY2lkLFxuICAgICAgICAgICAgICAgIG9yaWVudCA9IFwib3JpZW50YXRpb25jaGFuZ2UuXCIrY2lkO1xuXG4gICAgICAgICAgICAvLyB1bmJpbmQgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5wYXJlbnRzKCkuYWRkKHdpbmRvdykuZWFjaChmdW5jdGlvbiAoKSB7ICQodGhpcykub2ZmKHNjcm9sbCkub2ZmKHJlc2l6ZSkub2ZmKG9yaWVudCk7IH0pO1xuXG4gICAgICAgICAgICB0aGlzLmNsZWFyRHJvcGRvd25BbGlnbm1lbnRQcmVmZXJlbmNlKCk7XG5cbiAgICAgICAgICAgICQoXCIjc2VsZWN0Mi1kcm9wLW1hc2tcIikuaGlkZSgpO1xuICAgICAgICAgICAgdGhpcy5kcm9wZG93bi5yZW1vdmVBdHRyKFwiaWRcIik7IC8vIG9ubHkgdGhlIGFjdGl2ZSBkcm9wZG93biBoYXMgdGhlIHNlbGVjdDItZHJvcCBpZFxuICAgICAgICAgICAgdGhpcy5kcm9wZG93bi5oaWRlKCk7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDbGFzcyhcInNlbGVjdDItZHJvcGRvd24tb3BlblwiKS5yZW1vdmVDbGFzcyhcInNlbGVjdDItY29udGFpbmVyLWFjdGl2ZVwiKTtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0cy5lbXB0eSgpO1xuXG4gICAgICAgICAgICAvLyBOb3cgdGhhdCB0aGUgZHJvcGRvd24gaXMgY2xvc2VkLCB1bmJpbmQgdGhlIGdsb2JhbCBkb2N1bWVudCBtb3VzZW1vdmUgZXZlbnRcbiAgICAgICAgICAgICRkb2N1bWVudC5vZmYoXCJtb3VzZW1vdmUuc2VsZWN0MkV2ZW50XCIpO1xuXG4gICAgICAgICAgICB0aGlzLmNsZWFyU2VhcmNoKCk7XG4gICAgICAgICAgICB0aGlzLnNlYXJjaC5yZW1vdmVDbGFzcyhcInNlbGVjdDItYWN0aXZlXCIpO1xuICAgICAgICAgICAgdGhpcy5vcHRzLmVsZW1lbnQudHJpZ2dlcigkLkV2ZW50KFwic2VsZWN0Mi1jbG9zZVwiKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wZW5zIGNvbnRyb2wsIHNldHMgaW5wdXQgdmFsdWUsIGFuZCB1cGRhdGVzIHJlc3VsdHMuXG4gICAgICAgICAqL1xuICAgICAgICAvLyBhYnN0cmFjdFxuICAgICAgICBleHRlcm5hbFNlYXJjaDogZnVuY3Rpb24gKHRlcm0pIHtcbiAgICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICAgICAgdGhpcy5zZWFyY2gudmFsKHRlcm0pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVSZXN1bHRzKGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBhYnN0cmFjdFxuICAgICAgICBjbGVhclNlYXJjaDogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy9hYnN0cmFjdFxuICAgICAgICBnZXRNYXhpbXVtU2VsZWN0aW9uU2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZhbHVhdGUodGhpcy5vcHRzLm1heGltdW1TZWxlY3Rpb25TaXplLCB0aGlzLm9wdHMuZWxlbWVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gYWJzdHJhY3RcbiAgICAgICAgZW5zdXJlSGlnaGxpZ2h0VmlzaWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB0aGlzLnJlc3VsdHMsIGNoaWxkcmVuLCBpbmRleCwgY2hpbGQsIGhiLCByYiwgeSwgbW9yZSwgdG9wT2Zmc2V0O1xuXG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuaGlnaGxpZ2h0KCk7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHJldHVybjtcblxuICAgICAgICAgICAgaWYgKGluZGV4ID09IDApIHtcblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBmaXJzdCBlbGVtZW50IGlzIGhpZ2hsaWdodGVkIHNjcm9sbCBhbGwgdGhlIHdheSB0byB0aGUgdG9wLFxuICAgICAgICAgICAgICAgIC8vIHRoYXQgd2F5IGFueSB1bnNlbGVjdGFibGUgaGVhZGVycyBhYm92ZSBpdCB3aWxsIGFsc28gYmUgc2Nyb2xsZWRcbiAgICAgICAgICAgICAgICAvLyBpbnRvIHZpZXdcblxuICAgICAgICAgICAgICAgIHJlc3VsdHMuc2Nyb2xsVG9wKDApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLmZpbmRIaWdobGlnaHRhYmxlQ2hvaWNlcygpLmZpbmQoJy5zZWxlY3QyLXJlc3VsdC1sYWJlbCcpO1xuXG4gICAgICAgICAgICBjaGlsZCA9ICQoY2hpbGRyZW5baW5kZXhdKTtcblxuICAgICAgICAgICAgdG9wT2Zmc2V0ID0gKGNoaWxkLm9mZnNldCgpIHx8IHt9KS50b3AgfHwgMDtcblxuICAgICAgICAgICAgaGIgPSB0b3BPZmZzZXQgKyBjaGlsZC5vdXRlckhlaWdodCh0cnVlKTtcblxuICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyB0aGUgbGFzdCBjaGlsZCBsZXRzIGFsc28gbWFrZSBzdXJlIHNlbGVjdDItbW9yZS1yZXN1bHRzIGlzIHZpc2libGVcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gY2hpbGRyZW4ubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIG1vcmUgPSByZXN1bHRzLmZpbmQoXCJsaS5zZWxlY3QyLW1vcmUtcmVzdWx0c1wiKTtcbiAgICAgICAgICAgICAgICBpZiAobW9yZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGhiID0gbW9yZS5vZmZzZXQoKS50b3AgKyBtb3JlLm91dGVySGVpZ2h0KHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmIgPSByZXN1bHRzLm9mZnNldCgpLnRvcCArIHJlc3VsdHMub3V0ZXJIZWlnaHQoZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGhiID4gcmIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnNjcm9sbFRvcChyZXN1bHRzLnNjcm9sbFRvcCgpICsgKGhiIC0gcmIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHkgPSB0b3BPZmZzZXQgLSByZXN1bHRzLm9mZnNldCgpLnRvcDtcblxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSB0b3Agb2YgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZVxuICAgICAgICAgICAgaWYgKHkgPCAwICYmIGNoaWxkLmNzcygnZGlzcGxheScpICE9ICdub25lJyApIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnNjcm9sbFRvcChyZXN1bHRzLnNjcm9sbFRvcCgpICsgeSk7IC8vIHkgaXMgbmVnYXRpdmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBhYnN0cmFjdFxuICAgICAgICBmaW5kSGlnaGxpZ2h0YWJsZUNob2ljZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0cy5maW5kKFwiLnNlbGVjdDItcmVzdWx0LXNlbGVjdGFibGU6bm90KC5zZWxlY3QyLWRpc2FibGVkKTpub3QoLnNlbGVjdDItc2VsZWN0ZWQpXCIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGFic3RyYWN0XG4gICAgICAgIG1vdmVIaWdobGlnaHQ6IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICAgICAgdmFyIGNob2ljZXMgPSB0aGlzLmZpbmRIaWdobGlnaHRhYmxlQ2hvaWNlcygpLFxuICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5oaWdobGlnaHQoKTtcblxuICAgICAgICAgICAgd2hpbGUgKGluZGV4ID4gLTEgJiYgaW5kZXggPCBjaG9pY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGluZGV4ICs9IGRlbHRhO1xuICAgICAgICAgICAgICAgIHZhciBjaG9pY2UgPSAkKGNob2ljZXNbaW5kZXhdKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hvaWNlLmhhc0NsYXNzKFwic2VsZWN0Mi1yZXN1bHQtc2VsZWN0YWJsZVwiKSAmJiAhY2hvaWNlLmhhc0NsYXNzKFwic2VsZWN0Mi1kaXNhYmxlZFwiKSAmJiAhY2hvaWNlLmhhc0NsYXNzKFwic2VsZWN0Mi1zZWxlY3RlZFwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodChpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBhYnN0cmFjdFxuICAgICAgICBoaWdobGlnaHQ6IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgdmFyIGNob2ljZXMgPSB0aGlzLmZpbmRIaWdobGlnaHRhYmxlQ2hvaWNlcygpLFxuICAgICAgICAgICAgICAgIGNob2ljZSxcbiAgICAgICAgICAgICAgICBkYXRhO1xuXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleE9mKGNob2ljZXMuZmlsdGVyKFwiLnNlbGVjdDItaGlnaGxpZ2h0ZWRcIilbMF0sIGNob2ljZXMuZ2V0KCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gY2hvaWNlcy5sZW5ndGgpIGluZGV4ID0gY2hvaWNlcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkgaW5kZXggPSAwO1xuXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUhpZ2hsaWdodCgpO1xuXG4gICAgICAgICAgICBjaG9pY2UgPSAkKGNob2ljZXNbaW5kZXhdKTtcbiAgICAgICAgICAgIGNob2ljZS5hZGRDbGFzcyhcInNlbGVjdDItaGlnaGxpZ2h0ZWRcIik7XG5cbiAgICAgICAgICAgIC8vIGVuc3VyZSBhc3Npc3RpdmUgdGVjaG5vbG9neSBjYW4gZGV0ZXJtaW5lIHRoZSBhY3RpdmUgY2hvaWNlXG4gICAgICAgICAgICB0aGlzLnNlYXJjaC5hdHRyKFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIsIGNob2ljZS5maW5kKFwiLnNlbGVjdDItcmVzdWx0LWxhYmVsXCIpLmF0dHIoXCJpZFwiKSk7XG5cbiAgICAgICAgICAgIHRoaXMuZW5zdXJlSGlnaGxpZ2h0VmlzaWJsZSgpO1xuXG4gICAgICAgICAgICB0aGlzLmxpdmVSZWdpb24udGV4dChjaG9pY2UudGV4dCgpKTtcblxuICAgICAgICAgICAgZGF0YSA9IGNob2ljZS5kYXRhKFwic2VsZWN0Mi1kYXRhXCIpO1xuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdHMuZWxlbWVudC50cmlnZ2VyKHsgdHlwZTogXCJzZWxlY3QyLWhpZ2hsaWdodFwiLCB2YWw6IHRoaXMuaWQoZGF0YSksIGNob2ljZTogZGF0YSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmVIaWdobGlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRzLmZpbmQoXCIuc2VsZWN0Mi1oaWdobGlnaHRlZFwiKS5yZW1vdmVDbGFzcyhcInNlbGVjdDItaGlnaGxpZ2h0ZWRcIik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG91Y2hNb3ZlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl90b3VjaE1vdmVkID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhclRvdWNoTW92ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuX3RvdWNoTW92ZWQgPSBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBhYnN0cmFjdFxuICAgICAgICBjb3VudFNlbGVjdGFibGVSZXN1bHRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmRIaWdobGlnaHRhYmxlQ2hvaWNlcygpLmxlbmd0aDtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBhYnN0cmFjdFxuICAgICAgICBoaWdobGlnaHRVbmRlckV2ZW50OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBlbCA9ICQoZXZlbnQudGFyZ2V0KS5jbG9zZXN0KFwiLnNlbGVjdDItcmVzdWx0LXNlbGVjdGFibGVcIik7XG4gICAgICAgICAgICBpZiAoZWwubGVuZ3RoID4gMCAmJiAhZWwuaXMoXCIuc2VsZWN0Mi1oaWdobGlnaHRlZFwiKSkge1xuICAgICAgICAgICAgICAgIHZhciBjaG9pY2VzID0gdGhpcy5maW5kSGlnaGxpZ2h0YWJsZUNob2ljZXMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodChjaG9pY2VzLmluZGV4KGVsKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIG92ZXIgYW4gdW5zZWxlY3RhYmxlIGl0ZW0gcmVtb3ZlIGFsbCBoaWdobGlnaHRzXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVIaWdobGlnaHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBhYnN0cmFjdFxuICAgICAgICBsb2FkTW9yZUlmTmVlZGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHRoaXMucmVzdWx0cyxcbiAgICAgICAgICAgICAgICBtb3JlID0gcmVzdWx0cy5maW5kKFwibGkuc2VsZWN0Mi1tb3JlLXJlc3VsdHNcIiksXG4gICAgICAgICAgICAgICAgYmVsb3csIC8vIHBpeGVscyB0aGUgZWxlbWVudCBpcyBiZWxvdyB0aGUgc2Nyb2xsIGZvbGQsIGJlbG93PT0wIGlzIHdoZW4gdGhlIGVsZW1lbnQgaXMgc3RhcnRpbmcgdG8gYmUgdmlzaWJsZVxuICAgICAgICAgICAgICAgIHBhZ2UgPSB0aGlzLnJlc3VsdHNQYWdlICsgMSxcbiAgICAgICAgICAgICAgICBzZWxmPXRoaXMsXG4gICAgICAgICAgICAgICAgdGVybT10aGlzLnNlYXJjaC52YWwoKSxcbiAgICAgICAgICAgICAgICBjb250ZXh0PXRoaXMuY29udGV4dDtcblxuICAgICAgICAgICAgaWYgKG1vcmUubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICAgICAgICBiZWxvdyA9IG1vcmUub2Zmc2V0KCkudG9wIC0gcmVzdWx0cy5vZmZzZXQoKS50b3AgLSByZXN1bHRzLmhlaWdodCgpO1xuXG4gICAgICAgICAgICBpZiAoYmVsb3cgPD0gdGhpcy5vcHRzLmxvYWRNb3JlUGFkZGluZykge1xuICAgICAgICAgICAgICAgIG1vcmUuYWRkQ2xhc3MoXCJzZWxlY3QyLWFjdGl2ZVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdHMucXVlcnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogdGhpcy5vcHRzLmVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXJtOiB0ZXJtLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZTogcGFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyOiB0aGlzLm9wdHMubWF0Y2hlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiB0aGlzLmJpbmQoZnVuY3Rpb24gKGRhdGEpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgYSByZXNwb25zZSBpZiB0aGUgc2VsZWN0MiBoYXMgYmVlbiBjbG9zZWQgYmVmb3JlIGl0IHdhcyByZWNlaXZlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGYub3BlbmVkKCkpIHJldHVybjtcblxuXG4gICAgICAgICAgICAgICAgICAgIHNlbGYub3B0cy5wb3B1bGF0ZVJlc3VsdHMuY2FsbCh0aGlzLCByZXN1bHRzLCBkYXRhLnJlc3VsdHMsIHt0ZXJtOiB0ZXJtLCBwYWdlOiBwYWdlLCBjb250ZXh0OmNvbnRleHR9KTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wb3N0cHJvY2Vzc1Jlc3VsdHMoZGF0YSwgZmFsc2UsIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5tb3JlPT09dHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9yZS5kZXRhY2goKS5hcHBlbmRUbyhyZXN1bHRzKS5odG1sKHNlbGYub3B0cy5lc2NhcGVNYXJrdXAoZXZhbHVhdGUoc2VsZi5vcHRzLmZvcm1hdExvYWRNb3JlLCBzZWxmLm9wdHMuZWxlbWVudCwgcGFnZSsxKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHNlbGYubG9hZE1vcmVJZk5lZWRlZCgpOyB9LCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3JlLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucG9zaXRpb25Ecm9wZG93bigpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnJlc3VsdHNQYWdlID0gcGFnZTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb250ZXh0ID0gZGF0YS5jb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdHMuZWxlbWVudC50cmlnZ2VyKHsgdHlwZTogXCJzZWxlY3QyLWxvYWRlZFwiLCBpdGVtczogZGF0YSB9KTtcbiAgICAgICAgICAgICAgICB9KX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZhdWx0IHRva2VuaXplciBmdW5jdGlvbiB3aGljaCBkb2VzIG5vdGhpbmdcbiAgICAgICAgICovXG4gICAgICAgIHRva2VuaXplOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gaW5pdGlhbCB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBjYWxsIHRvIHRoaXMgbWV0aG9kIHJpZ2h0IGFmdGVyIHRoZSBkcm9wZG93biBoYXMgYmVlbiBvcGVuZWRcbiAgICAgICAgICovXG4gICAgICAgIC8vIGFic3RyYWN0XG4gICAgICAgIHVwZGF0ZVJlc3VsdHM6IGZ1bmN0aW9uIChpbml0aWFsKSB7XG4gICAgICAgICAgICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2gsXG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IHRoaXMucmVzdWx0cyxcbiAgICAgICAgICAgICAgICBvcHRzID0gdGhpcy5vcHRzLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgdGVybSA9IHNlYXJjaC52YWwoKSxcbiAgICAgICAgICAgICAgICBsYXN0VGVybSA9ICQuZGF0YSh0aGlzLmNvbnRhaW5lciwgXCJzZWxlY3QyLWxhc3QtdGVybVwiKSxcbiAgICAgICAgICAgICAgICAvLyBzZXF1ZW5jZSBudW1iZXIgdXNlZCB0byBkcm9wIG91dC1vZi1vcmRlciByZXNwb25zZXNcbiAgICAgICAgICAgICAgICBxdWVyeU51bWJlcjtcblxuICAgICAgICAgICAgLy8gcHJldmVudCBkdXBsaWNhdGUgcXVlcmllcyBhZ2FpbnN0IHRoZSBzYW1lIHRlcm1cbiAgICAgICAgICAgIGlmIChpbml0aWFsICE9PSB0cnVlICYmIGxhc3RUZXJtICYmIGVxdWFsKHRlcm0sIGxhc3RUZXJtKSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAkLmRhdGEodGhpcy5jb250YWluZXIsIFwic2VsZWN0Mi1sYXN0LXRlcm1cIiwgdGVybSk7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBzZWFyY2ggaXMgY3VycmVudGx5IGhpZGRlbiB3ZSBkbyBub3QgYWx0ZXIgdGhlIHJlc3VsdHNcbiAgICAgICAgICAgIGlmIChpbml0aWFsICE9PSB0cnVlICYmICh0aGlzLnNob3dTZWFyY2hJbnB1dCA9PT0gZmFsc2UgfHwgIXRoaXMub3BlbmVkKCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBwb3N0UmVuZGVyKCkge1xuICAgICAgICAgICAgICAgIHNlYXJjaC5yZW1vdmVDbGFzcyhcInNlbGVjdDItYWN0aXZlXCIpO1xuICAgICAgICAgICAgICAgIHNlbGYucG9zaXRpb25Ecm9wZG93bigpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzLmZpbmQoJy5zZWxlY3QyLW5vLXJlc3VsdHMsLnNlbGVjdDItc2VsZWN0aW9uLWxpbWl0LC5zZWxlY3QyLXNlYXJjaGluZycpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmxpdmVSZWdpb24udGV4dChyZXN1bHRzLnRleHQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmxpdmVSZWdpb24udGV4dChzZWxmLm9wdHMuZm9ybWF0TWF0Y2hlcyhyZXN1bHRzLmZpbmQoJy5zZWxlY3QyLXJlc3VsdC1zZWxlY3RhYmxlOm5vdChcIi5zZWxlY3QyLXNlbGVjdGVkXCIpJykubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiByZW5kZXIoaHRtbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMuaHRtbChodG1sKTtcbiAgICAgICAgICAgICAgICBwb3N0UmVuZGVyKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHF1ZXJ5TnVtYmVyID0gKyt0aGlzLnF1ZXJ5Q291bnQ7XG5cbiAgICAgICAgICAgIHZhciBtYXhTZWxTaXplID0gdGhpcy5nZXRNYXhpbXVtU2VsZWN0aW9uU2l6ZSgpO1xuICAgICAgICAgICAgaWYgKG1heFNlbFNpemUgPj0xKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZGF0YSgpO1xuICAgICAgICAgICAgICAgIGlmICgkLmlzQXJyYXkoZGF0YSkgJiYgZGF0YS5sZW5ndGggPj0gbWF4U2VsU2l6ZSAmJiBjaGVja0Zvcm1hdHRlcihvcHRzLmZvcm1hdFNlbGVjdGlvblRvb0JpZywgXCJmb3JtYXRTZWxlY3Rpb25Ub29CaWdcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyKFwiPGxpIGNsYXNzPSdzZWxlY3QyLXNlbGVjdGlvbi1saW1pdCc+XCIgKyBldmFsdWF0ZShvcHRzLmZvcm1hdFNlbGVjdGlvblRvb0JpZywgb3B0cy5lbGVtZW50LCBtYXhTZWxTaXplKSArIFwiPC9saT5cIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWFyY2gudmFsKCkubGVuZ3RoIDwgb3B0cy5taW5pbXVtSW5wdXRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tGb3JtYXR0ZXIob3B0cy5mb3JtYXRJbnB1dFRvb1Nob3J0LCBcImZvcm1hdElucHV0VG9vU2hvcnRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyKFwiPGxpIGNsYXNzPSdzZWxlY3QyLW5vLXJlc3VsdHMnPlwiICsgZXZhbHVhdGUob3B0cy5mb3JtYXRJbnB1dFRvb1Nob3J0LCBvcHRzLmVsZW1lbnQsIHNlYXJjaC52YWwoKSwgb3B0cy5taW5pbXVtSW5wdXRMZW5ndGgpICsgXCI8L2xpPlwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXIoXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbml0aWFsICYmIHRoaXMuc2hvd1NlYXJjaCkgdGhpcy5zaG93U2VhcmNoKHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdHMubWF4aW11bUlucHV0TGVuZ3RoICYmIHNlYXJjaC52YWwoKS5sZW5ndGggPiBvcHRzLm1heGltdW1JbnB1dExlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChjaGVja0Zvcm1hdHRlcihvcHRzLmZvcm1hdElucHV0VG9vTG9uZywgXCJmb3JtYXRJbnB1dFRvb0xvbmdcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyKFwiPGxpIGNsYXNzPSdzZWxlY3QyLW5vLXJlc3VsdHMnPlwiICsgZXZhbHVhdGUob3B0cy5mb3JtYXRJbnB1dFRvb0xvbmcsIG9wdHMuZWxlbWVudCwgc2VhcmNoLnZhbCgpLCBvcHRzLm1heGltdW1JbnB1dExlbmd0aCkgKyBcIjwvbGk+XCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcihcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3B0cy5mb3JtYXRTZWFyY2hpbmcgJiYgdGhpcy5maW5kSGlnaGxpZ2h0YWJsZUNob2ljZXMoKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZW5kZXIoXCI8bGkgY2xhc3M9J3NlbGVjdDItc2VhcmNoaW5nJz5cIiArIGV2YWx1YXRlKG9wdHMuZm9ybWF0U2VhcmNoaW5nLCBvcHRzLmVsZW1lbnQpICsgXCI8L2xpPlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VhcmNoLmFkZENsYXNzKFwic2VsZWN0Mi1hY3RpdmVcIik7XG5cbiAgICAgICAgICAgIHRoaXMucmVtb3ZlSGlnaGxpZ2h0KCk7XG5cbiAgICAgICAgICAgIC8vIGdpdmUgdGhlIHRva2VuaXplciBhIGNoYW5jZSB0byBwcmUtcHJvY2VzcyB0aGUgaW5wdXRcbiAgICAgICAgICAgIGlucHV0ID0gdGhpcy50b2tlbml6ZSgpO1xuICAgICAgICAgICAgaWYgKGlucHV0ICE9IHVuZGVmaW5lZCAmJiBpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2VhcmNoLnZhbChpbnB1dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucmVzdWx0c1BhZ2UgPSAxO1xuXG4gICAgICAgICAgICBvcHRzLnF1ZXJ5KHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBvcHRzLmVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHRlcm06IHNlYXJjaC52YWwoKSxcbiAgICAgICAgICAgICAgICAgICAgcGFnZTogdGhpcy5yZXN1bHRzUGFnZSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcjogb3B0cy5tYXRjaGVyLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogdGhpcy5iaW5kKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlZjsgLy8gZGVmYXVsdCBjaG9pY2VcblxuICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBvbGQgcmVzcG9uc2VzXG4gICAgICAgICAgICAgICAgaWYgKHF1ZXJ5TnVtYmVyICE9IHRoaXMucXVlcnlDb3VudCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBhIHJlc3BvbnNlIGlmIHRoZSBzZWxlY3QyIGhhcyBiZWVuIGNsb3NlZCBiZWZvcmUgaXQgd2FzIHJlY2VpdmVkXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wZW5lZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoLnJlbW92ZUNsYXNzKFwic2VsZWN0Mi1hY3RpdmVcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgYWpheCBlcnJvclxuICAgICAgICAgICAgICAgIGlmKGRhdGEuaGFzRXJyb3IgIT09IHVuZGVmaW5lZCAmJiBjaGVja0Zvcm1hdHRlcihvcHRzLmZvcm1hdEFqYXhFcnJvciwgXCJmb3JtYXRBamF4RXJyb3JcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyKFwiPGxpIGNsYXNzPSdzZWxlY3QyLWFqYXgtZXJyb3InPlwiICsgZXZhbHVhdGUob3B0cy5mb3JtYXRBamF4RXJyb3IsIG9wdHMuZWxlbWVudCwgZGF0YS5qcVhIUiwgZGF0YS50ZXh0U3RhdHVzLCBkYXRhLmVycm9yVGhyb3duKSArIFwiPC9saT5cIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBzYXZlIGNvbnRleHQsIGlmIGFueVxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IChkYXRhLmNvbnRleHQ9PT11bmRlZmluZWQpID8gbnVsbCA6IGRhdGEuY29udGV4dDtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYSBkZWZhdWx0IGNob2ljZSBhbmQgcHJlcGVuZCBpdCB0byB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuY3JlYXRlU2VhcmNoQ2hvaWNlICYmIHNlYXJjaC52YWwoKSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBkZWYgPSB0aGlzLm9wdHMuY3JlYXRlU2VhcmNoQ2hvaWNlLmNhbGwoc2VsZiwgc2VhcmNoLnZhbCgpLCBkYXRhLnJlc3VsdHMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmICE9PSB1bmRlZmluZWQgJiYgZGVmICE9PSBudWxsICYmIHNlbGYuaWQoZGVmKSAhPT0gdW5kZWZpbmVkICYmIHNlbGYuaWQoZGVmKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCQoZGF0YS5yZXN1bHRzKS5maWx0ZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXF1YWwoc2VsZi5pZCh0aGlzKSwgc2VsZi5pZChkZWYpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdHMuY3JlYXRlU2VhcmNoQ2hvaWNlUG9zaXRpb24oZGF0YS5yZXN1bHRzLCBkZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEucmVzdWx0cy5sZW5ndGggPT09IDAgJiYgY2hlY2tGb3JtYXR0ZXIob3B0cy5mb3JtYXROb01hdGNoZXMsIFwiZm9ybWF0Tm9NYXRjaGVzXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcihcIjxsaSBjbGFzcz0nc2VsZWN0Mi1uby1yZXN1bHRzJz5cIiArIGV2YWx1YXRlKG9wdHMuZm9ybWF0Tm9NYXRjaGVzLCBvcHRzLmVsZW1lbnQsIHNlYXJjaC52YWwoKSkgKyBcIjwvbGk+XCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5lbXB0eSgpO1xuICAgICAgICAgICAgICAgIHNlbGYub3B0cy5wb3B1bGF0ZVJlc3VsdHMuY2FsbCh0aGlzLCByZXN1bHRzLCBkYXRhLnJlc3VsdHMsIHt0ZXJtOiBzZWFyY2gudmFsKCksIHBhZ2U6IHRoaXMucmVzdWx0c1BhZ2UsIGNvbnRleHQ6bnVsbH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEubW9yZSA9PT0gdHJ1ZSAmJiBjaGVja0Zvcm1hdHRlcihvcHRzLmZvcm1hdExvYWRNb3JlLCBcImZvcm1hdExvYWRNb3JlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMuYXBwZW5kKFwiPGxpIGNsYXNzPSdzZWxlY3QyLW1vcmUtcmVzdWx0cyc+XCIgKyBvcHRzLmVzY2FwZU1hcmt1cChldmFsdWF0ZShvcHRzLmZvcm1hdExvYWRNb3JlLCBvcHRzLmVsZW1lbnQsIHRoaXMucmVzdWx0c1BhZ2UpKSArIFwiPC9saT5cIik7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBzZWxmLmxvYWRNb3JlSWZOZWVkZWQoKTsgfSwgMTApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMucG9zdHByb2Nlc3NSZXN1bHRzKGRhdGEsIGluaXRpYWwpO1xuXG4gICAgICAgICAgICAgICAgcG9zdFJlbmRlcigpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRzLmVsZW1lbnQudHJpZ2dlcih7IHR5cGU6IFwic2VsZWN0Mi1sb2FkZWRcIiwgaXRlbXM6IGRhdGEgfSk7XG4gICAgICAgICAgICB9KX0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGFic3RyYWN0XG4gICAgICAgIGNhbmNlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGFic3RyYWN0XG4gICAgICAgIGJsdXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGlmIHNlbGVjdE9uQmx1ciA9PSB0cnVlLCBzZWxlY3QgdGhlIGN1cnJlbnRseSBoaWdobGlnaHRlZCBvcHRpb25cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuc2VsZWN0T25CbHVyKVxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0SGlnaGxpZ2h0ZWQoe25vRm9jdXM6IHRydWV9KTtcblxuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlQ2xhc3MoXCJzZWxlY3QyLWNvbnRhaW5lci1hY3RpdmVcIik7XG4gICAgICAgICAgICAvLyBzeW5vbnltb3VzIHRvIC5pcygnOmZvY3VzJyksIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiBqcXVlcnkgPj0gMS42XG4gICAgICAgICAgICBpZiAodGhpcy5zZWFyY2hbMF0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHsgdGhpcy5zZWFyY2guYmx1cigpOyB9XG4gICAgICAgICAgICB0aGlzLmNsZWFyU2VhcmNoKCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5maW5kKFwiLnNlbGVjdDItc2VhcmNoLWNob2ljZS1mb2N1c1wiKS5yZW1vdmVDbGFzcyhcInNlbGVjdDItc2VhcmNoLWNob2ljZS1mb2N1c1wiKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBhYnN0cmFjdFxuICAgICAgICBmb2N1c1NlYXJjaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9jdXModGhpcy5zZWFyY2gpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGFic3RyYWN0XG4gICAgICAgIHNlbGVjdEhpZ2hsaWdodGVkOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3RvdWNoTW92ZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5jbGVhclRvdWNoTW92ZWQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGluZGV4PXRoaXMuaGlnaGxpZ2h0KCksXG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0ZWQ9dGhpcy5yZXN1bHRzLmZpbmQoXCIuc2VsZWN0Mi1oaWdobGlnaHRlZFwiKSxcbiAgICAgICAgICAgICAgICBkYXRhID0gaGlnaGxpZ2h0ZWQuY2xvc2VzdCgnLnNlbGVjdDItcmVzdWx0JykuZGF0YShcInNlbGVjdDItZGF0YVwiKTtcblxuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodChpbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vblNlbGVjdChkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm5vRm9jdXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gYWJzdHJhY3RcbiAgICAgICAgZ2V0UGxhY2Vob2xkZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwbGFjZWhvbGRlck9wdGlvbjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdHMuZWxlbWVudC5hdHRyKFwicGxhY2Vob2xkZXJcIikgfHxcbiAgICAgICAgICAgICAgICB0aGlzLm9wdHMuZWxlbWVudC5hdHRyKFwiZGF0YS1wbGFjZWhvbGRlclwiKSB8fCAvLyBqcXVlcnkgMS40IGNvbXBhdFxuICAgICAgICAgICAgICAgIHRoaXMub3B0cy5lbGVtZW50LmRhdGEoXCJwbGFjZWhvbGRlclwiKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMub3B0cy5wbGFjZWhvbGRlciB8fFxuICAgICAgICAgICAgICAgICgocGxhY2Vob2xkZXJPcHRpb24gPSB0aGlzLmdldFBsYWNlaG9sZGVyT3B0aW9uKCkpICE9PSB1bmRlZmluZWQgPyBwbGFjZWhvbGRlck9wdGlvbi50ZXh0KCkgOiB1bmRlZmluZWQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGFic3RyYWN0XG4gICAgICAgIGdldFBsYWNlaG9sZGVyT3B0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdE9wdGlvbiA9IHRoaXMuc2VsZWN0LmNoaWxkcmVuKCdvcHRpb24nKS5maXJzdCgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdHMucGxhY2Vob2xkZXJPcHRpb24gIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgLy9EZXRlcm1pbmUgdGhlIHBsYWNlaG9sZGVyIG9wdGlvbiBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIHBsYWNlaG9sZGVyT3B0aW9uIHNldHRpbmdcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLm9wdHMucGxhY2Vob2xkZXJPcHRpb24gPT09IFwiZmlyc3RcIiAmJiBmaXJzdE9wdGlvbikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgdGhpcy5vcHRzLnBsYWNlaG9sZGVyT3B0aW9uID09PSBcImZ1bmN0aW9uXCIgJiYgdGhpcy5vcHRzLnBsYWNlaG9sZGVyT3B0aW9uKHRoaXMuc2VsZWN0KSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgkLnRyaW0oZmlyc3RPcHRpb24udGV4dCgpKSA9PT0gXCJcIiAmJiBmaXJzdE9wdGlvbi52YWwoKSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAvL05vIGV4cGxpY2l0IHBsYWNlaG9sZGVyIG9wdGlvbiBzcGVjaWZpZWQsIHVzZSB0aGUgZmlyc3QgaWYgaXQncyBibGFua1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlyc3RPcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGRlc2lyZWQgd2lkdGggZm9yIHRoZSBjb250YWluZXIgZWxlbWVudC4gIFRoaXMgaXNcbiAgICAgICAgICogZGVyaXZlZCBmaXJzdCBmcm9tIG9wdGlvbiBgd2lkdGhgIHBhc3NlZCB0byBzZWxlY3QyLCB0aGVuXG4gICAgICAgICAqIHRoZSBpbmxpbmUgJ3N0eWxlJyBvbiB0aGUgb3JpZ2luYWwgZWxlbWVudCwgYW5kIGZpbmFsbHlcbiAgICAgICAgICogZmFsbHMgYmFjayB0byB0aGUgalF1ZXJ5IGNhbGN1bGF0ZWQgZWxlbWVudCB3aWR0aC5cbiAgICAgICAgICovXG4gICAgICAgIC8vIGFic3RyYWN0XG4gICAgICAgIGluaXRDb250YWluZXJXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZUNvbnRhaW5lcldpZHRoKCkge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSwgYXR0cnMsIG1hdGNoZXMsIGksIGwsIGF0dHI7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRzLndpZHRoID09PSBcIm9mZlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRzLndpZHRoID09PSBcImVsZW1lbnRcIil7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdHMuZWxlbWVudC5vdXRlcldpZHRoKGZhbHNlKSA9PT0gMCA/ICdhdXRvJyA6IHRoaXMub3B0cy5lbGVtZW50Lm91dGVyV2lkdGgoZmFsc2UpICsgJ3B4JztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0cy53aWR0aCA9PT0gXCJjb3B5XCIgfHwgdGhpcy5vcHRzLndpZHRoID09PSBcInJlc29sdmVcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBpcyBpbmxpbmUgc3R5bGUgb24gdGhlIGVsZW1lbnQgdGhhdCBjb250YWlucyB3aWR0aFxuICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IHRoaXMub3B0cy5lbGVtZW50LmF0dHIoJ3N0eWxlJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRycyA9IHN0eWxlLnNwbGl0KCc7Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0ciA9IGF0dHJzW2ldLnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcyA9IGF0dHIubWF0Y2goL153aWR0aDooKFstK10/KFswLTldKlxcLik/WzAtOV0rKShweHxlbXxleHwlfGlufGNtfG1tfHB0fHBjKSkvaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMgIT09IG51bGwgJiYgbWF0Y2hlcy5sZW5ndGggPj0gMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRzLndpZHRoID09PSBcInJlc29sdmVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBjaGVjayBpZiBjc3MoJ3dpZHRoJykgY2FuIHJlc29sdmUgYSB3aWR0aCB0aGF0IGlzIHBlcmNlbnQgYmFzZWQsIHRoaXMgaXMgc29tZXRpbWVzIHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIGF0dGFjaGVkIHRvIGlucHV0IHR5cGU9aGlkZGVuIG9yIGVsZW1lbnRzIGhpZGRlbiB2aWEgY3NzXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IHRoaXMub3B0cy5lbGVtZW50LmNzcygnd2lkdGgnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZS5pbmRleE9mKFwiJVwiKSA+IDApIHJldHVybiBzdHlsZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmluYWxseSwgZmFsbGJhY2sgb24gdGhlIGNhbGN1bGF0ZWQgd2lkdGggb2YgdGhlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5vcHRzLmVsZW1lbnQub3V0ZXJXaWR0aChmYWxzZSkgPT09IDAgPyAnYXV0bycgOiB0aGlzLm9wdHMuZWxlbWVudC5vdXRlcldpZHRoKGZhbHNlKSArICdweCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgkLmlzRnVuY3Rpb24odGhpcy5vcHRzLndpZHRoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRzLndpZHRoKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0cy53aWR0aDtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHJlc29sdmVDb250YWluZXJXaWR0aC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHdpZHRoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuY3NzKFwid2lkdGhcIiwgd2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBTaW5nbGVTZWxlY3QyID0gY2xhenooQWJzdHJhY3RTZWxlY3QyLCB7XG5cbiAgICAgICAgLy8gc2luZ2xlXG5cbiAgICAgICAgY3JlYXRlQ29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gJChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKS5hdHRyKHtcbiAgICAgICAgICAgICAgICBcImNsYXNzXCI6IFwic2VsZWN0Mi1jb250YWluZXJcIlxuICAgICAgICAgICAgfSkuaHRtbChbXG4gICAgICAgICAgICAgICAgXCI8YSBocmVmPSdqYXZhc2NyaXB0OnZvaWQoMCknIGNsYXNzPSdzZWxlY3QyLWNob2ljZScgdGFiaW5kZXg9Jy0xJz5cIixcbiAgICAgICAgICAgICAgICBcIiAgIDxzcGFuIGNsYXNzPSdzZWxlY3QyLWNob3Nlbic+JiMxNjA7PC9zcGFuPjxhYmJyIGNsYXNzPSdzZWxlY3QyLXNlYXJjaC1jaG9pY2UtY2xvc2UnPjwvYWJicj5cIixcbiAgICAgICAgICAgICAgICBcIiAgIDxzcGFuIGNsYXNzPSdzZWxlY3QyLWFycm93JyByb2xlPSdwcmVzZW50YXRpb24nPjxiIHJvbGU9J3ByZXNlbnRhdGlvbic+PC9iPjwvc3Bhbj5cIixcbiAgICAgICAgICAgICAgICBcIjwvYT5cIixcbiAgICAgICAgICAgICAgICBcIjxsYWJlbCBmb3I9JycgY2xhc3M9J3NlbGVjdDItb2Zmc2NyZWVuJz48L2xhYmVsPlwiLFxuICAgICAgICAgICAgICAgIFwiPGlucHV0IGNsYXNzPSdzZWxlY3QyLWZvY3Vzc2VyIHNlbGVjdDItb2Zmc2NyZWVuJyB0eXBlPSd0ZXh0JyBhcmlhLWhhc3BvcHVwPSd0cnVlJyByb2xlPSdidXR0b24nIC8+XCIsXG4gICAgICAgICAgICAgICAgXCI8ZGl2IGNsYXNzPSdzZWxlY3QyLWRyb3Agc2VsZWN0Mi1kaXNwbGF5LW5vbmUnPlwiLFxuICAgICAgICAgICAgICAgIFwiICAgPGRpdiBjbGFzcz0nc2VsZWN0Mi1zZWFyY2gnPlwiLFxuICAgICAgICAgICAgICAgIFwiICAgICAgIDxsYWJlbCBmb3I9JycgY2xhc3M9J3NlbGVjdDItb2Zmc2NyZWVuJz48L2xhYmVsPlwiLFxuICAgICAgICAgICAgICAgIFwiICAgICAgIDxpbnB1dCB0eXBlPSd0ZXh0JyBhdXRvY29tcGxldGU9J29mZicgYXV0b2NvcnJlY3Q9J29mZicgYXV0b2NhcGl0YWxpemU9J29mZicgc3BlbGxjaGVjaz0nZmFsc2UnIGNsYXNzPSdzZWxlY3QyLWlucHV0JyByb2xlPSdjb21ib2JveCcgYXJpYS1leHBhbmRlZD0ndHJ1ZSdcIixcbiAgICAgICAgICAgICAgICBcIiAgICAgICBhcmlhLWF1dG9jb21wbGV0ZT0nbGlzdCcgLz5cIixcbiAgICAgICAgICAgICAgICBcIiAgIDwvZGl2PlwiLFxuICAgICAgICAgICAgICAgIFwiICAgPHVsIGNsYXNzPSdzZWxlY3QyLXJlc3VsdHMnIHJvbGU9J2xpc3Rib3gnPlwiLFxuICAgICAgICAgICAgICAgIFwiICAgPC91bD5cIixcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiXS5qb2luKFwiXCIpKTtcbiAgICAgICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gc2luZ2xlXG4gICAgICAgIGVuYWJsZUludGVyZmFjZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQuZW5hYmxlSW50ZXJmYWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvY3Vzc2VyLnByb3AoXCJkaXNhYmxlZFwiLCAhdGhpcy5pc0ludGVyZmFjZUVuYWJsZWQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gc2luZ2xlXG4gICAgICAgIG9wZW5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlbCwgcmFuZ2UsIGxlbjtcblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5taW5pbXVtUmVzdWx0c0ZvclNlYXJjaCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93U2VhcmNoKHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnBhcmVudC5vcGVuaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNob3dTZWFyY2hJbnB1dCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBJRSBhcHBlbmRzIGZvY3Vzc2VyLnZhbCgpIGF0IHRoZSBlbmQgb2YgZmllbGQgOi8gc28gd2UgbWFudWFsbHkgaW5zZXJ0IGl0IGF0IHRoZSBiZWdpbm5pbmcgdXNpbmcgYSByYW5nZVxuICAgICAgICAgICAgICAgIC8vIGFsbCBvdGhlciBicm93c2VycyBoYW5kbGUgdGhpcyBqdXN0IGZpbmVcblxuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoLnZhbCh0aGlzLmZvY3Vzc2VyLnZhbCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuc2hvdWxkRm9jdXNJbnB1dCh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgLy8gbW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBlbmQgYWZ0ZXIgZm9jdXNzaW5nLCBvdGhlcndpc2UgaXQgd2lsbCBiZSBhdCB0aGUgYmVnaW5uaW5nIGFuZFxuICAgICAgICAgICAgICAgIC8vIG5ldyB0ZXh0IHdpbGwgYXBwZWFyICpiZWZvcmUqIGZvY3Vzc2VyLnZhbCgpXG4gICAgICAgICAgICAgICAgZWwgPSB0aGlzLnNlYXJjaC5nZXQoMCk7XG4gICAgICAgICAgICAgICAgaWYgKGVsLmNyZWF0ZVRleHRSYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICByYW5nZSA9IGVsLmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5jb2xsYXBzZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNlbGVjdCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWwuc2V0U2VsZWN0aW9uUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVuID0gdGhpcy5zZWFyY2gudmFsKCkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBlbC5zZXRTZWxlY3Rpb25SYW5nZShsZW4sIGxlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpbml0aWFsaXplcyBzZWFyY2gncyB2YWx1ZSB3aXRoIG5leHRTZWFyY2hUZXJtIChpZiBkZWZpbmVkIGJ5IHVzZXIpXG4gICAgICAgICAgICAvLyBpZ25vcmUgbmV4dFNlYXJjaFRlcm0gaWYgdGhlIGRyb3Bkb3duIGlzIG9wZW5lZCBieSB0aGUgdXNlciBwcmVzc2luZyBhIGxldHRlclxuICAgICAgICAgICAgaWYodGhpcy5zZWFyY2gudmFsKCkgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLm5leHRTZWFyY2hUZXJtICE9IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoLnZhbCh0aGlzLm5leHRTZWFyY2hUZXJtKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWFyY2guc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmZvY3Vzc2VyLnByb3AoXCJkaXNhYmxlZFwiLCB0cnVlKS52YWwoXCJcIik7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVJlc3VsdHModHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLm9wdHMuZWxlbWVudC50cmlnZ2VyKCQuRXZlbnQoXCJzZWxlY3QyLW9wZW5cIikpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHNpbmdsZVxuICAgICAgICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLm9wZW5lZCgpKSByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5jbG9zZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICB0aGlzLmZvY3Vzc2VyLnByb3AoXCJkaXNhYmxlZFwiLCBmYWxzZSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuc2hvdWxkRm9jdXNJbnB1dCh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXNzZXIuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBzaW5nbGVcbiAgICAgICAgZm9jdXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wZW5lZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvY3Vzc2VyLnByb3AoXCJkaXNhYmxlZFwiLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5zaG91bGRGb2N1c0lucHV0KHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9jdXNzZXIuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gc2luZ2xlXG4gICAgICAgIGlzRm9jdXNlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyLmhhc0NsYXNzKFwic2VsZWN0Mi1jb250YWluZXItYWN0aXZlXCIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHNpbmdsZVxuICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmNhbmNlbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgdGhpcy5mb2N1c3Nlci5wcm9wKFwiZGlzYWJsZWRcIiwgZmFsc2UpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLnNob3VsZEZvY3VzSW5wdXQodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvY3Vzc2VyLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gc2luZ2xlXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJChcImxhYmVsW2Zvcj0nXCIgKyB0aGlzLmZvY3Vzc2VyLmF0dHIoJ2lkJykgKyBcIiddXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZvcicsIHRoaXMub3B0cy5lbGVtZW50LmF0dHIoXCJpZFwiKSk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5kZXN0cm95LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGNsZWFudXBKUXVlcnlFbGVtZW50cy5jYWxsKHRoaXMsXG4gICAgICAgICAgICAgICAgXCJzZWxlY3Rpb25cIixcbiAgICAgICAgICAgICAgICBcImZvY3Vzc2VyXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gc2luZ2xlXG4gICAgICAgIGluaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbixcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcixcbiAgICAgICAgICAgICAgICBkcm9wZG93biA9IHRoaXMuZHJvcGRvd24sXG4gICAgICAgICAgICAgICAgaWRTdWZmaXggPSBuZXh0VWlkKCksXG4gICAgICAgICAgICAgICAgZWxlbWVudExhYmVsO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLm1pbmltdW1SZXN1bHRzRm9yU2VhcmNoIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvd1NlYXJjaChmYWxzZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvd1NlYXJjaCh0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBzZWxlY3Rpb24gPSBjb250YWluZXIuZmluZChcIi5zZWxlY3QyLWNob2ljZVwiKTtcblxuICAgICAgICAgICAgdGhpcy5mb2N1c3NlciA9IGNvbnRhaW5lci5maW5kKFwiLnNlbGVjdDItZm9jdXNzZXJcIik7XG5cbiAgICAgICAgICAgIC8vIGFkZCBhcmlhIGFzc29jaWF0aW9uc1xuICAgICAgICAgICAgc2VsZWN0aW9uLmZpbmQoXCIuc2VsZWN0Mi1jaG9zZW5cIikuYXR0cihcImlkXCIsIFwic2VsZWN0Mi1jaG9zZW4tXCIraWRTdWZmaXgpO1xuICAgICAgICAgICAgdGhpcy5mb2N1c3Nlci5hdHRyKFwiYXJpYS1sYWJlbGxlZGJ5XCIsIFwic2VsZWN0Mi1jaG9zZW4tXCIraWRTdWZmaXgpO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRzLmF0dHIoXCJpZFwiLCBcInNlbGVjdDItcmVzdWx0cy1cIitpZFN1ZmZpeCk7XG4gICAgICAgICAgICB0aGlzLnNlYXJjaC5hdHRyKFwiYXJpYS1vd25zXCIsIFwic2VsZWN0Mi1yZXN1bHRzLVwiK2lkU3VmZml4KTtcblxuICAgICAgICAgICAgLy8gcmV3cml0ZSBsYWJlbHMgZnJvbSBvcmlnaW5hbCBlbGVtZW50IHRvIGZvY3Vzc2VyXG4gICAgICAgICAgICB0aGlzLmZvY3Vzc2VyLmF0dHIoXCJpZFwiLCBcInMyaWRfYXV0b2dlblwiK2lkU3VmZml4KTtcblxuICAgICAgICAgICAgZWxlbWVudExhYmVsID0gJChcImxhYmVsW2Zvcj0nXCIgKyB0aGlzLm9wdHMuZWxlbWVudC5hdHRyKFwiaWRcIikgKyBcIiddXCIpO1xuICAgICAgICAgICAgdGhpcy5vcHRzLmVsZW1lbnQuZm9jdXModGhpcy5iaW5kKGZ1bmN0aW9uICgpIHsgdGhpcy5mb2N1cygpOyB9KSk7XG5cbiAgICAgICAgICAgIHRoaXMuZm9jdXNzZXIucHJldigpXG4gICAgICAgICAgICAgICAgLnRleHQoZWxlbWVudExhYmVsLnRleHQoKSlcbiAgICAgICAgICAgICAgICAuYXR0cignZm9yJywgdGhpcy5mb2N1c3Nlci5hdHRyKCdpZCcpKTtcblxuICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSBvcmlnaW5hbCBlbGVtZW50IHJldGFpbnMgYW4gYWNjZXNzaWJsZSBuYW1lXG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxUaXRsZSA9IHRoaXMub3B0cy5lbGVtZW50LmF0dHIoXCJ0aXRsZVwiKTtcbiAgICAgICAgICAgIHRoaXMub3B0cy5lbGVtZW50LmF0dHIoXCJ0aXRsZVwiLCAob3JpZ2luYWxUaXRsZSB8fCBlbGVtZW50TGFiZWwudGV4dCgpKSk7XG5cbiAgICAgICAgICAgIHRoaXMuZm9jdXNzZXIuYXR0cihcInRhYmluZGV4XCIsIHRoaXMuZWxlbWVudFRhYkluZGV4KTtcblxuICAgICAgICAgICAgLy8gd3JpdGUgbGFiZWwgZm9yIHNlYXJjaCBmaWVsZCB1c2luZyB0aGUgbGFiZWwgZnJvbSB0aGUgZm9jdXNzZXIgZWxlbWVudFxuICAgICAgICAgICAgdGhpcy5zZWFyY2guYXR0cihcImlkXCIsIHRoaXMuZm9jdXNzZXIuYXR0cignaWQnKSArICdfc2VhcmNoJyk7XG5cbiAgICAgICAgICAgIHRoaXMuc2VhcmNoLnByZXYoKVxuICAgICAgICAgICAgICAgIC50ZXh0KCQoXCJsYWJlbFtmb3I9J1wiICsgdGhpcy5mb2N1c3Nlci5hdHRyKCdpZCcpICsgXCInXVwiKS50ZXh0KCkpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZvcicsIHRoaXMuc2VhcmNoLmF0dHIoJ2lkJykpO1xuXG4gICAgICAgICAgICB0aGlzLnNlYXJjaC5vbihcImtleWRvd25cIiwgdGhpcy5iaW5kKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzSW50ZXJmYWNlRW5hYmxlZCgpKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgMjI5IGtleUNvZGVzIChpbnB1dCBtZXRob2QgZWRpdG9yIGlzIHByb2Nlc3Npbmcga2V5IGlucHV0KVxuICAgICAgICAgICAgICAgIGlmICgyMjkgPT0gZS5rZXlDb2RlKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBpZiAoZS53aGljaCA9PT0gS0VZLlBBR0VfVVAgfHwgZS53aGljaCA9PT0gS0VZLlBBR0VfRE9XTikge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcmV2ZW50IHRoZSBwYWdlIGZyb20gc2Nyb2xsaW5nXG4gICAgICAgICAgICAgICAgICAgIGtpbGxFdmVudChlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZS53aGljaCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEtFWS5VUDpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBLRVkuRE9XTjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZUhpZ2hsaWdodCgoZS53aGljaCA9PT0gS0VZLlVQKSA/IC0xIDogMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBraWxsRXZlbnQoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgS0VZLkVOVEVSOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RIaWdobGlnaHRlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAga2lsbEV2ZW50KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEtFWS5UQUI6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdEhpZ2hsaWdodGVkKHtub0ZvY3VzOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgS0VZLkVTQzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAga2lsbEV2ZW50KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgdGhpcy5zZWFyY2gub24oXCJibHVyXCIsIHRoaXMuYmluZChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgLy8gYSB3b3JrYXJvdW5kIGZvciBjaHJvbWUgdG8ga2VlcCB0aGUgc2VhcmNoIGZpZWxkIGZvY3Vzc2VkIHdoZW4gdGhlIHNjcm9sbCBiYXIgaXMgdXNlZCB0byBzY3JvbGwgdGhlIGRyb3Bkb3duLlxuICAgICAgICAgICAgICAgIC8vIHdpdGhvdXQgdGhpcyB0aGUgc2VhcmNoIGZpZWxkIGxvc2VzIGZvY3VzIHdoaWNoIGlzIGFubm95aW5nXG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMuYm9keS5nZXQoMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQodGhpcy5iaW5kKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3BlbmVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaC5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICB0aGlzLmZvY3Vzc2VyLm9uKFwia2V5ZG93blwiLCB0aGlzLmJpbmQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNJbnRlcmZhY2VFbmFibGVkKCkpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIGlmIChlLndoaWNoID09PSBLRVkuVEFCIHx8IEtFWS5pc0NvbnRyb2woZSkgfHwgS0VZLmlzRnVuY3Rpb25LZXkoZSkgfHwgZS53aGljaCA9PT0gS0VZLkVTQykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5vcGVuT25FbnRlciA9PT0gZmFsc2UgJiYgZS53aGljaCA9PT0gS0VZLkVOVEVSKSB7XG4gICAgICAgICAgICAgICAgICAgIGtpbGxFdmVudChlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChlLndoaWNoID09IEtFWS5ET1dOIHx8IGUud2hpY2ggPT0gS0VZLlVQXG4gICAgICAgICAgICAgICAgICAgIHx8IChlLndoaWNoID09IEtFWS5FTlRFUiAmJiB0aGlzLm9wdHMub3Blbk9uRW50ZXIpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLnNoaWZ0S2V5IHx8IGUubWV0YUtleSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICAgICAgICAgICAgICBraWxsRXZlbnQoZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZS53aGljaCA9PSBLRVkuREVMRVRFIHx8IGUud2hpY2ggPT0gS0VZLkJBQ0tTUEFDRSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRzLmFsbG93Q2xlYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBraWxsRXZlbnQoZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG5cblxuICAgICAgICAgICAgaW5zdGFsbEtleVVwQ2hhbmdlRXZlbnQodGhpcy5mb2N1c3Nlcik7XG4gICAgICAgICAgICB0aGlzLmZvY3Vzc2VyLm9uKFwia2V5dXAtY2hhbmdlIGlucHV0XCIsIHRoaXMuYmluZChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5taW5pbXVtUmVzdWx0c0ZvclNlYXJjaCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wZW5lZCgpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgc2VsZWN0aW9uLm9uKFwibW91c2Vkb3duIHRvdWNoc3RhcnRcIiwgXCJhYmJyXCIsIHRoaXMuYmluZChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0ludGVyZmFjZUVuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICAgICAgICAgIGtpbGxFdmVudEltbWVkaWF0ZWx5KGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgc2VsZWN0aW9uLm9uKFwibW91c2Vkb3duIHRvdWNoc3RhcnRcIiwgdGhpcy5iaW5kKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBJRSBmcm9tIGdlbmVyYXRpbmcgYSBjbGljayBldmVudCBvbiB0aGUgYm9keVxuICAgICAgICAgICAgICAgIHJlaW5zZXJ0RWxlbWVudChzZWxlY3Rpb24pO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRhaW5lci5oYXNDbGFzcyhcInNlbGVjdDItY29udGFpbmVyLWFjdGl2ZVwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdHMuZWxlbWVudC50cmlnZ2VyKCQuRXZlbnQoXCJzZWxlY3QyLWZvY3VzXCIpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcGVuZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzSW50ZXJmYWNlRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGtpbGxFdmVudChlKTtcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgZHJvcGRvd24ub24oXCJtb3VzZWRvd24gdG91Y2hzdGFydFwiLCB0aGlzLmJpbmQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5zaG91bGRGb2N1c0lucHV0KHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICBzZWxlY3Rpb24ub24oXCJmb2N1c1wiLCB0aGlzLmJpbmQoZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGtpbGxFdmVudChlKTtcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgdGhpcy5mb2N1c3Nlci5vbihcImZvY3VzXCIsIHRoaXMuYmluZChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250YWluZXIuaGFzQ2xhc3MoXCJzZWxlY3QyLWNvbnRhaW5lci1hY3RpdmVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRzLmVsZW1lbnQudHJpZ2dlcigkLkV2ZW50KFwic2VsZWN0Mi1mb2N1c1wiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENsYXNzKFwic2VsZWN0Mi1jb250YWluZXItYWN0aXZlXCIpO1xuICAgICAgICAgICAgfSkpLm9uKFwiYmx1clwiLCB0aGlzLmJpbmQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wZW5lZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUNsYXNzKFwic2VsZWN0Mi1jb250YWluZXItYWN0aXZlXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdHMuZWxlbWVudC50cmlnZ2VyKCQuRXZlbnQoXCJzZWxlY3QyLWJsdXJcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoLm9uKFwiZm9jdXNcIiwgdGhpcy5iaW5kKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRhaW5lci5oYXNDbGFzcyhcInNlbGVjdDItY29udGFpbmVyLWFjdGl2ZVwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdHMuZWxlbWVudC50cmlnZ2VyKCQuRXZlbnQoXCJzZWxlY3QyLWZvY3VzXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2xhc3MoXCJzZWxlY3QyLWNvbnRhaW5lci1hY3RpdmVcIik7XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIHRoaXMuaW5pdENvbnRhaW5lcldpZHRoKCk7XG4gICAgICAgICAgICB0aGlzLm9wdHMuZWxlbWVudC5oaWRlKCk7XG4gICAgICAgICAgICB0aGlzLnNldFBsYWNlaG9sZGVyKCk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBzaW5nbGVcbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uKHRyaWdnZXJDaGFuZ2UpIHtcbiAgICAgICAgICAgIHZhciBkYXRhPXRoaXMuc2VsZWN0aW9uLmRhdGEoXCJzZWxlY3QyLWRhdGFcIik7XG4gICAgICAgICAgICBpZiAoZGF0YSkgeyAvLyBndWFyZCBhZ2FpbnN0IHF1ZXVlZCBxdWljayBjb25zZWN1dGl2ZSBjbGlja3NcbiAgICAgICAgICAgICAgICB2YXIgZXZ0ID0gJC5FdmVudChcInNlbGVjdDItY2xlYXJpbmdcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRzLmVsZW1lbnQudHJpZ2dlcihldnQpO1xuICAgICAgICAgICAgICAgIGlmIChldnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcGxhY2Vob2xkZXJPcHRpb24gPSB0aGlzLmdldFBsYWNlaG9sZGVyT3B0aW9uKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRzLmVsZW1lbnQudmFsKHBsYWNlaG9sZGVyT3B0aW9uID8gcGxhY2Vob2xkZXJPcHRpb24udmFsKCkgOiBcIlwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5maW5kKFwiLnNlbGVjdDItY2hvc2VuXCIpLmVtcHR5KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24ucmVtb3ZlRGF0YShcInNlbGVjdDItZGF0YVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFBsYWNlaG9sZGVyKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodHJpZ2dlckNoYW5nZSAhPT0gZmFsc2Upe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdHMuZWxlbWVudC50cmlnZ2VyKHsgdHlwZTogXCJzZWxlY3QyLXJlbW92ZWRcIiwgdmFsOiB0aGlzLmlkKGRhdGEpLCBjaG9pY2U6IGRhdGEgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckNoYW5nZSh7cmVtb3ZlZDpkYXRhfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHNlbGVjdGlvbiBiYXNlZCBvbiBzb3VyY2UgZWxlbWVudCdzIHZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICAvLyBzaW5nbGVcbiAgICAgICAgaW5pdFNlbGVjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNQbGFjZWhvbGRlck9wdGlvblNlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbihudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQbGFjZWhvbGRlcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRzLmluaXRTZWxlY3Rpb24uY2FsbChudWxsLCB0aGlzLm9wdHMuZWxlbWVudCwgZnVuY3Rpb24oc2VsZWN0ZWQpe1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWQgIT09IHVuZGVmaW5lZCAmJiBzZWxlY3RlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi51cGRhdGVTZWxlY3Rpb24oc2VsZWN0ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXRQbGFjZWhvbGRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5uZXh0U2VhcmNoVGVybSA9IHNlbGYub3B0cy5uZXh0U2VhcmNoVGVybShzZWxlY3RlZCwgc2VsZi5zZWFyY2gudmFsKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNQbGFjZWhvbGRlck9wdGlvblNlbGVjdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwbGFjZWhvbGRlck9wdGlvbjtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldFBsYWNlaG9sZGVyKCkgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZhbHNlOyAvLyBubyBwbGFjZWhvbGRlciBzcGVjaWZpZWQgc28gbm8gb3B0aW9uIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgICAgICAgICByZXR1cm4gKChwbGFjZWhvbGRlck9wdGlvbiA9IHRoaXMuZ2V0UGxhY2Vob2xkZXJPcHRpb24oKSkgIT09IHVuZGVmaW5lZCAmJiBwbGFjZWhvbGRlck9wdGlvbi5wcm9wKFwic2VsZWN0ZWRcIikpXG4gICAgICAgICAgICAgICAgfHwgKHRoaXMub3B0cy5lbGVtZW50LnZhbCgpID09PSBcIlwiKVxuICAgICAgICAgICAgICAgIHx8ICh0aGlzLm9wdHMuZWxlbWVudC52YWwoKSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHx8ICh0aGlzLm9wdHMuZWxlbWVudC52YWwoKSA9PT0gbnVsbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gc2luZ2xlXG4gICAgICAgIHByZXBhcmVPcHRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3B0cyA9IHRoaXMucGFyZW50LnByZXBhcmVPcHRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgc2VsZj10aGlzO1xuXG4gICAgICAgICAgICBpZiAob3B0cy5lbGVtZW50LmdldCgwKS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwic2VsZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAvLyBpbnN0YWxsIHRoZSBzZWxlY3Rpb24gaW5pdGlhbGl6ZXJcbiAgICAgICAgICAgICAgICBvcHRzLmluaXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gZWxlbWVudC5maW5kKFwib3B0aW9uXCIpLmZpbHRlcihmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc2VsZWN0ZWQgJiYgIXRoaXMuZGlzYWJsZWQgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGEgc2luZ2xlIHNlbGVjdCBib3ggYWx3YXlzIGhhcyBhIHZhbHVlLCBubyBuZWVkIHRvIG51bGwgY2hlY2sgJ3NlbGVjdGVkJ1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhzZWxmLm9wdGlvblRvRGF0YShzZWxlY3RlZCkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFwiZGF0YVwiIGluIG9wdHMpIHtcbiAgICAgICAgICAgICAgICAvLyBpbnN0YWxsIGRlZmF1bHQgaW5pdFNlbGVjdGlvbiB3aGVuIGFwcGxpZWQgdG8gaGlkZGVuIGlucHV0IGFuZCBkYXRhIGlzIGxvY2FsXG4gICAgICAgICAgICAgICAgb3B0cy5pbml0U2VsZWN0aW9uID0gb3B0cy5pbml0U2VsZWN0aW9uIHx8IGZ1bmN0aW9uIChlbGVtZW50LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBlbGVtZW50LnZhbCgpO1xuICAgICAgICAgICAgICAgICAgICAvL3NlYXJjaCBpbiBkYXRhIGJ5IGlkLCBzdG9yaW5nIHRoZSBhY3R1YWwgbWF0Y2hpbmcgaXRlbVxuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBvcHRzLnF1ZXJ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXI6IGZ1bmN0aW9uKHRlcm0sIHRleHQsIGVsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNfbWF0Y2ggPSBlcXVhbChpZCwgb3B0cy5pZChlbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc19tYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNfbWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6ICEkLmlzRnVuY3Rpb24oY2FsbGJhY2spID8gJC5ub29wIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobWF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3B0cztcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBzaW5nbGVcbiAgICAgICAgZ2V0UGxhY2Vob2xkZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gaWYgYSBwbGFjZWhvbGRlciBpcyBzcGVjaWZpZWQgb24gYSBzaW5nbGUgc2VsZWN0IHdpdGhvdXQgYSB2YWxpZCBwbGFjZWhvbGRlciBvcHRpb24gaWdub3JlIGl0XG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRQbGFjZWhvbGRlck9wdGlvbigpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXRQbGFjZWhvbGRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHNpbmdsZVxuICAgICAgICBzZXRQbGFjZWhvbGRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gdGhpcy5nZXRQbGFjZWhvbGRlcigpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5pc1BsYWNlaG9sZGVyT3B0aW9uU2VsZWN0ZWQoKSAmJiBwbGFjZWhvbGRlciAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgYSBwbGFjZWhvbGRlciBvcHRpb24gaWYgYXR0YWNoZWQgdG8gYSBzZWxlY3RcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3QgJiYgdGhpcy5nZXRQbGFjZWhvbGRlck9wdGlvbigpID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLmZpbmQoXCIuc2VsZWN0Mi1jaG9zZW5cIikuaHRtbCh0aGlzLm9wdHMuZXNjYXBlTWFya3VwKHBsYWNlaG9sZGVyKSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5hZGRDbGFzcyhcInNlbGVjdDItZGVmYXVsdFwiKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUNsYXNzKFwic2VsZWN0Mi1hbGxvd2NsZWFyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHNpbmdsZVxuICAgICAgICBwb3N0cHJvY2Vzc1Jlc3VsdHM6IGZ1bmN0aW9uIChkYXRhLCBpbml0aWFsLCBub0hpZ2hsaWdodFVwZGF0ZSkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gMCwgc2VsZiA9IHRoaXMsIHNob3dTZWFyY2hJbnB1dCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIGZpbmQgdGhlIHNlbGVjdGVkIGVsZW1lbnQgaW4gdGhlIHJlc3VsdCBsaXN0XG5cbiAgICAgICAgICAgIHRoaXMuZmluZEhpZ2hsaWdodGFibGVDaG9pY2VzKCkuZWFjaDIoZnVuY3Rpb24gKGksIGVsbSkge1xuICAgICAgICAgICAgICAgIGlmIChlcXVhbChzZWxmLmlkKGVsbS5kYXRhKFwic2VsZWN0Mi1kYXRhXCIpKSwgc2VsZi5vcHRzLmVsZW1lbnQudmFsKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gaTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBhbmQgaGlnaGxpZ2h0IGl0XG4gICAgICAgICAgICBpZiAobm9IaWdobGlnaHRVcGRhdGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluaXRpYWwgPT09IHRydWUgJiYgc2VsZWN0ZWQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodChzZWxlY3RlZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHQoMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBoaWRlIHRoZSBzZWFyY2ggYm94IGlmIHRoaXMgaXMgdGhlIGZpcnN0IHdlIGdvdCB0aGUgcmVzdWx0cyBhbmQgdGhlcmUgYXJlIGVub3VnaCBvZiB0aGVtIGZvciBzZWFyY2hcblxuICAgICAgICAgICAgaWYgKGluaXRpYWwgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWluID0gdGhpcy5vcHRzLm1pbmltdW1SZXN1bHRzRm9yU2VhcmNoO1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dTZWFyY2goY291bnRSZXN1bHRzKGRhdGEucmVzdWx0cykgPj0gbWluKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gc2luZ2xlXG4gICAgICAgIHNob3dTZWFyY2g6IGZ1bmN0aW9uKHNob3dTZWFyY2hJbnB1dCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2hvd1NlYXJjaElucHV0ID09PSBzaG93U2VhcmNoSW5wdXQpIHJldHVybjtcblxuICAgICAgICAgICAgdGhpcy5zaG93U2VhcmNoSW5wdXQgPSBzaG93U2VhcmNoSW5wdXQ7XG5cbiAgICAgICAgICAgIHRoaXMuZHJvcGRvd24uZmluZChcIi5zZWxlY3QyLXNlYXJjaFwiKS50b2dnbGVDbGFzcyhcInNlbGVjdDItc2VhcmNoLWhpZGRlblwiLCAhc2hvd1NlYXJjaElucHV0KTtcbiAgICAgICAgICAgIHRoaXMuZHJvcGRvd24uZmluZChcIi5zZWxlY3QyLXNlYXJjaFwiKS50b2dnbGVDbGFzcyhcInNlbGVjdDItb2Zmc2NyZWVuXCIsICFzaG93U2VhcmNoSW5wdXQpO1xuICAgICAgICAgICAgLy9hZGQgXCJzZWxlY3QyLXdpdGgtc2VhcmNoYm94XCIgdG8gdGhlIGNvbnRhaW5lciBpZiBzZWFyY2ggYm94IGlzIHNob3duXG4gICAgICAgICAgICAkKHRoaXMuZHJvcGRvd24sIHRoaXMuY29udGFpbmVyKS50b2dnbGVDbGFzcyhcInNlbGVjdDItd2l0aC1zZWFyY2hib3hcIiwgc2hvd1NlYXJjaElucHV0KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBzaW5nbGVcbiAgICAgICAgb25TZWxlY3Q6IGZ1bmN0aW9uIChkYXRhLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy50cmlnZ2VyU2VsZWN0KGRhdGEpKSB7IHJldHVybjsgfVxuXG4gICAgICAgICAgICB2YXIgb2xkID0gdGhpcy5vcHRzLmVsZW1lbnQudmFsKCksXG4gICAgICAgICAgICAgICAgb2xkRGF0YSA9IHRoaXMuZGF0YSgpO1xuXG4gICAgICAgICAgICB0aGlzLm9wdHMuZWxlbWVudC52YWwodGhpcy5pZChkYXRhKSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbihkYXRhKTtcblxuICAgICAgICAgICAgdGhpcy5vcHRzLmVsZW1lbnQudHJpZ2dlcih7IHR5cGU6IFwic2VsZWN0Mi1zZWxlY3RlZFwiLCB2YWw6IHRoaXMuaWQoZGF0YSksIGNob2ljZTogZGF0YSB9KTtcblxuICAgICAgICAgICAgdGhpcy5uZXh0U2VhcmNoVGVybSA9IHRoaXMub3B0cy5uZXh0U2VhcmNoVGVybShkYXRhLCB0aGlzLnNlYXJjaC52YWwoKSk7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG5cbiAgICAgICAgICAgIGlmICgoIW9wdGlvbnMgfHwgIW9wdGlvbnMubm9Gb2N1cykgJiYgdGhpcy5vcHRzLnNob3VsZEZvY3VzSW5wdXQodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvY3Vzc2VyLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZXF1YWwob2xkLCB0aGlzLmlkKGRhdGEpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckNoYW5nZSh7IGFkZGVkOiBkYXRhLCByZW1vdmVkOiBvbGREYXRhIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHNpbmdsZVxuICAgICAgICB1cGRhdGVTZWxlY3Rpb246IGZ1bmN0aW9uIChkYXRhKSB7XG5cbiAgICAgICAgICAgIHZhciBjb250YWluZXI9dGhpcy5zZWxlY3Rpb24uZmluZChcIi5zZWxlY3QyLWNob3NlblwiKSwgZm9ybWF0dGVkLCBjc3NDbGFzcztcblxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uZGF0YShcInNlbGVjdDItZGF0YVwiLCBkYXRhKTtcblxuICAgICAgICAgICAgY29udGFpbmVyLmVtcHR5KCk7XG4gICAgICAgICAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZD10aGlzLm9wdHMuZm9ybWF0U2VsZWN0aW9uKGRhdGEsIGNvbnRhaW5lciwgdGhpcy5vcHRzLmVzY2FwZU1hcmt1cCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9ybWF0dGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kKGZvcm1hdHRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjc3NDbGFzcz10aGlzLm9wdHMuZm9ybWF0U2VsZWN0aW9uQ3NzQ2xhc3MoZGF0YSwgY29udGFpbmVyKTtcbiAgICAgICAgICAgIGlmIChjc3NDbGFzcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmFkZENsYXNzKGNzc0NsYXNzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24ucmVtb3ZlQ2xhc3MoXCJzZWxlY3QyLWRlZmF1bHRcIik7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuYWxsb3dDbGVhciAmJiB0aGlzLmdldFBsYWNlaG9sZGVyKCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENsYXNzKFwic2VsZWN0Mi1hbGxvd2NsZWFyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHNpbmdsZVxuICAgICAgICB2YWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YWwsXG4gICAgICAgICAgICAgICAgdHJpZ2dlckNoYW5nZSA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIGRhdGEgPSBudWxsLFxuICAgICAgICAgICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgICAgIG9sZERhdGEgPSB0aGlzLmRhdGEoKTtcblxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRzLmVsZW1lbnQudmFsKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbCA9IGFyZ3VtZW50c1swXTtcblxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdHJpZ2dlckNoYW5nZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RcbiAgICAgICAgICAgICAgICAgICAgLnZhbCh2YWwpXG4gICAgICAgICAgICAgICAgICAgIC5maW5kKFwib3B0aW9uXCIpLmZpbHRlcihmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc2VsZWN0ZWQgfSkuZWFjaDIoZnVuY3Rpb24gKGksIGVsbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHNlbGYub3B0aW9uVG9EYXRhKGVsbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2VsZWN0aW9uKGRhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UGxhY2Vob2xkZXIoKTtcbiAgICAgICAgICAgICAgICBpZiAodHJpZ2dlckNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJDaGFuZ2Uoe2FkZGVkOiBkYXRhLCByZW1vdmVkOm9sZERhdGF9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHZhbCBpcyBhbiBpZC4gIXZhbCBpcyB0cnVlIGZvciBbdW5kZWZpbmVkLG51bGwsJycsMF0gLSAwIGlzIGxlZ2FsXG4gICAgICAgICAgICAgICAgaWYgKCF2YWwgJiYgdmFsICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXIodHJpZ2dlckNoYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5pbml0U2VsZWN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGNhbGwgdmFsKCkgaWYgaW5pdFNlbGVjdGlvbigpIGlzIG5vdCBkZWZpbmVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm9wdHMuZWxlbWVudC52YWwodmFsKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdHMuaW5pdFNlbGVjdGlvbih0aGlzLm9wdHMuZWxlbWVudCwgZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYub3B0cy5lbGVtZW50LnZhbCghZGF0YSA/IFwiXCIgOiBzZWxmLmlkKGRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi51cGRhdGVTZWxlY3Rpb24oZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0UGxhY2Vob2xkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyaWdnZXJDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlckNoYW5nZSh7YWRkZWQ6IGRhdGEsIHJlbW92ZWQ6b2xkRGF0YX0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gc2luZ2xlXG4gICAgICAgIGNsZWFyU2VhcmNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnNlYXJjaC52YWwoXCJcIik7XG4gICAgICAgICAgICB0aGlzLmZvY3Vzc2VyLnZhbChcIlwiKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBzaW5nbGVcbiAgICAgICAgZGF0YTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBkYXRhLFxuICAgICAgICAgICAgICAgIHRyaWdnZXJDaGFuZ2UgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5zZWxlY3Rpb24uZGF0YShcInNlbGVjdDItZGF0YVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSA9PSB1bmRlZmluZWQpIGRhdGEgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckNoYW5nZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyKHRyaWdnZXJDaGFuZ2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRzLmVsZW1lbnQudmFsKCF2YWx1ZSA/IFwiXCIgOiB0aGlzLmlkKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2VsZWN0aW9uKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyaWdnZXJDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckNoYW5nZSh7YWRkZWQ6IHZhbHVlLCByZW1vdmVkOmRhdGF9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgTXVsdGlTZWxlY3QyID0gY2xhenooQWJzdHJhY3RTZWxlY3QyLCB7XG5cbiAgICAgICAgLy8gbXVsdGlcbiAgICAgICAgY3JlYXRlQ29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gJChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKS5hdHRyKHtcbiAgICAgICAgICAgICAgICBcImNsYXNzXCI6IFwic2VsZWN0Mi1jb250YWluZXIgc2VsZWN0Mi1jb250YWluZXItbXVsdGlcIlxuICAgICAgICAgICAgfSkuaHRtbChbXG4gICAgICAgICAgICAgICAgXCI8dWwgY2xhc3M9J3NlbGVjdDItY2hvaWNlcyc+XCIsXG4gICAgICAgICAgICAgICAgXCIgIDxsaSBjbGFzcz0nc2VsZWN0Mi1zZWFyY2gtZmllbGQnPlwiLFxuICAgICAgICAgICAgICAgIFwiICAgIDxsYWJlbCBmb3I9JycgY2xhc3M9J3NlbGVjdDItb2Zmc2NyZWVuJz48L2xhYmVsPlwiLFxuICAgICAgICAgICAgICAgIFwiICAgIDxpbnB1dCB0eXBlPSd0ZXh0JyBhdXRvY29tcGxldGU9J29mZicgYXV0b2NvcnJlY3Q9J29mZicgYXV0b2NhcGl0YWxpemU9J29mZicgc3BlbGxjaGVjaz0nZmFsc2UnIGNsYXNzPSdzZWxlY3QyLWlucHV0Jz5cIixcbiAgICAgICAgICAgICAgICBcIiAgPC9saT5cIixcbiAgICAgICAgICAgICAgICBcIjwvdWw+XCIsXG4gICAgICAgICAgICAgICAgXCI8ZGl2IGNsYXNzPSdzZWxlY3QyLWRyb3Agc2VsZWN0Mi1kcm9wLW11bHRpIHNlbGVjdDItZGlzcGxheS1ub25lJz5cIixcbiAgICAgICAgICAgICAgICBcIiAgIDx1bCBjbGFzcz0nc2VsZWN0Mi1yZXN1bHRzJz5cIixcbiAgICAgICAgICAgICAgICBcIiAgIDwvdWw+XCIsXG4gICAgICAgICAgICAgICAgXCI8L2Rpdj5cIl0uam9pbihcIlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIG11bHRpXG4gICAgICAgIHByZXBhcmVPcHRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3B0cyA9IHRoaXMucGFyZW50LnByZXBhcmVPcHRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgc2VsZj10aGlzO1xuXG4gICAgICAgICAgICAvLyBUT0RPIHZhbGlkYXRlIHBsYWNlaG9sZGVyIGlzIGEgc3RyaW5nIGlmIHNwZWNpZmllZFxuICAgICAgICAgICAgaWYgKG9wdHMuZWxlbWVudC5nZXQoMCkudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInNlbGVjdFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5zdGFsbCB0aGUgc2VsZWN0aW9uIGluaXRpYWxpemVyXG4gICAgICAgICAgICAgICAgb3B0cy5pbml0U2VsZWN0aW9uID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNhbGxiYWNrKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmZpbmQoXCJvcHRpb25cIikuZmlsdGVyKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5zZWxlY3RlZCAmJiAhdGhpcy5kaXNhYmxlZCB9KS5lYWNoMihmdW5jdGlvbiAoaSwgZWxtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2goc2VsZi5vcHRpb25Ub0RhdGEoZWxtKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcImRhdGFcIiBpbiBvcHRzKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5zdGFsbCBkZWZhdWx0IGluaXRTZWxlY3Rpb24gd2hlbiBhcHBsaWVkIHRvIGhpZGRlbiBpbnB1dCBhbmQgZGF0YSBpcyBsb2NhbFxuICAgICAgICAgICAgICAgIG9wdHMuaW5pdFNlbGVjdGlvbiA9IG9wdHMuaW5pdFNlbGVjdGlvbiB8fCBmdW5jdGlvbiAoZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkcyA9IHNwbGl0VmFsKGVsZW1lbnQudmFsKCksIG9wdHMuc2VwYXJhdG9yLCBvcHRzLnRyYW5zZm9ybVZhbCk7XG4gICAgICAgICAgICAgICAgICAgIC8vc2VhcmNoIGluIGRhdGEgYnkgYXJyYXkgb2YgaWRzLCBzdG9yaW5nIG1hdGNoaW5nIGl0ZW1zIGluIGEgbGlzdFxuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBvcHRzLnF1ZXJ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXI6IGZ1bmN0aW9uKHRlcm0sIHRleHQsIGVsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNfbWF0Y2ggPSAkLmdyZXAoaWRzLCBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXF1YWwoaWQsIG9wdHMuaWQoZWwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzX21hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaChlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc19tYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogISQuaXNGdW5jdGlvbihjYWxsYmFjaykgPyAkLm5vb3AgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW9yZGVyIG1hdGNoZXMgYmFzZWQgb24gdGhlIG9yZGVyIHRoZXkgYXBwZWFyIGluIHRoZSBpZHMgYXJyYXkgYmVjYXVzZSByaWdodCBub3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGV5IGFyZSBpbiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBhcHBlYXIgaW4gZGF0YSBhcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcmRlcmVkID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1hdGNoZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IG1hdGNoZXNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXF1YWwoaWQsIG9wdHMuaWQobWF0Y2gpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyZWQucHVzaChtYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcy5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sob3JkZXJlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvcHRzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIG11bHRpXG4gICAgICAgIHNlbGVjdENob2ljZTogZnVuY3Rpb24gKGNob2ljZSkge1xuXG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSB0aGlzLmNvbnRhaW5lci5maW5kKFwiLnNlbGVjdDItc2VhcmNoLWNob2ljZS1mb2N1c1wiKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZC5sZW5ndGggJiYgY2hvaWNlICYmIGNob2ljZVswXSA9PSBzZWxlY3RlZFswXSkge1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRzLmVsZW1lbnQudHJpZ2dlcihcImNob2ljZS1kZXNlbGVjdGVkXCIsIHNlbGVjdGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQucmVtb3ZlQ2xhc3MoXCJzZWxlY3QyLXNlYXJjaC1jaG9pY2UtZm9jdXNcIik7XG4gICAgICAgICAgICAgICAgaWYgKGNob2ljZSAmJiBjaG9pY2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgY2hvaWNlLmFkZENsYXNzKFwic2VsZWN0Mi1zZWFyY2gtY2hvaWNlLWZvY3VzXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdHMuZWxlbWVudC50cmlnZ2VyKFwiY2hvaWNlLXNlbGVjdGVkXCIsIGNob2ljZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIG11bHRpXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJChcImxhYmVsW2Zvcj0nXCIgKyB0aGlzLnNlYXJjaC5hdHRyKCdpZCcpICsgXCInXVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdmb3InLCB0aGlzLm9wdHMuZWxlbWVudC5hdHRyKFwiaWRcIikpO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuZGVzdHJveS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBjbGVhbnVwSlF1ZXJ5RWxlbWVudHMuY2FsbCh0aGlzLFxuICAgICAgICAgICAgICAgIFwic2VhcmNoQ29udGFpbmVyXCIsXG4gICAgICAgICAgICAgICAgXCJzZWxlY3Rpb25cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBtdWx0aVxuICAgICAgICBpbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IFwiLnNlbGVjdDItY2hvaWNlc1wiLCBzZWxlY3Rpb247XG5cbiAgICAgICAgICAgIHRoaXMuc2VhcmNoQ29udGFpbmVyID0gdGhpcy5jb250YWluZXIuZmluZChcIi5zZWxlY3QyLXNlYXJjaC1maWVsZFwiKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gc2VsZWN0aW9uID0gdGhpcy5jb250YWluZXIuZmluZChzZWxlY3Rvcik7XG5cbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5vbihcImNsaWNrXCIsIFwiLnNlbGVjdDItY29udGFpbmVyOm5vdCguc2VsZWN0Mi1jb250YWluZXItZGlzYWJsZWQpIC5zZWxlY3QyLXNlYXJjaC1jaG9pY2U6bm90KC5zZWxlY3QyLWxvY2tlZClcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZWFyY2hbMF0uZm9jdXMoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZWxlY3RDaG9pY2UoJCh0aGlzKSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gcmV3cml0ZSBsYWJlbHMgZnJvbSBvcmlnaW5hbCBlbGVtZW50IHRvIGZvY3Vzc2VyXG4gICAgICAgICAgICB0aGlzLnNlYXJjaC5hdHRyKFwiaWRcIiwgXCJzMmlkX2F1dG9nZW5cIituZXh0VWlkKCkpO1xuXG4gICAgICAgICAgICB0aGlzLnNlYXJjaC5wcmV2KClcbiAgICAgICAgICAgICAgICAudGV4dCgkKFwibGFiZWxbZm9yPSdcIiArIHRoaXMub3B0cy5lbGVtZW50LmF0dHIoXCJpZFwiKSArIFwiJ11cIikudGV4dCgpKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdmb3InLCB0aGlzLnNlYXJjaC5hdHRyKCdpZCcpKTtcbiAgICAgICAgICAgIHRoaXMub3B0cy5lbGVtZW50LmZvY3VzKHRoaXMuYmluZChmdW5jdGlvbiAoKSB7IHRoaXMuZm9jdXMoKTsgfSkpO1xuXG4gICAgICAgICAgICB0aGlzLnNlYXJjaC5vbihcImlucHV0IHBhc3RlXCIsIHRoaXMuYmluZChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWFyY2guYXR0cigncGxhY2Vob2xkZXInKSAmJiB0aGlzLnNlYXJjaC52YWwoKS5sZW5ndGggPT0gMCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0ludGVyZmFjZUVuYWJsZWQoKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5vcGVuZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIHRoaXMuc2VhcmNoLmF0dHIoXCJ0YWJpbmRleFwiLCB0aGlzLmVsZW1lbnRUYWJJbmRleCk7XG5cbiAgICAgICAgICAgIHRoaXMua2V5ZG93bnMgPSAwO1xuICAgICAgICAgICAgdGhpcy5zZWFyY2gub24oXCJrZXlkb3duXCIsIHRoaXMuYmluZChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0ludGVyZmFjZUVuYWJsZWQoKSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgKyt0aGlzLmtleWRvd25zO1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IHNlbGVjdGlvbi5maW5kKFwiLnNlbGVjdDItc2VhcmNoLWNob2ljZS1mb2N1c1wiKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJldiA9IHNlbGVjdGVkLnByZXYoXCIuc2VsZWN0Mi1zZWFyY2gtY2hvaWNlOm5vdCguc2VsZWN0Mi1sb2NrZWQpXCIpO1xuICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gc2VsZWN0ZWQubmV4dChcIi5zZWxlY3QyLXNlYXJjaC1jaG9pY2U6bm90KC5zZWxlY3QyLWxvY2tlZClcIik7XG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IGdldEN1cnNvckluZm8odGhpcy5zZWFyY2gpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAoZS53aGljaCA9PSBLRVkuTEVGVCB8fCBlLndoaWNoID09IEtFWS5SSUdIVCB8fCBlLndoaWNoID09IEtFWS5CQUNLU1BBQ0UgfHwgZS53aGljaCA9PSBLRVkuREVMRVRFIHx8IGUud2hpY2ggPT0gS0VZLkVOVEVSKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWRDaG9pY2UgPSBzZWxlY3RlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUud2hpY2ggPT0gS0VZLkxFRlQgJiYgcHJldi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkQ2hvaWNlID0gcHJldjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlLndoaWNoID09IEtFWS5SSUdIVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRDaG9pY2UgPSBuZXh0Lmxlbmd0aCA/IG5leHQgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGUud2hpY2ggPT09IEtFWS5CQUNLU1BBQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnVuc2VsZWN0KHNlbGVjdGVkLmZpcnN0KCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWFyY2gud2lkdGgoMTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkQ2hvaWNlID0gcHJldi5sZW5ndGggPyBwcmV2IDogbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlLndoaWNoID09IEtFWS5ERUxFVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnVuc2VsZWN0KHNlbGVjdGVkLmZpcnN0KCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWFyY2gud2lkdGgoMTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkQ2hvaWNlID0gbmV4dC5sZW5ndGggPyBuZXh0IDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlLndoaWNoID09IEtFWS5FTlRFUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRDaG9pY2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RDaG9pY2Uoc2VsZWN0ZWRDaG9pY2UpO1xuICAgICAgICAgICAgICAgICAgICBraWxsRXZlbnQoZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VsZWN0ZWRDaG9pY2UgfHwgIXNlbGVjdGVkQ2hvaWNlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKChlLndoaWNoID09PSBLRVkuQkFDS1NQQUNFICYmIHRoaXMua2V5ZG93bnMgPT0gMSlcbiAgICAgICAgICAgICAgICAgICAgfHwgZS53aGljaCA9PSBLRVkuTEVGVCkgJiYgKHBvcy5vZmZzZXQgPT0gMCAmJiAhcG9zLmxlbmd0aCkpIHtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdENob2ljZShzZWxlY3Rpb24uZmluZChcIi5zZWxlY3QyLXNlYXJjaC1jaG9pY2U6bm90KC5zZWxlY3QyLWxvY2tlZClcIikubGFzdCgpKTtcbiAgICAgICAgICAgICAgICAgICAga2lsbEV2ZW50KGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RDaG9pY2UobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3BlbmVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChlLndoaWNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgS0VZLlVQOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIEtFWS5ET1dOOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlSGlnaGxpZ2h0KChlLndoaWNoID09PSBLRVkuVVApID8gLTEgOiAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbGxFdmVudChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBLRVkuRU5URVI6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdEhpZ2hsaWdodGVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBraWxsRXZlbnQoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgS0VZLlRBQjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0SGlnaGxpZ2h0ZWQoe25vRm9jdXM6dHJ1ZX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEtFWS5FU0M6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbGxFdmVudChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChlLndoaWNoID09PSBLRVkuVEFCIHx8IEtFWS5pc0NvbnRyb2woZSkgfHwgS0VZLmlzRnVuY3Rpb25LZXkoZSlcbiAgICAgICAgICAgICAgICAgfHwgZS53aGljaCA9PT0gS0VZLkJBQ0tTUEFDRSB8fCBlLndoaWNoID09PSBLRVkuRVNDKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZS53aGljaCA9PT0gS0VZLkVOVEVSKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdHMub3Blbk9uRW50ZXIgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5hbHRLZXkgfHwgZS5jdHJsS2V5IHx8IGUuc2hpZnRLZXkgfHwgZS5tZXRhS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLm9wZW4oKTtcblxuICAgICAgICAgICAgICAgIGlmIChlLndoaWNoID09PSBLRVkuUEFHRV9VUCB8fCBlLndoaWNoID09PSBLRVkuUEFHRV9ET1dOKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgdGhlIHBhZ2UgZnJvbSBzY3JvbGxpbmdcbiAgICAgICAgICAgICAgICAgICAga2lsbEV2ZW50KGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChlLndoaWNoID09PSBLRVkuRU5URVIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJldmVudCBmb3JtIGZyb20gYmVpbmcgc3VibWl0dGVkXG4gICAgICAgICAgICAgICAgICAgIGtpbGxFdmVudChlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgdGhpcy5zZWFyY2gub24oXCJrZXl1cFwiLCB0aGlzLmJpbmQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmtleWRvd25zID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZVNlYXJjaCgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRoaXMuc2VhcmNoLm9uKFwiYmx1clwiLCB0aGlzLmJpbmQoZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUNsYXNzKFwic2VsZWN0Mi1jb250YWluZXItYWN0aXZlXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoLnJlbW92ZUNsYXNzKFwic2VsZWN0Mi1mb2N1c2VkXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0Q2hvaWNlKG51bGwpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5vcGVuZWQoKSkgdGhpcy5jbGVhclNlYXJjaCgpO1xuICAgICAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRzLmVsZW1lbnQudHJpZ2dlcigkLkV2ZW50KFwic2VsZWN0Mi1ibHVyXCIpKTtcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIub24oXCJjbGlja1wiLCBzZWxlY3RvciwgdGhpcy5iaW5kKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzSW50ZXJmYWNlRW5hYmxlZCgpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKCQoZS50YXJnZXQpLmNsb3Nlc3QoXCIuc2VsZWN0Mi1zZWFyY2gtY2hvaWNlXCIpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2xpY2tlZCBpbnNpZGUgYSBzZWxlY3QyIHNlYXJjaCBjaG9pY2UsIGRvIG5vdCBvcGVuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RDaG9pY2UobnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclBsYWNlaG9sZGVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRhaW5lci5oYXNDbGFzcyhcInNlbGVjdDItY29udGFpbmVyLWFjdGl2ZVwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdHMuZWxlbWVudC50cmlnZ2VyKCQuRXZlbnQoXCJzZWxlY3QyLWZvY3VzXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c1NlYXJjaCgpO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIub24oXCJmb2N1c1wiLCBzZWxlY3RvciwgdGhpcy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNJbnRlcmZhY2VFbmFibGVkKCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGFpbmVyLmhhc0NsYXNzKFwic2VsZWN0Mi1jb250YWluZXItYWN0aXZlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0cy5lbGVtZW50LnRyaWdnZXIoJC5FdmVudChcInNlbGVjdDItZm9jdXNcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRDbGFzcyhcInNlbGVjdDItY29udGFpbmVyLWFjdGl2ZVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyb3Bkb3duLmFkZENsYXNzKFwic2VsZWN0Mi1kcm9wLWFjdGl2ZVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyUGxhY2Vob2xkZXIoKTtcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgdGhpcy5pbml0Q29udGFpbmVyV2lkdGgoKTtcbiAgICAgICAgICAgIHRoaXMub3B0cy5lbGVtZW50LmhpZGUoKTtcblxuICAgICAgICAgICAgLy8gc2V0IHRoZSBwbGFjZWhvbGRlciBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgIHRoaXMuY2xlYXJTZWFyY2goKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBtdWx0aVxuICAgICAgICBlbmFibGVJbnRlcmZhY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50LmVuYWJsZUludGVyZmFjZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWFyY2gucHJvcChcImRpc2FibGVkXCIsICF0aGlzLmlzSW50ZXJmYWNlRW5hYmxlZCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBtdWx0aVxuICAgICAgICBpbml0U2VsZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuZWxlbWVudC52YWwoKSA9PT0gXCJcIiAmJiB0aGlzLm9wdHMuZWxlbWVudC50ZXh0KCkgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbihbXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIC8vIHNldCB0aGUgcGxhY2Vob2xkZXIgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclNlYXJjaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0IHx8IHRoaXMub3B0cy5lbGVtZW50LnZhbCgpICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMub3B0cy5pbml0U2VsZWN0aW9uLmNhbGwobnVsbCwgdGhpcy5vcHRzLmVsZW1lbnQsIGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkICYmIGRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlU2VsZWN0aW9uKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IHRoZSBwbGFjZWhvbGRlciBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2xlYXJTZWFyY2goKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIG11bHRpXG4gICAgICAgIGNsZWFyU2VhcmNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSB0aGlzLmdldFBsYWNlaG9sZGVyKCksXG4gICAgICAgICAgICAgICAgbWF4V2lkdGggPSB0aGlzLmdldE1heFNlYXJjaFdpZHRoKCk7XG5cbiAgICAgICAgICAgIGlmIChwbGFjZWhvbGRlciAhPT0gdW5kZWZpbmVkICAmJiB0aGlzLmdldFZhbCgpLmxlbmd0aCA9PT0gMCAmJiB0aGlzLnNlYXJjaC5oYXNDbGFzcyhcInNlbGVjdDItZm9jdXNlZFwiKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaC52YWwocGxhY2Vob2xkZXIpLmFkZENsYXNzKFwic2VsZWN0Mi1kZWZhdWx0XCIpO1xuICAgICAgICAgICAgICAgIC8vIHN0cmV0Y2ggdGhlIHNlYXJjaCBib3ggdG8gZnVsbCB3aWR0aCBvZiB0aGUgY29udGFpbmVyIHNvIGFzIG11Y2ggb2YgdGhlIHBsYWNlaG9sZGVyIGlzIHZpc2libGUgYXMgcG9zc2libGVcbiAgICAgICAgICAgICAgICAvLyB3ZSBjb3VsZCBjYWxsIHRoaXMucmVzaXplU2VhcmNoKCksIGJ1dCB3ZSBkbyBub3QgYmVjYXVzZSB0aGF0IHJlcXVpcmVzIGEgc2l6ZXIgYW5kIHdlIGRvIG5vdCB3YW50IHRvIGNyZWF0ZSBvbmUgc28gZWFybHkgYmVjYXVzZSBvZiBhIGZpcmVmb3ggYnVnLCBzZWUgIzk0NFxuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoLndpZHRoKG1heFdpZHRoID4gMCA/IG1heFdpZHRoIDogdGhpcy5jb250YWluZXIuY3NzKFwid2lkdGhcIikpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaC52YWwoXCJcIikud2lkdGgoMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIG11bHRpXG4gICAgICAgIGNsZWFyUGxhY2Vob2xkZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlYXJjaC5oYXNDbGFzcyhcInNlbGVjdDItZGVmYXVsdFwiKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoLnZhbChcIlwiKS5yZW1vdmVDbGFzcyhcInNlbGVjdDItZGVmYXVsdFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBtdWx0aVxuICAgICAgICBvcGVuaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyUGxhY2Vob2xkZXIoKTsgLy8gc2hvdWxkIGJlIGRvbmUgYmVmb3JlIHN1cGVyIHNvIHBsYWNlaG9sZGVyIGlzIG5vdCB1c2VkIHRvIHNlYXJjaFxuICAgICAgICAgICAgdGhpcy5yZXNpemVTZWFyY2goKTtcblxuICAgICAgICAgICAgdGhpcy5wYXJlbnQub3BlbmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICB0aGlzLmZvY3VzU2VhcmNoKCk7XG5cbiAgICAgICAgICAgIC8vIGluaXRpYWxpemVzIHNlYXJjaCdzIHZhbHVlIHdpdGggbmV4dFNlYXJjaFRlcm0gKGlmIGRlZmluZWQgYnkgdXNlcilcbiAgICAgICAgICAgIC8vIGlnbm9yZSBuZXh0U2VhcmNoVGVybSBpZiB0aGUgZHJvcGRvd24gaXMgb3BlbmVkIGJ5IHRoZSB1c2VyIHByZXNzaW5nIGEgbGV0dGVyXG4gICAgICAgICAgICBpZih0aGlzLnNlYXJjaC52YWwoKSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGlmKHRoaXMubmV4dFNlYXJjaFRlcm0gIT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWFyY2gudmFsKHRoaXMubmV4dFNlYXJjaFRlcm0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaC5zZWxlY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlUmVzdWx0cyh0cnVlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuc2hvdWxkRm9jdXNJbnB1dCh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9wdHMuZWxlbWVudC50cmlnZ2VyKCQuRXZlbnQoXCJzZWxlY3QyLW9wZW5cIikpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIG11bHRpXG4gICAgICAgIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMub3BlbmVkKCkpIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmNsb3NlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gbXVsdGlcbiAgICAgICAgZm9jdXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoLmZvY3VzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gbXVsdGlcbiAgICAgICAgaXNGb2N1c2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2guaGFzQ2xhc3MoXCJzZWxlY3QyLWZvY3VzZWRcIik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gbXVsdGlcbiAgICAgICAgdXBkYXRlU2VsZWN0aW9uOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdmFyIGlkcyA9IFtdLCBmaWx0ZXJlZCA9IFtdLCBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgLy8gZmlsdGVyIG91dCBkdXBsaWNhdGVzXG4gICAgICAgICAgICAkKGRhdGEpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleE9mKHNlbGYuaWQodGhpcyksIGlkcykgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkcy5wdXNoKHNlbGYuaWQodGhpcykpO1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZC5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGF0YSA9IGZpbHRlcmVkO1xuXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5maW5kKFwiLnNlbGVjdDItc2VhcmNoLWNob2ljZVwiKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICQoZGF0YSkuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5hZGRTZWxlY3RlZENob2ljZSh0aGlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZi5wb3N0cHJvY2Vzc1Jlc3VsdHMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBtdWx0aVxuICAgICAgICB0b2tlbml6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLnNlYXJjaC52YWwoKTtcbiAgICAgICAgICAgIGlucHV0ID0gdGhpcy5vcHRzLnRva2VuaXplci5jYWxsKHRoaXMsIGlucHV0LCB0aGlzLmRhdGEoKSwgdGhpcy5iaW5kKHRoaXMub25TZWxlY3QpLCB0aGlzLm9wdHMpO1xuICAgICAgICAgICAgaWYgKGlucHV0ICE9IG51bGwgJiYgaW5wdXQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWFyY2gudmFsKGlucHV0KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBtdWx0aVxuICAgICAgICBvblNlbGVjdDogZnVuY3Rpb24gKGRhdGEsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLnRyaWdnZXJTZWxlY3QoZGF0YSkgfHwgZGF0YS50ZXh0ID09PSBcIlwiKSB7IHJldHVybjsgfVxuXG4gICAgICAgICAgICB0aGlzLmFkZFNlbGVjdGVkQ2hvaWNlKGRhdGEpO1xuXG4gICAgICAgICAgICB0aGlzLm9wdHMuZWxlbWVudC50cmlnZ2VyKHsgdHlwZTogXCJzZWxlY3RlZFwiLCB2YWw6IHRoaXMuaWQoZGF0YSksIGNob2ljZTogZGF0YSB9KTtcblxuICAgICAgICAgICAgLy8ga2VlcCB0cmFjayBvZiB0aGUgc2VhcmNoJ3MgdmFsdWUgYmVmb3JlIGl0IGdldHMgY2xlYXJlZFxuICAgICAgICAgICAgdGhpcy5uZXh0U2VhcmNoVGVybSA9IHRoaXMub3B0cy5uZXh0U2VhcmNoVGVybShkYXRhLCB0aGlzLnNlYXJjaC52YWwoKSk7XG5cbiAgICAgICAgICAgIHRoaXMuY2xlYXJTZWFyY2goKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUmVzdWx0cygpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3QgfHwgIXRoaXMub3B0cy5jbG9zZU9uU2VsZWN0KSB0aGlzLnBvc3Rwcm9jZXNzUmVzdWx0cyhkYXRhLCBmYWxzZSwgdGhpcy5vcHRzLmNsb3NlT25TZWxlY3Q9PT10cnVlKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5jbG9zZU9uU2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoLndpZHRoKDEwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY291bnRTZWxlY3RhYmxlUmVzdWx0cygpPjApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWFyY2gud2lkdGgoMTApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZVNlYXJjaCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRNYXhpbXVtU2VsZWN0aW9uU2l6ZSgpID4gMCAmJiB0aGlzLnZhbCgpLmxlbmd0aCA+PSB0aGlzLmdldE1heGltdW1TZWxlY3Rpb25TaXplKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIHJlYWNoZWQgbWF4IHNlbGVjdGlvbiBzaXplIHJlcGFpbnQgdGhlIHJlc3VsdHMgc28gY2hvaWNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJlIHJlcGxhY2VkIHdpdGggdGhlIG1heCBzZWxlY3Rpb24gcmVhY2hlZCBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVJlc3VsdHModHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXplcyBzZWFyY2gncyB2YWx1ZSB3aXRoIG5leHRTZWFyY2hUZXJtIGFuZCB1cGRhdGUgc2VhcmNoIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5uZXh0U2VhcmNoVGVybSAhPSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoLnZhbCh0aGlzLm5leHRTZWFyY2hUZXJtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVJlc3VsdHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaC5zZWxlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uRHJvcGRvd24oKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBub3RoaW5nIGxlZnQgdG8gc2VsZWN0IGNsb3NlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWFyY2gud2lkdGgoMTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2luY2UgaXRzIG5vdCBwb3NzaWJsZSB0byBzZWxlY3QgYW4gZWxlbWVudCB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cbiAgICAgICAgICAgIC8vIGFkZGVkIHdlIGRvIG5vdCBuZWVkIHRvIGNoZWNrIGlmIHRoaXMgaXMgYSBuZXcgZWxlbWVudCBiZWZvcmUgZmlyaW5nIGNoYW5nZVxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyQ2hhbmdlKHsgYWRkZWQ6IGRhdGEgfSk7XG5cbiAgICAgICAgICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5ub0ZvY3VzKVxuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXNTZWFyY2goKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBtdWx0aVxuICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNTZWFyY2goKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZGRTZWxlY3RlZENob2ljZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBlbmFibGVDaG9pY2UgPSAhZGF0YS5sb2NrZWQsXG4gICAgICAgICAgICAgICAgZW5hYmxlZEl0ZW0gPSAkKFxuICAgICAgICAgICAgICAgICAgICBcIjxsaSBjbGFzcz0nc2VsZWN0Mi1zZWFyY2gtY2hvaWNlJz5cIiArXG4gICAgICAgICAgICAgICAgICAgIFwiICAgIDxkaXY+PC9kaXY+XCIgK1xuICAgICAgICAgICAgICAgICAgICBcIiAgICA8YSBocmVmPScjJyBjbGFzcz0nc2VsZWN0Mi1zZWFyY2gtY2hvaWNlLWNsb3NlJyB0YWJpbmRleD0nLTEnPjwvYT5cIiArXG4gICAgICAgICAgICAgICAgICAgIFwiPC9saT5cIiksXG4gICAgICAgICAgICAgICAgZGlzYWJsZWRJdGVtID0gJChcbiAgICAgICAgICAgICAgICAgICAgXCI8bGkgY2xhc3M9J3NlbGVjdDItc2VhcmNoLWNob2ljZSBzZWxlY3QyLWxvY2tlZCc+XCIgK1xuICAgICAgICAgICAgICAgICAgICBcIjxkaXY+PC9kaXY+XCIgK1xuICAgICAgICAgICAgICAgICAgICBcIjwvbGk+XCIpO1xuICAgICAgICAgICAgdmFyIGNob2ljZSA9IGVuYWJsZUNob2ljZSA/IGVuYWJsZWRJdGVtIDogZGlzYWJsZWRJdGVtLFxuICAgICAgICAgICAgICAgIGlkID0gdGhpcy5pZChkYXRhKSxcbiAgICAgICAgICAgICAgICB2YWwgPSB0aGlzLmdldFZhbCgpLFxuICAgICAgICAgICAgICAgIGZvcm1hdHRlZCxcbiAgICAgICAgICAgICAgICBjc3NDbGFzcztcblxuICAgICAgICAgICAgZm9ybWF0dGVkPXRoaXMub3B0cy5mb3JtYXRTZWxlY3Rpb24oZGF0YSwgY2hvaWNlLmZpbmQoXCJkaXZcIiksIHRoaXMub3B0cy5lc2NhcGVNYXJrdXApO1xuICAgICAgICAgICAgaWYgKGZvcm1hdHRlZCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjaG9pY2UuZmluZChcImRpdlwiKS5yZXBsYWNlV2l0aCgkKFwiPGRpdj48L2Rpdj5cIikuaHRtbChmb3JtYXR0ZWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNzc0NsYXNzPXRoaXMub3B0cy5mb3JtYXRTZWxlY3Rpb25Dc3NDbGFzcyhkYXRhLCBjaG9pY2UuZmluZChcImRpdlwiKSk7XG4gICAgICAgICAgICBpZiAoY3NzQ2xhc3MgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY2hvaWNlLmFkZENsYXNzKGNzc0NsYXNzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoZW5hYmxlQ2hvaWNlKXtcbiAgICAgICAgICAgICAgY2hvaWNlLmZpbmQoXCIuc2VsZWN0Mi1zZWFyY2gtY2hvaWNlLWNsb3NlXCIpXG4gICAgICAgICAgICAgICAgICAub24oXCJtb3VzZWRvd25cIiwga2lsbEV2ZW50KVxuICAgICAgICAgICAgICAgICAgLm9uKFwiY2xpY2sgZGJsY2xpY2tcIiwgdGhpcy5iaW5kKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNJbnRlcmZhY2VFbmFibGVkKCkpIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgdGhpcy51bnNlbGVjdCgkKGUudGFyZ2V0KSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5maW5kKFwiLnNlbGVjdDItc2VhcmNoLWNob2ljZS1mb2N1c1wiKS5yZW1vdmVDbGFzcyhcInNlbGVjdDItc2VhcmNoLWNob2ljZS1mb2N1c1wiKTtcbiAgICAgICAgICAgICAgICAgIGtpbGxFdmVudChlKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuZm9jdXNTZWFyY2goKTtcbiAgICAgICAgICAgICAgfSkpLm9uKFwiZm9jdXNcIiwgdGhpcy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0ludGVyZmFjZUVuYWJsZWQoKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2xhc3MoXCJzZWxlY3QyLWNvbnRhaW5lci1hY3RpdmVcIik7XG4gICAgICAgICAgICAgICAgICB0aGlzLmRyb3Bkb3duLmFkZENsYXNzKFwic2VsZWN0Mi1kcm9wLWFjdGl2ZVwiKTtcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaG9pY2UuZGF0YShcInNlbGVjdDItZGF0YVwiLCBkYXRhKTtcbiAgICAgICAgICAgIGNob2ljZS5pbnNlcnRCZWZvcmUodGhpcy5zZWFyY2hDb250YWluZXIpO1xuXG4gICAgICAgICAgICB2YWwucHVzaChpZCk7XG4gICAgICAgICAgICB0aGlzLnNldFZhbCh2YWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIG11bHRpXG4gICAgICAgIHVuc2VsZWN0OiBmdW5jdGlvbiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLmdldFZhbCgpLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgaW5kZXg7XG4gICAgICAgICAgICBzZWxlY3RlZCA9IHNlbGVjdGVkLmNsb3Nlc3QoXCIuc2VsZWN0Mi1zZWFyY2gtY2hvaWNlXCIpO1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIGFyZ3VtZW50OiBcIiArIHNlbGVjdGVkICsgXCIuIE11c3QgYmUgLnNlbGVjdDItc2VhcmNoLWNob2ljZVwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRhID0gc2VsZWN0ZWQuZGF0YShcInNlbGVjdDItZGF0YVwiKTtcblxuICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gcHJldmVudCBhIHJhY2UgY29uZGl0aW9uIHdoZW4gdGhlICd4JyBpcyBjbGlja2VkIHJlYWxseSBmYXN0IHJlcGVhdGVkbHkgdGhlIGV2ZW50IGNhbiBiZSBxdWV1ZWRcbiAgICAgICAgICAgICAgICAvLyBhbmQgaW52b2tlZCBvbiBhbiBlbGVtZW50IGFscmVhZHkgcmVtb3ZlZFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGV2dCA9ICQuRXZlbnQoXCJzZWxlY3QyLXJlbW92aW5nXCIpO1xuICAgICAgICAgICAgZXZ0LnZhbCA9IHRoaXMuaWQoZGF0YSk7XG4gICAgICAgICAgICBldnQuY2hvaWNlID0gZGF0YTtcbiAgICAgICAgICAgIHRoaXMub3B0cy5lbGVtZW50LnRyaWdnZXIoZXZ0KTtcblxuICAgICAgICAgICAgaWYgKGV2dC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2hpbGUoKGluZGV4ID0gaW5kZXhPZih0aGlzLmlkKGRhdGEpLCB2YWwpKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFsLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWYWwodmFsKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3QpIHRoaXMucG9zdHByb2Nlc3NSZXN1bHRzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGVjdGVkLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICB0aGlzLm9wdHMuZWxlbWVudC50cmlnZ2VyKHsgdHlwZTogXCJzZWxlY3QyLXJlbW92ZWRcIiwgdmFsOiB0aGlzLmlkKGRhdGEpLCBjaG9pY2U6IGRhdGEgfSk7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJDaGFuZ2UoeyByZW1vdmVkOiBkYXRhIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBtdWx0aVxuICAgICAgICBwb3N0cHJvY2Vzc1Jlc3VsdHM6IGZ1bmN0aW9uIChkYXRhLCBpbml0aWFsLCBub0hpZ2hsaWdodFVwZGF0ZSkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXMuZ2V0VmFsKCksXG4gICAgICAgICAgICAgICAgY2hvaWNlcyA9IHRoaXMucmVzdWx0cy5maW5kKFwiLnNlbGVjdDItcmVzdWx0XCIpLFxuICAgICAgICAgICAgICAgIGNvbXBvdW5kID0gdGhpcy5yZXN1bHRzLmZpbmQoXCIuc2VsZWN0Mi1yZXN1bHQtd2l0aC1jaGlsZHJlblwiKSxcbiAgICAgICAgICAgICAgICBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgY2hvaWNlcy5lYWNoMihmdW5jdGlvbiAoaSwgY2hvaWNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gc2VsZi5pZChjaG9pY2UuZGF0YShcInNlbGVjdDItZGF0YVwiKSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4T2YoaWQsIHZhbCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjaG9pY2UuYWRkQ2xhc3MoXCJzZWxlY3QyLXNlbGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBtYXJrIGFsbCBjaGlsZHJlbiBvZiB0aGUgc2VsZWN0ZWQgcGFyZW50IGFzIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgICAgIGNob2ljZS5maW5kKFwiLnNlbGVjdDItcmVzdWx0LXNlbGVjdGFibGVcIikuYWRkQ2xhc3MoXCJzZWxlY3QyLXNlbGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb21wb3VuZC5lYWNoMihmdW5jdGlvbihpLCBjaG9pY2UpIHtcbiAgICAgICAgICAgICAgICAvLyBoaWRlIGFuIG9wdGdyb3VwIGlmIGl0IGRvZXNuJ3QgaGF2ZSBhbnkgc2VsZWN0YWJsZSBjaGlsZHJlblxuICAgICAgICAgICAgICAgIGlmICghY2hvaWNlLmlzKCcuc2VsZWN0Mi1yZXN1bHQtc2VsZWN0YWJsZScpXG4gICAgICAgICAgICAgICAgICAgICYmIGNob2ljZS5maW5kKFwiLnNlbGVjdDItcmVzdWx0LXNlbGVjdGFibGU6bm90KC5zZWxlY3QyLXNlbGVjdGVkKVwiKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hvaWNlLmFkZENsYXNzKFwic2VsZWN0Mi1zZWxlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0KCkgPT0gLTEgJiYgbm9IaWdobGlnaHRVcGRhdGUgIT09IGZhbHNlICYmIHRoaXMub3B0cy5jbG9zZU9uU2VsZWN0ID09PSB0cnVlKXtcbiAgICAgICAgICAgICAgICBzZWxmLmhpZ2hsaWdodCgwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9JZiBhbGwgcmVzdWx0cyBhcmUgY2hvc2VuIHJlbmRlciBmb3JtYXROb01hdGNoZXNcbiAgICAgICAgICAgIGlmKCF0aGlzLm9wdHMuY3JlYXRlU2VhcmNoQ2hvaWNlICYmICFjaG9pY2VzLmZpbHRlcignLnNlbGVjdDItcmVzdWx0Om5vdCguc2VsZWN0Mi1zZWxlY3RlZCknKS5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgICAgICBpZighZGF0YSB8fCBkYXRhICYmICFkYXRhLm1vcmUgJiYgdGhpcy5yZXN1bHRzLmZpbmQoXCIuc2VsZWN0Mi1uby1yZXN1bHRzXCIpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2tGb3JtYXR0ZXIoc2VsZi5vcHRzLmZvcm1hdE5vTWF0Y2hlcywgXCJmb3JtYXROb01hdGNoZXNcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0cy5hcHBlbmQoXCI8bGkgY2xhc3M9J3NlbGVjdDItbm8tcmVzdWx0cyc+XCIgKyBldmFsdWF0ZShzZWxmLm9wdHMuZm9ybWF0Tm9NYXRjaGVzLCBzZWxmLm9wdHMuZWxlbWVudCwgc2VsZi5zZWFyY2gudmFsKCkpICsgXCI8L2xpPlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIG11bHRpXG4gICAgICAgIGdldE1heFNlYXJjaFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbi53aWR0aCgpIC0gZ2V0U2lkZUJvcmRlclBhZGRpbmcodGhpcy5zZWFyY2gpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIG11bHRpXG4gICAgICAgIHJlc2l6ZVNlYXJjaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1pbmltdW1XaWR0aCwgbGVmdCwgbWF4V2lkdGgsIGNvbnRhaW5lckxlZnQsIHNlYXJjaFdpZHRoLFxuICAgICAgICAgICAgICAgIHNpZGVCb3JkZXJQYWRkaW5nID0gZ2V0U2lkZUJvcmRlclBhZGRpbmcodGhpcy5zZWFyY2gpO1xuXG4gICAgICAgICAgICBtaW5pbXVtV2lkdGggPSBtZWFzdXJlVGV4dFdpZHRoKHRoaXMuc2VhcmNoKSArIDEwO1xuXG4gICAgICAgICAgICBsZWZ0ID0gdGhpcy5zZWFyY2gub2Zmc2V0KCkubGVmdDtcblxuICAgICAgICAgICAgbWF4V2lkdGggPSB0aGlzLnNlbGVjdGlvbi53aWR0aCgpO1xuICAgICAgICAgICAgY29udGFpbmVyTGVmdCA9IHRoaXMuc2VsZWN0aW9uLm9mZnNldCgpLmxlZnQ7XG5cbiAgICAgICAgICAgIHNlYXJjaFdpZHRoID0gbWF4V2lkdGggLSAobGVmdCAtIGNvbnRhaW5lckxlZnQpIC0gc2lkZUJvcmRlclBhZGRpbmc7XG5cbiAgICAgICAgICAgIGlmIChzZWFyY2hXaWR0aCA8IG1pbmltdW1XaWR0aCkge1xuICAgICAgICAgICAgICAgIHNlYXJjaFdpZHRoID0gbWF4V2lkdGggLSBzaWRlQm9yZGVyUGFkZGluZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlYXJjaFdpZHRoIDwgNDApIHtcbiAgICAgICAgICAgICAgICBzZWFyY2hXaWR0aCA9IG1heFdpZHRoIC0gc2lkZUJvcmRlclBhZGRpbmc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWFyY2hXaWR0aCA8PSAwKSB7XG4gICAgICAgICAgICAgIHNlYXJjaFdpZHRoID0gbWluaW11bVdpZHRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNlYXJjaC53aWR0aChNYXRoLmZsb29yKHNlYXJjaFdpZHRoKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gbXVsdGlcbiAgICAgICAgZ2V0VmFsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmFsO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFsID0gdGhpcy5zZWxlY3QudmFsKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbCA9PT0gbnVsbCA/IFtdIDogdmFsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWwgPSB0aGlzLm9wdHMuZWxlbWVudC52YWwoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3BsaXRWYWwodmFsLCB0aGlzLm9wdHMuc2VwYXJhdG9yLCB0aGlzLm9wdHMudHJhbnNmb3JtVmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBtdWx0aVxuICAgICAgICBzZXRWYWw6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHZhciB1bmlxdWU7XG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdC52YWwodmFsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdW5pcXVlID0gW107XG4gICAgICAgICAgICAgICAgLy8gZmlsdGVyIG91dCBkdXBsaWNhdGVzXG4gICAgICAgICAgICAgICAgJCh2YWwpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXhPZih0aGlzLCB1bmlxdWUpIDwgMCkgdW5pcXVlLnB1c2godGhpcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRzLmVsZW1lbnQudmFsKHVuaXF1ZS5sZW5ndGggPT09IDAgPyBcIlwiIDogdW5pcXVlLmpvaW4odGhpcy5vcHRzLnNlcGFyYXRvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIG11bHRpXG4gICAgICAgIGJ1aWxkQ2hhbmdlRGV0YWlsczogZnVuY3Rpb24gKG9sZCwgY3VycmVudCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBjdXJyZW50LnNsaWNlKDApLFxuICAgICAgICAgICAgICAgIG9sZCA9IG9sZC5zbGljZSgwKTtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIGludGVyc2VjdGlvbiBmcm9tIGVhY2ggYXJyYXlcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VycmVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb2xkLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcXVhbCh0aGlzLm9wdHMuaWQoY3VycmVudFtpXSksIHRoaXMub3B0cy5pZChvbGRbal0pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihpPjApe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZC5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7YWRkZWQ6IGN1cnJlbnQsIHJlbW92ZWQ6IG9sZH07XG4gICAgICAgIH0sXG5cblxuICAgICAgICAvLyBtdWx0aVxuICAgICAgICB2YWw6IGZ1bmN0aW9uICh2YWwsIHRyaWdnZXJDaGFuZ2UpIHtcbiAgICAgICAgICAgIHZhciBvbGREYXRhLCBzZWxmPXRoaXM7XG5cbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9sZERhdGE9dGhpcy5kYXRhKCk7XG4gICAgICAgICAgICBpZiAoIW9sZERhdGEubGVuZ3RoKSBvbGREYXRhPVtdO1xuXG4gICAgICAgICAgICAvLyB2YWwgaXMgYW4gaWQuICF2YWwgaXMgdHJ1ZSBmb3IgW3VuZGVmaW5lZCxudWxsLCcnLDBdIC0gMCBpcyBsZWdhbFxuICAgICAgICAgICAgaWYgKCF2YWwgJiYgdmFsICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRzLmVsZW1lbnQudmFsKFwiXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2VsZWN0aW9uKFtdKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyU2VhcmNoKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRyaWdnZXJDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyQ2hhbmdlKHthZGRlZDogdGhpcy5kYXRhKCksIHJlbW92ZWQ6IG9sZERhdGF9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB2YWwgaXMgYSBsaXN0IG9mIGlkc1xuICAgICAgICAgICAgdGhpcy5zZXRWYWwodmFsKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRzLmluaXRTZWxlY3Rpb24odGhpcy5zZWxlY3QsIHRoaXMuYmluZCh0aGlzLnVwZGF0ZVNlbGVjdGlvbikpO1xuICAgICAgICAgICAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckNoYW5nZSh0aGlzLmJ1aWxkQ2hhbmdlRGV0YWlscyhvbGREYXRhLCB0aGlzLmRhdGEoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5pbml0U2VsZWN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidmFsKCkgY2Fubm90IGJlIGNhbGxlZCBpZiBpbml0U2VsZWN0aW9uKCkgaXMgbm90IGRlZmluZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRzLmluaXRTZWxlY3Rpb24odGhpcy5vcHRzLmVsZW1lbnQsIGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWRzPSQubWFwKGRhdGEsIHNlbGYuaWQpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNldFZhbChpZHMpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZVNlbGVjdGlvbihkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jbGVhclNlYXJjaCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJpZ2dlckNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyQ2hhbmdlKHNlbGYuYnVpbGRDaGFuZ2VEZXRhaWxzKG9sZERhdGEsIHNlbGYuZGF0YSgpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2xlYXJTZWFyY2goKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBtdWx0aVxuICAgICAgICBvblNvcnRTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3QpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTb3J0aW5nIG9mIGVsZW1lbnRzIGlzIG5vdCBzdXBwb3J0ZWQgd2hlbiBhdHRhY2hlZCB0byA8c2VsZWN0Pi4gQXR0YWNoIHRvIDxpbnB1dCB0eXBlPSdoaWRkZW4nLz4gaW5zdGVhZC5cIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNvbGxhcHNlIHNlYXJjaCBmaWVsZCBpbnRvIDAgd2lkdGggc28gaXRzIGNvbnRhaW5lciBjYW4gYmUgY29sbGFwc2VkIGFzIHdlbGxcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoLndpZHRoKDApO1xuICAgICAgICAgICAgLy8gaGlkZSB0aGUgY29udGFpbmVyXG4gICAgICAgICAgICB0aGlzLnNlYXJjaENvbnRhaW5lci5oaWRlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gbXVsdGlcbiAgICAgICAgb25Tb3J0RW5kOmZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICB2YXIgdmFsPVtdLCBzZWxmPXRoaXM7XG5cbiAgICAgICAgICAgIC8vIHNob3cgc2VhcmNoIGFuZCBtb3ZlIGl0IHRvIHRoZSBlbmQgb2YgdGhlIGxpc3RcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoQ29udGFpbmVyLnNob3coKTtcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgc2VhcmNoIGNvbnRhaW5lciBpcyB0aGUgbGFzdCBpdGVtIGluIHRoZSBsaXN0XG4gICAgICAgICAgICB0aGlzLnNlYXJjaENvbnRhaW5lci5hcHBlbmRUbyh0aGlzLnNlYXJjaENvbnRhaW5lci5wYXJlbnQoKSk7XG4gICAgICAgICAgICAvLyBzaW5jZSB3ZSBjb2xsYXBzZWQgdGhlIHdpZHRoIGluIGRyYWdTdGFydGVkLCB3ZSByZXNpemUgaXQgaGVyZVxuICAgICAgICAgICAgdGhpcy5yZXNpemVTZWFyY2goKTtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIHNlbGVjdGlvblxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uZmluZChcIi5zZWxlY3QyLXNlYXJjaC1jaG9pY2VcIikuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YWwucHVzaChzZWxmLm9wdHMuaWQoJCh0aGlzKS5kYXRhKFwic2VsZWN0Mi1kYXRhXCIpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsKHZhbCk7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJDaGFuZ2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBtdWx0aVxuICAgICAgICBkYXRhOiBmdW5jdGlvbih2YWx1ZXMsIHRyaWdnZXJDaGFuZ2UpIHtcbiAgICAgICAgICAgIHZhciBzZWxmPXRoaXMsIGlkcywgb2xkO1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAuY2hpbGRyZW4oXCIuc2VsZWN0Mi1zZWFyY2gtY2hvaWNlXCIpXG4gICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKCkgeyByZXR1cm4gJCh0aGlzKS5kYXRhKFwic2VsZWN0Mi1kYXRhXCIpOyB9KVxuICAgICAgICAgICAgICAgICAgICAgLmdldCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvbGQgPSB0aGlzLmRhdGEoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbHVlcykgeyB2YWx1ZXMgPSBbXTsgfVxuICAgICAgICAgICAgICAgIGlkcyA9ICQubWFwKHZhbHVlcywgZnVuY3Rpb24oZSkgeyByZXR1cm4gc2VsZi5vcHRzLmlkKGUpOyB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFZhbChpZHMpO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2VsZWN0aW9uKHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclNlYXJjaCgpO1xuICAgICAgICAgICAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckNoYW5nZSh0aGlzLmJ1aWxkQ2hhbmdlRGV0YWlscyhvbGQsIHRoaXMuZGF0YSgpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAkLmZuLnNlbGVjdDIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApLFxuICAgICAgICAgICAgb3B0cyxcbiAgICAgICAgICAgIHNlbGVjdDIsXG4gICAgICAgICAgICBtZXRob2QsIHZhbHVlLCBtdWx0aXBsZSxcbiAgICAgICAgICAgIGFsbG93ZWRNZXRob2RzID0gW1widmFsXCIsIFwiZGVzdHJveVwiLCBcIm9wZW5lZFwiLCBcIm9wZW5cIiwgXCJjbG9zZVwiLCBcImZvY3VzXCIsIFwiaXNGb2N1c2VkXCIsIFwiY29udGFpbmVyXCIsIFwiZHJvcGRvd25cIiwgXCJvblNvcnRTdGFydFwiLCBcIm9uU29ydEVuZFwiLCBcImVuYWJsZVwiLCBcImRpc2FibGVcIiwgXCJyZWFkb25seVwiLCBcInBvc2l0aW9uRHJvcGRvd25cIiwgXCJkYXRhXCIsIFwic2VhcmNoXCJdLFxuICAgICAgICAgICAgdmFsdWVNZXRob2RzID0gW1wib3BlbmVkXCIsIFwiaXNGb2N1c2VkXCIsIFwiY29udGFpbmVyXCIsIFwiZHJvcGRvd25cIl0sXG4gICAgICAgICAgICBwcm9wZXJ0eU1ldGhvZHMgPSBbXCJ2YWxcIiwgXCJkYXRhXCJdLFxuICAgICAgICAgICAgbWV0aG9kc01hcCA9IHsgc2VhcmNoOiBcImV4dGVybmFsU2VhcmNoXCIgfTtcblxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwIHx8IHR5cGVvZihhcmdzWzBdKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIG9wdHMgPSBhcmdzLmxlbmd0aCA9PT0gMCA/IHt9IDogJC5leHRlbmQoe30sIGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgIG9wdHMuZWxlbWVudCA9ICQodGhpcyk7XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0cy5lbGVtZW50LmdldCgwKS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwic2VsZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGUgPSBvcHRzLmVsZW1lbnQucHJvcChcIm11bHRpcGxlXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpcGxlID0gb3B0cy5tdWx0aXBsZSB8fCBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwidGFnc1wiIGluIG9wdHMpIHtvcHRzLm11bHRpcGxlID0gbXVsdGlwbGUgPSB0cnVlO31cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZWxlY3QyID0gbXVsdGlwbGUgPyBuZXcgd2luZG93LlNlbGVjdDJbXCJjbGFzc1wiXS5tdWx0aSgpIDogbmV3IHdpbmRvdy5TZWxlY3QyW1wiY2xhc3NcIl0uc2luZ2xlKCk7XG4gICAgICAgICAgICAgICAgc2VsZWN0Mi5pbml0KG9wdHMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YoYXJnc1swXSkgPT09IFwic3RyaW5nXCIpIHtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRleE9mKGFyZ3NbMF0sIGFsbG93ZWRNZXRob2RzKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJVbmtub3duIG1ldGhvZDogXCIgKyBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHNlbGVjdDIgPSAkKHRoaXMpLmRhdGEoXCJzZWxlY3QyXCIpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3QyID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIG1ldGhvZD1hcmdzWzBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJjb250YWluZXJcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHNlbGVjdDIuY29udGFpbmVyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBcImRyb3Bkb3duXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzZWxlY3QyLmRyb3Bkb3duO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2RzTWFwW21ldGhvZF0pIG1ldGhvZCA9IG1ldGhvZHNNYXBbbWV0aG9kXTtcblxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHNlbGVjdDJbbWV0aG9kXS5hcHBseShzZWxlY3QyLCBhcmdzLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4T2YoYXJnc1swXSwgdmFsdWVNZXRob2RzKSA+PSAwXG4gICAgICAgICAgICAgICAgICAgIHx8IChpbmRleE9mKGFyZ3NbMF0sIHByb3BlcnR5TWV0aG9kcykgPj0gMCAmJiBhcmdzLmxlbmd0aCA9PSAxKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGFib3J0IHRoZSBpdGVyYXRpb24sIHJlYWR5IHRvIHJldHVybiBmaXJzdCBtYXRjaGVkIHZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkludmFsaWQgYXJndW1lbnRzIHRvIHNlbGVjdDIgcGx1Z2luOiBcIiArIGFyZ3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKHZhbHVlID09PSB1bmRlZmluZWQpID8gdGhpcyA6IHZhbHVlO1xuICAgIH07XG5cbiAgICAvLyBwbHVnaW4gZGVmYXVsdHMsIGFjY2Vzc2libGUgdG8gdXNlcnNcbiAgICAkLmZuLnNlbGVjdDIuZGVmYXVsdHMgPSB7XG4gICAgICAgIHdpZHRoOiBcImNvcHlcIixcbiAgICAgICAgbG9hZE1vcmVQYWRkaW5nOiAwLFxuICAgICAgICBjbG9zZU9uU2VsZWN0OiB0cnVlLFxuICAgICAgICBvcGVuT25FbnRlcjogdHJ1ZSxcbiAgICAgICAgY29udGFpbmVyQ3NzOiB7fSxcbiAgICAgICAgZHJvcGRvd25Dc3M6IHt9LFxuICAgICAgICBjb250YWluZXJDc3NDbGFzczogXCJcIixcbiAgICAgICAgZHJvcGRvd25Dc3NDbGFzczogXCJcIixcbiAgICAgICAgZm9ybWF0UmVzdWx0OiBmdW5jdGlvbihyZXN1bHQsIGNvbnRhaW5lciwgcXVlcnksIGVzY2FwZU1hcmt1cCkge1xuICAgICAgICAgICAgdmFyIG1hcmt1cD1bXTtcbiAgICAgICAgICAgIG1hcmtNYXRjaCh0aGlzLnRleHQocmVzdWx0KSwgcXVlcnkudGVybSwgbWFya3VwLCBlc2NhcGVNYXJrdXApO1xuICAgICAgICAgICAgcmV0dXJuIG1hcmt1cC5qb2luKFwiXCIpO1xuICAgICAgICB9LFxuICAgICAgICB0cmFuc2Zvcm1WYWw6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuICQudHJpbSh2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBmb3JtYXRTZWxlY3Rpb246IGZ1bmN0aW9uIChkYXRhLCBjb250YWluZXIsIGVzY2FwZU1hcmt1cCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEgPyBlc2NhcGVNYXJrdXAodGhpcy50ZXh0KGRhdGEpKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfSxcbiAgICAgICAgc29ydFJlc3VsdHM6IGZ1bmN0aW9uIChyZXN1bHRzLCBjb250YWluZXIsIHF1ZXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0UmVzdWx0Q3NzQ2xhc3M6IGZ1bmN0aW9uKGRhdGEpIHtyZXR1cm4gZGF0YS5jc3M7fSxcbiAgICAgICAgZm9ybWF0U2VsZWN0aW9uQ3NzQ2xhc3M6IGZ1bmN0aW9uKGRhdGEsIGNvbnRhaW5lcikge3JldHVybiB1bmRlZmluZWQ7fSxcbiAgICAgICAgbWluaW11bVJlc3VsdHNGb3JTZWFyY2g6IDAsXG4gICAgICAgIG1pbmltdW1JbnB1dExlbmd0aDogMCxcbiAgICAgICAgbWF4aW11bUlucHV0TGVuZ3RoOiBudWxsLFxuICAgICAgICBtYXhpbXVtU2VsZWN0aW9uU2l6ZTogMCxcbiAgICAgICAgaWQ6IGZ1bmN0aW9uIChlKSB7IHJldHVybiBlID09IHVuZGVmaW5lZCA/IG51bGwgOiBlLmlkOyB9LFxuICAgICAgICB0ZXh0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGlmIChlICYmIHRoaXMuZGF0YSAmJiB0aGlzLmRhdGEudGV4dCkge1xuICAgICAgICAgICAgaWYgKCQuaXNGdW5jdGlvbih0aGlzLmRhdGEudGV4dCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS50ZXh0KGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVbdGhpcy5kYXRhLnRleHRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZS50ZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbWF0Y2hlcjogZnVuY3Rpb24odGVybSwgdGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmlwRGlhY3JpdGljcygnJyt0ZXh0KS50b1VwcGVyQ2FzZSgpLmluZGV4T2Yoc3RyaXBEaWFjcml0aWNzKCcnK3Rlcm0pLnRvVXBwZXJDYXNlKCkpID49IDA7XG4gICAgICAgIH0sXG4gICAgICAgIHNlcGFyYXRvcjogXCIsXCIsXG4gICAgICAgIHRva2VuU2VwYXJhdG9yczogW10sXG4gICAgICAgIHRva2VuaXplcjogZGVmYXVsdFRva2VuaXplcixcbiAgICAgICAgZXNjYXBlTWFya3VwOiBkZWZhdWx0RXNjYXBlTWFya3VwLFxuICAgICAgICBibHVyT25DaGFuZ2U6IGZhbHNlLFxuICAgICAgICBzZWxlY3RPbkJsdXI6IGZhbHNlLFxuICAgICAgICBhZGFwdENvbnRhaW5lckNzc0NsYXNzOiBmdW5jdGlvbihjKSB7IHJldHVybiBjOyB9LFxuICAgICAgICBhZGFwdERyb3Bkb3duQ3NzQ2xhc3M6IGZ1bmN0aW9uKGMpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgIG5leHRTZWFyY2hUZXJtOiBmdW5jdGlvbihzZWxlY3RlZE9iamVjdCwgY3VycmVudFNlYXJjaFRlcm0pIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSxcbiAgICAgICAgc2VhcmNoSW5wdXRQbGFjZWhvbGRlcjogJycsXG4gICAgICAgIGNyZWF0ZVNlYXJjaENob2ljZVBvc2l0aW9uOiAndG9wJyxcbiAgICAgICAgc2hvdWxkRm9jdXNJbnB1dDogZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgICAgICAvLyBBdHRlbXB0IHRvIGRldGVjdCB0b3VjaCBkZXZpY2VzXG4gICAgICAgICAgICB2YXIgc3VwcG9ydHNUb3VjaEV2ZW50cyA9ICgoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG5hdmlnYXRvci5tc01heFRvdWNoUG9pbnRzID4gMCkpO1xuXG4gICAgICAgICAgICAvLyBPbmx5IGRldmljZXMgd2hpY2ggc3VwcG9ydCB0b3VjaCBldmVudHMgc2hvdWxkIGJlIHNwZWNpYWwgY2FzZWRcbiAgICAgICAgICAgIGlmICghc3VwcG9ydHNUb3VjaEV2ZW50cykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBOZXZlciBmb2N1cyB0aGUgaW5wdXQgaWYgc2VhcmNoIGlzIGRpc2FibGVkXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2Uub3B0cy5taW5pbXVtUmVzdWx0c0ZvclNlYXJjaCA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgICQuZm4uc2VsZWN0Mi5sb2NhbGVzID0gW107XG5cbiAgICAkLmZuLnNlbGVjdDIubG9jYWxlc1snZW4nXSA9IHtcbiAgICAgICAgIGZvcm1hdE1hdGNoZXM6IGZ1bmN0aW9uIChtYXRjaGVzKSB7IGlmIChtYXRjaGVzID09PSAxKSB7IHJldHVybiBcIk9uZSByZXN1bHQgaXMgYXZhaWxhYmxlLCBwcmVzcyBlbnRlciB0byBzZWxlY3QgaXQuXCI7IH0gcmV0dXJuIG1hdGNoZXMgKyBcIiByZXN1bHRzIGFyZSBhdmFpbGFibGUsIHVzZSB1cCBhbmQgZG93biBhcnJvdyBrZXlzIHRvIG5hdmlnYXRlLlwiOyB9LFxuICAgICAgICAgZm9ybWF0Tm9NYXRjaGVzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBcIk5vIG1hdGNoZXMgZm91bmRcIjsgfSxcbiAgICAgICAgIGZvcm1hdEFqYXhFcnJvcjogZnVuY3Rpb24gKGpxWEhSLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikgeyByZXR1cm4gXCJMb2FkaW5nIGZhaWxlZFwiOyB9LFxuICAgICAgICAgZm9ybWF0SW5wdXRUb29TaG9ydDogZnVuY3Rpb24gKGlucHV0LCBtaW4pIHsgdmFyIG4gPSBtaW4gLSBpbnB1dC5sZW5ndGg7IHJldHVybiBcIlBsZWFzZSBlbnRlciBcIiArIG4gKyBcIiBvciBtb3JlIGNoYXJhY3RlclwiICsgKG4gPT0gMSA/IFwiXCIgOiBcInNcIik7IH0sXG4gICAgICAgICBmb3JtYXRJbnB1dFRvb0xvbmc6IGZ1bmN0aW9uIChpbnB1dCwgbWF4KSB7IHZhciBuID0gaW5wdXQubGVuZ3RoIC0gbWF4OyByZXR1cm4gXCJQbGVhc2UgZGVsZXRlIFwiICsgbiArIFwiIGNoYXJhY3RlclwiICsgKG4gPT0gMSA/IFwiXCIgOiBcInNcIik7IH0sXG4gICAgICAgICBmb3JtYXRTZWxlY3Rpb25Ub29CaWc6IGZ1bmN0aW9uIChsaW1pdCkgeyByZXR1cm4gXCJZb3UgY2FuIG9ubHkgc2VsZWN0IFwiICsgbGltaXQgKyBcIiBpdGVtXCIgKyAobGltaXQgPT0gMSA/IFwiXCIgOiBcInNcIik7IH0sXG4gICAgICAgICBmb3JtYXRMb2FkTW9yZTogZnVuY3Rpb24gKHBhZ2VOdW1iZXIpIHsgcmV0dXJuIFwiTG9hZGluZyBtb3JlIHJlc3VsdHPigKZcIjsgfSxcbiAgICAgICAgIGZvcm1hdFNlYXJjaGluZzogZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJTZWFyY2hpbmfigKZcIjsgfVxuICAgIH07XG5cbiAgICAkLmV4dGVuZCgkLmZuLnNlbGVjdDIuZGVmYXVsdHMsICQuZm4uc2VsZWN0Mi5sb2NhbGVzWydlbiddKTtcblxuICAgICQuZm4uc2VsZWN0Mi5hamF4RGVmYXVsdHMgPSB7XG4gICAgICAgIHRyYW5zcG9ydDogJC5hamF4LFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXG4gICAgICAgICAgICBjYWNoZTogZmFsc2UsXG4gICAgICAgICAgICBkYXRhVHlwZTogXCJqc29uXCJcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBleHBvcnRzXG4gICAgd2luZG93LlNlbGVjdDIgPSB7XG4gICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICBhamF4OiBhamF4LFxuICAgICAgICAgICAgbG9jYWw6IGxvY2FsLFxuICAgICAgICAgICAgdGFnczogdGFnc1xuICAgICAgICB9LCB1dGlsOiB7XG4gICAgICAgICAgICBkZWJvdW5jZTogZGVib3VuY2UsXG4gICAgICAgICAgICBtYXJrTWF0Y2g6IG1hcmtNYXRjaCxcbiAgICAgICAgICAgIGVzY2FwZU1hcmt1cDogZGVmYXVsdEVzY2FwZU1hcmt1cCxcbiAgICAgICAgICAgIHN0cmlwRGlhY3JpdGljczogc3RyaXBEaWFjcml0aWNzXG4gICAgICAgIH0sIFwiY2xhc3NcIjoge1xuICAgICAgICAgICAgXCJhYnN0cmFjdFwiOiBBYnN0cmFjdFNlbGVjdDIsXG4gICAgICAgICAgICBcInNpbmdsZVwiOiBTaW5nbGVTZWxlY3QyLFxuICAgICAgICAgICAgXCJtdWx0aVwiOiBNdWx0aVNlbGVjdDJcbiAgICAgICAgfVxuICAgIH07XG5cbn0oalF1ZXJ5KSk7XG4iLCIvKioqKioqKioqKioqKioqKioqKioqKioqXG5qcXVlcnktdGltZXBpY2tlciB2MS4yLjE1XG5odHRwOi8vam9udGhvcm50b24uZ2l0aHViLmNvbS9qcXVlcnktdGltZXBpY2tlci9cblxucmVxdWlyZXMgalF1ZXJ5IDEuNytcbioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cblx0XHRkZWZpbmUoWydqcXVlcnknXSwgZmFjdG9yeSk7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gQnJvd3NlciBnbG9iYWxzXG5cdFx0ZmFjdG9yeShqUXVlcnkpO1xuXHR9XG59KGZ1bmN0aW9uICgkKSB7XG5cdHZhciBfYmFzZURhdGUgPSBfZ2VuZXJhdGVCYXNlRGF0ZSgpO1xuXHR2YXIgX09ORV9EQVkgPSA4NjQwMDtcblx0dmFyIF9kZWZhdWx0cyA9XHR7XG5cdFx0Y2xhc3NOYW1lOiBudWxsLFxuXHRcdG1pblRpbWU6IG51bGwsXG5cdFx0bWF4VGltZTogbnVsbCxcblx0XHRkdXJhdGlvblRpbWU6IG51bGwsXG5cdFx0c3RlcDogMzAsXG5cdFx0c2hvd0R1cmF0aW9uOiBmYWxzZSxcblx0XHR0aW1lRm9ybWF0OiAnZzppYScsXG5cdFx0c2Nyb2xsRGVmYXVsdE5vdzogZmFsc2UsXG5cdFx0c2Nyb2xsRGVmYXVsdFRpbWU6IGZhbHNlLFxuXHRcdHNlbGVjdE9uQmx1cjogZmFsc2UsXG5cdFx0ZGlzYWJsZVRvdWNoS2V5Ym9hcmQ6IGZhbHNlLFxuXHRcdGZvcmNlUm91bmRUaW1lOiBmYWxzZSxcblx0XHRhcHBlbmRUbzogJ2JvZHknLFxuXHRcdGRpc2FibGVUaW1lUmFuZ2VzOiBbXSxcblx0XHRjbG9zZU9uV2luZG93U2Nyb2xsOiBmYWxzZSxcblx0XHRkaXNhYmxlVGV4dElucHV0OiBmYWxzZSxcblx0XHR0eXBlYWhlYWRIaWdobGlnaHQ6IHRydWVcblx0fTtcblx0dmFyIF9sYW5nID0ge1xuXHRcdGRlY2ltYWw6ICcuJyxcblx0XHRtaW5zOiAnbWlucycsXG5cdFx0aHI6ICdocicsXG5cdFx0aHJzOiAnaHJzJ1xuXHR9O1xuXG5cdHZhciBtZXRob2RzID1cblx0e1xuXHRcdGluaXQ6IGZ1bmN0aW9uKG9wdGlvbnMpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBzZWxmID0gJCh0aGlzKTtcblxuXHRcdFx0XHQvLyBjb252ZXJ0IGRyb3Bkb3ducyB0byB0ZXh0IGlucHV0XG5cdFx0XHRcdGlmIChzZWxmWzBdLnRhZ05hbWUgPT0gJ1NFTEVDVCcpIHtcblx0XHRcdFx0XHR2YXIgYXR0cnMgPSB7ICd0eXBlJzogJ3RleHQnLCAndmFsdWUnOiBzZWxmLnZhbCgpIH07XG5cdFx0XHRcdFx0dmFyIHJhd19hdHRycyA9IHNlbGZbMF0uYXR0cmlidXRlcztcblxuXHRcdFx0XHRcdGZvciAodmFyIGk9MDsgaSA8IHJhd19hdHRycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0YXR0cnNbcmF3X2F0dHJzW2ldLm5vZGVOYW1lXSA9IHJhd19hdHRyc1tpXS5ub2RlVmFsdWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIGlucHV0ID0gJCgnPGlucHV0IC8+JywgYXR0cnMpO1xuXHRcdFx0XHRcdHNlbGYucmVwbGFjZVdpdGgoaW5wdXQpO1xuXHRcdFx0XHRcdHNlbGYgPSBpbnB1dDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCBfZGVmYXVsdHMpO1xuXG5cdFx0XHRcdGlmIChvcHRpb25zKSB7XG5cdFx0XHRcdFx0c2V0dGluZ3MgPSAkLmV4dGVuZChzZXR0aW5ncywgb3B0aW9ucyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoc2V0dGluZ3MubGFuZykge1xuXHRcdFx0XHRcdF9sYW5nID0gJC5leHRlbmQoX2xhbmcsIHNldHRpbmdzLmxhbmcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2V0dGluZ3MgPSBfcGFyc2VTZXR0aW5ncyhzZXR0aW5ncyk7XG5cblx0XHRcdFx0c2VsZi5kYXRhKCd0aW1lcGlja2VyLXNldHRpbmdzJywgc2V0dGluZ3MpO1xuXHRcdFx0XHRzZWxmLnByb3AoJ2F1dG9jb21wbGV0ZScsICdvZmYnKTtcblx0XHRcdFx0c2VsZi5vbignY2xpY2sudGltZXBpY2tlciBmb2N1cy50aW1lcGlja2VyJywgbWV0aG9kcy5zaG93KTtcblx0XHRcdFx0c2VsZi5vbignY2hhbmdlLnRpbWVwaWNrZXInLCBfZm9ybWF0VmFsdWUpO1xuXHRcdFx0XHRzZWxmLm9uKCdrZXlkb3duLnRpbWVwaWNrZXInLCBfa2V5ZG93bmhhbmRsZXIpO1xuXHRcdFx0XHRzZWxmLm9uKCdrZXl1cC50aW1lcGlja2VyJywgX2tleXVwaGFuZGxlcik7XG5cdFx0XHRcdHNlbGYuYWRkQ2xhc3MoJ3VpLXRpbWVwaWNrZXItaW5wdXQnKTtcblxuXHRcdFx0XHRfZm9ybWF0VmFsdWUuY2FsbChzZWxmLmdldCgwKSk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0c2hvdzogZnVuY3Rpb24oZSlcblx0XHR7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdHZhciBzZWxmID0gJCh0aGlzKTtcblx0XHRcdHZhciBzZXR0aW5ncyA9IHNlbGYuZGF0YSgndGltZXBpY2tlci1zZXR0aW5ncycpO1xuXG5cdFx0XHRpZiAoX2hpZGVLZXlib2FyZChzZWxmKSkge1xuXHRcdFx0XHQvLyBibG9jayB0aGUga2V5Ym9hcmQgb24gbW9iaWxlIGRldmljZXNcblx0XHRcdFx0c2VsZi5ibHVyKCk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBsaXN0ID0gc2VsZi5kYXRhKCd0aW1lcGlja2VyLWxpc3QnKTtcblxuXHRcdFx0Ly8gY2hlY2sgaWYgaW5wdXQgaXMgcmVhZG9ubHlcblx0XHRcdGlmIChzZWxmLnByb3AoJ3JlYWRvbmx5JykpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjaGVjayBpZiBsaXN0IG5lZWRzIHRvIGJlIHJlbmRlcmVkXG5cdFx0XHRpZiAoIWxpc3QgfHwgbGlzdC5sZW5ndGggPT09IDAgfHwgdHlwZW9mIHNldHRpbmdzLmR1cmF0aW9uVGltZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRfcmVuZGVyKHNlbGYpO1xuXHRcdFx0XHRsaXN0ID0gc2VsZi5kYXRhKCd0aW1lcGlja2VyLWxpc3QnKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGxpc3QuaXMoJzp2aXNpYmxlJykpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBtYWtlIHN1cmUgb3RoZXIgcGlja2VycyBhcmUgaGlkZGVuXG5cdFx0XHRtZXRob2RzLmhpZGUoKTtcblxuXHRcdFx0bGlzdC5zaG93KCk7XG5cblx0XHRcdGlmICgoc2VsZi5vZmZzZXQoKS50b3AgKyBzZWxmLm91dGVySGVpZ2h0KHRydWUpICsgbGlzdC5vdXRlckhlaWdodCgpKSA+ICQod2luZG93KS5oZWlnaHQoKSArICQod2luZG93KS5zY3JvbGxUb3AoKSkge1xuXHRcdFx0XHQvLyBwb3NpdGlvbiB0aGUgZHJvcGRvd24gb24gdG9wXG5cdFx0XHRcdGxpc3Qub2Zmc2V0KHtcblx0XHRcdFx0XHQnbGVmdCc6IHNlbGYub2Zmc2V0KCkubGVmdCArIHBhcnNlSW50KGxpc3QuY3NzKCdtYXJnaW5MZWZ0JykucmVwbGFjZSgncHgnLCAnJyksIDEwKSxcblx0XHRcdFx0XHQndG9wJzogc2VsZi5vZmZzZXQoKS50b3AgLSBsaXN0Lm91dGVySGVpZ2h0KCkgKyBwYXJzZUludChsaXN0LmNzcygnbWFyZ2luVG9wJykucmVwbGFjZSgncHgnLCAnJyksIDEwKVxuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHB1dCBpdCB1bmRlciB0aGUgaW5wdXRcblx0XHRcdFx0bGlzdC5vZmZzZXQoe1xuXHRcdFx0XHRcdCdsZWZ0JzpzZWxmLm9mZnNldCgpLmxlZnQgKyBwYXJzZUludChsaXN0LmNzcygnbWFyZ2luTGVmdCcpLnJlcGxhY2UoJ3B4JywgJycpLCAxMCksXG5cdFx0XHRcdFx0J3RvcCc6IHNlbGYub2Zmc2V0KCkudG9wICsgc2VsZi5vdXRlckhlaWdodCgpICsgcGFyc2VJbnQobGlzdC5jc3MoJ21hcmdpblRvcCcpLnJlcGxhY2UoJ3B4JywgJycpLCAxMClcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHBvc2l0aW9uIHNjcm9sbGluZ1xuXHRcdFx0dmFyIHNlbGVjdGVkID0gbGlzdC5maW5kKCcudWktdGltZXBpY2tlci1zZWxlY3RlZCcpO1xuXG5cdFx0XHRpZiAoIXNlbGVjdGVkLmxlbmd0aCkge1xuXHRcdFx0XHRpZiAoX2dldFRpbWVWYWx1ZShzZWxmKSkge1xuXHRcdFx0XHRcdHNlbGVjdGVkID0gX2ZpbmRSb3coc2VsZiwgbGlzdCwgX3RpbWUyaW50KF9nZXRUaW1lVmFsdWUoc2VsZikpKTtcblx0XHRcdFx0fSBlbHNlIGlmIChzZXR0aW5ncy5zY3JvbGxEZWZhdWx0Tm93KSB7XG5cdFx0XHRcdFx0c2VsZWN0ZWQgPSBfZmluZFJvdyhzZWxmLCBsaXN0LCBfdGltZTJpbnQobmV3IERhdGUoKSkpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHNldHRpbmdzLnNjcm9sbERlZmF1bHRUaW1lICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdHNlbGVjdGVkID0gX2ZpbmRSb3coc2VsZiwgbGlzdCwgX3RpbWUyaW50KHNldHRpbmdzLnNjcm9sbERlZmF1bHRUaW1lKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHNlbGVjdGVkICYmIHNlbGVjdGVkLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgdG9wT2Zmc2V0ID0gbGlzdC5zY3JvbGxUb3AoKSArIHNlbGVjdGVkLnBvc2l0aW9uKCkudG9wIC0gc2VsZWN0ZWQub3V0ZXJIZWlnaHQoKTtcblx0XHRcdFx0bGlzdC5zY3JvbGxUb3AodG9wT2Zmc2V0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxpc3Quc2Nyb2xsVG9wKDApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBhdHRhY2ggY2xvc2UgaGFuZGxlcnNcblx0XHRcdCQoJ2JvZHknKS5vbigndG91Y2hzdGFydC51aS10aW1lcGlja2VyIG1vdXNlZG93bi51aS10aW1lcGlja2VyJywgX2Nsb3NlSGFuZGxlcik7XG5cdFx0XHRpZiAoc2V0dGluZ3MuY2xvc2VPbldpbmRvd1Njcm9sbCkge1xuXHRcdFx0XHQkKHdpbmRvdykub24oJ3Njcm9sbC51aS10aW1lcGlja2VyJywgX2Nsb3NlSGFuZGxlcik7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGYudHJpZ2dlcignc2hvd1RpbWVwaWNrZXInKTtcblx0XHR9LFxuXG5cdFx0aGlkZTogZnVuY3Rpb24oZSlcblx0XHR7XG5cdFx0XHQkKCcudWktdGltZXBpY2tlci13cmFwcGVyOnZpc2libGUnKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbGlzdCA9ICQodGhpcyk7XG5cdFx0XHRcdHZhciBzZWxmID0gbGlzdC5kYXRhKCd0aW1lcGlja2VyLWlucHV0Jyk7XG5cdFx0XHRcdHZhciBzZXR0aW5ncyA9IHNlbGYuZGF0YSgndGltZXBpY2tlci1zZXR0aW5ncycpO1xuXG5cdFx0XHRcdGlmIChzZXR0aW5ncyAmJiBzZXR0aW5ncy5zZWxlY3RPbkJsdXIpIHtcblx0XHRcdFx0XHRfc2VsZWN0VmFsdWUoc2VsZik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsaXN0LmhpZGUoKTtcblx0XHRcdFx0c2VsZi50cmlnZ2VyKCdoaWRlVGltZXBpY2tlcicpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdG9wdGlvbjogZnVuY3Rpb24oa2V5LCB2YWx1ZSlcblx0XHR7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHR2YXIgc2V0dGluZ3MgPSBzZWxmLmRhdGEoJ3RpbWVwaWNrZXItc2V0dGluZ3MnKTtcblx0XHRcdHZhciBsaXN0ID0gc2VsZi5kYXRhKCd0aW1lcGlja2VyLWxpc3QnKTtcblxuXHRcdFx0aWYgKHR5cGVvZiBrZXkgPT0gJ29iamVjdCcpIHtcblx0XHRcdFx0c2V0dGluZ3MgPSAkLmV4dGVuZChzZXR0aW5ncywga2V5KTtcblxuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2Yga2V5ID09ICdzdHJpbmcnICYmIHR5cGVvZiB2YWx1ZSAhPSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRzZXR0aW5nc1trZXldID0gdmFsdWU7XG5cblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIGtleSA9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRyZXR1cm4gc2V0dGluZ3Nba2V5XTtcblx0XHRcdH1cblxuXHRcdFx0c2V0dGluZ3MgPSBfcGFyc2VTZXR0aW5ncyhzZXR0aW5ncyk7XG5cblx0XHRcdHNlbGYuZGF0YSgndGltZXBpY2tlci1zZXR0aW5ncycsIHNldHRpbmdzKTtcblxuXHRcdFx0aWYgKGxpc3QpIHtcblx0XHRcdFx0bGlzdC5yZW1vdmUoKTtcblx0XHRcdFx0c2VsZi5kYXRhKCd0aW1lcGlja2VyLWxpc3QnLCBmYWxzZSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZWxmO1xuXHRcdH0sXG5cblx0XHRnZXRTZWNvbmRzRnJvbU1pZG5pZ2h0OiBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIF90aW1lMmludChfZ2V0VGltZVZhbHVlKHRoaXMpKTtcblx0XHR9LFxuXG5cdFx0Z2V0VGltZTogZnVuY3Rpb24ocmVsYXRpdmVfZGF0ZSlcblx0XHR7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHRcdHZhciB0aW1lX3N0cmluZyA9IF9nZXRUaW1lVmFsdWUoc2VsZik7XG5cdFx0XHRpZiAoIXRpbWVfc3RyaW5nKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXJlbGF0aXZlX2RhdGUpIHtcblx0XHRcdFx0cmVsYXRpdmVfZGF0ZSA9IG5ldyBEYXRlKCk7XG5cdFx0XHR9XG5cblx0XHRcdHJlbGF0aXZlX2RhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG5cdFx0XHRyZXR1cm4gbmV3IERhdGUocmVsYXRpdmVfZGF0ZS52YWx1ZU9mKCkgKyAoX3RpbWUyaW50KHRpbWVfc3RyaW5nKSoxMDAwKSk7XG5cdFx0fSxcblxuXHRcdHNldFRpbWU6IGZ1bmN0aW9uKHZhbHVlKVxuXHRcdHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHZhciBwcmV0dHlUaW1lID0gX2ludDJ0aW1lKF90aW1lMmludCh2YWx1ZSksIHNlbGYuZGF0YSgndGltZXBpY2tlci1zZXR0aW5ncycpLnRpbWVGb3JtYXQpO1xuXG5cdFx0XHRfc2V0VGltZVZhbHVlKHNlbGYsIHByZXR0eVRpbWUpO1xuXHRcdFx0aWYgKHNlbGYuZGF0YSgndGltZXBpY2tlci1saXN0JykpIHtcblx0XHRcdFx0X3NldFNlbGVjdGVkKHNlbGYsIHNlbGYuZGF0YSgndGltZXBpY2tlci1saXN0JykpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRyZW1vdmU6IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHRcdC8vIGNoZWNrIGlmIHRoaXMgZWxlbWVudCBpcyBhIHRpbWVwaWNrZXJcblx0XHRcdGlmICghc2VsZi5oYXNDbGFzcygndWktdGltZXBpY2tlci1pbnB1dCcpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0c2VsZi5yZW1vdmVBdHRyKCdhdXRvY29tcGxldGUnLCAnb2ZmJyk7XG5cdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCd1aS10aW1lcGlja2VyLWlucHV0Jyk7XG5cdFx0XHRzZWxmLnJlbW92ZURhdGEoJ3RpbWVwaWNrZXItc2V0dGluZ3MnKTtcblx0XHRcdHNlbGYub2ZmKCcudGltZXBpY2tlcicpO1xuXG5cdFx0XHQvLyB0aW1lcGlja2VyLWxpc3Qgd29uJ3QgYmUgcHJlc2VudCB1bmxlc3MgdGhlIHVzZXIgaGFzIGludGVyYWN0ZWQgd2l0aCB0aGlzIHRpbWVwaWNrZXJcblx0XHRcdGlmIChzZWxmLmRhdGEoJ3RpbWVwaWNrZXItbGlzdCcpKSB7XG5cdFx0XHRcdHNlbGYuZGF0YSgndGltZXBpY2tlci1saXN0JykucmVtb3ZlKCk7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGYucmVtb3ZlRGF0YSgndGltZXBpY2tlci1saXN0Jyk7XG5cdFx0fVxuXHR9O1xuXG5cdC8vIHByaXZhdGUgbWV0aG9kc1xuXG5cdGZ1bmN0aW9uIF9wYXJzZVNldHRpbmdzKHNldHRpbmdzKVxuXHR7XG5cdFx0aWYgKHNldHRpbmdzLm1pblRpbWUpIHtcblx0XHRcdHNldHRpbmdzLm1pblRpbWUgPSBfdGltZTJpbnQoc2V0dGluZ3MubWluVGltZSk7XG5cdFx0fVxuXG5cdFx0aWYgKHNldHRpbmdzLm1heFRpbWUpIHtcblx0XHRcdHNldHRpbmdzLm1heFRpbWUgPSBfdGltZTJpbnQoc2V0dGluZ3MubWF4VGltZSk7XG5cdFx0fVxuXG5cdFx0aWYgKHNldHRpbmdzLmR1cmF0aW9uVGltZSAmJiB0eXBlb2Ygc2V0dGluZ3MuZHVyYXRpb25UaW1lICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRzZXR0aW5ncy5kdXJhdGlvblRpbWUgPSBfdGltZTJpbnQoc2V0dGluZ3MuZHVyYXRpb25UaW1lKTtcblx0XHR9XG5cblx0XHRpZiAoc2V0dGluZ3MuZGlzYWJsZVRpbWVSYW5nZXMubGVuZ3RoID4gMCkge1xuXHRcdFx0Ly8gY29udmVydCBzdHJpbmcgdGltZXMgdG8gaW50ZWdlcnNcblx0XHRcdGZvciAodmFyIGkgaW4gc2V0dGluZ3MuZGlzYWJsZVRpbWVSYW5nZXMpIHtcblx0XHRcdFx0c2V0dGluZ3MuZGlzYWJsZVRpbWVSYW5nZXNbaV0gPSBbXG5cdFx0XHRcdFx0X3RpbWUyaW50KHNldHRpbmdzLmRpc2FibGVUaW1lUmFuZ2VzW2ldWzBdKSxcblx0XHRcdFx0XHRfdGltZTJpbnQoc2V0dGluZ3MuZGlzYWJsZVRpbWVSYW5nZXNbaV1bMV0pXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cblx0XHRcdC8vIHNvcnQgYnkgc3RhcnRpbmcgdGltZVxuXHRcdFx0c2V0dGluZ3MuZGlzYWJsZVRpbWVSYW5nZXMgPSBzZXR0aW5ncy5kaXNhYmxlVGltZVJhbmdlcy5zb3J0KGZ1bmN0aW9uKGEsIGIpe1xuXHRcdFx0XHRyZXR1cm4gYVswXSAtIGJbMF07XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gbWVyZ2UgYW55IG92ZXJsYXBwaW5nIHJhbmdlc1xuXHRcdFx0Zm9yICh2YXIgaSA9IHNldHRpbmdzLmRpc2FibGVUaW1lUmFuZ2VzLmxlbmd0aC0xOyBpID4gMDsgaS0tKSB7XG5cdFx0XHRcdGlmIChzZXR0aW5ncy5kaXNhYmxlVGltZVJhbmdlc1tpXVswXSA8PSBzZXR0aW5ncy5kaXNhYmxlVGltZVJhbmdlc1tpLTFdWzFdKSB7XG5cdFx0XHRcdFx0c2V0dGluZ3MuZGlzYWJsZVRpbWVSYW5nZXNbaS0xXSA9IFtcblx0XHRcdFx0XHRcdE1hdGgubWluKHNldHRpbmdzLmRpc2FibGVUaW1lUmFuZ2VzW2ldWzBdLCBzZXR0aW5ncy5kaXNhYmxlVGltZVJhbmdlc1tpLTFdWzBdKSxcblx0XHRcdFx0XHRcdE1hdGgubWF4KHNldHRpbmdzLmRpc2FibGVUaW1lUmFuZ2VzW2ldWzFdLCBzZXR0aW5ncy5kaXNhYmxlVGltZVJhbmdlc1tpLTFdWzFdKVxuXHRcdFx0XHRcdF07XG5cdFx0XHRcdFx0c2V0dGluZ3MuZGlzYWJsZVRpbWVSYW5nZXMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNldHRpbmdzO1xuXHR9XG5cblx0ZnVuY3Rpb24gX3JlbmRlcihzZWxmKVxuXHR7XG5cdFx0dmFyIHNldHRpbmdzID0gc2VsZi5kYXRhKCd0aW1lcGlja2VyLXNldHRpbmdzJyk7XG5cdFx0dmFyIGxpc3QgPSBzZWxmLmRhdGEoJ3RpbWVwaWNrZXItbGlzdCcpO1xuXG5cdFx0aWYgKGxpc3QgJiYgbGlzdC5sZW5ndGgpIHtcblx0XHRcdGxpc3QucmVtb3ZlKCk7XG5cdFx0XHRzZWxmLmRhdGEoJ3RpbWVwaWNrZXItbGlzdCcsIGZhbHNlKTtcblx0XHR9XG5cblx0XHRsaXN0ID0gJCgnPHVsIC8+JywgeyAnY2xhc3MnOiAndWktdGltZXBpY2tlci1saXN0JyB9KTtcblxuXHRcdHZhciB3cmFwcGVkX2xpc3QgPSAkKCc8ZGl2IC8+JywgeyAnY2xhc3MnOiAndWktdGltZXBpY2tlci13cmFwcGVyJywgJ3RhYmluZGV4JzogLTEgfSk7XG5cdFx0d3JhcHBlZF9saXN0LmNzcyh7J2Rpc3BsYXknOidub25lJywgJ3Bvc2l0aW9uJzogJ2Fic29sdXRlJyB9KS5hcHBlbmQobGlzdCk7XG5cblxuXHRcdGlmIChzZXR0aW5ncy5jbGFzc05hbWUpIHtcblx0XHRcdHdyYXBwZWRfbGlzdC5hZGRDbGFzcyhzZXR0aW5ncy5jbGFzc05hbWUpO1xuXHRcdH1cblxuXHRcdGlmICgoc2V0dGluZ3MubWluVGltZSAhPT0gbnVsbCB8fCBzZXR0aW5ncy5kdXJhdGlvblRpbWUgIT09IG51bGwpICYmIHNldHRpbmdzLnNob3dEdXJhdGlvbikge1xuXHRcdFx0d3JhcHBlZF9saXN0LmFkZENsYXNzKCd1aS10aW1lcGlja2VyLXdpdGgtZHVyYXRpb24nKTtcblx0XHR9XG5cblx0XHR2YXIgZHVyU3RhcnQgPSBzZXR0aW5ncy5taW5UaW1lO1xuXHRcdGlmICh0eXBlb2Ygc2V0dGluZ3MuZHVyYXRpb25UaW1lID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRkdXJTdGFydCA9IF90aW1lMmludChzZXR0aW5ncy5kdXJhdGlvblRpbWUoKSk7XG5cdFx0fSBlbHNlIGlmIChzZXR0aW5ncy5kdXJhdGlvblRpbWUgIT09IG51bGwpIHtcblx0XHRcdGR1clN0YXJ0ID0gc2V0dGluZ3MuZHVyYXRpb25UaW1lO1xuXHRcdH1cblx0XHR2YXIgc3RhcnQgPSAoc2V0dGluZ3MubWluVGltZSAhPT0gbnVsbCkgPyBzZXR0aW5ncy5taW5UaW1lIDogMDtcblx0XHR2YXIgZW5kID0gKHNldHRpbmdzLm1heFRpbWUgIT09IG51bGwpID8gc2V0dGluZ3MubWF4VGltZSA6IChzdGFydCArIF9PTkVfREFZIC0gMSk7XG5cblx0XHRpZiAoZW5kIDw9IHN0YXJ0KSB7XG5cdFx0XHQvLyBtYWtlIHN1cmUgdGhlIGVuZCB0aW1lIGlzIGdyZWF0ZXIgdGhhbiBzdGFydCB0aW1lLCBvdGhlcndpc2UgdGhlcmUgd2lsbCBiZSBubyBsaXN0IHRvIHNob3dcblx0XHRcdGVuZCArPSBfT05FX0RBWTtcblx0XHR9XG5cblx0XHRpZiAoZW5kID09PSBfT05FX0RBWS0xICYmIHNldHRpbmdzLnRpbWVGb3JtYXQuaW5kZXhPZignSCcpICE9PSAtMSkge1xuXHRcdFx0Ly8gc2hvdyBhIDI0OjAwIG9wdGlvbiB3aGVuIHVzaW5nIG1pbGl0YXJ5IHRpbWVcblx0XHRcdGVuZCA9IF9PTkVfREFZO1xuXHRcdH1cblxuXHRcdHZhciBkciA9IHNldHRpbmdzLmRpc2FibGVUaW1lUmFuZ2VzO1xuXHRcdHZhciBkckN1ciA9IDA7XG5cdFx0dmFyIGRyTGVuID0gZHIubGVuZ3RoO1xuXG5cdFx0Zm9yICh2YXIgaT1zdGFydDsgaSA8PSBlbmQ7IGkgKz0gc2V0dGluZ3Muc3RlcCo2MCkge1xuXHRcdFx0dmFyIHRpbWVJbnQgPSBpO1xuXG5cdFx0XHR2YXIgcm93ID0gJCgnPGxpIC8+Jyk7XG5cdFx0XHRyb3cuZGF0YSgndGltZScsICh0aW1lSW50IDw9IDg2NDAwID8gdGltZUludCA6IHRpbWVJbnQgJSA4NjQwMCkpO1xuXHRcdFx0cm93LnRleHQoX2ludDJ0aW1lKHRpbWVJbnQsIHNldHRpbmdzLnRpbWVGb3JtYXQpKTtcblxuXHRcdFx0aWYgKChzZXR0aW5ncy5taW5UaW1lICE9PSBudWxsIHx8IHNldHRpbmdzLmR1cmF0aW9uVGltZSAhPT0gbnVsbCkgJiYgc2V0dGluZ3Muc2hvd0R1cmF0aW9uKSB7XG5cdFx0XHRcdHZhciBkdXJhdGlvbiA9ICQoJzxzcGFuIC8+Jyk7XG5cdFx0XHRcdGR1cmF0aW9uLmFkZENsYXNzKCd1aS10aW1lcGlja2VyLWR1cmF0aW9uJyk7XG5cdFx0XHRcdGR1cmF0aW9uLnRleHQoJyAoJytfaW50MmR1cmF0aW9uKGkgLSBkdXJTdGFydCkrJyknKTtcblx0XHRcdFx0cm93LmFwcGVuZChkdXJhdGlvbik7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChkckN1ciA8IGRyTGVuKSB7XG5cdFx0XHRcdGlmICh0aW1lSW50ID49IGRyW2RyQ3VyXVsxXSkge1xuXHRcdFx0XHRcdGRyQ3VyICs9IDE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZHJbZHJDdXJdICYmIHRpbWVJbnQgPj0gZHJbZHJDdXJdWzBdICYmIHRpbWVJbnQgPCBkcltkckN1cl1bMV0pIHtcblx0XHRcdFx0XHRyb3cuYWRkQ2xhc3MoJ3VpLXRpbWVwaWNrZXItZGlzYWJsZWQnKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRsaXN0LmFwcGVuZChyb3cpO1xuXHRcdH1cblxuXHRcdHdyYXBwZWRfbGlzdC5kYXRhKCd0aW1lcGlja2VyLWlucHV0Jywgc2VsZik7XG5cdFx0c2VsZi5kYXRhKCd0aW1lcGlja2VyLWxpc3QnLCB3cmFwcGVkX2xpc3QpO1xuXG5cdFx0dmFyIGFwcGVuZFRvID0gc2V0dGluZ3MuYXBwZW5kVG87XG5cdFx0aWYgKHR5cGVvZiBhcHBlbmRUbyA9PT0gJ3N0cmluZycpIHtcblx0XHRcdGFwcGVuZFRvID0gJChhcHBlbmRUbyk7XG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgYXBwZW5kVG8gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGFwcGVuZFRvID0gYXBwZW5kVG8oc2VsZik7XG5cdFx0fVxuXHRcdGFwcGVuZFRvLmFwcGVuZCh3cmFwcGVkX2xpc3QpO1xuXHRcdF9zZXRTZWxlY3RlZChzZWxmLCBsaXN0KTtcblxuXHRcdGxpc3Qub24oJ2NsaWNrJywgJ2xpJywgZnVuY3Rpb24oZSkge1xuXG5cdFx0XHQvLyBoYWNrOiB0ZW1wb3JhcmlseSBkaXNhYmxlIHRoZSBmb2N1cyBoYW5kbGVyXG5cdFx0XHQvLyB0byBkZWFsIHdpdGggdGhlIGZhY3QgdGhhdCBJRSBmaXJlcyAnZm9jdXMnXG5cdFx0XHQvLyBldmVudHMgYXN5bmNocm9ub3VzbHlcblx0XHRcdHNlbGYub2ZmKCdmb2N1cy50aW1lcGlja2VyJyk7XG5cdFx0XHRzZWxmLm9uKCdmb2N1cy50aW1lcGlja2VyLWllLWhhY2snLCBmdW5jdGlvbigpe1xuXHRcdFx0XHRzZWxmLm9mZignZm9jdXMudGltZXBpY2tlci1pZS1oYWNrJyk7XG5cdFx0XHRcdHNlbGYub24oJ2ZvY3VzLnRpbWVwaWNrZXInLCBtZXRob2RzLnNob3cpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGlmICghX2hpZGVLZXlib2FyZChzZWxmKSkge1xuXHRcdFx0XHRzZWxmWzBdLmZvY3VzKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIG1ha2Ugc3VyZSBvbmx5IHRoZSBjbGlja2VkIHJvdyBpcyBzZWxlY3RlZFxuXHRcdFx0bGlzdC5maW5kKCdsaScpLnJlbW92ZUNsYXNzKCd1aS10aW1lcGlja2VyLXNlbGVjdGVkJyk7XG5cdFx0XHQkKHRoaXMpLmFkZENsYXNzKCd1aS10aW1lcGlja2VyLXNlbGVjdGVkJyk7XG5cblx0XHRcdGlmIChfc2VsZWN0VmFsdWUoc2VsZikpIHtcblx0XHRcdFx0c2VsZi50cmlnZ2VyKCdoaWRlVGltZXBpY2tlcicpO1xuXHRcdFx0XHR3cmFwcGVkX2xpc3QuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gX2dlbmVyYXRlQmFzZURhdGUoKVxuXHR7XG5cdFx0cmV0dXJuIG5ldyBEYXRlKDE5NzAsIDEsIDEsIDAsIDAsIDApO1xuXHR9XG5cblx0Ly8gZXZlbnQgaGFuZGxlciB0byBkZWNpZGUgd2hldGhlciB0byBjbG9zZSB0aW1lcGlja2VyXG5cdGZ1bmN0aW9uIF9jbG9zZUhhbmRsZXIoZSlcblx0e1xuXHRcdHZhciB0YXJnZXQgPSAkKGUudGFyZ2V0KTtcblx0XHR2YXIgaW5wdXQgPSB0YXJnZXQuY2xvc2VzdCgnLnVpLXRpbWVwaWNrZXItaW5wdXQnKTtcblx0XHRpZiAoaW5wdXQubGVuZ3RoID09PSAwICYmIHRhcmdldC5jbG9zZXN0KCcudWktdGltZXBpY2tlci13cmFwcGVyJykubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRtZXRob2RzLmhpZGUoKTtcblx0XHRcdCQoJ2JvZHknKS51bmJpbmQoJy51aS10aW1lcGlja2VyJyk7XG5cdFx0XHQkKHdpbmRvdykudW5iaW5kKCcudWktdGltZXBpY2tlcicpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIF9oaWRlS2V5Ym9hcmQoc2VsZilcblx0e1xuXHRcdHZhciBzZXR0aW5ncyA9IHNlbGYuZGF0YSgndGltZXBpY2tlci1zZXR0aW5ncycpO1xuXHRcdHJldHVybiAoKHdpbmRvdy5uYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50cyB8fCAnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudCkgJiYgc2V0dGluZ3MuZGlzYWJsZVRvdWNoS2V5Ym9hcmQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gX2ZpbmRSb3coc2VsZiwgbGlzdCwgdmFsdWUpXG5cdHtcblx0XHRpZiAoIXZhbHVlICYmIHZhbHVlICE9PSAwKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dmFyIHNldHRpbmdzID0gc2VsZi5kYXRhKCd0aW1lcGlja2VyLXNldHRpbmdzJyk7XG5cdFx0dmFyIG91dCA9IGZhbHNlO1xuXHRcdHZhciBoYWxmU3RlcCA9IHNldHRpbmdzLnN0ZXAqMzA7XG5cblx0XHQvLyBsb29wIHRocm91Z2ggdGhlIG1lbnUgaXRlbXNcblx0XHRsaXN0LmZpbmQoJ2xpJykuZWFjaChmdW5jdGlvbihpLCBvYmopIHtcblx0XHRcdHZhciBqT2JqID0gJChvYmopO1xuXG5cdFx0XHR2YXIgb2Zmc2V0ID0gak9iai5kYXRhKCd0aW1lJykgLSB2YWx1ZTtcblxuXHRcdFx0Ly8gY2hlY2sgaWYgdGhlIHZhbHVlIGlzIGxlc3MgdGhhbiBoYWxmIGEgc3RlcCBmcm9tIGVhY2ggcm93XG5cdFx0XHRpZiAoTWF0aC5hYnMob2Zmc2V0KSA8IGhhbGZTdGVwIHx8IG9mZnNldCA9PSBoYWxmU3RlcCkge1xuXHRcdFx0XHRvdXQgPSBqT2JqO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gb3V0O1xuXHR9XG5cblx0ZnVuY3Rpb24gX3NldFNlbGVjdGVkKHNlbGYsIGxpc3QpXG5cdHtcblx0XHRsaXN0LmZpbmQoJ2xpJykucmVtb3ZlQ2xhc3MoJ3VpLXRpbWVwaWNrZXItc2VsZWN0ZWQnKTtcblxuXHRcdHZhciB0aW1lVmFsdWUgPSBfdGltZTJpbnQoX2dldFRpbWVWYWx1ZShzZWxmKSk7XG5cdFx0aWYgKHRpbWVWYWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBzZWxlY3RlZCA9IF9maW5kUm93KHNlbGYsIGxpc3QsIHRpbWVWYWx1ZSk7XG5cdFx0aWYgKHNlbGVjdGVkKSB7XG5cblx0XHRcdHZhciB0b3BEZWx0YSA9IHNlbGVjdGVkLm9mZnNldCgpLnRvcCAtIGxpc3Qub2Zmc2V0KCkudG9wO1xuXG5cdFx0XHRpZiAodG9wRGVsdGEgKyBzZWxlY3RlZC5vdXRlckhlaWdodCgpID4gbGlzdC5vdXRlckhlaWdodCgpIHx8IHRvcERlbHRhIDwgMCkge1xuXHRcdFx0XHRsaXN0LnNjcm9sbFRvcChsaXN0LnNjcm9sbFRvcCgpICsgc2VsZWN0ZWQucG9zaXRpb24oKS50b3AgLSBzZWxlY3RlZC5vdXRlckhlaWdodCgpKTtcblx0XHRcdH1cblxuXHRcdFx0c2VsZWN0ZWQuYWRkQ2xhc3MoJ3VpLXRpbWVwaWNrZXItc2VsZWN0ZWQnKTtcblx0XHR9XG5cdH1cblxuXG5cdGZ1bmN0aW9uIF9mb3JtYXRWYWx1ZSgpXG5cdHtcblx0XHRpZiAodGhpcy52YWx1ZSA9PT0gJycpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgc2VsZiA9ICQodGhpcyk7XG5cdFx0dmFyIGxpc3QgPSBzZWxmLmRhdGEoJ3RpbWVwaWNrZXItbGlzdCcpO1xuXG5cdFx0aWYgKGxpc3QgJiYgbGlzdC5pcygnOnZpc2libGUnKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBzZWNvbmRzID0gX3RpbWUyaW50KHRoaXMudmFsdWUpO1xuXG5cdFx0aWYgKHNlY29uZHMgPT09IG51bGwpIHtcblx0XHRcdHNlbGYudHJpZ2dlcigndGltZUZvcm1hdEVycm9yJyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHNldHRpbmdzID0gc2VsZi5kYXRhKCd0aW1lcGlja2VyLXNldHRpbmdzJyk7XG5cdFx0dmFyIHJhbmdlRXJyb3IgPSBmYWxzZTtcblx0XHQvLyBjaGVjayB0aGF0IHRoZSB0aW1lIGluIHdpdGhpbiBib3VuZHNcblx0XHRpZiAoc2V0dGluZ3MubWluVGltZSAhPT0gbnVsbCAmJiBzZWNvbmRzIDwgc2V0dGluZ3MubWluVGltZSkge1xuXHRcdFx0cmFuZ2VFcnJvciA9IHRydWU7XG5cdFx0fSBlbHNlIGlmIChzZXR0aW5ncy5tYXhUaW1lICE9PSBudWxsICYmIHNlY29uZHMgPiBzZXR0aW5ncy5tYXhUaW1lKSB7XG5cdFx0XHRyYW5nZUVycm9yID0gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBjaGVjayB0aGF0IHRpbWUgaXNuJ3Qgd2l0aGluIGRpc2FibGVkIHRpbWUgcmFuZ2VzXG5cdFx0JC5lYWNoKHNldHRpbmdzLmRpc2FibGVUaW1lUmFuZ2VzLCBmdW5jdGlvbigpe1xuXHRcdFx0aWYgKHNlY29uZHMgPj0gdGhpc1swXSAmJiBzZWNvbmRzIDwgdGhpc1sxXSkge1xuXHRcdFx0XHRyYW5nZUVycm9yID0gdHJ1ZTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0aWYgKHNldHRpbmdzLmZvcmNlUm91bmRUaW1lKSB7XG5cdFx0XHR2YXIgb2Zmc2V0ID0gc2Vjb25kcyAlIChzZXR0aW5ncy5zdGVwKjYwKTsgLy8gc3RlcCBpcyBpbiBtaW51dGVzXG5cblx0XHRcdGlmIChvZmZzZXQgPj0gc2V0dGluZ3Muc3RlcCozMCkge1xuXHRcdFx0XHQvLyBpZiBvZmZzZXQgaXMgbGFyZ2VyIHRoYW4gYSBoYWxmIHN0ZXAsIHJvdW5kIHVwXG5cdFx0XHRcdHNlY29uZHMgKz0gKHNldHRpbmdzLnN0ZXAqNjApIC0gb2Zmc2V0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gcm91bmQgZG93blxuXHRcdFx0XHRzZWNvbmRzIC09IG9mZnNldDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgcHJldHR5VGltZSA9IF9pbnQydGltZShzZWNvbmRzLCBzZXR0aW5ncy50aW1lRm9ybWF0KTtcblxuXHRcdGlmIChyYW5nZUVycm9yKSB7XG5cdFx0XHRpZiAoX3NldFRpbWVWYWx1ZShzZWxmLCBwcmV0dHlUaW1lLCAnZXJyb3InKSkge1xuXHRcdFx0XHRzZWxmLnRyaWdnZXIoJ3RpbWVSYW5nZUVycm9yJyk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdF9zZXRUaW1lVmFsdWUoc2VsZiwgcHJldHR5VGltZSk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gX2dldFRpbWVWYWx1ZShzZWxmKVxuXHR7XG5cdFx0aWYgKHNlbGYuaXMoJ2lucHV0JykpIHtcblx0XHRcdHJldHVybiBzZWxmLnZhbCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyB1c2UgdGhlIGVsZW1lbnQncyBkYXRhIGF0dHJpYnV0ZXMgdG8gc3RvcmUgdmFsdWVzXG5cdFx0XHRyZXR1cm4gc2VsZi5kYXRhKCd1aS10aW1lcGlja2VyLXZhbHVlJyk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gX3NldFRpbWVWYWx1ZShzZWxmLCB2YWx1ZSwgc291cmNlKVxuXHR7XG5cdFx0aWYgKHNlbGYuaXMoJ2lucHV0JykpIHtcblx0XHRcdHNlbGYudmFsKHZhbHVlKTtcblx0XHR9XG5cblx0XHRpZiAoc2VsZi5kYXRhKCd1aS10aW1lcGlja2VyLXZhbHVlJykgIT0gdmFsdWUpIHtcblx0XHRcdHNlbGYuZGF0YSgndWktdGltZXBpY2tlci12YWx1ZScsIHZhbHVlKTtcblx0XHRcdGlmIChzb3VyY2UgPT0gJ3NlbGVjdCcpIHtcblx0XHRcdFx0c2VsZi50cmlnZ2VyKCdzZWxlY3RUaW1lJykudHJpZ2dlcignY2hhbmdlVGltZScpLnRyaWdnZXIoJ2NoYW5nZScpO1xuXHRcdFx0fSBlbHNlIGlmIChzb3VyY2UgIT0gJ2Vycm9yJykge1xuXHRcdFx0XHRzZWxmLnRyaWdnZXIoJ2NoYW5nZVRpbWUnKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNlbGYudHJpZ2dlcignc2VsZWN0VGltZScpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdC8qXG5cdCogIEtleWJvYXJkIG5hdmlnYXRpb24gdmlhIGFycm93IGtleXNcblx0Ki9cblx0ZnVuY3Rpb24gX2tleWRvd25oYW5kbGVyKGUpXG5cdHtcblx0XHR2YXIgc2VsZiA9ICQodGhpcyk7XG5cdFx0dmFyIGxpc3QgPSBzZWxmLmRhdGEoJ3RpbWVwaWNrZXItbGlzdCcpO1xuXG5cdFx0aWYgKCFsaXN0IHx8ICFsaXN0LmlzKCc6dmlzaWJsZScpKSB7XG5cdFx0XHRpZiAoZS5rZXlDb2RlID09IDQwKSB7XG5cdFx0XHRcdGlmICghX2hpZGVLZXlib2FyZChzZWxmKSkge1xuXHRcdFx0XHRcdHNlbGYuZm9jdXMoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIF9zY3JlZW5JbnB1dChlLCBzZWxmKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRzd2l0Y2ggKGUua2V5Q29kZSkge1xuXG5cdFx0XHRjYXNlIDEzOiAvLyByZXR1cm5cblx0XHRcdFx0aWYgKF9zZWxlY3RWYWx1ZShzZWxmKSkge1xuXHRcdFx0XHRcdG1ldGhvZHMuaGlkZS5hcHBseSh0aGlzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRjYXNlIDM4OiAvLyB1cFxuXHRcdFx0XHR2YXIgc2VsZWN0ZWQgPSBsaXN0LmZpbmQoJy51aS10aW1lcGlja2VyLXNlbGVjdGVkJyk7XG5cblx0XHRcdFx0aWYgKCFzZWxlY3RlZC5sZW5ndGgpIHtcblx0XHRcdFx0XHRsaXN0LmZpbmQoJ2xpJykuZWFjaChmdW5jdGlvbihpLCBvYmopIHtcblx0XHRcdFx0XHRcdGlmICgkKG9iaikucG9zaXRpb24oKS50b3AgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdHNlbGVjdGVkID0gJChvYmopO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0c2VsZWN0ZWQuYWRkQ2xhc3MoJ3VpLXRpbWVwaWNrZXItc2VsZWN0ZWQnKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCFzZWxlY3RlZC5pcygnOmZpcnN0LWNoaWxkJykpIHtcblx0XHRcdFx0XHRzZWxlY3RlZC5yZW1vdmVDbGFzcygndWktdGltZXBpY2tlci1zZWxlY3RlZCcpO1xuXHRcdFx0XHRcdHNlbGVjdGVkLnByZXYoKS5hZGRDbGFzcygndWktdGltZXBpY2tlci1zZWxlY3RlZCcpO1xuXG5cdFx0XHRcdFx0aWYgKHNlbGVjdGVkLnByZXYoKS5wb3NpdGlvbigpLnRvcCA8IHNlbGVjdGVkLm91dGVySGVpZ2h0KCkpIHtcblx0XHRcdFx0XHRcdGxpc3Quc2Nyb2xsVG9wKGxpc3Quc2Nyb2xsVG9wKCkgLSBzZWxlY3RlZC5vdXRlckhlaWdodCgpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdGNhc2UgNDA6IC8vIGRvd25cblx0XHRcdFx0c2VsZWN0ZWQgPSBsaXN0LmZpbmQoJy51aS10aW1lcGlja2VyLXNlbGVjdGVkJyk7XG5cblx0XHRcdFx0aWYgKHNlbGVjdGVkLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdGxpc3QuZmluZCgnbGknKS5lYWNoKGZ1bmN0aW9uKGksIG9iaikge1xuXHRcdFx0XHRcdFx0aWYgKCQob2JqKS5wb3NpdGlvbigpLnRvcCA+IDApIHtcblx0XHRcdFx0XHRcdFx0c2VsZWN0ZWQgPSAkKG9iaik7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdHNlbGVjdGVkLmFkZENsYXNzKCd1aS10aW1lcGlja2VyLXNlbGVjdGVkJyk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIXNlbGVjdGVkLmlzKCc6bGFzdC1jaGlsZCcpKSB7XG5cdFx0XHRcdFx0c2VsZWN0ZWQucmVtb3ZlQ2xhc3MoJ3VpLXRpbWVwaWNrZXItc2VsZWN0ZWQnKTtcblx0XHRcdFx0XHRzZWxlY3RlZC5uZXh0KCkuYWRkQ2xhc3MoJ3VpLXRpbWVwaWNrZXItc2VsZWN0ZWQnKTtcblxuXHRcdFx0XHRcdGlmIChzZWxlY3RlZC5uZXh0KCkucG9zaXRpb24oKS50b3AgKyAyKnNlbGVjdGVkLm91dGVySGVpZ2h0KCkgPiBsaXN0Lm91dGVySGVpZ2h0KCkpIHtcblx0XHRcdFx0XHRcdGxpc3Quc2Nyb2xsVG9wKGxpc3Quc2Nyb2xsVG9wKCkgKyBzZWxlY3RlZC5vdXRlckhlaWdodCgpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdGNhc2UgMjc6IC8vIGVzY2FwZVxuXHRcdFx0XHRsaXN0LmZpbmQoJ2xpJykucmVtb3ZlQ2xhc3MoJ3VpLXRpbWVwaWNrZXItc2VsZWN0ZWQnKTtcblx0XHRcdFx0bWV0aG9kcy5oaWRlKCk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIDk6IC8vdGFiXG5cdFx0XHRcdG1ldGhvZHMuaGlkZSgpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIF9zY3JlZW5JbnB1dChlLCBzZWxmKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBfc2NyZWVuSW5wdXQoZSwgc2VsZilcblx0e1xuXHRcdHJldHVybiAhc2VsZi5kYXRhKCd0aW1lcGlja2VyLXNldHRpbmdzJykuZGlzYWJsZVRleHRJbnB1dCB8fCBlLmN0cmxLZXkgfHwgZS5hbHRLZXkgfHwgZS5tZXRhS2V5IHx8IChlLmtleUNvZGUgIT0gMiAmJiBlLmtleUNvZGUgIT0gOCAmJiBlLmtleUNvZGUgPCA0Nik7XG5cdH1cblxuXHQvKlxuXHQqXHRUaW1lIHR5cGVhaGVhZFxuXHQqL1xuXHRmdW5jdGlvbiBfa2V5dXBoYW5kbGVyKGUpXG5cdHtcblx0XHR2YXIgc2VsZiA9ICQodGhpcyk7XG5cdFx0dmFyIGxpc3QgPSBzZWxmLmRhdGEoJ3RpbWVwaWNrZXItbGlzdCcpO1xuXG5cdFx0aWYgKCFsaXN0IHx8ICFsaXN0LmlzKCc6dmlzaWJsZScpKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIXNlbGYuZGF0YSgndGltZXBpY2tlci1zZXR0aW5ncycpLnR5cGVhaGVhZEhpZ2hsaWdodCkge1xuXHRcdFx0bGlzdC5maW5kKCdsaScpLnJlbW92ZUNsYXNzKCd1aS10aW1lcGlja2VyLXNlbGVjdGVkJyk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRzd2l0Y2ggKGUua2V5Q29kZSkge1xuXG5cdFx0XHRjYXNlIDk2OiAvLyBudW1wYWQgbnVtZXJhbHNcblx0XHRcdGNhc2UgOTc6XG5cdFx0XHRjYXNlIDk4OlxuXHRcdFx0Y2FzZSA5OTpcblx0XHRcdGNhc2UgMTAwOlxuXHRcdFx0Y2FzZSAxMDE6XG5cdFx0XHRjYXNlIDEwMjpcblx0XHRcdGNhc2UgMTAzOlxuXHRcdFx0Y2FzZSAxMDQ6XG5cdFx0XHRjYXNlIDEwNTpcblx0XHRcdGNhc2UgNDg6IC8vIG51bWVyYWxzXG5cdFx0XHRjYXNlIDQ5OlxuXHRcdFx0Y2FzZSA1MDpcblx0XHRcdGNhc2UgNTE6XG5cdFx0XHRjYXNlIDUyOlxuXHRcdFx0Y2FzZSA1Mzpcblx0XHRcdGNhc2UgNTQ6XG5cdFx0XHRjYXNlIDU1OlxuXHRcdFx0Y2FzZSA1Njpcblx0XHRcdGNhc2UgNTc6XG5cdFx0XHRjYXNlIDY1OiAvLyBhXG5cdFx0XHRjYXNlIDc3OiAvLyBtXG5cdFx0XHRjYXNlIDgwOiAvLyBwXG5cdFx0XHRjYXNlIDE4NjogLy8gY29sb25cblx0XHRcdGNhc2UgODogLy8gYmFja3NwYWNlXG5cdFx0XHRjYXNlIDQ2OiAvLyBkZWxldGVcblx0XHRcdFx0X3NldFNlbGVjdGVkKHNlbGYsIGxpc3QpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0Ly8gbGlzdC5maW5kKCdsaScpLnJlbW92ZUNsYXNzKCd1aS10aW1lcGlja2VyLXNlbGVjdGVkJyk7XG5cdFx0XHRcdHJldHVybjtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBfc2VsZWN0VmFsdWUoc2VsZilcblx0e1xuXHRcdHZhciBzZXR0aW5ncyA9IHNlbGYuZGF0YSgndGltZXBpY2tlci1zZXR0aW5ncycpO1xuXHRcdHZhciBsaXN0ID0gc2VsZi5kYXRhKCd0aW1lcGlja2VyLWxpc3QnKTtcblx0XHR2YXIgdGltZVZhbHVlID0gbnVsbDtcblxuXHRcdHZhciBjdXJzb3IgPSBsaXN0LmZpbmQoJy51aS10aW1lcGlja2VyLXNlbGVjdGVkJyk7XG5cblx0XHRpZiAoY3Vyc29yLmhhc0NsYXNzKCd1aS10aW1lcGlja2VyLWRpc2FibGVkJykpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoY3Vyc29yLmxlbmd0aCkge1xuXHRcdFx0Ly8gc2VsZWN0ZWQgdmFsdWUgZm91bmRcblx0XHRcdHRpbWVWYWx1ZSA9IGN1cnNvci5kYXRhKCd0aW1lJyk7XG5cblx0XHR9IGVsc2UgaWYgKF9nZXRUaW1lVmFsdWUoc2VsZikpIHtcblxuXHRcdFx0Ly8gbm8gc2VsZWN0ZWQgdmFsdWU7IGZhbGwgYmFjayBvbiBpbnB1dCB2YWx1ZVxuXHRcdFx0dGltZVZhbHVlID0gX3RpbWUyaW50KF9nZXRUaW1lVmFsdWUoc2VsZikpO1xuXG5cdFx0XHRfc2V0U2VsZWN0ZWQoc2VsZiwgbGlzdCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRpbWVWYWx1ZSAhPT0gbnVsbCkge1xuXHRcdFx0dmFyIHRpbWVTdHJpbmcgPSBfaW50MnRpbWUodGltZVZhbHVlLCBzZXR0aW5ncy50aW1lRm9ybWF0KTtcblx0XHRcdF9zZXRUaW1lVmFsdWUoc2VsZiwgdGltZVN0cmluZywgJ3NlbGVjdCcpO1xuXHRcdH1cblxuXHRcdC8vc2VsZi50cmlnZ2VyKCdjaGFuZ2UnKS50cmlnZ2VyKCdzZWxlY3RUaW1lJyk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRmdW5jdGlvbiBfaW50MmR1cmF0aW9uKHNlY29uZHMpXG5cdHtcblx0XHR2YXIgbWludXRlcyA9IE1hdGgucm91bmQoc2Vjb25kcy82MCk7XG5cdFx0dmFyIGR1cmF0aW9uO1xuXG5cdFx0aWYgKE1hdGguYWJzKG1pbnV0ZXMpIDwgNjApIHtcblx0XHRcdGR1cmF0aW9uID0gW21pbnV0ZXMsIF9sYW5nLm1pbnNdO1xuXHRcdH0gZWxzZSBpZiAobWludXRlcyA9PSA2MCkge1xuXHRcdFx0ZHVyYXRpb24gPSBbJzEnLCBfbGFuZy5ocl07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBob3VycyA9IChtaW51dGVzLzYwKS50b0ZpeGVkKDEpO1xuXHRcdFx0aWYgKF9sYW5nLmRlY2ltYWwgIT0gJy4nKSBob3VycyA9IGhvdXJzLnJlcGxhY2UoJy4nLCBfbGFuZy5kZWNpbWFsKTtcblx0XHRcdGR1cmF0aW9uID0gW2hvdXJzLCBfbGFuZy5ocnNdO1xuXHRcdH1cblxuXHRcdHJldHVybiBkdXJhdGlvbi5qb2luKCcgJyk7XG5cdH1cblxuXHRmdW5jdGlvbiBfaW50MnRpbWUoc2Vjb25kcywgZm9ybWF0KVxuXHR7XG5cdFx0aWYgKHNlY29uZHMgPT09IG51bGwpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgdGltZSA9IG5ldyBEYXRlKF9iYXNlRGF0ZS52YWx1ZU9mKCkgKyAoc2Vjb25kcyoxMDAwKSk7XG5cdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdHZhciBob3VyLCBjb2RlO1xuXG5cdFx0Zm9yICh2YXIgaT0wOyBpPGZvcm1hdC5sZW5ndGg7IGkrKykge1xuXG5cdFx0XHRjb2RlID0gZm9ybWF0LmNoYXJBdChpKTtcblx0XHRcdHN3aXRjaCAoY29kZSkge1xuXG5cdFx0XHRcdGNhc2UgJ2EnOlxuXHRcdFx0XHRcdG91dHB1dCArPSAodGltZS5nZXRIb3VycygpID4gMTEpID8gJ3BtJyA6ICdhbSc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnQSc6XG5cdFx0XHRcdFx0b3V0cHV0ICs9ICh0aW1lLmdldEhvdXJzKCkgPiAxMSkgPyAnUE0nIDogJ0FNJztcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdnJzpcblx0XHRcdFx0XHRob3VyID0gdGltZS5nZXRIb3VycygpICUgMTI7XG5cdFx0XHRcdFx0b3V0cHV0ICs9IChob3VyID09PSAwKSA/ICcxMicgOiBob3VyO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0cnOlxuXHRcdFx0XHRcdG91dHB1dCArPSB0aW1lLmdldEhvdXJzKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnaCc6XG5cdFx0XHRcdFx0aG91ciA9IHRpbWUuZ2V0SG91cnMoKSAlIDEyO1xuXG5cdFx0XHRcdFx0aWYgKGhvdXIgIT09IDAgJiYgaG91ciA8IDEwKSB7XG5cdFx0XHRcdFx0XHRob3VyID0gJzAnK2hvdXI7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0ICs9IChob3VyID09PSAwKSA/ICcxMicgOiBob3VyO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0gnOlxuXHRcdFx0XHRcdGhvdXIgPSB0aW1lLmdldEhvdXJzKCk7XG5cdFx0XHRcdFx0aWYgKHNlY29uZHMgPT09IF9PTkVfREFZKSBob3VyID0gMjQ7XG5cdFx0XHRcdFx0b3V0cHV0ICs9IChob3VyID4gOSkgPyBob3VyIDogJzAnK2hvdXI7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnaSc6XG5cdFx0XHRcdFx0dmFyIG1pbnV0ZXMgPSB0aW1lLmdldE1pbnV0ZXMoKTtcblx0XHRcdFx0XHRvdXRwdXQgKz0gKG1pbnV0ZXMgPiA5KSA/IG1pbnV0ZXMgOiAnMCcrbWludXRlcztcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdzJzpcblx0XHRcdFx0XHRzZWNvbmRzID0gdGltZS5nZXRTZWNvbmRzKCk7XG5cdFx0XHRcdFx0b3V0cHV0ICs9IChzZWNvbmRzID4gOSkgPyBzZWNvbmRzIDogJzAnK3NlY29uZHM7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRvdXRwdXQgKz0gY29kZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0ZnVuY3Rpb24gX3RpbWUyaW50KHRpbWVTdHJpbmcpXG5cdHtcblx0XHRpZiAodGltZVN0cmluZyA9PT0gJycpIHJldHVybiBudWxsO1xuXHRcdGlmICghdGltZVN0cmluZyB8fCB0aW1lU3RyaW5nKzAgPT0gdGltZVN0cmluZykgcmV0dXJuIHRpbWVTdHJpbmc7XG5cblx0XHRpZiAodHlwZW9mKHRpbWVTdHJpbmcpID09ICdvYmplY3QnKSB7XG5cdFx0XHR0aW1lU3RyaW5nID0gdGltZVN0cmluZy5nZXRIb3VycygpKyc6JytfcGFkMih0aW1lU3RyaW5nLmdldE1pbnV0ZXMoKSkrJzonK19wYWQyKHRpbWVTdHJpbmcuZ2V0U2Vjb25kcygpKTtcblx0XHR9XG5cblx0XHR0aW1lU3RyaW5nID0gdGltZVN0cmluZy50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0dmFyIGQgPSBuZXcgRGF0ZSgwKTtcblx0XHR2YXIgdGltZTtcblxuXHRcdC8vIHRyeSB0byBwYXJzZSB0aW1lIGlucHV0XG5cdFx0aWYgKHRpbWVTdHJpbmcuaW5kZXhPZihcIjpcIikgPT09IC0xKSB7XG5cdFx0XHQvLyBubyBjb2xvbiBwcmVzZW50XG5cdFx0XHR0aW1lID0gdGltZVN0cmluZy5tYXRjaCgvXihbMC05XSk6PyhbMC01XVswLTldKT86PyhbMC01XVswLTldKT9cXHMqKFtwYV0/KW0/JC8pO1xuXG5cdFx0XHRpZiAoIXRpbWUpIHtcblx0XHRcdFx0dGltZSA9IHRpbWVTdHJpbmcubWF0Y2goL14oWzAtMl1bMC05XSk6PyhbMC01XVswLTldKT86PyhbMC01XVswLTldKT9cXHMqKFtwYV0/KW0/JC8pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aW1lID0gdGltZVN0cmluZy5tYXRjaCgvXihcXGR7MSwyfSkoPzo6KFswLTVdWzAtOV0pKT8oPzo6KFswLTVdWzAtOV0pKT9cXHMqKFtwYV0/KW0/JC8pO1xuXHRcdH1cblxuXHRcdGlmICghdGltZSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0dmFyIGhvdXIgPSBwYXJzZUludCh0aW1lWzFdKjEsIDEwKTtcblx0XHR2YXIgaG91cnM7XG5cblx0XHRpZiAodGltZVs0XSkge1xuXHRcdFx0aWYgKGhvdXIgPT0gMTIpIHtcblx0XHRcdFx0aG91cnMgPSAodGltZVs0XSA9PSAncCcpID8gMTIgOiAwO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aG91cnMgPSAoaG91ciArICh0aW1lWzRdID09ICdwJyA/IDEyIDogMCkpO1xuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGhvdXJzID0gaG91cjtcblx0XHR9XG5cblx0XHR2YXIgbWludXRlcyA9ICggdGltZVsyXSoxIHx8IDAgKTtcblx0XHR2YXIgc2Vjb25kcyA9ICggdGltZVszXSoxIHx8IDAgKTtcblx0XHRyZXR1cm4gaG91cnMqMzYwMCArIG1pbnV0ZXMqNjAgKyBzZWNvbmRzO1xuXHR9XG5cblx0ZnVuY3Rpb24gX3BhZDIobikge1xuXHRcdHJldHVybiAoXCIwXCIgKyBuKS5zbGljZSgtMik7XG5cdH1cblxuXHQvLyBQbHVnaW4gZW50cnlcblx0JC5mbi50aW1lcGlja2VyID0gZnVuY3Rpb24obWV0aG9kKVxuXHR7XG5cdFx0aWYobWV0aG9kc1ttZXRob2RdKSB7IHJldHVybiBtZXRob2RzW21ldGhvZF0uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7IH1cblx0XHRlbHNlIGlmKHR5cGVvZiBtZXRob2QgPT09IFwib2JqZWN0XCIgfHwgIW1ldGhvZCkgeyByZXR1cm4gbWV0aG9kcy5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblx0XHRlbHNlIHsgJC5lcnJvcihcIk1ldGhvZCBcIisgbWV0aG9kICsgXCIgZG9lcyBub3QgZXhpc3Qgb24galF1ZXJ5LnRpbWVwaWNrZXJcIik7IH1cblx0fTtcbn0pKTtcbiIsIi8vICAgICBVbmRlcnNjb3JlLmpzIDEuOC4yXG4vLyAgICAgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmdcbi8vICAgICAoYykgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgVW5kZXJzY29yZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8vIEJhc2VsaW5lIHNldHVwXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgaW4gdGhlIGJyb3dzZXIsIG9yIGBleHBvcnRzYCBvbiB0aGUgc2VydmVyLlxuICB2YXIgcm9vdCA9IHRoaXM7XG5cbiAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGBfYCB2YXJpYWJsZS5cbiAgdmFyIHByZXZpb3VzVW5kZXJzY29yZSA9IHJvb3QuXztcblxuICAvLyBTYXZlIGJ5dGVzIGluIHRoZSBtaW5pZmllZCAoYnV0IG5vdCBnemlwcGVkKSB2ZXJzaW9uOlxuICB2YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSwgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlLCBGdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbiAgLy8gQ3JlYXRlIHF1aWNrIHJlZmVyZW5jZSB2YXJpYWJsZXMgZm9yIHNwZWVkIGFjY2VzcyB0byBjb3JlIHByb3RvdHlwZXMuXG4gIHZhclxuICAgIHB1c2ggICAgICAgICAgICAgPSBBcnJheVByb3RvLnB1c2gsXG4gICAgc2xpY2UgICAgICAgICAgICA9IEFycmF5UHJvdG8uc2xpY2UsXG4gICAgdG9TdHJpbmcgICAgICAgICA9IE9ialByb3RvLnRvU3RyaW5nLFxuICAgIGhhc093blByb3BlcnR5ICAgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAvLyBBbGwgKipFQ01BU2NyaXB0IDUqKiBuYXRpdmUgZnVuY3Rpb24gaW1wbGVtZW50YXRpb25zIHRoYXQgd2UgaG9wZSB0byB1c2VcbiAgLy8gYXJlIGRlY2xhcmVkIGhlcmUuXG4gIHZhclxuICAgIG5hdGl2ZUlzQXJyYXkgICAgICA9IEFycmF5LmlzQXJyYXksXG4gICAgbmF0aXZlS2V5cyAgICAgICAgID0gT2JqZWN0LmtleXMsXG4gICAgbmF0aXZlQmluZCAgICAgICAgID0gRnVuY1Byb3RvLmJpbmQsXG4gICAgbmF0aXZlQ3JlYXRlICAgICAgID0gT2JqZWN0LmNyZWF0ZTtcblxuICAvLyBOYWtlZCBmdW5jdGlvbiByZWZlcmVuY2UgZm9yIHN1cnJvZ2F0ZS1wcm90b3R5cGUtc3dhcHBpbmcuXG4gIHZhciBDdG9yID0gZnVuY3Rpb24oKXt9O1xuXG4gIC8vIENyZWF0ZSBhIHNhZmUgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgdXNlIGJlbG93LlxuICB2YXIgXyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBfKSByZXR1cm4gb2JqO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfKSkgcmV0dXJuIG5ldyBfKG9iaik7XG4gICAgdGhpcy5fd3JhcHBlZCA9IG9iajtcbiAgfTtcblxuICAvLyBFeHBvcnQgdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciAqKk5vZGUuanMqKiwgd2l0aFxuICAvLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgdGhlIG9sZCBgcmVxdWlyZSgpYCBBUEkuIElmIHdlJ3JlIGluXG4gIC8vIHRoZSBicm93c2VyLCBhZGQgYF9gIGFzIGEgZ2xvYmFsIG9iamVjdC5cbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gXztcbiAgICB9XG4gICAgZXhwb3J0cy5fID0gXztcbiAgfSBlbHNlIHtcbiAgICByb290Ll8gPSBfO1xuICB9XG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uLlxuICBfLlZFUlNJT04gPSAnMS44LjInO1xuXG4gIC8vIEludGVybmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlZmZpY2llbnQgKGZvciBjdXJyZW50IGVuZ2luZXMpIHZlcnNpb25cbiAgLy8gb2YgdGhlIHBhc3NlZC1pbiBjYWxsYmFjaywgdG8gYmUgcmVwZWF0ZWRseSBhcHBsaWVkIGluIG90aGVyIFVuZGVyc2NvcmVcbiAgLy8gZnVuY3Rpb25zLlxuICB2YXIgb3B0aW1pemVDYiA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgcmV0dXJuIGZ1bmM7XG4gICAgc3dpdGNoIChhcmdDb3VudCA9PSBudWxsID8gMyA6IGFyZ0NvdW50KSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSwgb3RoZXIpO1xuICAgICAgfTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEEgbW9zdGx5LWludGVybmFsIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGNhbGxiYWNrcyB0aGF0IGNhbiBiZSBhcHBsaWVkXG4gIC8vIHRvIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24sIHJldHVybmluZyB0aGUgZGVzaXJlZCByZXN1bHQg4oCUIGVpdGhlclxuICAvLyBpZGVudGl0eSwgYW4gYXJiaXRyYXJ5IGNhbGxiYWNrLCBhIHByb3BlcnR5IG1hdGNoZXIsIG9yIGEgcHJvcGVydHkgYWNjZXNzb3IuXG4gIHZhciBjYiA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gXy5pZGVudGl0eTtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHZhbHVlKSkgcmV0dXJuIG9wdGltaXplQ2IodmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KTtcbiAgICBpZiAoXy5pc09iamVjdCh2YWx1ZSkpIHJldHVybiBfLm1hdGNoZXIodmFsdWUpO1xuICAgIHJldHVybiBfLnByb3BlcnR5KHZhbHVlKTtcbiAgfTtcbiAgXy5pdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNiKHZhbHVlLCBjb250ZXh0LCBJbmZpbml0eSk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGFzc2lnbmVyIGZ1bmN0aW9ucy5cbiAgdmFyIGNyZWF0ZUFzc2lnbmVyID0gZnVuY3Rpb24oa2V5c0Z1bmMsIHVuZGVmaW5lZE9ubHkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPCAyIHx8IG9iaiA9PSBudWxsKSByZXR1cm4gb2JqO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XSxcbiAgICAgICAgICAgIGtleXMgPSBrZXlzRnVuYyhzb3VyY2UpLFxuICAgICAgICAgICAgbCA9IGtleXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmICghdW5kZWZpbmVkT25seSB8fCBvYmpba2V5XSA9PT0gdm9pZCAwKSBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgbmV3IG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gYW5vdGhlci5cbiAgdmFyIGJhc2VDcmVhdGUgPSBmdW5jdGlvbihwcm90b3R5cGUpIHtcbiAgICBpZiAoIV8uaXNPYmplY3QocHJvdG90eXBlKSkgcmV0dXJuIHt9O1xuICAgIGlmIChuYXRpdmVDcmVhdGUpIHJldHVybiBuYXRpdmVDcmVhdGUocHJvdG90eXBlKTtcbiAgICBDdG9yLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEN0b3I7XG4gICAgQ3Rvci5wcm90b3R5cGUgPSBudWxsO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gSGVscGVyIGZvciBjb2xsZWN0aW9uIG1ldGhvZHMgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBjb2xsZWN0aW9uXG4gIC8vIHNob3VsZCBiZSBpdGVyYXRlZCBhcyBhbiBhcnJheSBvciBhcyBhbiBvYmplY3RcbiAgLy8gUmVsYXRlZDogaHR0cDovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9sZW5ndGhcbiAgdmFyIE1BWF9BUlJBWV9JTkRFWCA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG4gIHZhciBpc0FycmF5TGlrZSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbiAmJiBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICByZXR1cm4gdHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyAmJiBsZW5ndGggPj0gMCAmJiBsZW5ndGggPD0gTUFYX0FSUkFZX0lOREVYO1xuICB9O1xuXG4gIC8vIENvbGxlY3Rpb24gRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gVGhlIGNvcm5lcnN0b25lLCBhbiBgZWFjaGAgaW1wbGVtZW50YXRpb24sIGFrYSBgZm9yRWFjaGAuXG4gIC8vIEhhbmRsZXMgcmF3IG9iamVjdHMgaW4gYWRkaXRpb24gdG8gYXJyYXktbGlrZXMuIFRyZWF0cyBhbGxcbiAgLy8gc3BhcnNlIGFycmF5LWxpa2VzIGFzIGlmIHRoZXkgd2VyZSBkZW5zZS5cbiAgXy5lYWNoID0gXy5mb3JFYWNoID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGksIGxlbmd0aDtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtpXSwgaSwgb2JqKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlcmF0ZWUob2JqW2tleXNbaV1dLCBrZXlzW2ldLCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0ZWUgdG8gZWFjaCBlbGVtZW50LlxuICBfLm1hcCA9IF8uY29sbGVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0cyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIHJlc3VsdHNbaW5kZXhdID0gaXRlcmF0ZWUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDcmVhdGUgYSByZWR1Y2luZyBmdW5jdGlvbiBpdGVyYXRpbmcgbGVmdCBvciByaWdodC5cbiAgZnVuY3Rpb24gY3JlYXRlUmVkdWNlKGRpcikge1xuICAgIC8vIE9wdGltaXplZCBpdGVyYXRvciBmdW5jdGlvbiBhcyB1c2luZyBhcmd1bWVudHMubGVuZ3RoXG4gICAgLy8gaW4gdGhlIG1haW4gZnVuY3Rpb24gd2lsbCBkZW9wdGltaXplIHRoZSwgc2VlICMxOTkxLlxuICAgIGZ1bmN0aW9uIGl0ZXJhdG9yKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGtleXMsIGluZGV4LCBsZW5ndGgpIHtcbiAgICAgIGZvciAoOyBpbmRleCA+PSAwICYmIGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSBkaXIpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgICAgbWVtbyA9IGl0ZXJhdGVlKG1lbW8sIG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBtZW1vLCBjb250ZXh0KSB7XG4gICAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQsIDQpO1xuICAgICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcbiAgICAgICAgICBpbmRleCA9IGRpciA+IDAgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgIC8vIERldGVybWluZSB0aGUgaW5pdGlhbCB2YWx1ZSBpZiBub25lIGlzIHByb3ZpZGVkLlxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgICAgIG1lbW8gPSBvYmpba2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXhdO1xuICAgICAgICBpbmRleCArPSBkaXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0b3Iob2JqLCBpdGVyYXRlZSwgbWVtbywga2V5cywgaW5kZXgsIGxlbmd0aCk7XG4gICAgfTtcbiAgfVxuXG4gIC8vICoqUmVkdWNlKiogYnVpbGRzIHVwIGEgc2luZ2xlIHJlc3VsdCBmcm9tIGEgbGlzdCBvZiB2YWx1ZXMsIGFrYSBgaW5qZWN0YCxcbiAgLy8gb3IgYGZvbGRsYC5cbiAgXy5yZWR1Y2UgPSBfLmZvbGRsID0gXy5pbmplY3QgPSBjcmVhdGVSZWR1Y2UoMSk7XG5cbiAgLy8gVGhlIHJpZ2h0LWFzc29jaWF0aXZlIHZlcnNpb24gb2YgcmVkdWNlLCBhbHNvIGtub3duIGFzIGBmb2xkcmAuXG4gIF8ucmVkdWNlUmlnaHQgPSBfLmZvbGRyID0gY3JlYXRlUmVkdWNlKC0xKTtcblxuICAvLyBSZXR1cm4gdGhlIGZpcnN0IHZhbHVlIHdoaWNoIHBhc3NlcyBhIHRydXRoIHRlc3QuIEFsaWFzZWQgYXMgYGRldGVjdGAuXG4gIF8uZmluZCA9IF8uZGV0ZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIga2V5O1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSB7XG4gICAgICBrZXkgPSBfLmZpbmRJbmRleChvYmosIHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IF8uZmluZEtleShvYmosIHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgfVxuICAgIGlmIChrZXkgIT09IHZvaWQgMCAmJiBrZXkgIT09IC0xKSByZXR1cm4gb2JqW2tleV07XG4gIH07XG5cbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBwYXNzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgc2VsZWN0YC5cbiAgXy5maWx0ZXIgPSBfLnNlbGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGxpc3QpKSByZXN1bHRzLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGZvciB3aGljaCBhIHRydXRoIHRlc3QgZmFpbHMuXG4gIF8ucmVqZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm5lZ2F0ZShjYihwcmVkaWNhdGUpKSwgY29udGV4dCk7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgYWxsIG9mIHRoZSBlbGVtZW50cyBtYXRjaCBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYGFsbGAuXG4gIF8uZXZlcnkgPSBfLmFsbCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgaWYgKCFwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiBhdCBsZWFzdCBvbmUgZWxlbWVudCBpbiB0aGUgb2JqZWN0IG1hdGNoZXMgYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbnlgLlxuICBfLnNvbWUgPSBfLmFueSA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgaWYgKHByZWRpY2F0ZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaikpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBhcnJheSBvciBvYmplY3QgY29udGFpbnMgYSBnaXZlbiB2YWx1ZSAodXNpbmcgYD09PWApLlxuICAvLyBBbGlhc2VkIGFzIGBpbmNsdWRlc2AgYW5kIGBpbmNsdWRlYC5cbiAgXy5jb250YWlucyA9IF8uaW5jbHVkZXMgPSBfLmluY2x1ZGUgPSBmdW5jdGlvbihvYmosIHRhcmdldCwgZnJvbUluZGV4KSB7XG4gICAgaWYgKCFpc0FycmF5TGlrZShvYmopKSBvYmogPSBfLnZhbHVlcyhvYmopO1xuICAgIHJldHVybiBfLmluZGV4T2Yob2JqLCB0YXJnZXQsIHR5cGVvZiBmcm9tSW5kZXggPT0gJ251bWJlcicgJiYgZnJvbUluZGV4KSA+PSAwO1xuICB9O1xuXG4gIC8vIEludm9rZSBhIG1ldGhvZCAod2l0aCBhcmd1bWVudHMpIG9uIGV2ZXJ5IGl0ZW0gaW4gYSBjb2xsZWN0aW9uLlxuICBfLmludm9rZSA9IGZ1bmN0aW9uKG9iaiwgbWV0aG9kKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGlzRnVuYyA9IF8uaXNGdW5jdGlvbihtZXRob2QpO1xuICAgIHJldHVybiBfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzRnVuYyA/IG1ldGhvZCA6IHZhbHVlW21ldGhvZF07XG4gICAgICByZXR1cm4gZnVuYyA9PSBudWxsID8gZnVuYyA6IGZ1bmMuYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYG1hcGA6IGZldGNoaW5nIGEgcHJvcGVydHkuXG4gIF8ucGx1Y2sgPSBmdW5jdGlvbihvYmosIGtleSkge1xuICAgIHJldHVybiBfLm1hcChvYmosIF8ucHJvcGVydHkoa2V5KSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgZmlsdGVyYDogc2VsZWN0aW5nIG9ubHkgb2JqZWN0c1xuICAvLyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLndoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbHRlcihvYmosIF8ubWF0Y2hlcihhdHRycykpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbmRgOiBnZXR0aW5nIHRoZSBmaXJzdCBvYmplY3RcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5maW5kV2hlcmUgPSBmdW5jdGlvbihvYmosIGF0dHJzKSB7XG4gICAgcmV0dXJuIF8uZmluZChvYmosIF8ubWF0Y2hlcihhdHRycykpO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbWF4aW11bSBlbGVtZW50IChvciBlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgXy5tYXggPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IC1JbmZpbml0eSwgbGFzdENvbXB1dGVkID0gLUluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgJiYgb2JqICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlID4gcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPiBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IC1JbmZpbml0eSAmJiByZXN1bHQgPT09IC1JbmZpbml0eSkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1pbmltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWluID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSBJbmZpbml0eSwgbGFzdENvbXB1dGVkID0gSW5maW5pdHksXG4gICAgICAgIHZhbHVlLCBjb21wdXRlZDtcbiAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCAmJiBvYmogIT0gbnVsbCkge1xuICAgICAgb2JqID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gb2JqW2ldO1xuICAgICAgICBpZiAodmFsdWUgPCByZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgbGlzdCk7XG4gICAgICAgIGlmIChjb21wdXRlZCA8IGxhc3RDb21wdXRlZCB8fCBjb21wdXRlZCA9PT0gSW5maW5pdHkgJiYgcmVzdWx0ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBTaHVmZmxlIGEgY29sbGVjdGlvbiwgdXNpbmcgdGhlIG1vZGVybiB2ZXJzaW9uIG9mIHRoZVxuICAvLyBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVy4oCTWWF0ZXNfc2h1ZmZsZSkuXG4gIF8uc2h1ZmZsZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBzZXQgPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0gc2V0Lmxlbmd0aDtcbiAgICB2YXIgc2h1ZmZsZWQgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMCwgcmFuZDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHJhbmQgPSBfLnJhbmRvbSgwLCBpbmRleCk7XG4gICAgICBpZiAocmFuZCAhPT0gaW5kZXgpIHNodWZmbGVkW2luZGV4XSA9IHNodWZmbGVkW3JhbmRdO1xuICAgICAgc2h1ZmZsZWRbcmFuZF0gPSBzZXRbaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gc2h1ZmZsZWQ7XG4gIH07XG5cbiAgLy8gU2FtcGxlICoqbioqIHJhbmRvbSB2YWx1ZXMgZnJvbSBhIGNvbGxlY3Rpb24uXG4gIC8vIElmICoqbioqIGlzIG5vdCBzcGVjaWZpZWQsIHJldHVybnMgYSBzaW5nbGUgcmFuZG9tIGVsZW1lbnQuXG4gIC8vIFRoZSBpbnRlcm5hbCBgZ3VhcmRgIGFyZ3VtZW50IGFsbG93cyBpdCB0byB3b3JrIHdpdGggYG1hcGAuXG4gIF8uc2FtcGxlID0gZnVuY3Rpb24ob2JqLCBuLCBndWFyZCkge1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHtcbiAgICAgIGlmICghaXNBcnJheUxpa2Uob2JqKSkgb2JqID0gXy52YWx1ZXMob2JqKTtcbiAgICAgIHJldHVybiBvYmpbXy5yYW5kb20ob2JqLmxlbmd0aCAtIDEpXTtcbiAgICB9XG4gICAgcmV0dXJuIF8uc2h1ZmZsZShvYmopLnNsaWNlKDAsIE1hdGgubWF4KDAsIG4pKTtcbiAgfTtcblxuICAvLyBTb3J0IHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24gcHJvZHVjZWQgYnkgYW4gaXRlcmF0ZWUuXG4gIF8uc29ydEJ5ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHJldHVybiBfLnBsdWNrKF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgY3JpdGVyaWE6IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgbGlzdClcbiAgICAgIH07XG4gICAgfSkuc29ydChmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgdmFyIGEgPSBsZWZ0LmNyaXRlcmlhO1xuICAgICAgdmFyIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgIGlmIChhICE9PSBiKSB7XG4gICAgICAgIGlmIChhID4gYiB8fCBhID09PSB2b2lkIDApIHJldHVybiAxO1xuICAgICAgICBpZiAoYSA8IGIgfHwgYiA9PT0gdm9pZCAwKSByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVmdC5pbmRleCAtIHJpZ2h0LmluZGV4O1xuICAgIH0pLCAndmFsdWUnKTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiB1c2VkIGZvciBhZ2dyZWdhdGUgXCJncm91cCBieVwiIG9wZXJhdGlvbnMuXG4gIHZhciBncm91cCA9IGZ1bmN0aW9uKGJlaGF2aW9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHZhciBrZXkgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIG9iaik7XG4gICAgICAgIGJlaGF2aW9yKHJlc3VsdCwgdmFsdWUsIGtleSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBHcm91cHMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbi4gUGFzcyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlXG4gIC8vIHRvIGdyb3VwIGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY3JpdGVyaW9uLlxuICBfLmdyb3VwQnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICBpZiAoXy5oYXMocmVzdWx0LCBrZXkpKSByZXN1bHRba2V5XS5wdXNoKHZhbHVlKTsgZWxzZSByZXN1bHRba2V5XSA9IFt2YWx1ZV07XG4gIH0pO1xuXG4gIC8vIEluZGV4ZXMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbiwgc2ltaWxhciB0byBgZ3JvdXBCeWAsIGJ1dCBmb3JcbiAgLy8gd2hlbiB5b3Uga25vdyB0aGF0IHlvdXIgaW5kZXggdmFsdWVzIHdpbGwgYmUgdW5pcXVlLlxuICBfLmluZGV4QnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICB9KTtcblxuICAvLyBDb3VudHMgaW5zdGFuY2VzIG9mIGFuIG9iamVjdCB0aGF0IGdyb3VwIGJ5IGEgY2VydGFpbiBjcml0ZXJpb24uIFBhc3NcbiAgLy8gZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZSB0byBjb3VudCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gIC8vIGNyaXRlcmlvbi5cbiAgXy5jb3VudEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0rKzsgZWxzZSByZXN1bHRba2V5XSA9IDE7XG4gIH0pO1xuXG4gIC8vIFNhZmVseSBjcmVhdGUgYSByZWFsLCBsaXZlIGFycmF5IGZyb20gYW55dGhpbmcgaXRlcmFibGUuXG4gIF8udG9BcnJheSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm4gW107XG4gICAgaWYgKF8uaXNBcnJheShvYmopKSByZXR1cm4gc2xpY2UuY2FsbChvYmopO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSByZXR1cm4gXy5tYXAob2JqLCBfLmlkZW50aXR5KTtcbiAgICByZXR1cm4gXy52YWx1ZXMob2JqKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiBhbiBvYmplY3QuXG4gIF8uc2l6ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIDA7XG4gICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iaikgPyBvYmoubGVuZ3RoIDogXy5rZXlzKG9iaikubGVuZ3RoO1xuICB9O1xuXG4gIC8vIFNwbGl0IGEgY29sbGVjdGlvbiBpbnRvIHR3byBhcnJheXM6IG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgc2F0aXNmeSB0aGUgZ2l2ZW5cbiAgLy8gcHJlZGljYXRlLCBhbmQgb25lIHdob3NlIGVsZW1lbnRzIGFsbCBkbyBub3Qgc2F0aXNmeSB0aGUgcHJlZGljYXRlLlxuICBfLnBhcnRpdGlvbiA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIgcGFzcyA9IFtdLCBmYWlsID0gW107XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqKSB7XG4gICAgICAocHJlZGljYXRlKHZhbHVlLCBrZXksIG9iaikgPyBwYXNzIDogZmFpbCkucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtwYXNzLCBmYWlsXTtcbiAgfTtcblxuICAvLyBBcnJheSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gR2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYGhlYWRgIGFuZCBgdGFrZWAuIFRoZSAqKmd1YXJkKiogY2hlY2tcbiAgLy8gYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxuICBfLmZpcnN0ID0gXy5oZWFkID0gXy50YWtlID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkgcmV0dXJuIGFycmF5WzBdO1xuICAgIHJldHVybiBfLmluaXRpYWwoYXJyYXksIGFycmF5Lmxlbmd0aCAtIG4pO1xuICB9O1xuXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGxhc3QgZW50cnkgb2YgdGhlIGFycmF5LiBFc3BlY2lhbGx5IHVzZWZ1bCBvblxuICAvLyB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiBhbGwgdGhlIHZhbHVlcyBpblxuICAvLyB0aGUgYXJyYXksIGV4Y2x1ZGluZyB0aGUgbGFzdCBOLlxuICBfLmluaXRpYWwgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgMCwgTWF0aC5tYXgoMCwgYXJyYXkubGVuZ3RoIC0gKG4gPT0gbnVsbCB8fCBndWFyZCA/IDEgOiBuKSkpO1xuICB9O1xuXG4gIC8vIEdldCB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBsYXN0IE5cbiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS5cbiAgXy5sYXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBfLnJlc3QoYXJyYXksIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIG4pKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBmaXJzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYHRhaWxgIGFuZCBgZHJvcGAuXG4gIC8vIEVzcGVjaWFsbHkgdXNlZnVsIG9uIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nIGFuICoqbioqIHdpbGwgcmV0dXJuXG4gIC8vIHRoZSByZXN0IE4gdmFsdWVzIGluIHRoZSBhcnJheS5cbiAgXy5yZXN0ID0gXy50YWlsID0gXy5kcm9wID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIG4gPT0gbnVsbCB8fCBndWFyZCA/IDEgOiBuKTtcbiAgfTtcblxuICAvLyBUcmltIG91dCBhbGwgZmFsc3kgdmFsdWVzIGZyb20gYW4gYXJyYXkuXG4gIF8uY29tcGFjdCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBfLmlkZW50aXR5KTtcbiAgfTtcblxuICAvLyBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiBhIHJlY3Vyc2l2ZSBgZmxhdHRlbmAgZnVuY3Rpb24uXG4gIHZhciBmbGF0dGVuID0gZnVuY3Rpb24oaW5wdXQsIHNoYWxsb3csIHN0cmljdCwgc3RhcnRJbmRleCkge1xuICAgIHZhciBvdXRwdXQgPSBbXSwgaWR4ID0gMDtcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleCB8fCAwLCBsZW5ndGggPSBpbnB1dCAmJiBpbnB1dC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gaW5wdXRbaV07XG4gICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmIChfLmlzQXJyYXkodmFsdWUpIHx8IF8uaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgICAgICAvL2ZsYXR0ZW4gY3VycmVudCBsZXZlbCBvZiBhcnJheSBvciBhcmd1bWVudHMgb2JqZWN0XG4gICAgICAgIGlmICghc2hhbGxvdykgdmFsdWUgPSBmbGF0dGVuKHZhbHVlLCBzaGFsbG93LCBzdHJpY3QpO1xuICAgICAgICB2YXIgaiA9IDAsIGxlbiA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgb3V0cHV0Lmxlbmd0aCArPSBsZW47XG4gICAgICAgIHdoaWxlIChqIDwgbGVuKSB7XG4gICAgICAgICAgb3V0cHV0W2lkeCsrXSA9IHZhbHVlW2orK107XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCkge1xuICAgICAgICBvdXRwdXRbaWR4KytdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG5cbiAgLy8gRmxhdHRlbiBvdXQgYW4gYXJyYXksIGVpdGhlciByZWN1cnNpdmVseSAoYnkgZGVmYXVsdCksIG9yIGp1c3Qgb25lIGxldmVsLlxuICBfLmZsYXR0ZW4gPSBmdW5jdGlvbihhcnJheSwgc2hhbGxvdykge1xuICAgIHJldHVybiBmbGF0dGVuKGFycmF5LCBzaGFsbG93LCBmYWxzZSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgdmVyc2lvbiBvZiB0aGUgYXJyYXkgdGhhdCBkb2VzIG5vdCBjb250YWluIHRoZSBzcGVjaWZpZWQgdmFsdWUocykuXG4gIF8ud2l0aG91dCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgcmV0dXJuIF8uZGlmZmVyZW5jZShhcnJheSwgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGEgZHVwbGljYXRlLWZyZWUgdmVyc2lvbiBvZiB0aGUgYXJyYXkuIElmIHRoZSBhcnJheSBoYXMgYWxyZWFkeVxuICAvLyBiZWVuIHNvcnRlZCwgeW91IGhhdmUgdGhlIG9wdGlvbiBvZiB1c2luZyBhIGZhc3RlciBhbGdvcml0aG0uXG4gIC8vIEFsaWFzZWQgYXMgYHVuaXF1ZWAuXG4gIF8udW5pcSA9IF8udW5pcXVlID0gZnVuY3Rpb24oYXJyYXksIGlzU29ydGVkLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gW107XG4gICAgaWYgKCFfLmlzQm9vbGVhbihpc1NvcnRlZCkpIHtcbiAgICAgIGNvbnRleHQgPSBpdGVyYXRlZTtcbiAgICAgIGl0ZXJhdGVlID0gaXNTb3J0ZWQ7XG4gICAgICBpc1NvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXRlcmF0ZWUgIT0gbnVsbCkgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBzZWVuID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpXSxcbiAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUsIGksIGFycmF5KSA6IHZhbHVlO1xuICAgICAgaWYgKGlzU29ydGVkKSB7XG4gICAgICAgIGlmICghaSB8fCBzZWVuICE9PSBjb21wdXRlZCkgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICBzZWVuID0gY29tcHV0ZWQ7XG4gICAgICB9IGVsc2UgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhzZWVuLCBjb21wdXRlZCkpIHtcbiAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghXy5jb250YWlucyhyZXN1bHQsIHZhbHVlKSkge1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSB1bmlvbjogZWFjaCBkaXN0aW5jdCBlbGVtZW50IGZyb20gYWxsIG9mXG4gIC8vIHRoZSBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLnVuaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW5pcShmbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSkpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyBldmVyeSBpdGVtIHNoYXJlZCBiZXR3ZWVuIGFsbCB0aGVcbiAgLy8gcGFzc2VkLWluIGFycmF5cy5cbiAgXy5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihhcnJheSkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gW107XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gYXJyYXlbaV07XG4gICAgICBpZiAoXy5jb250YWlucyhyZXN1bHQsIGl0ZW0pKSBjb250aW51ZTtcbiAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgYXJnc0xlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhhcmd1bWVudHNbal0sIGl0ZW0pKSBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChqID09PSBhcmdzTGVuZ3RoKSByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBUYWtlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gb25lIGFycmF5IGFuZCBhIG51bWJlciBvZiBvdGhlciBhcnJheXMuXG4gIC8vIE9ubHkgdGhlIGVsZW1lbnRzIHByZXNlbnQgaW4ganVzdCB0aGUgZmlyc3QgYXJyYXkgd2lsbCByZW1haW4uXG4gIF8uZGlmZmVyZW5jZSA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHJlc3QgPSBmbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSwgMSk7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICByZXR1cm4gIV8uY29udGFpbnMocmVzdCwgdmFsdWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFppcCB0b2dldGhlciBtdWx0aXBsZSBsaXN0cyBpbnRvIGEgc2luZ2xlIGFycmF5IC0tIGVsZW1lbnRzIHRoYXQgc2hhcmVcbiAgLy8gYW4gaW5kZXggZ28gdG9nZXRoZXIuXG4gIF8uemlwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW56aXAoYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBDb21wbGVtZW50IG9mIF8uemlwLiBVbnppcCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyBhbmQgZ3JvdXBzXG4gIC8vIGVhY2ggYXJyYXkncyBlbGVtZW50cyBvbiBzaGFyZWQgaW5kaWNlc1xuICBfLnVuemlwID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgJiYgXy5tYXgoYXJyYXksICdsZW5ndGgnKS5sZW5ndGggfHwgMDtcbiAgICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBfLnBsdWNrKGFycmF5LCBpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gQ29udmVydHMgbGlzdHMgaW50byBvYmplY3RzLiBQYXNzIGVpdGhlciBhIHNpbmdsZSBhcnJheSBvZiBgW2tleSwgdmFsdWVdYFxuICAvLyBwYWlycywgb3IgdHdvIHBhcmFsbGVsIGFycmF5cyBvZiB0aGUgc2FtZSBsZW5ndGggLS0gb25lIG9mIGtleXMsIGFuZCBvbmUgb2ZcbiAgLy8gdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICBfLm9iamVjdCA9IGZ1bmN0aW9uKGxpc3QsIHZhbHVlcykge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbGlzdCAmJiBsaXN0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldXSA9IHZhbHVlc1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldWzBdXSA9IGxpc3RbaV1bMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhbiBpdGVtIGluIGFuIGFycmF5LFxuICAvLyBvciAtMSBpZiB0aGUgaXRlbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIGFycmF5LlxuICAvLyBJZiB0aGUgYXJyYXkgaXMgbGFyZ2UgYW5kIGFscmVhZHkgaW4gc29ydCBvcmRlciwgcGFzcyBgdHJ1ZWBcbiAgLy8gZm9yICoqaXNTb3J0ZWQqKiB0byB1c2UgYmluYXJ5IHNlYXJjaC5cbiAgXy5pbmRleE9mID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGlzU29ydGVkKSB7XG4gICAgdmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheSAmJiBhcnJheS5sZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBpc1NvcnRlZCA9PSAnbnVtYmVyJykge1xuICAgICAgaSA9IGlzU29ydGVkIDwgMCA/IE1hdGgubWF4KDAsIGxlbmd0aCArIGlzU29ydGVkKSA6IGlzU29ydGVkO1xuICAgIH0gZWxzZSBpZiAoaXNTb3J0ZWQgJiYgbGVuZ3RoKSB7XG4gICAgICBpID0gXy5zb3J0ZWRJbmRleChhcnJheSwgaXRlbSk7XG4gICAgICByZXR1cm4gYXJyYXlbaV0gPT09IGl0ZW0gPyBpIDogLTE7XG4gICAgfVxuICAgIGlmIChpdGVtICE9PSBpdGVtKSB7XG4gICAgICByZXR1cm4gXy5maW5kSW5kZXgoc2xpY2UuY2FsbChhcnJheSwgaSksIF8uaXNOYU4pO1xuICAgIH1cbiAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSBpZiAoYXJyYXlbaV0gPT09IGl0ZW0pIHJldHVybiBpO1xuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICBfLmxhc3RJbmRleE9mID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGZyb20pIHtcbiAgICB2YXIgaWR4ID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgIGlmICh0eXBlb2YgZnJvbSA9PSAnbnVtYmVyJykge1xuICAgICAgaWR4ID0gZnJvbSA8IDAgPyBpZHggKyBmcm9tICsgMSA6IE1hdGgubWluKGlkeCwgZnJvbSArIDEpO1xuICAgIH1cbiAgICBpZiAoaXRlbSAhPT0gaXRlbSkge1xuICAgICAgcmV0dXJuIF8uZmluZExhc3RJbmRleChzbGljZS5jYWxsKGFycmF5LCAwLCBpZHgpLCBfLmlzTmFOKTtcbiAgICB9XG4gICAgd2hpbGUgKC0taWR4ID49IDApIGlmIChhcnJheVtpZHhdID09PSBpdGVtKSByZXR1cm4gaWR4O1xuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICAvLyBHZW5lcmF0b3IgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBmaW5kSW5kZXggYW5kIGZpbmRMYXN0SW5kZXggZnVuY3Rpb25zXG4gIGZ1bmN0aW9uIGNyZWF0ZUluZGV4RmluZGVyKGRpcikge1xuICAgIHJldHVybiBmdW5jdGlvbihhcnJheSwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ICE9IG51bGwgJiYgYXJyYXkubGVuZ3RoO1xuICAgICAgdmFyIGluZGV4ID0gZGlyID4gMCA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgZm9yICg7IGluZGV4ID49IDAgJiYgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IGRpcikge1xuICAgICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBvbiBhbiBhcnJheS1saWtlIHRoYXQgcGFzc2VzIGEgcHJlZGljYXRlIHRlc3RcbiAgXy5maW5kSW5kZXggPSBjcmVhdGVJbmRleEZpbmRlcigxKTtcblxuICBfLmZpbmRMYXN0SW5kZXggPSBjcmVhdGVJbmRleEZpbmRlcigtMSk7XG5cbiAgLy8gVXNlIGEgY29tcGFyYXRvciBmdW5jdGlvbiB0byBmaWd1cmUgb3V0IHRoZSBzbWFsbGVzdCBpbmRleCBhdCB3aGljaFxuICAvLyBhbiBvYmplY3Qgc2hvdWxkIGJlIGluc2VydGVkIHNvIGFzIHRvIG1haW50YWluIG9yZGVyLiBVc2VzIGJpbmFyeSBzZWFyY2guXG4gIF8uc29ydGVkSW5kZXggPSBmdW5jdGlvbihhcnJheSwgb2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQsIDEpO1xuICAgIHZhciB2YWx1ZSA9IGl0ZXJhdGVlKG9iaik7XG4gICAgdmFyIGxvdyA9IDAsIGhpZ2ggPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgIHZhciBtaWQgPSBNYXRoLmZsb29yKChsb3cgKyBoaWdoKSAvIDIpO1xuICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W21pZF0pIDwgdmFsdWUpIGxvdyA9IG1pZCArIDE7IGVsc2UgaGlnaCA9IG1pZDtcbiAgICB9XG4gICAgcmV0dXJuIGxvdztcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhbiBpbnRlZ2VyIEFycmF5IGNvbnRhaW5pbmcgYW4gYXJpdGhtZXRpYyBwcm9ncmVzc2lvbi4gQSBwb3J0IG9mXG4gIC8vIHRoZSBuYXRpdmUgUHl0aG9uIGByYW5nZSgpYCBmdW5jdGlvbi4gU2VlXG4gIC8vIFt0aGUgUHl0aG9uIGRvY3VtZW50YXRpb25dKGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS9mdW5jdGlvbnMuaHRtbCNyYW5nZSkuXG4gIF8ucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgIHN0b3AgPSBzdGFydCB8fCAwO1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgICBzdGVwID0gc3RlcCB8fCAxO1xuXG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApLCAwKTtcbiAgICB2YXIgcmFuZ2UgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKywgc3RhcnQgKz0gc3RlcCkge1xuICAgICAgcmFuZ2VbaWR4XSA9IHN0YXJ0O1xuICAgIH1cblxuICAgIHJldHVybiByYW5nZTtcbiAgfTtcblxuICAvLyBGdW5jdGlvbiAoYWhlbSkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIERldGVybWluZXMgd2hldGhlciB0byBleGVjdXRlIGEgZnVuY3Rpb24gYXMgYSBjb25zdHJ1Y3RvclxuICAvLyBvciBhIG5vcm1hbCBmdW5jdGlvbiB3aXRoIHRoZSBwcm92aWRlZCBhcmd1bWVudHNcbiAgdmFyIGV4ZWN1dGVCb3VuZCA9IGZ1bmN0aW9uKHNvdXJjZUZ1bmMsIGJvdW5kRnVuYywgY29udGV4dCwgY2FsbGluZ0NvbnRleHQsIGFyZ3MpIHtcbiAgICBpZiAoIShjYWxsaW5nQ29udGV4dCBpbnN0YW5jZW9mIGJvdW5kRnVuYykpIHJldHVybiBzb3VyY2VGdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIHZhciBzZWxmID0gYmFzZUNyZWF0ZShzb3VyY2VGdW5jLnByb3RvdHlwZSk7XG4gICAgdmFyIHJlc3VsdCA9IHNvdXJjZUZ1bmMuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgaWYgKF8uaXNPYmplY3QocmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICByZXR1cm4gc2VsZjtcbiAgfTtcblxuICAvLyBDcmVhdGUgYSBmdW5jdGlvbiBib3VuZCB0byBhIGdpdmVuIG9iamVjdCAoYXNzaWduaW5nIGB0aGlzYCwgYW5kIGFyZ3VtZW50cyxcbiAgLy8gb3B0aW9uYWxseSkuIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBGdW5jdGlvbi5iaW5kYCBpZlxuICAvLyBhdmFpbGFibGUuXG4gIF8uYmluZCA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQpIHtcbiAgICBpZiAobmF0aXZlQmluZCAmJiBmdW5jLmJpbmQgPT09IG5hdGl2ZUJpbmQpIHJldHVybiBuYXRpdmVCaW5kLmFwcGx5KGZ1bmMsIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgaWYgKCFfLmlzRnVuY3Rpb24oZnVuYykpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JpbmQgbXVzdCBiZSBjYWxsZWQgb24gYSBmdW5jdGlvbicpO1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBib3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4ZWN1dGVCb3VuZChmdW5jLCBib3VuZCwgY29udGV4dCwgdGhpcywgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgfTtcbiAgICByZXR1cm4gYm91bmQ7XG4gIH07XG5cbiAgLy8gUGFydGlhbGx5IGFwcGx5IGEgZnVuY3Rpb24gYnkgY3JlYXRpbmcgYSB2ZXJzaW9uIHRoYXQgaGFzIGhhZCBzb21lIG9mIGl0c1xuICAvLyBhcmd1bWVudHMgcHJlLWZpbGxlZCwgd2l0aG91dCBjaGFuZ2luZyBpdHMgZHluYW1pYyBgdGhpc2AgY29udGV4dC4gXyBhY3RzXG4gIC8vIGFzIGEgcGxhY2Vob2xkZXIsIGFsbG93aW5nIGFueSBjb21iaW5hdGlvbiBvZiBhcmd1bWVudHMgdG8gYmUgcHJlLWZpbGxlZC5cbiAgXy5wYXJ0aWFsID0gZnVuY3Rpb24oZnVuYykge1xuICAgIHZhciBib3VuZEFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgdmFyIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9zaXRpb24gPSAwLCBsZW5ndGggPSBib3VuZEFyZ3MubGVuZ3RoO1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheShsZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBhcmdzW2ldID0gYm91bmRBcmdzW2ldID09PSBfID8gYXJndW1lbnRzW3Bvc2l0aW9uKytdIDogYm91bmRBcmdzW2ldO1xuICAgICAgfVxuICAgICAgd2hpbGUgKHBvc2l0aW9uIDwgYXJndW1lbnRzLmxlbmd0aCkgYXJncy5wdXNoKGFyZ3VtZW50c1twb3NpdGlvbisrXSk7XG4gICAgICByZXR1cm4gZXhlY3V0ZUJvdW5kKGZ1bmMsIGJvdW5kLCB0aGlzLCB0aGlzLCBhcmdzKTtcbiAgICB9O1xuICAgIHJldHVybiBib3VuZDtcbiAgfTtcblxuICAvLyBCaW5kIGEgbnVtYmVyIG9mIGFuIG9iamVjdCdzIG1ldGhvZHMgdG8gdGhhdCBvYmplY3QuIFJlbWFpbmluZyBhcmd1bWVudHNcbiAgLy8gYXJlIHRoZSBtZXRob2QgbmFtZXMgdG8gYmUgYm91bmQuIFVzZWZ1bCBmb3IgZW5zdXJpbmcgdGhhdCBhbGwgY2FsbGJhY2tzXG4gIC8vIGRlZmluZWQgb24gYW4gb2JqZWN0IGJlbG9uZyB0byBpdC5cbiAgXy5iaW5kQWxsID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGksIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsIGtleTtcbiAgICBpZiAobGVuZ3RoIDw9IDEpIHRocm93IG5ldyBFcnJvcignYmluZEFsbCBtdXN0IGJlIHBhc3NlZCBmdW5jdGlvbiBuYW1lcycpO1xuICAgIGZvciAoaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gYXJndW1lbnRzW2ldO1xuICAgICAgb2JqW2tleV0gPSBfLmJpbmQob2JqW2tleV0sIG9iaik7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gTWVtb2l6ZSBhbiBleHBlbnNpdmUgZnVuY3Rpb24gYnkgc3RvcmluZyBpdHMgcmVzdWx0cy5cbiAgXy5tZW1vaXplID0gZnVuY3Rpb24oZnVuYywgaGFzaGVyKSB7XG4gICAgdmFyIG1lbW9pemUgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZhciBjYWNoZSA9IG1lbW9pemUuY2FjaGU7XG4gICAgICB2YXIgYWRkcmVzcyA9ICcnICsgKGhhc2hlciA/IGhhc2hlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDoga2V5KTtcbiAgICAgIGlmICghXy5oYXMoY2FjaGUsIGFkZHJlc3MpKSBjYWNoZVthZGRyZXNzXSA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBjYWNoZVthZGRyZXNzXTtcbiAgICB9O1xuICAgIG1lbW9pemUuY2FjaGUgPSB7fTtcbiAgICByZXR1cm4gbWVtb2l6ZTtcbiAgfTtcblxuICAvLyBEZWxheXMgYSBmdW5jdGlvbiBmb3IgdGhlIGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIGFuZCB0aGVuIGNhbGxzXG4gIC8vIGl0IHdpdGggdGhlIGFyZ3VtZW50cyBzdXBwbGllZC5cbiAgXy5kZWxheSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSwgd2FpdCk7XG4gIH07XG5cbiAgLy8gRGVmZXJzIGEgZnVuY3Rpb24sIHNjaGVkdWxpbmcgaXQgdG8gcnVuIGFmdGVyIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzXG4gIC8vIGNsZWFyZWQuXG4gIF8uZGVmZXIgPSBfLnBhcnRpYWwoXy5kZWxheSwgXywgMSk7XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCB3aGVuIGludm9rZWQsIHdpbGwgb25seSBiZSB0cmlnZ2VyZWQgYXQgbW9zdCBvbmNlXG4gIC8vIGR1cmluZyBhIGdpdmVuIHdpbmRvdyBvZiB0aW1lLiBOb3JtYWxseSwgdGhlIHRocm90dGxlZCBmdW5jdGlvbiB3aWxsIHJ1blxuICAvLyBhcyBtdWNoIGFzIGl0IGNhbiwgd2l0aG91dCBldmVyIGdvaW5nIG1vcmUgdGhhbiBvbmNlIHBlciBgd2FpdGAgZHVyYXRpb247XG4gIC8vIGJ1dCBpZiB5b3UnZCBsaWtlIHRvIGRpc2FibGUgdGhlIGV4ZWN1dGlvbiBvbiB0aGUgbGVhZGluZyBlZGdlLCBwYXNzXG4gIC8vIGB7bGVhZGluZzogZmFsc2V9YC4gVG8gZGlzYWJsZSBleGVjdXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2UsIGRpdHRvLlxuICBfLnRocm90dGxlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgIHZhciBjb250ZXh0LCBhcmdzLCByZXN1bHQ7XG4gICAgdmFyIHRpbWVvdXQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91cyA9IDA7XG4gICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICBwcmV2aW91cyA9IG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UgPyAwIDogXy5ub3coKTtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5vdyA9IF8ubm93KCk7XG4gICAgICBpZiAoIXByZXZpb3VzICYmIG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UpIHByZXZpb3VzID0gbm93O1xuICAgICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93IC0gcHJldmlvdXMpO1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgaWYgKHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+IHdhaXQpIHtcbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICghdGltZW91dCAmJiBvcHRpb25zLnRyYWlsaW5nICE9PSBmYWxzZSkge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgcmVtYWluaW5nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIGFzIGxvbmcgYXMgaXQgY29udGludWVzIHRvIGJlIGludm9rZWQsIHdpbGwgbm90XG4gIC8vIGJlIHRyaWdnZXJlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGl0IHN0b3BzIGJlaW5nIGNhbGxlZCBmb3JcbiAgLy8gTiBtaWxsaXNlY29uZHMuIElmIGBpbW1lZGlhdGVgIGlzIHBhc3NlZCwgdHJpZ2dlciB0aGUgZnVuY3Rpb24gb24gdGhlXG4gIC8vIGxlYWRpbmcgZWRnZSwgaW5zdGVhZCBvZiB0aGUgdHJhaWxpbmcuXG4gIF8uZGVib3VuY2UgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICB2YXIgdGltZW91dCwgYXJncywgY29udGV4dCwgdGltZXN0YW1wLCByZXN1bHQ7XG5cbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsYXN0ID0gXy5ub3coKSAtIHRpbWVzdGFtcDtcblxuICAgICAgaWYgKGxhc3QgPCB3YWl0ICYmIGxhc3QgPj0gMCkge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCAtIGxhc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIGlmICghaW1tZWRpYXRlKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB0aW1lc3RhbXAgPSBfLm5vdygpO1xuICAgICAgdmFyIGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG4gICAgICBpZiAoIXRpbWVvdXQpIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICAgIGlmIChjYWxsTm93KSB7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGZ1bmN0aW9uIHBhc3NlZCBhcyBhbiBhcmd1bWVudCB0byB0aGUgc2Vjb25kLFxuICAvLyBhbGxvd2luZyB5b3UgdG8gYWRqdXN0IGFyZ3VtZW50cywgcnVuIGNvZGUgYmVmb3JlIGFuZCBhZnRlciwgYW5kXG4gIC8vIGNvbmRpdGlvbmFsbHkgZXhlY3V0ZSB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXG4gIF8ud3JhcCA9IGZ1bmN0aW9uKGZ1bmMsIHdyYXBwZXIpIHtcbiAgICByZXR1cm4gXy5wYXJ0aWFsKHdyYXBwZXIsIGZ1bmMpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBuZWdhdGVkIHZlcnNpb24gb2YgdGhlIHBhc3NlZC1pbiBwcmVkaWNhdGUuXG4gIF8ubmVnYXRlID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICFwcmVkaWNhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBhIGxpc3Qgb2YgZnVuY3Rpb25zLCBlYWNoXG4gIC8vIGNvbnN1bWluZyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB0aGF0IGZvbGxvd3MuXG4gIF8uY29tcG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBzdGFydCA9IGFyZ3MubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaSA9IHN0YXJ0O1xuICAgICAgdmFyIHJlc3VsdCA9IGFyZ3Nbc3RhcnRdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB3aGlsZSAoaS0tKSByZXN1bHQgPSBhcmdzW2ldLmNhbGwodGhpcywgcmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgb24gYW5kIGFmdGVyIHRoZSBOdGggY2FsbC5cbiAgXy5hZnRlciA9IGZ1bmN0aW9uKHRpbWVzLCBmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tdGltZXMgPCAxKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgdXAgdG8gKGJ1dCBub3QgaW5jbHVkaW5nKSB0aGUgTnRoIGNhbGwuXG4gIF8uYmVmb3JlID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICB2YXIgbWVtbztcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA+IDApIHtcbiAgICAgICAgbWVtbyA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aW1lcyA8PSAxKSBmdW5jID0gbnVsbDtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhdCBtb3N0IG9uZSB0aW1lLCBubyBtYXR0ZXIgaG93XG4gIC8vIG9mdGVuIHlvdSBjYWxsIGl0LiBVc2VmdWwgZm9yIGxhenkgaW5pdGlhbGl6YXRpb24uXG4gIF8ub25jZSA9IF8ucGFydGlhbChfLmJlZm9yZSwgMik7XG5cbiAgLy8gT2JqZWN0IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gS2V5cyBpbiBJRSA8IDkgdGhhdCB3b24ndCBiZSBpdGVyYXRlZCBieSBgZm9yIGtleSBpbiAuLi5gIGFuZCB0aHVzIG1pc3NlZC5cbiAgdmFyIGhhc0VudW1CdWcgPSAhe3RvU3RyaW5nOiBudWxsfS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgndG9TdHJpbmcnKTtcbiAgdmFyIG5vbkVudW1lcmFibGVQcm9wcyA9IFsndmFsdWVPZicsICdpc1Byb3RvdHlwZU9mJywgJ3RvU3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAncHJvcGVydHlJc0VudW1lcmFibGUnLCAnaGFzT3duUHJvcGVydHknLCAndG9Mb2NhbGVTdHJpbmcnXTtcblxuICBmdW5jdGlvbiBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cykge1xuICAgIHZhciBub25FbnVtSWR4ID0gbm9uRW51bWVyYWJsZVByb3BzLmxlbmd0aDtcbiAgICB2YXIgY29uc3RydWN0b3IgPSBvYmouY29uc3RydWN0b3I7XG4gICAgdmFyIHByb3RvID0gKF8uaXNGdW5jdGlvbihjb25zdHJ1Y3RvcikgJiYgY29uc3RydWN0b3IucHJvdG90eXBlKSB8fCBPYmpQcm90bztcblxuICAgIC8vIENvbnN0cnVjdG9yIGlzIGEgc3BlY2lhbCBjYXNlLlxuICAgIHZhciBwcm9wID0gJ2NvbnN0cnVjdG9yJztcbiAgICBpZiAoXy5oYXMob2JqLCBwcm9wKSAmJiAhXy5jb250YWlucyhrZXlzLCBwcm9wKSkga2V5cy5wdXNoKHByb3ApO1xuXG4gICAgd2hpbGUgKG5vbkVudW1JZHgtLSkge1xuICAgICAgcHJvcCA9IG5vbkVudW1lcmFibGVQcm9wc1tub25FbnVtSWR4XTtcbiAgICAgIGlmIChwcm9wIGluIG9iaiAmJiBvYmpbcHJvcF0gIT09IHByb3RvW3Byb3BdICYmICFfLmNvbnRhaW5zKGtleXMsIHByb3ApKSB7XG4gICAgICAgIGtleXMucHVzaChwcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBSZXRyaWV2ZSB0aGUgbmFtZXMgb2YgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBPYmplY3Qua2V5c2BcbiAgXy5rZXlzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBbXTtcbiAgICBpZiAobmF0aXZlS2V5cykgcmV0dXJuIG5hdGl2ZUtleXMob2JqKTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGlmIChfLmhhcyhvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICAgIC8vIEFoZW0sIElFIDwgOS5cbiAgICBpZiAoaGFzRW51bUJ1ZykgY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpO1xuICAgIHJldHVybiBrZXlzO1xuICB9O1xuXG4gIC8vIFJldHJpZXZlIGFsbCB0aGUgcHJvcGVydHkgbmFtZXMgb2YgYW4gb2JqZWN0LlxuICBfLmFsbEtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gICAgLy8gQWhlbSwgSUUgPCA5LlxuICAgIGlmIChoYXNFbnVtQnVnKSBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cyk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgdGhlIHZhbHVlcyBvZiBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICBfLnZhbHVlcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciB2YWx1ZXMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbHVlc1tpXSA9IG9ialtrZXlzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcblxuICAvLyBSZXR1cm5zIHRoZSByZXN1bHRzIG9mIGFwcGx5aW5nIHRoZSBpdGVyYXRlZSB0byBlYWNoIGVsZW1lbnQgb2YgdGhlIG9iamVjdFxuICAvLyBJbiBjb250cmFzdCB0byBfLm1hcCBpdCByZXR1cm5zIGFuIG9iamVjdFxuICBfLm1hcE9iamVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICBfLmtleXMob2JqKSxcbiAgICAgICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHRzID0ge30sXG4gICAgICAgICAgY3VycmVudEtleTtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgY3VycmVudEtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgICByZXN1bHRzW2N1cnJlbnRLZXldID0gaXRlcmF0ZWUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gQ29udmVydCBhbiBvYmplY3QgaW50byBhIGxpc3Qgb2YgYFtrZXksIHZhbHVlXWAgcGFpcnMuXG4gIF8ucGFpcnMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgcGFpcnMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhaXJzW2ldID0gW2tleXNbaV0sIG9ialtrZXlzW2ldXV07XG4gICAgfVxuICAgIHJldHVybiBwYWlycztcbiAgfTtcblxuICAvLyBJbnZlcnQgdGhlIGtleXMgYW5kIHZhbHVlcyBvZiBhbiBvYmplY3QuIFRoZSB2YWx1ZXMgbXVzdCBiZSBzZXJpYWxpemFibGUuXG4gIF8uaW52ZXJ0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdFtvYmpba2V5c1tpXV1dID0ga2V5c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSBzb3J0ZWQgbGlzdCBvZiB0aGUgZnVuY3Rpb24gbmFtZXMgYXZhaWxhYmxlIG9uIHRoZSBvYmplY3QuXG4gIC8vIEFsaWFzZWQgYXMgYG1ldGhvZHNgXG4gIF8uZnVuY3Rpb25zID0gXy5tZXRob2RzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIG5hbWVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKF8uaXNGdW5jdGlvbihvYmpba2V5XSkpIG5hbWVzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWVzLnNvcnQoKTtcbiAgfTtcblxuICAvLyBFeHRlbmQgYSBnaXZlbiBvYmplY3Qgd2l0aCBhbGwgdGhlIHByb3BlcnRpZXMgaW4gcGFzc2VkLWluIG9iamVjdChzKS5cbiAgXy5leHRlbmQgPSBjcmVhdGVBc3NpZ25lcihfLmFsbEtleXMpO1xuXG4gIC8vIEFzc2lnbnMgYSBnaXZlbiBvYmplY3Qgd2l0aCBhbGwgdGhlIG93biBwcm9wZXJ0aWVzIGluIHRoZSBwYXNzZWQtaW4gb2JqZWN0KHMpXG4gIC8vIChodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvYXNzaWduKVxuICBfLmV4dGVuZE93biA9IF8uYXNzaWduID0gY3JlYXRlQXNzaWduZXIoXy5rZXlzKTtcblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBrZXkgb24gYW4gb2JqZWN0IHRoYXQgcGFzc2VzIGEgcHJlZGljYXRlIHRlc3RcbiAgXy5maW5kS2V5ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaiksIGtleTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2tleV0sIGtleSwgb2JqKSkgcmV0dXJuIGtleTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IG9ubHkgY29udGFpbmluZyB0aGUgd2hpdGVsaXN0ZWQgcHJvcGVydGllcy5cbiAgXy5waWNrID0gZnVuY3Rpb24ob2JqZWN0LCBvaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0ge30sIG9iaiA9IG9iamVjdCwgaXRlcmF0ZWUsIGtleXM7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0O1xuICAgIGlmIChfLmlzRnVuY3Rpb24ob2l0ZXJhdGVlKSkge1xuICAgICAga2V5cyA9IF8uYWxsS2V5cyhvYmopO1xuICAgICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKG9pdGVyYXRlZSwgY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleXMgPSBmbGF0dGVuKGFyZ3VtZW50cywgZmFsc2UsIGZhbHNlLCAxKTtcbiAgICAgIGl0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqKSB7IHJldHVybiBrZXkgaW4gb2JqOyB9O1xuICAgICAgb2JqID0gT2JqZWN0KG9iaik7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgaWYgKGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iaikpIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCB3aXRob3V0IHRoZSBibGFja2xpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLm9taXQgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihpdGVyYXRlZSkpIHtcbiAgICAgIGl0ZXJhdGVlID0gXy5uZWdhdGUoaXRlcmF0ZWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIga2V5cyA9IF8ubWFwKGZsYXR0ZW4oYXJndW1lbnRzLCBmYWxzZSwgZmFsc2UsIDEpLCBTdHJpbmcpO1xuICAgICAgaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHJldHVybiAhXy5jb250YWlucyhrZXlzLCBrZXkpO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIF8ucGljayhvYmosIGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgfTtcblxuICAvLyBGaWxsIGluIGEgZ2l2ZW4gb2JqZWN0IHdpdGggZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICBfLmRlZmF1bHRzID0gY3JlYXRlQXNzaWduZXIoXy5hbGxLZXlzLCB0cnVlKTtcblxuICAvLyBDcmVhdGUgYSAoc2hhbGxvdy1jbG9uZWQpIGR1cGxpY2F0ZSBvZiBhbiBvYmplY3QuXG4gIF8uY2xvbmUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIG9iajtcbiAgICByZXR1cm4gXy5pc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IF8uZXh0ZW5kKHt9LCBvYmopO1xuICB9O1xuXG4gIC8vIEludm9rZXMgaW50ZXJjZXB0b3Igd2l0aCB0aGUgb2JqLCBhbmQgdGhlbiByZXR1cm5zIG9iai5cbiAgLy8gVGhlIHByaW1hcnkgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0byBcInRhcCBpbnRvXCIgYSBtZXRob2QgY2hhaW4sIGluXG4gIC8vIG9yZGVyIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiBpbnRlcm1lZGlhdGUgcmVzdWx0cyB3aXRoaW4gdGhlIGNoYWluLlxuICBfLnRhcCA9IGZ1bmN0aW9uKG9iaiwgaW50ZXJjZXB0b3IpIHtcbiAgICBpbnRlcmNlcHRvcihvYmopO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gUmV0dXJucyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBzZXQgb2YgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8uaXNNYXRjaCA9IGZ1bmN0aW9uKG9iamVjdCwgYXR0cnMpIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhhdHRycyksIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkgcmV0dXJuICFsZW5ndGg7XG4gICAgdmFyIG9iaiA9IE9iamVjdChvYmplY3QpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKGF0dHJzW2tleV0gIT09IG9ialtrZXldIHx8ICEoa2V5IGluIG9iaikpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cblxuICAvLyBJbnRlcm5hbCByZWN1cnNpdmUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgYGlzRXF1YWxgLlxuICB2YXIgZXEgPSBmdW5jdGlvbihhLCBiLCBhU3RhY2ssIGJTdGFjaykge1xuICAgIC8vIElkZW50aWNhbCBvYmplY3RzIGFyZSBlcXVhbC4gYDAgPT09IC0wYCwgYnV0IHRoZXkgYXJlbid0IGlkZW50aWNhbC5cbiAgICAvLyBTZWUgdGhlIFtIYXJtb255IGBlZ2FsYCBwcm9wb3NhbF0oaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTplZ2FsKS5cbiAgICBpZiAoYSA9PT0gYikgcmV0dXJuIGEgIT09IDAgfHwgMSAvIGEgPT09IDEgLyBiO1xuICAgIC8vIEEgc3RyaWN0IGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5IGJlY2F1c2UgYG51bGwgPT0gdW5kZWZpbmVkYC5cbiAgICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkgcmV0dXJuIGEgPT09IGI7XG4gICAgLy8gVW53cmFwIGFueSB3cmFwcGVkIG9iamVjdHMuXG4gICAgaWYgKGEgaW5zdGFuY2VvZiBfKSBhID0gYS5fd3JhcHBlZDtcbiAgICBpZiAoYiBpbnN0YW5jZW9mIF8pIGIgPSBiLl93cmFwcGVkO1xuICAgIC8vIENvbXBhcmUgYFtbQ2xhc3NdXWAgbmFtZXMuXG4gICAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwoYSk7XG4gICAgaWYgKGNsYXNzTmFtZSAhPT0gdG9TdHJpbmcuY2FsbChiKSkgcmV0dXJuIGZhbHNlO1xuICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgICAvLyBTdHJpbmdzLCBudW1iZXJzLCByZWd1bGFyIGV4cHJlc3Npb25zLCBkYXRlcywgYW5kIGJvb2xlYW5zIGFyZSBjb21wYXJlZCBieSB2YWx1ZS5cbiAgICAgIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6XG4gICAgICAvLyBSZWdFeHBzIGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MgZm9yIGNvbXBhcmlzb24gKE5vdGU6ICcnICsgL2EvaSA9PT0gJy9hL2knKVxuICAgICAgY2FzZSAnW29iamVjdCBTdHJpbmddJzpcbiAgICAgICAgLy8gUHJpbWl0aXZlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBvYmplY3Qgd3JhcHBlcnMgYXJlIGVxdWl2YWxlbnQ7IHRodXMsIGBcIjVcImAgaXNcbiAgICAgICAgLy8gZXF1aXZhbGVudCB0byBgbmV3IFN0cmluZyhcIjVcIilgLlxuICAgICAgICByZXR1cm4gJycgKyBhID09PSAnJyArIGI7XG4gICAgICBjYXNlICdbb2JqZWN0IE51bWJlcl0nOlxuICAgICAgICAvLyBgTmFOYHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCBub24tcmVmbGV4aXZlLlxuICAgICAgICAvLyBPYmplY3QoTmFOKSBpcyBlcXVpdmFsZW50IHRvIE5hTlxuICAgICAgICBpZiAoK2EgIT09ICthKSByZXR1cm4gK2IgIT09ICtiO1xuICAgICAgICAvLyBBbiBgZWdhbGAgY29tcGFyaXNvbiBpcyBwZXJmb3JtZWQgZm9yIG90aGVyIG51bWVyaWMgdmFsdWVzLlxuICAgICAgICByZXR1cm4gK2EgPT09IDAgPyAxIC8gK2EgPT09IDEgLyBiIDogK2EgPT09ICtiO1xuICAgICAgY2FzZSAnW29iamVjdCBEYXRlXSc6XG4gICAgICBjYXNlICdbb2JqZWN0IEJvb2xlYW5dJzpcbiAgICAgICAgLy8gQ29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1lcmljIHByaW1pdGl2ZSB2YWx1ZXMuIERhdGVzIGFyZSBjb21wYXJlZCBieSB0aGVpclxuICAgICAgICAvLyBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnMuIE5vdGUgdGhhdCBpbnZhbGlkIGRhdGVzIHdpdGggbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zXG4gICAgICAgIC8vIG9mIGBOYU5gIGFyZSBub3QgZXF1aXZhbGVudC5cbiAgICAgICAgcmV0dXJuICthID09PSArYjtcbiAgICB9XG5cbiAgICB2YXIgYXJlQXJyYXlzID0gY2xhc3NOYW1lID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIGlmICghYXJlQXJyYXlzKSB7XG4gICAgICBpZiAodHlwZW9mIGEgIT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gT2JqZWN0cyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVpdmFsZW50LCBidXQgYE9iamVjdGBzIG9yIGBBcnJheWBzXG4gICAgICAvLyBmcm9tIGRpZmZlcmVudCBmcmFtZXMgYXJlLlxuICAgICAgdmFyIGFDdG9yID0gYS5jb25zdHJ1Y3RvciwgYkN0b3IgPSBiLmNvbnN0cnVjdG9yO1xuICAgICAgaWYgKGFDdG9yICE9PSBiQ3RvciAmJiAhKF8uaXNGdW5jdGlvbihhQ3RvcikgJiYgYUN0b3IgaW5zdGFuY2VvZiBhQ3RvciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uaXNGdW5jdGlvbihiQ3RvcikgJiYgYkN0b3IgaW5zdGFuY2VvZiBiQ3RvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKCdjb25zdHJ1Y3RvcicgaW4gYSAmJiAnY29uc3RydWN0b3InIGluIGIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQXNzdW1lIGVxdWFsaXR5IGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhlIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGN5Y2xpY1xuICAgIC8vIHN0cnVjdHVyZXMgaXMgYWRhcHRlZCBmcm9tIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gLlxuICAgIFxuICAgIC8vIEluaXRpYWxpemluZyBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAvLyBJdCdzIGRvbmUgaGVyZSBzaW5jZSB3ZSBvbmx5IG5lZWQgdGhlbSBmb3Igb2JqZWN0cyBhbmQgYXJyYXlzIGNvbXBhcmlzb24uXG4gICAgYVN0YWNrID0gYVN0YWNrIHx8IFtdO1xuICAgIGJTdGFjayA9IGJTdGFjayB8fCBbXTtcbiAgICB2YXIgbGVuZ3RoID0gYVN0YWNrLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIC8vIExpbmVhciBzZWFyY2guIFBlcmZvcm1hbmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZlxuICAgICAgLy8gdW5pcXVlIG5lc3RlZCBzdHJ1Y3R1cmVzLlxuICAgICAgaWYgKGFTdGFja1tsZW5ndGhdID09PSBhKSByZXR1cm4gYlN0YWNrW2xlbmd0aF0gPT09IGI7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBmaXJzdCBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wdXNoKGEpO1xuICAgIGJTdGFjay5wdXNoKGIpO1xuXG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgaWYgKGFyZUFycmF5cykge1xuICAgICAgLy8gQ29tcGFyZSBhcnJheSBsZW5ndGhzIHRvIGRldGVybWluZSBpZiBhIGRlZXAgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkuXG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICAvLyBEZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzLlxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmICghZXEoYVtsZW5ndGhdLCBiW2xlbmd0aF0sIGFTdGFjaywgYlN0YWNrKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWVwIGNvbXBhcmUgb2JqZWN0cy5cbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKGEpLCBrZXk7XG4gICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IGJvdGggb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzIGJlZm9yZSBjb21wYXJpbmcgZGVlcCBlcXVhbGl0eS5cbiAgICAgIGlmIChfLmtleXMoYikubGVuZ3RoICE9PSBsZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAvLyBEZWVwIGNvbXBhcmUgZWFjaCBtZW1iZXJcbiAgICAgICAga2V5ID0ga2V5c1tsZW5ndGhdO1xuICAgICAgICBpZiAoIShfLmhhcyhiLCBrZXkpICYmIGVxKGFba2V5XSwgYltrZXldLCBhU3RhY2ssIGJTdGFjaykpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aGUgZmlyc3Qgb2JqZWN0IGZyb20gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wb3AoKTtcbiAgICBiU3RhY2sucG9wKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gUGVyZm9ybSBhIGRlZXAgY29tcGFyaXNvbiB0byBjaGVjayBpZiB0d28gb2JqZWN0cyBhcmUgZXF1YWwuXG4gIF8uaXNFcXVhbCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gZXEoYSwgYik7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiBhcnJheSwgc3RyaW5nLCBvciBvYmplY3QgZW1wdHk/XG4gIC8vIEFuIFwiZW1wdHlcIiBvYmplY3QgaGFzIG5vIGVudW1lcmFibGUgb3duLXByb3BlcnRpZXMuXG4gIF8uaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikgJiYgKF8uaXNBcnJheShvYmopIHx8IF8uaXNTdHJpbmcob2JqKSB8fCBfLmlzQXJndW1lbnRzKG9iaikpKSByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMDtcbiAgICByZXR1cm4gXy5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBET00gZWxlbWVudD9cbiAgXy5pc0VsZW1lbnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PT0gMSk7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhbiBhcnJheT9cbiAgLy8gRGVsZWdhdGVzIHRvIEVDTUE1J3MgbmF0aXZlIEFycmF5LmlzQXJyYXlcbiAgXy5pc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgYW4gb2JqZWN0P1xuICBfLmlzT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2Ygb2JqO1xuICAgIHJldHVybiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGUgPT09ICdvYmplY3QnICYmICEhb2JqO1xuICB9O1xuXG4gIC8vIEFkZCBzb21lIGlzVHlwZSBtZXRob2RzOiBpc0FyZ3VtZW50cywgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGlzTnVtYmVyLCBpc0RhdGUsIGlzUmVnRXhwLCBpc0Vycm9yLlxuICBfLmVhY2goWydBcmd1bWVudHMnLCAnRnVuY3Rpb24nLCAnU3RyaW5nJywgJ051bWJlcicsICdEYXRlJywgJ1JlZ0V4cCcsICdFcnJvciddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgX1snaXMnICsgbmFtZV0gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0ICcgKyBuYW1lICsgJ10nO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIERlZmluZSBhIGZhbGxiYWNrIHZlcnNpb24gb2YgdGhlIG1ldGhvZCBpbiBicm93c2VycyAoYWhlbSwgSUUgPCA5KSwgd2hlcmVcbiAgLy8gdGhlcmUgaXNuJ3QgYW55IGluc3BlY3RhYmxlIFwiQXJndW1lbnRzXCIgdHlwZS5cbiAgaWYgKCFfLmlzQXJndW1lbnRzKGFyZ3VtZW50cykpIHtcbiAgICBfLmlzQXJndW1lbnRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gXy5oYXMob2JqLCAnY2FsbGVlJyk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIE9wdGltaXplIGBpc0Z1bmN0aW9uYCBpZiBhcHByb3ByaWF0ZS4gV29yayBhcm91bmQgc29tZSB0eXBlb2YgYnVncyBpbiBvbGQgdjgsXG4gIC8vIElFIDExICgjMTYyMSksIGFuZCBpbiBTYWZhcmkgOCAoIzE5MjkpLlxuICBpZiAodHlwZW9mIC8uLyAhPSAnZnVuY3Rpb24nICYmIHR5cGVvZiBJbnQ4QXJyYXkgIT0gJ29iamVjdCcpIHtcbiAgICBfLmlzRnVuY3Rpb24gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09ICdmdW5jdGlvbicgfHwgZmFsc2U7XG4gICAgfTtcbiAgfVxuXG4gIC8vIElzIGEgZ2l2ZW4gb2JqZWN0IGEgZmluaXRlIG51bWJlcj9cbiAgXy5pc0Zpbml0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBpc0Zpbml0ZShvYmopICYmICFpc05hTihwYXJzZUZsb2F0KG9iaikpO1xuICB9O1xuXG4gIC8vIElzIHRoZSBnaXZlbiB2YWx1ZSBgTmFOYD8gKE5hTiBpcyB0aGUgb25seSBudW1iZXIgd2hpY2ggZG9lcyBub3QgZXF1YWwgaXRzZWxmKS5cbiAgXy5pc05hTiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBfLmlzTnVtYmVyKG9iaikgJiYgb2JqICE9PSArb2JqO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBib29sZWFuP1xuICBfLmlzQm9vbGVhbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHRydWUgfHwgb2JqID09PSBmYWxzZSB8fCB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEJvb2xlYW5dJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGVxdWFsIHRvIG51bGw/XG4gIF8uaXNOdWxsID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIHVuZGVmaW5lZD9cbiAgXy5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcbiAgfTtcblxuICAvLyBTaG9ydGN1dCBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHByb3BlcnR5IGRpcmVjdGx5XG4gIC8vIG9uIGl0c2VsZiAoaW4gb3RoZXIgd29yZHMsIG5vdCBvbiBhIHByb3RvdHlwZSkuXG4gIF8uaGFzID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gIH07XG5cbiAgLy8gVXRpbGl0eSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSdW4gVW5kZXJzY29yZS5qcyBpbiAqbm9Db25mbGljdCogbW9kZSwgcmV0dXJuaW5nIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzXG4gIC8vIHByZXZpb3VzIG93bmVyLiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcm9vdC5fID0gcHJldmlvdXNVbmRlcnNjb3JlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEtlZXAgdGhlIGlkZW50aXR5IGZ1bmN0aW9uIGFyb3VuZCBmb3IgZGVmYXVsdCBpdGVyYXRlZXMuXG4gIF8uaWRlbnRpdHkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvLyBQcmVkaWNhdGUtZ2VuZXJhdGluZyBmdW5jdGlvbnMuIE9mdGVuIHVzZWZ1bCBvdXRzaWRlIG9mIFVuZGVyc2NvcmUuXG4gIF8uY29uc3RhbnQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICB9O1xuXG4gIF8ubm9vcCA9IGZ1bmN0aW9uKCl7fTtcblxuICBfLnByb3BlcnR5ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PSBudWxsID8gdm9pZCAwIDogb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZXMgYSBmdW5jdGlvbiBmb3IgYSBnaXZlbiBvYmplY3QgdGhhdCByZXR1cm5zIGEgZ2l2ZW4gcHJvcGVydHkuXG4gIF8ucHJvcGVydHlPZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT0gbnVsbCA/IGZ1bmN0aW9uKCl7fSA6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIG9ialtrZXldO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIHByZWRpY2F0ZSBmb3IgY2hlY2tpbmcgd2hldGhlciBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gc2V0IG9mIFxuICAvLyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5tYXRjaGVyID0gXy5tYXRjaGVzID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgICBhdHRycyA9IF8uZXh0ZW5kT3duKHt9LCBhdHRycyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIF8uaXNNYXRjaChvYmosIGF0dHJzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJ1biBhIGZ1bmN0aW9uICoqbioqIHRpbWVzLlxuICBfLnRpbWVzID0gZnVuY3Rpb24obiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgYWNjdW0gPSBBcnJheShNYXRoLm1heCgwLCBuKSk7XG4gICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykgYWNjdW1baV0gPSBpdGVyYXRlZShpKTtcbiAgICByZXR1cm4gYWNjdW07XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBtaW4gYW5kIG1heCAoaW5jbHVzaXZlKS5cbiAgXy5yYW5kb20gPSBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgIGlmIChtYXggPT0gbnVsbCkge1xuICAgICAgbWF4ID0gbWluO1xuICAgICAgbWluID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIG1pbiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSk7XG4gIH07XG5cbiAgLy8gQSAocG9zc2libHkgZmFzdGVyKSB3YXkgdG8gZ2V0IHRoZSBjdXJyZW50IHRpbWVzdGFtcCBhcyBhbiBpbnRlZ2VyLlxuICBfLm5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfTtcblxuICAgLy8gTGlzdCBvZiBIVE1MIGVudGl0aWVzIGZvciBlc2NhcGluZy5cbiAgdmFyIGVzY2FwZU1hcCA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmI3gyNzsnLFxuICAgICdgJzogJyYjeDYwOydcbiAgfTtcbiAgdmFyIHVuZXNjYXBlTWFwID0gXy5pbnZlcnQoZXNjYXBlTWFwKTtcblxuICAvLyBGdW5jdGlvbnMgZm9yIGVzY2FwaW5nIGFuZCB1bmVzY2FwaW5nIHN0cmluZ3MgdG8vZnJvbSBIVE1MIGludGVycG9sYXRpb24uXG4gIHZhciBjcmVhdGVFc2NhcGVyID0gZnVuY3Rpb24obWFwKSB7XG4gICAgdmFyIGVzY2FwZXIgPSBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgcmV0dXJuIG1hcFttYXRjaF07XG4gICAgfTtcbiAgICAvLyBSZWdleGVzIGZvciBpZGVudGlmeWluZyBhIGtleSB0aGF0IG5lZWRzIHRvIGJlIGVzY2FwZWRcbiAgICB2YXIgc291cmNlID0gJyg/OicgKyBfLmtleXMobWFwKS5qb2luKCd8JykgKyAnKSc7XG4gICAgdmFyIHRlc3RSZWdleHAgPSBSZWdFeHAoc291cmNlKTtcbiAgICB2YXIgcmVwbGFjZVJlZ2V4cCA9IFJlZ0V4cChzb3VyY2UsICdnJyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gc3RyaW5nID09IG51bGwgPyAnJyA6ICcnICsgc3RyaW5nO1xuICAgICAgcmV0dXJuIHRlc3RSZWdleHAudGVzdChzdHJpbmcpID8gc3RyaW5nLnJlcGxhY2UocmVwbGFjZVJlZ2V4cCwgZXNjYXBlcikgOiBzdHJpbmc7XG4gICAgfTtcbiAgfTtcbiAgXy5lc2NhcGUgPSBjcmVhdGVFc2NhcGVyKGVzY2FwZU1hcCk7XG4gIF8udW5lc2NhcGUgPSBjcmVhdGVFc2NhcGVyKHVuZXNjYXBlTWFwKTtcblxuICAvLyBJZiB0aGUgdmFsdWUgb2YgdGhlIG5hbWVkIGBwcm9wZXJ0eWAgaXMgYSBmdW5jdGlvbiB0aGVuIGludm9rZSBpdCB3aXRoIHRoZVxuICAvLyBgb2JqZWN0YCBhcyBjb250ZXh0OyBvdGhlcndpc2UsIHJldHVybiBpdC5cbiAgXy5yZXN1bHQgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5LCBmYWxsYmFjaykge1xuICAgIHZhciB2YWx1ZSA9IG9iamVjdCA9PSBudWxsID8gdm9pZCAwIDogb2JqZWN0W3Byb3BlcnR5XTtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgdmFsdWUgPSBmYWxsYmFjaztcbiAgICB9XG4gICAgcmV0dXJuIF8uaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZS5jYWxsKG9iamVjdCkgOiB2YWx1ZTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpbnRlZ2VyIGlkICh1bmlxdWUgd2l0aGluIHRoZSBlbnRpcmUgY2xpZW50IHNlc3Npb24pLlxuICAvLyBVc2VmdWwgZm9yIHRlbXBvcmFyeSBET00gaWRzLlxuICB2YXIgaWRDb3VudGVyID0gMDtcbiAgXy51bmlxdWVJZCA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHZhciBpZCA9ICsraWRDb3VudGVyICsgJyc7XG4gICAgcmV0dXJuIHByZWZpeCA/IHByZWZpeCArIGlkIDogaWQ7XG4gIH07XG5cbiAgLy8gQnkgZGVmYXVsdCwgVW5kZXJzY29yZSB1c2VzIEVSQi1zdHlsZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLCBjaGFuZ2UgdGhlXG4gIC8vIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgXy50ZW1wbGF0ZVNldHRpbmdzID0ge1xuICAgIGV2YWx1YXRlICAgIDogLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICBpbnRlcnBvbGF0ZSA6IC88JT0oW1xcc1xcU10rPyklPi9nLFxuICAgIGVzY2FwZSAgICAgIDogLzwlLShbXFxzXFxTXSs/KSU+L2dcbiAgfTtcblxuICAvLyBXaGVuIGN1c3RvbWl6aW5nIGB0ZW1wbGF0ZVNldHRpbmdzYCwgaWYgeW91IGRvbid0IHdhbnQgdG8gZGVmaW5lIGFuXG4gIC8vIGludGVycG9sYXRpb24sIGV2YWx1YXRpb24gb3IgZXNjYXBpbmcgcmVnZXgsIHdlIG5lZWQgb25lIHRoYXQgaXNcbiAgLy8gZ3VhcmFudGVlZCBub3QgdG8gbWF0Y2guXG4gIHZhciBub01hdGNoID0gLyguKV4vO1xuXG4gIC8vIENlcnRhaW4gY2hhcmFjdGVycyBuZWVkIHRvIGJlIGVzY2FwZWQgc28gdGhhdCB0aGV5IGNhbiBiZSBwdXQgaW50byBhXG4gIC8vIHN0cmluZyBsaXRlcmFsLlxuICB2YXIgZXNjYXBlcyA9IHtcbiAgICBcIidcIjogICAgICBcIidcIixcbiAgICAnXFxcXCc6ICAgICAnXFxcXCcsXG4gICAgJ1xccic6ICAgICAncicsXG4gICAgJ1xcbic6ICAgICAnbicsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIHZhciBlc2NhcGVyID0gL1xcXFx8J3xcXHJ8XFxufFxcdTIwMjh8XFx1MjAyOS9nO1xuXG4gIHZhciBlc2NhcGVDaGFyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gJ1xcXFwnICsgZXNjYXBlc1ttYXRjaF07XG4gIH07XG5cbiAgLy8gSmF2YVNjcmlwdCBtaWNyby10ZW1wbGF0aW5nLCBzaW1pbGFyIHRvIEpvaG4gUmVzaWcncyBpbXBsZW1lbnRhdGlvbi5cbiAgLy8gVW5kZXJzY29yZSB0ZW1wbGF0aW5nIGhhbmRsZXMgYXJiaXRyYXJ5IGRlbGltaXRlcnMsIHByZXNlcnZlcyB3aGl0ZXNwYWNlLFxuICAvLyBhbmQgY29ycmVjdGx5IGVzY2FwZXMgcXVvdGVzIHdpdGhpbiBpbnRlcnBvbGF0ZWQgY29kZS5cbiAgLy8gTkI6IGBvbGRTZXR0aW5nc2Agb25seSBleGlzdHMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICBfLnRlbXBsYXRlID0gZnVuY3Rpb24odGV4dCwgc2V0dGluZ3MsIG9sZFNldHRpbmdzKSB7XG4gICAgaWYgKCFzZXR0aW5ncyAmJiBvbGRTZXR0aW5ncykgc2V0dGluZ3MgPSBvbGRTZXR0aW5ncztcbiAgICBzZXR0aW5ncyA9IF8uZGVmYXVsdHMoe30sIHNldHRpbmdzLCBfLnRlbXBsYXRlU2V0dGluZ3MpO1xuXG4gICAgLy8gQ29tYmluZSBkZWxpbWl0ZXJzIGludG8gb25lIHJlZ3VsYXIgZXhwcmVzc2lvbiB2aWEgYWx0ZXJuYXRpb24uXG4gICAgdmFyIG1hdGNoZXIgPSBSZWdFeHAoW1xuICAgICAgKHNldHRpbmdzLmVzY2FwZSB8fCBub01hdGNoKS5zb3VyY2UsXG4gICAgICAoc2V0dGluZ3MuaW50ZXJwb2xhdGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmV2YWx1YXRlIHx8IG5vTWF0Y2gpLnNvdXJjZVxuICAgIF0uam9pbignfCcpICsgJ3wkJywgJ2cnKTtcblxuICAgIC8vIENvbXBpbGUgdGhlIHRlbXBsYXRlIHNvdXJjZSwgZXNjYXBpbmcgc3RyaW5nIGxpdGVyYWxzIGFwcHJvcHJpYXRlbHkuXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgc291cmNlID0gXCJfX3ArPSdcIjtcbiAgICB0ZXh0LnJlcGxhY2UobWF0Y2hlciwgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZSwgaW50ZXJwb2xhdGUsIGV2YWx1YXRlLCBvZmZzZXQpIHtcbiAgICAgIHNvdXJjZSArPSB0ZXh0LnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UoZXNjYXBlciwgZXNjYXBlQ2hhcik7XG4gICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgaWYgKGVzY2FwZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGVzY2FwZSArIFwiKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXFxuJ1wiO1xuICAgICAgfSBlbHNlIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGludGVycG9sYXRlICsgXCIpKT09bnVsbD8nJzpfX3QpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoZXZhbHVhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlICsgXCJcXG5fX3ArPSdcIjtcbiAgICAgIH1cblxuICAgICAgLy8gQWRvYmUgVk1zIG5lZWQgdGhlIG1hdGNoIHJldHVybmVkIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3Qgb2ZmZXN0LlxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAvLyBJZiBhIHZhcmlhYmxlIGlzIG5vdCBzcGVjaWZpZWQsIHBsYWNlIGRhdGEgdmFsdWVzIGluIGxvY2FsIHNjb3BlLlxuICAgIGlmICghc2V0dGluZ3MudmFyaWFibGUpIHNvdXJjZSA9ICd3aXRoKG9ianx8e30pe1xcbicgKyBzb3VyY2UgKyAnfVxcbic7XG5cbiAgICBzb3VyY2UgPSBcInZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixcIiArXG4gICAgICBcInByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XFxuXCIgK1xuICAgICAgc291cmNlICsgJ3JldHVybiBfX3A7XFxuJztcblxuICAgIHRyeSB7XG4gICAgICB2YXIgcmVuZGVyID0gbmV3IEZ1bmN0aW9uKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonLCAnXycsIHNvdXJjZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZS5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiByZW5kZXIuY2FsbCh0aGlzLCBkYXRhLCBfKTtcbiAgICB9O1xuXG4gICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgc291cmNlIGFzIGEgY29udmVuaWVuY2UgZm9yIHByZWNvbXBpbGF0aW9uLlxuICAgIHZhciBhcmd1bWVudCA9IHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonO1xuICAgIHRlbXBsYXRlLnNvdXJjZSA9ICdmdW5jdGlvbignICsgYXJndW1lbnQgKyAnKXtcXG4nICsgc291cmNlICsgJ30nO1xuXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xuICB9O1xuXG4gIC8vIEFkZCBhIFwiY2hhaW5cIiBmdW5jdGlvbi4gU3RhcnQgY2hhaW5pbmcgYSB3cmFwcGVkIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLmNoYWluID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGluc3RhbmNlID0gXyhvYmopO1xuICAgIGluc3RhbmNlLl9jaGFpbiA9IHRydWU7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xuXG4gIC8vIE9PUFxuICAvLyAtLS0tLS0tLS0tLS0tLS1cbiAgLy8gSWYgVW5kZXJzY29yZSBpcyBjYWxsZWQgYXMgYSBmdW5jdGlvbiwgaXQgcmV0dXJucyBhIHdyYXBwZWQgb2JqZWN0IHRoYXRcbiAgLy8gY2FuIGJlIHVzZWQgT08tc3R5bGUuIFRoaXMgd3JhcHBlciBob2xkcyBhbHRlcmVkIHZlcnNpb25zIG9mIGFsbCB0aGVcbiAgLy8gdW5kZXJzY29yZSBmdW5jdGlvbnMuIFdyYXBwZWQgb2JqZWN0cyBtYXkgYmUgY2hhaW5lZC5cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29udGludWUgY2hhaW5pbmcgaW50ZXJtZWRpYXRlIHJlc3VsdHMuXG4gIHZhciByZXN1bHQgPSBmdW5jdGlvbihpbnN0YW5jZSwgb2JqKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLl9jaGFpbiA/IF8ob2JqKS5jaGFpbigpIDogb2JqO1xuICB9O1xuXG4gIC8vIEFkZCB5b3VyIG93biBjdXN0b20gZnVuY3Rpb25zIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5taXhpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIF8uZWFjaChfLmZ1bmN0aW9ucyhvYmopLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IF9bbmFtZV0gPSBvYmpbbmFtZV07XG4gICAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IFt0aGlzLl93cmFwcGVkXTtcbiAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIGZ1bmMuYXBwbHkoXywgYXJncykpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBBZGQgYWxsIG9mIHRoZSBVbmRlcnNjb3JlIGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlciBvYmplY3QuXG4gIF8ubWl4aW4oXyk7XG5cbiAgLy8gQWRkIGFsbCBtdXRhdG9yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsncG9wJywgJ3B1c2gnLCAncmV2ZXJzZScsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9iaiA9IHRoaXMuX3dyYXBwZWQ7XG4gICAgICBtZXRob2QuYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKChuYW1lID09PSAnc2hpZnQnIHx8IG5hbWUgPT09ICdzcGxpY2UnKSAmJiBvYmoubGVuZ3RoID09PSAwKSBkZWxldGUgb2JqWzBdO1xuICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLCBvYmopO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEFkZCBhbGwgYWNjZXNzb3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBfLmVhY2goWydjb25jYXQnLCAnam9pbicsICdzbGljZSddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByZXN1bHQodGhpcywgbWV0aG9kLmFwcGx5KHRoaXMuX3dyYXBwZWQsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEV4dHJhY3RzIHRoZSByZXN1bHQgZnJvbSBhIHdyYXBwZWQgYW5kIGNoYWluZWQgb2JqZWN0LlxuICBfLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl93cmFwcGVkO1xuICB9O1xuXG4gIC8vIFByb3ZpZGUgdW53cmFwcGluZyBwcm94eSBmb3Igc29tZSBtZXRob2RzIHVzZWQgaW4gZW5naW5lIG9wZXJhdGlvbnNcbiAgLy8gc3VjaCBhcyBhcml0aG1ldGljIGFuZCBKU09OIHN0cmluZ2lmaWNhdGlvbi5cbiAgXy5wcm90b3R5cGUudmFsdWVPZiA9IF8ucHJvdG90eXBlLnRvSlNPTiA9IF8ucHJvdG90eXBlLnZhbHVlO1xuICBcbiAgXy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJycgKyB0aGlzLl93cmFwcGVkO1xuICB9O1xuXG4gIC8vIEFNRCByZWdpc3RyYXRpb24gaGFwcGVucyBhdCB0aGUgZW5kIGZvciBjb21wYXRpYmlsaXR5IHdpdGggQU1EIGxvYWRlcnNcbiAgLy8gdGhhdCBtYXkgbm90IGVuZm9yY2UgbmV4dC10dXJuIHNlbWFudGljcyBvbiBtb2R1bGVzLiBFdmVuIHRob3VnaCBnZW5lcmFsXG4gIC8vIHByYWN0aWNlIGZvciBBTUQgcmVnaXN0cmF0aW9uIGlzIHRvIGJlIGFub255bW91cywgdW5kZXJzY29yZSByZWdpc3RlcnNcbiAgLy8gYXMgYSBuYW1lZCBtb2R1bGUgYmVjYXVzZSwgbGlrZSBqUXVlcnksIGl0IGlzIGEgYmFzZSBsaWJyYXJ5IHRoYXQgaXNcbiAgLy8gcG9wdWxhciBlbm91Z2ggdG8gYmUgYnVuZGxlZCBpbiBhIHRoaXJkIHBhcnR5IGxpYiwgYnV0IG5vdCBiZSBwYXJ0IG9mXG4gIC8vIGFuIEFNRCBsb2FkIHJlcXVlc3QuIFRob3NlIGNhc2VzIGNvdWxkIGdlbmVyYXRlIGFuIGVycm9yIHdoZW4gYW5cbiAgLy8gYW5vbnltb3VzIGRlZmluZSgpIGlzIGNhbGxlZCBvdXRzaWRlIG9mIGEgbG9hZGVyIHJlcXVlc3QuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoJ3VuZGVyc2NvcmUnLCBbXSwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXztcbiAgICB9KTtcbiAgfVxufS5jYWxsKHRoaXMpKTtcbiIsIm1vZHVsZS5leHBvcnRzID0galF1ZXJ5O1xuIl19
