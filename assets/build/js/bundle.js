require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var AppsRouter = require('./apps/apps_router');


Application = {

  started: null,

  // Initialize and fire up the application.
  initialize: function () {
    var self = this;
    // Cache user
    // Check if a user is already defined
    if (!_.isUndefined(backendUser)) {
      window.cache.currentUser = backendUser;
    }
    if (!_.isUndefined(systemName)) {
      window.cache.system.name = systemName;
    }

    // Create a user events handler
    _.extend(window.cache.userEvents, Backbone.Events);

    // Mixin backbone events into our pub sub handler
    _.extend(entities.request, Backbone.Events);

    // Mixin backbone events into our rendering event handler
    _.extend(rendering, Backbone.Events);

    if (this.started) {
      self.started = false;
      this.application.initialize();
    } else {
      this.application = AppsRouter.initialize();
      self.started = true;
    }
  }
};

// Backbone Multi-tenant router firing up.
module.exports = Application;

},{"./apps/apps_router":20,"backbone":133,"underscore":159}],2:[function(require,module,exports){
/**
 * This is the main application bootstrap
 * that gets the rest of the apps, routers, etc
 * running.
 */

// Install jQuery plugins
require('blueimp-file-upload/js/vendor/jquery.ui.widget');
i18n = require('i18next-client/i18next.commonjs.withJQuery');
moment = require('moment');

// App
window.Application      = window.Application || {};
window.cache            = { userEvents: {}, currentUser: null, system: {} };

// Events
window.entities = { request: {} };
rendering       = {}

// Set up Backbone to use jQuery
_ = require('underscore');
Backbone = require('backbone');
Backbone.$ = jQuery;

// Load the application
var appr = require('./app-run');
appr.initialize();

},{"./app-run":1,"backbone":133,"blueimp-file-upload/js/vendor/jquery.ui.widget":136,"i18next-client/i18next.commonjs.withJQuery":152,"moment":156,"underscore":159}],3:[function(require,module,exports){

var _ = require('underscore');
var async = require('async');
var Backbone = require('backbone');
var utils = require('../../../mixins/utilities');
var BaseController = require('../../../base/base_controller');
var AdminMainView = require('../views/admin_main_view');


Admin = {};

Admin.ShowController = BaseController.extend({

  events: {
  },

  // Initialize the admin view
  initialize: function (options) {
    this.options = options;
    this.adminMainView = new AdminMainView({
      action: options.action,
      el: this.el
    }).render();
  },

  // Cleanup controller and views
  cleanup: function() {
    this.adminMainView.cleanup();
    removeView(this);
  }

});

module.exports = Admin.ShowController;

},{"../../../base/base_controller":101,"../../../mixins/utilities":128,"../views/admin_main_view":15,"async":131,"backbone":133,"underscore":159}],4:[function(require,module,exports){
module.exports = "<div class=\"row\">\n  <div class=\"col-md-12\">\n    <h2><i class=\"fa fa-newspaper-o\"></i><span class=\"box-icon-text\">Recent Activity</span></h2>\n    <ul class=\"activity-feed list-unstyled\"></ul>\n  </div>\n</div>\n\n<script type=\"text/template\" id=\"newComment\">\n  <li class=\"box-pad-t box-pad-b\">\n    &ldquo;{{comment.value}}&rdquo; said <a href=\"/profile/{{user.id}}\">{{user.name || user.username}}</a> on <a href=\"/{{itemType}}s/{{item.id}}\">{{item.title}}</a>\n    <div class=\"comment-metadata\"><time title=\"{{createdAt}}\">{{createdAtFormatted}}</time></div>\n  </li>\n</script>\n\n<script type=\"text/template\" id=\"newVolunteer\">\n  <li class=\"box-pad-t box-pad-b\">\n    <a href=\"/profile/{{user.id}}\">{{user.name || user.username}}</a> signed up for <a href=\"/tasks/{{task.id}}\">{{task.title}}</a>\n    <div class=\"comment-metadata\"><time title=\"{{createdAt}}\">{{createdAtFormatted}}</time></div>\n  </li>\n</script>\n\n<script type=\"text/template\" id=\"newUser\">\n  <li class=\"box-pad-t box-pad-b\">\n    <a href=\"/profile/{{user.id}}\">{{user.name || user.username}}</a> joined!\n    <div class=\"comment-metadata\"><time title=\"{{createdAt}}\">{{createdAtFormatted}}</time></div>\n  </li>\n</script>\n\n<script type=\"text/template\" id=\"updatedUser\">\n  <li class=\"box-pad-t box-pad-b\">\n    <a href=\"/profile/{{user.id}}\">{{user.name || user.username}}</a> updated their profile\n    <div class=\"comment-metadata\"><time title=\"{{createdAt}}\">{{createdAtFormatted}}</time></div>\n  </li>\n</script>\n\n<script type=\"text/template\" id=\"newTask\">\n  <li class=\"box-pad-t box-pad-b\">\n    <a href=\"/profile/{{user.id}}\">{{user.name || user.username}}</a> posted a new opportunity: <a href=\"/tasks/{{task.id}}\">{{task.title}}</a>\n    <div class=\"comment-metadata\"><time title=\"{{createdAt}}\">{{createdAtFormatted}}</time></div>\n  </li>\n</script>\n";

},{}],5:[function(require,module,exports){
module.exports = "<div class=\"row\">\n  <div class=\"col-sm-6 box-pad-t box-pad-b\">\n    <h2><i class=\"fa fa-line-chart\"></i><span class=\"box-icon-text\" data-i18n=\"InteractionPlural\">Interactions</span></h2>\n    <ul class=\"metrics\">\n      <li>Total Interactions: <%- interactions.count %></li>\n      <ul>\n        <li><span data-i18n=\"Task\">Task</span> Signups: <%- interactions.signups %></li>\n        <li>Assignments: <%- interactions.assignments %></li>\n        <li>Discussion Posts: <%- interactions.posts %></li>\n        <li>Completed Tasks: <%- interactions.completions %></li>\n        <li>Draft Tasks: <%- interactions.drafts %></li>\n        <li>Published Tasks: <%- interactions.publishes %></li>\n      </ul>\n    </ul>\n  </div>\n  <div class=\"col-sm-6 box-pad-t box-pad-b\">\n    <h2><i class=\"fa fa-tags\"></i><span class=\"box-icon-text\" data-i18n=\"TaskPlural\">Tasks</span></h2>\n    <ul class=\"metrics\">\n      <li>Total Created: <%- tasks.count %></li>\n      <ul>\n        <li>Draft: <%- tasks.draft %></li>\n        <li>Open: <%- tasks.open %></li>\n        <li>Assigned: <%- tasks.assigned %></li>\n        <li>Completed: <%- tasks.completed %></li>\n        <li>Archived: <%- tasks.archived %></li>\n      </ul>\n    </ul>\n  </div>\n</div>\n<div class=\"row\">\n  <div class=\"col-sm-6 box-pad-t box-pad-b\">\n    <h2><i class=\"fa fa-user\"></i><span class=\"box-icon-text\">Users</span></h2>\n    <ul class=\"metrics\">\n      <li>Quantity: <%- users.count %></li>\n      <ul><li>Who have created tasks: <%- users.withTasks %></li></ul>\n    </ul>\n  </div>\n  <div class=\"col-sm-6 box-pad-t box-pad-b\">\n    <h2><i class=\"fa fa-rocket\"></i><span class=\"box-icon-text\" data-i18n=\"ProjectPlural\">Projects</span></h2>\n    <ul class=\"metrics\">\n      <li>Total Created: <%- projects.count %></li>\n    </ul>\n  </div>\n</div>\n";

},{}],6:[function(require,module,exports){
module.exports = "<div class=\"alert alert-danger\" style=\"display:none;\">\n</div>\n<div class=\"col-md-12 box box-pad-lr\">\n  <div class=\"row\">\n    <div class=\"col-md-12 sm-nopadding md-nopadding\">\n      <div class=\"fullwidth text-center spinner\">\n        Loading... <i class=\"fa fa-spinner fa-spin\"></i>\n      </div>\n    </div>\n  </div>\n  <div class=\"metric-block\"></div>\n  <div class=\"activity-block\"></div>\n</div>\n";

},{}],7:[function(require,module,exports){
module.exports = "<div class=\"row\">\n  <div class=\"col-sm-3 col-md-3\">\n\n    <nav class=\"navbar admin navbar-default\" role=\"navigation\">\n      <!-- Brand and toggle get grouped for better mobile display -->\n      <div class=\"navbar-header\">\n        <button type=\"button\" class=\"navbar-toggle\" data-toggle=\"collapse\" data-target=\".navbar-ex1-collapse\">\n          <span class=\"sr-only\">Toggle navigation</span>\n          <span class=\"icon-bar\"></span>\n          <span class=\"icon-bar\"></span>\n          <span class=\"icon-bar\"></span>\n        </button>\n        <h2 class=\"box-pad-lr box-pad-t\">Administration</h2>\n      </div>\n\n      <!-- Collect the nav links, forms, and other content for toggling -->\n      <div class=\"collapse navbar-collapse navbar-ex1-collapse\">\n        <ul class=\"nav navbar-nav\">\n          <li><a href=\"/admin/dashboard\" class=\"link-admin\" data-target=\"dashboard\">Dashboard</a></li>\n          <li><a href=\"/admin/users\" class=\"link-admin\" data-target=\"user\">User Management</a></li>\n          <li><a href=\"/admin/tags\" class=\"link-admin\" data-target=\"tag\">Tag Configuration</a></li>\n          <li><a href=\"/admin/tasks\" class=\"link-admin\" data-target=\"tasks\">Tasks</a></li>\n        </ul>\n      </div><!-- /.navbar-collapse -->\n    </nav>\n\n  </div>\n  <div class=\"col-sm-9 col-md-9 sm-nopadding\">\n    <div class=\"admin-container\" id=\"admin-user\">\n    </div>\n    <div class=\"admin-container\" id=\"admin-tag\">\n    </div>\n    <div class=\"admin-container\" id=\"admin-task\">\n    </div>\n    <div class=\"admin-container\" id=\"admin-dashboard\">\n    </div>\n  </div>\n</div>\n";

},{}],8:[function(require,module,exports){
module.exports = "<ul class=\"pagination\" data-filter=\"<% q %>\">\n  <% if (page > 3) { %>\n  <li><a href=\"#\">&laquo;</a></li>\n  <% } %>\n  <%\n  var start = Math.max(1, page-2);\n  var ceil = Math.ceil(count/trueLimit);\n  if (ceil < page + 2) {\n    start = Math.max(1, ceil - 4);\n  }\n  var max = Math.min(page + 2, ceil);\n  if ((ceil > 5) && ((page + 2) < 5)) {\n    max = 5;\n  }\n  %>\n  <% for (var i = start; i <= max; i++) { %>\n  <li <% if (i == page) { %>class=\"active\"<% } %>><a class=\"page\" data-page=\"<%- i %>\" href=\"<%- urlbase %>?p=<%- i %>&q=<%- q %>\"><%- i %> <% if (i == page) { %><span class=\"sr-only\">(current)</span><% } %></a></li>\n  <% } %>\n  <% if (ceil > (page + 2)) { %>\n  <li><a href=\"#\">&raquo;</a></li>\n  <% } %>\n</ul>\n";

},{}],9:[function(require,module,exports){
module.exports = "<div class=\"alert alert-danger\" style=\"display:none;\">\n</div>\n<div class=\"row\">\n  <div class=\"col-md-12 box box-pad-lr\">\n    <div class=\"row\">\n      <div class=\"col-md-12 box-pad-b\">\n        <h2>Find and add tags</h2>\n        <p>Search in the fields below to see existing tags. Type a new tag value to create it.</p>\n        <% _(types).forEach(function(tag) { %>\n          <div class=\"row box-pad-b box-pad-t\">\n            <label for=\"<%= tag %>\" class=\"col-md-2 control-label\"><%= tag %>:</label>\n            <div class=\"col-md-10\">\n              <input type=\"hidden\" id=\"<%= tag %>\" name=\"<%= tag %>\" style=\"width: 100%\"/>\n              <div class=\"form-status text-success\"></div>\n            </div>\n          </div>\n        <% }); %>\n      </div>\n    </div>\n  </div>\n</div>\n";

},{}],10:[function(require,module,exports){
module.exports = "<div class=\"alert alert-danger\" style=\"display:none;\">\n</div>\n<div class=\"row\">\n  <div class=\"col-md-12 box box-pad-lr\">\n    <div class=\"row\">\n      <div class=\"col-md-12\">\n\n        <div role=\"tabpanel\">\n\n          <!-- Nav tabs -->\n          <ul class=\"nav nav-tabs box-pad-t\" role=\"tablist\">\n            <li role=\"presentation\">\n              <a href=\"#drafts\" aria-controls=\"open\" role=\"tab\" data-toggle=\"tab\">\n                Drafts: <%- drafts.length %>\n              </a>\n            </li>\n            <li role=\"presentation\" class=\"active\">\n              <a href=\"#open\" aria-controls=\"open\" role=\"tab\" data-toggle=\"tab\">\n                Open: <%- open.length %>\n              </a>\n            </li>\n            <li role=\"presentation\">\n              <a href=\"#signups\" aria-controls=\"signups\" role=\"tab\" data-toggle=\"tab\">\n                Sign-ups: <%- withSignups.length %>\n              </a>\n            </li>\n            <li role=\"presentation\">\n              <a href=\"#assigned\" aria-controls=\"assigned\" role=\"tab\" data-toggle=\"tab\">\n                Assigned: <%- assigned.length %>\n              </a>\n            </li>\n            <li role=\"presentation\">\n              <a href=\"#completed\" aria-controls=\"completed\" role=\"tab\" data-toggle=\"tab\">\n                Completed: <%- completed.length %>\n              </a>\n            </li>\n          </ul>\n\n          <!-- Tab panes -->\n          <div class=\"tab-content box-pad-t\">\n            <div role=\"tabpanel\" class=\"tab-pane\" id=\"drafts\">\n              <ul class=\"metrics\">\n                <% _(drafts).forEach(function(task) { %>\n                  <li>\n                    <a href=\"/tasks/<%- task.id %>\"><%- task.title %></a>,\n                    <a href=\"/profile/<%- task.user.id %>\"><%- task.user.name || task.user.username %></a>\n                    <% if (task.volunteers.length) { %>\n                    <p>Sign-ups:\n                      <% _(task.volunteers).forEach(function(vol) { %>\n                        <a href=\"/profile/<%- task.user.id %>\"><%- vol.user.name || vol.user.username %></a>\n                      <% }); %>\n                    </p>\n                    <% } %>\n                  </li>\n                <% }); %>\n              </ul>\n            </div>\n            <div role=\"tabpanel\" class=\"tab-pane active\" id=\"open\">\n              <ul class=\"metrics\">\n                <% _(open).forEach(function(task) { %>\n                  <li>\n                    <a href=\"/tasks/<%- task.id %>\"><%- task.title %></a>,\n                    <a href=\"/profile/<%- task.user.id %>\"><%- task.user.name || task.user.username %></a>\n                    <% if (task.volunteers.length) { %>\n                    <p>Sign-ups:\n                      <% _(task.volunteers).forEach(function(vol) { %>\n                        <a href=\"/profile/<%- task.user.id %>\"><%- vol.user.name || vol.user.username %></a>\n                      <% }); %>\n                    </p>\n                    <% } %>\n                  </li>\n                <% }); %>\n              </ul>\n            </div>\n            <div role=\"tabpanel\" class=\"tab-pane\" id=\"signups\">\n              <ul class=\"metrics\">\n                <% _(withSignups).forEach(function(task) { %>\n                  <li>\n                    <a href=\"/tasks/<%- task.id %>\"><%- task.title %></a>,\n                    <a href=\"/profile/<%- task.user.id %>\"><%- task.user.name || task.user.username %></a>\n                    <% if (task.volunteers.length) { %>\n                      <p>Sign-ups:\n                        <% _(task.volunteers).forEach(function(vol) { %>\n                          <a href=\"/profile/<%- task.user.id %>\"><%- vol.user.name || vol.user.username %></a>\n                        <% }); %>\n                      </p>\n                    <% } %>\n                  </li>\n                <% }); %>\n              </ul>\n            </div>\n            <div role=\"tabpanel\" class=\"tab-pane\" id=\"assigned\">\n              <ul class=\"metrics\">\n                <% _(assigned).forEach(function(task) { %>\n                  <li>\n                    <a href=\"/tasks/<%- task.id %>\"><%- task.title %></a>,\n                    <a href=\"/profile/<%- task.user.id %>\"><%- task.user.name || task.user.username %></a>\n                    <% if (task.volunteers.length) { %>\n                      <p>Sign-ups:\n                        <% _(task.volunteers).forEach(function(vol) { %>\n                          <a href=\"/profile/<%- task.user.id %>\"><%- vol.user.name || vol.user.username %></a>\n                        <% }); %>\n                      </p>\n                    <% } %>\n                  </li>\n                <% }); %>\n              </ul>\n            </div>\n            <div role=\"tabpanel\" class=\"tab-pane\" id=\"completed\">\n              <ul class=\"metrics\">\n                <% _(completed).forEach(function(task) { %>\n                  <li>\n                    <a href=\"/tasks/<%- task.id %>\"><%- task.title %></a>,\n                    <a href=\"/profile/<%- task.user.id %>\"><%- task.user.name || task.user.username %></a>\n                    <% if (task.volunteers.length) { %>\n                      <p>Sign-ups:\n                        <% _(task.volunteers).forEach(function(vol) { %>\n                          <a href=\"/profile/<%- task.user.id %>\"><%- vol.user.name || vol.user.username %></a>\n                        <% }); %>\n                      </p>\n                    <% } %>\n                  </li>\n                <% }); %>\n              </ul>\n            </div>\n          </div>\n\n        </div>\n\n      </div>\n    </div>\n  </div>\n</div>\n";

},{}],11:[function(require,module,exports){
module.exports = "<form action=\"\" id=\"reset-password\">\n  <div class=\"modal-body\">\n    <div class=\"alert alert-danger\" style=\"display:none;\">\n    </div>\n    <fieldset>\n      <div class=\"form-group\">\n        <label for=\"newPassword\">New Password for <%- u.name %></label>\n        <input type=\"password\" class=\"form-control\" id=\"newPassword\" name=\"password\" placeholder=\"New Password\" data-validate=\"empty\">\n        <span class=\"help-block error-empty\" style=\"display:none;\">You must enter a password.</span>\n      </div>\n    </fieldset>\n  </div>\n  <div class=\"modal-footer\">\n    <button type=\"button\" class=\"btn btn-c0\" data-dismiss=\"modal\">Cancel</button>\n    <input type=\"submit\" class=\"btn btn-c2\" id=\"submit\" value=\"Change Password\"/>\n  </div>\n</form>\n";

},{}],12:[function(require,module,exports){
module.exports = "<table class=\"table table-hover table-condensed\">\n  <thead>\n    <tr>\n      <th class=\"admin-user-id\">#</th>\n      <th>Name</th>\n      <th>Email</th>\n      <th>Created At</th>\n      <th><span data-i18n=\"ProjectPlural\">Projects</span> (open / closed)</th>\n      <th><span data-i18n=\"TaskPlural\">Tasks</span> (open / assigned / completed / archived)</th>\n      <th>Volunteer (open / assigned / completed / archived)</th>\n      <th class=\"admin-user-checkbox\">Enabled</th>\n      <% if (login.local.enabled === true) { %>\n      <th class=\"admin-user-checkbox\">Password</th>\n      <% } %>\n      <th class=\"admin-user-checkbox\">Admin</th>\n    </tr>\n  </thead>\n  <tbody>\n    <% if (users.length === 0) { %>\n    <tr class=\"empty-row\">\n      <td colspan=\"5\">\n        No users found.\n      </td>\n    </tr>\n    <% } %>\n    <% _.each(users, function (u) { %>\n    <tr data-id=\"<%- u.id %>\">\n      <td>\n        <%- u.id %>\n      </td>\n      <td class=\"admin-table-name\">\n        <%- u.name %>\n      </td>\n      <td class=\"admin-table-username\">\n        <a class=\"link-backbone\" href=\"/profile/<%- u.id %>\"><%- u.username %></a>\n      </td>\n      <td class=\"admin-table-createdat\">\n        <!-- day -->\n        <% var created = new Date(u.createdAt); %>\n        <%= created.toLocaleDateString() %>\n        <!-- time -->\n        <%= created.toLocaleTimeString() %>\n      </td>\n      <td class=\"admin-table-projects\">\n      <% if (u.projectsCreatedOpen !== 0 || u.projectsCreatedClosed !== 0) { %>\n        <a class=\"link-backbone\" href=\"/profile/<%- u.id %>\"><%- u.projectsCreatedOpen %> / <%- u.projectsCreatedClosed %></a>\n      <% } %>\n      </td>\n      <td class=\"admin-table-tasks\">\n      <% if (u.tasksCreatedOpen !== 0 || u.tasksCreatedAssigned !== 0 || u.tasksCreatedCompleted !== 0 || u.tasksCreatedArchived !== 0) { %>\n        <a class=\"link-backbone\" href=\"/profile/<%- u.id %>\"><%- u.tasksCreatedOpen %> / <%- u.tasksCreatedAssigned %> / <%- u.tasksCreatedCompleted %> / <%- u.tasksCreatedArchived %></a>\n      <% } %>\n      </td>\n      <td class=\"admin-table-volunteer\">\n      <% if (u.volCountOpen !== 0 || u.volCountAssigned !== 0 || u.volCountCompleted !== 0 || u.volCountArchived !== 0) { %>\n        <a class=\"link-backbone\" href=\"/profile/<%- u.id %>\"><%- u.volCountOpen %> / <%- u.volCountAssigned %> / <%- u.volCountCompleted %> / <%- u.volCountArchived %></a>\n      <% } %>\n      </td>\n      <td>\n        <button type=\"button\" class=\"btn btn-default btn-xs admin-user-enable\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"Enable\" <% if (u.disabled !== true) { %>style=\"display:none;\"<% } %>><i class=\"fa fa-remove-sign icon-red icon-center\"></i></button>\n        <button type=\"button\" class=\"btn btn-default btn-xs admin-user-disable\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"Disable\" <% if (u.disabled === true) { %>style=\"display:none;\"<% } %>><i class=\"fa fa-check icon-green icon-center\"></i></button>\n        <button type=\"button\" class=\"btn btn-default btn-xs btn-spin\" style=\"display:none;\"><i class=\"fa-spin fa fa-spinner icon-center\"></i></button>\n      </td>\n      <% if (login.local.enabled === true) { %>\n      <td>\n        <button type=\"button\" class=\"btn btn-default btn-xs admin-user-resetpw\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"Reset Password\"><i class=\"fa fa-check fa-cog\"></i></button>\n        <button type=\"button\" class=\"btn btn-default btn-xs admin-user-unlock\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"Unlock User (clear password attempts)\" <% if (u.locked !== true) { %>style=\"display:none;\"<% } %>><i class=\"fa fa-check icon-red fa-lock\"></i></button>\n        <button type=\"button\" class=\"btn btn-default btn-xs btn-spin\" style=\"display:none;\"><i class=\"fa fa-spin fa-spinner icon-center\"></i></button>\n      </td>\n      <% } %>\n      <td>\n        <button type=\"button\" class=\"btn btn-default btn-xs admin-user-rmadmin\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"Remove Admin Priviledges\" <% if (u.isAdmin !== true) { %>style=\"display:none;\"<% } %>><i class=\"fa fa-check icon-green icon-center\"></i></button>\n        <button type=\"button\" class=\"btn btn-default btn-xs admin-user-mkadmin\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"Make Admin\" <% if (u.isAdmin === true) { %>style=\"display:none;\"<% } %>><i class=\"fa fa-times-circle icon-red icon-center\"></i></button>\n        <button type=\"button\" class=\"btn btn-default btn-xs btn-spin\" style=\"display:none;\"><i class=\"fa fa-spin fa-spinner icon-center\"></i></button>\n      </td>\n    </tr>\n    <% }); %>\n  </tbody>\n</table>\n";

},{}],13:[function(require,module,exports){
module.exports = "<div class=\"alert alert-danger\" style=\"display:none;\">\n</div>\n<div id=\"reset-password-container\"></div>\n<div class=\"row\">\n  <div class=\"col-md-12 box box-pad-lr\">\n    <div class=\"row\">\n      <div class=\"col-lg-8 col-md-7 col-sm-5 sm-nopadding md-nopadding\">\n\n      <form class=\"form-inline fullwidth\" role=\"form\">\n        <div class=\"form-group fullwidth\">\n          <label class=\"sr-only\" for=\"user-filter\">Filter</label>\n          <input type=\"text\" class=\"form-control fullwidth\" id=\"user-filter\" placeholder=\"Filter\">\n        </div>\n      </form>\n\n      </div>\n      <div class=\"col-lg-4 col-md-5 col-sm-7 sm-nopadding md-nopadding-right\">\n        <div class=\"pull-right\" id=\"user-page\">\n        </div>\n      </div>\n    </div>\n    <div class=\"row\">\n      <div class=\"col-md-12 sm-nopadding md-nopadding\">\n        <div class=\"fullwidth text-center spinner\">\n          Loading... <i class=\"fa fa-spinner fa-spin\"></i>\n        </div>\n      </div>\n    </div>\n    <div class=\"row\">\n      <div class=\"col-md-12 sm-nopadding md-nopadding\">\n        <div class=\"table-responsive\">\n\n        </div>\n      </div>\n    </div>\n  </div>\n</div>";

},{}],14:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../mixins/utilities');
var ModalComponent = require('../../../components/modal');
var AdminDashboardTemplate = require('../templates/admin_dashboard_template.html');
var AdminDashboardTable = require('../templates/admin_dashboard_table.html');
var AdminDashboardActivities = require('../templates/admin_dashboard_activities.html');
var LoginConfig = require('../../../config/login.json');


var AdminDashboardView = Backbone.View.extend({

  events: {
  },

  initialize: function (options) {
    this.options = options;
    this.data = {
      page: 1
    };
  },

  render: function () {
    var self = this;
    Backbone.history.navigate('/admin/dashboard');
    this.$el.show();
    if (this.rendered === true) {
      return this;
    }
    var data = {
      user: window.cache.currentUser,
      login: LoginConfig
    };
    var template = _.template(AdminDashboardTemplate)(data);
    this.$el.html(template);
    this.rendered = true;
    // fetch data
    this.fetchData(self, this.data);
    return this;
  },

  renderMetrics: function (self, data) {
    var template = _.template(AdminDashboardTable)(data);
    self.$(".metric-block").html(template);
    this.$el.i18n();
    // hide spinner and show results
    self.$(".spinner").hide();
    self.$(".metric-block").show();
  },

  renderActivities: function (self, data) {
    var template = _.template(AdminDashboardActivities);
    self.$(".activity-block").html(template);
    _(data).forEach(function(activity) {
      if (!activity) return;
      // Strip HTML from comments
      if (activity.comment) {
        var value = activity.comment.value.replace(/<(?:.|\n)*?>/gm, '');
        activity.comment.value = value;
      }
      // Format timestamp
      activity.createdAtFormatted = $.timeago(activity.createdAt);
      var template = self.$('#' + activity.type).text(),
          content = _.template(template, { escape: /\{\{(.+?)\}\}/g })(activity);
      self.$('.activity-block .activity-feed').append(content);
    });

    this.$el.i18n();
    // hide spinner and show results
    self.$(".spinner").hide();
    self.$(".activity-block").show();
  },

  fetchData: function (self, data) {
    $.ajax({
      url: '/api/admin/metrics',
      dataType: 'json',
      data: data,
      success: function (data) {
        self.data = data;
        $.ajax({
          url: '/api/admin/interactions',
          dataType: 'json',
          data: data,
          success: function(interactions) {
            data.interactions = interactions;
            interactions.count = _(interactions).reduce(function(sum, value, key) {
              return sum + value;
            }, 0);
            self.renderMetrics(self, data);
          },
          error: function (xhr, status, error) {
            self.handleError(self, xhr, status, error);
          }
        });
      },
      error: function (xhr, status, error) {
        self.handleError(self, xhr, status, error);
      }
    });
    $.ajax({
      url: '/api/admin/activities',
      dataType: 'json',
      data: data,
      success: function (data) {
        self.data = data;
        self.renderActivities(self, data);
      },
      error: function (xhr, status, error) {
        self.handleError(self, xhr, status, error);
      }
    });
  },

  handleError: function (self, xhr, status, error) {
    // show the alert message and hide the spinner
    self.$('.alert').html(error.message || error);
    self.$('.alert').show();
    self.$('.spinner').hide();
  }
});

module.exports = AdminDashboardView;

},{"../../../components/modal":106,"../../../config/login.json":114,"../../../mixins/utilities":128,"../templates/admin_dashboard_activities.html":4,"../templates/admin_dashboard_table.html":5,"../templates/admin_dashboard_template.html":6,"backbone":133,"underscore":159}],15:[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../mixins/utilities');
var AdminUserView = require('./admin_user_view');
var AdminTagView = require('./admin_tag_view');
var AdminTaskView = require('./admin_task_view');
var AdminDashboardView = require('./admin_dashboard_view');
var AdminMainTemplate = require('../templates/admin_main_template.html');


var AdminMainView = Backbone.View.extend({

  events: {
    'click .link-admin'             : 'link'
  },

  initialize: function (options) {
    this.options = options;
  },

  render: function () {
    var data = {

    };
    var template = _.template(AdminMainTemplate)(data);
    this.$el.html(template);
    this.routeTarget(this.options.action || '');
    return this;
  },

  routeTarget: function (target) {
    if (!target) {
      target = 'dashboard';
    }
    var t = $((this.$("[data-target=" + target + "]"))[0]);
    // remove active classes
    $($(t.parents('ul')[0]).find('li')).removeClass('active');
    // make the current link active
    $(t.parent('li')[0]).addClass('active');
    if (target == 'user') {
      if (!this.adminUserView) {
        this.initializeAdminUserView();
      }
      this.hideOthers();
      this.adminUserView.render();
    } else if (target == 'tag') {
      if (!this.adminTagView) {
        this.initializeAdminTagView();
      }
      this.hideOthers();
      this.adminTagView.render();
    } else if (target == 'tasks') {
      if (!this.adminTaskView) {
        this.initializeAdminTaskView();
      }
      this.hideOthers();
      this.adminTaskView.render();
    } else if (target == 'dashboard') {
      if (!this.adminDashboardView) {
        this.initializeAdminDashboardView();
      }
      this.hideOthers();
      this.adminDashboardView.render();
    }
  },

  link: function (e) {
    if (e.preventDefault) e.preventDefault();
    var t = $(e.currentTarget);
    this.routeTarget(t.data('target'));
  },

  hideOthers: function () {
    this.$(".admin-container").hide();
  },

  initializeAdminUserView: function () {
    if (this.adminUserView) {
      this.adminUserView.cleanup();
    }
    this.adminUserView = new AdminUserView({
      el: "#admin-user"
    });
  },

  initializeAdminTagView: function () {
    if (this.adminTagView) {
      this.adminTagView.cleanup();
    }
    this.adminTagView = new AdminTagView({
      el: "#admin-tag"
    });
  },

  initializeAdminTaskView: function () {
    if (this.adminTaskView) {
      this.adminTaskView.cleanup();
    }
    this.adminTaskView = new AdminTaskView({
      el: "#admin-task"
    });
  },

  initializeAdminDashboardView: function () {
    if (this.adminDashboardView) {
      this.adminDashboardView.cleanup();
    }
    this.adminDashboardView = new AdminDashboardView({
      el: "#admin-dashboard"
    });
  },

  cleanup: function () {
    if (this.adminUserView) this.adminUserView.cleanup();
    if (this.adminTagView) this.adminTagView.cleanup();
    if (this.adminTaskView) this.adminTaskView.cleanup();
    if (this.adminDashboardView) this.adminDashboardView.cleanup();
    removeView(this);
  },
});

module.exports = AdminMainView;

},{"../../../mixins/utilities":128,"../templates/admin_main_template.html":7,"./admin_dashboard_view":14,"./admin_tag_view":16,"./admin_task_view":17,"./admin_user_view":19,"backbone":133,"underscore":159}],16:[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../mixins/utilities');
var AdminTagTemplate = require('../templates/admin_tag_template.html');
var TagFactory = require('../../../components/tag_factory');


var AdminTagView = Backbone.View.extend({

  events: {
  },

  initialize: function (options) {
    this.options = options;
    this.tagFactory = new TagFactory();
  },

  render: function () {
    var types = [
      'agency',
      'skill',
      'topic'
    ];
    var data = {
      types: types
    };
    var template = _.template(AdminTagTemplate)(data);
    var self = this;
    this.$el.html(template);
    this.$el.show();

    _(types).forEach(this.tagSelector, this);

    Backbone.history.navigate('/admin/tag');
    return this;
  },

  tagSelector: function(type) {
    var self = this;
    $('#' + type).select2({
      placeholder: 'Search for a tag',
      minimumInputLength: 2,
      formatResult: function (obj, container, query) {
        return obj.name;
      },
      formatSelection: function (obj, container, query) {
        return obj.name;
      },
      createSearchChoice: function (term, values) {
        var vals = values.map(function(value) {
          return value.value.toLowerCase();
        });
        return (vals.indexOf(term.toLowerCase()) >=0) ? false : {
          unmatched: true,
          tagType: type,
          id: term,
          value: term,
          name: "<b>"+term+"</b> <i>click to create a new tag with this value</i>"
        };
      },
      ajax: {
        url: '/api/ac/tag',
        dataType: 'json',
        data: function (term) {
          return {
            type: type,
            q: term
          };
        },
        results: function (data) {
          return { results: data };
        }
      }
    }).on('change', function(e) {
      var $el = self.$(e.currentTarget);
      self.tagFactory.addTagEntities(e.added, self, function() {
        $('#' + type).select2('data', null);
        if (e.added && e.added.value === e.added.id) {
          $el.next('.form-status').text('Added tag: ' + e.added.value);
        } else {
          $el.next('.form-status').text('');
        }
      });
    });
  },

  cleanup: function () {
    removeView(this);
  },
});

module.exports = AdminTagView;

},{"../../../components/tag_factory":112,"../../../mixins/utilities":128,"../templates/admin_tag_template.html":9,"backbone":133,"underscore":159}],17:[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../mixins/utilities');
var AdminTaskTemplate = require('../templates/admin_task_template.html');


var AdminTaskView = Backbone.View.extend({

  events: {
  },

  initialize: function (options) {
    this.options = options;
    this.data = {
      page: 1
    };
  },

  render: function () {
    var self = this;
    $.ajax({
      url: '/api/admin/tasks',
      data: this.data,
      dataType: 'json',
      success: function (data) {
        var template = _.template(AdminTaskTemplate)(data);
        self.$el.html(template);
        self.$el.show();
      },
      error: function (xhr, status, error) {
        self.handleError(self, xhr, status, error);
      }
    });

    Backbone.history.navigate('/admin/tasks');
    return this;
  },

  cleanup: function () {
    removeView(this);
  },

  handleError: function (self, xhr, status, error) {
    // show the alert message and hide the spinner
    self.$('.alert').html(error.message || error);
    self.$('.alert').show();
    self.$('.spinner').hide();
  }

});

module.exports = AdminTaskView;

},{"../../../mixins/utilities":128,"../templates/admin_task_template.html":10,"backbone":133,"underscore":159}],18:[function(require,module,exports){

var Bootstrap = require('bootstrap');
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../mixins/utilities');
var AdminUserPassword = require('../templates/admin_user_password.html');


var AdminUserPasswordView = Backbone.View.extend({

  events: {
    "blur #newPassword"             : "v",
    "submit #reset-password"        : "post"
  },

  initialize: function (options) {
    this.options = options;
  },

  render: function () {
    var data = {
      admin: this.options.admin,
      u: this.options.user
    }
    var template = _.template(AdminUserPassword)(data);
    this.$el.html(template);
    return this;
  },

  v: function (e) {
    return validate(e);
  },

  post: function (e) {
    var self = this;
    if (e.preventDefault) e.preventDefault();

    // validate input fields
    var validateIds = ['#newPassword'];
    var abort = false;
    for (i in validateIds) {
      var iAbort = validate({ currentTarget: validateIds[i] });
      abort = abort || iAbort;
    }
    if (abort === true) {
      return;
    }

    // execute password reset
    var data;
    data = {
      id: this.options.user.id,
      password: this.$("#newPassword").val()
    };

    $.ajax({
      url: '/api/user/resetPassword',
      type: 'POST',
      data: JSON.stringify(data),
      dataType: 'json',
      contentType: 'application/json',
      success: function (data) {
        if (data === true) {
          // collapse modal
          $("#reset-password-modal").modal('hide');
          return;
        }
        self.processError({ message: 'An error occurred while trying to save the password: the server provided an unexpected response.'})
      },
      error: function (xhr, status, error) {
        self.processError(xhr.responseJSON);
      }
    });

  },

  processError: function (e) {
    this.$(".alert").html(e.message || e);
    this.$(".alert").show();
  },

  cleanup: function () {
    removeView(this);
  }

});

module.exports = AdminUserPasswordView;

},{"../../../mixins/utilities":128,"../templates/admin_user_password.html":11,"backbone":133,"bootstrap":138,"underscore":159}],19:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../mixins/utilities');
var ModalComponent = require('../../../components/modal');
var AdminUserPasswordView = require('./admin_user_password_view');
var AdminUserTemplate = require('../templates/admin_user_template.html');
var AdminUserTable = require('../templates/admin_user_table.html');
var Paginate = require('../templates/admin_paginate.html');
var LoginConfig = require('../../../config/login.json');


var AdminUserView = Backbone.View.extend({

  events: {
    "click a.page"              : "clickPage",
    "click .link-backbone"      : linkBackbone,
    "click .admin-user-mkadmin" : "adminCreate",
    "click .admin-user-rmadmin" : "adminRemove",
    "click .admin-user-enable"  : "adminEnable",
    "click .admin-user-disable" : "adminDisable",
    "click .admin-user-unlock"  : "adminUnlock",
    "click .admin-user-resetpw" : "resetPassword",
    "keyup #user-filter"        : "filter"
  },

  initialize: function (options) {
    this.options = options;
    this.data = {
      page: 1
    };
  },

  render: function () {
    var self = this;
    Backbone.history.navigate('/admin/user');
    this.$el.show();
    if (this.rendered === true) {
      return this;
    }
    var data = {
      user: window.cache.currentUser,
      login: LoginConfig
    };
    var template = _.template(AdminUserTemplate)(data);
    this.$el.html(template);
    this.rendered = true;
    // fetch user data
    this.fetchData(self, this.data);
    return this;
  },

  renderUsers: function (self, data) {
    data.urlbase = '/admin/users';
    data.q = data.q || '';
    // if the limit of results coming back hasn't been set yet
    // use the server's default
    if (!self.limit) {
      self.limit = data.limit;
    }
    data.trueLimit = self.limit;
    data.login = LoginConfig;
    data.user = window.cache.currentUser;
    // render the table
    var template = _.template(AdminUserTable)(data);
    // render the pagination
    var paginate = _.template(Paginate)(data);
    self.$("#user-page").html(paginate);
    self.$(".table-responsive").html(template);
    self.$(".btn").tooltip();
    // hide spinner and show results
    self.$(".spinner").hide();
    self.$(".table-responsive").show();
    self.$el.i18n();
  },

  clickPage: function (e) {
    var self = this;
    // if meta or control is held, or if the middle mouse button is pressed,
    // let the link process normally.
    // eg: open a new tab or window based on the browser prefs
    if ((e.metaKey === true) || (e.ctrlKey === true) || (e.which == 2)) {
      return;
    }
    if (e.preventDefault) e.preventDefault();
    // load this page of data
    this.fetchData(self, {
      page: $(e.currentTarget).data('page'),
      q: $($(e.currentTarget).parent('ul')[0]).data('filter'),
      limit: this.limit
    });
  },

  filter: function (e) {
    // get the input box value
    var val = $(e.currentTarget).val().trim();
    // if the filter is the same, don't do anything
    if (val == this.q) {
      return;
    }
    this.q = val;
    // hide the table and show the spinner
    this.$(".table-responsive").hide();
    this.$(".spinner").show();
    // fetch this query, starting from the beginning page
    this.fetchData(this, {
      q: val
    });
  },

  fetchData: function (self, data) {
    // perform the ajax request to fetch the user list
    $.ajax({
      url: '/api/admin/users',
      dataType: 'json',
      data: data,
      success: function (data) {
        self.data = data;
        self.renderUsers(self, data);
      },
      error: function (xhr, status, error) {
        self.handleError(self, xhr, status, error);
      }
    });
  },

  handleError: function (self, xhr, status, error) {
    // show the alert message and hide the spinner
    self.$('.alert').html(error.message || error);
    self.$('.alert').show();
    self.$('.spinner').hide();
  },

  adminCreate: function (e) {
    if (e.preventDefault) e.preventDefault();
    var t = $(e.currentTarget);
    var id = $(t.parents('tr')[0]).data('id');
    this.updateUser(t, {
      id: id,
      isAdmin: true,
      url: '/api/admin/admin/' + id + '?action=true'
    });
  },

  adminRemove: function (e) {
    if (e.preventDefault) e.preventDefault();
    var t = $(e.currentTarget);
    var id = $(t.parents('tr')[0]).data('id');
    this.updateUser(t, {
      id: id,
      isAdmin: false,
      url: '/api/admin/admin/' + id + '?action=false'
    });
  },

  adminEnable: function (e) {
    if (e.preventDefault) e.preventDefault();
    var t = $(e.currentTarget);
    var id = $(t.parents('tr')[0]).data('id');
    this.updateUser(t, {
      id: id,
      disabled: false,
      url: '/api/user/enable/' + id
    });
  },

  adminDisable: function (e) {
    if (e.preventDefault) e.preventDefault();
    var t = $(e.currentTarget);
    var id = $(t.parents('tr')[0]).data('id');
    this.updateUser(t, {
      id: id,
      disabled: true,
      url: '/api/user/disable/' + id
    });
  },

  adminUnlock: function (e) {
    if (e.preventDefault) e.preventDefault();
    var t = $(e.currentTarget);
    var id = $(t.parents('tr')[0]).data('id');
    this.updateUser(t, {
      id: id,
      passwordAttempts: 0,
      url: '/api/admin/unlock/' + id
    });

  },

  updateUser: function (t, data) {
    var self = this;
    var spinner = $($(t.parent()[0]).children('.btn-spin')[0])
    spinner.show();
    t.hide();
    if (data.url) {
      $.ajax({
        url: data.url,
        dataType: 'json',
        success: function (d) {
          // hide the spinner
          spinner.hide();
          // show the opposite button
          if (data.disabled === true) {
            $(t.siblings(".admin-user-enable")[0]).show();
          }
          if (data.disabled === false) {
            $(t.siblings(".admin-user-disable")[0]).show();
          }
          if (data.isAdmin === true) {
            $(t.siblings(".admin-user-rmadmin")[0]).show();
          }
          if (data.isAdmin === false) {
            $(t.siblings(".admin-user-mkadmin")[0]).show();
          }
        },
        error: function (xhr, status, error) {
          self.handleError(self, xhr, status, error);
        }
      });
    }
  },

  resetPassword: function (e) {
    if (e.preventDefault) e.preventDefault();
    if (this.passwordView) { this.passwordView.cleanup(); }
    if (this.modalComponent) this.modalComponent.cleanup();

    var tr = $($(e.currentTarget).parents('tr')[0]);
    var user = {
      id: tr.data('id'),
      name: $(tr.find('td.admin-table-name')[0]).text().trim()
    };

    // set up the modal
    this.modalComponent = new ModalComponent({
      el: "#reset-password-container",
      id: "reset-password-modal",
      modalTitle: "Reset Password"
    }).render();

    // initialize the view inside the modal
    this.passwordView = new AdminUserPasswordView({
      el: ".modal-template",
      user: user
    }).render();

    // render the modal
    this.$("#reset-password-modal").modal('show');
  },

  cleanup: function () {
    removeView(this);
  },
});

module.exports = AdminUserView;

},{"../../../components/modal":106,"../../../config/login.json":114,"../../../mixins/utilities":128,"../templates/admin_paginate.html":8,"../templates/admin_user_table.html":12,"../templates/admin_user_template.html":13,"./admin_user_password_view":18,"backbone":133,"underscore":159}],20:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var i18nOption = require('../config/i18n.json');
var BrowseApp = require('./browse/browse_app');


var initialize = function () {
  var router, browse;

  // Initialize the internationalization library and start Backbone when it's done initializing.
  $.i18n.init(i18nOption, function(t) {
    // Here we are going to fire up all the routers for our app to listen
    // in on their respective applications.  We are -testing- this functionality
    // by using the profile application as a starting point (very simple, 1 route).
    browse = BrowseApp.initialize();

    return Backbone.history.start({ pushState: true });
  });
}

module.exports = {
  initialize: initialize
};

},{"../config/i18n.json":113,"./browse/browse_app":24,"backbone":133,"underscore":159}],21:[function(require,module,exports){
module.exports = "<tr>\n  <td>\n    <span class=\"file-tag c3-bg white\">file</span>\n  </td>\n  <td class=\"attachment-name\">\n    <a href=\"/api/file/get/<%= a.file.id %>\" class=\"file-link\" data-id=\"<%= a.file.id %>\">\n      <%= a.file.name %>\n      <% if (user && ((a.userId == a.userId) || owner)) { %>\n      <a href=\"#\" class=\"file-delete\" data-id=\"<%= a.id %>\"><i class=\"fa fa-remove\"></i></a>\n      <% } %>\n      <br/>\n      <time class=\"timeago\" datetime=\"<%- a.createdAt %>\"><%- a.createdAt %></time>\n    </a>\n  </td>\n  <td class=\"file-person\">\n    <div class=\"project-people-div\" data-userid=\"<%- a.userId %>\">\n      <img src=\"/api/user/photo/<%= a.userId %>\" class=\"project-people\" />\n    </div>\n  </td>\n</tr>\n";

},{}],22:[function(require,module,exports){
module.exports = "<div class=\"box-pad-lr border-bottom\">\n  <h2>\n    Attachments\n    <div class=\"btn btn-c0 btn-sm file-add attachment-filebtn fileinput-button\" style=\"<% if (!user) { %>display:none;<% } %>\">\n      Add File\n      <input id=\"attachment-fileupload\" type=\"file\" name=\"files[]\" title=\"Attach Files\">\n    </div>\n  </h2>\n</div>\n<div class=\"attachment-fileupload box-pad-lr box-pad-t\">\n  <div style=\"display: none;\" class=\"progress progress-striped active\">\n    <div class=\"progress-bar\" style=\"width: 0\"></div>\n  </div>\n</div>\n<div class=\"box-pad-lr\">\n  <div class=\"file-upload-alert alert alert-warning\" style=\"display:none;\">\n    <span></span>\n    <button type=\"button\" class=\"close\" data-dismiss=\"alert\" aria-hidden=\"true\">&times;</button>\n  </div>\n</div>\n<div class=\"box-pad-lr box-pad-t file-list\">\n  <table class=\"table table-hover table-condensed\">\n    <tbody class=\"attachment-tbody\">\n      <tr class=\"attachment-none\"><td>No Attachments</td></tr>\n    </tbody>\n  </table>\n</div>\n";

},{}],23:[function(require,module,exports){

var Bootstrap = require('bootstrap');
var _ = require('underscore');
var jqIframe = require('blueimp-file-upload/js/jquery.iframe-transport');
var jqFU = require('blueimp-file-upload/js/jquery.fileupload.js');
var TimeAgo = require('../../../../vendor/jquery.timeago');
var Backbone = require('backbone');
var utils = require('../../../mixins/utilities');
var async = require('async');
var Popovers = require('../../../mixins/popovers');
var AITemplate = require('../templates/attachment_item_template.html');
var ASTemplate = require('../templates/attachment_show_template.html');


var popovers = new Popovers();

var AttachmentShowView = Backbone.View.extend({

  events: {
    'click .file-delete'                : 'deleteAttachment',
    "mouseenter .project-people-div"    : popovers.popoverPeopleOn,
    "click .project-people-div"         : popovers.popoverClick,
  },

  initialize: function (options) {
    this.options = options;
    this.data = options.data;
    this.action = options.action;
    this.edit = false;
    if (this.options.action) {
      if (this.options.action == 'edit') {
        this.edit = true;
      }
    }
  },

  initializeFiles: function () {
    var self = this;
    $.ajax({
      url: '/api/attachment/findAllBy' + this.options.target + 'Id/' + this.options.id
    }).done(function (data) {
      if (data && (data.length > 0)) {
        $(".attachment-none").hide();
      }
      _.each(data, function (f) {
        var template = self.renderAttachment(f);
        $(".attachment-tbody").append(template);
      });
      $("time.timeago").timeago();
      popovers.popoverPeopleInit(".project-people-div");
    });
  },

  initializeFileUpload: function () {
    var self = this;


    $('#attachment-fileupload').fileupload({
      url: "/api/file/create",
      dataType: 'text',
      acceptFileTypes: /(\.|\/)(gif|jpe?g|png)$/i,
      add: function (e, data) {
        self.$('.attachment-fileupload > .progress').show();
        data.submit();
      },
      progressall: function (e, data) {
        var progress = parseInt(data.loaded / data.total * 100, 10);
        self.$('.attachment-fileupload .progress-bar').css(
          'width',
          progress + '%'
        );
      },
      done: function (e, data) {
        // for IE8/9 that use iframe
        if (data.dataType == 'iframe text') {
          var result = JSON.parse(data.result);
        }
        // for modern XHR browsers
        else {
          var result = JSON.parse($(data.result).text());
        }

        // store id in the database with the file
        var aData = {
          fileId: result[0].id
        };
        aData[self.options.target + 'Id'] = self.options.id;
        $.ajax({
          url: '/api/attachment',
          type: 'POST',
          data: JSON.stringify(aData),
          dataType: 'json',
          contentType: 'application/json'
        }).done(function (attachment) {
          self.$('.attachment-fileupload > .progress').hide();
          self.renderNewAttachment(result[0], attachment);
        });
      },
      fail: function (e, data) {
        // notify the user that the upload failed
        var message = data.errorThrown;
        self.$('.attachment-fileupload > .progress').hide();
        if (data.jqXHR.status == 413) {
          message = "The uploaded file exceeds the maximum file size.";
        }
        self.$(".file-upload-alert > span").html(message)
        self.$(".file-upload-alert").show();
      }
    });

  },

  render: function () {
    data = {
      user: window.cache.currentUser
    };
    var template = _.template(ASTemplate)(data);
    this.$el.html(template);
    this.initializeFileUpload();
    this.initializeFiles();
    return this;
  },

  renderAttachment: function (attachment) {
    var data = {
      a: attachment,
      user: window.cache.currentUser,
      owner: this.options.owner
    };
    var templ = _.template(AITemplate)(data);
    return templ;
  },

  renderNewAttachment: function (file, attachment) {
    attachment.file = file;
    var templ = this.renderAttachment(attachment);
    $(".attachment-none").hide();
    // put new at the top of the list rather than the bottom
    $(".attachment-tbody").prepend(templ);
    $("time.timeago").timeago();
    popovers.popoverPeopleInit(".project-people-div");
  },

  deleteAttachment: function (e) {
    if (e.preventDefault) { e.preventDefault(); }
    $.ajax({
      url: '/api/attachment/' + $(e.currentTarget).data('id'),
      type: 'DELETE',
      success: function (d) {
        // remove from the DOM
        var len = $($(e.currentTarget).parents('tbody')[0]).children().length;
        $(e.currentTarget).parents('tr')[0].remove();
        if (len == 2) {
          $(".attachment-none").show();
        }
      }
    });
  },

  cleanup: function () {
    removeView(this);
  }

});

module.exports = AttachmentShowView;

},{"../../../../vendor/jquery.timeago":130,"../../../mixins/popovers":126,"../../../mixins/utilities":128,"../templates/attachment_item_template.html":21,"../templates/attachment_show_template.html":22,"async":131,"backbone":133,"blueimp-file-upload/js/jquery.fileupload.js":134,"blueimp-file-upload/js/jquery.iframe-transport":135,"bootstrap":138,"underscore":159}],24:[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../mixins/utilities');
var NavView = require('../nav/views/nav_view');
var FooterView = require('../footer/views/footer_view');
var BrowseListController = require('./controllers/browse_list_controller');
var ProjectModel = require('../../entities/projects/project_model');
var ProjectShowController = require('../project/show/controllers/project_show_controller');
var ProfileShowController = require('../profiles/show/controllers/profile_show_controller');
var TaskModel = require('../../entities/tasks/task_model');
var TaskShowController = require('../tasks/show/controllers/task_show_controller');
var TaskEditFormView = require('../tasks/edit/views/task_edit_form_view');
var AdminMainController = require('../admin/controllers/admin_main_controller');
var HomeController = require('../home/controllers/home_controller');


var BrowseRouter = Backbone.Router.extend({

  routes: {
    ''                   : 'showHome',
    'projects(/)'               : 'listProjects',
    'projects/:id(/)'           : 'showProject',
    'projects/:id/:action(/)'   : 'showProject',
    'tasks(/)'                  : 'listTasks',
    'tasks/:id(/)'              : 'showTask',
    'tasks/:id/:action(/)'      : 'showTask',
    'profile(/)'                : 'showProfile',
    'profile/:id(/)'            : 'showProfile',
    'profile/:id(/)/:action'    : 'showProfile',
    'admin(/)'                  : 'showAdmin',
    'admin(/):action(/)'        : 'showAdmin'
  },

  data: { saved: false },

  initialize: function () {
    this.navView = new NavView({
      el: '.navigation'
    }).render();
    this.footerView = new FooterView({
      el: '#footer'
    }).render();
  },

  cleanupChildren: function () {
    if (this.browseListController) { this.browseListController.cleanup(); }
    if (this.projectShowController) { this.projectShowController.cleanup(); }
    if (this.profileShowController) { this.profileShowController.cleanup(); }
    if (this.taskShowController) { this.taskShowController.cleanup(); }
    if (this.homeController) { this.homeController.cleanup(); }
    this.data = { saved: false };
  },

  showHome: function () {
    this.cleanupChildren();
    this.homeController = new HomeController({target: 'home', el: '#container', router: this, data: this.data });
  },

  listProjects: function () {
    this.cleanupChildren();
    this.browseListController = new BrowseListController({
      target: 'projects',
      el: '#container',
      data: this.data
    });
  },

  listTasks: function () {
    this.cleanupChildren();
    this.browseListController = new BrowseListController({
      target: 'tasks',
      el: '#container',
      data: this.data
    });
  },

  showProject: function (id, action) {
    this.cleanupChildren();
    var model = new ProjectModel();
    model.set({ id: id });
    this.projectShowController = new ProjectShowController({ model: model, router: this, id: id, action: action, data: this.data });
  },

  showTask: function (id, action) {
    this.cleanupChildren();
    var model = new TaskModel();
    model.set({ id: id });
    this.taskShowController = new TaskShowController({ model: model, router: this, id: id, action: action, data: this.data });
  },

  showProfile: function (id, action) {
    this.cleanupChildren();
    // normalize input
    if (id) {
      id = id.toLowerCase();
    }
    if (action) {
      action = action.toLowerCase();
    }
    // normalize actions that don't have ids
    if (!action && id) {
      if (id == 'edit') {
        action = id;
        id = window.cache.currentUser.id;
      }
      else if (id == 'settings') {
        action = id;
        id = window.cache.currentUser.id;
      }
    }
    this.profileShowController = new ProfileShowController({ id: id, action: action, data: this.data });
  },

  showAdmin: function (action) {
    this.cleanupChildren();
    this.adminMainController = new AdminMainController({
      el: "#container",
      action: action
    });
  }

});

var initialize = function () {
  var router = new BrowseRouter();
  return router;
}

module.exports = {
  initialize: initialize
};


},{"../../entities/projects/project_model":122,"../../entities/tasks/task_model":124,"../../mixins/utilities":128,"../admin/controllers/admin_main_controller":3,"../footer/views/footer_view":47,"../home/controllers/home_controller":48,"../nav/views/nav_view":57,"../profiles/show/controllers/profile_show_controller":60,"../project/show/controllers/project_show_controller":72,"../tasks/edit/views/task_edit_form_view":87,"../tasks/show/controllers/task_show_controller":93,"./controllers/browse_list_controller":25,"backbone":133,"underscore":159}],25:[function(require,module,exports){

var Bootstrap = require('bootstrap');
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../mixins/utilities');
var BaseController = require('../../../base/base_controller');
var BrowseMainView = require('../views/browse_main_view');
var ProjectsCollection = require('../../../entities/projects/projects_collection');
var TasksCollection = require('../../../entities/tasks/tasks_collection');
var TaskModel = require('../../../entities/tasks/task_model');
var ProjectFormView = require('../../project/new/views/project_new_form_view');
var TaskFormView = require('../../tasks/new/views/task_form_view');
var ModalWizardComponent = require('../../../components/modal_wizard');
var ModalComponent = require('../../../components/modal');


Browse = {};

Browse.ListController = BaseController.extend({

  events: {
    "click .link-backbone"  : linkBackbone,
    "click .project-background-image" : "showProject",
    "click .task-box"       : "showTask",
    "click .add-project"    : "addProject",
    "click .add-opportunity": "addTask"
  },

  initialize: function ( options ) {
    var self = this;
    // this.options = options;
    this.target = options.target;
    this.fireUpCollection();
    this.initializeView();

    this.collection.trigger('browse:' + this.target + ":fetch");

    this.listenTo(this.projectsCollection, "project:save:success", function (data) {
      // hide the modal
      $('#addProject').bind('hidden.bs.modal', function() {
        Backbone.history.navigate('projects/' + data.attributes.id, { trigger: true });
      }).modal('hide');
    });

    this.listenTo(this.tasksCollection, "task:save:success", function (data) {
      // hide the modal
      $('#addTask').bind('hidden.bs.modal', function() {
        Backbone.history.navigate('tasks/' + data, { trigger: true });
      }).modal('hide');
    });

  },

  initializeView: function () {
    if (this.browseMainView) {
      this.browseMainView.cleanup();
    }
    this.browseMainView = new BrowseMainView({
      el: "#container",
      target: this.target,
      collection: this.collection
    }).render();
  },

  fireUpCollection: function () {
    var self = this;
    this.projectsCollection = new ProjectsCollection();
    this.tasksCollection = new TasksCollection();
    if (this.target == 'projects') {
      this.collection = this.projectsCollection;
    }
    else if (this.target == 'tasks') {
      this.collection = this.tasksCollection;
    }
    else {
      this.collection = new ProfilesCollection();
    }
    this.listenToOnce(this.collection, 'browse:' + this.target + ":fetch", function () {
      self.collection.fetch({
        success: function (collection) {
          self.collection = collection;
          self.browseMainView.renderList(self.collection.toJSON());
        }
      })
    })
  },

  // -----------------------
  //= BEGIN CLASS METHODS
  // -----------------------
  showProject: function (e) {
    if (e.preventDefault) e.preventDefault();
    var id = $($(e.currentTarget).parents('li.project-box')[0]).data('id');
    Backbone.history.navigate('projects/' + id, { trigger: true });
  },

  showTask: function (e) {
    if (e.preventDefault) e.preventDefault();
    var id = $(e.currentTarget).data('id') || $($(e.currentTarget).parents('li.task-box')[0]).data('id');
    Backbone.history.navigate('tasks/' + id, { trigger: true });
  },

  addProject: function (e) {
    if (e.preventDefault) e.preventDefault();

    if (this.projectFormView) this.projectFormView.cleanup();
    if (this.modalComponent) this.modalComponent.cleanup();

    this.modalComponent = new ModalComponent({
      el: ".wrapper-addProject",
      id: "addProject",
      modalTitle: "Add " + i18n.t("Project")
    }).render();

    this.projectFormView = new ProjectFormView({
      el: ".modal-template",
      collection: this.projectsCollection
    }).render();

  },

  addTask: function (e) {
    if (e.preventDefault) e.preventDefault();

    if (this.taskFormView) this.taskFormView.cleanup();
    if (this.modalWizardComponent) this.modalWizardComponent.cleanup();

    this.taskModel = new TaskModel();
    this.modalWizardComponent = new ModalWizardComponent({
      el: ".wrapper-addTask",
      id: "addTask",
      draft: true,
      modalTitle: 'New ' + i18n.t('Opportunity'),
      model: this.taskModel,
      collection: this.tasksCollection,
      modelName: 'task',
      data: function (parent) { return {
        title: parent.$("#task-title").val(),
        description: parent.$("#task-description").val(),
        // these tasks are orphaned
        projectId: null
      } }
    }).render();

    this.taskFormView = new TaskFormView({
      el: "#addTask .modal-body",
      projectId: null,
      model: this.taskModel,
      tasks: this.tasksCollection
    }).render();
    this.modalWizardComponent.setChildView(this.taskFormView);
    this.modalWizardComponent.setNext(this.taskFormView.childNext);
    this.modalWizardComponent.setSubmit(this.taskFormView.childNext);
  },

  // ---------------------
  //= UTILITY METHODS
  // ---------------------
  cleanup: function() {
    if (this.taskFormView) { this.taskFormView.cleanup(); }
    if (this.modalWizardComponent) { this.modalWizardComponent.cleanup(); }
    if (this.projectFormView) { this.projectFormView.cleanup(); }
    if (this.modalComponent) { this.modalComponent.cleanup(); }
    if (this.browseMainView) { this.browseMainView.cleanup(); }
    removeView(this);
  }

});

module.exports = Browse.ListController;

},{"../../../base/base_controller":101,"../../../components/modal":106,"../../../components/modal_wizard":110,"../../../entities/projects/projects_collection":123,"../../../entities/tasks/task_model":124,"../../../entities/tasks/tasks_collection":125,"../../../mixins/utilities":128,"../../project/new/views/project_new_form_view":71,"../../tasks/new/views/task_form_view":92,"../views/browse_main_view":32,"backbone":133,"bootstrap":138,"underscore":159}],26:[function(require,module,exports){
module.exports = "<div class=\"wrapper-addProject\"></div>\n<div class=\"wrapper-addTask\"></div>\n\n<div class=\"row search-row\">\n  <div class=\"col-md-3 col-md-push-9 browse-buttons\">\n    <% if (ui.project.show) { %>\n    <a href=\"#addProject\" class=\"btn btn-c2 add-project\" data-toggle=\"modal\" data-backdrop=\"static\" style=\"<% if (!user) { %>display: none;<% } %>\"><i class=\"fa fa-plus\"></i> <span data-i18n=\"Project\">Project</span></a>\n    <% } %>\n    <a href=\"#addTask\" class=\"btn btn-c2 add-opportunity\" data-toggle=\"modal\" data-backdrop=\"static\" style=\"<% if (!user) { %>display: none;<% } %>\"><i class=\"fa fa-plus\"></i> <span data-i18n=\"Task\">Opportunity</span></a>\n  </div>\n  <div class=\"col-md-9 col-md-pull-3\">\n    <form class=\"form-horizontal\" role=\"form\" id=\"search-form\">\n\n      <div class=\"form-group row\">\n        <div class=\"col-sm-10 col-md-10 col-lg-9 input-search\">\n          <input type=\"hidden\" id=\"search\" title=\"Search\" style=\"width: 100%\"/>\n        </div>\n        <div class=\"col-sm-2 col-md-2 col-lg-3 btn-search\">\n          <input type=\"submit\" class=\"btn btn-c1\" title=\"Search\" value=\"Search\"/>\n        </div>\n      </div>\n\n    </form>\n  </div>\n</div>\n<div class=\"row\">\n\n  <div class=\"col-md-3 col-md-push-9 box\">\n    <div class=\"border-bottom box-pad-lr\">\n      <h2>Filters</h2>\n    </div>\n    <div class=\"box-pad-t\">\n      <% if ( target == \"tasks\" ) {%>\n      <div class=\"box-pad-lr\" id=\"stateFilters\">\n        <% _.each(ui.states, function (t) { %>\n          <label class=\"<% if ( t.value == \"draft\" ) { %>hidden draft-filter<% } %>\">\n            <input type='checkbox' name='state<%- t.label %>' class='stateFilter' value='<%- t.value %>'\n            <% if ( t.value == \"open\" ) {%>\n              <%- checked=\"checked\" %>\n            <% } %>\n            > <%- t.label %>\n          </label>\n        <% }); %>\n      </div>\n      <% } %>\n      <div id=\"search-projs-wrapper\" class=\"box-pad-lr\">\n        <ul id=\"search-projs\" class=\"nav nav-pills nav-stacked nav-search\">\n        </ul>\n      </div>\n      <div class=\"box-pad-lr\">\n        <ul id=\"search-tags\" class=\"nav nav-pills nav-stacked nav-search\">\n        </ul>\n      </div>\n      <div class=\"box-pad-lr search-clear\" style=\"display: none;\">\n        <div class=\"align-right\">\n          <a href=\"#\" id=\"search-clear\" class=\"btn btn-sm btn-c0\"><i class=\"fa fa-remove\"></i> Clear Search Criteria</a>\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"col-md-9 col-md-pull-3\">\n    <div id=\"browse-search-spinner\" class=\"fullwidth text-center\">\n      Loading... <i class=\"fa fa-spinner fa-spin\"></i>\n    </div>\n    <ul id=\"browse-list\">\n    </ul>\n  </div>\n\n</div>\n";

},{}],27:[function(require,module,exports){
module.exports = "<li data-id=\"<%= data.id %>\">\n  <%= format %>\n  <div class=\"pull-right\">\n    <a href=\"#\" class=\"search-tag-remove\"><i class=\"fa fa-remove\"></i></a>\n  </div>\n</li>\n";

},{}],28:[function(require,module,exports){
module.exports = "<span data-i18n='[html]noSearchResults.text'>\n<h2>Oops we didn't find any results</h2>\n<p>Maybe your search was too specific. You could try including more filters like <b>Completed</b> or <b>Archived</b>. Maybe there are too many search terms, try removing some or using more general terms.</p>\n<p>Still not finding what you wanted?</p>\n<p>Did you mean to:</p>\n</span>\n\t<ul>\n\t\t<% if (ui.project.show) { %>\n\t\t<li>Look for <span data-i18n=\"ProjectIndefinite\">a Project</span>? Try going to Browse <span data-i18n=\"ProjectPlural\">Projects</span> or clicking <a href='/projects'>here</a> .</li>\n\t\t<% } %>\n\t\t<li>Look for <span data-i18n=\"TaskIndefinite\">a Task</span>? Try going to Browse <span data-i18n=\"TaskPlural\">Tasks</span> or clicking <a href='/tasks'>here</a> . </li>\n\t\t<% if (ui.faq.show) { %>\n\t\t<li>Get an answer to a general question? Try reading the FAQ by clicking <a href='<%- ui.faq.url %>'>here</a> .</li>\n\t\t<% } %>\n\t\t<li>Get an answer to a specific question you can't find elsewhere? Trying <a href='mailto:<%- ui.systemEmail %>'>sending an email to the team .</a></li>\n\t</ul>";

},{}],29:[function(require,module,exports){
module.exports = "<li data-id=\"<%- item.id %>\" class=\"box project-box\">\n  <% if (item.coverId) { %>\n  <div class=\"project-background-image border-bottom\" style=\"background-image: url(/api/file/get/<%= item.coverId %>)\">\n  <% } else { %>\n  <div class=\"project-background-image border-bottom project-background-image-default\">\n  <% } %>\n  </div>\n  <div class=\"project-title\">\n    <a href=\"/projects/<%- item.id %>\" class=\"link-backbone c1\">\n      <%- item.title %>\n    </a>\n  </div>\n  <div class=\"project-list-description\">\n    <%= item.descriptionHtml %>\n  </div>\n\n  <div class=\"project-list-bottom-wrapper border-top\">\n    <div class=\"project-list-counts\">\n      <div class=\"project-list-counts-col\">\n        <div class=\"project-list-count c2\">\n          <%- item.taskCount %>\n        </div>\n        <div class=\"project-list-count-text c2\">\n          opp<% if (item.taskCount != 1) { %>s<% } %>\n        </div>\n      </div>\n      <div class=\"project-list-counts-col\">\n        <div class=\"project-list-count c2\">\n          <%- item.commentCount %>\n        </div>\n        <div class=\"project-list-count-text c2\">\n          comment<% if (item.commentCount != 1) { %>s<% } %>\n        </div>\n      </div>\n      <div class=\"project-list-counts-col\">\n        <div class=\"project-list-count c2\">\n          <%- item.ownerCount %>\n        </div>\n        <div class=\"project-list-count-text c2  \">\n          <% if (item.ownerCount != 1) { %>people<% } else { %>person<% } %>\n        </div>\n      </div>\n    </div>\n  </div>\n</li>";

},{}],30:[function(require,module,exports){
module.exports = "<li data-id=\"<%- item.id %>\" class=\"box task-box\">\n\n    <div class=\"task-list-title task-title-overflow-multi\">\n      <a href=\"/tasks/<%- item.id %>\" class=\"link-backbone c1\">\n        <%- item.title %>\n      </a>\n    </div>\n\n  <div class=\"task-list-description task-desc-overflow-multi\">\n    <%= item.descriptionHtml %>\n  </div>\n\n  <div class=\"task-list-bottom border-top\">\n\n    <% _.each(tagShow, function (tagType) { %>\n\n      <% if (tags[tagType]) { %>\n      <div class=\"task-list-tags c0 task-single-overflow\">\n        <i class=\"task-list-icon-center <%= tagConfig.tags[tagType].icon %>\"></i>\n        <% _.each(tags[tagType], function (t, i) { %>\n          <%= t.name %><% if (i + 1 < tags[tagType].length) { %>,<% } %>\n        <% }); %>\n      </div>\n      <% } %>\n\n    <% }); %>\n\n  </div>\n  <div class=\"task-list-bottom-person border-top\">\n    <div class=\"task-list-person\">\n      <div class=\"project-people-div float-left\" data-userid=\"<%= item.userId %>\" style=\"text-align: right;\">\n        <img src=\"/api/user/photo/<%= item.userId %>\" class=\"project-people\"/>\n      </div>\n      <div class=\"task-list-requestbox\">\n        <div class=\"task-list-requested\">requested by</div>\n        <div class=\"task-list-name\"><%- item.user.name %></div>\n        <% if (item.user.agency) { %>\n        <div class=\"task-list-agency task-single-overflow\"><%= item.user.agency.tag.name %></div>\n        <% } %>\n      </div>\n    </div>\n\n  </div>\n\n</li>";

},{}],31:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var async = require('async');
var utils = require('../../../mixins/utilities');
var UIConfig = require('../../../config/ui.json');
var marked = require('marked');
var TagConfig = require('../../../config/tag');
var ProjectListItem = require('../templates/project_list_item.html');
var TaskListItem = require('../templates/task_list_item.html');
var NoListItem = require('../templates/no_search_results.html');


var BrowseListView = Backbone.View.extend({

  initialize: function (options) {
    var self = this;

    var pageSize = 27;
    if (UIConfig.browse && UIConfig.browse.pageSize)
      pageSize = UIConfig.browse.pageSize;

    this.options = options;
    this.data = {
      pageSize: pageSize,
      page: 1
    }
    $(window).on('scroll',function(e){
      self.scrollCheck(e);
    });
  },

  organizeTags: function (tags) {
    // put the tags into their types
    var outTags = {};
    for (t in tags) {
      if (!(_.has(outTags, tags[t].tag.type))) {
        outTags[tags[t].tag.type] = [];
      }
      outTags[tags[t].tag.type].push(tags[t].tag);
    }
    return outTags;
  },

  scrollCheck: function(e) {
    var currentScrollPos = $(window).scrollTop();
    var currentMaxHeight = $('#container').height();
    var buffer           = 600;

    if ( (this.options.collection.length / this.data.page) > 1 && Math.ceil(this.options.collection.length / this.data.pageSize) >= this.data.page && currentScrollPos + buffer > currentMaxHeight ){
      this.data.page += 1;
      this.render();
    }
  },

  render: function () {

    //settings for infinite scroll
    if ( UIConfig.browse && UIConfig.browse.useInfiniteScroll ) {
      if ( this.data.page == 1 ){
        var start = 0;
      } else {
        var start = (this.data.page-1) * this.data.pageSize;
      }
      var limit    = start + this.data.pageSize;
    } else {
      //reset page to 1 and return
      if ( this.data.page > 1 ) {
        this.data.page = 1;
        return this;
      }
      var limit = this.options.collection.length;
      var start = 0;
    }

    if ( this.options.collection.length == 0 ){
      var settings = {
        ui: UIConfig
      }
      compiledTemplate = _.template(NoListItem)(settings);
      this.$el.append(compiledTemplate);
    } else {

      for ( i = start; i < limit; i++ ){

      if ( typeof this.options.collection[i] == 'undefined' ){ break; }
        var item = {
          item: this.options.collection[i],
          user: window.cache.currentUser,
          tagConfig: TagConfig,
          tagShow: ['location', 'skill', 'topic', 'task-time-estimate', 'task-time-required']
        }
        if (this.options.collection[i].tags) {
          item.tags = this.organizeTags(this.options.collection[i].tags);
        } else {
          item.tags =[];
        }
        if (this.options.collection[i].description) {
          item.item.descriptionHtml = marked(this.options.collection[i].description);
        }
        var compiledTemplate = '';
        if (this.options.target == 'projects') {
          compiledTemplate = _.template(ProjectListItem)(item);
        } else {
          compiledTemplate = _.template(TaskListItem)(item);
        }
        this.$el.append(compiledTemplate);
      }
    }
    this.$el.i18n();
    return this;
  },

  cleanup: function () {
    removeView(this);
  }

});

module.exports = BrowseListView;

},{"../../../config/tag":115,"../../../config/ui.json":116,"../../../mixins/utilities":128,"../templates/no_search_results.html":28,"../templates/project_list_item.html":29,"../templates/task_list_item.html":30,"async":131,"backbone":133,"marked":155,"underscore":159}],32:[function(require,module,exports){
var select2 = require('select2');
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../mixins/utilities');
var UIConfig = require('../../../config/ui.json');
var Popovers = require('../../../mixins/popovers');
var TagConfig = require('../../../config/tag');
var BrowseListView = require('./browse_list_view');
var BrowseMainTemplate = require('../templates/browse_main_view_template.html');
var BrowseSearchTag = require('../templates/browse_search_tag.html');


var popovers = new Popovers();

var BrowseMainView = Backbone.View.extend({

  events: {
    "submit #search-form"             : "search",
    "click .search-tag-remove"        : "searchTagRemove",
    "click .search-clear"             : "searchClear",
    "change .stateFilter"             : "searchTagRemove",
    "mouseenter .project-people-div"  : popovers.popoverPeopleOn,
    "click      .project-people-div"  : popovers.popoverClick,
    "keyup .select2-container"        : "submitOnEnter"
  },

  initialize: function (options) {
    this.options = options;
  },

  render: function () {
    var options = {
      target: this.options.target,
      user: window.cache.currentUser,
      ui: UIConfig
    };
    this.compiledTemplate = _.template(BrowseMainTemplate)(options)
    this.$el.html(this.compiledTemplate);
    this.$el.i18n();

    this.initializeSearch();

    // Allow chaining.
    return this;
  },

  format: function (self, object, container, query) {
    var name = object.name || object.title;
    var icon = this.tagIcon[object.type];
    if (object.target == 'project') {
      icon = 'fa fa-folder-o';
    } else if (object.target == 'task') {
      icon = 'fa fa-tag';
    }
    return '<i class="' + icon + '"></i> <span class="box-icon-text">' + name + '</span>';
  },

  initializeSearch: function() {
    var self = this;
    this.searchTerms = [];
    this.tags = [];

    // figure out which tags apply
    for (var i = 0; i < TagConfig[this.options.target].length; i++) {
      this.tags.push(TagConfig.tags[TagConfig[this.options.target][i]]);
    }

    // extract tag icons and classes
    this.tagIcon = {};
    this.tagClass = {};
    for (var i = 0; i < this.tags.length; i++) {
      this.tagIcon[this.tags[i].type] = this.tags[i].icon;
      this.tagClass[this.tags[i].type] = this.tags[i]['class'];
    }

    var formatResult = function (object, container, query) {
      return self.format(self, object, container, query);
    };

    // Initialize Select2
    $("#search").select2({
      placeholder: 'I\'m looking for...',
      multiple: true,
      formatResult: formatResult,
      formatSelection: function(object,container,query) {
          //null object.target to remove the task / project icons that get readded when terms go
          //     to the search box on the right
          object.target = null;
          object.type   = object.name || object.title;
          object.id     = object.name || object.title;
          object.value  = object.name || object.title;
          object.unmatched = true;
          return object.name || object.title;
      },
      createSearchChoice: function (term) {
          return { unmatched: true,id: term, value: term, name: "<b>"+term+"</b> <i>click to text search for this value.</i>" };
      },
      ajax: {
        url: '/api/ac/search/' + self.options.target,
        dataType: 'json',
        data: function (term) {
          return {
            type: TagConfig[self.options.target].join(),
            q: term
          };
        },
        results: function (data) {
          return { results: data };
        }
      }
    }).on("select2-selecting", function (e){
        if ( e.choice.hasOwnProperty("unmatched") && e.choice.unmatched ){
          //remove the hint before adding it to the list
          e.choice.name = e.val;
        }
      });
  },

  submitOnEnter: function (e) {
    if(e.keyCode === 13) {
      this.search(e);
    }
  },

  search: function (e) {
    var self = this;
    if (e.preventDefault) e.preventDefault();
    // get values from select2
    var data = $("#search").select2("data");
    if (data.length > 0) {
      $("#search-none").hide();
      $(".search-clear").show();
    }
    _.each(data, function (d) {
      var found = false;
      // check if this search term already is chosen
      for (var i in self.searchTerms) {
        if (self.searchTerms[i].id == d.id) {
          if (self.searchTerms[i].title && (self.searchTerms[i].title == d.title)) {
            found = true;
          }
          else if (self.searchTerms[i].name && (self.searchTerms[i].name == d.name)) {
            found = true;
          }
        }
      }
      // return if the search term is found
      if (found) return;
      // add it to our list of search terms
      self.searchTerms.push(d);
      // render the search term in the list
      var templData = {
        data: d,
        format: self.format(self, d)
      };
      var templ = _.template(BrowseSearchTag)(templData);
      if (d.target == 'tagentity') {
        $("#search-tags").append(templ);
      } else {
        $("#search-projs").append(templ);
      }
    });
    $("#search").select2("data","");
    self.searchExec(self.searchTerms);
  },

  renderList: function (collection) {
    // create a new view for the returned data
    if (this.browseListView) { this.browseListView.cleanup(); }

    var filteredCollection = this.applyStateFilters(collection);

    this.browseListView = new BrowseListView({
      el: '#browse-list',
      target: this.options.target,
      collection: filteredCollection,
    });
    // Show draft filter
    var draft = _(collection).chain()
          .pluck('state')
          .indexOf('draft').value() >= 0;
    $(".draft-filter").toggleClass('hidden', !draft);
    $("#browse-search-spinner").hide();
    $("#browse-list").show();
    this.browseListView.render();
    popovers.popoverPeopleInit(".project-people-div");
  },

  searchExec: function (terms) {
    var self = this;

    if (!terms || (terms.length == 0)) {
      // re-render the collection
      self.renderList(this.options.collection.toJSON());
      return;
    }

    // create a search object
    var data = {
      items: [],
      tags: [],
      freeText: [],
      target: self.options.target
    };
    _.each(terms, function (t) {
      if ( t.unmatched ) {
        data.freeText.push(t.value);
      } else {
        data.items.push(t.id);
      }
    });
    $.ajax({
      url: '/api/search',
      type: 'POST',
      data: JSON.stringify(data),
      dataType: 'json',
      contentType: 'application/json'
    }).done(function (data) {
      // render the search results
      self.renderList(data);
    });
  },

  applyStateFilters: function (data) {

    if ( !_.isObject(data) || !$("#stateFilters").length ){ return data; }
    var keepers = [];
    //get check stateFilter inputs
    var inputs = $(".stateFilter:checked");

    _.each(data,function(item){
      _.each(inputs,function(test){
         if ( item.state == test.value ){
           keepers.push(item);
         }
      });
    });

    return keepers;
  },

  searchTagRemove: function (e) {
    if (e.preventDefault) e.preventDefault();

    var self = this;

    if ( $(e.currentTarget).hasClass("stateFilter") ){
      if ( $("#search-tags").length > 0 ) {
        var parent = $("#search-tags");
        var id = "search-tags";
        var project = false;
      }
    } else {
      var parent = $(e.currentTarget).parents('li')[0];
      var id = $(parent).data('id');
      var type = $($(e.currentTarget).parents('ul')[0]).attr('id');
      var project = false;

      if (type == 'search-projs') {
        project = true;
      }
    }

    for (i in self.searchTerms) {
      if (self.searchTerms[i].id == id) {
        if (project && self.searchTerms[i].title) {
          self.searchTerms.splice(i, 1);
          break;
        } else if (self.searchTerms[i].name) {
          self.searchTerms.splice(i, 1);
          break;
        }
      }
    }

    if ( !$(e.currentTarget).hasClass("stateFilter") ){
      parent.remove();
    }
    if (self.searchTerms.length == 0) {
      $("#search-none").show();
      $(".search-clear").hide();
    }
    self.searchExec(self.searchTerms);
  },

  searchClear: function (e) {
    if (e.preventDefault) e.preventDefault();
    this.searchTerms = [];
    $("#search-projs").children().remove();
    $("#search-tags").children().remove();
    $("#search-none").show();
    $(".search-clear").hide();
    this.searchExec(self.searchTerms);
  },

  cleanup: function() {
    if (this.browseListView) { this.browseListView.cleanup(); }
    removeView(this);
  }

});

module.exports = BrowseMainView;

},{"../../../config/tag":115,"../../../config/ui.json":116,"../../../mixins/popovers":126,"../../../mixins/utilities":128,"../templates/browse_main_view_template.html":26,"../templates/browse_search_tag.html":27,"./browse_list_view":31,"backbone":133,"select2":157,"underscore":159}],33:[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var TimeAgo = require('../../../../../vendor/jquery.timeago');
var Popovers = require('../../../../mixins/popovers');
var CommentCollection = require('../../../../entities/comments/comment_collection');
var CommentFormView = require('../../new/views/comment_form_view');
var CommentItemView = require('../views/comment_item_view');
var CommentWrapper = require('../templates/comment_wrapper_template.html');


var popovers = new Popovers();

Comment = Backbone.View.extend({

  el: ".comment-list-wrapper",

  events: {
    "click .new-topic"                  : "newTopic",
    "click .comment-expand"             : "topicExpand",
    "click .comment-contract"           : "topicContract",
    "mouseenter .comment-user-link"     : popovers.popoverPeopleOn,
    "click .comment-user-link"          : popovers.popoverClick,
    "click .link-backbone"              : linkBackbone,
    "click a[href='#reply-to-comment']" : "reply"
  },

  initialize: function (options) {
    var self = this;
    this.options = options;

    this.initializeRender();
    this.initializeCommentCollection();
    this.initializeListeners();

    // Populating the DOM after a comment was created.
    this.listenTo(this.commentCollection, "comment:save:success", function (model, modelJson, currentTarget) {
      if (modelJson.topic) {
        // cleanup the topic form
        if (this.topicForm) this.topicForm.cleanup();
      }
      self.addNewCommentToDom(modelJson, currentTarget);
    });

  },

  initializeRender: function() {
    var template = _.template(CommentWrapper)({ user: window.cache.currentUser });
    this.$el.html(template);
  },

  initializeCommentCollection: function () {
    var self = this;

    if (this.commentCollection) { this.renderView() }
    else { this.commentCollection = new CommentCollection(); }

    this.commentCollection.fetch({
      url: '/api/comment/findAllBy' + this.options.target + 'Id/' + this.options.id,
      success: function (collection) {
        self.collection = collection;
        self.renderView(collection);
      }
    });
  },

  initializeListeners: function() {
    var self = this;

    this.listenTo(this.commentCollection, "comment:topic:new", function (value) {
      var data = {
        value: value,
        topic: true
      };
      data[self.options.target + 'Id'] = self.options.id;

      // TODO: DM: Fix this to add to the collection appropriately,
      // and fetch/re-render as needed.  This is a hack to get it to work
      $.ajax({
        url: '/api/comment',
        type: 'POST',
        contentType: 'application/json',
        processData: false,
        data: JSON.stringify(data)
      }).done(function (result) {
        self.commentCollection.fetch({
          url: '/api/comment/findAllBy' + self.options.target + 'Id/' + self.options.id,
          success: function (collection) {
          }
        });
      });
    });
  },

  renderView: function (collection) {
    var self = this;
    this.parentMap = {};
    this.topics = [];
    var data = {
      comments: collection.toJSON()[0].comments
    };

    // compute the depth of each comment to use as metadata when rendering
    // in the process, create a map of the ids of each comment's children
    var depth = {};
    if (!data.comments) {
      data.comments = [];
    }
    for (var i = 0; i < data.comments.length; i += 1) {
      if (data.comments[i].topic === true) {
        depth[data.comments[i].id] = 0;
        data.comments[i]['depth'] = depth[data.comments[i].id];
        this.topics.push(data);
      } else {
        depth[data.comments[i].id] = depth[data.comments[i].parentId] + 1;
        data.comments[i]['depth'] = depth[data.comments[i].id];
        // augment the parentMap with this comment
        if (_.isUndefined(this.parentMap[data.comments[i].parentId])) {
          this.parentMap[data.comments[i].parentId] = [];
        }
        this.parentMap[data.comments[i].parentId].push(data.comments[i].id);
      }
    }

    // hide the loading spinner
    this.$('.comment-spinner').hide();

    this.commentViews = [];
    this.commentForms = [];
    if (data.comments.length == 0) {
      this.$('#comment-empty').show();
    }
    _.each(data.comments, function (comment, i) {
      self.renderComment(self, comment, collection, self.parentMap);
    });

    this.initializeCommentUIAdditions();
  },

  renderComment: function (self, comment, collection, map) {
    var self = this;
    // count the number of replies in a topic, recursively
    var countChildren = function (map, comment) {
      if (_.isUndefined(map[comment])) {
        return 0;
      }
      var count = map[comment].length;
      _.each(map[comment], function (c) {
        count += countChildren(map, c);
      });
      return count;
    };
    // if this is a topic, count the children for rendering
    if (comment.topic === true) {
      comment.numChildren = countChildren(map, comment.id);
    }
    // Render the topic view and then in that view spew out all of its children.
    var commentIV = new CommentItemView({
      el: "#comment-list-" + (comment.topic ? 'null' : comment.parentId),
      model: comment,
      target: this.options.target,
      projectId: comment.projectId,
      taskId: comment.taskId,
      collection: collection
    }).render();
    self.commentViews.push(commentIV);
    if (comment.depth <= 1) {
      // Place the commentForm at the bottom of the list of comments for that topic.
      var commentFV = new CommentFormView({
        el: '#comment-form-' + comment.id,
        target: this.options.target,
        projectId: comment.projectId,
        taskId: comment.taskId,
        parentId: comment.id,
        collection: collection,
        depth: comment['depth']
      });
      self.commentForms.push(commentFV);
    }
    return $("#comment-list-" + (comment.topic ? 'null' : comment.parentId));
  },

  initializeCommentUIAdditions: function ($comment) {
    if (_.isUndefined($comment)) {
      this.$("time.timeago").timeago();
    } else {
      $comment.find("time.timeago").timeago();
    }
    popovers.popoverPeopleInit(".comment-user-link");
    popovers.popoverPeopleInit(".project-people-div");
  },

  topicExpand: function (e) {
    if (e.preventDefault) e.preventDefault();
    // toggle all the sublists
    var target = $($(e.currentTarget).parents('li')[0])
    $(e.currentTarget).hide();
    $(target.find('.comment-contract')[0]).show();
    $(target.children('.comment-sublist-wrapper')[0]).slideToggle();
  },

  topicContract: function (e) {
    if (e.preventDefault) e.preventDefault();
    // toggle all the sublists
    var target = $($(e.currentTarget).parents('li')[0])
    $(e.currentTarget).hide();
    $(target.find('.comment-expand')[0]).show();
    $(target.children('.comment-sublist-wrapper')[0]).slideToggle();
  },

  reply: function (e) {
    if (e.preventDefault) e.preventDefault();
    // The comment form is adjacent, not a child of the current target.
    // so find the li container, and then the form inside
    var target = $($($(e.currentTarget).parents('li.comment-item')[0]).children('.comment-form')[0]);
    if (target.data('clicked') == 'true') {
      target.hide();
      target.data('clicked', 'false');
    } else {
      target.show();
      target.data('clicked', 'true');
    }
  },

  newTopic: function (e) {
    if (e.preventDefault) e.preventDefault();

    if (this.topicForm) this.topicForm.cleanup();
    var options = {
      el: '.topic-form-wrapper',
      target: this.options.target,
      collection: this.collection,
      topic: true,
      depth: -1
    }
    options[this.options.target + 'Id'] = this.options.id;
    this.topicForm = new CommentFormView(options);
  },

  addNewCommentToDom: function (modelJson, currentTarget) {
    var self = this;
    modelJson['user'] = window.cache.currentUser;
    // increment the comment counter
    if ($(currentTarget).data('depth') >= 0) {
      var itemContainer = $(currentTarget).parents('.comment-item.border-left')[0];
      var countSpan = $(itemContainer).find('.comment-count-num')[0];
      $(countSpan).html(parseInt($(countSpan).text()) + 1);
    }
    // set the depth based on the position in the tree
    modelJson['depth'] = $(currentTarget).data('depth') + 1;
    // update the parentMap for sorting
    if (!_.isNull(modelJson.parentId)) {
      if (_.isUndefined(this.parentMap[modelJson.parentId])) {
        this.parentMap[modelJson.parentId] = [];
      }
      this.parentMap[modelJson.parentId].push(modelJson.id);
    } else {
      this.topics.push(modelJson);
    }
    // hide the empty placeholder, just in case it is still showing
    $("#comment-empty").hide();
    // render comment and UI addons
    var $comment = self.renderComment(self, modelJson, self.collection, self.parentMap);
    self.initializeCommentUIAdditions($comment);

    // Clear out the current div
    $(currentTarget).find("div[contentEditable=true]").text("");
  },

  cleanup: function () {
    for (var i in this.commentForms.reverse()) {
      if (this.commentForms[i]) { this.commentForms[i].cleanup(); }
    }
    for (var i in this.commentViews.reverse()) {
      if (this.commentViews[i]) { this.commentViews[i].cleanup(); }
    }
    if (this.topicForm) {
      this.topicForm.cleanup();
    }
    removeView(this);
  }

});

module.exports = Comment;


},{"../../../../../vendor/jquery.timeago":130,"../../../../entities/comments/comment_collection":117,"../../../../mixins/popovers":126,"../../../../mixins/utilities":128,"../../new/views/comment_form_view":40,"../templates/comment_wrapper_template.html":35,"../views/comment_item_view":36,"backbone":133,"underscore":159}],34:[function(require,module,exports){
module.exports = "<li class=\"comment-item clearfix <% if (topic) { %>border-left box-pad-lr<% } else { %>border-top<% } %>\">\n\n  <div class=\"comment-content\">\n    <% if (topic) { %>\n    <div class=\"comment-expand\">\n      <span class=\"content\">expand</span> <i class=\"fa fa-angle-double-down\"></i>\n    </div>\n    <div class=\"comment-contract\">\n      <span class=\"content\">contract</span> <i class=\"fa fa-angle-double-up\"></i>\n    </div>\n    <% } %>\n    <div class=\"comment-image\">\n      <div class=\"project-people-div\" data-userid=\"<%- userId %>\">\n        <img src=\"/api/user/photo/<%= userId %>\" alt=\"<%- user.name %>\" class=\"project-people\" />\n      </div>\n    </div>\n\n    <div class=\"comment-inner <% if (topic) { %>topic<% }%>\">\n      <span class=\"user-username\" data-userid=\"<%- userId %>\">\n        <a href=\"#\" class=\"comment-user-link\" data-userid=\"<%- userId %>\">\n          <% if (user.name) { %>\n            <%- user.name %>\n          <% } else { %>\n            <%- user.username %>\n          <% } %>\n        </a>\n      </span>\n\n      <%= valueHtml %>\n\n      <div class=\"comment-metadata\">\n        <time class=\"timeago comment-created-at\" datetime=\"<%- createdAt %>\"><%- createdAt %></time>\n        <% if (topic) { %>\n        &bull;&nbsp;\n        <span class=\"comment-count\"><i class=\"fa fa-comments\"></i> <span class=\"comment-count-num\"><%- numChildren %></span> comments</span>\n        <% } %>\n        <% if (depth == 1)  { %>\n        <% if (currentUser) { %>\n        &bull;\n        <a href=\"#reply-to-comment\" class=\"reply-to-<%= id %>\" data-depth=\"<%= depth %>\">Reply</a>\n        <% } %>\n        <% } %>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"comment-sublist-wrapper\">\n\n    <ul id=\"comment-list-<%= id %>\"></ul>\n  </div>\n\n  <div class=\"comment-form\" <% if ((depth >= 1) || (!currentUser)) { %>style=\"display: none;\"<% } %> id=\"comment-form-<%= id %>\"></div>\n\n</li>\n";

},{}],35:[function(require,module,exports){
module.exports = "<div class=\"box-pad-lr border-bottom\">\n  <h2>Discussion\n  <% if (user) { %>\n  <button class=\"btn btn-c0 btn-sm file-add new-topic\" id=\"project-topic-new\">New Topic</button>\n  <% } %>\n  </h2>\n</div>\n<div class=\"box-pad-lr box-pad-t topic-form-wrapper\"></div>\n<div class=\"comment-spinner fullwidth text-center\">\n  Loading discussion... <i class=\"fa fa-spinner fa-spin\"></i>\n</div>\n<ul id=\"comment-list-null\">\n  <li class=\"comment-item clearfix border-left box-pad-lr\" id=\"comment-empty\" style=\"display:none;\">\n    No discussion yet.  Start a topic!\n  </li>\n</ul>\n";

},{}],36:[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');
var utilities = require('../../../../mixins/utilities');
var Autolinker = require('autolinker');
var CommentItemTemplate = require('../templates/comment_item_template.html');


var CommentItemView = Backbone.View.extend({

  render: function () {
    this.model.currentUser = window.cache.currentUser;
    this.model.valueHtml = Autolinker.link(this.model.value);
    if (this.model.topic) {
      var compiledTemplate = _.template(CommentItemTemplate)(this.model);
      this.$el.append(compiledTemplate);
    } else {
      var self = this;
      if (this.model.parentId === parseInt($("#comment-list-" + this.model.parentId).attr("id").split("-")[$("#comment-list-"+this.model.parentId).attr("id").split("-").length - 1])) {
        var newTemplate = _.template(CommentItemTemplate)(this.model);
        $("#comment-list-" + this.model.parentId).append(newTemplate);
      }
    }
  },

  cleanup: function () {
    removeView(this);
  }

});

module.exports = CommentItemView;

},{"../../../../mixins/utilities":128,"../templates/comment_item_template.html":34,"autolinker":132,"backbone":133,"underscore":159}],37:[function(require,module,exports){
module.exports = "<li data-value='<%- value %>'>\n  <div class=\"ac-container\">\n    <% if (image !== null) { %>\n    <img src=\"<%- image %>\" alt=\"<%- value %>\" class=\"ac-image\"/>\n    <% } else if (target == 'project') { %>\n    <img src=\"/images/project_default.png\" alt=\"<%- value %>\" class=\"ac-image\"/>\n    <% } else { %>\n    <div class=\"ac-image\"></div>\n    <% } %>\n    <div class=\"ac-content\">\n      <div class=\"ac-title\">\n        <%- value %>\n      </div>\n      <div class=\"ac-description\">\n        <% if ((target == 'project') || (target == 'user')) { %>\n        <%= description %>\n        <% } %>\n      </div>\n    </div>\n  </div>\n</li>";

},{}],38:[function(require,module,exports){
module.exports = "<div class=\"row\">\n  <div class=\"col-lg-12 \">\n    <div class=\"alert alert-danger comment-alert-empty\">\n      You must enter text before submitting a comment.\n    </div>\n  </div>\n</div>\n<div class=\"row\">\n  <div class=\"col-lg-12 \">\n    <form action=\"\" class=\"form-inline comment-submit <% if (form.topic) { %>comment-form-topic<% } %>\" role=\"form\" data-depth=\"<%= form.depth %>\">\n      <div class=\"input-group\">\n        <div class=\"comment-input form-control input-sm\" contentEditable=\"true\"></div>\n        <span class=\"input-group-btn\">\n          <input class=\"btn btn-c2 btn-sm\" type=\"submit\" value=\"<% if (form.topic) { %> Start Topic <% } else if (form.depth == 1) { %> Reply <% } else { %>Add Comment<% } %>\" title=\"<% if (form.topic) { %> Start Topic <% } else if (form.depth == 1) { %> Reply <% } else { %>Add Comment<% } %>\">\n        </span>\n      </div>\n    </form>\n  </div>\n</div>\n";

},{}],39:[function(require,module,exports){
module.exports = "<% if (target == 'user') {\n  %><a href=\"<%- link %>\" class=\"comment-user-link\" data-userid=<%- id %>>@<%- value %></a><% }\n  else if (target == 'project') {\n  %><a href=\"<%- link %>\" class=\"link-backbone\"><%- value %></a><% }\n  else {\n  %><a href=\"<%- link %>\"><%- value %></a><% } %>";

},{}],40:[function(require,module,exports){
// This is the comment, and topic form.
// We know what to do based on a flag being passed into this view
// via the controller.  That flag is:
// this.options.topic = true


var _ = require('underscore');
var Backbone = require('backbone');
var jqCaret = require('jquery.caret/dist/jquery.caret.min');
var jqAt = require('jquery.atwho/dist/js/jquery.atwho');
var utils = require('../../../../mixins/utilities');
var marked = require('marked');
var CommentCollection = require('../../../../entities/comments/comment_collection');
var CommentFormTemplate = require('../templates/comment_form_template.html');
var CommentAcTemplate = require('../templates/comment_ac_template.html');
var CommentInlineTemplate = require('../templates/comment_inline_template.html');


var CommentFormView = Backbone.View.extend({

  events: {
    "submit .comment-submit": "post"
  },

  initialize: function (options) {
    this.options = options;
    this.render();
  },

  render: function () {
    var self = this;
    var data = { form: this.options };
    var template = _.template(CommentFormTemplate)(data);

    if (this.options.topic) {
      this.$el.prepend(template).append("<div class='clearfix'></div>");
    } else {
      this.$el.append(template);
    }

    var genTemplate = function (template, data) {
      if (!data) {
        return '';
      }
      // use the agency/office name as the description
      // if none exists, use the job title.
      // otherwise leave blank.
      if (data.target == 'user') {
        if (data.agency) {
          data.description = data.agency;
        }
        else if (data.title) {
          data.description = data.title;
        }
        else {
          data.description = '';
        }
      }
      // convert descriptions to markdown/html
      if (data.target == 'project') {
        if (data.description) {
          data.description = marked(data.description);
        }
        if (!data.coverId) {
          data.coverId = null;
        }
      }
      if (!data.image) {
        data.image = null;
      }
      // render template
      return _.template(template)(data);
    };

    this.$(".comment-input").atwho({
      at: '@',
      search_key: 'value',
      tpl: CommentAcTemplate,
      insert_tpl: CommentInlineTemplate,
      limit: 10,
      callbacks: {
        tpl_eval: genTemplate,
        sorter: function (query, items, search_key) {
          // don't sort, use the order from the server
          return items;
        },
        highlighter: function (li, query) {
          return li;
        },
        // highlighter: function (li, query) {
        //   var regexp;
        //   if (!query) {
        //     return li;
        //   }
        //   // just want to find all case insensitive matches and replace with <strong>
        //   // set up the query as a regular expression
        //   var re = new RegExp('(' + query.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1") + ')', 'ig');
        //   // parse the li string into a DOM node
        //   var liDom = $.parseHTML(li);
        //   var text = $(liDom[0]).text().replace(re, "<strong>$1</strong>");
        //   $(liDom[0]).html(text);
        //   return liDom[0];
        // },
        remote_filter: function (query, callback) {
          // get data from the server
          $.getJSON("/api/ac/inline", { q: query }, function (data) {
            _.each(data, function (d) {
              // At.js expects the name to be set for the matcher fn
              if (_.isUndefined(d.name)) {
                d.name = d.value;
              }
            });
            callback(data);
          });
        }
      }
    }).on("inserted.atwho", function(event, $li) {
      // This is a hack to hide the space after inserting an element.
      var ids = self.$("span.atwho-view-flag > span:visible");
      // insert a non-breaking space after the inserted element, but not within it
      // this allows the user to delete that space if they want to, without deleting
      // the referenced element
      ids.parent().after('&nbsp;');
      ids.hide();
    });

    return this;
  },

  post: function (e) {
    if (e.preventDefault) e.preventDefault();

    var commentHtml = this.$(".comment-input").html();
    var commentText = this.$(".comment-input").text().trim();

    // abort if the comment is empty
    if (!commentText) {
      this.$('.comment-alert-empty').show();
      return;
    }

    var parentId;

    if (this.options.parentId) {
      parentId = parseInt(this.options.parentId);
    }

    var data = {
      comment   : commentHtml,
      topic     : false
    };
    data[this.options.target + 'Id'] = this.options[this.options.target + 'Id'];

    if (this.options.topic) {
      data.topic = true;
    } else {
      data.parentId = parentId;
    }
    this.$('.comment-alert-empty').hide();

    var currentTarget = e.currentTarget;
    this.collection.trigger("comment:save", data, currentTarget);
  },

  cleanup: function () {
    removeView(this);
  }

});

module.exports = CommentFormView;

},{"../../../../entities/comments/comment_collection":117,"../../../../mixins/utilities":128,"../templates/comment_ac_template.html":37,"../templates/comment_form_template.html":38,"../templates/comment_inline_template.html":39,"backbone":133,"jquery.atwho/dist/js/jquery.atwho":153,"jquery.caret/dist/jquery.caret.min":154,"marked":155,"underscore":159}],41:[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var Popovers = require('../../../../mixins/popovers');
var EventsCollection = require('../../../../entities/events/events_collection');
var EventCollectionView = require('../views/event_collection_view');
var ModalComponent = require('../../../../components/modal');
var EventFormView = require('../../new/views/event_form_view');


var popovers = new Popovers();

EventList = Backbone.View.extend({

  el: "#event-list-wrapper",

  events: {
    'click .add-event'                : 'add',
    'click .rsvp'                     : 'toggleRSVP',
    'mouseenter .data-event-flag-true': 'buttonRSVPOn',
    'mouseleave .data-event-flag-true': 'buttonRSVPOff',
    "mouseenter .project-people-div"  : popovers.popoverPeopleOn,
    "click .project-people-div"       : popovers.popoverClick
  },

  initialize: function (settings) {
    var self = this;
    this.options = _.extend(settings, this.defaults);
    this.requestEventsCollectionData();
  },

  requestEventsCollectionData: function () {
    var self = this;
    this.collection = new EventsCollection();
    this.collection.fetch({
      url: '/api/event/findAllByProjectId/' + parseInt(this.options.projectId),
      success: function (collection) {
        self.collection = collection;
        self.renderEventCollectionView(collection);
      }
    })
  },

  renderEventCollectionView: function (collection) {
    var self = this;
    this.listenTo(this.collection, "event:save:success", function (model) {
      $('#addEvent').bind('hidden.bs.modal', function() {
        self.requestEventsCollectionData();
        if (this.eventFormView) this.eventFormView.cleanup();
        if (this.modalComponent) this.modalComponent.cleanup();
      }).modal('hide');
    });

    if (this.eventCollectionView) {
      this.eventCollectionView.cleanup();
    }

    this.eventCollectionView = new EventCollectionView({
      el: "#event-list-wrapper",
      onRender: true,
      collection: collection,
      projectId: this.options.projectId
    });

    popovers.popoverPeopleInit(".project-people-div");
  },

  add: function (e) {
    if (e.preventDefault) e.preventDefault();

    // cleanup existing views
    if (this.eventFormView) this.eventFormView.cleanup();
    if (this.modalComponent) this.modalComponent.cleanup();

    // instantiate the modal with the event form view
    this.modalComponent = new ModalComponent({
      el: "#event-modal-add",
      id: "addEvent",
      modalTitle: 'Add Event'
    }).render();

    this.eventFormView = new EventFormView({
      el: "#event-modal-add .modal-template",
      projectId: this.options.projectId,
      collection: this.collection
    }).render();
  },

  updatePeople: function (e, inc) {
    var peopleDiv = $($(e.currentTarget).parents('.event')[0]).find('.event-people')[0];
    var numDiv = $(peopleDiv).children('.event-people-number');
    var newNum = parseInt($(numDiv).html());
    if (inc) {
      newNum++
    } else {
      newNum--;
    }
    // Don't allow race conditions to set the number of people below zero
    if (newNum < 0) {
      newNum = 0;
    }
    $(numDiv).html(newNum);
    var textDiv = $(peopleDiv).children('.event-people-text')[0];
    if (newNum == 1) {
      $(textDiv).html($(textDiv).data('singular'));
    } else {
      $(textDiv).html($(textDiv).data('plural'));
    }
  },

  buttonRSVPOn: function (e) {
    $(e.currentTarget).button('hover');
  },

  buttonRSVPOff: function (e) {
    $(e.currentTarget).button('going');
  },

  toggleRSVP: function (e) {
    var self = this;
    if (e.preventDefault) e.preventDefault();
    // get the id from the parent event div
    var id = $($(e.currentTarget).parents('div.event')[0]).data('id');
    if ($(".rsvp").hasClass("data-event-flag-true") === false) {
      $(".rsvp").removeClass("data-event-flag-false");
      $(".rsvp").addClass("data-event-flag-true");
      $(e.currentTarget).button('going');
      self.updatePeople(e, true);
      $.ajax({
        url: '/api/event/attend/' + id,
        success: function (data) {
        }
      });
    } else {
      $(".rsvp").removeClass("data-event-flag-true");
      $(".rsvp").addClass("data-event-flag-false");
      $(e.currentTarget).button('rsvp');
      self.updatePeople(e, false);
      $.ajax({
        url: '/api/event/cancel/' + id,
        success: function (data) {
        }
      })
    }
  },

  cleanup: function () {
    if (this.eventCollectionView) this.eventCollectionView.cleanup();
    if (this.eventFormView) this.eventFormView.cleanup();
    if (this.modalComponent) this.modalComponent.cleanup();
    removeView(this);
  }

});

module.exports = EventList

},{"../../../../components/modal":106,"../../../../entities/events/events_collection":120,"../../../../mixins/popovers":126,"../../../../mixins/utilities":128,"../../new/views/event_form_view":45,"../views/event_collection_view":43,"backbone":133,"underscore":159}],42:[function(require,module,exports){
module.exports = "<div class=\"box-pad-lr border-bottom\">\n  <h2>\n    Upcoming Events\n    <% if (user) { %>\n    <a href=\"#addEvent\" class=\"btn btn-c0 btn-sm file-add add-event\" data-toggle=\"modal\" data-backdrop=\"static\">Add Event</a>\n    <% } %>\n  </h2>\n</div>\n\n<div id=\"event-modal-add\"></div>\n\n<div class=\"task-scroll\">\n\n  <% if (events.length == 0) { %>\n\n  <div class=\"event border-left\" data-id=\"null\">\n    <div class=\"event-title\">\n      No events scheduled.\n    </div>\n  </div>\n\n  <% } else { %>\n\n  <% _.each(events, function (event, iterator) { %>\n  <div class=\"event border-left\" data-id=\"<%= event.id %>\">\n    <% if (user) { %>\n    <div class=\"event-button pull-right\">\n      <button class=\"btn btn-c2 btn-sm rsvp data-event-flag-<%= event.rsvp %>\" data-going-text=\"<i class='fa fa-check'></i> I'm going\" data-rsvp-text=\"RSVP\" data-hover-text=\"Cancel RSVP\"><% if (event.rsvp) { %><i class='fa fa-check'></i> I'm going<% } else { %>RSVP<% } %></button>\n    </div>\n    <% } %>\n    <div class=\"event-title\">\n      <%- event.title %>\n    </div>\n    <div class=\"event-description\">\n      <%- event.description %>\n    </div>\n    <div class=\"event-tag\">\n      <i class=\"fa fa-calendar\"></i>\n      <span class=\"box-icon-text\">\n      <!-- day -->\n      <% var st = new Date(event.start); var et = new Date(event.end); %>\n      <%= st.toLocaleDateString() %>\n      <% if (st.toLocaleDateString() != et.toLocaleDateString()) { %>\n      - <%= et.toLocaleDateString() %>\n      <% } %>\n      <!-- time -->\n      <%= st.toLocaleTimeString() %>\n      <% if (st.toLocaleDateString() == et.toLocaleDateString()) { %>\n      - <%= et.toLocaleTimeString() %>\n      <% } %>\n      </span>\n    </div>\n    <div class=\"event-tag\">\n      <span class=\"fa fa-map-marker\"></span>\n      <span class=\"box-icon-text\">\n      <%= event.location %>\n      </span>\n    </div>\n    <div class=\"event-tag\">\n      <span class=\"event-icon-center\"><i class=\"fa fa-male\"></i></span>\n      <span class=\"box-icon-text event-people\">\n        <span class=\"event-people-number\"><%= event.rsvps.length %></span>\n        <span class=\"event-people-text\" data-plural=\"people\" data-singular=\"person\">\n        <% if (event.rsvps.length == 1) { %>\n          person\n        <% } else { %>\n          people\n        <% } %>\n        </span>\n        going\n      </span>\n    </div>\n  </div>\n  <% }); %>\n\n  <% } %>\n</div>\n";

},{}],43:[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var EventListTemplate = require('../templates/event_collection_view_template.html');


var EventCollectionView = Backbone.View.extend({

  el: "#event-list-wrapper",

  initialize: function (options) {
    this.options = options;
    this.render();
  },

  render: function () {
    var eventsJSON = {
      events: this.options.collection.toJSON(),
      projectId: this.options.projectId,
      user: window.cache.currentUser
    }

    this.compiledTemplate = _.template(EventListTemplate)(eventsJSON);
    this.$el.html(this.compiledTemplate);

    return this;
  },

  cleanup: function () {
    removeView(this);
  }

});

module.exports = EventCollectionView;

},{"../../../../mixins/utilities":128,"../templates/event_collection_view_template.html":42,"backbone":133,"underscore":159}],44:[function(require,module,exports){
module.exports = "<form id=\"event-form\" class=\"form-horizontal\" style=\"display: block;\">\n\n  <div class=\"modal-body\">\n\n    <fieldset>\n\n      <div class=\"form-group\">\n        <label for=\"event-title\" class=\"col-lg-2 control-label\">Title</label>\n        <div class=\"col-lg-10\">\n          <input id=\"event-title\" class=\"form-control\" type=\"text\" data-validate=\"empty,count100\">\n          <span class=\"help-block error-empty\" style=\"display:none;\">You must enter an event title.</span>\n          <span class=\"help-block error-count100\" style=\"display:none;\">The event title must be less than 100 characters.</span>\n        </div>\n      </div>\n\n      <div class=\"form-group\">\n        <label for=\"event-description\" class=\"col-lg-2 control-label\">Description</label>\n        <div class=\"col-lg-10\">\n          <textarea id=\"event-description\" class=\"form-control\" type=\"text\" data-validate=\"empty,count250\" rows=\"3\"></textarea>\n          <span class=\"help-block error-empty\" style=\"display:none;\">You must enter an event description.</span>\n          <span class=\"help-block error-count100\" style=\"display:none;\">The event description must be less than 250 characters.</span>\n        </div>\n      </div>\n\n      <div class=\"form-group\">\n        <label for=\"event-start\" class=\"col-md-2 control-label\">Time</label>\n        <div class=\"col-md-2 padding-right-none\">\n          <input id=\"event-start\" class=\"form-control fullwidth\" type=\"text\">\n        </div>\n        <div class=\"col-md-2 padding-none\" id=\"div-event-start-time\">\n          <input id=\"event-start-time\" class=\"form-control fullwidth timepicker\" type=\"text\">\n        </div>\n        <div class=\"col-md-1 control-label\">\n          to\n        </div>\n        <div class=\"col-md-2 padding-none\" id=\"div-event-end-time\">\n          <input id=\"event-end-time\" class=\"form-control fullwidth timepicker\" type=\"text\">\n        </div>\n        <div class=\"col-md-2 padding-none\">\n          <input id=\"event-end\" class=\"form-control fullwidth\" type=\"text\">\n        </div>\n      </div>\n\n      <div class=\"form-group\" style=\"margin-top: -10px;\">\n        <div class=\"col-md-10 col-md-offset-2 event-timezone\">\n          Your time zone is set to <span class=\"timezone\">None</span>.\n        </div>\n      </div>\n\n      <div class=\"form-group\">\n        <label for=\"event-location\" class=\"col-lg-2 control-label\">Location</label>\n        <div class=\"col-lg-10\">\n          <input id=\"event-location\" class=\"form-control\" type=\"text\" data-validate=\"empty\">\n          <span class=\"help-block error-empty\" style=\"display:none;\">You must enter an event location.</span>\n        </div>\n      </div>\n\n    </fieldset>\n  </div>\n  <div class=\"modal-footer\">\n    <button type=\"button\" class=\"btn btn-c0 wizard-cancel\" data-dismiss=\"modal\">Cancel</button>\n    <button class=\"btn btn-c2\" type=\"submit\">Add Event</button>\n  </div>\n\n</form>\n";

},{}],45:[function(require,module,exports){

var Bootstrap = require('bootstrap');
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var DatePicker = require('bootstrap-datetimepicker/src/js/bootstrap-datetimepicker');
var TimePicker = require('timepicker/jquery.timepicker');
var EventsCollection = require('../../../../entities/events/events_collection');
var EventFormTemplate = require('../templates/event_form_template.html');


var EventFormView = Backbone.View.extend({

  el: "#event-list-wrapper",

  events: {
    // field validation
    "blur #event-title"       : "v",
    "blur #event-description" : "v",
    "blur #event-location"    : "v",
    // form submission
    "submit #event-form"      : "post"
  },

  initialize: function (options) {
    this.options = options;
  },

  initializeTimeZone: function () {
    var offset = (new Date()).getTimezoneOffset();
    var timezones = {
        '-12': 'Pacific/Kwajalein',
        '-11': 'Pacific/Samoa',
        '-10': 'Pacific/Honolulu',
        '-9': 'America/Juneau',
        '-8': 'America/Los Angeles',
        '-7': 'America/Denver',
        '-6': 'America/Mexico City',
        '-5': 'America/New York',
        '-4': 'America/Caracas',
        '-3.5': 'America/St Johns',
        '-3': 'America/Argentina/Buenos Aires',
        '-2': 'Atlantic/Azores',
        '-1': 'Atlantic/Azores',
        '0': 'Europe/London',
        '1': 'Europe/Paris',
        '2': 'Europe/Helsinki',
        '3': 'Europe/Moscow',
        '3.5': 'Asia/Tehran',
        '4': 'Asia/Baku',
        '4.5': 'Asia/Kabul',
        '5': 'Asia/Karachi',
        '5.5': 'Asia/Calcutta',
        '6': 'Asia/Colombo',
        '7': 'Asia/Bangkok',
        '8': 'Asia/Singapore',
        '9': 'Asia/Tokyo',
        '9.5': 'Australia/Darwin',
        '10': 'Pacific/Guam',
        '11': 'Asia/Magadan',
        '12': 'Asia/Kamchatka'
    };
    // create a timezone string for display
    var tz = timezones[-offset / 60];
    tz += ' (';
    if (offset <= 0) {
      tz += '+';
    }
    tz += (-offset/60) + ':00)';
    $('.timezone').html(tz);

    // set input pickers for time
    $('#event-start-time').timepicker({
      selectOnBlur: true,
      appendTo: '#div-event-start-time'
    });
    $('#event-end-time').timepicker({
      selectOnBlur: true,
      showDuration: true,
      durationTime: function() {
        return ($('#event-start-time').val());
      },
      appendTo: '#div-event-end-time'
    });
    // get the start time by rounding the current time to the nearest 30 minutes
    var coeff = 1000 * 60 * 30;
    var startTime = new Date();  //or use any other date
    startTime = new Date(Math.ceil(startTime.getTime() / coeff) * coeff)
    // the initial end time should be 1 hour after the initial start time
    var endTime = new Date(startTime.getTime() + 1000*60*60);
    $('#event-start-time').timepicker('setTime', startTime);
    $('#event-end-time').timepicker('setTime', endTime);

    // Initialize the date pickers
    var startDate = new Date();
    $('#event-start').datetimepicker({
      pickDate: true,
      pickTime: false,
      startDate: startDate
    });
    $('#event-end').datetimepicker({
      pickDate: true,
      pickTime: false,
      startDate: startDate
    });
    // Set the initial date to now (today)
    $('#event-start').data("DateTimePicker").setDate(startDate);
    $('#event-end').data("DateTimePicker").setDate(startDate);

    // When the start date changes,
    // set the end date to be at least the start date
    $('#event-start').on("change.dp",function (e) {
      $('#event-end').data("DateTimePicker").setStartDate(e.date);
      var diff = $('#event-end').data("DateTimePicker").getDate().unix() - e.date.unix();
      if (diff < 0) {
        $('#event-end').data("DateTimePicker").setDate(e.date);
      }
      $(e.currentTarget).blur();
    });
    // When the end date changes,
    // Enable/disable duration in the timepicker based on whether the
    // start and end dates match
    $('#event-end').on("change.dp",function (e) {
      var diff = e.date.unix() - $('#event-start').data("DateTimePicker").getDate().unix();
      if (diff === 0) {
        $('#event-end-time').timepicker('option', 'showDuration', true);
      } else {
        $('#event-end-time').timepicker('option', 'showDuration', false);
      }
      $(e.currentTarget).blur();
    });
  },

  render: function () {
    var template = _.template(EventFormTemplate);
    this.$el.html(template);
    this.initializeTimeZone();
  },

  v: function (e) {
    return validate(e);
  },

  post: function (e) {
    if (e.preventDefault) e.preventDefault();

    // validate the fields; if any is not validated, abort form submission
    var validateIds = ['#event-title', '#event-description', '#event-location'];
    var abort = false;
    for (i in validateIds) {
      var iAbort = validate({ currentTarget: validateIds[i] });
      abort = abort || iAbort;
    }
    if (abort) {
      return;
    }

    // process the form; create time objects
    var start = $('#event-start').data("DateTimePicker").getDate().clone().toDate();
    var end = $('#event-start').data("DateTimePicker").getDate().clone().toDate();
    start = $('#event-start-time').timepicker('getTime', start);
    end = $('#event-end-time').timepicker('getTime', end);

    var data = {
      title       : $("#event-title").val(),
      description : $("#event-description").val(),
      start       : start.toISOString(),
      end         : end.toISOString(),
      location    : $("#event-location").val(),
      projectId   : this.options.projectId
    };

    this.collection.trigger("event:save", data);
  },

  cleanup: function () {
    removeView(this);
  }

});

module.exports = EventFormView;

},{"../../../../entities/events/events_collection":120,"../../../../mixins/utilities":128,"../templates/event_form_template.html":44,"backbone":133,"bootstrap":138,"bootstrap-datetimepicker/src/js/bootstrap-datetimepicker":137,"timepicker/jquery.timepicker":158,"underscore":159}],46:[function(require,module,exports){
module.exports = "<footer class=\"container\">\n  <div class=\"row\">\n    <div class=\"col-md-12\">\n      <a href=\"https://github.com/18F/midas\"><i class=\"fa fa-github\"></i> powered by midas</a>\n      |\n      version <%- version.version %> (<a href=\"https://github.com/18F/midas/commit/<%- version.gitLong %>\"><%- version.gitShort %></a>)\n      <% if (login.terms.enabled === true) { %>\n      |\n      <a href=\"<%= login.terms.link %>\"><%= login.terms.name %></a>\n      <% } %>\n      |\n      Locations provided by <a href=\"http://www.geonames.org/\">GeoNames</a>.\n    </div>\n  </div>\n</footer>\n";

},{}],47:[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../mixins/utilities');
var Login = require('../../../config/login.json');
var FooterTemplate = require('../templates/footer_template.html');


var FooterView = Backbone.View.extend({

  events: {
  },

  render: function () {
    var self = this;
    var data = {
      version: version,
      login: Login
    };
    var compiledTemplate = _.template(FooterTemplate)(data);
    this.$el.html(compiledTemplate);

    function resizeElements() {
      headerHeight = $('.navbar').height();
      footerHeight = $('footer').height();
      if (($(document.body).height() + footerHeight) < $(window).height()) {
        self.$el.addClass('navbar-fixed-bottom');
      } else {
        self.$el.removeClass('navbar-fixed-bottom');
      }
    }
    resizeElements();
    $(".container").bind("DOMSubtreeModified", resizeElements);
  },

  cleanup: function () {
    removeView(this);
  }

});

module.exports = FooterView;


},{"../../../config/login.json":114,"../../../mixins/utilities":128,"../templates/footer_template.html":46,"backbone":133,"underscore":159}],48:[function(require,module,exports){

var _ = require('underscore');
var async = require('async');
var Backbone = require('backbone');
var utils = require('../../../mixins/utilities');
var BaseController = require('../../../base/base_controller');
var HomeView = require('../views/home_view');


Home = {};

Home.Controller = BaseController.extend({

  events: {
  },

  // The initialize method is mainly used for event bindings (for efficiency)
  initialize: function (options) {
    var self = this;
    this.homeView = new HomeView().render();
  },

  // ---------------------
  //= Utility Methods
  // ---------------------
  cleanup: function() {
    if (this.homeView) this.homeView.cleanup();
    removeView(this);
  }

});

module.exports = Home.Controller;


},{"../../../base/base_controller":101,"../../../mixins/utilities":128,"../views/home_view":50,"async":131,"backbone":133,"underscore":159}],49:[function(require,module,exports){
module.exports = "  <div class=\"container-fluid padding-left-none padding-right-none\" id=\"home\">\n    <div class=\"splash-wrap\" id=\"splash1\">\n      <div class=\"splash-center\">\n      <h1 class=\"text-center\" data-i18n=\"home.headline\">Hassle Free Collaboration</h1>\n      <p class=\"lead text-center\" data-i18n=\"home.subhead\">Work with other federal employees on projects you are passionate about.</p>\n      <div class=\"text-center\"><a class=\"login\" href=\"/auth\"><button class=\"btn btn-midas\" id=\"center\" data-i18n=\"home.callToAction\">Get Started Today</button></a></div>\n      <!--div class=\"text-center text-on-dark text-muted\"><a href=\"#\">Learn More</a></div-->\n    </div><!-- /#splash -->\n    </div><!-- /.splash-wrap -->\n\n  <div class=\"inline-block-center\">\n    <div class=\"value-prop\">\n        <div class=\"icon\"><i class=\"fa fa-comments\"></i></div> <!-- icon -->\n        <div class=\"text\">Make Connections</div>\n    </div>\n    <div class=\"value-prop\">\n        <div class=\"icon\"><i class=\"fa fa-cogs\"></i></div> <!-- icon -->\n        <div class=\"text\">Build Skills</div>\n    </div>\n    <div class=\"value-prop\">\n        <div class=\"icon\"><i class=\"fa fa-line-chart\"></i></div> <!-- icon -->\n        <div class=\"text\">Make a Difference</div>\n    </div>\n  </div>\n  <div class=\"text-center\"><a class=\"login\" href=\"/auth\"><button class=\"btn btn-midas\" id=\"center\" data-i18n=\"home.callToAction\">Get Started Today</button></a></div>\n\n\n  </div><!-- /.container-fluid-->\n";

},{}],50:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var async = require('async');
var utils = require('../../../mixins/utilities');
var UIConfig = require('../../../config/ui.json');
var Login = require('../../../config/login.json');
var LoginController = require('../../login/controllers/login_controller');
var HomeTemplate = require('../templates/home_view_template.html');


var HomeView = Backbone.View.extend({

  el: "#container",

  events: {
    'click .login'          : 'loginClick'
  },

  initialize: function (options) {
    this.options = options;
    this.listenTo(window.cache.userEvents, "user:login:success", function (user) {
      Backbone.history.navigate(UIConfig.home.logged_in_path, { trigger: true });
    });
  },

  render: function () {
    var compiledTemplate;
    var data = {
      hostname: window.location.hostname,
      user: window.cache.currentUser || {},
    };

    this.$el.addClass('home');
    compiledTemplate = _.template(HomeTemplate)(data);
    this.$el.html(compiledTemplate);
    this.$el.i18n();

    return this;
  },

  loginClick: function (e) {
    if (e.preventDefault) e.preventDefault();
    if (window.cache.currentUser) {
      // we're already logged in
      Backbone.history.navigate(UIConfig.home.logged_in_path, { trigger: true });
    } else {
      this.login();
    }
  },

  login: function (message) {
    if (this.loginController) {
      this.loginController.cleanup();
    }
    this.loginController = new LoginController({
      el: '#login-wrapper',
      message: message
    });
  },

  cleanup: function () {
    this.$el.removeClass('home');
    removeView(this);
  },
});

module.exports = HomeView;

},{"../../../config/login.json":114,"../../../config/ui.json":116,"../../../mixins/utilities":128,"../../login/controllers/login_controller":51,"../templates/home_view_template.html":49,"async":131,"backbone":133,"underscore":159}],51:[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');
var Bootstrap = require('bootstrap');
var utils = require('../../../mixins/utilities');
var BaseController = require('../../../base/base_controller');
var LoginView = require('../views/login_view');
var login = require('../../../config/login.json');
var ModalComponent = require('../../../components/modal');


Login = BaseController.extend({

  events: {
    "click #register-cancel"   : "showLogin",
    "click #login-register"    : "showRegister",
    "click #forgot-done-cancel": "showLogin",
    "click #forgot-cancel"     : "showLogin",
    "click #forgot-password"   : "showForgot"
  },

  initialize: function ( options ) {
    var self = this;
    this.options = options;
    this.initializeView();
  },

  initializeView: function () {
    var self = this;
    if (this.loginView) {
      this.loginView.cleanup();
      this.modalComponent.cleanup();
    }

    // initialize the modal
    if (!_.isUndefined(this.options.message)) {
      var disableClose = this.options.message.disableClose || false;
    }
    this.modalComponent = new ModalComponent({
      el: this.el,
      id: "login",
      modalTitle: "Login or Register",
      disableClose: disableClose
    }).render();

    // put the login view inside the modal
    this.loginView = new LoginView({
      el: ".modal-template",
      login: login,
      message: this.options.message
    }).render();
    this.$("#registration-view").hide();
    this.$("#forgot-view").hide();
    this.$("#forgot-done-view").hide();
    $("#login").modal('show');

    self.listenTo(window.cache.userEvents, "user:login", function (user) {
      // hide the modal
      self.stopListening(window.cache.userEvents);
      // window.cache.userEvents.stopListening();
      $('#login').bind('hidden.bs.modal', function() {
        // reload the page after login
        Backbone.history.loadUrl();
        window.cache.userEvents.trigger("user:login:success", user);
        self.cleanup();
      }).modal('hide');
    });
  },

  showRegister: function (e) {
    if (e.preventDefault) e.preventDefault();
    this.$("#login-view").hide();
    this.$("#login-footer").hide();
    this.$("#registration-view").show();
    this.$("#registration-footer").show();
    this.$("#forgot-view").hide();
    this.$("#forgot-footer").hide();
    this.$("#forgot-done-view").hide();
    this.$("#forgot-done-footer").hide();
  },

  showLogin: function (e) {
    if (e.preventDefault) e.preventDefault();
    this.$("#login-view").show();
    this.$("#login-footer").show();
    this.$("#registration-view").hide();
    this.$("#registration-footer").hide();
    this.$("#forgot-view").hide();
    this.$("#forgot-footer").hide();
    this.$("#forgot-done-view").hide();
    this.$("#forgot-done-footer").hide();
  },

  showForgot: function (e) {
    if (e.preventDefault) e.preventDefault();
    this.$("#forgot-view").show();
    this.$("#forgot-footer").show();
    this.$("#registration-view").hide();
    this.$("#registration-footer").hide();
    this.$("#login-view").hide();
    this.$("#login-footer").hide();
    this.$("#forgot-done-view").hide();
    this.$("#forgot-done-footer").hide();
  },

  // ---------------------
  //= UTILITY METHODS
  // ---------------------
  cleanup: function() {
    // don't do anything
    if (this.loginView) { this.loginView.cleanup(); }
    if (this.modalComponent) { this.modalComponent.cleanup(); }
    removeView(this);
  }

});

module.exports = Login;

},{"../../../base/base_controller":101,"../../../components/modal":106,"../../../config/login.json":114,"../../../mixins/utilities":128,"../views/login_view":55,"backbone":133,"bootstrap":138,"underscore":159}],52:[function(require,module,exports){
module.exports = "<div class=\"row\">\n  <div class=\"col-sm-9 sm-nopadding\">\n    <div class=\"form-group\">\n      <label for=\"rpassword\" class=\"control-label\">Password</label>\n      <input type=\"password\" class=\"form-control validate\" id=\"rpassword\" name=\"password\" placeholder=\"Password\" data-validate=\"empty,password,confirm\"/>\n      <span class=\"help-block error-empty\" style=\"display:none;\">You must enter a password.</span>\n      <span class=\"help-block error-password\" style=\"display:none;\">Your password does not meet password rules.</span>\n    </div>\n    <div class=\"form-group\">\n      <label for=\"rpassword-confirm\" class=\"control-label\">Confirm Password</label>\n      <input type=\"password\" class=\"form-control\" id=\"rpassword-confirm\" placeholder=\"Confirm Password\"/>\n      <span class=\"help-block error-confirm\" style=\"display:none;\">Your password does not match the password entered above.</span>\n    </div>\n  </div>\n  <div class=\"col-sm-3 nopadding\">\n    <div class=\"password-rules-title\">\n      Must Contain:\n    </div>\n    <ul class=\"password-rules\">\n      <li class=\"success rule-username\"><i class=\"fa fa-check\"></i> Not your email</li>\n      <li class=\"error rule-username\"><i class=\"fa fa-remove\"></i> Not your email</li>\n      <li class=\"success rule-length\"><i class=\"fa fa-check\"></i> 8 characters or more</li>\n      <li class=\"error rule-length\"><i class=\"fa fa-remove\"></i> 8 characters or more</li>\n      <li class=\"success rule-upper\"><i class=\"fa fa-check\"></i> Uppercase</li>\n      <li class=\"error rule-upper\"><i class=\"fa fa-remove\"></i> Uppercase</li>\n      <li class=\"success rule-lower\"><i class=\"fa fa-check\"></i> Lowercase</li>\n      <li class=\"error rule-lower\"><i class=\"fa fa-remove\"></i> Lowercase</li>\n      <li class=\"success rule-number\"><i class=\"fa fa-check\"></i> A Number</li>\n      <li class=\"error rule-number\"><i class=\"fa fa-remove\"></i> A Number</li>\n      <li class=\"success rule-symbol\"><i class=\"fa fa-check\"></i> A Symbol</li>\n      <li class=\"error rule-symbol\"><i class=\"fa fa-remove\"></i> A Symbol</li>\n    </ul>\n  </div>\n</div>\n";

},{}],53:[function(require,module,exports){
module.exports = "<form role=\"form\" id=\"login-password-form\">\n<div class=\"modal-body padding-bottom-none\" id=\"login-view\">\n\n  <% if (message && !_.isUndefined(message.message)) { %>\n  <div class=\"alert alert-warning\">\n    <%= message.message %>\n  </div>\n  <% } %>\n\n  <% if (login.oauth.length > 0) { %>\n  <div class=\"login-oauth\">Login with\n  <% _.each(login.oauth, function (e) { %>\n  <div class=\"row\">\n    <div class=\"col-sm-offset-3 col-sm-6\">\n      <div class=\"login-option\">\n        <a href=\"<%= login.config[e].endpoint %>\" class=\"btn btn-c0 btn-login\">\n          <img src=\"<%= login.config[e].image %>\" alt=\"<%= login.config[e].name %>\" class=\"btn-login-responsive\"/>\n        </a>\n      </div>\n    </div>\n  </div>\n  <% }); %>\n  </div>\n  <% } %>\n\n  <% if (login.local.enabled === true) { %>\n    <% if (login.oauth.length > 0) { %>\n    <hr/>\n    <% } %>\n    <div class=\"alert alert-danger\" id=\"login-error\" style=\"display:none;\"></div>\n      <div class=\"form-group\">\n        <label for=\"username\" class=\"control-label\" data-i18n=\"loginModal.emailAddress\">Email Address</label>\n        <input type=\"email\" class=\"form-control\" id=\"username\" name=\"username\" placeholder=\"Email Address\"/>\n      </div>\n      <div class=\"form-group margin-bottom-none\">\n        <label for=\"password\" class=\"control-label\">Password</label>\n        <input type=\"password\" class=\"form-control\" id=\"password\" name=\"password\" placeholder=\"Password\"/>\n        <a href=\"#forgot-password\" class=\"forgot-password\" id=\"forgot-password\">Forgot your password?</a>\n      </div>\n    </div>\n    <div class=\"modal-footer modal-footer-grey\" id=\"login-footer\">\n      <div class=\"row\">\n        <div class=\"col-md-12\">\n          <button type=\"submit\" class=\"btn btn-c2 pull-right\">Sign in</button>\n          <p class=\"pull-left login-register-label\" id=\"login-register-label\">\n            Need an account? \n            <a href=\"#login-register\" id=\"login-register\">\n              <strong>Sign up now</strong>\n            </a>\n          </p>\n        </div>\n      </div>\n    </div>\n  <% } else { %>\n  </div>\n  <% } %>\n</form>\n\n<form role=\"form\" id=\"registration-form\">\n<div class=\"modal-body padding-bottom-none\" id=\"registration-view\">\n    <h2>Create a New Account</h2>\n\n    <div class=\"row\">\n      <div class=\"col-sm-12\">\n        <div class=\"form-group\">\n          <label for=\"rname\" class=\"control-label\" data-i18n=\"loginModal.name\">Name</label>\n          <input type=\"text\" class=\"form-control validate\" id=\"rname\" name=\"rname\" placeholder=\"Full Name\" data-validate=\"empty\">\n          <span class=\"help-block error-empty\" style=\"display:none;\">Please enter your full name.</span>\n        </div>\n      </div>\n      <div class=\"col-sm-12\">\n        <div class=\"form-group\">\n          <label for=\"rusername\" class=\"control-label\" data-i18n=\"loginModal.emailAddress\">Email Address</label>\n          <div class=\"input-group\">\n            <input type=\"text\" class=\"form-control validate\" id=\"rusername\" name=\"username\" placeholder=\"Email Address\" data-validate=\"button\"/>\n            <span class=\"input-group-btn\">\n              <a href=\"#\" class=\"btn btn-danger\" id=\"rusername-button\" tabindex=\"-1\">\n                <i id=\"rusername-check\" class=\"fa fa-times\"></i>\n              </a>\n            </span>\n          </div>\n          <span class=\"help-block error-button\" style=\"display:none;\">The email address is not valid or is already in use.</span>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"password-view\">\n    </div>\n\n    <div class=\"checkbox\">\n      <label>\n        <% if (login.terms.enabled === true) { %>\n        <input type=\"checkbox\" id=\"rterms\" class=\"validate\" data-validate=\"checked\"> <span data-i18n=\"loginModal.tosCheckbox\">Yes, I agree to the </span><a href=\"<%= login.terms.link %>\"><%= login.terms.name %></a>.\n        <span class=\"help-block error-checked\" style=\"display:none;\">You must accept the <%= login.terms.name %> to register.</span>\n        <% } %>\n      </label>\n    </div>\n\n    <div class=\"form-group margin-bottom-none\">\n      <div class=\"row\">\n        <div class=\"col-sm-12\">\n          <div class=\"alert alert-danger\" id=\"registration-error\" style=\"display:none;\"></div>\n        </div>\n      </div>\n    </div>\n</div>\n<div class=\"modal-footer modal-footer-grey\" id=\"registration-footer\" style=\"display:none;\">\n  <div class=\"row\">\n    <div class=\"col-sm-12\">\n      <div class=\"pull-right\">\n        <button type=\"button\" id=\"register-cancel\" class=\"btn btn-c0\">Cancel</button>\n        <button type=\"submit\" class=\"btn btn-c2\">Register</button>\n      </div>\n    </div>\n  </div>\n</div>\n</form>\n\n<form role=\"form\" id=\"forgot-form\">\n<div class=\"modal-body padding-bottom-none\" id=\"forgot-view\">\n    <h2>Reset Your Password</h2>\n\n    <p>Please enter your email address and we'll send you a link to reset your password</p>\n\n    <div class=\"form-group\">\n      <label for=\"fusername\" class=\"control-label\">Email Address</label>\n      <input type=\"text\" class=\"form-control validate\" id=\"fusername\" name=\"username\" placeholder=\"Email Address\" data-validate=\"button\"/>\n    </div>\n    <div class=\"form-group margin-bottom-none\">\n      <div class=\"row\">\n        <div class=\"col-sm-12\">\n          <div class=\"alert alert-danger\" id=\"forgot-error\" style=\"display:none;\"></div>\n        </div>\n      </div>\n    </div>\n</div>\n<div class=\"modal-footer modal-footer-grey\" id=\"forgot-footer\" style=\"display:none;\">\n  <div class=\"row\">\n    <div class=\"col-sm-12\">\n      <div class=\"pull-right\">\n        <button type=\"button\" id=\"forgot-cancel\" class=\"btn btn-c0\">Cancel</button>\n        <button type=\"submit\" class=\"btn btn-c2\">Reset Password</button>\n      </div>\n    </div>\n  </div>\n</div>\n</form>\n\n<div class=\"modal-body padding-bottom-none\" id=\"forgot-done-view\">\n    <h2>Reset Your Password</h2>\n\n    <p>\n      Thank you! An email will arrive shortly with a link to reset your password.\n    </p>\n    <p>\n      If you don't receive an email shortly, check your spam folder.\n    </p>\n</div>\n<div class=\"modal-footer modal-footer-grey\" id=\"forgot-done-footer\" style=\"display:none;\">\n  <div class=\"row\">\n    <div class=\"col-sm-12\">\n      <div class=\"pull-right\">\n        <button type=\"button\" id=\"forgot-done-cancel\" class=\"btn btn-c2\">Return to Login</button>\n      </div>\n    </div>\n  </div>\n</div>";

},{}],54:[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../mixins/utilities');
var LoginPasswordTemplate = require('../templates/login_password_template.html');


var LoginPasswordView = Backbone.View.extend({

  initialize: function (options) {
    this.options = options;
  },

  render: function () {
    var template = _.template(LoginPasswordTemplate);
    this.$el.html(template);
    return this;
  },

  cleanup: function () {
    removeView(this);
  },
});

module.exports = LoginPasswordView;


},{"../../../mixins/utilities":128,"../templates/login_password_template.html":52,"backbone":133,"underscore":159}],55:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../mixins/utilities');
var LoginPasswordView = require('./login_password_view');
var LoginTemplate = require('../templates/login_template.html');
var ModalComponent = require('../../../components/modal');


var LoginView = Backbone.View.extend({

  events: {
    'click .oauth-link'              : 'link',
    'keyup #rname'                   : 'checkName',
    'change #rname'                  : 'checkName',
    'blur #rname'                    : 'checkName',
    'keyup #rusername'               : 'checkUsername',
    'change #rusername'              : 'checkUsername',
    'click #rusername-button'        : 'clickUsername',
    'keyup #rpassword'               : 'checkPassword',
    'blur #rpassword'                : 'checkPassword',
    'keyup #rpassword-confirm'       : 'checkPasswordConfirm',
    'blur #rpassword-confirm'        : 'checkPasswordConfirm',
    'submit #login-password-form'    : 'submitLogin',
    'submit #registration-form'      : 'submitRegister',
    'submit #forgot-form'            : 'submitForgot'
  },

  initialize: function (options) {
    this.options = options;
  },

  render: function () {
    var self = this;
    var data = {
      login: this.options.login,
      message: this.options.message
    };
    var template = _.template(LoginTemplate)(data);
    this.$el.html(template);
    this.$el.i18n();
    this.loginPasswordView = new LoginPasswordView({
      el: this.$(".password-view")
    }).render();
    setTimeout(function () {
      self.$("#username").focus();
    }, 500);
    return this;
  },

  link: function (e) {
    if (e.preventDefault) e.preventDefault();
    var link = $(e.currentTarget).attr('href');
    window.location.href = link;
  },

  v: function (e) {
    return validate(e);
  },

  submitLogin: function (e) {
    var self = this;
    if (e.preventDefault) e.preventDefault();
    var data = {
      username: this.$("#username").val(),
      password: this.$("#password").val(),
      json: true
    };
    $.ajax({
      url: '/api/auth/local',
      type: 'POST',
      data: data
    }).done(function (success) {
      // Set the user object and trigger the user login event
      window.cache.currentUser = success;
      window.cache.userEvents.trigger("user:login", success);
    }).fail(function (error) {
      var d = JSON.parse(error.responseText);
      self.$("#login-error").html(d.message);
      self.$("#login-error").show();
    });
  },

  submitRegister: function (e) {
    var self = this,
        $submitButton = self.$('#registration-form [type="submit"]');
    if (e.preventDefault) e.preventDefault();

    $submitButton.prop('disabled', true);
    // validate input fields
    var validateIds = ['#rname', '#rusername', '#rpassword'];
    // Only validate terms & conditions if it is enabled
    if (this.options.login.terms.enabled === true) {
      validateIds.push('#rterms');
    }
    var abort = false;
    for (i in validateIds) {
      var iAbort = validate({ currentTarget: validateIds[i] });
      abort = abort || iAbort;
    }
    var passwordSuccess = this.checkPassword();
    var parent = $(this.$("#rpassword").parents('.form-group')[0]);
    if (passwordSuccess !== true) {
      parent.addClass('has-error');
      $(parent.find('.error-password')[0]).show();
    } else {
      $(parent.find('.error-password')[0]).hide();
    }
    var passwordConfirmSuccess = this.checkPasswordConfirm();
    var passwordConfirmParent = $(this.$("#rpassword-confirm").parents('.form-group')[0]);
    if (passwordConfirmSuccess !== true) {
      passwordConfirmParent.addClass('has-error');
      $(passwordConfirmParent.find('.error-password')[0]).show();
    } else {
      $(passwordConfirmParent.find('.error-password')[0]).hide();
    }
    if (abort === true || passwordSuccess !== true || passwordConfirmSuccess !== true) {
      $submitButton.prop('disabled', false);
      return;
    }

    // Create a data object with the required fields
    var data = {
      name: this.$("#rname").val(),
      username: this.$("#rusername").val(),
      password: this.$("#rpassword").val(),
      json: true
    };
    // Add in additional, optional fields
    if (this.options.login.terms.enabled === true) {
      data['terms'] = (this.$("#rterms").val() == "on");
    }
    // Post the registration request to the server
    $.ajax({
      url: '/api/auth/register',
      type: 'POST',
      data: data
    }).done(function (success) {
      // Set the user object and trigger the user login event
      window.cache.currentUser = success;
      window.cache.userEvents.trigger("user:login", success);
    }).fail(function (error) {
      var d = JSON.parse(error.responseText);
      self.$("#registration-error").html(d.message);
      self.$("#registration-error").show();
      $submitButton.prop('disabled', false);
    });
  },

  submitForgot: function (e) {
    var self = this;
    if (e.preventDefault) e.preventDefault();
    var data = {
      username: this.$("#fusername").val()
    };
    // Post the registration request to the server
    $.ajax({
      url: '/api/auth/forgot',
      type: 'POST',
      data: data
    }).done(function (success) {
      // Set the user object and trigger the user login event
      self.$("#forgot-view").hide();
      self.$("#forgot-footer").hide();
      self.$("#forgot-done-view").show();
      self.$("#forgot-done-footer").show();
    }).fail(function (error) {
      var d = JSON.parse(error.responseText);
      self.$("#forgot-error").html(d.message);
      self.$("#forgot-error").show();
    });
  },

  checkName: function (e) {
    var name = this.$("#rname").val();
    if (name && name !== '') {
      $("#rname").closest(".form-group").find(".help-block").hide();
    } else {
      $("#rname").closest(".form-group").find(".help-block").show();
    }
  },

  checkUsername: function (e) {
    var username = $("#rusername").val();
    $.ajax({
      url: '/api/user/username/' + username,
    }).done(function (data) {
      $("#rusername-button").removeClass('btn-success');
      $("#rusername-button").removeClass('btn-danger');
      $("#rusername-check").removeClass('fa fa-check');
      $("#rusername-check").removeClass('fa fa-times');
      if (data) {
        // username is taken
        $("#rusername-button").addClass('btn-danger');
        $("#rusername-check").addClass('fa fa-times');
      } else {
        // username is available
        $("#rusername-button").addClass('btn-success');
        $("#rusername-check").addClass('fa fa-check');
        $("#rusername").closest(".form-group").removeClass('has-error');
        $("#rusername").closest(".form-group").find(".help-block").hide();
      }
    });
  },

  checkPassword: function (e) {
    var rules = validatePassword(this.$("#rusername").val(), this.$("#rpassword").val());
    var valuesArray = _.values(rules);
    var validRules = _.every(valuesArray);
    var success = true;
    if (validRules === true) {
      $("#rpassword").closest(".form-group").removeClass('has-error');
      $("#rpassword").closest(".form-group").find(".help-block").hide();
    }
    _.each(rules, function (value, key) {
      if (value === true) {
        this.$(".password-rules .success.rule-" + key).show();
        this.$(".password-rules .error.rule-" + key).hide();
      } else {
        this.$(".password-rules .success.rule-" + key).hide();
        this.$(".password-rules .error.rule-" + key).show();
      }
      success = success && value;
    });
    return success;
  },

  checkPasswordConfirm: function (e) {
    var success = true;
    var password = this.$("#rpassword").val();
    var confirm = this.$("#rpassword-confirm").val()
    if (password === confirm) {
      $("#rpassword-confirm").closest(".form-group").find(".help-block").hide();
    } else {
      $("#rpassword-confirm").closest(".form-group").find(".help-block").show();
      success = false;
    }
    return success;
  },

  clickUsername: function (e) {
    e.preventDefault();
  },

  cleanup: function () {
    if (this.loginPasswordView) { this.loginPasswordView.cleanup(); }
    removeView(this);
  },
});

module.exports = LoginView;

},{"../../../components/modal":106,"../../../mixins/utilities":128,"../templates/login_template.html":53,"./login_password_view":54,"backbone":133,"underscore":159}],56:[function(require,module,exports){
module.exports = "<div id=\"login-wrapper\"></div>\n<div class=\"navbar navbar-default navbar-static-top\">\n  <div class=\"container\">\n    <div class=\"navbar-header\">\n      <button type=\"button\" class=\"navbar-toggle\" data-toggle=\"collapse\" data-target=\".navbar-collapse\">\n        <span class=\"icon-bar\"></span>\n        <span class=\"icon-bar\"></span>\n        <span class=\"icon-bar\"></span>\n      </button>\n      <a class=\"navbar-brand\" href=\"/\" title=\"<%- systemName %> Home\">\n      </a>\n    </div>\n    <div class=\"navbar-collapse collapse pull-right\">\n      <ul class=\"nav navbar-nav\">\n\n        <% if (ui.project.show) { %>\n        <li class=\"projects\">\n          <a href=\"/projects\" class=\"nav-link\">\n            <i class=\"fa fa-rocket\"></i>\n            <span class=\"navbar-title-small\" data-i18n=\"Browse\">Browse</span><br/>\n            <span class=\"navbar-title-big\" data-i18n=\"ProjectPlural\">Projects</span>\n          </a>\n        </li>\n        <% } %>\n        <li class=\"tasks\">\n          <a href=\"/tasks\" class=\"nav-link\">\n            <i class=\"fa fa-tags\"></i>\n            <span class=\"navbar-title-small\" data-i18n=\"Browse\">Browse</span><br/>\n            <span class=\"navbar-title-big\" data-i18n=\"TaskPlural\">Tasks</span>\n          </a>\n        </li>\n\n        <li class=\"divider-vertical navbar-text\"></li>\n        <% if (user) { %>\n          <li class=\"profile dropdown\"><a href=\"/profile\" id=\"navbar-profile\" role=\"button\" class=\"dropdown-toggle\" data-toggle=\"dropdown\">\n            <img src=\"/api/user/photo/<%- user.id %>\" class=\"navbar-people\"/> &nbsp;\n              <% if (user.name) { %><%- user.name %>\n              <% } else { %><%- user.username %>\n              <% } %>\n            </a>\n            <ul class=\"dropdown-menu\" role=\"menu\" aria-labelledby=\"navbar-profile\">\n              <li role=\"presentation\"><a role=\"menuitem\" class=\"nav-link\" tabindex=\"-1\" href=\"/profile\">Profile</a></li>\n              <% if (user.isAdmin === true) { %>\n              <li role=\"presentation\" class=\"divider\"></li>\n              <li role=\"presentation\"><a role=\"menuitem\"\n                 tabindex=\"-1\" href=\"/admin\" class=\"nav-link\">Administration</a></li>\n              <% } %>\n              <% if (login.local.logout) { %>\n              <li role=\"presentation\" class=\"divider\"></li>\n              <li role=\"presentation\"><a role=\"menuitem\"\n                 tabindex=\"-1\" href=\"/auth/logout\" class=\"logout\">Logout</a></li>\n              <% } %>\n            </ul>\n          </li>\n        <% } else { %>\n          <% if (login.signin !== false) { %>\n          <li class=\"navbar-1line\"><a href=\"/auth\" class=\"login\"><i class=\"fa fa-plus-circle\"></i> Sign In</a></li>\n          <% } %>\n        <% }; %>\n      </ul>\n    </div>\n  </div>\n</div>\n";

},{}],57:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../mixins/utilities');
var UIConfig = require('../../../config/ui.json');
var Login = require('../../../config/login.json');
var LoginController = require('../../login/controllers/login_controller');
var NavTemplate = require('../templates/nav_template.html');


var NavView = Backbone.View.extend({

  events: {
    'click .navbar-brand'   : linkBackbone,
    'click .nav-link'       : linkBackbone,
    'click .login'          : 'loginClick',
    'click .logout'         : 'logout'
  },

  initialize: function (options) {
    var self = this;
    this.options = options;

    this.listenTo(window.cache.userEvents, "user:login:success", function (userData) {
      self.doRender({ user: userData });
    });

    this.listenTo(window.cache.userEvents, "user:logout", function () {
      self.doRender({ user: null });
      Backbone.history.loadUrl();
      window.cache.userEvents.trigger("user:logout:success");
    });

    // request that the user log in to see the page
    this.listenTo(window.cache.userEvents, "user:request:login", function (message) {
      // trigger the login modal
      self.login(message);
    });

    // update the navbar when the profile changes
    this.listenTo(window.cache.userEvents, "user:profile:save", function (data) {
      // reset the currentUser object
      window.cache.currentUser = data;
      // re-render the view
      self.render();
    });

    // update the user's photo when they change it
    this.listenTo(window.cache.userEvents, "user:profile:photo:save", function (url) {
      $(".navbar-people").attr('src', url);
    });
  },

  render: function () {
    var self = this;
    this.doRender({ user: window.cache.currentUser, systemName: window.cache.system.name });
    return this;
  },

  doRender: function (data) {
    data.login = Login;
    data.ui = UIConfig;
    var template = _.template(NavTemplate)(data);
    this.$el.html(template);
    this.$el.i18n();
    $(".nav li").on("click", function () {
      $(".nav li").removeClass("active");
      $(this).addClass("active");
    });
  },

  loginClick: function (e) {
    if (e.preventDefault) e.preventDefault();
    this.login();
  },

  login: function (message) {
    if (this.loginController) {
      this.loginController.cleanup();
    }
    this.loginController = new LoginController({
      el: '#login-wrapper',
      message: message
    });
  },

  logout: function (e) {
    if (e.preventDefault) e.preventDefault();
    $.ajax({
      url: '/api/auth/logout?json=true',
    }).done(function (success) {
      window.cache.currentUser = null;
      window.cache.userEvents.trigger("user:logout");
    }).fail(function (error) {
      // do nothing
    });
  },

  cleanup: function () {
    if (this.loginController) { this.loginController.cleanup(); }
    removeView(this);
  },
});

module.exports = NavView;

},{"../../../config/login.json":114,"../../../config/ui.json":116,"../../../mixins/utilities":128,"../../login/controllers/login_controller":51,"../templates/nav_template.html":56,"backbone":133,"underscore":159}],58:[function(require,module,exports){
module.exports = "<form role=\"form\" action=\"\" id=\"email-form\">\n  <div class=\"modal-body\">\n    <div class=\"alert alert-warning\" style=\"display:none;\"></div>\n    <fieldset>\n      <div class=\"form-group\">\n        <label for=\"email\">Email Address</label>\n        <input type=\"email\" class=\"form-control\" id=\"email\" name=\"email\" placeholder=\"name@domain.com\"/>\n      </div>\n    </fieldset>\n  </div>\n  <div class=\"modal-footer\">\n    <button type=\"button\" class=\"btn btn-c0\" data-dismiss=\"modal\">Cancel</button>\n    <input type=\"submit\" class=\"btn btn-c2\" id=\"submit\" value=\"Add Email Address\"/>\n  </div>\n</form>\n";

},{}],59:[function(require,module,exports){

var Bootstrap = require('bootstrap');
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var EmailFormTemplate = require('../templates/profile_email_form.html');


var EmailFormView = Backbone.View.extend({

  events: {
    "submit #email-form" : "post"
  },

  initialize: function (options) {
    this.target = options.target;
    this.options = options;
  },

  render: function () {
    var template = _.template(EmailFormTemplate)({});
    this.$el.html(template);
    return this;
  },

  post: function (e) {
    if (e.preventDefault) e.preventDefault();
    var data;
    var self = this;

    this.$(".alert").hide();
    data = {
      email: $(e.currentTarget).find("#email").val(),
    }

    $.ajax({
      url: '/api/useremail',
      type: 'POST',
      data: data,
      success: function (result) {
        // Pass the tag back
        self.options.model.trigger(self.target + ":email:new", result);
      },
      error: function (req, status, error) {
        self.$(".alert").html(req.responseJSON.message);
        self.$(".alert").show();
        self.options.model.trigger(self.target + ":email:error", req.responseJSON);
      }
    });

  },

  cleanup: function () {
    removeView(this);
  }

});

module.exports = EmailFormView;

},{"../../../../mixins/utilities":128,"../templates/profile_email_form.html":58,"backbone":133,"bootstrap":138,"underscore":159}],60:[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');
var BaseController = require('../../../../base/base_controller');
var ProfileModel = require('../../../../entities/profiles/profile_model');
var ProfileView = require('../views/profile_show_view');
var ProfileSettingsView = require('../views/profile_settings_view');
var ProfileResetView = require('../views/profile_reset_view');
var Login = require('../../../../config/login.json');
var AlertTemplate = require('../../../../components/alert_template.html');

Profile = BaseController.extend({

  // Here we are defining wether or not this is a full-region object
  // or a sub-region of another region.
  region: true,
  subRegion: false,

  el: "#container",

  events: {
  },

  initialize: function (options) {
    this.options = options;
    this.routeId = options.id;
    this.action = options.action;
    this.data = options.data;
    this.initializeController();
  },

  initializeController: function () {
    // Clean up previous views
    if (this.profileView) { this.profileView.cleanup(); }
    if (this.settingsView) { this.settingsView.cleanup(); }
    if (this.profileResetView) { this.profileResetView.cleanup(); }
    // If the action does not require the profile model, display that action
    if (this.routeId == 'reset') {
      this.profileResetView = new ProfileResetView({
        el: this.$el,
        routeId: this.routeId,
        action: this.action,
        data: this.data
      }).render();
    }
    // otherwise load the profile model and display the appropriate view
    else {
      this.initializeProfileModelInstance();
    }
  },

  initializeProfileModelInstance: function () {
    var self = this;

    if (this.model) this.model.remove();
    this.model = new ProfileModel();

    // prevent directly editing profiles when disabled
    if ((Login.profile.edit === false) && (this.action == 'edit')) {
      var data = {
        alert: {
          message: "<strong>Direct editing of profiles is disabled.</strong>  <a href=\"" + Login.profile.editUrl + "\" title=\"Edit Profile\">Click here to edit your profile</a>"
        }
      };
      var template = _.template(AlertTemplate)(data)
      this.$el.html(template);
      return;
    }
    // var fetchId = null;
    // if (this.id && this.id != 'edit') { fetchId = this.id; }
    this.model.trigger("profile:fetch", this.routeId);
    // process a successful model fetch, and display the model
    this.listenTo(this.model, "profile:fetch:success", function (model) {
      // @instance
      self.model = model;
      var modelJson = model.toJSON();
      for (i in modelJson.tags) {
        if (modelJson.tags[i].tag.type == 'agency') {
          self.model.agency = modelJson.tags[i].tag;
          self.model.agency['tagId'] = modelJson.tags[i].id;
        }
        else if (modelJson.tags[i].tag.type == 'location') {
          self.model.location = modelJson.tags[i].tag;
          self.model.location['tagId'] = modelJson.tags[i].id;
        }
      }
      self.initializeProfileViewInstance();
    });
    // if the profile fetch fails, check if it is due to the user
    // not being logged in
    this.listenTo(this.model, "profile:fetch:error", function (model, response) {
      // if the user isn't logged in, trigger the login window
      if (response.status === 403) {
        window.cache.userEvents.trigger("user:request:login", {
          message: "You must be logged in to view profiles",
          disableClose: false
        });
      }
      var data = {
        alert: {
          message: "<strong>Unable to load profile.  Please reload this page to try again.</strong><br/>Error: "
        }
      };
      // check if the response provided an error
      if (response.responseText) {
        var err = JSON.parse(response.responseText);
        if (err.message) {
          data.alert.message += err.message;
        }
      }
      var template = _.template(AlertTemplate)(data)
      self.$el.html(template);
    });
  },

  initializeProfileViewInstance: function () {
    if (this.action == 'settings') {
      this.settingsView = new ProfileSettingsView({
        el: this.$el,
        model: this.model,
        routeId: this.routeId,
        action: this.action,
        data: this.data
      }).render();
    } else {
      this.profileView = new ProfileView({
        el: this.$el,
        model: this.model,
        routeId: this.routeId,
        action: this.action,
        data: this.data
      }).render();
    }
  },

  cleanup: function() {
    if (this.profileView) { this.profileView.cleanup(); }
    if (this.settingsView) { this.settingsView.cleanup(); }
    removeView(this);
  }

});

module.exports = Profile;

},{"../../../../base/base_controller":101,"../../../../components/alert_template.html":103,"../../../../config/login.json":114,"../../../../entities/profiles/profile_model":121,"../views/profile_reset_view":67,"../views/profile_settings_view":68,"../views/profile_show_view":69,"backbone":133,"underscore":159}],61:[function(require,module,exports){
module.exports = "<ul class=\"nav nav-tabs\">\n  <li class=\"active\"><a href=\"#<%= handle %>-tab-open\" data-toggle=\"tab\">Open</a></li>\n  <li><a href=\"#<%= handle %>-tab-closed\" data-toggle=\"tab\">Closed</a></li>\n</ul>\n\n<div class=\"tab-content\">\n  <div class=\"tab-pane active\" id=\"<%= handle %>-tab-open\">\n    <table class=\"table table-condensed table-hover\">\n      <% if ( count.open > 0 || count.assigned > 0 || count.draft > 0) { %>\n        <thead>\n          <tr>\n            <th data-i18n=\"<%= targetCapitalized %>\">Project</th>\n            <th>Created</th>\n            <th>Likes</th>\n          </tr>\n        </thead>\n        <tbody>\n        <% for (var i in data) { %>\n          <% if (data[i].state == 'completed' || data[i].state == 'archived') { continue; } %>\n          <tr>\n            <td>\n              <% if (data[i].state == 'draft') { %>\n              <span class=\"label label-warning\">draft</span>\n              <% } %>\n              <a href=\"<%= target %>s/<%= data[i].id %>\" class=\"activity-link\" data-id=\"<%= data[i].id %>\"><%= data[i].title %></a>\n            </td>\n            <td>\n              <% var created = new Date(data[i].createdAt); %>\n              <%= created.toLocaleDateString() %> <%= created.toLocaleTimeString() %></td>\n            <td><%= data[i].likeCount %></td>\n          </tr>\n        <% } %>\n        </tbody>\n      <% } else { %>\n        <tbody>\n          <tr>\n            <td>No <%= targetsFriendly %></td>\n          </tr>\n        </tbody>\n      <% } %>\n    </table>\n  </div>\n  <div class=\"tab-pane\" id=\"<%= handle %>-tab-closed\">\n    <table class=\"table table-condensed table-hover\">\n      <% if (count.completed > 0 || count.archived > 0) { %>\n        <thead>\n          <tr>\n            <th data-i18n=\"<%= targetCapitalized %>\">Project</th>\n            <th>Created</th>\n            <th>Likes</th>\n          </tr>\n        </thead>\n        <tbody>\n        <% for (var i in data) { %>\n          <% if (data[i].state !== 'completed' && data[i].state !== 'archived') { continue; } %>\n          <tr>\n            <td>\n              <a href=\"<%= target %>s/<%= data[i].id %>\" class=\"activity-link\" data-id=\"<%= data[i].id %>\"><%= data[i].title %></a>\n            </td>\n            <td><%= data[i].createdAt %></td>\n            <td><%= data[i].likeCount %></td>\n          </tr>\n        <% } %>\n        </tbody>\n      <% } else { %>\n        <tbody>\n          <tr>\n            <td>No <%= targetsFriendly %></td>\n          </tr>\n        </tbody>\n      <% } %>\n    </table>\n  </div>\n</div>\n";

},{}],62:[function(require,module,exports){
module.exports = "<div class=\"radio\">\n  <label>\n    <input type=\"radio\" name=\"primaryEmail\" id=\"email-<%- email.id %>\" value=\"<%- email.email %>\" <% if (email.isPrimary) { %>checked<% } %>>\n    <a href=\"#\" class=\"email-remove\" id=\"email-remove-<%- email.id %>\" data-id=\"<%- email.id %>\"><span class=\"fa fa-trash\"></span></a> <%- email.email %>\n  </label>\n</div>\n";

},{}],63:[function(require,module,exports){
module.exports = "<div class=\"row\">\n\n  <div class=\"row\">\n    <div class=\"col-md-6 col-md-offset-3 box\">\n      <div class=\"box-main\">\n\n        <div class=\"profile-reset center\" id=\"profile-reset-check\">\n          <i class=\"fa fa-spin fa-spinner\"></i> Looking up password reset code...\n        </div>\n\n        <div class=\"profile-reset error\" id=\"profile-reset-check-error\" style=\"display: none;\">\n          This is not a valid password reset code.  Please try resetting your password again and clicking on the link in the email.\n        </div>\n        <div class=\"profile-reset error\" id=\"profile-reset-submit-error\" style=\"display: none;\">\n          An error occurred resetting your password.  Please reload this page and try again.\n        </div>\n\n        <div class=\"profile-reset\" id=\"profile-reset-dialog\" style=\"display: none;\">\n          <form id=\"form-password-reset\" title=\"Password Reset\">\n            <h1>\n              Please set a new password for your account.\n            </h1>\n            <div class=\"password-view\">\n            </div>\n            <div>\n              <input type=\"submit\" class=\"btn btn-c1\" value=\"Reset Password\"/>\n            </div>\n          </form>\n        </div>\n        <div class=\"profile-reset center\" id=\"profile-reset-submit\" style=\"display: none;\">\n          <i class=\"fa fa-spin fa-spinner\"></i> Performing password reset.  Please stand by...\n        </div>\n\n      </div>\n    </div>\n  </div>\n\n</div>\n";

},{}],64:[function(require,module,exports){
module.exports = "<div class=\"row\">\n\n  <div class=\"alert alert-info\">\n    Profile settings are not yet implemented.  Please contact the administrator of this system to update your email settings.  Our apologies, stay tuned!\n  </div>\n\n</div>\n";

},{}],65:[function(require,module,exports){
module.exports = "<div class=\"row\">\n\n  <% if (user.isAdmin) { %>\n  <div class=\"alert alert-info\">\n    You are an administrator.\n    <% if (user.id !== data.id) { %>\n      <% if (edit === true) { %>\n        <strong>You are editing another user's profile.</strong>\n      <% } else { %>\n        You are viewing another user's profile.\n      <% } %>\n    <% } %>\n  </div>\n  <% } %>\n\n  <% if (saved) { %>\n  <div class=\"alert alert-success\">Your profile has been successfully updated.</div>\n  <% } %>\n\n  <div class=\"col-sm-3 col-md-4 project-sidebar\">\n    <!-- LEFT SIDEBAR -->\n\n    <div class=\"row\">\n      <div class=\"col-md-12 box project-header-wrapper\">\n        <div id=\"project-header\" style=\"background-image:url('/api/user/photo/<%- data.id %>');\">\n          <div class=\"btn btn-c2 fileinput-button\" <% if (!((data.isOwner || user.isAdmin) && edit)) { %>style=\"display:none;\"<% } %>>\n            <i class=\"fa fa-camera fa-lg\" title=\"Change Cover Photo\" id=\"fileupload-icon\"></i>\n            <input id=\"fileupload\" type=\"file\" name=\"files[]\" title=\"Upload Photo\">\n          </div>\n        </div>\n        <div id=\"file-upload-progress-container\" style=\"display: none;\" class=\"progress progress-striped active\">\n          <div id=\"file-upload-progress\" class=\"progress-bar\" style=\"width: 0\"></div>\n        </div>\n        <div id=\"file-upload-alert\" class=\"alert alert-warning\" style=\"display:none;\">\n        </div>\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"col-md-12 box\">\n        <div class=\"box-main tag-wrapper\">\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"col-sm-9 col-md-8\">\n    <!-- RIGHT MAIN BAR -->\n    <% if (edit) { %> <!-- in edit mode -->\n    <div class=\"box box-main\">\n      <div id=\"emailModal\"></div>\n\n      <form class=\"form-horizontal\" role=\"form\" id=\"profile-form\">\n        <h1>\n          <div class=\"form-group\">\n            <input type=\"text\" class=\"form-control input-lg\" id=\"name\" name=\"name\" placeholder=\"Your Full Name\" value=\"<% if (data.name) { %><%- data.name %><% } %>\" title=\"Your Full Name\"/>\n          </div>\n        </h1>\n\n        <h2> Bio </h2>\n\n        <div class=\"form-group\">\n          <label for=\"title\" class=\"col-md-3 control-label\">Title</label>\n          <div class=\"col-md-9\">\n            <input type=\"text\" class=\"form-control\" id=\"title\" name=\"title\" placeholder=\"Title\" value=\"<% if (data.title) { %><%- data.title %><% } %>\"/>\n          </div>\n        </div>\n\n        <div class=\"form-group\">\n          <label for=\"company\" class=\"col-md-3 control-label\">Agency</label>\n          <div class=\"col-md-9\">\n            <input type=\"hidden\" id=\"company\" name=\"company\" style=\"width: 100%\"/>\n          </div>\n        </div>\n\n        <div class=\"form-group\">\n          <label for=\"location\" class=\"col-md-3 control-label\">Location</label>\n          <div class=\"col-md-9\">\n            <input type=\"hidden\" id=\"location\" name=\"location\" style=\"width: 100%\"/>\n          </div>\n        </div>\n\n        <div class=\"form-group\">\n          <label for=\"bio\" class=\"col-md-3 control-label\">A brief public biography</label>\n          <div class=\"col-md-9\">\n            <div class=\"markdown-edit\"></div>\n          </div>\n        </div>\n\n        <h2> Account Information </h2>\n\n        <div class=\"form-group\">\n          <label for=\"profile-email\" class=\"col-md-3 control-label\">Email</label>\n          <div class=\"col-md-9\">\n            <input type=\"text\" class=\"form-control\" id=\"profile-email\" name=\"email\"\n              placeholder=\"Email\" value=\"<% if (email) { %><%- email.email %><% } %>\">\n            <div id=\"email-update-alert\" class=\"alert alert-warning\" style=\"display:none;\"></div>\n          </div>\n        </div>\n\n        <div class=\"form-group\">\n          <% if (login.oauth.length > 0) { %>\n          <label for=\"services\" class=\"col-md-3 control-label\">Connected Accounts</label>\n          <div class=\"col-md-9\" id=\"services\">\n            <form class=\"form-horizontal\" role=\"form\">\n            <% _.each(login.oauth, function (a) { %>\n              <div class=\"form-group\">\n                <div class=\"col-xs-8 col-sm-9 col-md-9\">\n                  <img src=\"<%= login.config[a].image %>\" alt=\"<%= login.config[a].name %>\" style=\"height: 30px\"/>\n                </div>\n                <div class=\"col-xs-4 col-sm-3 col-md-3\">\n                  <% if (_.contains(data.auths, a)) { %>\n                  <a href=\"#\" class=\"btn btn-danger btn-sm removeAuth pull-right\" data-service=\"<%= a %>\"><span class=\"fa fa-remove\"></span> Disconnect</a>\n                  <% } else { %>\n                  <a href=\"<%= login.config[a].endpoint %>\" class=\"btn btn-success btn-sm pull-right\"><span class=\"fa fa-plus\"></span> Connect</a>\n                  <% } %>\n                  <!-- <%= login.config[a].name %> -->\n                </div>\n              </div>\n            <% }); %>\n          </div>\n          <% } %>\n        </div>\n        <div class=\"form-group\">\n          <div class=\"col-md-offset-3 col-md-9\">\n            <div class=\"pull-right\">\n              <a href=\"#\" class=\"btn btn-c0\" id=\"profile-cancel\">Discard Changes</a>\n\n              <button id=\"submit\" type=\"submit\" class=\"btn btn-c2\" disabled=\"disabled\" data-loading-text=\"<i class='fa fa-spinner fa-spin'></i> Saving...\" data-success-text=\"Saved!\" data-fail-text=\"Save Failed.\">Save Profile</button>\n            </div>\n          </div>\n        </div>\n\n      </form>\n    </div>\n    <% } else { %> <!-- not in edit mode -->\n    <div class=\"row\">\n      <div class=\"col-md-9 sm-nopadding md-nopadding\">\n        <div class=\"box box-main\">\n          <h1><% if (data.name) { %><%- data.name %><% } else { %><%- data.username %><% } %></h1>\n\n          <div class=\"profile-jobtitle\"><% if (data.title) { %><i class=\"fa fa-briefcase\"></i> <span class=\"box-icon-text\"><%- data.title %></span><% } %></div>\n          <div class=\"profile-company\"><% if (data.agency) { %><i class=\"icon-library\"></i> <span class=\"box-icon-text\"><%- data.agency.tag.name %></span><% } %></div>\n          <div class=\"profile-location\"><% if (data.location) { %><span class=\"fa fa-map-marker\"></span> <span class=\"box-icon-text\"><%- data.location.tag.name %></span><% } %></div>\n\n          <div class=\"profile-bio box-pad-t\">\n            <% if (data.bioHtml) { %><%= data.bioHtml %><% } else { %>This person doesn't have a bio yet.<% } %>\n          </div>\n        </div>\n      </div>\n      <div class=\"col-md-3 sm-nopadding md-nopadding padding-left-none\">\n        <div class=\"box padding-none\">\n<!--\n          <div class=\"navbar-side like-row border-bottom\">\n            <a href=\"#\" id=\"like-button\" class=\"like-button\">\n              <i id=\"like-button-icon\" class=\"fa fa-star-o fa-lg gold\"></i>\n            </a>\n            <span class=\"like-number\" id=\"like-number\"><%- data.likeCount %></span>\n            <span class=\"like-plural\" id=\"like-text\" data-plural=\"followers\" data-singular=\"follower\">followers</span>\n          </div>\n-->\n          <div class=\"navbar-side <% if (data.isOwner || user.isAdmin) { %>border-bottom<% } %>\">\n            <ul class=\"nav nav-pills nav-stacked\">\n              <li>\n                <a href=\"#\" id=\"email\"><i class=\"fa fa-envelope-o\"></i> <span class=\"box-icon-text\">Share</span></a>\n              </li>\n              <% if (data.isOwner || user.isAdmin) { %>\n              <li>\n                <a href=\"/api/event/ical/\"><span class=\"fa fa-calendar\"></span> <span class=\"box-icon-text\">Calendar</span></a>\n              </li>\n            </ul>\n          </div>\n          <div class=\"navbar-side\">\n              <ul class=\"nav nav-pills nav-stacked\">\n              <li>\n                <% if (login.profile.edit === true) { %>\n                <a href=\"/profile/<%- data.id %>/edit\" class=\"link-backbone\"><i class=\"fa fa-pencil\"></i> <span class=\"box-icon-text\">Edit Profile</span></a>\n                <% } else if (login.profile.editUrl) { %>\n                <a href=\"<%= login.profile.editUrl %>\" target=\"_blank\"><i class=\"fa fa-pencil\"></i> <span class=\"box-icon-text\">Edit Profile</span></a>\n                <% } %>\n              </li>\n              <% } %>\n            </ul>\n          </div>\n        </div>\n\n      </div>\n    </div>\n\n    <% if (data.isOwner) { %>\n    <div class=\"box\">\n      <div class=\"box-pad-lr border-bottom\">\n        <h2>Account Information</h2>\n      </div>\n\n      <div class=\"box-pad-lr box-pad-t\">\n        <div class=\"row\">\n          <div class=\"col-xs-3 col-sm-3 col-md-3\">\n            Email<% if (data.emails.length > 1) { %>s<% }%>:\n          </div>\n          <div class=\"col-xs-9 col-sm-9 col-md-9\">\n            <% for (var e = 0; e < data.emails.length; e++) { %>\n              <% if (data.emails[e].isPrimary) { %>x<% } %>\n              <%- data.emails[e].email %><br/>\n            <% } %>\n            <% if (data.emails.length == 0) { %>\n            No email addresses\n            <% } %>\n          </div>\n        </div>\n\n        <% if (login.oauth.length > 0) { %>\n        <div class=\"row\">\n          <div class=\"col-xs-3 col-sm-3 col-md-3\">\n            Connected Accounts:\n          </div>\n          <div class=\"col-xs-9 col-sm-9 col-md-9\">\n            <% if (data.auths.length === 0) { %>\n              No connected accounts.\n            <% } %>\n            <% _.each(login.oauth, function (a) { %>\n              <% if (_.contains(data.auths, a)) { %>\n              <div>\n                <%= login.config[a].name %>\n                <span class=\"label label-success\">Connected</span>\n              </div>\n              <% } %>\n            <% }); %>\n          </div>\n        </div>\n        <% } %>\n      </div>\n    </div>\n    <% } %>\n\n    <% if (ui.project.show) { %>\n    <div class=\"box\">\n      <div class=\"box-pad-lr border-bottom\">\n        <h2><span data-i18n=\"ProjectPlural\">Projects</span></h2>\n      </div>\n      <div class=\"box-pad-lr box-pad-t\">\n        <div class=\"project-activity-wrapper\"></div>\n      </div>\n    </div>\n    <% } %>\n\n    <div class=\"box\">\n      <div class=\"box-pad-lr border-bottom\">\n        <h2><span data-i18n=\"TaskPlural\">Opportunities</span> Volunteered For</h2>\n      </div>\n      <div class=\"box-pad-lr box-pad-t\">\n        <div class=\"task-activity-wrapper\"></div>\n      </div>\n    </div>\n\n    <div class=\"box\">\n      <div class=\"box-pad-lr border-bottom\">\n        <h2><span data-i18n=\"TaskPlural\">Opportunities</span> Created</h2>\n      </div>\n      <div class=\"box-pad-lr box-pad-t\">\n        <div class=\"task-createdactivity-wrapper\"></div>\n      </div>\n    </div>\n\n    <% } %> <!-- /edit check -->\n\n  </div>\n</div>\n";

},{}],66:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var UIConfig = require('../../../../config/ui.json');
var async = require('async');
var ActTemplate = require('../templates/profile_activity_template.html');


var ProfileActivityView = Backbone.View.extend({

  events: {
    'click .activity-link'    : 'link'
  },

  initialize: function (options) {
    this.options = options;
  },

  render: function () {
    // sort initially by date, descending.
    var results = this.options.data.sort(function (a, b) {
      return new Date(b.createdAt) - new Date(a.createdAt);
    });
    var data = {
      ui: UIConfig,
      target: this.options.target,
      targetFriendly: i18n.t(this.options.target),
      targetsFriendly: i18n.t(this.options.target + 'Plural'),
      targetCapitalized: this.options.target.charAt(0).toUpperCase() + this.options.target.slice(1),
      handle: this.options.handle,
      data: results,
      count: {}
    };

    for (var i in this.options.data) {
      if (_.isUndefined(data.count[this.options.data[i].state])) {
        data.count[this.options.data[i].state] = 1;
      } else {
        data.count[this.options.data[i].state]++
      }
    }
    var template = _.template(ActTemplate)(data);
    this.$el.html(template);
    this.$el.i18n();

    return this;
  },

  link: function (e) {
    if (e.preventDefault) e.preventDefault();
    Backbone.history.navigate(this.options.target + 's/' + $(e.currentTarget).data('id'), { trigger: true });
  },

  cleanup: function () {
    removeView(this);
  },

});

module.exports = ProfileActivityView;

},{"../../../../config/ui.json":116,"../../../../mixins/utilities":128,"../templates/profile_activity_template.html":61,"async":131,"backbone":133,"underscore":159}],67:[function(require,module,exports){

var async = require('async');
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var LoginPasswordView = require('../../../login/views/login_password_view');
var ProfileResetTemplate = require('../templates/profile_reset_template.html');


var ProfileResetView = Backbone.View.extend({

  events: {
    'keyup #rpassword'               : 'checkPassword',
    'blur #rpassword'                : 'checkPassword',
    'submit #form-password-reset'    : 'submitReset'
  },

  initialize: function (options) {
    this.options = options;
    this.data = options.data;
  },

  render: function () {
    var data = {
      user: window.cache.currentUser || {}
    };
    var template = _.template(ProfileResetTemplate)(data);
    this.$el.html(template);
    this.loginPasswordView = new LoginPasswordView({
      el: this.$(".password-view")
    }).render();
    this.checkValidCode(this.options.action);
    return this;
  },

  checkPassword: function (e) {
    var rules = validatePassword(this.token.email, this.$("#rpassword").val());
    var success = true;
    _.each(rules, function (value, key) {
      if (value === true) {
        this.$(".password-rules .success.rule-" + key).show();
        this.$(".password-rules .error.rule-" + key).hide();
      } else {
        this.$(".password-rules .success.rule-" + key).hide();
        this.$(".password-rules .error.rule-" + key).show();
      }
      success = success && value;
    });
    return success;
  },

  checkValidCode: function (code) {
    var self = this;
    // check if the code is valid and update the DOM accordingly
    $.ajax({
      url: '/api/auth/checkToken/' + code,
      success: function (data) {
        self.$("#profile-reset-check").hide();
        // true means the token is a valid reset token
        if (data === false) {
          self.$("#profile-reset-check-error").show();
        }
        else {
          self.token = data;
          self.$("#profile-reset-dialog").show();
        }
      },
      error: function (data) {
        self.$("#profile-reset-check").hide();
        self.$("#profile-reset-check-error").show();
      }
    });
  },

  submitReset: function (e) {
    var self = this;
    if (e.preventDefault) e.preventDefault();

    var passwordSuccess = this.checkPassword();
    var parent = $(this.$("#rpassword").parents('.form-group')[0]);
    if (passwordSuccess !== true) {
      parent.addClass('has-error');
      $(parent.find('.error-password')[0]).show();
      return;
    } else {
      $(parent.find('.error-password')[0]).hide();
    }

    // Create a data object with the required fields
    var data = {
      token: this.options.action,
      password: this.$("#rpassword").val(),
      json: true
    };
    self.$("#profile-reset-submit").show();
    self.$("#profile-reset-submit-error").hide();
    $.ajax({
      url: '/api/auth/reset/',
      type: 'POST',
      data: data,
      success: function (data) {
        self.$("#profile-reset-submit").hide();
        // true means the token is a valid reset token
        if (data === false) {
          self.$("#profile-reset-submit-error").show();
        }
        else {
          // navigate to the projects main page
          Backbone.history.navigate('/', { trigger: true });
          // show log in screen with notice to log in.
          window.cache.userEvents.trigger("user:request:login", {
            message: "Your password has been reset.  Please log in to continue."
          });
        }
      },
      error: function (data) {
        self.$("#profile-reset-submit").hide();
        self.$("#profile-reset-submit-error").show();
      }
    });

  },

  cleanup: function () {
    removeView(this);
  },

});

module.exports = ProfileResetView;


},{"../../../../mixins/utilities":128,"../../../login/views/login_password_view":54,"../templates/profile_reset_template.html":63,"async":131,"backbone":133,"underscore":159}],68:[function(require,module,exports){

var async = require('async');
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var ProfileSettingsTemplate = require('../templates/profile_settings_template.html');


var ProfileSettingsView = Backbone.View.extend({

  events: {
  },

  initialize: function (options) {
    this.options = options;
    this.data = options.data;
  },

  render: function () {
    var data = {
      user: window.cache.currentUser || {}
    }
    var template = _.template(ProfileSettingsTemplate)(data);
    this.$el.html(template);
    return this;
  },

  cleanup: function () {
    removeView(this);
  },

});

module.exports = ProfileSettingsView;


},{"../../../../mixins/utilities":128,"../templates/profile_settings_template.html":64,"async":131,"backbone":133,"underscore":159}],69:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var UIConfig = require('../../../../config/ui.json');
var async = require('async');
var jqIframe = require('blueimp-file-upload/js/jquery.iframe-transport');
var jqFU = require('blueimp-file-upload/js/jquery.fileupload.js');
var MarkdownEditor = require('../../../../components/markdown_editor');
var marked = require('marked');
var TagShowView = require('../../../tag/show/views/tag_show_view');
var ProfileTemplate = require('../templates/profile_show_template.html');
var EmailTemplate = require('../templates/profile_email_template.html');
var Login = require('../../../../config/login.json');
var ModalComponent = require('../../../../components/modal');
var PAView = require('./profile_activity_view');
var EmailFormView = require('../../email/views/profile_email_view');
var TagFactory = require('../../../../components/tag_factory');


var ProfileShowView = Backbone.View.extend({

  events: {
    "submit #profile-form"       : "profileSubmit",
    "click #profile-save"        : "profileSave",
    "click .link-backbone"       : linkBackbone,
    "click #profile-cancel"      : "profileCancel",
    "click #like-button"         : "like",
    "keyup #name, #title, #bio"  : "fieldModified",
    "click .removeAuth"          : "removeAuth"
  },

  initialize: function (options) {
    this.options = options;
    this.data = options.data;
    this.tagFactory = new TagFactory();
    this.data.newItemTags = [];
    this.edit = false;
    if (this.options.action == 'edit') {
      this.edit = true;
    }
    if (this.data.saved) {
      this.saved = true;
      this.data.saved = false;
    }
  },

  render: function () {
    var data = {
      login: Login,
      data: this.model.toJSON(),
      user: window.cache.currentUser || {},
      edit: this.edit,
      saved: this.saved,
      ui: UIConfig
    }

    data.email = (data.data.emails && data.data.emails.length) ? data.data.emails[0] : '';

    if (data.data.bio) {
      data.data.bioHtml = marked(data.data.bio);
    }
    var template = _.template(ProfileTemplate)(data);
    this.$el.html(template);
    this.$el.i18n();

    // initialize sub components
    this.initializeFileUpload();
    this.initializeForm();
    this.initializeSelect2();
    this.initializeLikes();
    this.initializeTags();
    this.initializePAView();
    this.initializeTextArea();
    this.updatePhoto();
    this.updateProfileEmail();
    return this;
  },

  initializeFileUpload: function () {
    var self = this;

    $('#fileupload').fileupload({
        url: "/api/file/create",
        dataType: 'text',
        acceptFileTypes: /(\.|\/)(gif|jpe?g|png)$/i,
        formData: { 'type': 'image_square' },
        add: function (e, data) {
          self.$('#file-upload-progress-container').show();
          data.submit();
        },
        progressall: function (e, data) {
          var progress = parseInt(data.loaded / data.total * 100, 10);
          self.$('#file-upload-progress').css(
            'width',
            progress + '%'
          );
        },
        done: function (e, data) {
          // for IE8/9 that use iframe
          if (data.dataType == 'iframe text') {
            var result = JSON.parse(data.result);
          }
          // for modern XHR browsers
          else {
            var result = JSON.parse($(data.result).text());
          }
          self.model.trigger("profile:updateWithPhotoId", result[0]);
        },
        fail: function (e, data) {
          // notify the user that the upload failed
          var message = data.errorThrown;
          self.$('#file-upload-progress-container').hide();
          if (data.jqXHR.status == 413) {
            message = "The uploaded file exceeds the maximum file size.";
          }
          self.$("#file-upload-alert").html(message)
          self.$("#file-upload-alert").show();
        }
    });

  },

  updateProfileEmail: function(){
    var self = this;
    $.ajax({
      url: encodeURI('/api/email/makeURL?email=contactUserAboutProfile&subject=Check Out "'+ self.model.attributes.name + '"' +
      '&profileTitle=' + (self.model.attributes.title || '') +
      '&profileLink=' + window.location.protocol + "//" + window.location.host + "" + window.location.pathname +
      '&profileName=' + (self.model.attributes.name || '') +
      '&profileLocation=' + (self.model.attributes.location ? self.model.attributes.location.tag.name : '') +
      '&profileAgency=' + (self.model.agency ? self.model.agency.name : '')),
      type: 'GET'
    }).done( function (data) {
      self.$('#email').attr('href', data);
    });
  },

  initializeTags: function() {
    if (this.tagView) { this.tagView.cleanup(); }
    this.tagView = new TagShowView({
      model: this.model,
      el: '.tag-wrapper',
      target: 'profile',
      targetId: 'userId',
      edit: this.edit,
      url: '/api/tag/findAllByUserId/'
    });
    this.tagView.render();
  },

  initializePAView: function () {
    if (this.projectView) { this.projectView.cleanup(); }
    if (this.taskView) { this.taskView.cleanup(); }
    if (this.volView) { this.volView.cleanup(); }
    $.ajax('/api/user/activities/' + this.model.attributes.id).done(function (data) {
      this.projectView = new PAView({
        model: this.model,
        el: '.project-activity-wrapper',
        target: 'project',
        handle: 'project',
        data: data.projects
      });
      this.projectView.render();
      this.taskView = new PAView({
        model: this.model,
        el: '.task-createdactivity-wrapper',
        target: 'task',
        handle: 'task',
        data: data.tasks
      });
      this.taskView.render();
      this.volView = new PAView({
        model: this.model,
        el: '.task-activity-wrapper',
        target: 'task',
        handle: 'volTask',
        data: data.volTasks
      });
      this.volView.render();

    });
  },

  updatePhoto: function () {
    var self = this;
    this.model.on("profile:updatedPhoto", function (data) {
      var url = '/api/user/photo/' + data.attributes.id;
      // force the new image to be loaded
      $.get(url, function (data) {
        $("#project-header").css('background-image', "url('" + url + "')");
        $('#file-upload-progress-container').hide();
        // notify listeners of the new user image, but only for the current user
        if (self.model.toJSON().id == window.cache.currentUser.id) {
          window.cache.userEvents.trigger("user:profile:photo:save", url);
        }
      });
    });
  },

  initializeForm: function() {
    var self = this;

    $("#topics").on('change', function (e) {
      self.model.trigger("profile:input:changed", e);
    });

    $("#skills").on('change', function (e) {
      self.model.trigger("profile:input:changed", e);
    });

    this.listenTo(self.model, "profile:save:success", function (data) {
      // Bootstrap .button() has execution order issue since it
      // uses setTimeout to change the text of buttons.
      // make sure attr() runs last
      $("#submit").button('success');
      // notify listeners if the current user has been updated
      if (self.model.toJSON().id == window.cache.currentUser.id) {
        window.cache.userEvents.trigger("user:profile:save", data.toJSON());
      }

      var tags = [
        $("#company").select2('data'),
        $("#location").select2('data')
      ];
      self.model.trigger("profile:tags:save", tags);
    });

    self.on('newTagSaveDone',function (){

      tags         = [];
      var tempTags = [];

      //get newly created tags from big three types
      _.each(self.data.newItemTags, function(newItemTag){
        tags.push(newItemTag);
      });

      tempTags.push.apply(tempTags,self.$("#tag_topic").select2('data'));
      tempTags.push.apply(tempTags,self.$("#tag_skill").select2('data'));
      tempTags.push.apply(tempTags,self.$("#tag_location").select2('data'));
      tempTags.push.apply(tempTags,self.$("#tag_agency").select2('data'));

      //see if there are any previously created big three tags and add them to the tag array
      _.each(tempTags,function(tempTag){
          if ( tempTag.id !== tempTag.name ){
          tags.push(tempTag);
        }
      });

      var tagMap = {};

        // if a different profile is being edited, add its userId
        if (self.model.toJSON().id !== window.cache.currentUser.id) {
          tagMap.userId = self.model.toJSON().id;
        }

      async.forEach(tags, function(tag, callback){
        //diffAdd,self.model.attributes.id,"taskId",callback
        return self.tagFactory.addTag(tag,tagMap.userId,"userId",callback);
      }, function(err) {
        self.model.trigger("profile:tags:save:success", err);
      });
    });

    this.listenTo(self.model, "profile:tags:save", function (tags) {

      var newTags = [];

      newTags = newTags.concat(
        self.$("#tag_topic").select2('data'),
        self.$("#tag_skill").select2('data'),
        self.$("#tag_location").select2('data'),
        self.$("#location").select2('data'),
        self.$("#tag_agency").select2('data')
      );

      var removeTag = function(type, done) {
        if (self.model[type]) {
          // delete the existing tag
          $.ajax({
            url: '/api/tag/' + self.model[type].tagId,
            type: 'DELETE',
          }).done(function (data) {
            return done();
          });
          return;
        }
        return done();
      }

      var addTag = function (tag, done) {
        // the tag is invalid or hasn't been selected
        if (!tag || !tag.id) {
          return done();
        }
        // the tag already is stored in the db
        if (tag.tagId) {
          return done();
        }
        var tagMap = {
          tagId: tag.id
        };
        // if a different profile is being edited, add its userId
        if (self.model.toJSON().id !== window.cache.currentUser.id) {
          tagMap.userId = self.model.toJSON().id;
        }
        $.ajax({
          url: '/api/tag',
          type: 'POST',
          data: tagMap
        }).done(function (data) {
          done();
        });
      }

      async.forEach(
        newTags,
        function(newTag, callback) {
          return self.tagFactory.addTagEntities(newTag,self,callback);
        },
        function(err) {
          if (err) return next(err);

          tags = _.filter(tags, function(tag) {
            return (tag && tag.id !== tag.name);
          });
          async.each(['agency','location'], removeTag, function (err) {
            async.each(tags, addTag, function (err) {
              self.trigger("newTagSaveDone");
            });
          });
        }
      );

    });

    this.listenTo(self.model, "profile:tags:save:success", function (err) {
      setTimeout(function() { $("#profile-save, #submit").attr("disabled", "disabled") },0);
      $("#profile-save, #submit").removeClass("btn-primary");
      $("#profile-save, #submit").addClass("btn-success");
      self.data.saved = true;
      Backbone.history.navigate('profile/' + self.model.toJSON().id, { trigger: true });
    });

    this.listenTo(self.model, "profile:save:fail", function (data) {
      $("#submit").button('fail');
    });
    this.listenTo(self.model, "profile:removeAuth:success", function (data, id) {
      self.render();
    });
    this.listenTo(self.model, "profile:input:changed", function (e) {
      $("#profile-save, #submit").button('reset');
      $("#profile-save, #submit").removeAttr("disabled");
      $("#profile-save, #submit").removeClass("btn-success");
      $("#profile-save, #submit").addClass("btn-c2");
    });
  },

  initializeLikes: function() {
    $("#like-number").text(this.model.attributes.likeCount);
    if (parseInt(this.model.attributes.likeCount) === 1) {
      $("#like-text").text($("#like-text").data('singular'));
    } else {
      $("#like-text").text($("#like-text").data('plural'));
    }
    if (this.model.attributes.like) {
      $("#like-button-icon").removeClass('fa fa-star-o');
      $("#like-button-icon").addClass('fa fa-star');
    }
  },

  initializeSelect2: function () {
    var self = this;

    var formatResult = function (object, container, query) {
      return object.name;
    };

    var modelJson = this.model.toJSON();

    var locationSettings = {
      placeholder: 'Select a Location',
      formatResult: formatResult,
      formatSelection: formatResult,
      minimumInputLength: 1,
      data: [ location ],
      createSearchChoice: function (term, values) {
        var vals = values.map(function(value) {
          return value.value.toLowerCase();
        });

        //unmatched = true is the flag for saving these "new" tags to tagEntity when the opp is saved
        return (vals.indexOf(term.toLowerCase()) >=0) ? false : {
          tagType: 'location',
          id: term,
          value: term,
          temp: true,
          name: "<b>"+term+"</b> <i>search for this location</i>"
        };
      },
      ajax: {
        url: '/api/ac/tag',
        dataType: 'json',
        data: function (term) {
          return {
            type: 'location',
            q: term
          };
        },
        results: function (data) {
          return { results: data };
        }
      }
    };

    $("#company").select2({
      placeholder: 'Select an Agency',
      formatResult: formatResult,
      formatSelection: formatResult,
      minimumInputLength: 2,
      ajax: {
        url: '/api/ac/tag',
        dataType: 'json',
        data: function (term) {
          return {
            type: 'agency',
            q: term
          };
        },
        results: function (data) {
          return { results: data };
        }
      }
    });
    if (modelJson.agency) {
      $("#company").select2('data', modelJson.agency.tag);
    }

    $("#topics").on('change', function (e) {
      self.model.trigger("profile:input:changed", e);
    });

    $("#skills").on('change', function (e) {
      self.model.trigger("profile:input:changed", e);
    });

    $("#company").on('change', function (e) {
      self.model.trigger("profile:input:changed", e);
    });
    $('#location').select2(locationSettings).on('select2-selecting', function(e) {
      var $el = self.$(e.currentTarget),
          el = this;
      if (e.choice.temp) {
        this.temp = true;
        $('#location').select2('data', e.choice.name);
        $.get('/api/location/suggest?q=' + e.choice.value, function(d) {
          d = _(d).map(function(item) {
            return {
              id: item.name,
              text: item.name,
              name: item.name,
              unmatched: true,
              tagType: 'location',
              data: _(item).omit('name')
            };
          });
          el.reload = true;
          el.open = true;
          $('#location').select2({ data: d }).select2('open');
        });
      } else {
        delete this.temp;
      }
    }).on('select2-open', function(e) {
      if (!this.reload && this.open) {
        delete this.open;
        delete this.temp;
        var cache = $("#location").select2('data');
        setTimeout(function() {
          $("#location").select2(locationSettings)
            .select2('data', cache)
            .select2('open');
        }, 0);
      } else if (this.reload && this.open) {
        delete this.reload;
      }
    });
    if (modelJson.location) {
      $("#location").select2('data', modelJson.location.tag);
    }
    $("#location").on('change', function (e) {
      self.model.trigger("profile:input:changed", e);
    });
  },

  initializeTextArea: function () {
    if (this.md) { this.md.cleanup(); }
    this.md = new MarkdownEditor({
      data: this.model.toJSON().bio,
      el: ".markdown-edit",
      id: 'bio',
      placeholder: 'A short biography.',
      title: 'Biography',
      rows: 6
    }).render();
  },

  fieldModified: function (e) {
    this.model.trigger("profile:input:changed", e);
  },

  profileCancel: function (e) {
    e.preventDefault();
    Backbone.history.navigate('profile/' + this.model.toJSON().id, { trigger: true });
  },

  profileSave: function (e) {
    e.preventDefault();
    $("#profile-form").submit();
  },

  profileSubmit: function (e) {
    e.preventDefault();
    $("#profile-save, #submit").button('loading');
    setTimeout(function() { $("#profile-save, #submit").attr("disabled", "disabled") }, 0);
    var data = {
          name: $("#name").val(),
          title: $("#title").val(),
          bio: $("#bio").val()
        },
        email = this.model.get('emails')[0],
        self = this;

    if ($("#profile-email").val() !== email.email) {
      $.ajax({
        url: '/api/useremail/' + email.id,
        dataType: 'json',
        method: 'put',
        data: { email: $("#profile-email").val() },
        success: function() { self.model.trigger("profile:save", data); },
        error: function() {
          var msg = 'Failed to update your email address. Please verify it \
                     is a valid email address and try again.';
          $("#email-update-alert").html(msg);
          $("#email-update-alert").show();
        }
      });
    } else {
      this.model.trigger("profile:save", data);
    }
  },

  removeAuth: function (e) {
    if (e.preventDefault) e.preventDefault();
    var node = $(e.target);
    // walk up the tree until we get to the marked node
    while (!(node.hasClass("removeAuth"))) {
      node = node.parent();
    }
    this.model.trigger("profile:removeAuth", node.attr("id"));
  },

  like: function (e) {
    e.preventDefault();
    var self = this;
    var child = $(e.currentTarget).children("#like-button-icon");
    var likenumber = $("#like-number");
    // Not yet liked, initiate like
    if (child.hasClass('fa-star-o')) {
      child.removeClass('fa-star-o');
      child.addClass('fa fa-star');
      likenumber.text(parseInt(likenumber.text()) + 1);
      if (parseInt(likenumber.text()) === 1) {
        $("#like-text").text($("#like-text").data('singular'));
      } else {
        $("#like-text").text($("#like-text").data('plural'));
      }
      $.ajax({
        url: '/api/like/likeu/' + self.model.attributes.id
      }).done( function (data) {
        // liked!
        // response should be the like object
        // console.log(data.id);
      });
    }
    // Liked, initiate unlike
    else {
      child.removeClass('fa-star');
      child.addClass('fa-star-o');
      likenumber.text(parseInt(likenumber.text()) - 1);
      if (parseInt(likenumber.text()) === 1) {
        $("#like-text").text($("#like-text").data('singular'));
      } else {
        $("#like-text").text($("#like-text").data('plural'));
      }
      $.ajax({
        url: '/api/like/unlikeu/' + self.model.attributes.id
      }).done( function (data) {
        // un-liked!
        // response should be null (empty)
      });
    }
  },
  cleanup: function () {
    if (this.md) { this.md.cleanup(); }
    if (this.tagView) { this.tagView.cleanup(); }
    if (this.projectView) { this.projectView.cleanup(); }
    if (this.taskView) { this.taskView.cleanup(); }
    if (this.volView) { this.volView.cleanup(); }
    removeView(this);
  },

});

module.exports = ProfileShowView;

},{"../../../../components/markdown_editor":104,"../../../../components/modal":106,"../../../../components/tag_factory":112,"../../../../config/login.json":114,"../../../../config/ui.json":116,"../../../../mixins/utilities":128,"../../../tag/show/views/tag_show_view":84,"../../email/views/profile_email_view":59,"../templates/profile_email_template.html":62,"../templates/profile_show_template.html":65,"./profile_activity_view":66,"async":131,"backbone":133,"blueimp-file-upload/js/jquery.fileupload.js":134,"blueimp-file-upload/js/jquery.iframe-transport":135,"marked":155,"underscore":159}],70:[function(require,module,exports){
module.exports = "<form action=\"\" id=\"project-form\">\n  <div class=\"modal-body\">\n    <fieldset>\n      <div class=\"form-group\">\n        <label for=\"project-form-title\"><span data-i18n=\"Project\">Project</span> Title</label>\n        <input type=\"text\" class=\"project-title-form form-control\" id=\"project-form-title\" name=\"project-form-title\" placeholder=\"Title\" data-validate=\"empty,count100\">\n        <span class=\"help-block error-empty\" style=\"display:none;\">You must enter a title.</span>\n        <span class=\"help-block error-count100\" style=\"display:none;\">The title must be less than 100 characters.</span>\n      </div>\n      <div class=\"form-group\">\n        <label for=\"project-form-description\"><span data-i18n=\"Project\">Project</span> Description</label>\n        <div class=\"markdown-edit\"></div>\n        <span class=\"help-block error-empty\" style=\"display:none;\">You must enter a description.</span>\n      </div>\n    </fieldset>\n  </div>\n  <div class=\"modal-footer\">\n    <button type=\"button\" class=\"btn btn-c0\" data-dismiss=\"modal\">Cancel</button>\n    <input type=\"submit\" class=\"btn btn-c2 btn-add-project\" id=\"submit\" value=\"Add Project\"/>\n  </div>\n</form>\n";

},{}],71:[function(require,module,exports){
var Bootstrap = require('bootstrap');
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var MarkdownEditor = require('../../../../components/markdown_editor');
var ProjectsCollection = require('../../../../entities/projects/projects_collection');
var ProjectFormTemplate = require('../templates/project_new_form_template.html');


var ProjectFormView = Backbone.View.extend({

  events: {
    "blur #project-form-title"      : "v",
    "blur #project-form-description": "v",
    "submit #project-form"          : "post"
  },

  render: function () {
    var template = _.template(ProjectFormTemplate);
    this.$el.html(template);

    this.$el.i18n();
    this.initializeTextArea();
    this.$(".btn-add-project").val('Add ' + i18n.t('Project'));
    return this;
  },

  v: function (e) {
    return validate(e);
  },

  initializeTextArea: function () {
    if (this.md) { this.md.cleanup(); }
    this.md = new MarkdownEditor({
      data: '',
      el: ".markdown-edit",
      id: 'project-form-description',
      placeholder: 'A description of your ' + i18n.t('project') + ' that explains the focus, objectives, and deliverables.',
      title: i18n.t('Project') + ' Description',
      rows: 6,
      validate: ['empty']
    }).render();
  },

  post: function (e) {
    if (e.preventDefault) e.preventDefault();

    // validate input fields
    var validateIds = ['#project-form-title', '#project-form-description'];
    var abort = false;
    for (i in validateIds) {
      var iAbort = validate({ currentTarget: validateIds[i] });
      abort = abort || iAbort;
    }
    if (abort === true) {
      return;
    }

    // process project form
    var data;
    data = {
      title       : this.$(".project-title-form").val(),
      description : this.$("#project-form-description").val()
    };

    this.collection.trigger("project:save", data);
  },

  cleanup: function () {
    if (this.md) { this.md.cleanup(); }
    removeView(this);
  }

});

module.exports = ProjectFormView;

},{"../../../../components/markdown_editor":104,"../../../../entities/projects/projects_collection":123,"../../../../mixins/utilities":128,"../templates/project_new_form_template.html":70,"backbone":133,"bootstrap":138,"underscore":159}],72:[function(require,module,exports){
var _ = require('underscore');
var async = require('async');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var Popovers = require('../../../../mixins/popovers');
var BaseController = require('../../../../base/base_controller');
var ProjectItemView = require('../views/project_item_view');
var ProjectItemCoreMetaView = require('../views/project_item_coremeta_view');
var ProjectownerShowView = require('../../../projectowner/show/views/projectowner_show_view');
var AttachmentView = require('../../../attachment/views/attachment_show_view');
var TaskListController = require('../../../tasks/list/controllers/task_list_controller');
var EventListController = require('../../../events/list/controllers/event_list_controller');
var CommentListController = require('../../../comments/list/controllers/comment_list_controller');
var CommentFormView = require('../../../comments/new/views/comment_form_view');
var ModalComponent = require('../../../../components/modal');
var ModalAlert = require('../../../../components/modal_alert');
var TaskModel = require('../../../../entities/tasks/task_model');
var ProjectOpenTasksWarningTemplate = require('../templates/project_open_tasks_warning_template.html');


var popovers = new Popovers();

Project = {};

Project.ShowController = BaseController.extend({

  el: "#container",

  // Set the model to null, before it is fetched from the server.
  // This allows us to clear out the previous data from the list_view,
  // and get ready for the new data for the project show view.
  model: null,

  events: {
    "click #like-button"              : "like",
    "keyup .comment-content"          : "search",
    "click #tag-save"                 : "tagSave",
    "click #tag-create"               : "tagCreate",
    "click .tag-delete"               : "tagDelete",
    "click #project-close"            : "stateClose",
    "click #project-reopen"           : "stateReopen",
    'click #editProject'              : 'toggleEditMode',
    "mouseenter .project-people-div"  : popovers.popoverPeopleOn,
    "click .project-people-div"       : popovers.popoverClick
  },

  // The initialize method is mainly used for event bindings (for effeciency)
  initialize: function (options) {
    var self = this;

    this.router = options.router;
    this.id = options.id;
    this.data = options.data;
    this.action = options.action;

    this.model.trigger("project:model:fetch", this.model.id);
    this.listenTo(this.model, "project:model:fetch:success", function (projectModel) {
      self.model = projectModel;
      if (self.action == 'edit') {
        var model = this.model.toJSON();
        // check if the user owns the task
        var owner = model.isOwner;
        if (owner !== true) {
          // if none of these apply, are they an admin?
          if (window.cache.currentUser) {
            if (window.cache.currentUser.isAdmin === true) {
              owner = true;
            }
          }
        }
        // if not the owner, trigger the login dialog.
        if (owner !== true) {
          window.cache.userEvents.trigger("user:request:login", {
            message: "You are not the owner of this project. <a class='link-backbone' href='/projects/" + model.id + "'>View the project instead.</a>",
            disableClose: true
          });
          return;
        }
      }
      self.initializeItemView();
    });

    this.model.on("project:show:rendered", function () {
      self.initializeItemCoreMetaView();
      self.initializeOwners();
      self.initializeItemViewControllers();
      self.initializeHandlers();
      self.initializeLikes();
      self.initializeUI();
    });
  },

  initializeItemView: function () {
    if (this.projectShowItemView) this.projectShowItemView.cleanup();
    this.projectShowItemView  = new ProjectItemView({
                              model: this.model,
                              action: this.action,
                              data: this.data
                            }).render();
  },

  initializeItemCoreMetaView: function () {
    if (this.projectShowItemCoreMetaView) this.projectShowItemCoreMetaView.cleanup();
    this.projectShowItemCoreMetaView  = new ProjectItemCoreMetaView({
                              model: this.model,
                              action: this.action,
                              data: this.data
                             }).render();
  },


  initializeOwners : function(){
    if (this.projectownerShowView) this.projectownerShowView.cleanup();
    this.projectownerShowView = new ProjectownerShowView({
                              model: this.model,
                              action: this.action,
                              data: this.data
                             }).render();
  },

  initializeItemViewControllers: function () {
    if (this.action != 'edit') {
      // Tasks
      if (this.taskListController) this.taskListController.cleanup();
      this.taskListController = new TaskListController({
        projectId: this.model.id
      });

      // Events
      if (this.eventListController) this.eventListController.cleanup();
      this.eventListController = new EventListController({
        projectId: this.model.id
      });
      // Comments
      if (this.commentListController) this.commentListController.cleanup();
      this.commentListController = new CommentListController({
        target: 'project',
        id: this.model.id
      });
      // Attachments
      if (this.attachmentView) this.attachmentView.cleanup();
      this.attachmentView = new AttachmentView({
        target: 'project',
        id: this.model.attributes.id,
        action: this.action,
        data: this.data,
        owner: this.model.attributes.isOwner,
        el: '.attachment-wrapper'
      }).render();
    }
  },

  initializeLikes: function() {
    $("#like-number").text(this.model.attributes.likeCount);
    if (parseInt(this.model.attributes.likeCount) === 1) {
      $("#like-text").text($("#like-text").data('singular'));
    } else {
      $("#like-text").text($("#like-text").data('plural'));
    }
    if (this.model.attributes.like) {
      $("#like-button-icon").removeClass('fa-star-o');
      $("#like-button-icon").addClass('fa fa-star');
    }
  },

  initializeHandlers: function() {
    this.listenTo(this.model, "project:update:state:success", function (data) {
      if (data.attributes.state == 'closed') {
        $("#li-project-close").hide();
        $("#li-project-reopen").show();
        $("#alert-closed").show();
      } else {
        $("#li-project-close").show();
        $("#li-project-reopen").hide();
        $("#alert-closed").hide();
      }
    });
  },

  initializeUI: function() {
    popovers.popoverPeopleInit(".project-people-div");
  },

  toggleEditMode: function(e){
    if (e.preventDefault) e.preventDefault();
    var action = '';
    if (!(this.action && this.action == 'edit')) {
      action = '/edit';
    }
    Backbone.history.navigate('projects/' + this.id + action, { trigger: true });
  },

  stateClose: function (e) {
    if (e.preventDefault) e.preventDefault();
    var self = this;

    var projectTasks = self.model.hasOpenTasks(self.taskListController.collection);
    if (this.modalAlert) { this.modalAlert.cleanup(); }
    if (this.modalComponent) { this.modalComponent.cleanup(); }
    this.modalComponent = new ModalComponent({
      el: "#modal-close",
      id: "check-close",
      modalTitle: "Close "+i18n.t("Project")
    }).render();

    var count = 0;
    if ( projectTasks.hasOpenTasks ){
      var modalContent = _.template(ProjectOpenTasksWarningTemplate)({count: projectTasks.count});
      var submitLabel = "I Understand and Want to Close This "+i18n.t("Project");
    } else {
      var modalContent = '<p>Are you sure you want to close this '+i18n.t("project")+'?  Once the '+i18n.t("project")+' is closed, participants will no longer be able to contribute.</p>';
      var submitLabel = "Close "+i18n.t("Project");
    }

    this.modalAlert = new ModalAlert({
      el: "#check-close .modal-template",
      modalDiv: '#check-close',
      content: modalContent,
      cancel: 'Cancel',
      submit: submitLabel,
      callback: function (e) {
        // user clicked the submit button
        if ( projectTasks.hasOpenTasks ) { self.model.trigger("project:update:tasks:orphan",self.taskListController.collection); }
        self.model.trigger("project:update:state", 'closed');
        self.initializeItemView();
      }
    }).render();
  },

  stateReopen: function (e) {
    if (e.preventDefault) e.preventDefault();
    this.model.trigger("project:update:state", 'open');
  },

  like: function (e) {
    if (e.preventDefault) e.preventDefault();
    var self = this;
    var child = $(e.currentTarget).children("#like-button-icon");
    var likenumber = $("#like-number");
    // Not yet liked, initiate like
    if (child.hasClass('fa-star-o')) {
      child.removeClass('fa-star-o');
      child.addClass('fa fa-star');
      likenumber.text(parseInt(likenumber.text()) + 1);
      if (parseInt(likenumber.text()) === 1) {
        $("#like-text").text($("#like-text").data('singular'));
      } else {
        $("#like-text").text($("#like-text").data('plural'));
      }
      $.ajax({
        url: '/api/like/like/' + this.model.attributes.id
      }).done( function (data) {
        // liked!
        // response should be the like object
        // console.log(data.id);
      });
    }
    // Liked, initiate unlike
    else {
      child.removeClass('fa-star');
      child.addClass('fa-star-o');
      likenumber.text(parseInt(likenumber.text()) - 1);
      if (parseInt(likenumber.text()) === 1) {
        $("#like-text").text($("#like-text").data('singular'));
      } else {
        $("#like-text").text($("#like-text").data('plural'));
      }
      $.ajax({
        url: '/api/like/unlike/' + this.model.attributes.id
      }).done( function (data) {
        // un-liked!
        // response should be null (empty)
      });
    }
  },

  // ---------------------
  //= Utility Methods
  // ---------------------
  cleanup: function() {
    if (this.projectShowItemCoreMetaView) this.projectShowItemCoreMetaView.cleanup();
    if (this.taskListController) this.taskListController.cleanup();
    if (this.eventListController) this.eventListController.cleanup();
    if (this.commentListController) this.commentListController.cleanup();
    if (this.projectShowItemView) this.projectShowItemView.cleanup();
    if (this.projectownerShowView) this.projectownerShowView.cleanup();
    if (this.attachmentView) this.attachmentView.cleanup();
    removeView(this);
  }

});

module.exports = Project.ShowController;

},{"../../../../base/base_controller":101,"../../../../components/modal":106,"../../../../components/modal_alert":107,"../../../../entities/tasks/task_model":124,"../../../../mixins/popovers":126,"../../../../mixins/utilities":128,"../../../attachment/views/attachment_show_view":23,"../../../comments/list/controllers/comment_list_controller":33,"../../../comments/new/views/comment_form_view":40,"../../../events/list/controllers/event_list_controller":41,"../../../projectowner/show/views/projectowner_show_view":79,"../../../tasks/list/controllers/task_list_controller":88,"../templates/project_open_tasks_warning_template.html":75,"../views/project_item_coremeta_view":76,"../views/project_item_view":77,"async":131,"backbone":133,"underscore":159}],73:[function(require,module,exports){
module.exports = "<div id=\"project-coremeta-show\" class=\"coremeta-form-toggle\">\n\n    <h1><%= data.title %></h1>\n\n    <div class=\"project-description\">\n      <%= data.descriptionHtml %>\n    </div>\n\n\n</div> <!-- /main-section -->\n<div id=\"project-coremeta-form\" class=\"coremeta-form-toggle coremeta-admin\">\n  <div class=\"row\">\n    <div class=\"col-md-12\">\n      <form role=\"form\">\n\n        <div class=\"alert alert-success\" id=\"project-coremeta-success\" style=\"display: none;\">\n          Your <span data-i18n=\"project\">project</span> has been successfully updated!\n          <a class=\"close\" data-dismiss=\"alert\" href=\"#\" aria-hidden=\"true\">&times;</a>\n        </div>\n\n        <!-- RIGHT MAIN BAR -->\n        <div class=\"form-group\">\n          <h2 class=\"box-pad-t\"><span data-i18n=\"Project\">Project</span> Title</h2>\n          <input id=\"project-edit-form-title\" class=\"form-control input-lg\" value=\"<%= data.title %>\" type=\"text\" data-validate=\"empty,count100\" title=\"Title\"/>\n          <span class=\"help-block error-empty\" style=\"display:none;\">You must enter a <span data-i18n=\"project\">project</span> title.</span>\n          <span class=\"help-block error-count100\" style=\"display:none;\">Your title must be less than 100 characters.</span>\n        </div>\n        <div class=\"form-group\">\n          <h2 class=\"box-pad-t\"><span data-i18n=\"Project\">Project</span> Description</h2>\n          <div class=\"markdown-edit\">\n          </div>\n          <span class=\"help-block error-empty\" style=\"display:none;\">You must enter a <span data-i18n=\"project\">project</span> description.</span>\n        </div>\n      </form>\n    </div>\n  </div>\n  <div class=\"row\">\n    <div class=\"col-md-12 form-group\">\n\n      <div class=\"pull-right coremeta-admin\" id=\"project-coremeta-buttons\">\n          <button class=\"btn btn-c0\" id=\"coremeta-view\">Discard Changes</button>\n          <button class=\"btn btn-c2\" id=\"coremeta-save\">Save <span data-i18n=\"Project\">Project</span></button>\n      </div>\n\n    </div>\n  </div>\n</div>\n";

},{}],74:[function(require,module,exports){
module.exports = "<!-- ALERTS -->\n<div class=\"alert alert-danger\" id=\"alert-closed\" style=\"<% if (data.state != 'closed') { %>display: none;<% } %>\">This <span data-i18n=\"project\">project</span> is <strong>closed</strong>.  It is no longer active, and no more modifications may be made.</div>\n\n<div class=\"row\">\n  <div class=\"col-sm-4 col-md-4 col-lg-4 project-sidebar md-nopadding-right sm-nopadding\">\n    <!-- LEFT SIDEBAR -->\n\n    <div class=\"row\">\n      <div class=\"col-md-12 box project-header-wrapper\">\n        <% if (data.coverId) { %>\n        <div id=\"project-header\" style=\"background-image:url('/api/file/get/<%= data.coverId %>');\">\n        <% } else { %>\n        <div id=\"project-header\" style=\"background-image:url('/images/project_default.png');\">\n        <% } %>\n          <div class=\"btn btn-c2 fileinput-button\" <% if (!(data.isOwner || user.isAdmin) || !edit) { %>style=\"display:none;\"<% } %>>\n            <i class=\"fa fa-camera fa-lg\" title=\"Change Cover Photo\" id=\"fileupload-icon\"></i>\n            <input id=\"fileupload\" type=\"file\" name=\"files[]\" title=\"Change Cover Photo\">\n          </div>\n        </div>\n        <div id=\"file-upload-progress-container\" style=\"display: none;\" class=\"progress progress-striped active\">\n          <div id=\"file-upload-progress\" class=\"progress-bar\" style=\"width: 0\"></div>\n        </div>\n        <div class=\"file-upload-alert alert alert-warning\" style=\"display:none;\">\n        </div>\n      </div>\n    </div>\n\n  </div>\n\n  <div class=\"col-sm-8 col-md-8 col-lg-8 md-nopadding sm-nopadding\">\n\n    <!-- RIGHT MAIN BAR -->\n    <div class=\"row\">\n      <div class=\"col-sm-8 col-md-9 sm-nopadding\">\n        <div class=\"main-section\">\n          <div class=\"box box-main\" id=\"project-coremeta-wrapper\">\n          </div>\n        </div>\n      </div>\n      <div class=\"col-sm-4 col-md-3 padding-left-none sm-nopadding\">\n        <div class=\"box padding-none\">\n\n          <div class=\"navbar-side like-row border-bottom\">\n            <% if (user) { %>\n            <button id=\"like-button\" class=\"btn btn-link like-button\" title=\"Click to Like or Unlike\">\n            <% } else { %>\n            <span class=\"like-button\">\n            <% } %>\n              <i id=\"like-button-icon\" class=\"fa fa-star-o fa-lg gold\"></i>\n            <% if (user) { %>\n            </button>\n            <% } else { %>\n            </span>\n            <% } %>\n            <span class=\"like-number\" id=\"like-number\"><%- data.likeCount %></span>\n            <span class=\"like-plural\" id=\"like-text\" data-plural=\"likes\" data-singular=\"like\">likes</span>\n          </div>\n          <div class=\"navbar-side <% if (data.isOwner || user.isAdmin) { %>border-bottom<% } %>\">\n            <ul class=\"nav nav-pills nav-stacked\">\n              <li>\n                <a href=\"#\" id=\"email\"><i class=\"fa fa-envelope-o\"></i> <span class=\"box-icon-text\">Share</span></a>\n              </li>\n              <li>\n                <a href=\"webcal://<%- hostname %>/api/event/ical/<%- data.id %>\"><span class=\"fa fa-calendar\"></span> <span class=\"box-icon-text\">Calendar</span></a>\n              </li>\n            </ul>\n          </div>\n          <% if (data.isOwner || user.isAdmin) { %>\n          <div class=\"navbar-side\">\n            <div id=\"modal-close\"></div>\n            <ul class=\"nav nav-pills nav-stacked\">\n              <li>\n                <a href=\"#\" id=\"editProject\"><i class=\"fa fa-pencil\"></i> <span class=\"box-icon-text\">Edit <span data-i18n=\"Project\">Project</span></span></a>\n              </li>\n              <% if ( !edit ) { %>\n              <li id=\"li-project-close\" style=\"<% if (data.state == 'closed') { %>display: none;<% } %>\">\n                <a href=\"#\" id=\"project-close\"><i class=\"fa fa-times-circle\"></i> <span class=\"box-icon-text\">Close <span data-i18n=\"Project\">Project</span></span></a>\n              </li>\n              <li id=\"li-project-reopen\" style=\"<% if (data.state != 'closed') { %>display: none;<% } %>\">\n                <a href=\"#\" id=\"project-reopen\"><i class=\"fa fa-share\"></i> <span class=\"box-icon-text\">Reopen <span data-i18n=\"Project\">Project</span></span></a>\n              </li>\n              <% } %>\n              <!--\n              <li>\n                <a href=\"#\" id=\"project-delete\"><i class=\"fa fa-trash-o\"></i> <span class=\"box-icon-text\">Delete <span data-i18n=\"Project\">Project</span></span></a>\n              </li>\n              -->\n            </ul>\n          </div>\n          <% } %>\n        </div>\n      </div>\n    </div>\n\n  </div>\n</div>\n<div class=\"row\">\n\n  <div class=\"col-sm-5 col-md-4 md-nopadding-right sm-nopadding\">\n\n    <div class=\"row\">\n      <div class=\"col-md-12 box\">\n        <div class=\"box-main tag-wrapper\">\n        </div>\n      </div>\n    </div>\n\n    <% if (!(data.isOwner || user.isAdmin) || !edit) { %>\n    <div class=\"row\">\n      <div class=\"col-md-12 box\">\n        <div class=\"attachment-wrapper\">\n        </div>\n      </div>\n    </div>\n    <% } %>\n\n  </div>\n  <div class=\"col-sm-7 col-md-8 md-nopadding-right sm-nopadding\">\n\n    <div class=\"row\">\n      <div class=\"col-md-12 sm-nopadding md-nopadding\">\n        <div class=\"box\" id=\"projectowner-wrapper\">\n        </div>\n      </div>\n    </div>\n\n    <% if (!(data.isOwner || user.isAdmin) || !edit) { %>\n    <div class=\"row\">\n      <div class=\"col-md-12 sm-nopadding md-nopadding\">\n        <!-- BEGIN EVENTS -->\n        <div class=\"box\" id=\"event-list-wrapper\">\n        </div>\n        <!-- END EVENTS -->\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"col-md-12 sm-nopadding md-nopadding\">\n        <!-- BEGIN TASKS -->\n        <div class=\"wrapper-addTask\"></div>\n        <div class=\"box\" id=\"task-list-wrapper\" data-project-id=\"<%= data.id %>\">\n        </div>\n        <!-- END TASKS -->\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"col-md-12 sm-nopadding md-nopadding\">\n\n        <div class=\"box comment-list-wrapper\" style=\"clear: both;\">\n        </div>\n      </div>\n    </div>\n\n    <% } %> <!-- end of check for edit mode -->\n\n    <!-- add a space at the bottom of the page until we figure out what goes here -->\n    <div style=\"height: 50px;\">\n    </div>\n\n  </div>\n</div>\n";

},{}],75:[function(require,module,exports){
module.exports = "<div>\n  <p>This <span data-i18n=\"project\">project</span> has <strong><%- count %></strong> open, or in progress, opportunities. Closing this <span data-i18n=\"project\">project</span> will cause any such opportunities to be orphaned (no longer associated with any <span data-i18n=\"project\">project</span>).</p>\n\n  <p>Are you sure you wish to proceed?</p>\n\n</div>\n";

},{}],76:[function(require,module,exports){
var _ = require('underscore');
var async = require('async');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var marked = require('marked');
var MarkdownEditor = require('../../../../components/markdown_editor');
var Popovers = require('../../../../mixins/popovers');
var ModalComponent = require('../../../../components/modal');
var ProjectItemCoreMetaTemplate = require('../templates/project_item_coremeta_template.html');


//if(_.isUndefined(popovers)){var popovers = new Popovers();}

var ProjectItemCoreMetaView = Backbone.View.extend({

  el: "#project-coremeta-wrapper",
  model : null,

  // Set the model to null, before it is fetched from the server.
  // This allows us to clear out the previous data from the list_view,
  // and get ready for the new data for the project show view.
  // model: null,

  events: {
    "blur #project-edit-form-title"            : "v",
    "blur #project-edit-form-description"      : "v",
    "click #coremeta-save"                     : "saveCoreMeta",
    "click #coremeta-view"                     : "viewProject"
  },

  // The initialize method is mainly used for event bindings (for effeciency)
  initialize: function (options) {
    var self = this;
    this.options = options;
    this.data = options.data;
    this.action = options.action;
    this.user = window.cache.currentUser || {};
    this.edit = false;
    if (this.options.action) {
      if (this.options.action == 'edit') {
        this.edit = true;
      }
    }

    this.model.on("project:coremeta:show:rendered", function () {
      self.initializeTextArea();
      self.initializeToggledElements();
    });

    this.model.on("project:save:success", function (data) {
      self.render();
      $('#project-coremeta-success').show();
      self.viewProject({});
    });

    this.model.on("project:tags:save:success", function (data) {
      self.render();
      $('#project-coremeta-success').show();
      self.viewProject({});
    });

  },

  render: function () {
    var data = {
      data: this.model.toJSON()
    };
    // convert description to html using markdown syntax
    data.data.descriptionHtml = marked(data.data.description || '');
    var compiledTemplate = _.template(ProjectItemCoreMetaTemplate)(data);
    this.$el.html(compiledTemplate);
    this.$el.i18n();
    this.model.trigger("project:coremeta:show:rendered", data);

    return this;
  },

  initializeTextArea: function () {
    if (this.md) { this.md.cleanup(); }
    this.md = new MarkdownEditor({
      data: this.model.toJSON().description,
      el: ".markdown-edit",
      id: 'project-edit-form-description',
      title: 'Project Description',
      rows: 6,
      validate: ['empty']
    }).render();
  },

  initializeToggledElements: function() {
    var self = this;
    if ((this.model.attributes.isOwner || this.user.isAdmin) && this.edit){
      self.$('#project-coremeta-form').show();
      self.$('#project-coremeta-show').hide();
    }
    else{
      self.$('.coremeta-admin').hide();
    }
  },

  v: function(e) {
    return validate(e);
  },

  saveCoreMeta: function (e){
    if (e.preventDefault) e.preventDefault();
    if (!(this.model.attributes.isOwner || this.user.isAdmin) && this.edit) return false;

    // validate the form fields
    var validateIds = ['#project-edit-form-title', '#project-edit-form-description'];
    var abort = false;
    for (var i in validateIds) {
      var iAbort = validate({ currentTarget: validateIds[i] });
      abort = abort || iAbort;
    }
    if (abort) {
      return;
    }

    // process and update the data model for the project
    var self = this;
    var pId = self.model.attributes.id;
    var title = self.$('#project-edit-form-title').val();
    var description = self.$('#project-edit-form-description').val();
    var params = { title :title, description: description };

    self.model.trigger("project:tag:update:start");
    self.model.trigger("project:model:update", params);
  },

  viewProject: function (e) {
    if (e.preventDefault) e.preventDefault();
    Backbone.history.navigate('projects/' + this.model.attributes.id, { trigger: true });
  },

  // ---------------------
  //= Utility Methods
  // ---------------------
  cleanup: function() {
    if (this.md) { this.md.cleanup(); }
    removeView(this);
  }

});

module.exports = ProjectItemCoreMetaView;

},{"../../../../components/markdown_editor":104,"../../../../components/modal":106,"../../../../mixins/popovers":126,"../../../../mixins/utilities":128,"../templates/project_item_coremeta_template.html":73,"async":131,"backbone":133,"marked":155,"underscore":159}],77:[function(require,module,exports){
var jqIframe = require('blueimp-file-upload/js/jquery.iframe-transport');
var jqFU = require('blueimp-file-upload/js/jquery.fileupload.js');
var select2 = require('select2');
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var async = require('async');
var ProjectShowTemplate = require('../templates/project_item_view_template.html');
var TagShowView = require('../../../tag/show/views/tag_show_view');
var TagFactory = require('../../../../components/tag_factory');


var ProjectShowView = Backbone.View.extend({

  el: "#container",

  events: {
  },

  initialize: function (options) {
    this.options = options;
    this.data = options.data;
    this.action = options.action;
    this.edit = false;
    if (this.options.action) {
      if (this.options.action == 'edit') {
        this.edit = true;
      }
    }
    this.tagFactory = new TagFactory();
    this.data.newItemTags = [];
  },

  render: function () {
    var compiledTemplate;
    var data = {
      hostname: window.location.hostname,
      data: this.model.toJSON(),
      user: window.cache.currentUser || {},
      edit: this.edit
    };

    compiledTemplate = _.template(ProjectShowTemplate)(data);
    this.$el.html(compiledTemplate);
    this.$el.i18n();

    this.initializeToggle();
    this.initializeTagFactory();
    this.initializeFileUpload();
    this.initializeTags();
    this.updatePhoto();
    this.updateProjectEmail();
    this.model.trigger("project:show:rendered");

    return this;
  },

  updatePhoto: function () {
    this.listenTo(this.model, "project:updated:photo:success", function (data) {
      var model = data.toJSON(), url;
      if (model.coverId) {
        url = '/api/file/get/' + model.coverId;
        $("#project-header").css('background-image', "url(" + url + ")");
      }
      $('#file-upload-progress-container').hide();
    });
  },

  updateProjectEmail: function() {
    var self = this;
    $.ajax({
      url: encodeURI('/api/email/makeURL?email=contactUserAboutProject&subject=Check Out "'+ self.model.attributes.title + '"' +
      '&projectTitle=' + self.model.attributes.title +
      '&projectLink=' + window.location.protocol + "//" + window.location.host + "" + window.location.pathname +
      '&projectDescription=' + (self.model.attributes.description || '')),
      type: 'GET'
    }).done( function (data) {
      self.$('#email').attr('href', data);
    });

  },

  initializeTagFactory: function() {
    var self = this;

    this.listenTo(self.model, "project:tag:update:start", function (tags) {

      var newTags = [];
      newTags = newTags.concat(self.$("#tag_topic").select2('data'),self.$("#tag_skill").select2('data'),self.$("#tag_location").select2('data'),self.$("#tag_agency").select2('data'));

      async.forEach(
        newTags,
        function(newTag, callback) {
          return self.tagFactory.addTagEntities(newTag,self,callback);
        },
        function(err) {
          if (err) return next(err);
          self.trigger("newTagSaveDone");
        }
      );
    });

    self.on('newTagSaveDone',function (){

      tags         = [];
      var tempTags = [];

      //get newly created tags from big three types
      _.each(self.data.newItemTags, function(newItemTag){
        tags.push(newItemTag);
      });

      tempTags.push.apply(tempTags,self.$("#tag_topic").select2('data'));
      tempTags.push.apply(tempTags,self.$("#tag_skill").select2('data'));
      tempTags.push.apply(tempTags,self.$("#tag_location").select2('data'));
      tempTags.push.apply(tempTags,self.$("#tag_agency").select2('data'));

      //see if there are any previously created big three tags and add them to the tag array
      _.each(tempTags,function(tempTag){
          if ( tempTag.id !== tempTag.name ){
          tags.push(tempTag);
        }
      });

      var tagMap = {};
      var projectId = self.model.attributes.id;

      async.forEach(
        tags,
        function(tag, callback){
          return self.tagFactory.addTag(tag,projectId,"projectId",callback);
        },
        function(err){
          self.model.trigger("project:tags:save:success", err);
        }
      );
    });
  },

  initializeToggle: function () {
    if(this.edit){
      this.$('#editProject').find('.box-icon-text').html('View ' + i18n.t('Project'));
    }
    else{
      this.$('#editProject').find('.box-icon-text').html('Edit ' + i18n.t('Project'));
    }
  },

  initializeTags: function () {
    this.tagView = new TagShowView({
      model: this.model,
      el: '.tag-wrapper',
      target: 'project',
      targetId: 'projectId',
      edit: this.edit,
      url: '/api/tag/findAllByProjectId/'
    });
    this.tagView.render();
  },

  initializeFileUpload: function () {
    var self = this;

    $('#fileupload').fileupload({
        url: "/api/file/create",
        dataType: 'text',
        acceptFileTypes: /(\.|\/)(gif|jpe?g|png)$/i,
        formData: { 'type': 'image' },
        add: function (e, data) {
          self.$('#file-upload-progress-container').show();
          data.submit();
        },
        progressall: function (e, data) {
          var progress = parseInt(data.loaded / data.total * 100, 10);
          self.$('#file-upload-progress').css(
            'width',
            progress + '%'
          );
        },
        done: function (e, data) {
          // for IE8/9 that use iframe
          if (data.dataType == 'iframe text') {
            var result = JSON.parse(data.result);
          }
          // for modern XHR browsers
          else {
            var result = JSON.parse($(data.result).text());
          }
          self.model.trigger("project:update:photoId", result[0]);
        },
        fail: function (e, data) {
          // notify the user that the upload failed
          var message = data.errorThrown;
          self.$('#file-upload-progress-container').hide();
          if (data.jqXHR.status == 413) {
            message = "The uploaded file exceeds the maximum file size.";
          }
          self.$(".file-upload-alert").html(message)
          self.$(".file-upload-alert").show();
        }
    });

  },

  cleanup: function () {
    if (this.tagView) { this.tagView.cleanup(); }
    removeView(this);
  },
});

module.exports = ProjectShowView;

},{"../../../../components/tag_factory":112,"../../../../mixins/utilities":128,"../../../tag/show/views/tag_show_view":84,"../templates/project_item_view_template.html":74,"async":131,"backbone":133,"blueimp-file-upload/js/jquery.fileupload.js":134,"blueimp-file-upload/js/jquery.iframe-transport":135,"select2":157,"underscore":159}],78:[function(require,module,exports){
module.exports = "<div class=\"box-pad-lr border-bottom\">\n  <h2><span data-i18n=\"ProjectOwnerPlural\">Project Owners</span>\n    <button id=\"owner-edit\" name=\"owner-edit\" class=\"btn btn-c0 btn-sm file-add owner-form-toggle\">Add Owners</button>\n    <button id=\"owner-cancel\" name=\"owner-cancel\" class=\"btn btn-c0 btn-sm file-add owner-form-toggle\">Cancel</button>\n    <button id=\"owner-save\" name=\"owner-save\" class=\"btn btn-c2 btn-sm file-add owner-form-toggle\">Submit</button>\n  </h2>\n</div>\n\n<div id=\"project-owners-form\" class=\"box-pad-lr box-pad-t owner-form-toggle\">\n  <form class=\"\" role=\"form\">\n    <div class=\"form-group\">\n      <input style=\"width: 100%\" id=\"owners\" name=\"owners\" type=\"hidden\" value=\"Add Owner\"/>\n    </div>\n  </form>\n</div>\n\n<div id=\"project-owners-show\" class=\"box-pad-lr box-pad-t owner-form-toggle\">\n  <% if (data.owners) { %>\n    <% for (var i = 0; i < data.owners.length; i++) { %>\n    <div class=\"project-people-div\" data-userid=\"<%= data.owners[i].userId %>\">\n      <img src=\"/api/user/photo/<%= data.owners[i].userId %>\" class=\"project-people\" alt=\"<%= data.owners[i].name %>\"/>\n      <% if ((data.isOwner || user.isAdmin) && (data.owners[i].userId != cache.currentUser.id) && data.edit) { %>\n      <a href=\"#\" class=\"delete-projectowner project-owner-delete fa fa-times\"  id=\"delete-projectowner-<%= data.owners[i].id %>\" data-uid=\"<%= data.owners[i].userId %>\" data-poid=\"<%= data.owners[i].id %>\">\n      </a>\n      <% } %>\n    </div>\n    <% } %>\n  <% } %>\n</div>\n";

},{}],79:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var async = require('async');
var Popovers = require('../../../../mixins/popovers');
var ModalComponent = require('../../../../components/modal');
var ProjectownerShowTemplate = require('../templates/projectowner_show_template.html');


var ProjectownerShowView = Backbone.View.extend({

  el: "#projectowner-wrapper",
  model : null,

  // Set the model to null, before it is fetched from the server.
  // This allows us to clear out the previous data from the list_view,
  // and get ready for the new data for the project show view.
  // model: null,

  events: {
    "click button.owner-form-toggle"      : "toggleOwners",
    "click #owner-save"                   : "saveOwners",
    "click #owner-cancel"                 : "initializeOwnerSelect2",
    "click .delete-projectowner"          : "removeOwner"
  },

  // The initialize method is mainly used for event bindings (for effeciency)
  initialize: function (options) {
    var self = this;
    this.options = options;
    this.data = options.data;
    this.action = options.action;
    this.user = window.cache.currentUser || {};
    if (this.options.action) {
      if (this.options.action == 'edit') {
        this.edit = true;
      }
    }

    this.model.on("projectowner:show:rendered", function () {
      self.initializeOwnerSelect2();
    });
    //when owner set is updated, re-render and re-init popovers
    this.model.on("project:update:owners:success", function (data) {
      self.render();
      if (_.isUndefined(popovers)) {
        var popovers = new Popovers();
        popovers.popoverPeopleInit(".project-people-div");
      }
    });

  },

  render: function () {
    var compiledTemplate;
    var data = {
      data: this.model.toJSON(),
      user: this.user
    };
    data.data.edit = this.edit;
    compiledTemplate = _.template(ProjectownerShowTemplate)(data);
    this.$el.html(compiledTemplate);
    this.$el.i18n();

    this.model.trigger("projectowner:show:rendered", data);
    return this;
  },

  initializeOwnerSelect2: function () {
    var self = this;
    if ((this.model.attributes.isOwner || this.user.isAdmin) && this.edit){
      var formatResult = function (object, container, query) {
        return object.name;
      };
      var oldOwners = this.model.attributes.owners || [];
      var oldOwnerIds = _.map(oldOwners, function(owner){ return owner.userId }) || [];

      self.$("#owners").select2({
        placeholder: 'Add ' + i18n.t('Project') + ' Owners',
        multiple: true,
        formatResult: formatResult,
        formatSelection: formatResult,
        minimumInputLength: 1,
        ajax: {
            url: '/api/ac/user',
            dataType: 'json',
            data: function (term) {
              return {
                q: term
              };
            },
            results: function (data) {
              return { results: _.filter(data, function(user){  return _.indexOf( oldOwnerIds, user.id) >= 0 ? false : true; }, self ) };
          }
        }
      });

      self.$('#owner-edit').show();

    }
    else
    {
      self.$('#owner-edit').hide();
    }

    self.$('#project-owners-form').hide();
    self.$('#project-owners-show').show();
    self.$('#owner-save').hide();
    self.$('#owner-cancel').hide();

  },

  toggleOwners : function(e){
    if (!(this.model.attributes.isOwner || this.user.isAdmin) && this.edit) return false;
    $('.owner-form-toggle').toggle(400);
  },

  saveOwners : function(e){
    if (e.preventDefault) e.preventDefault();
    if (!(this.model.attributes.isOwner || this.user.isAdmin) && this.edit) return false;
    var self = this;

    var pId = self.model.attributes.id;

    var oldOwners = this.model.attributes.owners || [];
    var s2data = $("#owners").select2("data")  || [];
    var s2OwnerIds = _.map(s2data, function(owner){ return owner.id }) || [];

    async.each(s2OwnerIds, createOwner, function(){ self.model.trigger("projectowner:show:changed", oldOwners); });

    $("#owners").select2("data", []);

    function createOwner(ownerID, done){
      var self = this;
      $.ajax({
          url: '/api/projectowner/',
          type: 'POST',
          data: {
            projectId: pId,
            userId: ownerID
          },
          success : function(data){
            var POId = data.id;
            oldOwners.push({ id:POId, userId: ownerID});
          }

        }).done(function (data) {
          done();
        });
    };

  },

  removeOwner: function(e) {
    if (e.stopPropagation()) e.stopPropagation();
    if (e.preventDefault) e.preventDefault();
    $(e.currentTarget).off("mouseenter");
    $('.popover').remove();

    var pOId = $(e.currentTarget).data('poid');
    var uId = $(e.currentTarget).data('uid');
    var self = this;

    if (typeof cache !== "undefined" && uId !== cache.currentUser.id)
    {
      $.ajax({
        url: '/api/projectowner/' + pOId,
        type: 'DELETE',
      }).done(function (data) {
          // done();
      });
    }

    var oldOwners = this.model.attributes.owners || [];
    var unchangedOwners = _.filter(oldOwners, function(owner){ return ( owner.id !== pOId ); } , this)  || [];
    self.model.trigger("projectowner:show:changed", unchangedOwners);
  },




  // ---------------------
  //= Utility Methods
  // ---------------------
  cleanup: function() {
    removeView(this);
  }

});

module.exports = ProjectownerShowView;

},{"../../../../components/modal":106,"../../../../mixins/popovers":126,"../../../../mixins/utilities":128,"../templates/projectowner_show_template.html":78,"async":131,"backbone":133,"underscore":159}],80:[function(require,module,exports){
module.exports = "<form role=\"form\" action=\"\" id=\"tag-form\">\n  <div class=\"modal-body\">\n    <fieldset>\n      <div class=\"form-group\">\n        <label for=\"tag-form-type\">Tag Type</label>\n        <select id=\"tag-form-type\" name=\"tag-form-type\" class=\"form-control\">\n          <% for (var i = 0; i < tags.length; i++) { %>\n          <option value=\"<%- tags[i].type %>\"><%- tags[i].name %></option>\n          <% } %>\n        </select>\n      </div>\n      <div class=\"form-group\">\n        <label for=\"tag-form-name\">\n          Tag Name\n        </label>\n        <input type=\"text\" class=\"form-control\" id=\"tag-form-name\" name=\"tag-form-name\" placeholder=\"Tag Name\" data-validate=\"empty,count100\"/>\n        <span class=\"help-block error-empty\" style=\"display:none;\">You must enter a tag name.</span>\n        <span class=\"help-block error-count100\" style=\"display:none;\">Tags must be less than 100 characters in length.</span>\n      </div>\n    </fieldset>\n  </div>\n  <div class=\"modal-footer\">\n    <button type=\"button\" class=\"btn btn-c0\" data-dismiss=\"modal\">Cancel</button>\n    <input type=\"submit\" class=\"btn btn-c2\" id=\"submit\" value=\"Create Tag\"/>\n  </div>\n</form>\n";

},{}],81:[function(require,module,exports){

var Bootstrap = require('bootstrap');
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var TagFormTemplate = require('../templates/tag_new_form_template.html');


var TagFormView = Backbone.View.extend({

  events: {
    "blur #tag-form-name" : "v",
    "submit #tag-form"    : "post"
  },

  initialize: function (options) {
    this.tags = options.tags;
    this.target = options.target;
    this.options = options;
  },

  render: function () {
    var data = {
      tags: this.tags
    };
    var template = _.template(TagFormTemplate)(data);
    this.$el.html(template);
    return this;
  },

  v: function (e) {
    return validate(e);
  },

  post: function (e) {
    if (e.preventDefault) e.preventDefault();

    // perform field validation
    var validateIds = ['#tag-form-name'];
    var abort = false;
    for (var i in validateIds) {
      var iAbort = validate({ currentTarget: validateIds[i] });
      abort = abort || iAbort;
    }
    if (abort) {
      return;
    }

    // assemble form and submit
    var data;
    var self = this;

    data = {
      type: $(e.currentTarget).find("#tag-form-type").val(),
      name: $(e.currentTarget).find("#tag-form-name").val()
    }

    $.ajax({
      url: '/api/tag/add',
      type: 'POST',
      data: data
    }).done(function (result) {
      // Pass the tag back
      self.options.model.trigger(self.target + ":tag:new", result);
    });

  },

  cleanup: function () {
    removeView(this);
  }

});

module.exports = TagFormView;

},{"../../../../mixins/utilities":128,"../templates/tag_new_form_template.html":80,"backbone":133,"bootstrap":138,"underscore":159}],82:[function(require,module,exports){
module.exports = "<li><%- tag.tag.name %>\n<% if ((data.isOwner || user.isAdmin) && edit) { %>\n<span class=\"tag-delete fa fa-times\" data-id=\"<%- tag.id %>\"></span>\n<% } %>\n</li>\n";

},{}],83:[function(require,module,exports){
module.exports = "<% for (var i = 0; i < tags.length; i++) { %>\n<div class=\"tag-title <%- tags[i]['class'] %>\" id=\"<%- tags[i].id %>\">\n  <h2><i class=\"<%- tags[i].icon %>\"></i> <span class=\"box-icon-text\"><%- tags[i].plural %></span></h2>\n  <% if ((data.isOwner || user.isAdmin) && edit) { %>\n  <div style='margin-bottom: 5px'>\n    <input type=\"text\" id=\"tag_<%- tags[i].id.toLowerCase() %>\" class=\"fullwidth\" name=\"tag_<%- tags[i].name.toLowerCase() %>\"/>\n  </div>\n  <% } %>\n  <ul class=\"tags\">\n    <li class=\"tag-empty\" id=\"<%- tags[i]['class'] %>-empty\">\n      <% if (tags[i]['class'] === 'location') { %>Anywhere<% } else { %>None<% } %>\n    </li>\n  </ul>\n</div>\n<% } %>\n<% if (data.userId) {\n%>\n<div class=\"tag-title\">\n  <h2><i class=\"fa fa-child \"></i> <span class=\"box-icon-text\">Progress</span></h2>\n  <ul class=\"tags\">\n    <li class=\"tag-empty\" id=\"task-length-empty\" style=\"display: none;\">None</li>\n    <li>Published: <%- data.publishedAt ? moment(data.publishedAt).format('ddd, MMM D, YYYY') : '--' %></li><br>\n    <li>Assigned: <%- data.assignedAt ? moment(data.assignedAt).format('ddd, MMM D, YYYY') : '--' %></li><br>\n    <li>Completed: <%- data.completedAt ? moment(data.completedAt).format('ddd, MMM D, YYYY') : '--' %></li>\n  </ul>\n</div>\n<% } %>\n";

},{}],84:[function(require,module,exports){

var Bootstrap = require('bootstrap');
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var async = require('async');
var ModalComponent = require('../../../../components/modal');
var TagConfig = require('../../../../config/tag');
var TagFormView = require('../../new/views/tag_new_form_view');
var TagTemplate = require('../templates/tag_item_template.html');
var TagShowTemplate = require('../templates/tag_show_template.html');
var TagFactory = require('../../../../components/tag_factory');


var TagShowView = Backbone.View.extend({

  events: {
    "click #tag-create"     : "createTag",
    "click #tag-save"       : "saveTag",
    "click .tag-delete"     : "deleteTag"
  },

  initialize: function (options) {
    this.options = options;
    this.model = options.model;
    this.target = options.target;
    this.targetId = options.targetId;
    this.edit = options.edit;
    this.tagFactory = new TagFactory();
    this.tags = [];
    // Figure out which tags apply
    for (var i = 0; i < TagConfig[this.target].length; i++) {
      this.tags.push(TagConfig.tags[TagConfig[this.target][i]]);
    }
  },

  render: function () {
    var data = {
      data: this.model.toJSON(),
      tags: this.tags,
      edit: this.edit,
      user: window.cache.currentUser || {}
    };
    var template = _.template(TagShowTemplate)(data);
    this.$el.html(template);
    this.initializeSelect2();
    this.initializeTags();
    return this;
  },

  initializeSelect2: function () {
    var self = this;

    self.tagFactory.createTagDropDown({
      type:"skill",selector:"#tag_skill",width: "100%",tokenSeparators: [","]
    });

    self.tagFactory.createTagDropDown({
      type:"topic",selector:"#tag_topic",width: "100%",tokenSeparators: [","]
    });

    self.tagFactory.createTagDropDown({type:"location",selector:"#tag_location",width: "100%"});
    self.tagFactory.createTagDropDown({type:"agency",selector:"#tag_agency",width: "100%"});
    self.model.trigger("profile:input:changed");
  },

  initializeTags: function() {
    // Load tags for the view
    var self = this;

    var tagIcon = {};
    var tagClass = {};
    for (var i = 0; i < this.tags.length; i++) {
      tagIcon[this.tags[i].type] = this.tags[i].icon;
      tagClass[this.tags[i].type] = this.tags[i]['class'];
    }

    var renderTag = function (tag) {
      var templData = {
        data: self.model.toJSON(),
        tags: self.tags,
        tag: tag,
        edit: self.edit,
        user: window.cache.currentUser || {}
      };
      var compiledTemplate = _.template(TagTemplate)(templData);
      var tagDom = $("." + tag.tag.type).children(".tags");
      tagDom.append(compiledTemplate);
      $('#' + tagClass[tag.tag.type] + '-empty').hide();
    };

    $.ajax({
      url: this.options.url + this.model.id
    }).done(function (data) {
      for (var i = 0; i < data.length; i++) {
        // Render tags onto page
        renderTag(data[i]);
      }
    });

    // Initialize Select2 for Administrative Functions
    var formatResult = function (object, container, query) {
      return '<i class="' + tagIcon[object.type] + '"></i> ' + object.name;
    };

    $("#input-tags").select2({
      placeholder: 'Add tags',
      multiple: true,
      formatResult: formatResult,
      formatSelection: formatResult,
      ajax: {
        url: '/api/ac/tag',
        dataType: 'json',
        data: function (term) {
          return {
            type: TagConfig[self.target].join(),
            q: term
          };
        },
        results: function (data) {
          return { results: data };
        }
      }
    });

    // New tags added in to the DB via the modal
    this.listenTo(this.model, this.target + ":tag:new", function (data) {
      // Destory modal
      $(".modal").modal('hide');
      // Add tag into the data list
      var s2data = $("#input-tags").select2("data");
      s2data.push(data);
      $("#input-tags").select2("data", s2data);
    });

    // Tags saved using the select2 dialog
    this.listenTo(this.model, this.target + ":tag:save", function (data) {
      for (var i = 0; i < data.length; i++) {
        if (!data[i].existing) {
          renderTag(data[i]);
        }
      }
      $("#input-tags").select2("val", "");
    });

    this.listenTo(this.model, this.target + ":tag:delete", function (e) {
      if ($(e.currentTarget).parent('li').siblings().length == 1) {
        $(e.currentTarget).parent('li').siblings('.tag-empty').show();
      }
      $(e.currentTarget).parent('li').remove();
    });
  },

  createTag: function (e) {
    if (e.preventDefault) e.preventDefault();
    var self = this;

    // Pop up dialog box to create tag,
    // then put tag into the select box
    if (_.isUndefined(this.modalComponent)) {
      this.modalComponent = new ModalComponent({
        el: "#container",
        id: "createTag",
        modalTitle: "Create Tag"
      }).render();
    }

    if (!_.isUndefined(this.modalComponent)) {
      if (this.tagFormView) {
        this.tagFormView.cleanup();
      }
      this.tagFormView = new TagFormView({
        el: "#createTag .modal-template",
        model: self.model,
        tags: self.tags,
        target: self.target
      });
      this.tagFormView.render();
    }
  },

  saveTag: function (e) {
    if (e.preventDefault) e.preventDefault();
    var self = this;
    // Cycle through tags in select box
    // and call create on each one, then
    // render
    $("#tag-save").addClass('disabled');
    var data = $("#input-tags").select2('data');
    var result = [];

    var processTag = function(tag, done) {
      var tagMap = {
        tagId: tag.id
      };
      if (self.targetId) {
        tagMap[self.targetId] = self.model.id;
      }
      $.ajax({
        url: '/api/tag',
        type: 'POST',
        data: tagMap
      }).done(function (data) {
        result.push(data);
        done();
      });
    };

    async.each(data, processTag, function (err) {
      for (var i = 0; i < result.length; i++) {
        for (var j = 0; j < data.length; j++) {
          if (result[i].tagId == data[j].id) {
            result[i].tag = data[j];
            break;
          }
        }
      }
      $("#tag-save").removeClass('disabled');
      self.model.trigger(self.options.target + ":tag:save", result);
    });

  },

  deleteTag: function (e) {
    if (e.preventDefault) e.preventDefault();
    var self = this;
    // Get the data-id of the currentTarget
    // and then call HTTP DELETE on that tag id
    $.ajax({
      url: '/api/tag/' + $(e.currentTarget).data('id'),
      type: 'DELETE',
    }).done(function (data) {
      self.model.trigger(self.options.target + ":tag:delete", e);
    });
  },

  cleanup: function () {
    if (this.tagFormView) { this.tagFormView.cleanup(); }
    removeView(this);
  }

});

module.exports = TagShowView;

},{"../../../../components/modal":106,"../../../../components/tag_factory":112,"../../../../config/tag":115,"../../../../mixins/utilities":128,"../../new/views/tag_new_form_view":81,"../templates/tag_item_template.html":82,"../templates/tag_show_template.html":83,"async":131,"backbone":133,"bootstrap":138,"underscore":159}],85:[function(require,module,exports){
module.exports = "<form action=\"\" id=\"task-edit-form\">\n  <div class=\"form-group\">\n    <h2 class=\"box-pad-t\">\n      <span data-i18n=\"Task\">Opportunity</span> Title\n    </h2>\n    <input id=\"task-title\" type=\"text\" placeholder=\"A short description of the problem.\" value=\"<%- data.title %>\" class=\"form-control input-lg validate\" data-validate=\"empty,count100\"/>\n    <span class=\"help-block error-empty\" style=\"display:none;\">You must enter a title for this <span data-i18n=\"task\">opportunity</span></span>\n    <span class=\"help-block error-count100\" style=\"display:none;\">The short description of the problem must be less than 100 characters.</span>\n  </div>\n  <div class=\"form-group\">\n    <h2 class=\"box-pad-t\">\n      <span data-i18n=\"Task\">Opportunity</span> Description\n    </h2>\n    <div class=\"markdown-edit\"></div>\n    <span class=\"help-block error-empty\" style=\"display:none;\">You must enter a description for this <span data-i18n=\"task\">opportunity</span></span>\n  </div>\n  <hr />\n\n  <% if (ui.project.show) { %>\n  This <span data-i18n=\"task\">opportunity</span> belongs to the <span data-i18n=\"project\">project</span>:\n  <div class=\"row\">\n    <div class=\"col-md-12\">\n      <input type=\"hidden\" id=\"projectId\" class=\"task-skills fullwidth\" />\n    </div>\n  </div>\n  <% } %>\n\n  <hr/>\n\n  <div class=\"row\">\n    <div class=\"col-md-12\">\n        <span data-i18n=\"TaskOwner\">Task Owner</span>\n        <input style=\"width: 100%\" id=\"owner\" name=\"owner\" type=\"hidden\" value=\"Edit Owner\"/>\n    </div>\n  </div>\n\n  <hr/>\n\n  <div class=\"task-edit-description\">\n    We need\n    <select id=\"people\" class=\"dropdown\">\n      <% _.each(tagTypes['task-people'], function (t) { %>\n      <option value=<%= t.id %> <% if (madlibTags['task-people'] && (madlibTags['task-people'][0].id == t.id)) { %>selected<% } %>><%= t.name %></option>\n      <% }); %>\n    </select>\n\n    to work on an <span data-i18n=\"task\">opportunity</span> about:\n    <div class=\"row\">\n      <div class=\"col-md-12\">\n        <input type=\"hidden\" id=\"task_tag_topics\" class=\"task-skills fullwidth\" />\n      </div>\n    </div>\n\n    <hr />\n\n    The following skills are useful and\n    <select id=\"skills-required\" class=\"dropdown\">\n      <% _.each(tagTypes['task-skills-required'], function (t) { %>\n      <option value=<%= t.id %> <% if (madlibTags['task-skills-required'] && (madlibTags['task-skills-required'][0].id == t.id)) { %>selected<% } %>><%= t.name %></option>\n      <% }); %>\n    </select>\n\n    to complete this <span data-i18n=\"task\">opportunity</span> you should\n    <div class=\"row\">\n      <div class=\"col-md-12\">\n        <input type=\"hidden\" id=\"task_tag_skills\" class=\"task-skills fullwidth\"/>\n      </div>\n    </div>\n\n    <hr />\n\n    The <span data-i18n=\"task\">opportunity</span> will require\n    <select id=\"time-estimate\" class=\"dropdown\">\n      <% _.each(tagTypes['task-time-estimate'], function (t) { %>\n      <option value=<%= t.id %> <% if (madlibTags['task-time-estimate'] && (madlibTags['task-time-estimate'][0].id == t.id)) { %>selected<% } %>><%= t.name %></option>\n      <% }); %>\n    </select>\n\n    of\n    <select id=\"time-required\" class=\"dropdown\">\n      <% _.each(tagTypes['task-time-required'], function (t) { %>\n      <option value=<%= t.id %> <% if (madlibTags['task-time-required'] && (madlibTags['task-time-required'][0].id == t.id)) { %>selected<% } %>><%= t.name %></option>\n      <% }); %>\n    </select>\n\n    work, and must be completed within\n    <select id=\"length\" class=\"dropdown\">\n      <% _.each(tagTypes['task-length'], function (t) { %>\n      <option value=<%= t.id %> <% if (madlibTags['task-length'] && (madlibTags['task-length'][0].id == t.id)) { %>selected<% } %>><%= t.name %></option>\n      <% }); %>\n    </select>\n\n    <hr />\n\n    Participants must be located at:<br/>\n\n    <div class=\"row\">\n      <div class=\"col-md-12\">\n        <input type=\"hidden\" id=\"task_tag_location\" class=\"task-skills fullwidth\"/>\n      </div>\n    </div>\n    <small>Leave empty if people can participate from anywhere</small>\n\n    <hr/>\n\n    Pubished date:<br>\n    <div class=\"col-md-12 padding-none\" id=\"div-publishedAt\">\n      <input id=\"publishedAt\" name=\"publishedAt\" class=\"form-control timepicker\" type=\"text\">\n    </div>\n    Assigned date:<br>\n    <div class=\"col-md-12 padding-none\" id=\"div-assignedAt\">\n      <input id=\"assignedAt\" name=\"assignedAt\" class=\"form-control timepicker\" type=\"text\">\n    </div>\n    Completed date:<br>\n    <div class=\"col-md-12 padding-none\" id=\"div-completedAt\">\n      <input id=\"completedAt\" name=\"completedAt\" class=\"form-control timepicker\" type=\"text\">\n    </div>\n    <div class=\"clearfix\">\n      <hr>\n    </div>\n\n  </div>\n  <div class=\"row\">\n    <div class=\"col-lg-12\">\n      <div class=\"pull-right box-pad-b\">\n        <button class=\"btn btn-c0\" id=\"task-view\">Discard Changes</button>\n        <input type=\"submit\" class=\"btn btn-c2\" data-i18n=\"[value]SaveTask\" value=\"Save Opportunity\"/>\n      </div>\n    </div>\n  </div>\n</form>\n";

},{}],86:[function(require,module,exports){
module.exports = "<div class=\"project-people-div\" data-userid=\"<%= data.userId %>\">\n  <img src=\"/api/user/photo/<%= data.userId %>\" class=\"project-people\" alt=\"<%= data.owner.name %>\"/>\n</div>\n<div class=\"project-people-space\">\n  <div class=\"bar\"></div>\n</div>\n<% _.each(data.volunteers, function (v) { %>\n  <div class=\"project-people-div\" data-userid=\"<%= v.userId %>\" data-voluserid=\"<%= v.userId %>\">\n    <img src=\"/api/user/photo/<%= v.userId %>\" class=\"project-people\" alt=\"<%= v.name %>\"/>\n    <a href=\"#\" class=\"delete-volunteer volunteer-delete fa fa-times\"  id=\"delete-volunteer-<%= v.id %>\" data-uid=\"<%= v.userId %>\" data-vid=\"<%= v.id %>\"></a>\n  </div>\n<% }); %>\n";

},{}],87:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var utilities = require('../../../../mixins/utilities');
var UIConfig = require('../../../../config/ui.json');
var async = require('async');
var marked = require('marked');
var MarkdownEditor = require('../../../../components/markdown_editor');
var TaskEditFormTemplate = require('../templates/task_edit_form_template.html');
var VolunteerEditFormTemplate = require('../templates/volunteer_edit_form_template.html');
var TagFactory = require('../../../../components/tag_factory');


var TaskEditFormView = Backbone.View.extend({

  events: {
    'blur .validate'         : 'v',
    'click #task-view'       : 'view',
    'submit #task-edit-form' : 'submit'
  },

  initialize: function (options) {
    this.options = options;
    this.tagFactory = new TagFactory();
    this.data = {};
    this.data.newTag = {};
    this.initializeListeners();
    // Register listener to task update, the last step of saving
    this.listenTo(this.options.model, "task:update:success", function (data) {
      Backbone.history.navigate('tasks/' + data.attributes.id, { trigger: true });
    });
  },

  view: function (e) {
    if (e.preventDefault) e.preventDefault();
    Backbone.history.navigate('tasks/' + this.model.attributes.id, { trigger: true });
  },

  v: function (e) {
    return validate(e);
  },

  render: function () {
    var compiledTemplate, volunteerTemplate;

    this.data = {
      data: this.model.toJSON(),
      tagTypes: this.options.tagTypes,
      newTags: [],
      newItemTags: [],
      tags: this.options.tags,
      madlibTags: this.options.madlibTags,
      ui: UIConfig
    };

    volunteerTemplate = _.template(VolunteerEditFormTemplate)(this.data);
    //$(this.options.elVolunteer).remove();
    $(this.options.elVolunteer).html(volunteerTemplate);
    $(this.options.elVolunteer).i18n();

    compiledTemplate = _.template(TaskEditFormTemplate)(this.data);
    this.$el.html(compiledTemplate);
    this.$el.i18n();

    // DOM now exists, begin select2 init
    this.initializeSelect2();
    this.initializeTextArea();

    // Set up time pickers
    $('#publishedAt').datetimepicker({
      defaultDate: this.data.data.publishedAt
    });
    $('#assignedAt').datetimepicker({
      defaultDate: this.data.data.assignedAt
    });
    $('#completedAt').datetimepicker({
      defaultDate: this.data.data.completedAt
    });

  },

  initializeSelect2: function () {

    var formatResult = function (object, container, query) {
      var formatted = '<div class="select2-result-title">';
      formatted += object.name || object.title;
      formatted += '</div>';
      if (!_.isUndefined(object.description)) {
        formatted += '<div class="select2-result-description">' + marked(object.description) + '</div>';
      }
      return formatted;
    };

    this.$("#projectId").select2({
      placeholder: "Select a project to associate",
      multiple: false,
      formatResult: formatResult,
      formatSelection: formatResult,
      allowClear: true,
      ajax: {
        url: '/api/ac/project',
        dataType: 'json',
        data: function (term) {
          return {
            q: term
          };
        },
        results: function (data) {
          return { results: data };
        }
      }
    });
    if (this.data.data.project) {
      this.$("#projectId").select2('data', this.data.data.project);
    }

    this.$("#owner").select2({
      placeholder: "task owner",
      multiple: false,
      formatResult: formatResult,
      formatSelection: formatResult,
      allowClear: false,
      ajax: {
        url: '/api/ac/user',
        dataType: 'json',
        data: function (term) {
          return {
            q: term
          };
        },
        results: function (data) {
          return { results: data };
        }
      }
    });
    if (this.data.data.owner) {
      this.$("#owner").select2('data', this.data.data.owner);
    }

    this.tagFactory.createTagDropDown({
      type:"skill",selector:"#task_tag_skills",width: "100%", tokenSeparators: [","]
    });
    if (this.data['madlibTags'].skill) {
      this.$("#task_tag_skills").select2('data', this.data['madlibTags'].skill);
    }

    this.tagFactory.createTagDropDown({
      type:"topic", selector: "#task_tag_topics", width: "100%", tokenSeparators: [","]
    });
    if (this.data['madlibTags'].topic) {
      this.$("#task_tag_topics").select2('data', this.data['madlibTags'].topic);
    }

    this.tagFactory.createTagDropDown({type:"location",selector:"#task_tag_location",width: "100%"});
    if (this.data['madlibTags'].location) {
      this.$("#task_tag_location").select2('data', this.data['madlibTags'].location);
    }

    $("#skills-required").select2({
      placeholder: "required/not-required",
      width: '200px'
    });

    $("#time-required").select2({
      placeholder: 'time-required',
      width: '130px'
    });

    $("#people").select2({
      placeholder: 'people',
      width: '150px'
    });

    $("#length").select2({
      placeholder: 'length',
      width: '130px'
    });

    $("#time-estimate").select2({
      placeholder: 'time-estimate',
      width: '200px'
    });

    $("#task-location").select2({
      placeholder: 'location',
      width: '130px'
    });

  },

  initializeTextArea: function () {
    if (this.md) { this.md.cleanup(); }
    this.md = new MarkdownEditor({
      data: this.model.toJSON().description,
      el: ".markdown-edit",
      id: 'task-description',
      placeholder: 'Description of opportunity including goals, expected outcomes and deliverables.',
      title: 'Opportunity Description',
      rows: 6,
      validate: ['empty']
    }).render();
  },

  initializeListeners: function() {
    var self = this;

    self.on("task:tags:save:done", function (){

      var modelData = {
        title: this.$("#task-title").val(),
        description: this.$("#task-description").val(),
        publishedAt: this.$("#publishedAt").val() || undefined,
        assignedAt: this.$("#assignedAt").val() || undefined,
        completedAt: this.$("#completedAt").val() || undefined
      };

      var project = this.$("#projectId").select2('data');
      if (project) {
        modelData.projectId = project.id;
      } else {
        modelData.projectId = null;
      }

      var owner = this.$("#owner").select2('data');
      if (owner) {
        modelData.userId = owner.id;
      }

      oldTags = this.getOldTags();
      tags    = this.getTagsFromPage();
      diff    = this.tagFactory.createDiff(oldTags, tags);

      _.each(self.data.newItemTags, function(newItemTag){
        diff.add.push(newItemTag.id);
      });

      async.forEach(
        diff.add,
        function(diffAdd, callback){
          if ( !_.isFinite(diffAdd) && diffAdd.name == diffAdd.id ) { return callback(); }
          self.tagFactory.addTag(diffAdd,self.model.attributes.id,"taskId",callback);
        },
        function(err){
          self.options.model.trigger("task:update", modelData);
        }
      );

    });
  },

  submit: function (e) {
    var self = this;
    if (e.preventDefault) e.preventDefault();
    //var self = this;

    var tags = [];
    var oldTags = [];
    var diff = [];

    _.extend(this, Backbone.Events);

    // check all of the field validation before submitting
    var children = this.$el.find('.validate');
    var abort = false;
    _.each(children, function (child) {
      var iAbort = validate({ currentTarget: child });
      abort = abort || iAbort;
    });
    if (abort === true) {
      return;
    }

    //var types = ["task-skills-required", "task-time-required", "task-people", "task-length", "task-time-estimate", "skill", "topic", "location"];
    tags = this.getTagsFromPage();
    oldTags = this.getOldTags();

    newTags = [];
    newTags = newTags.concat(self.$("#task_tag_topics").select2('data'),self.$("#task_tag_skills").select2('data'),self.$("#task_tag_location").select2('data'));

      async.forEach(
        newTags,
        function(newTag, callback) {
          self.tagFactory.addTagEntities(newTag,self,callback);
        },
        function(err, data) {
          if (err) return next(err);
          self.trigger("task:tags:save:done");
        }
      );
    diff = this.tagFactory.createDiff(oldTags, tags);

    if ( diff.remove.length > 0 ) {
      async.each(diff.remove, self.tagFactory.removeTag, function (err) {
        // do nothing for now
      });
    }
  },

  getTagsFromPage: function () {

    // Gather tags for submission after the task is created
    var tags = [];
    tags.push.apply(tags,this.$("#task_tag_topics").select2('data'));
    tags.push.apply(tags,this.$("#task_tag_skills").select2('data'));
    tags.push.apply(tags,this.$("#task_tag_location").select2('data'));
    tags.push.apply(tags,[this.$("#skills-required").select2('data')]);
    tags.push.apply(tags,[this.$("#people").select2('data')]);
    tags.push.apply(tags,[this.$("#time-required").select2('data')]);
    tags.push.apply(tags,[this.$("#time-estimate").select2('data')]);
    tags.push.apply(tags,[this.$("#length").select2('data')]);

    return tags;
  },

  getOldTags: function () {

    var oldTags = [];
      for (var i in this.options.tags) {
        oldTags.push({
          id: parseInt(this.options.tags[i].id),
          tagId: parseInt(this.options.tags[i].tag.id),
          type: this.options.tags[i].tag.type
        });
      }

    return oldTags;
  },

  cleanup: function () {
    if (this.md) { this.md.cleanup(); }
    removeView(this);
  }

});

module.exports = TaskEditFormView;

},{"../../../../components/markdown_editor":104,"../../../../components/tag_factory":112,"../../../../config/ui.json":116,"../../../../mixins/utilities":128,"../templates/task_edit_form_template.html":85,"../templates/volunteer_edit_form_template.html":86,"async":131,"backbone":133,"marked":155,"underscore":159}],88:[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');
var Utilities = require('../../../../mixins/utilities');
var Bootstrap = require('bootstrap');
var TasksCollection = require('../../../../entities/tasks/tasks_collection');
var TaskCollectionView = require('../views/task_collection_view');
var TaskFormView = require('../../new/views/task_form_view');
var ModalWizardComponent = require('../../../../components/modal_wizard');
var TaskModel = require('../../../../entities/tasks/task_model');

TaskList = Backbone.View.extend({

  el: "#task-list-wrapper",

  events: {
    'click .add-task' : 'add',
    'click .show-task': 'show',
    'click .task'     : 'show',
    'click .wizard'   : 'wizard'
  },

  initialize: function (settings) {
    this.options = _.extend(settings, this.defaults);
    var self = this;

    this.initializeTaskCollectionInstance();
    this.initializeTaskModelInstance();
    this.initializeListeners();
    this.requestTasksCollectionData();

    this.collection.on("tasks:render", function () {
      self.requestTasksCollectionData()
    })
  },

  initializeListeners: function() {
    var self = this;
    this.listenTo(this.taskModel, 'task:tags:save:success', function () {
      self.initializeTaskModelInstance();
      self.requestTasksCollectionData();
    });
  },

  initializeTaskModelInstance: function () {
    this.taskModel = new TaskModel();
  },

  initializeTaskCollectionInstance: function () {
    if (this.collection) {
      this.collection.initialize();
    } else {
      this.collection = new TasksCollection();
    }
  },

  requestTasksCollectionData: function () {
    var self = this;

    this.collection.fetch({
      url: '/api/task/findAllByProjectId/' + parseInt(this.options.projectId),
      success: function (collection) {
        self.tasks = collection;
        self.renderTaskCollectionView()
      }
    });
  },

  renderTaskCollectionView: function () {
    var self = this;

    if (this.taskCollectionView) this.taskCollectionView.cleanup();
    this.taskCollectionView = new TaskCollectionView({
      el: "#task-list-wrapper",
      onRender: true,
      collection: self.tasks
    });
  },

  add: function (e) {
    if (e.preventDefault) e.preventDefault();
    var self = this;

    if (this.taskFormView) this.taskFormView.cleanup();
    if (this.modalWizardComponent) this.modalWizardComponent.cleanup();
    this.modalWizardComponent = new ModalWizardComponent({
      el: ".wrapper-addTask",
      id: "addTask",
      modalTitle: 'New Opportunity',
      model: self.taskModel,
      collection: self.tasks,
      modelName: 'task',
      data: function (parent) { return {
        title: parent.$("#task-title").val(),
        description: parent.$("#task-description").val(),
        projectId: self.options.projectId
      } }
    }).render();

    this.taskFormView = new TaskFormView({
      el: ".modal-body",
      projectId: this.options.projectId,
      model: self.taskModel,
      tasks: self.tasks
    }).render();
    this.modalWizardComponent.setChildView(this.taskFormView);
    this.modalWizardComponent.setNext(this.taskFormView.childNext);
    this.modalWizardComponent.setSubmit(this.taskFormView.childNext);
  },

  show: function (e) {
    if (e.preventDefault) e.preventDefault();
    var projectId = $(e.currentTarget).data('projectid'),
        taskId    = $(e.currentTarget).data('id');

    if (taskId == 'null') { return; }

    Backbone.history.navigate('tasks/' + taskId, { trigger: true }, taskId);
  },

  cleanup: function () {
    if (this.taskFormView) this.taskFormView.cleanup();
    if (this.modalWizardComponent) this.modalWizardComponent.cleanup();
    if (this.taskCollectionView) this.taskCollectionView.cleanup();
    removeView(this);
  }

});

module.exports = TaskList;


},{"../../../../components/modal_wizard":110,"../../../../entities/tasks/task_model":124,"../../../../entities/tasks/tasks_collection":125,"../../../../mixins/utilities":128,"../../new/views/task_form_view":92,"../views/task_collection_view":90,"backbone":133,"bootstrap":138,"underscore":159}],89:[function(require,module,exports){
module.exports = "<div class=\"box-pad-lr border-bottom\">\n  <h2>\n    Available Opportunities\n    <% if (user) { %>\n    <a href=\"#addTask\" class=\"btn btn-c0 btn-sm file-add add-task\" data-toggle=\"modal\" data-backdrop=\"static\">Add Opportunity</a>\n    <% } %>\n  </h2>\n</div>\n\n<div class=\"task-scroll\">\n  <% if (tasks.length == 0) { %>\n  <div class=\"task border-left\" data-id=\"null\">\n    <div class=\"task-title\">\n      No current opportunities.\n    </div>\n  </div>\n  <% } %>\n  <% _.each(tasks, function(task) { %>\n  <div class=\"task border-left\" data-projectid=\"<%= task.projectId %>\" data-id=\"<%= task.id %>\">\n    <div class=\"pull-right\">\n      <strong><%= task.state %></strong>\n    </div>\n    <div class=\"task-title\">\n      <a href=\"/tasks/<%- task.id %>\" class=\"show-task\" data-projectid=\"<%= task.projectId %>\" data-id=\"<%= task.id %>\"><%- task.title %></a>\n    </div>\n    <div class=\"task-description\">\n      <%= task.description %>\n    </div>\n    <div class=\"task-tags-row\">\n      <ul class=\"tags task-tags\">\n        <% _.each(task.tags, function (tag) { %>\n          <li><%= tag.tag.name %></li>\n        <% }); %>\n      </ul>\n    </div>\n  </div>\n  <% }) %>\n</div>\n";

},{}],90:[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var async = require('async');
var marked = require('marked');
var TaskListTemplate = require('../templates/task_collection_view_template.html');


	var TasksCollectionView = Backbone.View.extend({

		el: "#task-list-wrapper",

		initialize: function (options) {
			this.options = options;
			this.requestTagData();
		},

		requestTagData: function () {
			var self = this;

			this.tasksJson = {
				tasks: this.options.collection.toJSON(),
				user: window.cache.currentUser
			};

			var requestTagData = function (task, done) {
				$.ajax({
					url: '/api/tag/findAllByTaskId/' + task.id,
					async: false,
					success: function (tags) {
						task['tags'] = tags;
						done();
					},
					error: function () {
						task['tags'] = [];
						done();
					}
				});
			}

			async.each(this.tasksJson.tasks, requestTagData, function () {
				self.render();
			});

		},

		render: function () {
			_.each(this.tasksJson.tasks, function(task) {
				task.description = marked(task.description);
			});
			this.compiledTemplate = _.template(TaskListTemplate)(this.tasksJson);
			this.$el.html(this.compiledTemplate);

			return this;
		},

		cleanup: function () {
			removeView(this);
		}

	});

	module.exports = TasksCollectionView;

},{"../../../../mixins/utilities":128,"../templates/task_collection_view_template.html":89,"async":131,"backbone":133,"marked":155,"underscore":159}],91:[function(require,module,exports){
module.exports = "<form id=\"task-form\" class=\"form-inline\" action=\"/api/task\">\n\n  <section id=\"section-1\" class=\"current\">\n    <div class=\"form-group fullwidth\">\n      <label for=\"task-title\">\n        What problem are you trying to solve?\n      </label>\n      <div class=\"row\">\n        <div class=\"col-md-12\">\n          <input type=\"text\" id=\"task-title\" class=\"fullwidth form-control validate\" placeholder=\"A short description of the problem.\" data-validate=\"empty,count100\"/>\n          <span class=\"help-block error-empty\" style=\"display:none;\">You must enter a title for this <span data-i18n=\"task\">opportunity</span></span>\n          <span class=\"help-block error-count100\" style=\"display:none;\">The short description of the problem must be less than 100 characters.</span>\n        </div>\n      </div>\n    </div>\n  </section>\n\n  <section id=\"section-2\">\n    <div class=\"form-group fullwidth\">\n      <label for=\"people\">\n        We need\n      </label>\n      <select id=\"people\" class=\"dropdown\">\n        <% _.each(tags['task-people'], function (person) { %>\n          <option value=\"<%= person.id %>\"><%= person.name %></option>\n        <% }); %>\n      </select>\n\n      <label for=\"topics\">\n        to work on an <span data-i18n=\"task\">opportunity</span> about these topics:\n      </label>\n      <div class=\"row\">\n        <div class=\"col-md-12\">\n          <input type=\"hidden\" id=\"task_tag_topics\" class=\"fullwidth\" name=\"topic\" />\n        </div>\n      </div>\n    </div>\n\n    <hr/>\n\n    <div class=\"form-group fullwidth\">\n      <label for=\"skills-required\">\n        The following skills are useful and\n      </label>\n      <select id=\"skills-required\" name=\"skills-required\" class=\"dropdown\">\n        <% _.each(tags['task-skills-required'], function(requirement) { %>\n          <option value=\"<%= requirement.id %>\"><%= requirement.name %></option>\n        <% }); %>\n      </select>\n      <label for=\"skills\">\n        to complete this <span data-i18n=\"task\">opportunity</span>:\n      </label>\n      <div class=\"row\">\n        <div class=\"col-md-12\">\n          <input type=\"hidden\" id=\"task_tag_skills\" name=\"skills\" class=\"fullwidth\" />\n        </div>\n      </div>\n    </div>\n\n  </section>\n\n  <section id=\"section-3\">\n    <div class=\"form-group fullwidth\">\n      <label for=\"time-estimate\">\n        The <span data-i18n=\"task\">opportunity</span> will require\n      </label>\n      <select id=\"time-estimate\" class=\"dropdown\">\n        <% _.each(tags['task-time-estimate'], function (timeEstimate) { %>\n          <option value=\"<%= timeEstimate.id %>\"><%= timeEstimate.name %></option>\n        <% }); %>\n      </select>\n\n      <label for=\"time-required\">\n        of\n      </label>\n      <select id=\"time-required\" class=\"dropdown\">\n        <% _.each(tags['task-time-required'], function (time) { %>\n          <option value=\"<%= time.id %>\"><%= time.name %></option>\n        <% }); %>\n      </select>\n\n      <label for=\"length\">\n        work, and must be completed within\n      </label>\n      <select id=\"length\" class=\"dropdown\">\n        <% _.each(tags['task-length'], function (item) { %>\n          <option value=\"<%= item.id %>\"><%= item.name %></option>\n        <% }) %>\n      </select>\n    </div>\n\n    <hr/>\n\n    <div class=\"form-group fullwidth\">\n      <label for=\"task-location\">\n        The volunteer(s) must be located\n      </label>\n      <select id=\"task-location\" class=\"dropdown\">\n        <option value=\"false\">anywhere</option>\n        <option value=\"true\">at specific location(s)</option>\n      </select> to complete this task.\n\n      <div class=\"row el-specific-location\">\n        <div class=\"col-md-12\">\n          <div class=\"form-group task-skills fullwidth\">\n            <label for=\"location\">\n              The specific location(s) are:\n            </label>\n            <input type=\"hidden\" id=\"task_tag_location\" name=\"location\" class=\"fullwidth\"/>\n          </div>\n        </div>\n      </div>\n    </div>\n  </section>\n\n  <section id=\"section-4\">\n    <div class=\"form-group fullwidth\">\n      <label for=\"task-description\">\n        Describe the <span data-i18n=\"task\">opportunity</span> details, including goals, expected outcomes and deliverables.\n      </label>\n      <div class=\"row\">\n        <div class=\"col-md-12\">\n          <div class=\"markdown-edit\"></div>\n          <span class=\"help-block error-empty\" style=\"display:none;\">You must enter a description for this <span data-i18n=\"task\">opportunity</span></span>\n        </div>\n      </div>\n    </div>\n  </section>\n\n</form>\n";

},{}],92:[function(require,module,exports){
var Bootstrap = require('bootstrap');
var _ = require('underscore');
var Backbone = require('backbone');
var async = require('async');
var utilities = require('../../../../mixins/utilities');
var MarkdownEditor = require('../../../../components/markdown_editor');
var TasksCollection = require('../../../../entities/tasks/tasks_collection');
var TaskFormTemplate = require('../templates/task_form_template.html');
var TagFactory = require('../../../../components/tag_factory');


var TaskFormView = Backbone.View.extend({

  el: "#task-list-wrapper",

  events: {
    "change .validate"        : "v",
    "change #task-location" : "locationChange"
  },

  initialize: function (options) {
    this.options = _.extend(options, this.defaults);
    this.tasks = this.options.tasks;
    this.tagFactory = new TagFactory();
    this.data = {};
    this.data.newTag = {};
    this.data.newItemTags = [];
    this.data.existingTags = [];
    this.initializeSelect2Data();
    this.initializeListeners();
  },

  initializeSelect2Data: function () {
    var self = this;
    var types = ["task-skills-required", "task-time-required", "task-people", "task-length", "task-time-estimate"];

    this.tagSources = {};

    var requestAllTagsByType = function (type) {
      $.ajax({
        url: '/api/ac/tag?type=' + type + '&list',
        type: 'GET',
        async: false,
        success: function (data) {
          self.tagSources[type] = data;
        }
      });
    }

    async.each(types, requestAllTagsByType, function (err) {
      self.render();
    });
  },

  initializeListeners: function() {
    var self = this;

    _.extend(this, Backbone.Events);

    self.on('newTagSaveDone',function (){

      tags         = [];
      var tempTags = [];

      //get newly created tags from big three types
      _.each(self.data.newItemTags, function(newItemTag){
        tags.push(newItemTag);
      });

      tempTags.push.apply(tempTags,self.$("#task_tag_topics").select2('data'));
      tempTags.push.apply(tempTags,self.$("#task_tag_skills").select2('data'));
      if (self.$("#task-location").select2('data').id == 'true') {
        tempTags.push.apply(tempTags,self.$("#task_tag_location").select2('data'));
      }

      //see if there are any previously created big three tags and add them to the tag array
      _.each(tempTags,function(tempTag){
          if ( tempTag.id !== tempTag.name ){
          tags.push(tempTag);
        }
      });

      _.each(this.data.existingTags, function(tempTag) {
          tags.push(tempTag);
      });

      async.forEach(
        tags,
        function(tag, callback){
          //diffAdd,self.model.attributes.id,"taskId",callback
          return self.tagFactory.addTag(tag,self.tempTaskId,"taskId",callback);
        },
        function(err){
          self.model.trigger("task:modal:hide");
          self.model.trigger("task:tags:save:success", err);
        }
      );
    });

    this.listenTo(this.tasks,"task:save:success", function (taskId){
      //the only concern here is to add newly created tags which is only available in the three items below
      //

      self.tempTaskId = taskId;

      // save the tags from the drop downs
      this.data.existingTags.push(self.$("#skills-required").select2('data'));
      this.data.existingTags.push(self.$("#people").select2('data'));
      this.data.existingTags.push(self.$("#time-required").select2('data'));
      this.data.existingTags.push(self.$("#time-estimate").select2('data'));
      this.data.existingTags.push(self.$("#length").select2('data'));

      var newTags = [];

      newTags = newTags.concat(self.$("#task_tag_topics").select2('data'),self.$("#task_tag_skills").select2('data'),self.$("#task_tag_location").select2('data'));

      async.forEach(
        newTags,
        function(newTag, callback) {
          return self.tagFactory.addTagEntities(newTag,self,callback);
        },
        function(err) {
          if (err) return next(err);
          self.trigger("newTagSaveDone");
        }
      );

    });
  },

  getTagsFromPage: function () {

    // Gather tags for submission after the task is created
    tags = {
      topic: this.$("#task_tag_topics").select2('data'),
      skill: this.$("#task_tagskills").select2('data'),
      location: this.$("#task_tag_location").select2('data'),
      'task-skills-required': [ this.$("#skills-required").select2('data') ],
      'task-people': [ this.$("#people").select2('data') ],
      'task-time-required': [ this.$("#time-required").select2('data') ],
      'task-time-estimate': [ this.$("#time-estimate").select2('data') ],
      'task-length': [ this.$("#length").select2('data') ]
    };

    return tags;
  },

  render: function () {
    var template = _.template(TaskFormTemplate)({ tags: this.tagSources })
    this.$el.html(template);
    this.initializeSelect2();
    this.initializeTextArea();

    // Important: Hide all non-currently opened sections of wizard.
    this.$("section:not(.current)").hide();
    this.$el.i18n();

    // Return this for chaining.
    return this;
  },

  v: function (e) {
    return validate(e);
  },

  childNext: function (e, current) {
    // find all the validation elements
    var children = current.find('.validate');
    var abort = false;
    _.each(children, function (child) {
      var iAbort = validate({ currentTarget: child });
      abort = abort || iAbort;
    });
    return abort;
  },

  initializeSelect2: function () {
    var self = this;

    self.tagFactory.createTagDropDown({type:"skill",selector:"#task_tag_skills",width: "100%",tokenSeparators: [","]});
    self.tagFactory.createTagDropDown({type:"topic",selector:"#task_tag_topics",width: "100%",tokenSeparators: [","]});
    self.tagFactory.createTagDropDown({type:"location",selector:"#task_tag_location",width: "100%",tokenSeparators: [","]});

    self.$(".el-specific-location").hide();

    // ------------------------------ //
    // PRE-DEFINED SELECT MENUS BELOW //
    // ------------------------------ //
    self.$("#skills-required").select2({
      placeholder: "Required/Not Required",
      width: 'resolve'
    });

    self.$("#time-required").select2({
      placeholder: 'Time Commitment',
      width: 'resolve'
    });

    self.$("#people").select2({
      placeholder: 'Personnel Needed',
      width: 'resolve'
    });

    self.$("#length").select2({
      placeholder: 'Deadline',
      width: 'resolve'
    });

    self.$("#time-estimate").select2({
      placeholder: 'Estimated Time Required',
      width: 'resolve'
    });

    self.$("#task-location").select2({
      placeholder: 'Work Location',
      width: 'resolve'
    });

  },

  initializeTextArea: function () {
    if (this.md) { this.md.cleanup(); }
    this.md = new MarkdownEditor({
      data: '',
      el: ".markdown-edit",
      id: 'task-description',
      placeholder: 'Description of ' + i18n.t('task') + ' including goals, expected outcomes and deliverables.',
      title: i18n.t('Task') + ' Description',
      rows: 6,
      validate: ['empty']
    }).render();
  },

  locationChange: function (e) {
    if (_.isEqual(e.currentTarget.value, "true")) {
      this.$(".el-specific-location").show();
    } else {
      this.$(".el-specific-location").hide();
    }
  },

  cleanup: function () {
    if (this.md) { this.md.cleanup(); }
    removeView(this);
  }

});

module.exports = TaskFormView;

},{"../../../../components/markdown_editor":104,"../../../../components/tag_factory":112,"../../../../entities/tasks/tasks_collection":125,"../../../../mixins/utilities":128,"../templates/task_form_template.html":91,"async":131,"backbone":133,"bootstrap":138,"underscore":159}],93:[function(require,module,exports){
var Bootstrap = require('bootstrap');
var _ = require('underscore');
var Backbone = require('backbone');
var Popovers = require('../../../../mixins/popovers');
var utils = require('../../../../mixins/utilities');
var BaseView = require('../../../../base/base_view');
var CommentListController = require('../../../comments/list/controllers/comment_list_controller');
var AttachmentView = require('../../../attachment/views/attachment_show_view');
var TaskItemView = require('../views/task_item_view');
var TagShowView = require('../../../tag/show/views/tag_show_view');
var ModalComponent = require('../../../../components/modal');
var ModalAlert = require('../../../../components/modal_alert');
var TaskEditFormView = require('../../edit/views/task_edit_form_view');
var UIConfig = require('../../../../config/ui.json');
var VolunteerSupervisorNotifyTemplate = require('../templates/volunteer_supervisor_notify_template.html');
var VolunteerTextTemplate = require('../templates/volunteer_text_template.html');
var ChangeStateTemplate = require('../templates/change_state_template.html');
var UpdateNameTemplate = require('../templates/update_name_template.html');


var popovers = new Popovers();

var TaskShowController = BaseView.extend({

  el: "#container",

  events: {
    'change .validate'                : 'v',
    'keyup .validate'                 : 'v',
    'click #task-edit'                : 'edit',
    'click #task-view'                : 'view',
    "click #like-button"              : 'like',
    'click #volunteer'                : 'volunteer',
    'click #volunteered'              : 'volunteered',
    "click #task-close"               : "stateChange",
    "click #task-reopen"              : "stateReopen",
    "click .link-backbone"            : linkBackbone,
    "click .delete-volunteer"         : 'removeVolunteer',
    "mouseenter .project-people-div"  : popovers.popoverPeopleOn,
    "click .project-people-div"       : popovers.popoverClick
  },

  initialize: function (options) {
    this.options = options;

    this.initializeTaskItemView();
    this.initializeChildren();

    //load user settings so they are available as needed
    this.getUserSettings(window.cache.currentUser);

  },

  initializeEdit: function () {
    var model = this.model.toJSON();
    // check if the user owns the task
    var owner = model.isOwner;
    if (owner !== true) {
      // if they don't own the task, do they own the project?
      if (!_.isUndefined(model.project)) {
        if (model.project.isOwner === true) {
          owner = true;
        }
      }
      // if none of these apply, are they an admin?
      if (window.cache.currentUser) {
        if (window.cache.currentUser.isAdmin === true) {
          owner = true;
        }
      }
    }
    // if not the owner, trigger the login dialog.
    if (owner !== true) {
      window.cache.userEvents.trigger("user:request:login", {
        message: "You are not the owner of this opportunity. <a class='link-backbone' href='/tasks/" + model.id + "'>View the opportunity instead.</a>",
        disableClose: true
      });
      return;
    }

    if (this.taskEditFormView) this.taskEditFormView.cleanup();
    this.taskEditFormView = new TaskEditFormView({
      el: '.edit-task-section',
      elVolunteer: '#task-volunteers',
      edit: true,
      taskId: this.model.attributes.id,
      model: this.model,
      tags: this.tags,
      madlibTags: this.madlibTags,
      tagTypes: this.tagTypes
    }).render();
    this.$(".task-show-madlib").hide();
    this.$(".li-task-view").show();
    this.$(".li-task-edit").hide();
    this.$(".task-view").hide();
  },

  initializeChildren: function () {
    var self = this;

    this.listenTo(this.model, 'task:show:render:done', function () {
      self.initializeHandlers();
      self.initializeLikes();

      if (window.cache.currentUser) {
        self.initializeVolunteers();
      }

      if (self.options.action == 'edit') {
        self.initializeEdit();
        popovers.popoverPeopleInit(".project-people-div");
      } else {
        popovers.popoverPeopleInit(".project-people-div");
        if (self.commentListController) self.commentListController.cleanup();
        self.commentListController = new CommentListController({
          target: 'task',
          id: self.model.attributes.id
        });
        if (self.attachmentView) self.attachmentView.cleanup();
        self.attachmentView = new AttachmentView({
          target: 'task',
          id: this.model.attributes.id,
          owner: this.model.attributes.isOwner,
          el: '.attachment-wrapper'
        }).render();
      }

      if (self.tagView) self.tagView.cleanup();
      self.tagView = new TagShowView({
        model: self.model,
        el: '.tag-wrapper',
        target: 'task',
        targetId: 'taskId',
        edit: false,
        url: '/api/tag/findAllByTaskId/'
      }).render();

    });
  },

  initializeLikes: function () {
    $("#like-number").text(this.model.attributes.likeCount);
    if (parseInt(this.model.attributes.likeCount) === 1) {
      $("#like-text").text($("#like-text").data('singular'));
    } else {
      $("#like-text").text($("#like-text").data('plural'));
    }
    if (this.model.attributes.like) {
      $("#like-button-icon").removeClass('fa fa-star-o');
      $("#like-button-icon").addClass('fa fa-star');
    }
  },

  initializeVolunteers: function () {
    if (this.model.attributes.volunteer) {
      $('.volunteer-true').show();
      $('.volunteer-false').hide();
    } else {
      $('.volunteer-true').hide();
      $('.volunteer-false').show();
    }
  },

  initializeHandlers: function() {
    this.listenTo(this.model, "task:update:state:success", function (data) {
      if (data.attributes.state == 'closed') {
        $("#li-task-close").hide();
        $("#li-task-reopen").show();
        $("#alert-closed").show();
      } else {
        $("#li-task-close").show();
        $("#li-task-reopen").hide();
        $("#alert-closed").hide();
      }
    });
  },
  initializeTaskItemView: function () {
    var self = this;
    // Get the tag type info from the view so we don't have to refetch
    this.listenTo(this.model, 'task:tag:types', function (data) {
      self.tagTypes = data;
    });
    this.listenTo(this.model, 'task:tag:data', function (tags, madlibTags) {
      self.tags = tags;
      self.madlibTags = madlibTags;
    });
    if (this.taskItemView) this.taskItemView.cleanup();
    this.taskItemView = new TaskItemView({
      model: this.options.model,
      router: this.options.router,
      id: this.options.id,
      el: this.el
    });
  },

  v: function (e) {
    return validate(e);
  },

  edit: function (e) {
    if (e.preventDefault) e.preventDefault();
    this.initializeEdit();
    popovers.popoverPeopleInit(".project-people-div");
    Backbone.history.navigate('tasks/' + this.model.id + '/edit');
  },

  view: function (e) {
    if (e.preventDefault) e.preventDefault();
    Backbone.history.navigate('tasks/' + this.model.id, { trigger: true });
  },

  like: function (e) {
    if (e.preventDefault) e.preventDefault();
    var self = this;
    var child = $(e.currentTarget).children("#like-button-icon");
    var likenumber = $("#like-number");
    // Not yet liked, initiate like
    if (child.hasClass('fa-star-o')) {
      child.removeClass('fa-star-o');
      child.addClass('fa-star');
      likenumber.text(parseInt(likenumber.text()) + 1);
      if (parseInt(likenumber.text()) === 1) {
        $("#like-text").text($("#like-text").data('singular'));
      } else {
        $("#like-text").text($("#like-text").data('plural'));
      }
      $.ajax({
        url: '/api/like/liket/' + this.model.attributes.id
      }).done( function (data) {
        // liked!
        // response should be the like object
        // console.log(data.id);
      });
    }
    // Liked, initiate unlike
    else {
      child.removeClass('fa-star');
      child.addClass('fa-star-empty');
      likenumber.text(parseInt(likenumber.text()) - 1);
      if (parseInt(likenumber.text()) === 1) {
        $("#like-text").text($("#like-text").data('singular'));
      } else {
        $("#like-text").text($("#like-text").data('plural'));
      }
      $.ajax({
        url: '/api/like/unliket/' + this.model.attributes.id
      }).done( function (data) {
        // un-liked!
        // response should be null (empty)
      });
    }
  },
  getUserSettings: function (userId) {
    //does this belong somewhere else?
    if ( _.isNull(userId) ){ return null; }
    $.ajax({
      url: '/api/usersetting/'+userId.id,
      type: 'GET',
      dataType: 'json'
    })
    .success(function(data){
      _.each(data,function(setting){
        //save active settings to the current user object
        if ( setting.isActive ){
          window.cache.currentUser[setting.key]=setting;
        }
      });
    });
  },

  deleteUserSettingByKey: function(settingKey) {
    //this function expects the entire row from usersetting in the form
    //     window.cache.currentUser[settingKey] = {}
    var self = this;

    //if not set skip
    var targetId =  ( window.cache.currentUser[settingKey] ) ? window.cache.currentUser[settingKey].id : null ;

    if ( targetId ){
      $.ajax({
        url: '/api/usersetting/'+targetId,
        type: 'DELETE',
        dataType: 'json'
      })
    }

  },

  saveUserSettingByKey: function(userId, options) {
    //this function expects the entire row from usersetting in the form
    //     window.cache.currentUser[settingKey] = {}
    var self = this;

    //are values the same, stop
    if ( options.newValue == options.oldValue ) { return true; }

    //if delete old is set, delete exisitng value
    //   default is delete
    if ( !options.deleteOld ){
      self.deleteUserSettingByKey(options.settingKey);
    }

    $.ajax({
        url: '/api/usersetting/',
        type: 'POST',
        dataType: 'json',
        data: {
          userId: userId,
          key: options.settingKey,
          value: options.newValue
        }
      });
  },

  volunteer: function (e) {
    if (e.preventDefault) e.preventDefault();
    if (!window.cache.currentUser) {
      window.cache.userEvents.trigger("user:request:login");
    } else {
      var self = this;
      var child = $(e.currentTarget).children("#like-button-icon");
      var originalEvent = e;

      if (this.modalAlert) { this.modalAlert.cleanup(); }
      if (this.modalComponent) { this.modalComponent.cleanup(); }

      // If user's profile has no name, ask them to enter one
      if (!window.cache.currentUser.name) {
        var modalContent = _.template(UpdateNameTemplate)({});
        this.modalComponent = new ModalComponent({
          el: "#modal-volunteer",
          id: "update-name",
          modalTitle: "What's your name?"
        }).render();
        this.modalAlert = new ModalAlert({
          el: "#update-name .modal-template",
          modalDiv: '#update-name',
          content: modalContent,
          validateBeforeSubmit: true,
          cancel: i18n.t('volunteerModal.cancel'),
          submit: i18n.t('volunteerModal.ok'),
          callback: function(e) {
            var name = $('#update-name-field').val();
            $.ajax({
              url: '/api/user/' + window.cache.currentUser.id,
              method: 'PUT',
              data: { name: name }
            }).done(function(user) {
              window.cache.currentUser.name = user.name;
              self.volunteer(originalEvent);
            });
          }
        }).render();
        return;
      }

      this.modalComponent = new ModalComponent({
        el: "#modal-volunteer",
        id: "check-volunteer",
        modalTitle: i18n.t("volunteerModal.title")
      }).render();

      if ( UIConfig.supervisorEmail.useSupervisorEmail ) {
        //not assigning as null because null injected into the modalContent var shows as a literal value
        //    when what we want is nothing if value is null
        var supervisorEmail = ( window.cache.currentUser.supervisorEmail ) ? window.cache.currentUser.supervisorEmail.value  : "";
        var supervisorName = ( window.cache.currentUser.supervisorName ) ? window.cache.currentUser.supervisorName.value : "";
        var validateBeforeSubmit = true;
        var modalContent = _.template(VolunteerSupervisorNotifyTemplate)({supervisorEmail: supervisorEmail,supervisorName: supervisorName});
      } else {
        validateBeforeSubmit = false;
        var modalContent = _.template(VolunteerTextTemplate)({});
      }

      this.modalAlert = new ModalAlert({
        el: "#check-volunteer .modal-template",
        modalDiv: '#check-volunteer',
        content: modalContent,
        cancel: i18n.t('volunteerModal.cancel'),
        submit: i18n.t('volunteerModal.ok'),
        validateBeforeSubmit: validateBeforeSubmit,
        callback: function (e) {
          if ( UIConfig.supervisorEmail.useSupervisorEmail ) {
            self.saveUserSettingByKey(window.cache.currentUser.id,{settingKey:"supervisorEmail",newValue: $('#userSuperVisorEmail').val(),oldValue: supervisorEmail});
            self.saveUserSettingByKey(window.cache.currentUser.id,{settingKey:"supervisorName",newValue: $('#userSuperVisorName').val(),oldValue: supervisorName});
          }
          // user clicked the submit button
          $.ajax({
            url: '/api/volunteer/',
            type: 'POST',
            data: {
              taskId: self.model.attributes.id
            }
          }).done( function (data) {
            $('.volunteer-true').show();
            $('.volunteer-false').hide();
            var html = '<div class="project-people-div" data-userid="' + data.userId + '" data-voluserid="' + data.userId + '"><img src="/api/user/photo/' + data.userId + '" class="project-people"/>';
            if (self.options.action === "edit") {
              html += '<a href="#" class="delete-volunteer volunteer-delete fa fa-times"  id="delete-volunteer-' + data.id + '" data-uid="' + data.userId + '" data-vid="' +  data.id + '"></a>';
            }
            html += '</div>';
            $('#task-volunteers').append(html);
            popovers.popoverPeopleInit(".project-people-div");
          });
        }
      }).render();
    }
  },

  volunteered: function (e) {
    if (e.preventDefault) e.preventDefault();
    // Not able to un-volunteer, so do nothing
  },

  removeVolunteer: function(e) {
    if (e.stopPropagation()) e.stopPropagation();
    if (e.preventDefault) e.preventDefault();
    $(e.currentTarget).off("mouseenter");
    $('.popover').remove();

    var vId = $(e.currentTarget).data('vid');
    var uId = $(e.currentTarget).data('uid');
    var self = this;

    if (typeof cache !== "undefined")
    {
      $.ajax({
        url: '/api/volunteer/' + vId,
        type: 'DELETE',
      }).done(function (data) {
          // done();
      });
    }

    var oldVols = this.model.attributes.volunteers || [];
    var unchangedVols = _.filter(oldVols, function(vol){ return ( vol.id !== vId ); } , this)  || [];
    this.model.attributes.volunteers = unchangedVols;
    $('[data-voluserid="' + uId + '"]').remove();
    if (window.cache.currentUser.id === uId) {
      $('.volunteer-false').show();
      $('.volunteer-true').hide();
    }
  },

  stateChange: function (e) {
    if (e.preventDefault) e.preventDefault();
    var self = this;

    if (this.modalAlert) { this.modalAlert.cleanup(); }
    if (this.modalComponent) { this.modalComponent.cleanup(); }
    var states = UIConfig.states;
    if (draftAdminOnly && !window.cache.currentUser.isAdmin) {
      states = _(states).reject(function(state) {
        return state.value === 'draft';
      });
    }

    var modalContent = _.template(ChangeStateTemplate)({model:self.model,states: states});
    this.modalComponent = new ModalComponent({
      el: "#modal-close",
      id: "check-close",
      modalTitle: "Change "+i18n.t("Task")+" State"
    }).render();

    this.modalAlert = new ModalAlert({
      el: "#check-close .modal-template",
      modalDiv: '#check-close',
      content: modalContent,
      cancel: 'Cancel',
      submit: 'Change '+i18n.t("Task")+' State',
      callback: function (e) {
        // user clicked the submit button
        self.model.trigger("task:update:state", $('input[name=opportunityState]:checked').val());
      }
    }).render();
  },

  stateReopen: function (e) {
    if (e.preventDefault) e.preventDefault();
    this.model.trigger("task:update:state", 'open');
  },

  cleanup: function () {
    if (this.taskEditFormView) this.taskEditFormView.cleanup();
    if (this.tagView) { this.tagView.cleanup(); }
    if (this.attachmentView) { this.attachmentView.cleanup(); }
    if (this.commentListController) { this.commentListController.cleanup(); }
    if (this.taskItemView) { this.taskItemView.cleanup(); }
    removeView(this);
  }

});

module.exports = TaskShowController;

},{"../../../../base/base_view":102,"../../../../components/modal":106,"../../../../components/modal_alert":107,"../../../../config/ui.json":116,"../../../../mixins/popovers":126,"../../../../mixins/utilities":128,"../../../attachment/views/attachment_show_view":23,"../../../comments/list/controllers/comment_list_controller":33,"../../../tag/show/views/tag_show_view":84,"../../edit/views/task_edit_form_view":87,"../templates/change_state_template.html":94,"../templates/update_name_template.html":96,"../templates/volunteer_supervisor_notify_template.html":97,"../templates/volunteer_text_template.html":98,"../views/task_item_view":99,"backbone":133,"bootstrap":138,"underscore":159}],94:[function(require,module,exports){
module.exports = "<div class=\"form-group\">\n\t<p>Please select the new state for the opportunity. The current state is checked and the available states are:\n\t\t<ul style='list-style-type:none'>\n\t\t\t<% _.each(states, function (t) { %>\n\t\t\t\t<li><input type='radio' name='opportunityState' value='<%- t.value %>'\n\t\t\t\t\t<% if ( t.value == model.attributes.state ) {%>\n\t\t\t\t\t\t<%- checked=\"checked\" %>\n\t\t\t\t\t<% } %>\n\t\t\t\t\t\t> <%- t.label %> </li>\n\t\t\t\t\t<% }); %>\n\t\t</ul>\n\t</p>\n</div>\n";

},{}],95:[function(require,module,exports){
module.exports = "<!-- ALERTS -->\n<div class=\"alert alert-danger\" id=\"alert-closed\" style=\"<% if (model.state != 'closed') { %>display: none;<% } %>\">This <span data-i18n=\"task\">opportunity</span> is <strong>closed</strong>.  It is no longer active, and no more modifications may be made.</div>\n\n<div class=\"row\">\n\n  <div class=\"col-md-push-4 col-sm-push-4 col-sm-8 col-md-8 md-nopadding-right\">\n    <div class=\"row\">\n      <div class=\"col-md-9 sm-nopadding md-nopadding\">\n        <div class=\"box box-main\">\n\n          <div class=\"main-section\">\n            <div class=\"edit-task-section\">\n\n              <h1><%- model.title %></h1>\n              <% if (!_.isUndefined(model.project) && ui.project.show) { %>\n              <div class=\"task-project\">\n                <a href=\"/projects/<%- model.projectId %>\" class=\"link-backbone\">\n                  <i class=\"fa fa-folder-o\"></i>\n                  <%- model.project.title %>\n                </a>\n              </div>\n              <% } %>\n\n              <div class=\"task-show-description\">\n                <%= model.descriptionHtml %>\n              </div>\n\n              <div class=\"task-show-creation\">\n                <span data-i18n=\"Task\">Opportunity</span> created <time class=\"timeago\" datetime=\"<%- model.createdAt %>\"><%- model.createdAt %></time>\n                <% if (model.createdAt != model.updatedAt) { %>\n                and updated <time class=\"timeago\" datetime=\"<%- model.updatedAt %>\"><%- model.updatedAt %></time>\n                <% } %>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n      <div class=\"col-md-3 padding-left-none sm-nopadding md-nopadding\">\n        <div class=\"box padding-none\">\n\n          <div class=\"navbar-side like-row border-bottom\">\n            <% if (user) { %>\n            <a href=\"#\" id=\"like-button\" class=\"like-button\">\n            <% } else { %>\n            <span class=\"like-button\">\n            <% } %>\n              <i id=\"like-button-icon\" class=\"fa fa-star-o fa-lg gold\"></i>\n            <% if (user) { %>\n            </a>\n            <% } else { %>\n            </span>\n            <% } %>\n            <span class=\"like-number\" id=\"like-number\"><%- model.likeCount %></span>\n            <span class=\"like-plural\" id=\"like-text\" data-plural=\"likes\" data-singular=\"like\">likes</span>\n          </div>\n          <div class=\"navbar-side border-bottom\">\n            <ul class=\"nav nav-pills nav-stacked\">\n              <li>\n                <a href=\"#\" id=\"email\"><i class=\"fa fa-envelope-o\"></i> <span class=\"box-icon-text\">Share</span></a>\n              </li>\n            </ul>\n          </div>\n          <% if (model.isOwner || (user && user.isAdmin)) { %>\n          <div class=\"navbar-side <% if (user) { %>border-bottom<% } %>\">\n            <div id=\"modal-close\"></div>\n            <ul class=\"nav nav-pills nav-stacked\">\n              <li class=\"li-task-edit\">\n                <a href=\"#\" id=\"task-edit\"><i class=\"fa fa-pencil\"></i> <span class=\"box-icon-text\">Edit <span data-i18n=\"Task\">Opportunity</span></span></a>\n              </li>\n              <li class=\"li-task-view\" style=\"display: none;\">\n                <a href=\"#\" id=\"task-view\"><i class=\"fa fa-pencil\"></i> <span class=\"box-icon-text\">View <span data-i18n=\"Task\">Opportunity</span></span></a>\n              </li>\n              <% if (!draftAdminOnly || model.state !== 'draft' || (user && user.isAdmin)) { %>\n              <li id=\"li-task-close\" style=\"<% if (model.state == 'closed') { %>display: none;<% } %>\">\n                <a href=\"#\" id=\"task-close\"><i class=\"fa fa-times-circle\"></i> <span class=\"box-icon-text\">Change <span data-i18n=\"Task\">Opportunity</span> State</span></a>\n              </li>\n              <% } else {%>\n                <li><span class=\"no-link\">This draft <span data-i18n=\"task\">opportunity</span> is awaiting approval from an administrator.</span></li>\n              <% } %>\n              <li id=\"li-task-reopen\" style=\"<% if (model.state != 'closed') { %>display: none;<% } %>\">\n                <a href=\"#\" id=\"task-reopen\"><i class=\"fa fa-share\"></i> <span class=\"box-icon-text\">Reopen</span></a>\n              </li>\n              <!--\n              <li>\n                <a href=\"#\" id=\"task-delete\"><i class=\"fa fa-trash-o\"></i> <span class=\"box-icon-text\">Delete <span data-i18n=\"Task\">Opportunity</span></span></a>\n              </li>\n              -->\n            </ul>\n          </div>\n          <% } %>\n          <div class=\"navbar-side border-bottom\" <% if (!vol) {%>style=\"display: none;\"<%}%>>\n            <div id=\"modal-volunteer\"></div>\n            <ul class=\"nav nav-pills nav-stacked\">\n              <li class=\"volunteer-true\" style=\"display: none;\">\n                <a href=\"#\" id=\"volunteered\" class=\"btn btn-c1\"><i class=\"fa fa-thumbs-up\"></i> <span class=\"box-icon-text\" data-i18n=\"taskPage.volunteeredButton\">Volunteered!</span></a>\n\n              </li>\n              <li class=\"volunteer-false\">\n                <a href=\"#\" id=\"volunteer\" class=\"btn btn-c2\"><i class=\"fa fa-thumbs-o-up\"></i> <span class=\"box-icon-text\" data-i18n=\"taskPage.volunteerButton\">Volunteer</span></a>\n              </li>\n            </ul>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"col-md-12 sm-nopadding md-nopadding\">\n        <div class=\"box box-main task-view\">\n          <div id=\"task-show-madlib-description\" class=\"task-show-description\">\n            We need\n              <strong>\n                <% if (madlibTags['task-people']) { %>\n                  <%= madlibTags['task-people'][0].name %>\n                <% } else { %>\n                  'no people yet assigned'\n                <% } %>\n              </strong>\n\n            <% if (madlibTags.topic) { %>\n            to work on an <span data-i18n=\"task\">opportunity</span> about:\n              <strong>\n                    <% _.each(madlibTags.topic, function (t, i) { %>\n                    <% if (i > 0) { %>\n                    ,\n                    <% } %>\n                    <%= t.name %>\n                    <% }) %>\n              </strong>.\n            <% } %>\n\n            <br />\n\n            The following skills are useful and\n              <strong>\n                <% if (madlibTags['task-skills-required']) { %>\n                  <%= madlibTags['task-skills-required'][0].name %>\n                <% } else { %>\n                  not required\n                <% } %>\n              </strong>\n\n            to complete this <span data-i18n=\"task\">opportunity</span>:\n              <strong>\n                <% if (madlibTags.skill) { %>\n                  <% _.each(madlibTags.skill, function (s, i) { %>\n                  <% if (i > 0) { %>\n                  ,\n                  <% } %>\n                  <%= s.name %>\n                  <% }) %>\n                <% } else { %>\n                  no special skills required\n                <% } %>\n              </strong>.\n\n\n            The <span data-i18n=\"task\">opportunity</span> will require\n              <strong>\n                <% if (madlibTags['task-time-estimate']) { %>\n                  <%= madlibTags['task-time-estimate'][0].name %>\n                <% } else { %>\n                  an unspecified amount of time\n                <% } %>\n              </strong>\n\n            of\n              <strong>\n                <% if (madlibTags['task-time-required']) { %>\n                  <%= madlibTags['task-time-required'][0].name %>\n                <% } else { %>\n                  unstructured\n                <% } %>\n              </strong>\n\n            work, and\n            <% if (madlibTags['task-length']) { %>\n            must be completed within\n              <strong>\n                <%= madlibTags['task-length'][0].name %></strong>.\n            <% } else { %>\n              <strong>\n                has no deadline.\n              </strong>\n            <% } %>\n\n            <% if (madlibTags.location) { %>\n            The participant(s) must be located at\n            <strong>\n              <% _.each(madlibTags.location, function (s, i) { %>\n              <% if (i > 0) { %>\n              ,\n              <% } %>\n              <%= s.name %>\n              <% }) %>\n            </strong>\n            to complete this <span data-i18n=\"task\">opportunity</span>.\n            <% } else { %>\n            The participant(s) can be located anywhere.\n            <% } %>\n            </strong>\n\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"col-md-12 sm-nopadding md-nopadding\">\n        <div class=\"box task-both\">\n          <div class=\"box-pad-lr border-bottom\">\n            <h2>Requestor and Participants\n            </h2>\n          </div>\n          <div class=\"box-main\" id=\"task-volunteers\">\n            <div class=\"project-people-div\" data-userid=\"<%= model.userId %>\">\n              <img src=\"/api/user/photo/<%= model.userId %>\" class=\"project-people\" alt=\"<%= model.owner.name %>\"/>\n            </div>\n            <div class=\"project-people-space\">\n              <div class=\"bar\">\n              </div>\n            </div>\n            <% _.each(model.volunteers, function (v) { %>\n            <div class=\"project-people-div\" data-userid=\"<%= v.userId %>\" data-voluserid=\"<%= v.userId %>\">\n              <img src=\"/api/user/photo/<%= v.userId %>\" class=\"project-people\" alt=\"<%= v.name %>\"/>\n            </div>\n            <% }); %>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"col-md-12 task-view sm-nopadding md-nopadding\">\n\n        <div class=\"box comment-list-wrapper\" style=\"clear: both;\">\n          <div class=\"box-pad-lr border-bottom\">\n            <h2>Discussion\n            <% if (user) { %>\n            <button class=\"btn btn-c0 btn-sm file-add new-topic\" id=\"project-topic-new\">New Topic</button>\n            <% } %>\n            </h2>\n          </div>\n          <div class=\"\">\n            <div class=\"box-pad-lr box-pad-t topic-form-wrapper\"></div>\n            <ul id=\"comment-list-null\">\n            </ul>\n          </div>\n        </div>\n      </div>\n    </div>\n\n  </div>\n\n  <div class=\"col-md-pull-8 col-sm-pull-8 col-sm-4 col-md-4 project-sidebar md-nopadding-right\">\n    <!-- LEFT SIDEBAR -->\n    <div class=\"row\">\n      <div class=\"col-md-12 box sm-nopadding\">\n        <div class=\"box-main tag-wrapper\">\n        </div>\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"col-md-12 box task-view sm-nopadding\">\n        <div class=\"attachment-wrapper\">\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n";

},{}],96:[function(require,module,exports){
module.exports = "<p>In order to introduce you as part of the sign up process, we would like to fill in your profile. Please enter your name:</p>\n<div class=\"form-group\">\n  <input type=\"text\" class=\"form-control validate\" id=\"update-name-field\" name=\"update-name-field\" placeholder=\"Full Name\" data-validate=\"empty\">\n  <span class=\"help-block error-empty\" style=\"display:none;\">Please enter your full name.</span>\n</div>\n";

},{}],97:[function(require,module,exports){
module.exports = "<div class=\"form-group\">\n\t<p>Thank you for volunteering. Please be sure you have the availability and expertise to support this opportunity to completion. We will notify your supervisor of your interest in this project so that he or she is aware that you plan to include this work during your regularly scheduled work week to support Department colleagues and projects. Kudos to you!</p>\n\t<p>Please enter  the name and email address of your supervisor below. If you’ve previously volunteered, the last supervisor email you provided is shown. Please update it if necessary.</p>\n\t<span class=\"form-group\">\n\t\t<input type=\"text\" id=\"userSuperVisorName\" placeholder=\"Supervisor Name\" class=\"validate\" data-validate=\"empty\" value=\"<%= supervisorName %>\"/>\n\t\t<input type=\"text\" id=\"userSuperVisorEmail\" placeholder=\"Supervisor email address\" class=\"validate\" data-validate=\"empty,email,emaildomain\" data-emaildomain=\"state.gov\" value=\"<%= supervisorEmail %>\"/>\n\t\t<span class=\"help-block error-email error-empty error-emaildomain\" style=\"display:none;\">You must enter a name and a valid State Department email address to proceed.</span>\n\t</span>\n</div>\n";

},{}],98:[function(require,module,exports){
module.exports = "<p data-i18n=\"volunteerModal.notifySupervisor\">I understand it is my responsibility to confirm supervisor approval prior to committing to an opportunity.</p>\n<p data-i18n=\"volunteerModal.cantCancel\">Once you volunteer for an opportunity, you will not be able to cancel your commitment to volunteer.</p>\n";

},{}],99:[function(require,module,exports){
var Bootstrap = require('bootstrap');
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../../../../mixins/utilities');
var UIConfig = require('../../../../config/ui.json');
var async = require('async');
var marked = require('marked');
var TimeAgo = require('../../../../../vendor/jquery.timeago');
var BaseView = require('../../../../base/base_view');
var TaskShowTemplate = require('../templates/task_show_item_template.html');


var TaskItemView = BaseView.extend({

  initialize: function (options) {
    var self = this;
    this.options = options;
    this.model.trigger("task:model:fetch", options.id);
    this.listenTo(this.model, "task:model:fetch:success", function (model) {
      self.model = model;
      self.initializeTags(self);
    });
  },

  getTagData: function (self, cb) {
    $.ajax({
      url: '/api/tag/findAllByTaskId/' + self.options.id,
      async: false,
      success: function (data) {
        self.tags = [];
        for (var i = 0; i < data.length; i += 1) {
          self.tags.push(data[i]);
        }
        // Build object for render
        self.data = {
          user: window.cache.currentUser,
          model: self.model.toJSON(),
          tags: self.tags
        };
        self.data['madlibTags'] = organizeTags(self.tags);
        // convert description from markdown to html
        self.data.model.descriptionHtml = marked(self.data.model.description);
        self.model.trigger('task:tag:data', self.tags, self.data['madlibTags']);
        return cb();
      }
    });

  },

  render: function (self) {
    self.getTagData(self, function () {
      var d = self.data,
          vol = ((!d.user || d.user.id !== d.model.userId) && d.model.state !== 'draft');
      self.data.ui = UIConfig;
      self.data.vol = vol;
      var compiledTemplate = _.template(TaskShowTemplate)(self.data);
      self.$el.html(compiledTemplate);
      self.$el.i18n();
      $("time.timeago").timeago();
      self.updateTaskEmail();
      self.model.trigger('task:show:render:done');
    });
  },

  updateTaskEmail: function() {
    var self = this;
    $.ajax({
      url: encodeURI('/api/email/makeURL?email=contactUserAboutTask&subject=Check Out "'+ self.model.attributes.title + '"' +
      '&opportunityTitle=' + self.model.attributes.title +
      '&opportunityLink=' + window.location.protocol + "//" + window.location.host + "" + window.location.pathname +
      '&opportunityDescription=' + (self.model.attributes.description || '') +
      '&opportunityMadlibs=' + $('<div />', { html: self.$('#task-show-madlib-description').html() }).text().replace(/\s+/g, " ")),
      type: 'GET'
    }).done( function (data) {
      self.$('#email').attr('href', data);
    });

  },

  initializeTags: function (self) {
    var types = ["task-skills-required", "task-time-required", "task-people", "task-length", "task-time-estimate"];

    self.tagSources = {};

    var requestAllTagsByType = function (type, cb) {
      $.ajax({
        url: '/api/ac/tag?type=' + type + '&list',
        type: 'GET',
        async: false,
        success: function (data) {
          // Dynamically create an associative
          // array based on that for the pointer to the list itself to be iterated through
          // on the front-end.
          self.tagSources[type] = data;
          return cb();
        }
      });
    }

    async.each(types, requestAllTagsByType, function (err) {
      self.model.trigger('task:tag:types', self.tagSources);
      self.render(self);
    });
  },

  cleanup: function() {
    removeView(this);
  }
});

module.exports = TaskItemView;

},{"../../../../../vendor/jquery.timeago":130,"../../../../base/base_view":102,"../../../../config/ui.json":116,"../../../../mixins/utilities":128,"../templates/task_show_item_template.html":95,"async":131,"backbone":133,"bootstrap":138,"marked":155,"underscore":159}],100:[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');


	BaseComponent = Backbone.View.extend({

		initialize: function () {}

	});

	module.exports = BaseComponent;

},{"backbone":133,"underscore":159}],101:[function(require,module,exports){
// Base Controller


var _ = require('underscore');
var Backbone = require('backbone');


	BaseController = Backbone.View.extend({
		
		initialize: function () {},

		// ------------
		//= Class Methods available for other views 
		// ------------

		initializeViewSafely: function (viewName) {
			if (this.view) {
				this.view.initialize();
			} else {
				this.view = new viewName();
			}
		},

		cleanup: function () {
			$(this).remove();
		}

	});

	module.exports = BaseController;


},{"backbone":133,"underscore":159}],102:[function(require,module,exports){
// This class implements a paradigm wherein it renders its own child class.
// Doing this allows us to perform logic against it.

// NOTES:
// 'this' refers to the prototype class, not the constructor (logical this).
// This is very useful for smaller el regions, such as a task list
// or anything that requires a small spinner.  Currently to add a bigger spinner
// I'd have to exchange the gif currently provided by font-awesome.


var _ = require('underscore');
var Backbone = require('backbone');
var utilities = require('../mixins/utilities');


var BaseView = Backbone.View.extend({

  initialize: function () {
  },

  cleanup: function () {
    removeView(this);
  }

});

module.exports = BaseView;

},{"../mixins/utilities":128,"backbone":133,"underscore":159}],103:[function(require,module,exports){
module.exports = "<div class=\"alert <% if (alert.type) { %><%= alert.type %><% } else { %>alert-danger<% } %>\" id=\"alert-main\">\n  <% if (alert.dismiss) { %>\n  <button type=\"button\" class=\"close\" data-dismiss=\"alert\" aria-hidden=\"true\">&times;</button>\n  <% } %>\n  <%= alert.message %>\n</div>\n";

},{}],104:[function(require,module,exports){
/**
 * This component implements a Markdown TextEditor that can be
 * dropped into anywhere on an existing form.
 * Initialize the MarkdownEditor with an element `el`,
 * and the `id` of the textarea (so you can retreive its
 * value when the user submits the form.)
 *
 * Options:
 *   el: HTML element to fill - required
 *   id: HTML ID for the <textarea> element - required
 *   data: Default data for the textarea - required
 *   placeholder: Textarea placeholder value - optional
 *   maxlength: Maximum characters for the text area - optional
 *   rows: Number of rows in the textarea - optional
 *   validate: List of strings for the data-validate attribute - optional
 *     example: ['empty', 'count400']
 */

var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../mixins/utilities');
var marked = require('marked');
var BaseComponent = require('../base/base_component');
var jqSelection = require('../../vendor/jquery.selection');
var EditorTemplate = require('./markdown_editor_template.html');


MarkdownEditor = BaseComponent.extend({

  events: {
    "click .btn"                 : "clickButton"
  },

  initialize: function (options) {
    this.options = options;
    this.actions = {
      'bold': {
        before: '**',
        text: 'text',
        after: '**'
      },
      'italic': {
        before: '_',
        text: 'text',
        after: '_'
      },
      'strikethrough': {
        before: '~~',
        text: 'text',
        after: '~~'
      },
      'code': {
        before: '`',
        text: 'code',
        after: '`'
      },
      'link': {
        before: '[Link Title](',
        text: 'http://',
        after: ')'
      }
    }
    return this;
  },

  render: function () {
    var data = {
      id: this.options.id,
      validate: this.options.validate,
      rows: this.options.rows,
      maxlength: this.options.maxlength,
      placeholder: this.options.placeholder,
      title: this.options.title,
      data: this.options.data
    };
    var template = _.template(EditorTemplate)(data);
    this.$el.html(template);
    return this;
  },

  clickButton: function (e) {
    var self = this;
    if (e.preventDefault) e.preventDefault();
    var t = $(e.currentTarget);
    var selText = this.$("#" + this.options.id).selection();
    var editData = t.data('edit');
    if ((editData != 'preview') &&
        (editData != 'edit') &&
        (editData != 'help')) {
      // get the current selected positions
      var pos = this.$("#" + this.options.id).selection('getPos');
      var text = this.$("#" + this.options.id).val();
      // check if this modifier has already been inserted
      var origBefore = text.substring(pos.start-this.actions[editData].before.length,pos.start);
      var origAfter = text.substring(pos.end,pos.end+this.actions[editData].after.length);
      var before = this.actions[editData].before;
      var after = this.actions[editData].after;
      // If the selected text already has the markdown syntax before and after
      // don't insert it again.  Eg, if text is selected in **text**, don't add ** again
      if ((origBefore == before) && (origAfter == after)) {
        before = '';
        after = '';
      }
      // set placeholder text if no text is selected by the user
      if (selText == '') {
        selText = this.actions[editData].text;
      }
      // insert markdown syntax
      this.$("#" + this.options.id).selection('insert', {
        text: before,
        mode: 'before'
      })
      .selection('replace', {
        text: selText
      })
      .selection('insert', {
        text: after,
        mode: 'after'
      });
    } else if (editData == 'help') {
      // show help text and links to markdown syntax
      if (this.$('.help').is(':visible')) {
        this.$('.help').hide();
        t.removeClass('active');
      } else {
        this.$('.help').show();
        t.addClass('active');
      }
    } else {
      if (this.$('.preview').is(':visible')) {
        // if we're in preview mode, switch back to edit mode
        this.$('.btn-edit').hide();
        this.$('.btn-preview').show();
        this.$('.preview').hide();
        this.$("#" + this.options.id).show();
      } else {
        // render the preview using marked
        var html = marked(this.$("#" + this.options.id).val());
        this.$('.btn-preview').hide();
        this.$('.btn-edit').show();
        this.$('.preview').html(html);
        this.$("#" + this.options.id).hide();
        this.$('.preview').show();
      }
    }
  },

  cleanup: function () {
    removeView(this);
  }

});

module.exports = MarkdownEditor;

},{"../../vendor/jquery.selection":129,"../base/base_component":100,"../mixins/utilities":128,"./markdown_editor_template.html":105,"backbone":133,"marked":155,"underscore":159}],105:[function(require,module,exports){
module.exports = "<div class=\"btn-toolbar\" role=\"toolbar\">\n  <div class=\"btn-group btn-group-sm\">\n    <button type=\"button\" class=\"btn btn-c0\" data-edit=\"bold\" title=\"Bold\"><i class=\"fa fa-bold\" alt=\"Bold\"></i></button>\n    <button type=\"button\" class=\"btn btn-c0\" data-edit=\"italic\" title=\"Italic\"><i class=\"fa fa-italic\" alt=\"Italic\"></i></button>\n    <button type=\"button\" class=\"btn btn-c0\" data-edit=\"strikethrough\" title=\"Strikethrough\"><i class=\"fa fa-strikethrough\" alt=\"Strikethrough\"></i></button>\n    <button type=\"button\" class=\"btn btn-c0\" data-edit=\"code\" title=\"Code\"><i class=\"fa fa-code\" alt=\"Code\"></i></button>\n  </div>\n  <div class=\"btn-group btn-group-sm\">\n    <button type=\"button\" class=\"btn btn-c0\" data-edit=\"link\" title=\"Link\"><i class=\"fa fa-link\" alt=\"Link\"></i></button>\n  </div>\n  <div class=\"btn-group btn-group-sm\">\n    <button type=\"button\" class=\"btn btn-c0\" data-edit=\"help\"><i class=\"fa fa-question-circle\" alt=\"Help\"></i> Help</button>\n  </div>\n\n  <div class=\"btn-group btn-group-sm\">\n    <button type=\"button\" class=\"btn btn-c1 btn-preview\" data-edit=\"preview\"><i class=\"fa fa-eye\" alt=\"Open\"></i> Preview</button>\n  </div>\n  <div class=\"btn-group btn-group-sm\">\n    <button type=\"button\" class=\"btn btn-c1 btn-edit\" data-edit=\"edit\" style=\"display: none;\"><i class=\"fa fa-pencil\" alt=\"Edit\"></i> Edit</button>\n  </div>\n</div>\n<div class=\"help\">\n  You can use any <a href=\"http://daringfireball.net/projects/markdown/syntax\" target=\"_blank\">Markdown</a> or <a href=\"https://help.github.com/articles/github-flavored-markdown\" target=\"_blank\">GitHub Flavored Markdown</a> syntax in this text box.\n</div>\n<textarea\n  <%if (!_.isUndefined(maxlength)) { %>maxlength=\"<%= maxlength %>\"<% } %>\n  <% if (!_.isUndefined(rows)) { %>rows=\"<%= rows %>\"<% } %>\n  class=\"form-control validate\"\n  id=\"<%= id %>\"\n  data-validate=\"<% if (!_.isUndefined(validate)) { %><%= validate.join(',') %><% } %>\"\n  <% if (!_.isUndefined(placeholder)) { %>placeholder=\"<%= placeholder %>\"<% } %>\n  <% if (!_.isUndefined(title)) { %>title=\"<%= title %>\"<% } %>\n  ><%= data %></textarea>\n<div class=\"preview\" style=\"display: none;\"></div>\n";

},{}],106:[function(require,module,exports){
/**
 * The Modal component needs to be set to the el: of the parent view
 * you are trying to init it within, then you will be appending the modal-template to that
 * view (this).  Then the form view has an el of $(".modal-body") so that the form will render
 * within that body area.
 * Then all you have to do is set the ID of the modal to the ID of the link you are trying
 * to trigger from as per bootstrap BP.
 */

var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../mixins/utilities');
var BaseComponent = require('../base/base_component');
var ModalTemplate = require('./modal_template.html');


Modal = BaseComponent.extend({

  events: {
    "click .link-backbone"  : "link"
  },

  initialize: function (options) {
    this.options = options;
  },

  render: function () {
    var data = {
      id: this.options.id,
      modalTitle: this.options.modalTitle,
      disableClose: this.options.disableClose
    };

    var compiledTemplate = _.template(ModalTemplate)(data);
    this.$el.append(compiledTemplate);

    return this;
  },

  link: function (e) {
    if (e.preventDefault) e.preventDefault();
    // hide the modal, wait for it to close, then navigate
    $('#' + this.options.id).bind('hidden.bs.modal', function() {
      linkBackbone(e);
    }).modal('hide');
  },

  cleanup: function () {
    removeView(this);
  }

});

module.exports = Modal;

},{"../base/base_component":100,"../mixins/utilities":128,"./modal_template.html":109,"backbone":133,"underscore":159}],107:[function(require,module,exports){
var Bootstrap = require('bootstrap');
var _ = require('underscore');
var Backbone = require('backbone');
var utils = require('../mixins/utilities');
var ModalTemplate = require('./modal_alert_template.html');


var ModalAlert = Backbone.View.extend({

  events: {
    "submit #modal-form"    : "post"
  },

  initialize: function (options) {
    this.options = options;
  },

  render: function () {
    var template = _.template(ModalTemplate)(this.options);
    this.$el.html(template);
    this.$el.i18n();
    $(this.options.modalDiv).modal('show');
    return this;
  },

  post: function (e) {
    var self = this;
    var hasError = false;

    if (e.preventDefault) e.preventDefault();

    //check any .validate elements and don't submit if they fail
    if ( self.options.validateBeforeSubmit ){
      $(".validate").each(function(index){
        hasError = validate({currentTarget: this});
        if ( hasError ){ return false; }
      });
    }

    if ( !hasError ) {
      $(this.options.modalDiv).bind('hidden.bs.modal', function() {
        self.options.callback(e);
      }).modal('hide');
    }
  },

  cleanup: function () {
    removeView(this);
  }

});

module.exports = ModalAlert;

},{"../mixins/utilities":128,"./modal_alert_template.html":108,"backbone":133,"bootstrap":138,"underscore":159}],108:[function(require,module,exports){
module.exports = "<form role=\"form\" action=\"\" id=\"modal-form\">\n  <div class=\"modal-body\">\n    <%= content %>\n  </div>\n  <div class=\"modal-footer\">\n    <button type=\"button\" class=\"btn btn-c0\" data-dismiss=\"modal\"><%= cancel %></button>\n    <input type=\"submit\" class=\"btn btn-c2\" id=\"submit\" value=\"<%= submit %>\"/>\n  </div>\n</form>\n";

},{}],109:[function(require,module,exports){
module.exports = "<div class=\"modal fade\"\n  id=\"<%- id %>\"\n  role=\"dialog\"\n  aria-hidden=\"true\"\n  tabindex=\"-1\"\n  <% if (disableClose === true) { %>\n  data-backdrop=\"static\"\n  data-keyboard=\"false\"\n  <% } %>\n  >\n  <div class=\"modal-dialog\">\n    <div class=\"modal-content\">\n      <div class=\"modal-header\">\n        <% if (disableClose !== true) { %>\n        <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-hidden=\"true\">&times;</button>\n        <% } %>\n        <h4 class=\"modal-title\"><%- modalTitle %></h4>\n      </div>\n\n      <div class=\"modal-template\">\n\n      </div>\n    </div><!-- /.modal-content -->\n  </div><!-- /.modal-dialog -->\n</div><!-- /.modal -->\n";

},{}],110:[function(require,module,exports){
// Similar to Modal component in every way in all ways but two:
// 1) This modal has a next button instead of save button.
// 2) This modal has some expectations inside the modal-body form.
//    ^ More on this below
//
// This is all the component expects for it to work:
// <div class='modal-body'>
//  <section class="current">First content section</section>
//  <section>Second content section</section>
//  <section>Third content section</section>
//  <!-- and so on -->
// </div>
//
// REMEMBER: This goes inside your formTemplate.  This
// is the ModalWizardComponent, which is scoped to list controller,
// then the Form itself for the addition to the list is scoped to the
// modal-body within this modal-component template.

var _ = require('underscore');
var Backbone = require('backbone');
var utilities = require('../mixins/utilities');
var BaseView = require('../base/base_view');
var ModalWizardTemplate = require('./modal_wizard_template.html');


ModalWizard = BaseView.extend({

  events: {
    "click .wizard-forward" : "moveWizardForward",
    "click .wizard-backward": "moveWizardBackward",
    "click .wizard-submit"  : "submit",
    "click .wizard-cancel"  : "cancel"
  },

  initialize: function (options) {
    this.options = options;
    this.initializeListeners();
  },

  initializeListeners: function () {
    var self = this;
    if (this.model) {
      this.listenTo(this.model, this.options.modelName + ':modal:hide', function () {
        $('.modal.in').modal('hide');
      });
    }
  },

  render: function () {
    var data = {
      id: this.options.id,
      modalTitle: this.options.modalTitle,
      draft: this.options.draft
    };
    var compiledTemplate = _.template(ModalWizardTemplate)(data);
    this.$el.html(compiledTemplate);
    return this;
  },

  /**
   * Set the child of this view, so we can remove it
   * when the view is destroyed
   * @return this for chaining
   */
  setChildView: function (view) {
    this.childView = view;
    return this;
  },

  /**
   * Set the callback on the next button of the modal.
   * Useful for callbacks
   * @return this for chaining
   */
  setNext: function (fn) {
    this.childNext = fn;
    return this;
  },

  /**
   * Set the callback on the submit button of the modal.
   * Useful for callbacks
   * @return this for chaining
   */
  setSubmit: function (fn) {
    this.childSubmit = fn;
    return this;
  },

  // In order for the ModalWizard to work it expects a section
  // by section layout inside the modal, with a 'current' class on
  // the first you want to always start on (re)render.
  moveWizardForward: function (e) {
    if (e.preventDefault) e.preventDefault();
    var self = this;

    // Store $(".current") in cache to reduce query times for DOM lookup
    // on future children and adjacent element to the current el.
    var current   = $(".current"),
        next      = current.next(),
        nextHtml  = next.html();

    // Notify the sub-view to see if it is safe to proceed
    // if not, return and stop processing.
    var abort = false;
    if (this.childNext) {
      abort = this.childNext(e, current);
    }
    if (abort === true) {
      return;
    }

    var nextWizardStep = {
      exists: function () {
        return !_.isUndefined(next.next().html());
      },
      doesNotExist: function () {
        return _.isUndefined(next.next().html());
      }
    };

    hideCurrentAndInitializeNextWizardStep();
    if (nextWizardStep.doesNotExist()) {
      $("button.wizard-forward").hide();
      $("button.wizard-submit").show();
    }

    function hideCurrentAndInitializeNextWizardStep () {
      current.hide();
      current.removeClass("current");
      next.addClass("current");
      next.show();
    };
  },

  moveWizardBackward: function (e) {
    if (e.preventDefault) e.preventDefault();

    var current   = $(".current"),
        prev      = current.prev(),
        prevHtml  = prev.html();

    if (!_.isUndefined(prevHtml)) {
      current.hide();
      current.removeClass("current");
      prev.addClass("current");
      prev.show();
      $("button.wizard-forward").show();
      $("button.wizard-submit").hide();
    } else {
      return;
    }
  },

  // Dumb submit.  Everything is expected via a promise from
  // from the instantiation of this modal wizard.
  submit: function (e) {
    if (e.preventDefault) e.preventDefault();

    var d = this.options.data(this);
    var abort = false;
    var state = $(e.currentTarget).data('state');

    // pass the data to the view
    if (this.childSubmit) {
      // if submit returns true, abort modal processing
      abort = this.childSubmit(e, this.$(".current"));
    }

    if (abort === true) {
      return;
    }

    $('.modal.in').modal('hide');
    if (state) d.state = state;
    this.collection.trigger(this.options.modelName + ":save", d);
  },

  cancel: function (e) {
    if (e.preventDefault) e.preventDefault();
    $('.modal.in').modal('hide');
  },

  cleanup: function () {
    if (this.childView) { this.childView.cleanup(); }
    removeView(this);
  }
});

module.exports = ModalWizard;

},{"../base/base_view":102,"../mixins/utilities":128,"./modal_wizard_template.html":111,"backbone":133,"underscore":159}],111:[function(require,module,exports){
module.exports = "<div class=\"modal fade\" id=\"<%- id %>\" role=\"dialog\" aria-hidden=\"true\" tabindex=\"-1\">\n  <div class=\"modal-dialog\">\n    <div class=\"modal-content\">\n      <div class=\"modal-header\">\n        <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-hidden=\"true\">&times;</button>\n        <h4 class=\"modal-title\"><%- modalTitle %></h4>\n      </div>\n\n      <div class=\"modal-body\">\n\n      </div>\n\n      <div class=\"modal-footer\">\n        <button type=\"button\" class=\"btn btn-c0 wizard-cancel\" data-dismiss=\"modal\">Cancel</button>\n        <% if (draft) { %><button type=\"button\" class=\"btn btn-c0 wizard-submit\" data-state=\"draft\">Save Draft</button><% } %>\n        <button type=\"button\" class=\"btn btn-c2 wizard-backward\"><i class=\"fa fa-chevron-left\"></i> Back</button>\n        <button type=\"button\" class=\"btn btn-c2 wizard-forward\">Next <i class=\"fa fa-chevron-right\"></i></button>\n        <button type=\"button\" class=\"btn btn-c2 wizard-submit\" style=\"display: none;\">Create</button>\n      </div>\n\n    </div><!-- /.modal-content -->\n  </div><!-- /.modal-dialog -->\n</div>\n";

},{}],112:[function(require,module,exports){
/**
 * This component implements a tag widget, allowing creation lookup and deletion of tags from a common ui element
 *
 * Options:
 *
 */

var _ = require('underscore');
var Backbone = require('backbone');
var async = require('async');
var utils = require('../mixins/utilities');
var marked = require('marked');
var BaseComponent = require('../base/base_component');
var jqSelection = require('../../vendor/jquery.selection');


TagFactory = BaseComponent.extend({

	initialize: function (options) {
    this.options = options;

    return this;
  },

  addTagEntities: function (tag, context, done) {
  	//assumes
  	//  tag -- array of tag objects to add
  	//  tagType -- string specifying type for tagEntity table
    var self = this;

  	//this is current solution to mark a tag object as on the fly added
      if ( !tag || typeof tag.unmatched == 'undefined' || !tag.unmatched ){
        return done();
      }
    //remove the flag that marks them as new
    delete tag.unmatched;

    $.ajax({
      url: '/api/tagEntity',
      type: 'POST',
      data: {
        type: tag.tagType,
        name: tag.id,
        data: tag.data
      },
      success: function (data){
        if (context.data) {
          context.data.newTag = data;
          context.data.newItemTags.push(data);
        }
        return done(null, data);
      }
    });
  },

  removeTag: function (id, done) {
    $.ajax({
      url: '/api/tag/' + id,
      type: 'DELETE',
      success: function (data) {
        return done();
      }
    });
  },

  addTag: function (tag, modelId, modelType, done) {
  	//assumes
  	//  tag -- array of tag objects to add
  	//  --- NYI ---
  	//  project or task id - string
    // TODO: abstract the below if-else to a different function so this funciton just takes an array tag ids

    var tagMap = {};
    tagMap[modelType] = modelId;

    if ( _.isFinite(tag) ){
        // --- NYI ---
        // or project id

        tagMap.tagId = tag;
    } else {
        // --- NYI ---
        // or project id

        tagMap.tagId = tag.id;
    }

    $.ajax({
      url: '/api/tag',
      type: 'POST',
      data: tagMap,
      success: function (data) {
        return done();
      },
      error: function (err) {
        return done(err);
      }
    });

  },

  createTagDropDown: function(options) {
    var settings = {
          placeholder: "Start typing to select a "+options.type,
          minimumInputLength: 2,
          multiple: true,
          width: options.width || "500px",
          tokenSeparators: options.tokenSeparators || [],
          formatResult: function (obj, container, query) {
            return obj.name;
          },
          formatSelection: function (obj, container, query) {
            return obj.name;
          },
          createSearchChoice: function (term) {
            //unmatched = true is the flag for saving these "new" tags to tagEntity when the opp is saved
            return {
              unmatched: true,
              tagType: options.type,
              id: term,
              value: term,
              temp: true,
              name: "<b>"+term+"</b> <i>" + ((options.type !== 'location') ?
                "click to create a new tag with this value" :
                "search for this location") + "</i>"
            };
          },
          ajax: {
            url: '/api/ac/tag',
            dataType: 'json',
            data: function (term) {
              return {
                type: options.type,
                q: term
              };
            },
            results: function (data) {
              return { results: data }
            }
          }
        },
      $sel = self.$(options.selector);
    $sel.remote = true;
    $sel.select2(settings).on("select2-selecting", function (e) {
      if (e.choice.tagType === 'location') {
        var $el = self.$(e.currentTarget);
        if (e.choice.temp) {
          e.choice.name = '<em>Searching for <strong>' +
            e.choice.value + '</strong></em>';
          this.temp = true;
          $.get('/api/location/suggest?q=' + e.choice.value, function(d) {
            d = _(d).map(function(item) {
              return {
                id: item.name,
                name: item.name,
                unmatched: true,
                tagType: 'location',
                data: _(item).omit('name')
              };
            });
            var items = $sel.select2('data');
            this.cache = _.reject(items, function(item) {
              return (item.name.indexOf('<em>Searching for <strong>') >= 0);
            });
            $sel.select2({
              multiple: true,
              data: { results: d, text: 'name' }
            }).select2('data', this.cache).select2('open');
            $sel.remote = false;
          });
        } else {
          this.reload = true;
          delete this.temp;
        }
      } else {
        if ( e.choice.hasOwnProperty("unmatched") && e.choice.unmatched ){
          //remove the hint before adding it to the list
          e.choice.name = e.val;
        }
      }
    }).on('select2-blur', function(e) {
      if (!this.reload && this.temp) {
        this.reload = true;
        delete this.temp;
      }
    }).on('select2-open', function(e) {
      var el = this;
      if (this.reload) {
        this.cache = $sel.select2('data');
        setTimeout(function(){
          $sel.select2(settings).select2('data', el.cache).select2('open');
        }, 0);
        delete this.reload;
      }
    });
  },

  createDiff: function ( oldTags, currentTags){
    //sort tags into their needed actions
    //

    var out = {
      remove: [],
      add: [],
      none: []
    };

    var none = null;

    _.each(oldTags, function (oTag,oi){

      none = null;

      _.each(currentTags, function (cTag, ci){
          if (cTag && parseInt(cTag.id) == oTag.tagId ){
            currentTags.splice(ci,1);
            none = oi;
          }
        });

      if( _.isFinite(none) ){
        out.none.push(parseInt(oldTags[none].tagId));
      } else {
        out.remove.push(parseInt(oTag.id));
      }
    });

    out.add = currentTags;

    return out;
  }

});

module.exports = TagFactory;

},{"../../vendor/jquery.selection":129,"../base/base_component":100,"../mixins/utilities":128,"async":131,"backbone":133,"marked":155,"underscore":159}],113:[function(require,module,exports){
module.exports={
  "resGetPath"      : "/locales/__lng__/__ns__.json",

  "lng"             : "en-US",

  "fallbackLng"     : "en",

  "useLocalStorage" : false,

  "sendMissing"     : false,
  "sendMissingTo"   : "current"
}

},{}],114:[function(require,module,exports){
module.exports={
  "signin": true,
  "oauth": [
    "linkedin",
    "myusa"
  ],
  "config": {
    "linkedin": {
      "name": "LinkedIn",
      "image": "/images/login/linkedin.png",
      "endpoint": "/api/auth/oauth/linkedin",
      "params": {"scope": ["r_basicprofile", "r_fullprofile", "r_emailaddress", "r_network"]}
    },
    "myusa": {
      "name": "MyUSA",
      "image": "/images/login/myusa.png",
      "endpoint": "/api/auth/oauth/myusa",
      "params": { "scope": ["profile.email", "profile.first_name", "profile.last_name"] }
    }
  },
  "local": {
    "enabled": true,
    "expand": true,
    "logout": true
  },
  "terms": {
    "enabled": false,
    "name": "Terms and Conditions",
    "link": "https://18f.gsa.gov/"
  },
  "profile": {
    "edit": true,
    "editUrl": null
  }
}

},{}],115:[function(require,module,exports){
/**
 * This is a configuration file that defines the standard
 * tags for this installation.  The tags will be displayed
 * in the order of the array.
 */
module.exports = {
  // This defines all of the tag elements for use in the app
  tags: {
    'skill': {
      'icon': 'icon-atom',
      'class': 'skill',
      'id': 'skill',
      'type': 'skill',
      'name': 'Skill',
      'plural': 'Skills'
    },

    'topic': {
      'icon': 'fa fa-briefcase',
      'class': 'topic',
      'id': 'topic',
      'type': 'topic',
      'name': 'Topic',
      'plural': 'Topics'
    },

    'agency': {
      'icon': 'icon-library',
      'class': 'agency',
      'id': 'agency',
      'type': 'agency',
      'name': 'Agency',
      'plural': 'Agencies'
    },

    'location': {
      'icon': 'fa fa-map-marker',
      'class': 'location',
      'id': 'location',
      'type': 'location',
      'name': 'Work Location',
      'plural': 'Work Locations'
    },

    // ---
    // Task-specific tags
    // ---
    'task-skills-required': {
      'icon': 'fa fa-map-marker',
      'class': 'task-skills-required',
      'id': 'task-skills-required',
      'type': 'task-skills-required',
      'name': 'Skill Required',
      'plural': 'Skills Required'
    },

    'task-time-required': {
      'icon': 'fa fa-calendar-o',
      'class': 'task-time-required',
      'id': 'task-time-required',
      'type': 'task-time-required',
      'name': 'Time Commitment',
      'plural': 'Time Commitment'
    },

    'task-people': {
      'icon': 'fa fa-group',
      'class': 'task-people',
      'id': 'task-people',
      'type': 'task-people',
      'name': 'Personnel Needed',
      'plural': 'Personnel Needed'
    },

    'task-length': {
      'icon': 'fa fa-bullseye',
      'class': 'task-length',
      'id': 'task-length',
      'type': 'task-length',
      'name': 'Deadline',
      'plural': 'Deadline'
    },

    'task-time-estimate': {
      'icon': 'fa fa-cogs',
      'class': 'task-time-estimate',
      'id': 'task-time-estimate',
      'type': 'task-time-estimate',
      'name': 'Estimated Time Required',
      'plural': 'Estimated Time Required'
    }

  },

  // This defines the part of the app and which tags apply
  // plural names are for searching the collection
  // singular names are for the individual show views.
  project   : ['skill', 'topic', 'agency', 'location'],
  projects  : ['skill', 'topic', 'agency', 'location'],

  profile   : ['skill', 'topic'],
  profiles  : ['skill', 'topic', 'agency', 'location'],

  task      : ['skill', 'topic', 'location', 'task-people', 'task-time-estimate', 'task-time-required', 'task-length'],
  tasks     : ['skill', 'topic', 'agency', 'location', 'task-skills-required', 'task-time-required', 'task-people', 'task-length', 'task-time-estimate']
};

},{}],116:[function(require,module,exports){
module.exports={
  "project": {
    "show": true
  },
  "supervisorEmail": {
	  "useSupervisorEmail": false
  },
  "home": {
    "logged_in_path": "/projects"
  },
  "faq" : {
    "show" : false,
    "url"  : "/faq"
  },
  "systemEmail" : "test@midas.com",
  "browse": {
    "pageSize" : 27,
    "useInfiniteScroll" : false
  },
  "states" : [{"value": "draft","label":"Draft"},{"value": "open","label":"Open"},{"value":"assigned","label":"Assigned"},{"value": "completed","label":"Completed"},{"value":"archived","label":"Archived"}]
}

},{}],117:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var CommentModel = require('./comment_model');
var CommentListController = require('../../apps/comments/list/controllers/comment_list_controller');

'use strict';

var CommentCollection = Backbone.Collection.extend({

  urlRoot: '/api/comment',

  model: CommentModel,

  initialize: function () {
    var self = this;

    this.listenTo(this, "comment:save", function (data, currentTarget) {
      self.addAndSave(data, currentTarget);
    });

  },

  addAndSave: function (data, currentTarget) {
    var self = this, comment;

    comment = new CommentModel({
      parentId  : data['parentId'],
      value     : data['comment'],
      taskId    : data['taskId'],
      projectId : data['projectId'],
      topic     : data['topic']
    })

    self.add(comment);

    self.models.forEach(function (model) {
      if (model.attributes.value === data['comment']) {
        model.save(null, {
          success: function (modelInstance, response) {
            self.trigger("comment:save:success", modelInstance, response, currentTarget);
          }
        });
      }
    });

  }
});

module.exports = CommentCollection;

},{"../../apps/comments/list/controllers/comment_list_controller":33,"./comment_model":118,"backbone":133,"underscore":159}],118:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');


var CommentModel = Backbone.Model.extend({

  urlRoot: '/api/comment',

  initialize: function () {
    this.saveComment();
  },

  saveComment: function () {
    var self = this;

    this.listenTo(this, 'comment:save', function (parentId, comment, projectId) {
      self.save({
        parentId  : parentId,
        value     : comment,
        projectId : projectId
      }, {
        success: function (data) {
          self.trigger("comment:save:success");
        }
      })
    })
  }

});

module.exports = CommentModel;

},{"backbone":133,"underscore":159}],119:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');


var EventModel = Backbone.Model.extend({

  urlRoot: '/api/event'

});

module.exports = EventModel;

},{"backbone":133,"underscore":159}],120:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var EventModel = require('./event_model');


var EventCollection = Backbone.Collection.extend({
  
  model: EventModel,
  
  parse: function (response) {
    if (response) {
      return response.events;
    }
  },

  url: '/api/event',

  initialize: function () {
    this.addAndSave();
  },

  addAndSave: function () {
    var self = this;

    this.listenTo(this, "event:save", function (data) {

      self.ev = new EventModel({
        title       : data['title'], 
        description : data['description'], 
        start       : data['start'],
        end         : data['end'],
        location    : data['location'],
        projectId   : data['projectId'] 
      });

      self.add(self.event);

      self.ev.save({}, {
        success: function (modelInstance, response) {
          self.trigger("event:save:success", modelInstance, response);
        }
      });
    });
  }

});

module.exports = EventCollection;

},{"./event_model":119,"backbone":133,"underscore":159}],121:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');


	var ProfileModel = Backbone.Model.extend({

		urlRoot: '/api/user',

		initialize: function () {
			this.initializeProfileSave();
			this.initializeProfileGet();
		},

		parse: function(res, options) {
			// Remove falsy values (db returns null instead of undefined)
			_(res).each(function(v, k, o) { if (!v) delete o[k]; });
			return res;
		},

		initializeProfileGet: function () {
			var self = this;

			this.listenTo(this, "profile:fetch", function (id) {
				self.remoteGet(id);
			});
		},

  remoteGet: function (id) {
    var self = this;
    if (id) {
	      this.set({ id: id });
    }
    this.fetch({
      success: function (model, response, options) {
        self.trigger("profile:fetch:success", model);
      },
      error: function (model, response, options) {
        self.trigger("profile:fetch:error", model, response);
      }
    });
  },

		initializeProfileSave: function () {
			var _this = this;

			this.listenTo(this, "profile:updateWithPhotoId", function(file) {
				var _self = this;
				_this.save({
					photoId: file['id']
				}, {
				success: function (data) {
					_this.trigger("profile:updatedPhoto", data);
				},
				error: function (data) {
					// an error occurred
				}
				});
			});

			this.listenTo(this, "profile:save", function (form) {
				_this.save({
					name: form['name'],
					username: form['username'],
					title: form['title'],
					bio: form['bio']
				}, {
				success: function (data) {
					_this.trigger("profile:save:success", data);
				},
				error: function (data) {
					_this.trigger("profile:save:fail", data);
				}
				});
			});

			this.listenTo(this, "profile:removeAuth", function(id) {
				var auths = this.get("auths");
				auths.splice(auths.indexOf(id), 1);
				_this.save({
					auths: auths
				}, {
				success: function (data) {
					_this.trigger("profile:removeAuth:success", data, id);
				},
				error: function (data) {
					_this.trigger("profile:removeAuth:fail", data, id);
				}
				});
			});

		}

	});

	module.exports = ProfileModel;


},{"backbone":133,"underscore":159}],122:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');


var ProjectModel = Backbone.Model.extend({

  defaults: {
    title       : null,
    description : null,
    archived    : false
  },

  // Initialize contains only event bindings and if/then response
  // functions (class methods).
  initialize: function () {
    var self = this;

    this.listenTo(this, "project:model:fetch", function (id) {
      self.remoteGet(id);
    });

    this.listenTo(this, "project:model:update", function (data) {
      self.update(data);
    });

    this.listenTo(this, "project:update:photoId", function (file) {
      self.updatePhoto(file);
    });

    this.listenTo(this, "project:update:state", function (state) {
      self.updateState(state);
    });

    this.listenTo(this, "projectowner:show:changed", function (data) {
      self.updateOwners(data);
    });

    this.listenTo(this, "project:update:tasks:orphan", function (data) {
      self.orphan(data);
    });

  },

  urlRoot: '/api/project',

  remoteGet: function (id) {
    var self = this;
    this.set({ id: id });
    this.fetch({
      success: function (data) {
        self.trigger("project:model:fetch:success", data);
      }
    });
  },

  update: function (data) {
    var self = this;

    this.save({
      title: data['title'],
      description: data['description']
    }, { success: function (data) {
        self.trigger("project:save:success", data);
      }
    });
  },

  // TODO: Update this method and move it into the global update method.
  updatePhoto: function (file) {
    var self = this;

    this.save({
      coverId: file['id']
    }, {
      success: function (data) {
        self.trigger("project:updated:photo:success", data);
      }
    });
  },

  updateState: function (state) {
    var self = this;

    this.save({
      state: state
    }, {
      success: function(data) {
        self.trigger("project:update:state:success", data);
      }
    });
  },

  updateOwners: function (data) {
    var self = this;
    // console.log(data);
    this.save({
      owners: data
    }, {
      success: function(data) {
        self.trigger("project:update:owners:success", data);
      }
    });
  },

  hasOpenTasks: function(tasks){
    //takes a task collection object
    var hasOpenTasks = false;
    var self = this;
    var count = 0;

    _.each(tasks.models,function(task){
      if ( _.indexOf(['open','assigned'],task.attributes.state) != -1 ){
        hasOpenTasks = true;
        count++;
      }
    });

    return {hasOpenTasks:hasOpenTasks,count:count};
  },

  orphan: function(tasks) {
    //orphans associated tasks for a state change
    tasks.each(function(model){
      model.trigger("task:update:orphan",{});
    });
  }

});

module.exports = ProjectModel;

},{"backbone":133,"underscore":159}],123:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var ProjectModel = require('./project_model');


var ProjectsCollection = Backbone.Collection.extend({

  model: ProjectModel,

  url: '/api/project/findAll',

  parse: function (response) {
    return response.projects;
  },

  initialize: function () {
    var self = this;

    this.listenTo(this, "project:save", function (data) {
      self.addAndSave(data);
    });
  },

  addAndSave: function (data) {
    var project, self = this;

    project = new ProjectModel({
      title: data['title'],
      description: data['description']
    });

    project.save({}, {
      success: function (data) {
        self.add(project);
        self.trigger("project:save:success", data);
      }
    });
  }

});

module.exports = ProjectsCollection;

},{"./project_model":122,"backbone":133,"underscore":159}],124:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');

'use strict';

var TaskModel = Backbone.Model.extend({

  defaults: {
    name        : null,
    description : null
  },

  urlRoot: '/api/task',

  initialize: function () {
    this.listenTo(this, "task:save", function (data) {
      this.save(data);
    });

    this.listenTo(this, "task:model:fetch", function (data) {
      this.remoteGet(data);
    });

    this.listenTo(this, "task:update", function (data) {
      this.update(data);
    });

    this.listenTo(this, "task:update:state", function (state) {
      this.updateState(state);
    });

    this.listenTo(this, "task:update:orphan", function (data) {
      this.orphan(data);
    });
  },

  update: function (data) {
    var self = this;

    this.save(data, {
      success: function (data) {
        self.trigger("task:update:success", data);
      }
    });
  },

  updateState: function (state) {
    var self = this;

    this.save({
      state: state
    }, {
      success: function(data) {
        self.trigger("task:update:state:success", data);
      }
    });
  },

  orphan: function(data) {
    var self = this;

    this.save({
      projectId: null
    }, {
      success: function(data) {
        self.trigger("task:update:orphan:success", data);
      }
    });

  },

  remoteGet: function (id) {
    var self = this;
    this.set({ id: id });
    this.fetch({
      success: function (data) {
        self.trigger("task:model:fetch:success", data);
      }
    });
  },

});

  module.exports = TaskModel;


},{"backbone":133,"underscore":159}],125:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var TaskModel = require('./task_model');

'use strict';

var TasksCollection = Backbone.Collection.extend({

  model: TaskModel,

  parse: function (response) {
    if (response) {
      if (response.tasks) {
        return response.tasks;
      }
      return response;
    }
    return [];
  },

  url: '/api/task',

  initialize: function () {
    var self = this;

    this.listenTo(this, "task:save", function (data) {
      self.addAndSave(data);
    })
  },

  addAndSave: function (data) {
    var self = this;

    self.task = new TaskModel(data);

    self.task.save(null,{
      success: function (model) {
        self.trigger("task:save:success", self.task.id);
      }
    });
  }

});

module.exports = TasksCollection;


},{"./task_model":124,"backbone":133,"underscore":159}],126:[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');
var BaseComponent = require('../base/base_component');
var Bootstrap = require('bootstrap');
var utils = require('./utilities');
var PopoverProfile = require('./templates/popover_profile.html');


Popovers = BaseComponent.extend({

  popoverPeopleInit: function (target) {
    $(target).popover(
      {
        placement: 'auto top',
        trigger: 'manual',
        html: 'true',
        title: 'load',
        container: 'body',
        content: '<div class="popover-spinner"><div class="loading">Fetching Information</div><i class="fa fa-spinner fa-spin"></i></div>',
        template: '<div class="popover"><div class="arrow"></div><h3 class="popover-title" style="display:none; visibility:hidden"></h3><div class="popover-content"></div></div>'
      }).on("mouseleave", function () {
        var _this = this;
        var timeoutFn = function () {
          if (!$(".popover:hover").length) {
            $(_this).popover("hide");
          } else {
            setTimeout(timeoutFn, 100);
          }
        };
        setTimeout(timeoutFn, 100);
      });
  },

  popoverPeopleOn: function (e) {
    if (e.preventDefault) e.preventDefault();
    var target = $(e.currentTarget);
    var popover = target.data('bs.popover');
    // if the data element isn't set or popovers not init'd, abort
    if ((_.isUndefined(target.data('userid'))) || (_.isUndefined(popover))) {
      return;
    }
    target.popover('show');
    // Only load data if the popover hasn't previously been loaded
    if (popover.options.title == 'load') {
      $.ajax({ url: '/api/user/info/' + target.data('userid') }).done(function(data) {
        var template = _.template(PopoverProfile)({data: data});
        popover.options.title = 'done';
        popover.options.content = template;
        popover.setContent();
        popover.$tip.addClass(popover.options.placement);
        // handle links in the popovers
        $(".popover").on('click', ".link-backbone", function (e) {
          target.popover('hide');
          linkBackbone(e);
        });
      });
    }
  },

  popoverClick: function (e) {
    if (e.preventDefault) e.preventDefault();
    var id = $(e.currentTarget).data('userid');
    $(e.currentTarget).popover('hide');
    Backbone.history.navigate('profile/' + id, { trigger: true });
  }
});

module.exports = Popovers;

},{"../base/base_component":100,"./templates/popover_profile.html":127,"./utilities":128,"backbone":133,"bootstrap":138,"underscore":159}],127:[function(require,module,exports){
module.exports = "<div class=\"popover-table\">\n  <div class=\"popover-row\">\n    <div class=\"popover-cell-left\">\n      <img align=\"left\" src=\"/api/user/photo/<%- data.id %>\" class=\"popover-image\"/>\n    </div>\n    <div class=\"popover-cell-right popover-person\">\n      <div class=\"title\"><a class=\"link-backbone\" href=\"/profile/<%- data.id %>\"><%- data.name %></a></div>\n      <% if (data.title) { %><div class=\"text-line\"><i class=\"fa fa-briefcase\"></i> <%- data.title %></div><% } %>\n      <% if (data.agency) { %><div class=\"text-line\"><i class=\"fa fa-library\"></i> <%- data.agency.tag.name %></div><% } %>\n      <% if (data.location) { %><div class=\"text-line\"><span class=\"fa fa-map-marker\"></span> <%- data.location.tag.name %></div><% } %>\n    </div>\n  </div>\n</div>";

},{}],128:[function(require,module,exports){
(function (global){
// Input:
// @collection [ARRAY] Backbone collection.
// @modelId [INTEGER] Backbone Model.cid

// Return: [OBJECT] Model instance looked up from modelId within collection.
global.getCurrentModelFromId = function (collection, modelId) {
	var i = 0;
			id = parseInt(modelId)
			models = collection.models;

	for ( ; i < models.length; i += 1) {
		if (models[i].id === id) {
			return models[i];
		} else {
			continue;
		}
	}
}

// Input:
// @collection [ARRAY] Backbone collection.
// @attr [STRING] Value, to be found.

// Return: [OBJECT] Model instance that is corollary to the found @attr value.
global.getCurrentModelFromFormAttributes = function (collection, attr) {
	var	j,
			i = 0,
			attr = $.trim(attr),
			models = collection.models;

	// Loop through all the models
	for ( ; i < models.length; i += 1) {

		// Loop through all the attributes within the model
		for (j in models[i].attributes) {

			// If we find the model.attr[value] on the current models
			// attribute that we are looping over, then stop and return that
			// model back out to the front-end.
			if (models[i].attributes[j] === attr) {
				return models[i]
			} else {
				// Otherwise continue on.
				continue;
			}
		}
	}
}

/**
 * Completely remove a backbone view and all of its
 * references.  This is needed to destroy the view
 * and all of its listeners, in order to start
 * fresh again and render a new view with a new
 * model.
 *
 * Input:
 * @view the view to be removed, typically called with removeView(this);
 *
 * Return:
 * nothing
 */
global.removeView = function (view) {
  view.undelegateEvents();
  view.$el.html("");
}

/**
 * Clear out any el.
 * @params {[The non-jquery mapped el for the view instance]}
 * Return: Nothing.
 */
global.clearEl = function (el) {
  $(el).children().remove();
}

/**
 * Clear out our global container for full page transitions.
 * @params None
 * @return Nothing
 */
global.clearContainer = function () {
  $("#container").children().remove();
}

/**
 * This helps alleviate a common bug with ajax based
 * page transitions. That is sometimes when the page pushes itself off the screen
 * and allows a browser default background to show, after which scrolling
 * up is required.  It is a somewhat rare bug, but useful to have this function
 * if you need it.
 *
 * Return:
 * nothing
 */
global.scrollTop = function () {
  $(window).scrollTop($(window).scrollTop());
}

/**
 * Organize the tags output into an associative array key'd by their type.
 * If the tag has more than one value for said key, make it an array otherwise
 * keep it as a top level object.
 * @param  {[array]} tags           [array of tags]
 * @return {[object]}               [bindingObject returned out]
 */
global.organizeTags = function (tags) {
  var outTags = {};
  for (t in tags) {
    if (!(_.has(outTags, tags[t].tag.type))) {
      outTags[tags[t].tag.type] = [];
    }
    outTags[tags[t].tag.type].push(tags[t].tag);
  }
  return outTags;
}

/**
 * Validate an input field.  Assumes that there is a data
 * variable in the HTML tag called `data-validate` with the
 * validation options that you want to enforce.
 *
 * email is only meant to allow the value is generally email shaped
 *    it is not bullet proof
 *
 * emaildomain requires a data-emaildomain variable in the HTML tag
 *    it will validate against the value there
 *
 * The input should be in a `form-group` component,
 * and the component should have a .help-text element
 * with a class `.error-[code]` where [code] is the
 * validation rule (eg, `empty`);
 *
 * Expects an object with currentTarget, eg { currentTarget: '#foo' }
 */
global.validate = function (e) {
  var opts = String($(e.currentTarget).data('validate')).split(',');
  var val = $(e.currentTarget).val();
  var parent = $(e.currentTarget).parents('.form-group, .checkbox')[0];
  var result = false;
  _.each(opts, function (o) {
    if (o == 'empty') {
      if (!val) {
        $(parent).find('.error-empty').show();
        result = true;
      } else {
        $(parent).find('.error-empty').hide();
      }
      return;
    }
    if (o == 'checked') {
      if ($(e.currentTarget).prop('checked') !== true) {
        $(parent).find('.error-checked').show();
        result = true;
      } else {
        $(parent).find('.error-checked').hide();
      }
      return;
    }
    if (o.substring(0,5) == 'count') {
      var len = parseInt(o.substring(5));
      if (val.length > len) {
        $(parent).find('.error-' + o).show();
        result = true;
      } else {
        $(parent).find('.error-' + o).hide();
      }
      return;
    }
    if (o == 'confirm') {
      var id = $(e.currentTarget).attr('id');
      var newVal = $('#' + id + '-confirm').val();
      if (val != newVal) {
        $(parent).find('.error-' + o).show();
        result = true;
      } else {
        $(parent).find('.error-' + o).hide();
      }
      return;
    }
    if (o == 'button') {
      if (!($($(parent).find("#" + $(e.currentTarget).attr('id') + "-button")[0]).hasClass('btn-success'))) {
        $(parent).find('.error-' + o).show();
        result = true;
      } else {
        $(parent).find('.error-' + o).hide();
      }
    }
    if (o == 'email'){
      var correctLength = false;
      if ( val != "" && val.indexOf("@") >= 2 ){
        var bits = val.split("@");
        var addrBits = bits[1].split(".");
        if ( addrBits.length >=2 ) {
          for (i=0; i<addrBits.length; i++ ){
            if ( addrBits[i].length < 2 ){
              correctLength = false;
              break;
            } else {
              correctLength = true;
            }
          }
        }
      }
      if ( !correctLength || bits[0].length < 2 ) {
        $(parent).find('.error-email').show();
        result = true;
      } else {
        $(parent).find('.error-email').hide();
      }
      return;
    }
    if ( o== 'emaildomain'){
      var domain = $(e.currentTarget).data('emaildomain');
      if ( val != "" && val.indexOf("@") >= 2 ){
        var bits = val.split("@");
        if ( bits[1] != domain ){
          $(parent).find('.error-emaildomain').show();
          result = true;
        } else {
          $(parent).find('.error-emaildomain').hide();
        }
      }
      return;
    }
  });
  if (result === true) {
    $(parent).addClass('has-error');
  } else {
    $(parent).removeClass('has-error');
  }
  return result;
};

global.validatePassword = function (username, password) {
  var rules = {
    username: false,
    length: false,
    upper: false,
    lower: false,
    number: false,
    symbol: false
  };
  var _username = username.toLowerCase().trim();
  var _password = password.toLowerCase().trim();
  // check username is not the same as the password, in any case
  if (_username != _password && _username.split('@',1)[0] != _password) {
    rules['username'] = true;
  }
  // length > 8 characters
  if (password && password.length >= 8) {
    rules['length'] = true;
  }
  // Uppercase, Lowercase, and Numbers
  for (var i = 0; i < password.length; i++) {
    var test = password.charAt(i);
    // from http://stackoverflow.com/questions/3816905/checking-if-a-string-starts-with-a-lowercase-letter
    if (test === test.toLowerCase() && test !== test.toUpperCase()) {
      // lowercase found
      rules['lower'] = true;
    }
    else if (test === test.toUpperCase() && test !== test.toLowerCase()) {
      rules['upper'] = true;
    }
    // from http://stackoverflow.com/questions/18082/validate-numbers-in-javascript-isnumeric
    else if (!isNaN(parseFloat(test)) && isFinite(test)) {
      rules['number'] = true;
    }
  }
  // check for symbols
  if (/.*[^\w\s].*/.test(password)) {
    rules['symbol'] = true;
  }
  return rules;
};

/**
 * Helper function to navigate links within backbone
 * instead of reloading the whole page through a hard link.
 * Typically used with the `events: {}` handler of backbone
 * such as 'click .link-backbone' : linkBackbone
 * @param e the event fired by jquery/backbone
 */
global.linkBackbone = function (e) {
  // if meta or control is held, or if the middle mouse button is pressed,
  // let the link process normally.
  // eg: open a new tab or window based on the browser prefs
  if ((e.metaKey === true) || (e.ctrlKey === true) || (e.which == 2)) {
    return;
  }
  // otherwise contain the link within backbone
  if (e.preventDefault) e.preventDefault();
  var href = $(e.currentTarget).attr('href');
  Backbone.history.navigate(href, { trigger: true });
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],129:[function(require,module,exports){
/*!
 * jQuery.selection - jQuery Plugin
 *
 * Copyright (c) 2010-2014 IWASAKI Koji (@madapaja).
 * http://blog.madapaja.net/
 * Under The MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
(function($, win, doc) {
    /**
     * get caret status of the selection of the element
     *
     * @param   {Element}   element         target DOM element
     * @return  {Object}    return
     * @return  {String}    return.text     selected text
     * @return  {Number}    return.start    start position of the selection
     * @return  {Number}    return.end      end position of the selection
     */
    var _getCaretInfo = function(element){
        var res = {
            text: '',
            start: 0,
            end: 0
        };

        if (!element.value) {
            /* no value or empty string */
            return res;
        }

        try {
            if (win.getSelection) {
                /* except IE */
                res.start = element.selectionStart;
                res.end = element.selectionEnd;
                res.text = element.value.slice(res.start, res.end);
            } else if (doc.selection) {
                /* for IE */
                element.focus();

                var range = doc.selection.createRange(),
                    range2 = doc.body.createTextRange(),
                    tmpLength;

                res.text = range.text;

                try {
                    range2.moveToElementText(element);
                    range2.setEndPoint('StartToStart', range);
                } catch (e) {
                    range2 = element.createTextRange();
                    range2.setEndPoint('StartToStart', range);
                }

                res.start = element.value.length - range2.text.length;
                res.end = res.start + range.text.length;
            }
        } catch (e) {
            /* give up */
        }

        return res;
    };

    /**
     * caret operation for the element
     * @type {Object}
     */
    var _CaretOperation = {
        /**
         * get caret position
         *
         * @param   {Element}   element         target element
         * @return  {Object}    return
         * @return  {Number}    return.start    start position for the selection
         * @return  {Number}    return.end      end position for the selection
         */
        getPos: function(element) {
            var tmp = _getCaretInfo(element);
            return {start: tmp.start, end: tmp.end};
        },

        /**
         * set caret position
         *
         * @param   {Element}   element         target element
         * @param   {Object}    toRange         caret position
         * @param   {Number}    toRange.start   start position for the selection
         * @param   {Number}    toRange.end     end position for the selection
         * @param   {String}    caret           caret mode: any of the following: "keep" | "start" | "end"
         */
        setPos: function(element, toRange, caret) {
            caret = this._caretMode(caret);

            if (caret == 'start') {
                toRange.end = toRange.start;
            } else if (caret == 'end') {
                toRange.start = toRange.end;
            }

            element.focus();
            try {
                if (element.createTextRange) {
                    var range = element.createTextRange();

                    if (win.navigator.userAgent.toLowerCase().indexOf("msie") >= 0) {
                        toRange.start = element.value.substr(0, toRange.start).replace(/\r/g, '').length;
                        toRange.end = element.value.substr(0, toRange.end).replace(/\r/g, '').length;
                    }

                    range.collapse(true);
                    range.moveStart('character', toRange.start);
                    range.moveEnd('character', toRange.end - toRange.start);

                    range.select();
                } else if (element.setSelectionRange) {
                    element.setSelectionRange(toRange.start, toRange.end);
                }
            } catch (e) {
                /* give up */
            }
        },

        /**
         * get selected text
         *
         * @param   {Element}   element         target element
         * @return  {String}    return          selected text
         */
        getText: function(element) {
            return _getCaretInfo(element).text;
        },

        /**
         * get caret mode
         *
         * @param   {String}    caret           caret mode
         * @return  {String}    return          any of the following: "keep" | "start" | "end"
         */
        _caretMode: function(caret) {
            caret = caret || "keep";
            if (caret === false) {
                caret = 'end';
            }

            switch (caret) {
                case 'keep':
                case 'start':
                case 'end':
                    break;

                default:
                    caret = 'keep';
            }

            return caret;
        },

        /**
         * replace selected text
         *
         * @param   {Element}   element         target element
         * @param   {String}    text            replacement text
         * @param   {String}    caret           caret mode: any of the following: "keep" | "start" | "end"
         */
        replace: function(element, text, caret) {
            var tmp = _getCaretInfo(element),
                orig = element.value,
                pos = $(element).scrollTop(),
                range = {start: tmp.start, end: tmp.start + text.length};

            element.value = orig.substr(0, tmp.start) + text + orig.substr(tmp.end);

            $(element).scrollTop(pos);
            this.setPos(element, range, caret);
        },

        /**
         * insert before the selected text
         *
         * @param   {Element}   element         target element
         * @param   {String}    text            insertion text
         * @param   {String}    caret           caret mode: any of the following: "keep" | "start" | "end"
         */
        insertBefore: function(element, text, caret) {
            var tmp = _getCaretInfo(element),
                orig = element.value,
                pos = $(element).scrollTop(),
                range = {start: tmp.start + text.length, end: tmp.end + text.length};

            element.value = orig.substr(0, tmp.start) + text + orig.substr(tmp.start);

            $(element).scrollTop(pos);
            this.setPos(element, range, caret);
        },

        /**
         * insert after the selected text
         *
         * @param   {Element}   element         target element
         * @param   {String}    text            insertion text
         * @param   {String}    caret           caret mode: any of the following: "keep" | "start" | "end"
         */
        insertAfter: function(element, text, caret) {
            var tmp = _getCaretInfo(element),
                orig = element.value,
                pos = $(element).scrollTop(),
                range = {start: tmp.start, end: tmp.end};

            element.value = orig.substr(0, tmp.end) + text + orig.substr(tmp.end);

            $(element).scrollTop(pos);
            this.setPos(element, range, caret);
        }
    };

    /* add jQuery.selection */
    $.extend({
        /**
         * get selected text on the window
         *
         * @param   {String}    mode            selection mode: any of the following: "text" | "html"
         * @return  {String}    return
         */
        selection: function(mode) {
            var getText = ((mode || 'text').toLowerCase() == 'text');

            try {
                if (win.getSelection) {
                    if (getText) {
                        // get text
                        return win.getSelection().toString();
                    } else {
                        // get html
                        var sel = win.getSelection(), range;

                        if (sel.getRangeAt) {
                            range = sel.getRangeAt(0);
                        } else {
                            range = doc.createRange();
                            range.setStart(sel.anchorNode, sel.anchorOffset);
                            range.setEnd(sel.focusNode, sel.focusOffset);
                        }

                        return $('<div></div>').append(range.cloneContents()).html();
                    }
                } else if (doc.selection) {
                    if (getText) {
                        // get text
                        return doc.selection.createRange().text;
                    } else {
                        // get html
                        return doc.selection.createRange().htmlText;
                    }
                }
            } catch (e) {
                /* give up */
            }

            return '';
        }
    });

    /* add selection */
    $.fn.extend({
        selection: function(mode, opts) {
            opts = opts || {};

            switch (mode) {
                /**
                 * selection('getPos')
                 * get caret position
                 *
                 * @return  {Object}    return
                 * @return  {Number}    return.start    start position for the selection
                 * @return  {Number}    return.end      end position for the selection
                 */
                case 'getPos':
                    return _CaretOperation.getPos(this[0]);

                /**
                 * selection('setPos', opts)
                 * set caret position
                 *
                 * @param   {Number}    opts.start      start position for the selection
                 * @param   {Number}    opts.end        end position for the selection
                 */
                case 'setPos':
                    return this.each(function() {
                        _CaretOperation.setPos(this, opts);
                    });

                /**
                 * selection('replace', opts)
                 * replace the selected text
                 *
                 * @param   {String}    opts.text            replacement text
                 * @param   {String}    opts.caret           caret mode: any of the following: "keep" | "start" | "end"
                 */
                case 'replace':
                    return this.each(function() {
                        _CaretOperation.replace(this, opts.text, opts.caret);
                    });

                /**
                 * selection('insert', opts)
                 * insert before/after the selected text
                 *
                 * @param   {String}    opts.text            insertion text
                 * @param   {String}    opts.caret           caret mode: any of the following: "keep" | "start" | "end"
                 * @param   {String}    opts.mode            insertion mode: any of the following: "before" | "after"
                 */
                case 'insert':
                    return this.each(function() {
                        if (opts.mode == 'before') {
                            _CaretOperation.insertBefore(this, opts.text, opts.caret);
                        } else {
                            _CaretOperation.insertAfter(this, opts.text, opts.caret);
                        }
                    });

                /**
                 * selection('get')
                 * get selected text
                 *
                 * @return  {String}    return
                 */
                case 'get':
                    /* falls through */
                default:
                    return _CaretOperation.getText(this[0]);
            }

            return this;
        }
    });
})(jQuery, window, window.document);

},{}],130:[function(require,module,exports){
/**
 * Timeago is a jQuery plugin that makes it easy to support automatically
 * updating fuzzy timestamps (e.g. "4 minutes ago" or "about 1 day ago").
 *
 * @name timeago
 * @version 1.3.0
 * @requires jQuery v1.2.3+
 * @author Ryan McGeary
 * @license MIT License - http://www.opensource.org/licenses/mit-license.php
 *
 * For usage and examples, visit:
 * http://timeago.yarp.com/
 *
 * Copyright (c) 2008-2013, Ryan McGeary (ryan -[at]- mcgeary [*dot*] org)
 */

(function (factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(['jquery'], factory);
  } else {
    // Browser globals
    factory(jQuery);
  }
}(function ($) {
  $.timeago = function(timestamp) {
    if (timestamp instanceof Date) {
      return inWords(timestamp);
    } else if (typeof timestamp === "string") {
      return inWords($.timeago.parse(timestamp));
    } else if (typeof timestamp === "number") {
      return inWords(new Date(timestamp));
    } else {
      return inWords($.timeago.datetime(timestamp));
    }
  };
  var $t = $.timeago;

  $.extend($.timeago, {
    settings: {
      refreshMillis: 60000,
      allowFuture: false,
      localeTitle: false,
      cutoff: 0,
      strings: {
        prefixAgo: null,
        prefixFromNow: null,
        suffixAgo: "ago",
        suffixFromNow: "from now",
        seconds: "less than a minute",
        minute: "about a minute",
        minutes: "%d minutes",
        hour: "about an hour",
        hours: "about %d hours",
        day: "a day",
        days: "%d days",
        month: "about a month",
        months: "%d months",
        year: "about a year",
        years: "%d years",
        wordSeparator: " ",
        numbers: []
      }
    },
    inWords: function(distanceMillis) {
      var $l = this.settings.strings;
      var prefix = $l.prefixAgo;
      var suffix = $l.suffixAgo;
      if (this.settings.allowFuture) {
        if (distanceMillis < 0) {
          prefix = $l.prefixFromNow;
          suffix = $l.suffixFromNow;
        }
      }

      var seconds = Math.abs(distanceMillis) / 1000;
      var minutes = seconds / 60;
      var hours = minutes / 60;
      var days = hours / 24;
      var years = days / 365;

      function substitute(stringOrFunction, number) {
        var string = $.isFunction(stringOrFunction) ? stringOrFunction(number, distanceMillis) : stringOrFunction;
        var value = ($l.numbers && $l.numbers[number]) || number;
        return string.replace(/%d/i, value);
      }

      var words = seconds < 45 && substitute($l.seconds, Math.round(seconds)) ||
        seconds < 90 && substitute($l.minute, 1) ||
        minutes < 45 && substitute($l.minutes, Math.round(minutes)) ||
        minutes < 90 && substitute($l.hour, 1) ||
        hours < 24 && substitute($l.hours, Math.round(hours)) ||
        hours < 42 && substitute($l.day, 1) ||
        days < 30 && substitute($l.days, Math.round(days)) ||
        days < 45 && substitute($l.month, 1) ||
        days < 365 && substitute($l.months, Math.round(days / 30)) ||
        years < 1.5 && substitute($l.year, 1) ||
        substitute($l.years, Math.round(years));

      var separator = $l.wordSeparator || "";
      if ($l.wordSeparator === undefined) { separator = " "; }
      return $.trim([prefix, words, suffix].join(separator));
    },
    parse: function(iso8601) {
      var s = $.trim(iso8601);
      s = s.replace(/\.\d+/,""); // remove milliseconds
      s = s.replace(/-/,"/").replace(/-/,"/");
      s = s.replace(/T/," ").replace(/Z/," UTC");
      s = s.replace(/([\+\-]\d\d)\:?(\d\d)/," $1$2"); // -04:00 -> -0400
      return new Date(s);
    },
    datetime: function(elem) {
      var iso8601 = $t.isTime(elem) ? $(elem).attr("datetime") : $(elem).attr("title");
      return $t.parse(iso8601);
    },
    isTime: function(elem) {
      // jQuery's `is()` doesn't play well with HTML5 in IE
      return $(elem).get(0).tagName.toLowerCase() === "time"; // $(elem).is("time");
    }
  });

  // functions that can be called via $(el).timeago('action')
  // init is default when no action is given
  // functions are called with context of a single element
  var functions = {
    init: function(){
      var refresh_el = $.proxy(refresh, this);
      refresh_el();
      var $s = $t.settings;
      if ($s.refreshMillis > 0) {
        setInterval(refresh_el, $s.refreshMillis);
      }
    },
    update: function(time){
      $(this).data('timeago', { datetime: $t.parse(time) });
      refresh.apply(this);
    },
    updateFromDOM: function(){
      $(this).data('timeago', { datetime: $t.parse( $t.isTime(this) ? $(this).attr("datetime") : $(this).attr("title") ) });
      refresh.apply(this);
    }
  };

  $.fn.timeago = function(action, options) {
    var fn = action ? functions[action] : functions.init;
    if(!fn){
      throw new Error("Unknown function name '"+ action +"' for timeago");
    }
    // each over objects here and call the requested function
    this.each(function(){
      fn.call(this, options);
    });
    return this;
  };

  function refresh() {
    var data = prepareData(this);
    var $s = $t.settings;

    if (!isNaN(data.datetime)) {
      if ( $s.cutoff == 0 || distance(data.datetime) < $s.cutoff) {
        $(this).text(inWords(data.datetime));
      }
    }
    return this;
  }

  function prepareData(element) {
    element = $(element);
    if (!element.data("timeago")) {
      element.data("timeago", { datetime: $t.datetime(element) });
      var text = $.trim(element.text());
      if ($t.settings.localeTitle) {
        element.attr("title", element.data('timeago').datetime.toLocaleString());
      } else if (text.length > 0 && !($t.isTime(element) && element.attr("title"))) {
        element.attr("title", text);
      }
    }
    return element.data("timeago");
  }

  function inWords(date) {
    return $t.inWords(distance(date));
  }

  function distance(date) {
    return (new Date().getTime() - date.getTime());
  }

  // fix for IE6 suckage
  document.createElement("abbr");
  document.createElement("time");
}));

},{}],131:[function(require,module,exports){
(function (process){
/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _each = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = function (fn) {
              // not a direct alias for IE10 compatibility
              setImmediate(fn);
            };
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                }
            }));
        });
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (err, v) {
                results[x.index] = v;
                callback(err);
            });
        }, function (err) {
            callback(err, results);
        });
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        if (!keys.length) {
            return callback(null);
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (_keys(results).length === keys.length) {
                callback(null, results);
                callback = function () {};
            }
        });

        _each(keys, function (k) {
            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor !== Array) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (test()) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (!test()) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if(data.constructor !== Array) {
              data = [data];
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            }
        };
        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
                if(data.constructor !== Array) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain) cargo.drain();
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                callback.apply(null, memo[key]);
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.compose = function (/* functions... */) {
        var fns = Array.prototype.reverse.call(arguments);
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // AMD / RequireJS
    if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // Node.js
    else if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

}).call(this,require('_process'))

},{"_process":151}],132:[function(require,module,exports){
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define([], function () {
      return (root.returnExportsGlobal = factory());
    });
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like enviroments that support module.exports,
    // like Node.
    module.exports = factory();
  } else {
    root['Autolinker'] = factory();
  }
}(this, function () {

	/*!
	 * Autolinker.js
	 * 0.15.2
	 *
	 * Copyright(c) 2015 Gregory Jacobs <greg@greg-jacobs.com>
	 * MIT Licensed. http://www.opensource.org/licenses/mit-license.php
	 *
	 * https://github.com/gregjacobs/Autolinker.js
	 */
	/**
	 * @class Autolinker
	 * @extends Object
	 * 
	 * Utility class used to process a given string of text, and wrap the URLs, email addresses, and Twitter handles in 
	 * the appropriate anchor (&lt;a&gt;) tags to turn them into links.
	 * 
	 * Any of the configuration options may be provided in an Object (map) provided to the Autolinker constructor, which
	 * will configure how the {@link #link link()} method will process the links.
	 * 
	 * For example:
	 * 
	 *     var autolinker = new Autolinker( {
	 *         newWindow : false,
	 *         truncate  : 30
	 *     } );
	 *     
	 *     var html = autolinker.link( "Joe went to www.yahoo.com" );
	 *     // produces: 'Joe went to <a href="http://www.yahoo.com">yahoo.com</a>'
	 * 
	 * 
	 * The {@link #static-link static link()} method may also be used to inline options into a single call, which may
	 * be more convenient for one-off uses. For example:
	 * 
	 *     var html = Autolinker.link( "Joe went to www.yahoo.com", {
	 *         newWindow : false,
	 *         truncate  : 30
	 *     } );
	 *     // produces: 'Joe went to <a href="http://www.yahoo.com">yahoo.com</a>'
	 * 
	 * 
	 * ## Custom Replacements of Links
	 * 
	 * If the configuration options do not provide enough flexibility, a {@link #replaceFn} may be provided to fully customize
	 * the output of Autolinker. This function is called once for each URL/Email/Twitter handle match that is encountered.
	 * 
	 * For example:
	 * 
	 *     var input = "...";  // string with URLs, Email Addresses, and Twitter Handles
	 *     
	 *     var linkedText = Autolinker.link( input, {
	 *         replaceFn : function( autolinker, match ) {
	 *             console.log( "href = ", match.getAnchorHref() );
	 *             console.log( "text = ", match.getAnchorText() );
	 *         
	 *             switch( match.getType() ) {
	 *                 case 'url' : 
	 *                     console.log( "url: ", match.getUrl() );
	 *                     
	 *                     if( match.getUrl().indexOf( 'mysite.com' ) === -1 ) {
	 *                         var tag = autolinker.getTagBuilder().build( match );  // returns an `Autolinker.HtmlTag` instance, which provides mutator methods for easy changes
	 *                         tag.setAttr( 'rel', 'nofollow' );
	 *                         tag.addClass( 'external-link' );
	 *                         
	 *                         return tag;
	 *                         
	 *                     } else {
	 *                         return true;  // let Autolinker perform its normal anchor tag replacement
	 *                     }
	 *                     
	 *                 case 'email' :
	 *                     var email = match.getEmail();
	 *                     console.log( "email: ", email );
	 *                     
	 *                     if( email === "my@own.address" ) {
	 *                         return false;  // don't auto-link this particular email address; leave as-is
	 *                     } else {
	 *                         return;  // no return value will have Autolinker perform its normal anchor tag replacement (same as returning `true`)
	 *                     }
	 *                 
	 *                 case 'twitter' :
	 *                     var twitterHandle = match.getTwitterHandle();
	 *                     console.log( twitterHandle );
	 *                     
	 *                     return '<a href="http://newplace.to.link.twitter.handles.to/">' + twitterHandle + '</a>';
	 *             }
	 *         }
	 *     } );
	 * 
	 * 
	 * The function may return the following values:
	 * 
	 * - `true` (Boolean): Allow Autolinker to replace the match as it normally would.
	 * - `false` (Boolean): Do not replace the current match at all - leave as-is.
	 * - Any String: If a string is returned from the function, the string will be used directly as the replacement HTML for
	 *   the match.
	 * - An {@link Autolinker.HtmlTag} instance, which can be used to build/modify an HTML tag before writing out its HTML text.
	 * 
	 * @constructor
	 * @param {Object} [config] The configuration options for the Autolinker instance, specified in an Object (map).
	 */
	var Autolinker = function( cfg ) {
		Autolinker.Util.assign( this, cfg );  // assign the properties of `cfg` onto the Autolinker instance. Prototype properties will be used for missing configs.

		this.matchValidator = new Autolinker.MatchValidator();
	};


	Autolinker.prototype = {
		constructor : Autolinker,  // fix constructor property

		/**
		 * @cfg {Boolean} urls
		 * 
		 * `true` if miscellaneous URLs should be automatically linked, `false` if they should not be.
		 */
		urls : true,

		/**
		 * @cfg {Boolean} email
		 * 
		 * `true` if email addresses should be automatically linked, `false` if they should not be.
		 */
		email : true,

		/**
		 * @cfg {Boolean} twitter
		 * 
		 * `true` if Twitter handles ("@example") should be automatically linked, `false` if they should not be.
		 */
		twitter : true,

		/**
		 * @cfg {Boolean} newWindow
		 * 
		 * `true` if the links should open in a new window, `false` otherwise.
		 */
		newWindow : true,

		/**
		 * @cfg {Boolean} stripPrefix
		 * 
		 * `true` if 'http://' or 'https://' and/or the 'www.' should be stripped from the beginning of URL links' text, 
		 * `false` otherwise.
		 */
		stripPrefix : true,

		/**
		 * @cfg {Number} truncate
		 * 
		 * A number for how many characters long URLs/emails/twitter handles should be truncated to inside the text of 
		 * a link. If the URL/email/twitter is over this number of characters, it will be truncated to this length by 
		 * adding a two period ellipsis ('..') to the end of the string.
		 * 
		 * For example: A url like 'http://www.yahoo.com/some/long/path/to/a/file' truncated to 25 characters might look
		 * something like this: 'yahoo.com/some/long/pat..'
		 */

		/**
		 * @cfg {String} className
		 * 
		 * A CSS class name to add to the generated links. This class will be added to all links, as well as this class
		 * plus url/email/twitter suffixes for styling url/email/twitter links differently.
		 * 
		 * For example, if this config is provided as "myLink", then:
		 * 
		 * - URL links will have the CSS classes: "myLink myLink-url"
		 * - Email links will have the CSS classes: "myLink myLink-email", and
		 * - Twitter links will have the CSS classes: "myLink myLink-twitter"
		 */
		className : "",

		/**
		 * @cfg {Function} replaceFn
		 * 
		 * A function to individually process each URL/Email/Twitter match found in the input string.
		 * 
		 * See the class's description for usage.
		 * 
		 * This function is called with the following parameters:
		 * 
		 * @cfg {Autolinker} replaceFn.autolinker The Autolinker instance, which may be used to retrieve child objects from (such
		 *   as the instance's {@link #getTagBuilder tag builder}).
		 * @cfg {Autolinker.match.Match} replaceFn.match The Match instance which can be used to retrieve information about the
		 *   {@link Autolinker.match.Url URL}/{@link Autolinker.match.Email email}/{@link Autolinker.match.Twitter Twitter}
		 *   match that the `replaceFn` is currently processing.
		 */


		/**
		 * @private
		 * @property {RegExp} htmlCharacterEntitiesRegex
		 *
		 * The regular expression that matches common HTML character entities.
		 * 
		 * Ignoring &amp; as it could be part of a query string -- handling it separately.
		 */
		htmlCharacterEntitiesRegex: /(&nbsp;|&#160;|&lt;|&#60;|&gt;|&#62;|&quot;|&#34;|&#39;)/gi,

		/**
		 * @private
		 * @property {RegExp} matcherRegex
		 * 
		 * The regular expression that matches URLs, email addresses, and Twitter handles.
		 * 
		 * This regular expression has the following capturing groups:
		 * 
		 * 1. Group that is used to determine if there is a Twitter handle match (i.e. \@someTwitterUser). Simply check for its 
		 *    existence to determine if there is a Twitter handle match. The next couple of capturing groups give information 
		 *    about the Twitter handle match.
		 * 2. The whitespace character before the \@sign in a Twitter handle. This is needed because there are no lookbehinds in
		 *    JS regular expressions, and can be used to reconstruct the original string in a replace().
		 * 3. The Twitter handle itself in a Twitter match. If the match is '@someTwitterUser', the handle is 'someTwitterUser'.
		 * 4. Group that matches an email address. Used to determine if the match is an email address, as well as holding the full 
		 *    address. Ex: 'me@my.com'
		 * 5. Group that matches a URL in the input text. Ex: 'http://google.com', 'www.google.com', or just 'google.com'.
		 *    This also includes a path, url parameters, or hash anchors. Ex: google.com/path/to/file?q1=1&q2=2#myAnchor
		 * 6. Group that matches a protocol URL (i.e. 'http://google.com'). This is used to match protocol URLs with just a single
		 *    word, like 'http://localhost', where we won't double check that the domain name has at least one '.' in it.
		 * 7. A protocol-relative ('//') match for the case of a 'www.' prefixed URL. Will be an empty string if it is not a 
		 *    protocol-relative match. We need to know the character before the '//' in order to determine if it is a valid match
		 *    or the // was in a string we don't want to auto-link.
		 * 8. A protocol-relative ('//') match for the case of a known TLD prefixed URL. Will be an empty string if it is not a 
		 *    protocol-relative match. See #6 for more info. 
		 */
		matcherRegex : (function() {
			var twitterRegex = /(^|[^\w])@(\w{1,15})/,              // For matching a twitter handle. Ex: @gregory_jacobs

			    emailRegex = /(?:[\-;:&=\+\$,\w\.]+@)/,             // something@ for email addresses (a.k.a. local-part)

			    protocolRegex = /(?:[A-Za-z][-.+A-Za-z0-9]+:(?![A-Za-z][-.+A-Za-z0-9]+:\/\/)(?!\d+\/?)(?:\/\/)?)/,  // match protocol, allow in format "http://" or "mailto:". However, do not match the first part of something like 'link:http://www.google.com' (i.e. don't match "link:"). Also, make sure we don't interpret 'google.com:8000' as if 'google.com' was a protocol here (i.e. ignore a trailing port number in this regex)
			    wwwRegex = /(?:www\.)/,                             // starting with 'www.'
			    domainNameRegex = /[A-Za-z0-9\.\-]*[A-Za-z0-9\-]/,  // anything looking at all like a domain, non-unicode domains, not ending in a period
			    tldRegex = /\.(?:international|construction|contractors|enterprises|photography|productions|foundation|immobilien|industries|management|properties|technology|christmas|community|directory|education|equipment|institute|marketing|solutions|vacations|bargains|boutique|builders|catering|cleaning|clothing|computer|democrat|diamonds|graphics|holdings|lighting|partners|plumbing|supplies|training|ventures|academy|careers|company|cruises|domains|exposed|flights|florist|gallery|guitars|holiday|kitchen|neustar|okinawa|recipes|rentals|reviews|shiksha|singles|support|systems|agency|berlin|camera|center|coffee|condos|dating|estate|events|expert|futbol|kaufen|luxury|maison|monash|museum|nagoya|photos|repair|report|social|supply|tattoo|tienda|travel|viajes|villas|vision|voting|voyage|actor|build|cards|cheap|codes|dance|email|glass|house|mango|ninja|parts|photo|shoes|solar|today|tokyo|tools|watch|works|aero|arpa|asia|best|bike|blue|buzz|camp|club|cool|coop|farm|fish|gift|guru|info|jobs|kiwi|kred|land|limo|link|menu|mobi|moda|name|pics|pink|post|qpon|rich|ruhr|sexy|tips|vote|voto|wang|wien|wiki|zone|bar|bid|biz|cab|cat|ceo|com|edu|gov|int|kim|mil|net|onl|org|pro|pub|red|tel|uno|wed|xxx|xyz|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cw|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sx|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|za|zm|zw)\b/,   // match our known top level domains (TLDs)

			    // Allow optional path, query string, and hash anchor, not ending in the following characters: "?!:,.;"
			    // http://blog.codinghorror.com/the-problem-with-urls/
			    urlSuffixRegex = /[\-A-Za-z0-9+&@#\/%=~_()|'$*\[\]?!:,.;]*[\-A-Za-z0-9+&@#\/%=~_()|'$*\[\]]/;

			return new RegExp( [
				'(',  // *** Capturing group $1, which can be used to check for a twitter handle match. Use group $3 for the actual twitter handle though. $2 may be used to reconstruct the original string in a replace() 
					// *** Capturing group $2, which matches the whitespace character before the '@' sign (needed because of no lookbehinds), and 
					// *** Capturing group $3, which matches the actual twitter handle
					twitterRegex.source,
				')',

				'|',

				'(',  // *** Capturing group $4, which is used to determine an email match
					emailRegex.source,
					domainNameRegex.source,
					tldRegex.source,
				')',

				'|',

				'(',  // *** Capturing group $5, which is used to match a URL
					'(?:', // parens to cover match for protocol (optional), and domain
						'(',  // *** Capturing group $6, for a protocol-prefixed url (ex: http://google.com)
							protocolRegex.source,
							domainNameRegex.source,
						')',

						'|',

						'(?:',  // non-capturing paren for a 'www.' prefixed url (ex: www.google.com)
							'(.?//)?',  // *** Capturing group $7 for an optional protocol-relative URL. Must be at the beginning of the string or start with a non-word character
							wwwRegex.source,
							domainNameRegex.source,
						')',

						'|',

						'(?:',  // non-capturing paren for known a TLD url (ex: google.com)
							'(.?//)?',  // *** Capturing group $8 for an optional protocol-relative URL. Must be at the beginning of the string or start with a non-word character
							domainNameRegex.source,
							tldRegex.source,
						')',
					')',

					'(?:' + urlSuffixRegex.source + ')?',  // match for path, query string, and/or hash anchor - optional
				')'
			].join( "" ), 'gi' );
		} )(),

		/**
		 * @private
		 * @property {RegExp} charBeforeProtocolRelMatchRegex
		 * 
		 * The regular expression used to retrieve the character before a protocol-relative URL match.
		 * 
		 * This is used in conjunction with the {@link #matcherRegex}, which needs to grab the character before a protocol-relative
		 * '//' due to the lack of a negative look-behind in JavaScript regular expressions. The character before the match is stripped
		 * from the URL.
		 */
		charBeforeProtocolRelMatchRegex : /^(.)?\/\//,

		/**
		 * @private
		 * @property {Autolinker.MatchValidator} matchValidator
		 * 
		 * The MatchValidator object, used to filter out any false positives from the {@link #matcherRegex}. See
		 * {@link Autolinker.MatchValidator} for details.
		 */

		/**
		 * @private
		 * @property {Autolinker.HtmlParser} htmlParser
		 * 
		 * The HtmlParser instance used to skip over HTML tags, while finding text nodes to process. This is lazily instantiated
		 * in the {@link #getHtmlParser} method.
		 */

		/**
		 * @private
		 * @property {Autolinker.AnchorTagBuilder} tagBuilder
		 * 
		 * The AnchorTagBuilder instance used to build the URL/email/Twitter replacement anchor tags. This is lazily instantiated
		 * in the {@link #getTagBuilder} method.
		 */


		/**
		 * Automatically links URLs, email addresses, and Twitter handles found in the given chunk of HTML. 
		 * Does not link URLs found within HTML tags.
		 * 
		 * For instance, if given the text: `You should go to http://www.yahoo.com`, then the result
		 * will be `You should go to &lt;a href="http://www.yahoo.com"&gt;http://www.yahoo.com&lt;/a&gt;`
		 * 
		 * This method finds the text around any HTML elements in the input `textOrHtml`, which will be the text that is processed.
		 * Any original HTML elements will be left as-is, as well as the text that is already wrapped in anchor (&lt;a&gt;) tags.
		 * 
		 * @param {String} textOrHtml The HTML or text to link URLs, email addresses, and Twitter handles within (depending on if
		 *   the {@link #urls}, {@link #email}, and {@link #twitter} options are enabled).
		 * @return {String} The HTML, with URLs/emails/Twitter handles automatically linked.
		 */
		link : function( textOrHtml ) {
			var me = this,  // for closure
			    htmlParser = this.getHtmlParser(),
			    htmlCharacterEntitiesRegex = this.htmlCharacterEntitiesRegex,
			    anchorTagStackCount = 0,  // used to only process text around anchor tags, and any inner text/html they may have
			    resultHtml = [];

			htmlParser.parse( textOrHtml, {
				// Process HTML nodes in the input `textOrHtml`
				processHtmlNode : function( tagText, tagName, isClosingTag ) {
					if( tagName === 'a' ) {
						if( !isClosingTag ) {  // it's the start <a> tag
							anchorTagStackCount++;
						} else {   // it's the end </a> tag
							anchorTagStackCount = Math.max( anchorTagStackCount - 1, 0 );  // attempt to handle extraneous </a> tags by making sure the stack count never goes below 0
						}
					}
					resultHtml.push( tagText );  // now add the text of the tag itself verbatim
				},

				// Process text nodes in the input `textOrHtml`
				processTextNode : function( text ) {
					if( anchorTagStackCount === 0 ) {
						// If we're not within an <a> tag, process the text node
						var unescapedText = Autolinker.Util.splitAndCapture( text, htmlCharacterEntitiesRegex );  // split at HTML entities, but include the HTML entities in the results array

						for ( var i = 0, len = unescapedText.length; i < len; i++ ) {
							var textToProcess = unescapedText[ i ],
							    processedTextNode = me.processTextNode( textToProcess );

							resultHtml.push( processedTextNode );
						}

					} else {
						// `text` is within an <a> tag, simply append the text - we do not want to autolink anything 
						// already within an <a>...</a> tag
						resultHtml.push( text );
					}
				}
			} );

			return resultHtml.join( "" );
		},


		/**
		 * Lazily instantiates and returns the {@link #htmlParser} instance for this Autolinker instance.
		 * 
		 * @protected
		 * @return {Autolinker.HtmlParser}
		 */
		getHtmlParser : function() {
			var htmlParser = this.htmlParser;

			if( !htmlParser ) {
				htmlParser = this.htmlParser = new Autolinker.HtmlParser();
			}

			return htmlParser;
		},


		/**
		 * Returns the {@link #tagBuilder} instance for this Autolinker instance, lazily instantiating it
		 * if it does not yet exist.
		 * 
		 * This method may be used in a {@link #replaceFn} to generate the {@link Autolinker.HtmlTag HtmlTag} instance that 
		 * Autolinker would normally generate, and then allow for modifications before returning it. For example:
		 * 
		 *     var html = Autolinker.link( "Test google.com", {
		 *         replaceFn : function( autolinker, match ) {
		 *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance
		 *             tag.setAttr( 'rel', 'nofollow' );
		 *             
		 *             return tag;
		 *         }
		 *     } );
		 *     
		 *     // generated html:
		 *     //   Test <a href="http://google.com" target="_blank" rel="nofollow">google.com</a>
		 * 
		 * @return {Autolinker.AnchorTagBuilder}
		 */
		getTagBuilder : function() {
			var tagBuilder = this.tagBuilder;

			if( !tagBuilder ) {
				tagBuilder = this.tagBuilder = new Autolinker.AnchorTagBuilder( {
					newWindow   : this.newWindow,
					truncate    : this.truncate,
					className   : this.className
				} );
			}

			return tagBuilder;
		},


		/**
		 * Process the text that lies inbetween HTML tags. This method does the actual wrapping of URLs with
		 * anchor tags.
		 * 
		 * @private
		 * @param {String} text The text to auto-link.
		 * @return {String} The text with anchor tags auto-filled.
		 */
		processTextNode : function( text ) {
			var me = this;  // for closure

			return text.replace( this.matcherRegex, function( matchStr, $1, $2, $3, $4, $5, $6, $7, $8 ) {
				var matchDescObj = me.processCandidateMatch( matchStr, $1, $2, $3, $4, $5, $6, $7, $8 );  // match description object

				// Return out with no changes for match types that are disabled (url, email, twitter), or for matches that are 
				// invalid (false positives from the matcherRegex, which can't use look-behinds since they are unavailable in JS).
				if( !matchDescObj ) {
					return matchStr;

				} else {
					// Generate the replacement text for the match
					var matchReturnVal = me.createMatchReturnVal( matchDescObj.match, matchDescObj.matchStr );
					return matchDescObj.prefixStr + matchReturnVal + matchDescObj.suffixStr;
				}
			} );
		},


		/**
		 * Processes a candidate match from the {@link #matcherRegex}. 
		 * 
		 * Not all matches found by the regex are actual URL/email/Twitter matches, as determined by the {@link #matchValidator}. In
		 * this case, the method returns `null`. Otherwise, a valid Object with `prefixStr`, `match`, and `suffixStr` is returned.
		 * 
		 * @private
		 * @param {String} matchStr The full match that was found by the {@link #matcherRegex}.
		 * @param {String} twitterMatch The matched text of a Twitter handle, if the match is a Twitter match.
		 * @param {String} twitterHandlePrefixWhitespaceChar The whitespace char before the @ sign in a Twitter handle match. This 
		 *   is needed because of no lookbehinds in JS regexes, and is need to re-include the character for the anchor tag replacement.
		 * @param {String} twitterHandle The actual Twitter user (i.e the word after the @ sign in a Twitter match).
		 * @param {String} emailAddressMatch The matched email address for an email address match.
		 * @param {String} urlMatch The matched URL string for a URL match.
		 * @param {String} protocolUrlMatch The match URL string for a protocol match. Ex: 'http://yahoo.com'. This is used to match
		 *   something like 'http://localhost', where we won't double check that the domain name has at least one '.' in it.
		 * @param {String} wwwProtocolRelativeMatch The '//' for a protocol-relative match from a 'www' url, with the character that 
		 *   comes before the '//'.
		 * @param {String} tldProtocolRelativeMatch The '//' for a protocol-relative match from a TLD (top level domain) match, with 
		 *   the character that comes before the '//'.
		 *   
		 * @return {Object} A "match description object". This will be `null` if the match was invalid, or if a match type is disabled.
		 *   Otherwise, this will be an Object (map) with the following properties:
		 * @return {String} return.prefixStr The char(s) that should be prepended to the replacement string. These are char(s) that
		 *   were needed to be included from the regex match that were ignored by processing code, and should be re-inserted into 
		 *   the replacement stream.
		 * @return {String} return.suffixStr The char(s) that should be appended to the replacement string. These are char(s) that
		 *   were needed to be included from the regex match that were ignored by processing code, and should be re-inserted into 
		 *   the replacement stream.
		 * @return {String} return.matchStr The `matchStr`, fixed up to remove characters that are no longer needed (which have been
		 *   added to `prefixStr` and `suffixStr`).
		 * @return {Autolinker.match.Match} return.match The Match object that represents the match that was found.
		 */
		processCandidateMatch : function( 
			matchStr, twitterMatch, twitterHandlePrefixWhitespaceChar, twitterHandle, 
			emailAddressMatch, urlMatch, protocolUrlMatch, wwwProtocolRelativeMatch, tldProtocolRelativeMatch
		) {
			var protocolRelativeMatch = wwwProtocolRelativeMatch || tldProtocolRelativeMatch,
			    match,  // Will be an Autolinker.match.Match object

			    prefixStr = "",       // A string to use to prefix the anchor tag that is created. This is needed for the Twitter handle match
			    suffixStr = "";       // A string to suffix the anchor tag that is created. This is used if there is a trailing parenthesis that should not be auto-linked.


			// Return out with `null` for match types that are disabled (url, email, twitter), or for matches that are 
			// invalid (false positives from the matcherRegex, which can't use look-behinds since they are unavailable in JS).
			if(
				( twitterMatch && !this.twitter ) || ( emailAddressMatch && !this.email ) || ( urlMatch && !this.urls ) ||
				!this.matchValidator.isValidMatch( urlMatch, protocolUrlMatch, protocolRelativeMatch ) 
			) {
				return null;
			}

			// Handle a closing parenthesis at the end of the match, and exclude it if there is not a matching open parenthesis
			// in the match itself. 
			if( this.matchHasUnbalancedClosingParen( matchStr ) ) {
				matchStr = matchStr.substr( 0, matchStr.length - 1 );  // remove the trailing ")"
				suffixStr = ")";  // this will be added after the generated <a> tag
			}


			if( emailAddressMatch ) {
				match = new Autolinker.match.Email( { matchedText: matchStr, email: emailAddressMatch } );

			} else if( twitterMatch ) {
				// fix up the `matchStr` if there was a preceding whitespace char, which was needed to determine the match 
				// itself (since there are no look-behinds in JS regexes)
				if( twitterHandlePrefixWhitespaceChar ) {
					prefixStr = twitterHandlePrefixWhitespaceChar;
					matchStr = matchStr.slice( 1 );  // remove the prefixed whitespace char from the match
				}
				match = new Autolinker.match.Twitter( { matchedText: matchStr, twitterHandle: twitterHandle } );

			} else {  // url match
				// If it's a protocol-relative '//' match, remove the character before the '//' (which the matcherRegex needed
				// to match due to the lack of a negative look-behind in JavaScript regular expressions)
				if( protocolRelativeMatch ) {
					var charBeforeMatch = protocolRelativeMatch.match( this.charBeforeProtocolRelMatchRegex )[ 1 ] || "";

					if( charBeforeMatch ) {  // fix up the `matchStr` if there was a preceding char before a protocol-relative match, which was needed to determine the match itself (since there are no look-behinds in JS regexes)
						prefixStr = charBeforeMatch;
						matchStr = matchStr.slice( 1 );  // remove the prefixed char from the match
					}
				}

				match = new Autolinker.match.Url( {
					matchedText : matchStr,
					url : matchStr,
					protocolUrlMatch : !!protocolUrlMatch,
					protocolRelativeMatch : !!protocolRelativeMatch,
					stripPrefix : this.stripPrefix
				} );
			}

			return {
				prefixStr : prefixStr,
				suffixStr : suffixStr,
				matchStr  : matchStr,
				match     : match
			};
		},


		/**
		 * Determines if a match found has an unmatched closing parenthesis. If so, this parenthesis will be removed
		 * from the match itself, and appended after the generated anchor tag in {@link #processTextNode}.
		 * 
		 * A match may have an extra closing parenthesis at the end of the match because the regular expression must include parenthesis
		 * for URLs such as "wikipedia.com/something_(disambiguation)", which should be auto-linked. 
		 * 
		 * However, an extra parenthesis *will* be included when the URL itself is wrapped in parenthesis, such as in the case of
		 * "(wikipedia.com/something_(disambiguation))". In this case, the last closing parenthesis should *not* be part of the URL 
		 * itself, and this method will return `true`.
		 * 
		 * @private
		 * @param {String} matchStr The full match string from the {@link #matcherRegex}.
		 * @return {Boolean} `true` if there is an unbalanced closing parenthesis at the end of the `matchStr`, `false` otherwise.
		 */
		matchHasUnbalancedClosingParen : function( matchStr ) {
			var lastChar = matchStr.charAt( matchStr.length - 1 );

			if( lastChar === ')' ) {
				var openParensMatch = matchStr.match( /\(/g ),
				    closeParensMatch = matchStr.match( /\)/g ),
				    numOpenParens = ( openParensMatch && openParensMatch.length ) || 0,
				    numCloseParens = ( closeParensMatch && closeParensMatch.length ) || 0;

				if( numOpenParens < numCloseParens ) {
					return true;
				}
			}

			return false;
		},


		/**
		 * Creates the return string value for a given match in the input string, for the {@link #processTextNode} method.
		 * 
		 * This method handles the {@link #replaceFn}, if one was provided.
		 * 
		 * @private
		 * @param {Autolinker.match.Match} match The Match object that represents the match.
		 * @param {String} matchStr The original match string, after having been preprocessed to fix match edge cases (see
		 *   the `prefixStr` and `suffixStr` vars in {@link #processTextNode}.
		 * @return {String} The string that the `match` should be replaced with. This is usually the anchor tag string, but
		 *   may be the `matchStr` itself if the match is not to be replaced.
		 */
		createMatchReturnVal : function( match, matchStr ) {
			// Handle a custom `replaceFn` being provided
			var replaceFnResult;
			if( this.replaceFn ) {
				replaceFnResult = this.replaceFn.call( this, this, match );  // Autolinker instance is the context, and the first arg
			}

			if( typeof replaceFnResult === 'string' ) {
				return replaceFnResult;  // `replaceFn` returned a string, use that

			} else if( replaceFnResult === false ) {
				return matchStr;  // no replacement for the match

			} else if( replaceFnResult instanceof Autolinker.HtmlTag ) {
				return replaceFnResult.toString();

			} else {  // replaceFnResult === true, or no/unknown return value from function
				// Perform Autolinker's default anchor tag generation
				var tagBuilder = this.getTagBuilder(),
				    anchorTag = tagBuilder.build( match );  // returns an Autolinker.HtmlTag instance

				return anchorTag.toString();
			}
		}

	};


	/**
	 * Automatically links URLs, email addresses, and Twitter handles found in the given chunk of HTML. 
	 * Does not link URLs found within HTML tags.
	 * 
	 * For instance, if given the text: `You should go to http://www.yahoo.com`, then the result
	 * will be `You should go to &lt;a href="http://www.yahoo.com"&gt;http://www.yahoo.com&lt;/a&gt;`
	 * 
	 * Example:
	 * 
	 *     var linkedText = Autolinker.link( "Go to google.com", { newWindow: false } );
	 *     // Produces: "Go to <a href="http://google.com">google.com</a>"
	 * 
	 * @static
	 * @param {String} textOrHtml The HTML or text to find URLs, email addresses, and Twitter handles within (depending on if
	 *   the {@link #urls}, {@link #email}, and {@link #twitter} options are enabled).
	 * @param {Object} [options] Any of the configuration options for the Autolinker class, specified in an Object (map).
	 *   See the class description for an example call.
	 * @return {String} The HTML text, with URLs automatically linked
	 */
	Autolinker.link = function( textOrHtml, options ) {
		var autolinker = new Autolinker( options );
		return autolinker.link( textOrHtml );
	};


	// Namespace for `match` classes
	Autolinker.match = {};
	/*global Autolinker */
	/*jshint eqnull:true, boss:true */
	/**
	 * @class Autolinker.Util
	 * @singleton
	 * 
	 * A few utility methods for Autolinker.
	 */
	Autolinker.Util = {

		/**
		 * @property {Function} abstractMethod
		 * 
		 * A function object which represents an abstract method.
		 */
		abstractMethod : function() { throw "abstract"; },


		/**
		 * Assigns (shallow copies) the properties of `src` onto `dest`.
		 * 
		 * @param {Object} dest The destination object.
		 * @param {Object} src The source object.
		 * @return {Object} The destination object (`dest`)
		 */
		assign : function( dest, src ) {
			for( var prop in src ) {
				if( src.hasOwnProperty( prop ) ) {
					dest[ prop ] = src[ prop ];
				}
			}

			return dest;
		},


		/**
		 * Extends `superclass` to create a new subclass, adding the `protoProps` to the new subclass's prototype.
		 * 
		 * @param {Function} superclass The constructor function for the superclass.
		 * @param {Object} protoProps The methods/properties to add to the subclass's prototype. This may contain the
		 *   special property `constructor`, which will be used as the new subclass's constructor function.
		 * @return {Function} The new subclass function.
		 */
		extend : function( superclass, protoProps ) {
			var superclassProto = superclass.prototype;

			var F = function() {};
			F.prototype = superclassProto;

			var subclass;
			if( protoProps.hasOwnProperty( 'constructor' ) ) {
				subclass = protoProps.constructor;
			} else {
				subclass = function() { superclassProto.constructor.apply( this, arguments ); };
			}

			var subclassProto = subclass.prototype = new F();  // set up prototype chain
			subclassProto.constructor = subclass;  // fix constructor property
			subclassProto.superclass = superclassProto;

			delete protoProps.constructor;  // don't re-assign constructor property to the prototype, since a new function may have been created (`subclass`), which is now already there
			Autolinker.Util.assign( subclassProto, protoProps );

			return subclass;
		},


		/**
		 * Truncates the `str` at `len - ellipsisChars.length`, and adds the `ellipsisChars` to the
		 * end of the string (by default, two periods: '..'). If the `str` length does not exceed 
		 * `len`, the string will be returned unchanged.
		 * 
		 * @param {String} str The string to truncate and add an ellipsis to.
		 * @param {Number} truncateLen The length to truncate the string at.
		 * @param {String} [ellipsisChars=..] The ellipsis character(s) to add to the end of `str`
		 *   when truncated. Defaults to '..'
		 */
		ellipsis : function( str, truncateLen, ellipsisChars ) {
			if( str.length > truncateLen ) {
				ellipsisChars = ( ellipsisChars == null ) ? '..' : ellipsisChars;
				str = str.substring( 0, truncateLen - ellipsisChars.length ) + ellipsisChars;
			}
			return str;
		},


		/**
		 * Supports `Array.prototype.indexOf()` functionality for old IE (IE8 and below).
		 * 
		 * @param {Array} arr The array to find an element of.
		 * @param {*} element The element to find in the array, and return the index of.
		 * @return {Number} The index of the `element`, or -1 if it was not found.
		 */
		indexOf : function( arr, element ) {
			if( Array.prototype.indexOf ) {
				return arr.indexOf( element );

			} else {
				for( var i = 0, len = arr.length; i < len; i++ ) {
					if( arr[ i ] === element ) return i;
				}
				return -1;
			}
		},



		/**
		 * Performs the functionality of what modern browsers do when `String.prototype.split()` is called
		 * with a regular expression that contains capturing parenthesis.
		 * 
		 * For example:
		 * 
		 *     // Modern browsers: 
		 *     "a,b,c".split( /(,)/ );  // --> [ 'a', ',', 'b', ',', 'c' ]
		 *     
		 *     // Old IE (including IE8):
		 *     "a,b,c".split( /(,)/ );  // --> [ 'a', 'b', 'c' ]
		 *     
		 * This method emulates the functionality of modern browsers for the old IE case.
		 * 
		 * @param {String} str The string to split.
		 * @param {RegExp} splitRegex The regular expression to split the input `str` on. The splitting
		 *   character(s) will be spliced into the array, as in the "modern browsers" example in the 
		 *   description of this method. 
		 *   Note #1: the supplied regular expression **must** have the 'g' flag specified.
		 *   Note #2: for simplicity's sake, the regular expression does not need 
		 *   to contain capturing parenthesis - it will be assumed that any match has them.
		 * @return {String[]} The split array of strings, with the splitting character(s) included.
		 */
		splitAndCapture : function( str, splitRegex ) {
			if( !splitRegex.global ) throw new Error( "`splitRegex` must have the 'g' flag set" );

			var result = [],
			    lastIdx = 0,
			    match;

			while( match = splitRegex.exec( str ) ) {
				result.push( str.substring( lastIdx, match.index ) );
				result.push( match[ 0 ] );  // push the splitting char(s)

				lastIdx = match.index + match[ 0 ].length;
			}
			result.push( str.substring( lastIdx ) );

			return result;
		}

	};
	/*global Autolinker */
	/**
	 * @private
	 * @class Autolinker.HtmlParser
	 * @extends Object
	 * 
	 * An HTML parser implementation which simply walks an HTML string and calls the provided visitor functions to process 
	 * HTML and text nodes.
	 * 
	 * Autolinker uses this to only link URLs/emails/Twitter handles within text nodes, basically ignoring HTML tags.
	 */
	Autolinker.HtmlParser = Autolinker.Util.extend( Object, {

		/**
		 * @private
		 * @property {RegExp} htmlRegex
		 * 
		 * The regular expression used to pull out HTML tags from a string. Handles namespaced HTML tags and
		 * attribute names, as specified by http://www.w3.org/TR/html-markup/syntax.html.
		 * 
		 * Capturing groups:
		 * 
		 * 1. The "!DOCTYPE" tag name, if a tag is a &lt;!DOCTYPE&gt; tag.
		 * 2. If it is an end tag, this group will have the '/'.
		 * 3. The tag name for all tags (other than the &lt;!DOCTYPE&gt; tag)
		 */
		htmlRegex : (function() {
			var tagNameRegex = /[0-9a-zA-Z][0-9a-zA-Z:]*/,
			    attrNameRegex = /[^\s\0"'>\/=\x01-\x1F\x7F]+/,   // the unicode range accounts for excluding control chars, and the delete char
			    attrValueRegex = /(?:"[^"]*?"|'[^']*?'|[^'"=<>`\s]+)/, // double quoted, single quoted, or unquoted attribute values
			    nameEqualsValueRegex = attrNameRegex.source + '(?:\\s*=\\s*' + attrValueRegex.source + ')?';  // optional '=[value]'

			return new RegExp( [
				// for <!DOCTYPE> tag. Ex: <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">) 
				'(?:',
					'<(!DOCTYPE)',  // *** Capturing Group 1 - If it's a doctype tag

						// Zero or more attributes following the tag name
						'(?:',
							'\\s+',  // one or more whitespace chars before an attribute

							// Either:
							// A. attr="value", or 
							// B. "value" alone (To cover example doctype tag: <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">) 
							'(?:', nameEqualsValueRegex, '|', attrValueRegex.source + ')',
						')*',
					'>',
				')',

				'|',

				// All other HTML tags (i.e. tags that are not <!DOCTYPE>)
				'(?:',
					'<(/)?',  // Beginning of a tag. Either '<' for a start tag, or '</' for an end tag. 
					          // *** Capturing Group 2: The slash or an empty string. Slash ('/') for end tag, empty string for start or self-closing tag.

						// *** Capturing Group 3 - The tag name
						'(' + tagNameRegex.source + ')',

						// Zero or more attributes following the tag name
						'(?:',
							'\\s+',                // one or more whitespace chars before an attribute
							nameEqualsValueRegex,  // attr="value" (with optional ="value" part)
						')*',

						'\\s*/?',  // any trailing spaces and optional '/' before the closing '>'
					'>',
				')'
			].join( "" ), 'gi' );
		} )(),


		/**
		 * Walks an HTML string, calling the `options.processHtmlNode` function for each HTML tag that is encountered, and calling
		 * the `options.processTextNode` function when each text around HTML tags is encountered.
		 * 
		 * @param {String} html The HTML to parse.
		 * @param {Object} [options] An Object (map) which may contain the following properties:
		 * 
		 * @param {Function} [options.processHtmlNode] A visitor function which allows processing of an encountered HTML node.
		 *   This function is called with the following arguments:
		 * @param {String} [options.processHtmlNode.tagText] The HTML tag text that was found.
		 * @param {String} [options.processHtmlNode.tagName] The tag name for the HTML tag that was found. Ex: 'a' for an anchor tag.
		 * @param {String} [options.processHtmlNode.isClosingTag] `true` if the tag is a closing tag (ex: &lt;/a&gt;), `false` otherwise.
		 *  
		 * @param {Function} [options.processTextNode] A visitor function which allows processing of an encountered text node.
		 *   This function is called with the following arguments:
		 * @param {String} [options.processTextNode.text] The text node that was matched.
		 */
		parse : function( html, options ) {
			options = options || {};

			var processHtmlNodeVisitor = options.processHtmlNode || function() {},
			    processTextNodeVisitor = options.processTextNode || function() {},
			    htmlRegex = this.htmlRegex,
			    currentResult,
			    lastIndex = 0;

			// Loop over the HTML string, ignoring HTML tags, and processing the text that lies between them,
			// wrapping the URLs in anchor tags
			while( ( currentResult = htmlRegex.exec( html ) ) !== null ) {
				var tagText = currentResult[ 0 ],
				    tagName = currentResult[ 1 ] || currentResult[ 3 ],  // The <!DOCTYPE> tag (ex: "!DOCTYPE"), or another tag (ex: "a") 
				    isClosingTag = !!currentResult[ 2 ],
				    inBetweenTagsText = html.substring( lastIndex, currentResult.index );

				if( inBetweenTagsText ) {
					processTextNodeVisitor( inBetweenTagsText );
				}

				processHtmlNodeVisitor( tagText, tagName.toLowerCase(), isClosingTag );

				lastIndex = currentResult.index + tagText.length;
			}

			// Process any remaining text after the last HTML element. Will process all of the text if there were no HTML elements.
			if( lastIndex < html.length ) {
				var text = html.substring( lastIndex );

				if( text ) {
					processTextNodeVisitor( text );
				}
			}
		}

	} );
	/*global Autolinker */
	/*jshint boss:true */
	/**
	 * @class Autolinker.HtmlTag
	 * @extends Object
	 * 
	 * Represents an HTML tag, which can be used to easily build/modify HTML tags programmatically.
	 * 
	 * Autolinker uses this abstraction to create HTML tags, and then write them out as strings. You may also use
	 * this class in your code, especially within a {@link Autolinker#replaceFn replaceFn}.
	 * 
	 * ## Examples
	 * 
	 * Example instantiation:
	 * 
	 *     var tag = new Autolinker.HtmlTag( {
	 *         tagName : 'a',
	 *         attrs   : { 'href': 'http://google.com', 'class': 'external-link' },
	 *         innerHtml : 'Google'
	 *     } );
	 *     
	 *     tag.toString();  // <a href="http://google.com" class="external-link">Google</a>
	 *     
	 *     // Individual accessor methods
	 *     tag.getTagName();                 // 'a'
	 *     tag.getAttr( 'href' );            // 'http://google.com'
	 *     tag.hasClass( 'external-link' );  // true
	 * 
	 * 
	 * Using mutator methods (which may be used in combination with instantiation config properties):
	 * 
	 *     var tag = new Autolinker.HtmlTag();
	 *     tag.setTagName( 'a' );
	 *     tag.setAttr( 'href', 'http://google.com' );
	 *     tag.addClass( 'external-link' );
	 *     tag.setInnerHtml( 'Google' );
	 *     
	 *     tag.getTagName();                 // 'a'
	 *     tag.getAttr( 'href' );            // 'http://google.com'
	 *     tag.hasClass( 'external-link' );  // true
	 *     
	 *     tag.toString();  // <a href="http://google.com" class="external-link">Google</a>
	 *     
	 * 
	 * ## Example use within a {@link Autolinker#replaceFn replaceFn}
	 * 
	 *     var html = Autolinker.link( "Test google.com", {
	 *         replaceFn : function( autolinker, match ) {
	 *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance, configured with the Match's href and anchor text
	 *             tag.setAttr( 'rel', 'nofollow' );
	 *             
	 *             return tag;
	 *         }
	 *     } );
	 *     
	 *     // generated html:
	 *     //   Test <a href="http://google.com" target="_blank" rel="nofollow">google.com</a>
	 *     
	 *     
	 * ## Example use with a new tag for the replacement
	 * 
	 *     var html = Autolinker.link( "Test google.com", {
	 *         replaceFn : function( autolinker, match ) {
	 *             var tag = new Autolinker.HtmlTag( {
	 *                 tagName : 'button',
	 *                 attrs   : { 'title': 'Load URL: ' + match.getAnchorHref() },
	 *                 innerHtml : 'Load URL: ' + match.getAnchorText()
	 *             } );
	 *             
	 *             return tag;
	 *         }
	 *     } );
	 *     
	 *     // generated html:
	 *     //   Test <button title="Load URL: http://google.com">Load URL: google.com</button>
	 */
	Autolinker.HtmlTag = Autolinker.Util.extend( Object, {

		/**
		 * @cfg {String} tagName
		 * 
		 * The tag name. Ex: 'a', 'button', etc.
		 * 
		 * Not required at instantiation time, but should be set using {@link #setTagName} before {@link #toString}
		 * is executed.
		 */

		/**
		 * @cfg {Object.<String, String>} attrs
		 * 
		 * An key/value Object (map) of attributes to create the tag with. The keys are the attribute names, and the
		 * values are the attribute values.
		 */

		/**
		 * @cfg {String} innerHtml
		 * 
		 * The inner HTML for the tag. 
		 * 
		 * Note the camel case name on `innerHtml`. Acronyms are camelCased in this utility (such as not to run into the acronym 
		 * naming inconsistency that the DOM developers created with `XMLHttpRequest`). You may alternatively use {@link #innerHTML}
		 * if you prefer, but this one is recommended.
		 */

		/**
		 * @cfg {String} innerHTML
		 * 
		 * Alias of {@link #innerHtml}, accepted for consistency with the browser DOM api, but prefer the camelCased version
		 * for acronym names.
		 */


		/**
		 * @protected
		 * @property {RegExp} whitespaceRegex
		 * 
		 * Regular expression used to match whitespace in a string of CSS classes.
		 */
		whitespaceRegex : /\s+/,


		/**
		 * @constructor
		 * @param {Object} [cfg] The configuration properties for this class, in an Object (map)
		 */
		constructor : function( cfg ) {
			Autolinker.Util.assign( this, cfg );

			this.innerHtml = this.innerHtml || this.innerHTML;  // accept either the camelCased form or the fully capitalized acronym
		},


		/**
		 * Sets the tag name that will be used to generate the tag with.
		 * 
		 * @param {String} tagName
		 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
		 */
		setTagName : function( tagName ) {
			this.tagName = tagName;
			return this;
		},


		/**
		 * Retrieves the tag name.
		 * 
		 * @return {String}
		 */
		getTagName : function() {
			return this.tagName || "";
		},


		/**
		 * Sets an attribute on the HtmlTag.
		 * 
		 * @param {String} attrName The attribute name to set.
		 * @param {String} attrValue The attribute value to set.
		 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
		 */
		setAttr : function( attrName, attrValue ) {
			var tagAttrs = this.getAttrs();
			tagAttrs[ attrName ] = attrValue;

			return this;
		},


		/**
		 * Retrieves an attribute from the HtmlTag. If the attribute does not exist, returns `undefined`.
		 * 
		 * @param {String} name The attribute name to retrieve.
		 * @return {String} The attribute's value, or `undefined` if it does not exist on the HtmlTag.
		 */
		getAttr : function( attrName ) {
			return this.getAttrs()[ attrName ];
		},


		/**
		 * Sets one or more attributes on the HtmlTag.
		 * 
		 * @param {Object.<String, String>} attrs A key/value Object (map) of the attributes to set.
		 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
		 */
		setAttrs : function( attrs ) {
			var tagAttrs = this.getAttrs();
			Autolinker.Util.assign( tagAttrs, attrs );

			return this;
		},


		/**
		 * Retrieves the attributes Object (map) for the HtmlTag.
		 * 
		 * @return {Object.<String, String>} A key/value object of the attributes for the HtmlTag.
		 */
		getAttrs : function() {
			return this.attrs || ( this.attrs = {} );
		},


		/**
		 * Sets the provided `cssClass`, overwriting any current CSS classes on the HtmlTag.
		 * 
		 * @param {String} cssClass One or more space-separated CSS classes to set (overwrite).
		 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
		 */
		setClass : function( cssClass ) {
			return this.setAttr( 'class', cssClass );
		},


		/**
		 * Convenience method to add one or more CSS classes to the HtmlTag. Will not add duplicate CSS classes.
		 * 
		 * @param {String} cssClass One or more space-separated CSS classes to add.
		 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
		 */
		addClass : function( cssClass ) {
			var classAttr = this.getClass(),
			    whitespaceRegex = this.whitespaceRegex,
			    indexOf = Autolinker.Util.indexOf,  // to support IE8 and below
			    classes = ( !classAttr ) ? [] : classAttr.split( whitespaceRegex ),
			    newClasses = cssClass.split( whitespaceRegex ),
			    newClass;

			while( newClass = newClasses.shift() ) {
				if( indexOf( classes, newClass ) === -1 ) {
					classes.push( newClass );
				}
			}

			this.getAttrs()[ 'class' ] = classes.join( " " );
			return this;
		},


		/**
		 * Convenience method to remove one or more CSS classes from the HtmlTag.
		 * 
		 * @param {String} cssClass One or more space-separated CSS classes to remove.
		 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
		 */
		removeClass : function( cssClass ) {
			var classAttr = this.getClass(),
			    whitespaceRegex = this.whitespaceRegex,
			    indexOf = Autolinker.Util.indexOf,  // to support IE8 and below
			    classes = ( !classAttr ) ? [] : classAttr.split( whitespaceRegex ),
			    removeClasses = cssClass.split( whitespaceRegex ),
			    removeClass;

			while( classes.length && ( removeClass = removeClasses.shift() ) ) {
				var idx = indexOf( classes, removeClass );
				if( idx !== -1 ) {
					classes.splice( idx, 1 );
				}
			}

			this.getAttrs()[ 'class' ] = classes.join( " " );
			return this;
		},


		/**
		 * Convenience method to retrieve the CSS class(es) for the HtmlTag, which will each be separated by spaces when
		 * there are multiple.
		 * 
		 * @return {String}
		 */
		getClass : function() {
			return this.getAttrs()[ 'class' ] || "";
		},


		/**
		 * Convenience method to check if the tag has a CSS class or not.
		 * 
		 * @param {String} cssClass The CSS class to check for.
		 * @return {Boolean} `true` if the HtmlTag has the CSS class, `false` otherwise.
		 */
		hasClass : function( cssClass ) {
			return ( ' ' + this.getClass() + ' ' ).indexOf( ' ' + cssClass + ' ' ) !== -1;
		},


		/**
		 * Sets the inner HTML for the tag.
		 * 
		 * @param {String} html The inner HTML to set.
		 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
		 */
		setInnerHtml : function( html ) {
			this.innerHtml = html;

			return this;
		},


		/**
		 * Retrieves the inner HTML for the tag.
		 * 
		 * @return {String}
		 */
		getInnerHtml : function() {
			return this.innerHtml || "";
		},


		/**
		 * Override of superclass method used to generate the HTML string for the tag.
		 * 
		 * @return {String}
		 */
		toString : function() {
			var tagName = this.getTagName(),
			    attrsStr = this.buildAttrsStr();

			attrsStr = ( attrsStr ) ? ' ' + attrsStr : '';  // prepend a space if there are actually attributes

			return [ '<', tagName, attrsStr, '>', this.getInnerHtml(), '</', tagName, '>' ].join( "" );
		},


		/**
		 * Support method for {@link #toString}, returns the string space-separated key="value" pairs, used to populate 
		 * the stringified HtmlTag.
		 * 
		 * @protected
		 * @return {String} Example return: `attr1="value1" attr2="value2"`
		 */
		buildAttrsStr : function() {
			if( !this.attrs ) return "";  // no `attrs` Object (map) has been set, return empty string

			var attrs = this.getAttrs(),
			    attrsArr = [];

			for( var prop in attrs ) {
				if( attrs.hasOwnProperty( prop ) ) {
					attrsArr.push( prop + '="' + attrs[ prop ] + '"' );
				}
			}
			return attrsArr.join( " " );
		}

	} );
	/*global Autolinker */
	/*jshint scripturl:true */
	/**
	 * @private
	 * @class Autolinker.MatchValidator
	 * @extends Object
	 * 
	 * Used by Autolinker to filter out false positives from the {@link Autolinker#matcherRegex}.
	 * 
	 * Due to the limitations of regular expressions (including the missing feature of look-behinds in JS regular expressions),
	 * we cannot always determine the validity of a given match. This class applies a bit of additional logic to filter out any
	 * false positives that have been matched by the {@link Autolinker#matcherRegex}.
	 */
	Autolinker.MatchValidator = Autolinker.Util.extend( Object, {

		/**
		 * @private
		 * @property {RegExp} invalidProtocolRelMatchRegex
		 * 
		 * The regular expression used to check a potential protocol-relative URL match, coming from the 
		 * {@link Autolinker#matcherRegex}. A protocol-relative URL is, for example, "//yahoo.com"
		 * 
		 * This regular expression checks to see if there is a word character before the '//' match in order to determine if 
		 * we should actually autolink a protocol-relative URL. This is needed because there is no negative look-behind in 
		 * JavaScript regular expressions. 
		 * 
		 * For instance, we want to autolink something like "Go to: //google.com", but we don't want to autolink something 
		 * like "abc//google.com"
		 */
		invalidProtocolRelMatchRegex : /^[\w]\/\//,

		/**
		 * Regex to test for a full protocol, with the two trailing slashes. Ex: 'http://'
		 * 
		 * @private
		 * @property {RegExp} hasFullProtocolRegex
		 */
		hasFullProtocolRegex : /^[A-Za-z][-.+A-Za-z0-9]+:\/\//,

		/**
		 * Regex to find the URI scheme, such as 'mailto:'.
		 * 
		 * This is used to filter out 'javascript:' and 'vbscript:' schemes.
		 * 
		 * @private
		 * @property {RegExp} uriSchemeRegex
		 */
		uriSchemeRegex : /^[A-Za-z][-.+A-Za-z0-9]+:/,

		/**
		 * Regex to determine if at least one word char exists after the protocol (i.e. after the ':')
		 * 
		 * @private
		 * @property {RegExp} hasWordCharAfterProtocolRegex
		 */
		hasWordCharAfterProtocolRegex : /:[^\s]*?[A-Za-z]/,


		/**
		 * Determines if a given match found by {@link Autolinker#processTextNode} is valid. Will return `false` for:
		 * 
		 * 1) URL matches which do not have at least have one period ('.') in the domain name (effectively skipping over 
		 *    matches like "abc:def"). However, URL matches with a protocol will be allowed (ex: 'http://localhost')
		 * 2) URL matches which do not have at least one word character in the domain name (effectively skipping over
		 *    matches like "git:1.0").
		 * 3) A protocol-relative url match (a URL beginning with '//') whose previous character is a word character 
		 *    (effectively skipping over strings like "abc//google.com")
		 * 
		 * Otherwise, returns `true`.
		 * 
		 * @param {String} urlMatch The matched URL, if there was one. Will be an empty string if the match is not a URL match.
		 * @param {String} protocolUrlMatch The match URL string for a protocol match. Ex: 'http://yahoo.com'. This is used to match
		 *   something like 'http://localhost', where we won't double check that the domain name has at least one '.' in it.
		 * @param {String} protocolRelativeMatch The protocol-relative string for a URL match (i.e. '//'), possibly with a preceding
		 *   character (ex, a space, such as: ' //', or a letter, such as: 'a//'). The match is invalid if there is a word character
		 *   preceding the '//'.
		 * @return {Boolean} `true` if the match given is valid and should be processed, or `false` if the match is invalid and/or 
		 *   should just not be processed.
		 */
		isValidMatch : function( urlMatch, protocolUrlMatch, protocolRelativeMatch ) {
			if(
				( protocolUrlMatch && !this.isValidUriScheme( protocolUrlMatch ) ) ||
				this.urlMatchDoesNotHaveProtocolOrDot( urlMatch, protocolUrlMatch ) ||       // At least one period ('.') must exist in the URL match for us to consider it an actual URL, *unless* it was a full protocol match (like 'http://localhost')
				this.urlMatchDoesNotHaveAtLeastOneWordChar( urlMatch, protocolUrlMatch ) ||  // At least one letter character must exist in the domain name after a protocol match. Ex: skip over something like "git:1.0"
				this.isInvalidProtocolRelativeMatch( protocolRelativeMatch )                 // A protocol-relative match which has a word character in front of it (so we can skip something like "abc//google.com")
			) {
				return false;
			}

			return true;
		},


		/**
		 * Determines if the URI scheme is a valid scheme to be autolinked. Returns `false` if the scheme is 
		 * 'javascript:' or 'vbscript:'
		 * 
		 * @private
		 * @param {String} uriSchemeMatch The match URL string for a full URI scheme match. Ex: 'http://yahoo.com' 
		 *   or 'mailto:a@a.com'.
		 * @return {Boolean} `true` if the scheme is a valid one, `false` otherwise.
		 */
		isValidUriScheme : function( uriSchemeMatch ) {
			var uriScheme = uriSchemeMatch.match( this.uriSchemeRegex )[ 0 ];

			return ( uriScheme !== 'javascript:' && uriScheme !== 'vbscript:' );
		},


		/**
		 * Determines if a URL match does not have either:
		 * 
		 * a) a full protocol (i.e. 'http://'), or
		 * b) at least one dot ('.') in the domain name (for a non-full-protocol match).
		 * 
		 * Either situation is considered an invalid URL (ex: 'git:d' does not have either the '://' part, or at least one dot
		 * in the domain name. If the match was 'git:abc.com', we would consider this valid.)
		 * 
		 * @private
		 * @param {String} urlMatch The matched URL, if there was one. Will be an empty string if the match is not a URL match.
		 * @param {String} protocolUrlMatch The match URL string for a protocol match. Ex: 'http://yahoo.com'. This is used to match
		 *   something like 'http://localhost', where we won't double check that the domain name has at least one '.' in it.
		 * @return {Boolean} `true` if the URL match does not have a full protocol, or at least one dot ('.') in a non-full-protocol
		 *   match.
		 */
		urlMatchDoesNotHaveProtocolOrDot : function( urlMatch, protocolUrlMatch ) {
			return ( !!urlMatch && ( !protocolUrlMatch || !this.hasFullProtocolRegex.test( protocolUrlMatch ) ) && urlMatch.indexOf( '.' ) === -1 );
		},


		/**
		 * Determines if a URL match does not have at least one word character after the protocol (i.e. in the domain name).
		 * 
		 * At least one letter character must exist in the domain name after a protocol match. Ex: skip over something 
		 * like "git:1.0"
		 * 
		 * @private
		 * @param {String} urlMatch The matched URL, if there was one. Will be an empty string if the match is not a URL match.
		 * @param {String} protocolUrlMatch The match URL string for a protocol match. Ex: 'http://yahoo.com'. This is used to
		 *   know whether or not we have a protocol in the URL string, in order to check for a word character after the protocol
		 *   separator (':').
		 * @return {Boolean} `true` if the URL match does not have at least one word character in it after the protocol, `false`
		 *   otherwise.
		 */
		urlMatchDoesNotHaveAtLeastOneWordChar : function( urlMatch, protocolUrlMatch ) {
			if( urlMatch && protocolUrlMatch ) {
				return !this.hasWordCharAfterProtocolRegex.test( urlMatch );
			} else {
				return false;
			}
		},


		/**
		 * Determines if a protocol-relative match is an invalid one. This method returns `true` if there is a `protocolRelativeMatch`,
		 * and that match contains a word character before the '//' (i.e. it must contain whitespace or nothing before the '//' in
		 * order to be considered valid).
		 * 
		 * @private
		 * @param {String} protocolRelativeMatch The protocol-relative string for a URL match (i.e. '//'), possibly with a preceding
		 *   character (ex, a space, such as: ' //', or a letter, such as: 'a//'). The match is invalid if there is a word character
		 *   preceding the '//'.
		 * @return {Boolean} `true` if it is an invalid protocol-relative match, `false` otherwise.
		 */
		isInvalidProtocolRelativeMatch : function( protocolRelativeMatch ) {
			return ( !!protocolRelativeMatch && this.invalidProtocolRelMatchRegex.test( protocolRelativeMatch ) );
		}

	} );
	/*global Autolinker */
	/*jshint sub:true */
	/**
	 * @protected
	 * @class Autolinker.AnchorTagBuilder
	 * @extends Object
	 * 
	 * Builds anchor (&lt;a&gt;) tags for the Autolinker utility when a match is found.
	 * 
	 * Normally this class is instantiated, configured, and used internally by an {@link Autolinker} instance, but may 
	 * actually be retrieved in a {@link Autolinker#replaceFn replaceFn} to create {@link Autolinker.HtmlTag HtmlTag} instances
	 * which may be modified before returning from the {@link Autolinker#replaceFn replaceFn}. For example:
	 * 
	 *     var html = Autolinker.link( "Test google.com", {
	 *         replaceFn : function( autolinker, match ) {
	 *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance
	 *             tag.setAttr( 'rel', 'nofollow' );
	 *             
	 *             return tag;
	 *         }
	 *     } );
	 *     
	 *     // generated html:
	 *     //   Test <a href="http://google.com" target="_blank" rel="nofollow">google.com</a>
	 */
	Autolinker.AnchorTagBuilder = Autolinker.Util.extend( Object, {

		/**
		 * @cfg {Boolean} newWindow
		 * @inheritdoc Autolinker#newWindow
		 */

		/**
		 * @cfg {Number} truncate
		 * @inheritdoc Autolinker#truncate
		 */

		/**
		 * @cfg {String} className
		 * @inheritdoc Autolinker#className
		 */


		/**
		 * @constructor
		 * @param {Object} [cfg] The configuration options for the AnchorTagBuilder instance, specified in an Object (map).
		 */
		constructor : function( cfg ) {
			Autolinker.Util.assign( this, cfg );
		},


		/**
		 * Generates the actual anchor (&lt;a&gt;) tag to use in place of the matched URL/email/Twitter text,
		 * via its `match` object.
		 * 
		 * @param {Autolinker.match.Match} match The Match instance to generate an anchor tag from.
		 * @return {Autolinker.HtmlTag} The HtmlTag instance for the anchor tag.
		 */
		build : function( match ) {
			var tag = new Autolinker.HtmlTag( {
				tagName   : 'a',
				attrs     : this.createAttrs( match.getType(), match.getAnchorHref() ),
				innerHtml : this.processAnchorText( match.getAnchorText() )
			} );

			return tag;
		},


		/**
		 * Creates the Object (map) of the HTML attributes for the anchor (&lt;a&gt;) tag being generated.
		 * 
		 * @protected
		 * @param {"url"/"email"/"twitter"} matchType The type of match that an anchor tag is being generated for.
		 * @param {String} href The href for the anchor tag.
		 * @return {Object} A key/value Object (map) of the anchor tag's attributes. 
		 */
		createAttrs : function( matchType, anchorHref ) {
			var attrs = {
				'href' : anchorHref  // we'll always have the `href` attribute
			};

			var cssClass = this.createCssClass( matchType );
			if( cssClass ) {
				attrs[ 'class' ] = cssClass;
			}
			if( this.newWindow ) {
				attrs[ 'target' ] = "_blank";
			}

			return attrs;
		},


		/**
		 * Creates the CSS class that will be used for a given anchor tag, based on the `matchType` and the {@link #className}
		 * config.
		 * 
		 * @private
		 * @param {"url"/"email"/"twitter"} matchType The type of match that an anchor tag is being generated for.
		 * @return {String} The CSS class string for the link. Example return: "myLink myLink-url". If no {@link #className}
		 *   was configured, returns an empty string.
		 */
		createCssClass : function( matchType ) {
			var className = this.className;

			if( !className ) 
				return "";
			else
				return className + " " + className + "-" + matchType;  // ex: "myLink myLink-url", "myLink myLink-email", or "myLink myLink-twitter"
		},


		/**
		 * Processes the `anchorText` by truncating the text according to the {@link #truncate} config.
		 * 
		 * @private
		 * @param {String} anchorText The anchor tag's text (i.e. what will be displayed).
		 * @return {String} The processed `anchorText`.
		 */
		processAnchorText : function( anchorText ) {
			anchorText = this.doTruncate( anchorText );

			return anchorText;
		},


		/**
		 * Performs the truncation of the `anchorText`, if the `anchorText` is longer than the {@link #truncate} option.
		 * Truncates the text to 2 characters fewer than the {@link #truncate} option, and adds ".." to the end.
		 * 
		 * @private
		 * @param {String} text The anchor tag's text (i.e. what will be displayed).
		 * @return {String} The truncated anchor text.
		 */
		doTruncate : function( anchorText ) {
			return Autolinker.Util.ellipsis( anchorText, this.truncate || Number.POSITIVE_INFINITY );
		}

	} );
	/*global Autolinker */
	/**
	 * @abstract
	 * @class Autolinker.match.Match
	 * 
	 * Represents a match found in an input string which should be Autolinked. A Match object is what is provided in a 
	 * {@link Autolinker#replaceFn replaceFn}, and may be used to query for details about the match.
	 * 
	 * For example:
	 * 
	 *     var input = "...";  // string with URLs, Email Addresses, and Twitter Handles
	 *     
	 *     var linkedText = Autolinker.link( input, {
	 *         replaceFn : function( autolinker, match ) {
	 *             console.log( "href = ", match.getAnchorHref() );
	 *             console.log( "text = ", match.getAnchorText() );
	 *         
	 *             switch( match.getType() ) {
	 *                 case 'url' : 
	 *                     console.log( "url: ", match.getUrl() );
	 *                     
	 *                 case 'email' :
	 *                     console.log( "email: ", match.getEmail() );
	 *                     
	 *                 case 'twitter' :
	 *                     console.log( "twitter: ", match.getTwitterHandle() );
	 *             }
	 *         }
	 *     } );
	 *     
	 * See the {@link Autolinker} class for more details on using the {@link Autolinker#replaceFn replaceFn}.
	 */
	Autolinker.match.Match = Autolinker.Util.extend( Object, {

		/**
		 * @cfg {String} matchedText (required)
		 * 
		 * The original text that was matched.
		 */


		/**
		 * @constructor
		 * @param {Object} cfg The configuration properties for the Match instance, specified in an Object (map).
		 */
		constructor : function( cfg ) {
			Autolinker.Util.assign( this, cfg );
		},


		/**
		 * Returns a string name for the type of match that this class represents.
		 * 
		 * @abstract
		 * @return {String}
		 */
		getType : Autolinker.Util.abstractMethod,


		/**
		 * Returns the original text that was matched.
		 * 
		 * @return {String}
		 */
		getMatchedText : function() {
			return this.matchedText;
		},


		/**
		 * Returns the anchor href that should be generated for the match.
		 * 
		 * @abstract
		 * @return {String}
		 */
		getAnchorHref : Autolinker.Util.abstractMethod,


		/**
		 * Returns the anchor text that should be generated for the match.
		 * 
		 * @abstract
		 * @return {String}
		 */
		getAnchorText : Autolinker.Util.abstractMethod

	} );
	/*global Autolinker */
	/**
	 * @class Autolinker.match.Email
	 * @extends Autolinker.match.Match
	 * 
	 * Represents a Email match found in an input string which should be Autolinked.
	 * 
	 * See this class's superclass ({@link Autolinker.match.Match}) for more details.
	 */
	Autolinker.match.Email = Autolinker.Util.extend( Autolinker.match.Match, {

		/**
		 * @cfg {String} email (required)
		 * 
		 * The email address that was matched.
		 */


		/**
		 * Returns a string name for the type of match that this class represents.
		 * 
		 * @return {String}
		 */
		getType : function() {
			return 'email';
		},


		/**
		 * Returns the email address that was matched.
		 * 
		 * @return {String}
		 */
		getEmail : function() {
			return this.email;
		},


		/**
		 * Returns the anchor href that should be generated for the match.
		 * 
		 * @return {String}
		 */
		getAnchorHref : function() {
			return 'mailto:' + this.email;
		},


		/**
		 * Returns the anchor text that should be generated for the match.
		 * 
		 * @return {String}
		 */
		getAnchorText : function() {
			return this.email;
		}

	} );
	/*global Autolinker */
	/**
	 * @class Autolinker.match.Twitter
	 * @extends Autolinker.match.Match
	 * 
	 * Represents a Twitter match found in an input string which should be Autolinked.
	 * 
	 * See this class's superclass ({@link Autolinker.match.Match}) for more details.
	 */
	Autolinker.match.Twitter = Autolinker.Util.extend( Autolinker.match.Match, {

		/**
		 * @cfg {String} twitterHandle (required)
		 * 
		 * The Twitter handle that was matched.
		 */


		/**
		 * Returns the type of match that this class represents.
		 * 
		 * @return {String}
		 */
		getType : function() {
			return 'twitter';
		},


		/**
		 * Returns a string name for the type of match that this class represents.
		 * 
		 * @return {String}
		 */
		getTwitterHandle : function() {
			return this.twitterHandle;
		},


		/**
		 * Returns the anchor href that should be generated for the match.
		 * 
		 * @return {String}
		 */
		getAnchorHref : function() {
			return 'https://twitter.com/' + this.twitterHandle;
		},


		/**
		 * Returns the anchor text that should be generated for the match.
		 * 
		 * @return {String}
		 */
		getAnchorText : function() {
			return '@' + this.twitterHandle;
		}

	} );
	/*global Autolinker */
	/**
	 * @class Autolinker.match.Url
	 * @extends Autolinker.match.Match
	 * 
	 * Represents a Url match found in an input string which should be Autolinked.
	 * 
	 * See this class's superclass ({@link Autolinker.match.Match}) for more details.
	 */
	Autolinker.match.Url = Autolinker.Util.extend( Autolinker.match.Match, {

		/**
		 * @cfg {String} url (required)
		 * 
		 * The url that was matched.
		 */

		/**
		 * @cfg {Boolean} protocolUrlMatch (required)
		 * 
		 * `true` if the URL is a match which already has a protocol (i.e. 'http://'), `false` if the match was from a 'www' or
		 * known TLD match.
		 */

		/**
		 * @cfg {Boolean} protocolRelativeMatch (required)
		 * 
		 * `true` if the URL is a protocol-relative match. A protocol-relative match is a URL that starts with '//',
		 * and will be either http:// or https:// based on the protocol that the site is loaded under.
		 */

		/**
		 * @cfg {Boolean} stripPrefix (required)
		 * @inheritdoc Autolinker#stripPrefix
		 */


		/**
		 * @private
		 * @property {RegExp} urlPrefixRegex
		 * 
		 * A regular expression used to remove the 'http://' or 'https://' and/or the 'www.' from URLs.
		 */
		urlPrefixRegex: /^(https?:\/\/)?(www\.)?/i,

		/**
		 * @private
		 * @property {RegExp} protocolRelativeRegex
		 * 
		 * The regular expression used to remove the protocol-relative '//' from the {@link #url} string, for purposes
		 * of {@link #getAnchorText}. A protocol-relative URL is, for example, "//yahoo.com"
		 */
		protocolRelativeRegex : /^\/\//,

		/**
		 * @private
		 * @property {Boolean} protocolPrepended
		 * 
		 * Will be set to `true` if the 'http://' protocol has been prepended to the {@link #url} (because the
		 * {@link #url} did not have a protocol)
		 */
		protocolPrepended : false,


		/**
		 * Returns a string name for the type of match that this class represents.
		 * 
		 * @return {String}
		 */
		getType : function() {
			return 'url';
		},


		/**
		 * Returns the url that was matched, assuming the protocol to be 'http://' if the original
		 * match was missing a protocol.
		 * 
		 * @return {String}
		 */
		getUrl : function() {
			var url = this.url;

			// if the url string doesn't begin with a protocol, assume 'http://'
			if( !this.protocolRelativeMatch && !this.protocolUrlMatch && !this.protocolPrepended ) {
				url = this.url = 'http://' + url;

				this.protocolPrepended = true;
			}

			return url;
		},


		/**
		 * Returns the anchor href that should be generated for the match.
		 * 
		 * @return {String}
		 */
		getAnchorHref : function() {
			var url = this.getUrl();

			return url.replace( /&amp;/g, '&' );  // any &amp;'s in the URL should be converted back to '&' if they were displayed as &amp; in the source html 
		},


		/**
		 * Returns the anchor text that should be generated for the match.
		 * 
		 * @return {String}
		 */
		getAnchorText : function() {
			var anchorText = this.getUrl();

			if( this.protocolRelativeMatch ) {
				// Strip off any protocol-relative '//' from the anchor text
				anchorText = this.stripProtocolRelativePrefix( anchorText );
			}
			if( this.stripPrefix ) {
				anchorText = this.stripUrlPrefix( anchorText );
			}
			anchorText = this.removeTrailingSlash( anchorText );  // remove trailing slash, if there is one

			return anchorText;
		},


		// ---------------------------------------

		// Utility Functionality

		/**
		 * Strips the URL prefix (such as "http://" or "https://") from the given text.
		 * 
		 * @private
		 * @param {String} text The text of the anchor that is being generated, for which to strip off the
		 *   url prefix (such as stripping off "http://")
		 * @return {String} The `anchorText`, with the prefix stripped.
		 */
		stripUrlPrefix : function( text ) {
			return text.replace( this.urlPrefixRegex, '' );
		},


		/**
		 * Strips any protocol-relative '//' from the anchor text.
		 * 
		 * @private
		 * @param {String} text The text of the anchor that is being generated, for which to strip off the
		 *   protocol-relative prefix (such as stripping off "//")
		 * @return {String} The `anchorText`, with the protocol-relative prefix stripped.
		 */
		stripProtocolRelativePrefix : function( text ) {
			return text.replace( this.protocolRelativeRegex, '' );
		},


		/**
		 * Removes any trailing slash from the given `anchorText`, in preparation for the text to be displayed.
		 * 
		 * @private
		 * @param {String} anchorText The text of the anchor that is being generated, for which to remove any trailing
		 *   slash ('/') that may exist.
		 * @return {String} The `anchorText`, with the trailing slash removed.
		 */
		removeTrailingSlash : function( anchorText ) {
			if( anchorText.charAt( anchorText.length - 1 ) === '/' ) {
				anchorText = anchorText.slice( 0, -1 );
			}
			return anchorText;
		}

	} );

	return Autolinker;


}));

},{}],133:[function(require,module,exports){
//     Backbone.js 1.1.2

//     (c) 2010-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function(root, factory) {

  // Set up Backbone appropriately for the environment. Start with AMD.
  if (typeof define === 'function' && define.amd) {
    define(['underscore', 'jquery', 'exports'], function(_, $, exports) {
      // Export global even in AMD case in case this script is loaded with
      // others that may still expect a global Backbone.
      root.Backbone = factory(root, exports, _, $);
    });

  // Next for Node.js or CommonJS. jQuery may not be needed as a module.
  } else if (typeof exports !== 'undefined') {
    var _ = require('underscore');
    factory(root, exports, _);

  // Finally, as a browser global.
  } else {
    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));
  }

}(this, function(root, Backbone, _, $) {

  // Initial Setup
  // -------------

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;

  // Create local references to array methods we'll want to use later.
  var array = [];
  var push = array.push;
  var slice = array.slice;
  var splice = array.splice;

  // Current version of the library. Keep in sync with `package.json`.
  Backbone.VERSION = '1.1.2';

  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
  // the `$` variable.
  Backbone.$ = $;

  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.
  Backbone.noConflict = function() {
    root.Backbone = previousBackbone;
    return this;
  };

  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
  // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
  // set a `X-Http-Method-Override` header.
  Backbone.emulateHTTP = false;

  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
  // `application/json` requests ... will encode the body as
  // `application/x-www-form-urlencoded` instead and will send the model in a
  // form param named `model`.
  Backbone.emulateJSON = false;

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback
  // functions to an event; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  var Events = Backbone.Events = {

    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    on: function(name, callback, context) {
      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
      this._events || (this._events = {});
      var events = this._events[name] || (this._events[name] = []);
      events.push({callback: callback, context: context, ctx: context || this});
      return this;
    },

    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed.
    once: function(name, callback, context) {
      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
      var self = this;
      var once = _.once(function() {
        self.off(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
      return this.on(name, once, context);
    },

    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    off: function(name, callback, context) {
      var retain, ev, events, names, i, l, j, k;
      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
      if (!name && !callback && !context) {
        this._events = void 0;
        return this;
      }
      names = name ? [name] : _.keys(this._events);
      for (i = 0, l = names.length; i < l; i++) {
        name = names[i];
        if (events = this._events[name]) {
          this._events[name] = retain = [];
          if (callback || context) {
            for (j = 0, k = events.length; j < k; j++) {
              ev = events[j];
              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                  (context && context !== ev.context)) {
                retain.push(ev);
              }
            }
          }
          if (!retain.length) delete this._events[name];
        }
      }

      return this;
    },

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function(name) {
      if (!this._events) return this;
      var args = slice.call(arguments, 1);
      if (!eventsApi(this, 'trigger', name, args)) return this;
      var events = this._events[name];
      var allEvents = this._events.all;
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, arguments);
      return this;
    },

    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    stopListening: function(obj, name, callback) {
      var listeningTo = this._listeningTo;
      if (!listeningTo) return this;
      var remove = !name && !callback;
      if (!callback && typeof name === 'object') callback = this;
      if (obj) (listeningTo = {})[obj._listenId] = obj;
      for (var id in listeningTo) {
        obj = listeningTo[id];
        obj.off(name, callback, this);
        if (remove || _.isEmpty(obj._events)) delete this._listeningTo[id];
      }
      return this;
    }

  };

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Implement fancy features of the Events API such as multiple event
  // names `"change blur"` and jQuery-style event maps `{change: action}`
  // in terms of the existing API.
  var eventsApi = function(obj, action, name, rest) {
    if (!name) return true;

    // Handle event maps.
    if (typeof name === 'object') {
      for (var key in name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
      return false;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter);
      for (var i = 0, l = names.length; i < l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
      return false;
    }

    return true;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;
    }
  };

  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
  // listen to an event in another object ... keeping track of what it's
  // listening to.
  _.each(listenMethods, function(implementation, method) {
    Events[method] = function(obj, name, callback) {
      var listeningTo = this._listeningTo || (this._listeningTo = {});
      var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
      listeningTo[id] = obj;
      if (!callback && typeof name === 'object') callback = this;
      obj[implementation](name, callback, this);
      return this;
    };
  });

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Allow the `Backbone` object to serve as a global event bus, for folks who
  // want global "pubsub" in a convenient place.
  _.extend(Backbone, Events);

  // Backbone.Model
  // --------------

  // Backbone **Models** are the basic data object in the framework --
  // frequently representing a row in a table in a database on your server.
  // A discrete chunk of data and a bunch of useful, related methods for
  // performing computations and transformations on that data.

  // Create a new model with the specified attributes. A client id (`cid`)
  // is automatically generated and assigned for you.
  var Model = Backbone.Model = function(attributes, options) {
    var attrs = attributes || {};
    options || (options = {});
    this.cid = _.uniqueId('c');
    this.attributes = {};
    if (options.collection) this.collection = options.collection;
    if (options.parse) attrs = this.parse(attrs, options) || {};
    attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
    this.set(attrs, options);
    this.changed = {};
    this.initialize.apply(this, arguments);
  };

  // Attach all inheritable methods to the Model prototype.
  _.extend(Model.prototype, Events, {

    // A hash of attributes whose current and previous value differ.
    changed: null,

    // The value returned during the last failed validation.
    validationError: null,

    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
    // CouchDB users may want to set this to `"_id"`.
    idAttribute: 'id',

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Return a copy of the model's `attributes` object.
    toJSON: function(options) {
      return _.clone(this.attributes);
    },

    // Proxy `Backbone.sync` by default -- but override this if you need
    // custom syncing semantics for *this* particular model.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Get the value of an attribute.
    get: function(attr) {
      return this.attributes[attr];
    },

    // Get the HTML-escaped value of an attribute.
    escape: function(attr) {
      return _.escape(this.get(attr));
    },

    // Returns `true` if the attribute contains a value that is not null
    // or undefined.
    has: function(attr) {
      return this.get(attr) != null;
    },

    // Set a hash of model attributes on the object, firing `"change"`. This is
    // the core primitive operation of a model, updating the data and notifying
    // anyone who needs to know about the change in state. The heart of the beast.
    set: function(key, val, options) {
      var attr, attrs, unset, changes, silent, changing, prev, current;
      if (key == null) return this;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options || (options = {});

      // Run validation.
      if (!this._validate(attrs, options)) return false;

      // Extract attributes and options.
      unset           = options.unset;
      silent          = options.silent;
      changes         = [];
      changing        = this._changing;
      this._changing  = true;

      if (!changing) {
        this._previousAttributes = _.clone(this.attributes);
        this.changed = {};
      }
      current = this.attributes, prev = this._previousAttributes;

      // Check for changes of `id`.
      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

      // For each `set` attribute, update or delete the current value.
      for (attr in attrs) {
        val = attrs[attr];
        if (!_.isEqual(current[attr], val)) changes.push(attr);
        if (!_.isEqual(prev[attr], val)) {
          this.changed[attr] = val;
        } else {
          delete this.changed[attr];
        }
        unset ? delete current[attr] : current[attr] = val;
      }

      // Trigger all relevant attribute changes.
      if (!silent) {
        if (changes.length) this._pending = options;
        for (var i = 0, l = changes.length; i < l; i++) {
          this.trigger('change:' + changes[i], this, current[changes[i]], options);
        }
      }

      // You might be wondering why there's a `while` loop here. Changes can
      // be recursively nested within `"change"` events.
      if (changing) return this;
      if (!silent) {
        while (this._pending) {
          options = this._pending;
          this._pending = false;
          this.trigger('change', this, options);
        }
      }
      this._pending = false;
      this._changing = false;
      return this;
    },

    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
    // if the attribute doesn't exist.
    unset: function(attr, options) {
      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
    },

    // Clear all attributes on the model, firing `"change"`.
    clear: function(options) {
      var attrs = {};
      for (var key in this.attributes) attrs[key] = void 0;
      return this.set(attrs, _.extend({}, options, {unset: true}));
    },

    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
    hasChanged: function(attr) {
      if (attr == null) return !_.isEmpty(this.changed);
      return _.has(this.changed, attr);
    },

    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function(diff) {
      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
      var val, changed = false;
      var old = this._changing ? this._previousAttributes : this.attributes;
      for (var attr in diff) {
        if (_.isEqual(old[attr], (val = diff[attr]))) continue;
        (changed || (changed = {}))[attr] = val;
      }
      return changed;
    },

    // Get the previous value of an attribute, recorded at the time the last
    // `"change"` event was fired.
    previous: function(attr) {
      if (attr == null || !this._previousAttributes) return null;
      return this._previousAttributes[attr];
    },

    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
    previousAttributes: function() {
      return _.clone(this._previousAttributes);
    },

    // Fetch the model from the server. If the server's representation of the
    // model differs from its current attributes, they will be overridden,
    // triggering a `"change"` event.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        if (!model.set(model.parse(resp, options), options)) return false;
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function(key, val, options) {
      var attrs, method, xhr, attributes = this.attributes;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (key == null || typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options = _.extend({validate: true}, options);

      // If we're not waiting and attributes exist, save acts as
      // `set(attr).save(null, opts)` with validation. Otherwise, check if
      // the model will be valid when the attributes, if any, are set.
      if (attrs && !options.wait) {
        if (!this.set(attrs, options)) return false;
      } else {
        if (!this._validate(attrs, options)) return false;
      }

      // Set temporary attributes if `{wait: true}`.
      if (attrs && options.wait) {
        this.attributes = _.extend({}, attributes, attrs);
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        // Ensure attributes are restored during synchronous saves.
        model.attributes = attributes;
        var serverAttrs = model.parse(resp, options);
        if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
        if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
          return false;
        }
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);

      method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
      if (method === 'patch') options.attrs = attrs;
      xhr = this.sync(method, this, options);

      // Restore attributes.
      if (attrs && options.wait) this.attributes = attributes;

      return xhr;
    },

    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;

      var destroy = function() {
        model.trigger('destroy', model, model.collection, options);
      };

      options.success = function(resp) {
        if (options.wait || model.isNew()) destroy();
        if (success) success(model, resp, options);
        if (!model.isNew()) model.trigger('sync', model, resp, options);
      };

      if (this.isNew()) {
        options.success();
        return false;
      }
      wrapError(this, options);

      var xhr = this.sync('delete', this, options);
      if (!options.wait) destroy();
      return xhr;
    },

    // Default URL for the model's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function() {
      var base =
        _.result(this, 'urlRoot') ||
        _.result(this.collection, 'url') ||
        urlError();
      if (this.isNew()) return base;
      return base.replace(/([^\/])$/, '$1/') + encodeURIComponent(this.id);
    },

    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new model with identical attributes to this one.
    clone: function() {
      return new this.constructor(this.attributes);
    },

    // A model is new if it has never been saved to the server, and lacks an id.
    isNew: function() {
      return !this.has(this.idAttribute);
    },

    // Check if the model is currently in a valid state.
    isValid: function(options) {
      return this._validate({}, _.extend(options || {}, { validate: true }));
    },

    // Run validation against the next complete set of model attributes,
    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
    _validate: function(attrs, options) {
      if (!options.validate || !this.validate) return true;
      attrs = _.extend({}, this.attributes, attrs);
      var error = this.validationError = this.validate(attrs, options) || null;
      if (!error) return true;
      this.trigger('invalid', this, error, _.extend(options, {validationError: error}));
      return false;
    }

  });

  // Underscore methods that we want to implement on the Model.
  var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];

  // Mix in each Underscore method as a proxy to `Model#attributes`.
  _.each(modelMethods, function(method) {
    Model.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.attributes);
      return _[method].apply(_, args);
    };
  });

  // Backbone.Collection
  // -------------------

  // If models tend to represent a single row of data, a Backbone Collection is
  // more analagous to a table full of data ... or a small slice or page of that
  // table, or a collection of rows that belong together for a particular reason
  // -- all of the messages in this particular folder, all of the documents
  // belonging to this particular author, and so on. Collections maintain
  // indexes of their models, both in order, and for lookup by `id`.

  // Create a new **Collection**, perhaps to contain a specific type of `model`.
  // If a `comparator` is specified, the Collection will maintain
  // its models in sort order, as they're added and removed.
  var Collection = Backbone.Collection = function(models, options) {
    options || (options = {});
    if (options.model) this.model = options.model;
    if (options.comparator !== void 0) this.comparator = options.comparator;
    this._reset();
    this.initialize.apply(this, arguments);
    if (models) this.reset(models, _.extend({silent: true}, options));
  };

  // Default options for `Collection#set`.
  var setOptions = {add: true, remove: true, merge: true};
  var addOptions = {add: true, remove: false};

  // Define the Collection's inheritable methods.
  _.extend(Collection.prototype, Events, {

    // The default model for a collection is just a **Backbone.Model**.
    // This should be overridden in most cases.
    model: Model,

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // The JSON representation of a Collection is an array of the
    // models' attributes.
    toJSON: function(options) {
      return this.map(function(model){ return model.toJSON(options); });
    },

    // Proxy `Backbone.sync` by default.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Add a model, or list of models to the set.
    add: function(models, options) {
      return this.set(models, _.extend({merge: false}, options, addOptions));
    },

    // Remove a model, or a list of models from the set.
    remove: function(models, options) {
      var singular = !_.isArray(models);
      models = singular ? [models] : _.clone(models);
      options || (options = {});
      var i, l, index, model;
      for (i = 0, l = models.length; i < l; i++) {
        model = models[i] = this.get(models[i]);
        if (!model) continue;
        delete this._byId[model.id];
        delete this._byId[model.cid];
        index = this.indexOf(model);
        this.models.splice(index, 1);
        this.length--;
        if (!options.silent) {
          options.index = index;
          model.trigger('remove', model, this, options);
        }
        this._removeReference(model, options);
      }
      return singular ? models[0] : models;
    },

    // Update a collection by `set`-ing a new list of models, adding new ones,
    // removing models that are no longer present, and merging models that
    // already exist in the collection, as necessary. Similar to **Model#set**,
    // the core operation for updating the data contained by the collection.
    set: function(models, options) {
      options = _.defaults({}, options, setOptions);
      if (options.parse) models = this.parse(models, options);
      var singular = !_.isArray(models);
      models = singular ? (models ? [models] : []) : _.clone(models);
      var i, l, id, model, attrs, existing, sort;
      var at = options.at;
      var targetModel = this.model;
      var sortable = this.comparator && (at == null) && options.sort !== false;
      var sortAttr = _.isString(this.comparator) ? this.comparator : null;
      var toAdd = [], toRemove = [], modelMap = {};
      var add = options.add, merge = options.merge, remove = options.remove;
      var order = !sortable && add && remove ? [] : false;

      // Turn bare objects into model references, and prevent invalid models
      // from being added.
      for (i = 0, l = models.length; i < l; i++) {
        attrs = models[i] || {};
        if (attrs instanceof Model) {
          id = model = attrs;
        } else {
          id = attrs[targetModel.prototype.idAttribute || 'id'];
        }

        // If a duplicate is found, prevent it from being added and
        // optionally merge it into the existing model.
        if (existing = this.get(id)) {
          if (remove) modelMap[existing.cid] = true;
          if (merge) {
            attrs = attrs === model ? model.attributes : attrs;
            if (options.parse) attrs = existing.parse(attrs, options);
            existing.set(attrs, options);
            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
          }
          models[i] = existing;

        // If this is a new, valid model, push it to the `toAdd` list.
        } else if (add) {
          model = models[i] = this._prepareModel(attrs, options);
          if (!model) continue;
          toAdd.push(model);
          this._addReference(model, options);
        }

        // Do not add multiple models with the same `id`.
        model = existing || model;
        if (order && (model.isNew() || !modelMap[model.id])) order.push(model);
        modelMap[model.id] = true;
      }

      // Remove nonexistent models if appropriate.
      if (remove) {
        for (i = 0, l = this.length; i < l; ++i) {
          if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
        }
        if (toRemove.length) this.remove(toRemove, options);
      }

      // See if sorting is needed, update `length` and splice in new models.
      if (toAdd.length || (order && order.length)) {
        if (sortable) sort = true;
        this.length += toAdd.length;
        if (at != null) {
          for (i = 0, l = toAdd.length; i < l; i++) {
            this.models.splice(at + i, 0, toAdd[i]);
          }
        } else {
          if (order) this.models.length = 0;
          var orderedModels = order || toAdd;
          for (i = 0, l = orderedModels.length; i < l; i++) {
            this.models.push(orderedModels[i]);
          }
        }
      }

      // Silently sort the collection if appropriate.
      if (sort) this.sort({silent: true});

      // Unless silenced, it's time to fire all appropriate add/sort events.
      if (!options.silent) {
        for (i = 0, l = toAdd.length; i < l; i++) {
          (model = toAdd[i]).trigger('add', model, this, options);
        }
        if (sort || (order && order.length)) this.trigger('sort', this, options);
      }

      // Return the added (or merged) model (or models).
      return singular ? models[0] : models;
    },

    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any granular `add` or `remove` events. Fires `reset` when finished.
    // Useful for bulk operations and optimizations.
    reset: function(models, options) {
      options || (options = {});
      for (var i = 0, l = this.models.length; i < l; i++) {
        this._removeReference(this.models[i], options);
      }
      options.previousModels = this.models;
      this._reset();
      models = this.add(models, _.extend({silent: true}, options));
      if (!options.silent) this.trigger('reset', this, options);
      return models;
    },

    // Add a model to the end of the collection.
    push: function(model, options) {
      return this.add(model, _.extend({at: this.length}, options));
    },

    // Remove a model from the end of the collection.
    pop: function(options) {
      var model = this.at(this.length - 1);
      this.remove(model, options);
      return model;
    },

    // Add a model to the beginning of the collection.
    unshift: function(model, options) {
      return this.add(model, _.extend({at: 0}, options));
    },

    // Remove a model from the beginning of the collection.
    shift: function(options) {
      var model = this.at(0);
      this.remove(model, options);
      return model;
    },

    // Slice out a sub-array of models from the collection.
    slice: function() {
      return slice.apply(this.models, arguments);
    },

    // Get a model from the set by id.
    get: function(obj) {
      if (obj == null) return void 0;
      return this._byId[obj] || this._byId[obj.id] || this._byId[obj.cid];
    },

    // Get the model at the given index.
    at: function(index) {
      return this.models[index];
    },

    // Return models with matching attributes. Useful for simple cases of
    // `filter`.
    where: function(attrs, first) {
      if (_.isEmpty(attrs)) return first ? void 0 : [];
      return this[first ? 'find' : 'filter'](function(model) {
        for (var key in attrs) {
          if (attrs[key] !== model.get(key)) return false;
        }
        return true;
      });
    },

    // Return the first model with matching attributes. Useful for simple cases
    // of `find`.
    findWhere: function(attrs) {
      return this.where(attrs, true);
    },

    // Force the collection to re-sort itself. You don't need to call this under
    // normal circumstances, as the set will maintain sort order as each item
    // is added.
    sort: function(options) {
      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
      options || (options = {});

      // Run sort based on type of `comparator`.
      if (_.isString(this.comparator) || this.comparator.length === 1) {
        this.models = this.sortBy(this.comparator, this);
      } else {
        this.models.sort(_.bind(this.comparator, this));
      }

      if (!options.silent) this.trigger('sort', this, options);
      return this;
    },

    // Pluck an attribute from each model in the collection.
    pluck: function(attr) {
      return _.invoke(this.models, 'get', attr);
    },

    // Fetch the default set of models for this collection, resetting the
    // collection when they arrive. If `reset: true` is passed, the response
    // data will be passed through the `reset` method instead of `set`.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var success = options.success;
      var collection = this;
      options.success = function(resp) {
        var method = options.reset ? 'reset' : 'set';
        collection[method](resp, options);
        if (success) success(collection, resp, options);
        collection.trigger('sync', collection, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Create a new instance of a model in this collection. Add the model to the
    // collection immediately, unless `wait: true` is passed, in which case we
    // wait for the server to agree.
    create: function(model, options) {
      options = options ? _.clone(options) : {};
      if (!(model = this._prepareModel(model, options))) return false;
      if (!options.wait) this.add(model, options);
      var collection = this;
      var success = options.success;
      options.success = function(model, resp) {
        if (options.wait) collection.add(model, options);
        if (success) success(model, resp, options);
      };
      model.save(null, options);
      return model;
    },

    // **parse** converts a response into a list of models to be added to the
    // collection. The default implementation is just to pass it through.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new collection with an identical list of models as this one.
    clone: function() {
      return new this.constructor(this.models);
    },

    // Private method to reset all internal state. Called when the collection
    // is first initialized or reset.
    _reset: function() {
      this.length = 0;
      this.models = [];
      this._byId  = {};
    },

    // Prepare a hash of attributes (or other model) to be added to this
    // collection.
    _prepareModel: function(attrs, options) {
      if (attrs instanceof Model) return attrs;
      options = options ? _.clone(options) : {};
      options.collection = this;
      var model = new this.model(attrs, options);
      if (!model.validationError) return model;
      this.trigger('invalid', this, model.validationError, options);
      return false;
    },

    // Internal method to create a model's ties to a collection.
    _addReference: function(model, options) {
      this._byId[model.cid] = model;
      if (model.id != null) this._byId[model.id] = model;
      if (!model.collection) model.collection = this;
      model.on('all', this._onModelEvent, this);
    },

    // Internal method to sever a model's ties to a collection.
    _removeReference: function(model, options) {
      if (this === model.collection) delete model.collection;
      model.off('all', this._onModelEvent, this);
    },

    // Internal method called every time a model in the set fires an event.
    // Sets need to update their indexes when models change ids. All other
    // events simply proxy through. "add" and "remove" events that originate
    // in other collections are ignored.
    _onModelEvent: function(event, model, collection, options) {
      if ((event === 'add' || event === 'remove') && collection !== this) return;
      if (event === 'destroy') this.remove(model, options);
      if (model && event === 'change:' + model.idAttribute) {
        delete this._byId[model.previous(model.idAttribute)];
        if (model.id != null) this._byId[model.id] = model;
      }
      this.trigger.apply(this, arguments);
    }

  });

  // Underscore methods that we want to implement on the Collection.
  // 90% of the core usefulness of Backbone Collections is actually implemented
  // right here:
  var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',
    'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',
    'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',
    'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',
    'tail', 'drop', 'last', 'without', 'difference', 'indexOf', 'shuffle',
    'lastIndexOf', 'isEmpty', 'chain', 'sample'];

  // Mix in each Underscore method as a proxy to `Collection#models`.
  _.each(methods, function(method) {
    Collection.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.models);
      return _[method].apply(_, args);
    };
  });

  // Underscore methods that take a property name as an argument.
  var attributeMethods = ['groupBy', 'countBy', 'sortBy', 'indexBy'];

  // Use attributes instead of properties.
  _.each(attributeMethods, function(method) {
    Collection.prototype[method] = function(value, context) {
      var iterator = _.isFunction(value) ? value : function(model) {
        return model.get(value);
      };
      return _[method](this.models, iterator, context);
    };
  });

  // Backbone.View
  // -------------

  // Backbone Views are almost more convention than they are actual code. A View
  // is simply a JavaScript object that represents a logical chunk of UI in the
  // DOM. This might be a single item, an entire list, a sidebar or panel, or
  // even the surrounding frame which wraps your whole app. Defining a chunk of
  // UI as a **View** allows you to define your DOM events declaratively, without
  // having to worry about render order ... and makes it easy for the view to
  // react to specific changes in the state of your models.

  // Creating a Backbone.View creates its initial element outside of the DOM,
  // if an existing element is not provided...
  var View = Backbone.View = function(options) {
    this.cid = _.uniqueId('view');
    options || (options = {});
    _.extend(this, _.pick(options, viewOptions));
    this._ensureElement();
    this.initialize.apply(this, arguments);
    this.delegateEvents();
  };

  // Cached regex to split keys for `delegate`.
  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

  // List of view options to be merged as properties.
  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

  // Set up all inheritable **Backbone.View** properties and methods.
  _.extend(View.prototype, Events, {

    // The default `tagName` of a View's element is `"div"`.
    tagName: 'div',

    // jQuery delegate for element lookup, scoped to DOM elements within the
    // current view. This should be preferred to global lookups where possible.
    $: function(selector) {
      return this.$el.find(selector);
    },

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // **render** is the core function that your view should override, in order
    // to populate its element (`this.el`), with the appropriate HTML. The
    // convention is for **render** to always return `this`.
    render: function() {
      return this;
    },

    // Remove this view by taking the element out of the DOM, and removing any
    // applicable Backbone.Events listeners.
    remove: function() {
      this.$el.remove();
      this.stopListening();
      return this;
    },

    // Change the view's element (`this.el` property), including event
    // re-delegation.
    setElement: function(element, delegate) {
      if (this.$el) this.undelegateEvents();
      this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
      this.el = this.$el[0];
      if (delegate !== false) this.delegateEvents();
      return this;
    },

    // Set callbacks, where `this.events` is a hash of
    //
    // *{"event selector": "callback"}*
    //
    //     {
    //       'mousedown .title':  'edit',
    //       'click .button':     'save',
    //       'click .open':       function(e) { ... }
    //     }
    //
    // pairs. Callbacks will be bound to the view, with `this` set properly.
    // Uses event delegation for efficiency.
    // Omitting the selector binds the event to `this.el`.
    // This only works for delegate-able events: not `focus`, `blur`, and
    // not `change`, `submit`, and `reset` in Internet Explorer.
    delegateEvents: function(events) {
      if (!(events || (events = _.result(this, 'events')))) return this;
      this.undelegateEvents();
      for (var key in events) {
        var method = events[key];
        if (!_.isFunction(method)) method = this[events[key]];
        if (!method) continue;

        var match = key.match(delegateEventSplitter);
        var eventName = match[1], selector = match[2];
        method = _.bind(method, this);
        eventName += '.delegateEvents' + this.cid;
        if (selector === '') {
          this.$el.on(eventName, method);
        } else {
          this.$el.on(eventName, selector, method);
        }
      }
      return this;
    },

    // Clears all callbacks previously bound to the view with `delegateEvents`.
    // You usually don't need to use this, but may wish to if you have multiple
    // Backbone views attached to the same DOM element.
    undelegateEvents: function() {
      this.$el.off('.delegateEvents' + this.cid);
      return this;
    },

    // Ensure that the View has a DOM element to render into.
    // If `this.el` is a string, pass it through `$()`, take the first
    // matching element, and re-assign it to `el`. Otherwise, create
    // an element from the `id`, `className` and `tagName` properties.
    _ensureElement: function() {
      if (!this.el) {
        var attrs = _.extend({}, _.result(this, 'attributes'));
        if (this.id) attrs.id = _.result(this, 'id');
        if (this.className) attrs['class'] = _.result(this, 'className');
        var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);
        this.setElement($el, false);
      } else {
        this.setElement(_.result(this, 'el'), false);
      }
    }

  });

  // Backbone.sync
  // -------------

  // Override this function to change the manner in which Backbone persists
  // models to the server. You will be passed the type of request, and the
  // model in question. By default, makes a RESTful Ajax request
  // to the model's `url()`. Some possible customizations could be:
  //
  // * Use `setTimeout` to batch rapid-fire updates into a single request.
  // * Send up the models as XML instead of JSON.
  // * Persist models via WebSockets instead of Ajax.
  //
  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
  // as `POST`, with a `_method` parameter containing the true HTTP method,
  // as well as all requests with the body as `application/x-www-form-urlencoded`
  // instead of `application/json` with the model in a param named `model`.
  // Useful when interfacing with server-side languages like **PHP** that make
  // it difficult to read the body of `PUT` requests.
  Backbone.sync = function(method, model, options) {
    var type = methodMap[method];

    // Default options, unless specified.
    _.defaults(options || (options = {}), {
      emulateHTTP: Backbone.emulateHTTP,
      emulateJSON: Backbone.emulateJSON
    });

    // Default JSON-request options.
    var params = {type: type, dataType: 'json'};

    // Ensure that we have a URL.
    if (!options.url) {
      params.url = _.result(model, 'url') || urlError();
    }

    // Ensure that we have the appropriate request data.
    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(options.attrs || model.toJSON(options));
    }

    // For older servers, emulate JSON by encoding the request into an HTML-form.
    if (options.emulateJSON) {
      params.contentType = 'application/x-www-form-urlencoded';
      params.data = params.data ? {model: params.data} : {};
    }

    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
    // And an `X-HTTP-Method-Override` header.
    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
      params.type = 'POST';
      if (options.emulateJSON) params.data._method = type;
      var beforeSend = options.beforeSend;
      options.beforeSend = function(xhr) {
        xhr.setRequestHeader('X-HTTP-Method-Override', type);
        if (beforeSend) return beforeSend.apply(this, arguments);
      };
    }

    // Don't process data on a non-GET request.
    if (params.type !== 'GET' && !options.emulateJSON) {
      params.processData = false;
    }

    // If we're sending a `PATCH` request, and we're in an old Internet Explorer
    // that still has ActiveX enabled by default, override jQuery to use that
    // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.
    if (params.type === 'PATCH' && noXhrPatch) {
      params.xhr = function() {
        return new ActiveXObject("Microsoft.XMLHTTP");
      };
    }

    // Make the request, allowing the user to override any Ajax options.
    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
    model.trigger('request', model, xhr, options);
    return xhr;
  };

  var noXhrPatch =
    typeof window !== 'undefined' && !!window.ActiveXObject &&
      !(window.XMLHttpRequest && (new XMLHttpRequest).dispatchEvent);

  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'patch':  'PATCH',
    'delete': 'DELETE',
    'read':   'GET'
  };

  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
  // Override this if you'd like to use a different library.
  Backbone.ajax = function() {
    return Backbone.$.ajax.apply(Backbone.$, arguments);
  };

  // Backbone.Router
  // ---------------

  // Routers map faux-URLs to actions, and fire events when routes are
  // matched. Creating a new one sets its `routes` hash, if not set statically.
  var Router = Backbone.Router = function(options) {
    options || (options = {});
    if (options.routes) this.routes = options.routes;
    this._bindRoutes();
    this.initialize.apply(this, arguments);
  };

  // Cached regular expressions for matching named param parts and splatted
  // parts of route strings.
  var optionalParam = /\((.*?)\)/g;
  var namedParam    = /(\(\?)?:\w+/g;
  var splatParam    = /\*\w+/g;
  var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

  // Set up all inheritable **Backbone.Router** properties and methods.
  _.extend(Router.prototype, Events, {

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Manually bind a single named route to a callback. For example:
    //
    //     this.route('search/:query/p:num', 'search', function(query, num) {
    //       ...
    //     });
    //
    route: function(route, name, callback) {
      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
      if (_.isFunction(name)) {
        callback = name;
        name = '';
      }
      if (!callback) callback = this[name];
      var router = this;
      Backbone.history.route(route, function(fragment) {
        var args = router._extractParameters(route, fragment);
        router.execute(callback, args);
        router.trigger.apply(router, ['route:' + name].concat(args));
        router.trigger('route', name, args);
        Backbone.history.trigger('route', router, name, args);
      });
      return this;
    },

    // Execute a route handler with the provided parameters.  This is an
    // excellent place to do pre-route setup or post-route cleanup.
    execute: function(callback, args) {
      if (callback) callback.apply(this, args);
    },

    // Simple proxy to `Backbone.history` to save a fragment into the history.
    navigate: function(fragment, options) {
      Backbone.history.navigate(fragment, options);
      return this;
    },

    // Bind all defined routes to `Backbone.history`. We have to reverse the
    // order of the routes here to support behavior where the most general
    // routes can be defined at the bottom of the route map.
    _bindRoutes: function() {
      if (!this.routes) return;
      this.routes = _.result(this, 'routes');
      var route, routes = _.keys(this.routes);
      while ((route = routes.pop()) != null) {
        this.route(route, this.routes[route]);
      }
    },

    // Convert a route string into a regular expression, suitable for matching
    // against the current location hash.
    _routeToRegExp: function(route) {
      route = route.replace(escapeRegExp, '\\$&')
                   .replace(optionalParam, '(?:$1)?')
                   .replace(namedParam, function(match, optional) {
                     return optional ? match : '([^/?]+)';
                   })
                   .replace(splatParam, '([^?]*?)');
      return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
    },

    // Given a route, and a URL fragment that it matches, return the array of
    // extracted decoded parameters. Empty or unmatched parameters will be
    // treated as `null` to normalize cross-browser behavior.
    _extractParameters: function(route, fragment) {
      var params = route.exec(fragment).slice(1);
      return _.map(params, function(param, i) {
        // Don't decode the search params.
        if (i === params.length - 1) return param || null;
        return param ? decodeURIComponent(param) : null;
      });
    }

  });

  // Backbone.History
  // ----------------

  // Handles cross-browser history management, based on either
  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
  // and URL fragments. If the browser supports neither (old IE, natch),
  // falls back to polling.
  var History = Backbone.History = function() {
    this.handlers = [];
    _.bindAll(this, 'checkUrl');

    // Ensure that `History` can be used outside of the browser.
    if (typeof window !== 'undefined') {
      this.location = window.location;
      this.history = window.history;
    }
  };

  // Cached regex for stripping a leading hash/slash and trailing space.
  var routeStripper = /^[#\/]|\s+$/g;

  // Cached regex for stripping leading and trailing slashes.
  var rootStripper = /^\/+|\/+$/g;

  // Cached regex for detecting MSIE.
  var isExplorer = /msie [\w.]+/;

  // Cached regex for removing a trailing slash.
  var trailingSlash = /\/$/;

  // Cached regex for stripping urls of hash.
  var pathStripper = /#.*$/;

  // Has the history handling already been started?
  History.started = false;

  // Set up all inheritable **Backbone.History** properties and methods.
  _.extend(History.prototype, Events, {

    // The default interval to poll for hash changes, if necessary, is
    // twenty times a second.
    interval: 50,

    // Are we at the app root?
    atRoot: function() {
      return this.location.pathname.replace(/[^\/]$/, '$&/') === this.root;
    },

    // Gets the true hash value. Cannot use location.hash directly due to bug
    // in Firefox where location.hash will always be decoded.
    getHash: function(window) {
      var match = (window || this).location.href.match(/#(.*)$/);
      return match ? match[1] : '';
    },

    // Get the cross-browser normalized URL fragment, either from the URL,
    // the hash, or the override.
    getFragment: function(fragment, forcePushState) {
      if (fragment == null) {
        if (this._hasPushState || !this._wantsHashChange || forcePushState) {
          fragment = decodeURI(this.location.pathname + this.location.search);
          var root = this.root.replace(trailingSlash, '');
          if (!fragment.indexOf(root)) fragment = fragment.slice(root.length);
        } else {
          fragment = this.getHash();
        }
      }
      return fragment.replace(routeStripper, '');
    },

    // Start the hash change handling, returning `true` if the current URL matches
    // an existing route, and `false` otherwise.
    start: function(options) {
      if (History.started) throw new Error("Backbone.history has already been started");
      History.started = true;

      // Figure out the initial configuration. Do we need an iframe?
      // Is pushState desired ... is it available?
      this.options          = _.extend({root: '/'}, this.options, options);
      this.root             = this.options.root;
      this._wantsHashChange = this.options.hashChange !== false;
      this._wantsPushState  = !!this.options.pushState;
      this._hasPushState    = !!(this.options.pushState && this.history && this.history.pushState);
      var fragment          = this.getFragment();
      var docMode           = document.documentMode;
      var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));

      // Normalize root to always include a leading and trailing slash.
      this.root = ('/' + this.root + '/').replace(rootStripper, '/');

      if (oldIE && this._wantsHashChange) {
        var frame = Backbone.$('<iframe src="javascript:0" tabindex="-1">');
        this.iframe = frame.hide().appendTo('body')[0].contentWindow;
        this.navigate(fragment);
      }

      // Depending on whether we're using pushState or hashes, and whether
      // 'onhashchange' is supported, determine how we check the URL state.
      if (this._hasPushState) {
        Backbone.$(window).on('popstate', this.checkUrl);
      } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {
        Backbone.$(window).on('hashchange', this.checkUrl);
      } else if (this._wantsHashChange) {
        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
      }

      // Determine if we need to change the base url, for a pushState link
      // opened by a non-pushState browser.
      this.fragment = fragment;
      var loc = this.location;

      // Transition from hashChange to pushState or vice versa if both are
      // requested.
      if (this._wantsHashChange && this._wantsPushState) {

        // If we've started off with a route from a `pushState`-enabled
        // browser, but we're currently in a browser that doesn't support it...
        if (!this._hasPushState && !this.atRoot()) {
          this.fragment = this.getFragment(null, true);
          this.location.replace(this.root + '#' + this.fragment);
          // Return immediately as browser will do redirect to new url
          return true;

        // Or if we've started out with a hash-based route, but we're currently
        // in a browser where it could be `pushState`-based instead...
        } else if (this._hasPushState && this.atRoot() && loc.hash) {
          this.fragment = this.getHash().replace(routeStripper, '');
          this.history.replaceState({}, document.title, this.root + this.fragment);
        }

      }

      if (!this.options.silent) return this.loadUrl();
    },

    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
    // but possibly useful for unit testing Routers.
    stop: function() {
      Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);
      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);
      History.started = false;
    },

    // Add a route to be tested when the fragment changes. Routes added later
    // may override previous routes.
    route: function(route, callback) {
      this.handlers.unshift({route: route, callback: callback});
    },

    // Checks the current URL to see if it has changed, and if it has,
    // calls `loadUrl`, normalizing across the hidden iframe.
    checkUrl: function(e) {
      var current = this.getFragment();
      if (current === this.fragment && this.iframe) {
        current = this.getFragment(this.getHash(this.iframe));
      }
      if (current === this.fragment) return false;
      if (this.iframe) this.navigate(current);
      this.loadUrl();
    },

    // Attempt to load the current URL fragment. If a route succeeds with a
    // match, returns `true`. If no defined routes matches the fragment,
    // returns `false`.
    loadUrl: function(fragment) {
      fragment = this.fragment = this.getFragment(fragment);
      return _.any(this.handlers, function(handler) {
        if (handler.route.test(fragment)) {
          handler.callback(fragment);
          return true;
        }
      });
    },

    // Save a fragment into the hash history, or replace the URL state if the
    // 'replace' option is passed. You are responsible for properly URL-encoding
    // the fragment in advance.
    //
    // The options object can contain `trigger: true` if you wish to have the
    // route callback be fired (not usually desirable), or `replace: true`, if
    // you wish to modify the current URL without adding an entry to the history.
    navigate: function(fragment, options) {
      if (!History.started) return false;
      if (!options || options === true) options = {trigger: !!options};

      var url = this.root + (fragment = this.getFragment(fragment || ''));

      // Strip the hash for matching.
      fragment = fragment.replace(pathStripper, '');

      if (this.fragment === fragment) return;
      this.fragment = fragment;

      // Don't include a trailing slash on the root.
      if (fragment === '' && url !== '/') url = url.slice(0, -1);

      // If pushState is available, we use it to set the fragment as a real URL.
      if (this._hasPushState) {
        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

      // If hash changes haven't been explicitly disabled, update the hash
      // fragment to store history.
      } else if (this._wantsHashChange) {
        this._updateHash(this.location, fragment, options.replace);
        if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {
          // Opening and closing the iframe tricks IE7 and earlier to push a
          // history entry on hash-tag change.  When replace is true, we don't
          // want this.
          if(!options.replace) this.iframe.document.open().close();
          this._updateHash(this.iframe.location, fragment, options.replace);
        }

      // If you've told us that you explicitly don't want fallback hashchange-
      // based history, then `navigate` becomes a page refresh.
      } else {
        return this.location.assign(url);
      }
      if (options.trigger) return this.loadUrl(fragment);
    },

    // Update the hash location, either replacing the current entry, or adding
    // a new one to the browser history.
    _updateHash: function(location, fragment, replace) {
      if (replace) {
        var href = location.href.replace(/(javascript:|#).*$/, '');
        location.replace(href + '#' + fragment);
      } else {
        // Some browsers require that `hash` contains a leading #.
        location.hash = '#' + fragment;
      }
    }

  });

  // Create the default Backbone.history.
  Backbone.history = new History;

  // Helpers
  // -------

  // Helper function to correctly set up the prototype chain, for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.
  var extend = function(protoProps, staticProps) {
    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ return parent.apply(this, arguments); };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    var Surrogate = function(){ this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) _.extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  // Set up inheritance for the model, collection, router, view and history.
  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

  // Throw an error when a URL is needed, and none is supplied.
  var urlError = function() {
    throw new Error('A "url" property or function must be specified');
  };

  // Wrap an optional error callback with a fallback error event.
  var wrapError = function(model, options) {
    var error = options.error;
    options.error = function(resp) {
      if (error) error(model, resp, options);
      model.trigger('error', model, resp, options);
    };
  };

  return Backbone;

}));

},{"underscore":159}],134:[function(require,module,exports){
/*
 * jQuery File Upload Plugin 5.40.1
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2010, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/* jshint nomen:false */
/* global define, window, document, location, Blob, FormData */

(function (factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define([
            'jquery',
            'jquery.ui.widget'
        ], factory);
    } else {
        // Browser globals:
        factory(window.jQuery);
    }
}(function ($) {
    'use strict';

    // Detect file input support, based on
    // http://viljamis.com/blog/2012/file-upload-support-on-mobile/
    $.support.fileInput = !(new RegExp(
        // Handle devices which give false positives for the feature detection:
        '(Android (1\\.[0156]|2\\.[01]))' +
            '|(Windows Phone (OS 7|8\\.0))|(XBLWP)|(ZuneWP)|(WPDesktop)' +
            '|(w(eb)?OSBrowser)|(webOS)' +
            '|(Kindle/(1\\.0|2\\.[05]|3\\.0))'
    ).test(window.navigator.userAgent) ||
        // Feature detection for all other devices:
        $('<input type="file">').prop('disabled'));

    // The FileReader API is not actually used, but works as feature detection,
    // as some Safari versions (5?) support XHR file uploads via the FormData API,
    // but not non-multipart XHR file uploads.
    // window.XMLHttpRequestUpload is not available on IE10, so we check for
    // window.ProgressEvent instead to detect XHR2 file upload capability:
    $.support.xhrFileUpload = !!(window.ProgressEvent && window.FileReader);
    $.support.xhrFormDataFileUpload = !!window.FormData;

    // Detect support for Blob slicing (required for chunked uploads):
    $.support.blobSlice = window.Blob && (Blob.prototype.slice ||
        Blob.prototype.webkitSlice || Blob.prototype.mozSlice);

    // The fileupload widget listens for change events on file input fields defined
    // via fileInput setting and paste or drop events of the given dropZone.
    // In addition to the default jQuery Widget methods, the fileupload widget
    // exposes the "add" and "send" methods, to add or directly send files using
    // the fileupload API.
    // By default, files added via file input selection, paste, drag & drop or
    // "add" method are uploaded immediately, but it is possible to override
    // the "add" callback option to queue file uploads.
    $.widget('blueimp.fileupload', {

        options: {
            // The drop target element(s), by the default the complete document.
            // Set to null to disable drag & drop support:
            dropZone: $(document),
            // The paste target element(s), by the default the complete document.
            // Set to null to disable paste support:
            pasteZone: $(document),
            // The file input field(s), that are listened to for change events.
            // If undefined, it is set to the file input fields inside
            // of the widget element on plugin initialization.
            // Set to null to disable the change listener.
            fileInput: undefined,
            // By default, the file input field is replaced with a clone after
            // each input field change event. This is required for iframe transport
            // queues and allows change events to be fired for the same file
            // selection, but can be disabled by setting the following option to false:
            replaceFileInput: true,
            // The parameter name for the file form data (the request argument name).
            // If undefined or empty, the name property of the file input field is
            // used, or "files[]" if the file input name property is also empty,
            // can be a string or an array of strings:
            paramName: undefined,
            // By default, each file of a selection is uploaded using an individual
            // request for XHR type uploads. Set to false to upload file
            // selections in one request each:
            singleFileUploads: true,
            // To limit the number of files uploaded with one XHR request,
            // set the following option to an integer greater than 0:
            limitMultiFileUploads: undefined,
            // The following option limits the number of files uploaded with one
            // XHR request to keep the request size under or equal to the defined
            // limit in bytes:
            limitMultiFileUploadSize: undefined,
            // Multipart file uploads add a number of bytes to each uploaded file,
            // therefore the following option adds an overhead for each file used
            // in the limitMultiFileUploadSize configuration:
            limitMultiFileUploadSizeOverhead: 512,
            // Set the following option to true to issue all file upload requests
            // in a sequential order:
            sequentialUploads: false,
            // To limit the number of concurrent uploads,
            // set the following option to an integer greater than 0:
            limitConcurrentUploads: undefined,
            // Set the following option to true to force iframe transport uploads:
            forceIframeTransport: false,
            // Set the following option to the location of a redirect url on the
            // origin server, for cross-domain iframe transport uploads:
            redirect: undefined,
            // The parameter name for the redirect url, sent as part of the form
            // data and set to 'redirect' if this option is empty:
            redirectParamName: undefined,
            // Set the following option to the location of a postMessage window,
            // to enable postMessage transport uploads:
            postMessage: undefined,
            // By default, XHR file uploads are sent as multipart/form-data.
            // The iframe transport is always using multipart/form-data.
            // Set to false to enable non-multipart XHR uploads:
            multipart: true,
            // To upload large files in smaller chunks, set the following option
            // to a preferred maximum chunk size. If set to 0, null or undefined,
            // or the browser does not support the required Blob API, files will
            // be uploaded as a whole.
            maxChunkSize: undefined,
            // When a non-multipart upload or a chunked multipart upload has been
            // aborted, this option can be used to resume the upload by setting
            // it to the size of the already uploaded bytes. This option is most
            // useful when modifying the options object inside of the "add" or
            // "send" callbacks, as the options are cloned for each file upload.
            uploadedBytes: undefined,
            // By default, failed (abort or error) file uploads are removed from the
            // global progress calculation. Set the following option to false to
            // prevent recalculating the global progress data:
            recalculateProgress: true,
            // Interval in milliseconds to calculate and trigger progress events:
            progressInterval: 100,
            // Interval in milliseconds to calculate progress bitrate:
            bitrateInterval: 500,
            // By default, uploads are started automatically when adding files:
            autoUpload: true,

            // Error and info messages:
            messages: {
                uploadedBytes: 'Uploaded bytes exceed file size'
            },

            // Translation function, gets the message key to be translated
            // and an object with context specific data as arguments:
            i18n: function (message, context) {
                message = this.messages[message] || message.toString();
                if (context) {
                    $.each(context, function (key, value) {
                        message = message.replace('{' + key + '}', value);
                    });
                }
                return message;
            },

            // Additional form data to be sent along with the file uploads can be set
            // using this option, which accepts an array of objects with name and
            // value properties, a function returning such an array, a FormData
            // object (for XHR file uploads), or a simple object.
            // The form of the first fileInput is given as parameter to the function:
            formData: function (form) {
                return form.serializeArray();
            },

            // The add callback is invoked as soon as files are added to the fileupload
            // widget (via file input selection, drag & drop, paste or add API call).
            // If the singleFileUploads option is enabled, this callback will be
            // called once for each file in the selection for XHR file uploads, else
            // once for each file selection.
            //
            // The upload starts when the submit method is invoked on the data parameter.
            // The data object contains a files property holding the added files
            // and allows you to override plugin options as well as define ajax settings.
            //
            // Listeners for this callback can also be bound the following way:
            // .bind('fileuploadadd', func);
            //
            // data.submit() returns a Promise object and allows to attach additional
            // handlers using jQuery's Deferred callbacks:
            // data.submit().done(func).fail(func).always(func);
            add: function (e, data) {
                if (e.isDefaultPrevented()) {
                    return false;
                }
                if (data.autoUpload || (data.autoUpload !== false &&
                        $(this).fileupload('option', 'autoUpload'))) {
                    data.process().done(function () {
                        data.submit();
                    });
                }
            },

            // Other callbacks:

            // Callback for the submit event of each file upload:
            // submit: function (e, data) {}, // .bind('fileuploadsubmit', func);

            // Callback for the start of each file upload request:
            // send: function (e, data) {}, // .bind('fileuploadsend', func);

            // Callback for successful uploads:
            // done: function (e, data) {}, // .bind('fileuploaddone', func);

            // Callback for failed (abort or error) uploads:
            // fail: function (e, data) {}, // .bind('fileuploadfail', func);

            // Callback for completed (success, abort or error) requests:
            // always: function (e, data) {}, // .bind('fileuploadalways', func);

            // Callback for upload progress events:
            // progress: function (e, data) {}, // .bind('fileuploadprogress', func);

            // Callback for global upload progress events:
            // progressall: function (e, data) {}, // .bind('fileuploadprogressall', func);

            // Callback for uploads start, equivalent to the global ajaxStart event:
            // start: function (e) {}, // .bind('fileuploadstart', func);

            // Callback for uploads stop, equivalent to the global ajaxStop event:
            // stop: function (e) {}, // .bind('fileuploadstop', func);

            // Callback for change events of the fileInput(s):
            // change: function (e, data) {}, // .bind('fileuploadchange', func);

            // Callback for paste events to the pasteZone(s):
            // paste: function (e, data) {}, // .bind('fileuploadpaste', func);

            // Callback for drop events of the dropZone(s):
            // drop: function (e, data) {}, // .bind('fileuploaddrop', func);

            // Callback for dragover events of the dropZone(s):
            // dragover: function (e) {}, // .bind('fileuploaddragover', func);

            // Callback for the start of each chunk upload request:
            // chunksend: function (e, data) {}, // .bind('fileuploadchunksend', func);

            // Callback for successful chunk uploads:
            // chunkdone: function (e, data) {}, // .bind('fileuploadchunkdone', func);

            // Callback for failed (abort or error) chunk uploads:
            // chunkfail: function (e, data) {}, // .bind('fileuploadchunkfail', func);

            // Callback for completed (success, abort or error) chunk upload requests:
            // chunkalways: function (e, data) {}, // .bind('fileuploadchunkalways', func);

            // The plugin options are used as settings object for the ajax calls.
            // The following are jQuery ajax settings required for the file uploads:
            processData: false,
            contentType: false,
            cache: false
        },

        // A list of options that require reinitializing event listeners and/or
        // special initialization code:
        _specialOptions: [
            'fileInput',
            'dropZone',
            'pasteZone',
            'multipart',
            'forceIframeTransport'
        ],

        _blobSlice: $.support.blobSlice && function () {
            var slice = this.slice || this.webkitSlice || this.mozSlice;
            return slice.apply(this, arguments);
        },

        _BitrateTimer: function () {
            this.timestamp = ((Date.now) ? Date.now() : (new Date()).getTime());
            this.loaded = 0;
            this.bitrate = 0;
            this.getBitrate = function (now, loaded, interval) {
                var timeDiff = now - this.timestamp;
                if (!this.bitrate || !interval || timeDiff > interval) {
                    this.bitrate = (loaded - this.loaded) * (1000 / timeDiff) * 8;
                    this.loaded = loaded;
                    this.timestamp = now;
                }
                return this.bitrate;
            };
        },

        _isXHRUpload: function (options) {
            return !options.forceIframeTransport &&
                ((!options.multipart && $.support.xhrFileUpload) ||
                $.support.xhrFormDataFileUpload);
        },

        _getFormData: function (options) {
            var formData;
            if ($.type(options.formData) === 'function') {
                return options.formData(options.form);
            }
            if ($.isArray(options.formData)) {
                return options.formData;
            }
            if ($.type(options.formData) === 'object') {
                formData = [];
                $.each(options.formData, function (name, value) {
                    formData.push({name: name, value: value});
                });
                return formData;
            }
            return [];
        },

        _getTotal: function (files) {
            var total = 0;
            $.each(files, function (index, file) {
                total += file.size || 1;
            });
            return total;
        },

        _initProgressObject: function (obj) {
            var progress = {
                loaded: 0,
                total: 0,
                bitrate: 0
            };
            if (obj._progress) {
                $.extend(obj._progress, progress);
            } else {
                obj._progress = progress;
            }
        },

        _initResponseObject: function (obj) {
            var prop;
            if (obj._response) {
                for (prop in obj._response) {
                    if (obj._response.hasOwnProperty(prop)) {
                        delete obj._response[prop];
                    }
                }
            } else {
                obj._response = {};
            }
        },

        _onProgress: function (e, data) {
            if (e.lengthComputable) {
                var now = ((Date.now) ? Date.now() : (new Date()).getTime()),
                    loaded;
                if (data._time && data.progressInterval &&
                        (now - data._time < data.progressInterval) &&
                        e.loaded !== e.total) {
                    return;
                }
                data._time = now;
                loaded = Math.floor(
                    e.loaded / e.total * (data.chunkSize || data._progress.total)
                ) + (data.uploadedBytes || 0);
                // Add the difference from the previously loaded state
                // to the global loaded counter:
                this._progress.loaded += (loaded - data._progress.loaded);
                this._progress.bitrate = this._bitrateTimer.getBitrate(
                    now,
                    this._progress.loaded,
                    data.bitrateInterval
                );
                data._progress.loaded = data.loaded = loaded;
                data._progress.bitrate = data.bitrate = data._bitrateTimer.getBitrate(
                    now,
                    loaded,
                    data.bitrateInterval
                );
                // Trigger a custom progress event with a total data property set
                // to the file size(s) of the current upload and a loaded data
                // property calculated accordingly:
                this._trigger(
                    'progress',
                    $.Event('progress', {delegatedEvent: e}),
                    data
                );
                // Trigger a global progress event for all current file uploads,
                // including ajax calls queued for sequential file uploads:
                this._trigger(
                    'progressall',
                    $.Event('progressall', {delegatedEvent: e}),
                    this._progress
                );
            }
        },

        _initProgressListener: function (options) {
            var that = this,
                xhr = options.xhr ? options.xhr() : $.ajaxSettings.xhr();
            // Accesss to the native XHR object is required to add event listeners
            // for the upload progress event:
            if (xhr.upload) {
                $(xhr.upload).bind('progress', function (e) {
                    var oe = e.originalEvent;
                    // Make sure the progress event properties get copied over:
                    e.lengthComputable = oe.lengthComputable;
                    e.loaded = oe.loaded;
                    e.total = oe.total;
                    that._onProgress(e, options);
                });
                options.xhr = function () {
                    return xhr;
                };
            }
        },

        _isInstanceOf: function (type, obj) {
            // Cross-frame instanceof check
            return Object.prototype.toString.call(obj) === '[object ' + type + ']';
        },

        _initXHRData: function (options) {
            var that = this,
                formData,
                file = options.files[0],
                // Ignore non-multipart setting if not supported:
                multipart = options.multipart || !$.support.xhrFileUpload,
                paramName = $.type(options.paramName) === 'array' ?
                    options.paramName[0] : options.paramName;
            options.headers = $.extend({}, options.headers);
            if (options.contentRange) {
                options.headers['Content-Range'] = options.contentRange;
            }
            if (!multipart || options.blob || !this._isInstanceOf('File', file)) {
                options.headers['Content-Disposition'] = 'attachment; filename="' +
                    encodeURI(file.name) + '"';
            }
            if (!multipart) {
                options.contentType = file.type || 'application/octet-stream';
                options.data = options.blob || file;
            } else if ($.support.xhrFormDataFileUpload) {
                if (options.postMessage) {
                    // window.postMessage does not allow sending FormData
                    // objects, so we just add the File/Blob objects to
                    // the formData array and let the postMessage window
                    // create the FormData object out of this array:
                    formData = this._getFormData(options);
                    if (options.blob) {
                        formData.push({
                            name: paramName,
                            value: options.blob
                        });
                    } else {
                        $.each(options.files, function (index, file) {
                            formData.push({
                                name: ($.type(options.paramName) === 'array' &&
                                    options.paramName[index]) || paramName,
                                value: file
                            });
                        });
                    }
                } else {
                    if (that._isInstanceOf('FormData', options.formData)) {
                        formData = options.formData;
                    } else {
                        formData = new FormData();
                        $.each(this._getFormData(options), function (index, field) {
                            formData.append(field.name, field.value);
                        });
                    }
                    if (options.blob) {
                        formData.append(paramName, options.blob, file.name);
                    } else {
                        $.each(options.files, function (index, file) {
                            // This check allows the tests to run with
                            // dummy objects:
                            if (that._isInstanceOf('File', file) ||
                                    that._isInstanceOf('Blob', file)) {
                                formData.append(
                                    ($.type(options.paramName) === 'array' &&
                                        options.paramName[index]) || paramName,
                                    file,
                                    file.uploadName || file.name
                                );
                            }
                        });
                    }
                }
                options.data = formData;
            }
            // Blob reference is not needed anymore, free memory:
            options.blob = null;
        },

        _initIframeSettings: function (options) {
            var targetHost = $('<a></a>').prop('href', options.url).prop('host');
            // Setting the dataType to iframe enables the iframe transport:
            options.dataType = 'iframe ' + (options.dataType || '');
            // The iframe transport accepts a serialized array as form data:
            options.formData = this._getFormData(options);
            // Add redirect url to form data on cross-domain uploads:
            if (options.redirect && targetHost && targetHost !== location.host) {
                options.formData.push({
                    name: options.redirectParamName || 'redirect',
                    value: options.redirect
                });
            }
        },

        _initDataSettings: function (options) {
            if (this._isXHRUpload(options)) {
                if (!this._chunkedUpload(options, true)) {
                    if (!options.data) {
                        this._initXHRData(options);
                    }
                    this._initProgressListener(options);
                }
                if (options.postMessage) {
                    // Setting the dataType to postmessage enables the
                    // postMessage transport:
                    options.dataType = 'postmessage ' + (options.dataType || '');
                }
            } else {
                this._initIframeSettings(options);
            }
        },

        _getParamName: function (options) {
            var fileInput = $(options.fileInput),
                paramName = options.paramName;
            if (!paramName) {
                paramName = [];
                fileInput.each(function () {
                    var input = $(this),
                        name = input.prop('name') || 'files[]',
                        i = (input.prop('files') || [1]).length;
                    while (i) {
                        paramName.push(name);
                        i -= 1;
                    }
                });
                if (!paramName.length) {
                    paramName = [fileInput.prop('name') || 'files[]'];
                }
            } else if (!$.isArray(paramName)) {
                paramName = [paramName];
            }
            return paramName;
        },

        _initFormSettings: function (options) {
            // Retrieve missing options from the input field and the
            // associated form, if available:
            if (!options.form || !options.form.length) {
                options.form = $(options.fileInput.prop('form'));
                // If the given file input doesn't have an associated form,
                // use the default widget file input's form:
                if (!options.form.length) {
                    options.form = $(this.options.fileInput.prop('form'));
                }
            }
            options.paramName = this._getParamName(options);
            if (!options.url) {
                options.url = options.form.prop('action') || location.href;
            }
            // The HTTP request method must be "POST" or "PUT":
            options.type = (options.type ||
                ($.type(options.form.prop('method')) === 'string' &&
                    options.form.prop('method')) || ''
                ).toUpperCase();
            if (options.type !== 'POST' && options.type !== 'PUT' &&
                    options.type !== 'PATCH') {
                options.type = 'POST';
            }
            if (!options.formAcceptCharset) {
                options.formAcceptCharset = options.form.attr('accept-charset');
            }
        },

        _getAJAXSettings: function (data) {
            var options = $.extend({}, this.options, data);
            this._initFormSettings(options);
            this._initDataSettings(options);
            return options;
        },

        // jQuery 1.6 doesn't provide .state(),
        // while jQuery 1.8+ removed .isRejected() and .isResolved():
        _getDeferredState: function (deferred) {
            if (deferred.state) {
                return deferred.state();
            }
            if (deferred.isResolved()) {
                return 'resolved';
            }
            if (deferred.isRejected()) {
                return 'rejected';
            }
            return 'pending';
        },

        // Maps jqXHR callbacks to the equivalent
        // methods of the given Promise object:
        _enhancePromise: function (promise) {
            promise.success = promise.done;
            promise.error = promise.fail;
            promise.complete = promise.always;
            return promise;
        },

        // Creates and returns a Promise object enhanced with
        // the jqXHR methods abort, success, error and complete:
        _getXHRPromise: function (resolveOrReject, context, args) {
            var dfd = $.Deferred(),
                promise = dfd.promise();
            context = context || this.options.context || promise;
            if (resolveOrReject === true) {
                dfd.resolveWith(context, args);
            } else if (resolveOrReject === false) {
                dfd.rejectWith(context, args);
            }
            promise.abort = dfd.promise;
            return this._enhancePromise(promise);
        },

        // Adds convenience methods to the data callback argument:
        _addConvenienceMethods: function (e, data) {
            var that = this,
                getPromise = function (args) {
                    return $.Deferred().resolveWith(that, args).promise();
                };
            data.process = function (resolveFunc, rejectFunc) {
                if (resolveFunc || rejectFunc) {
                    data._processQueue = this._processQueue =
                        (this._processQueue || getPromise([this])).pipe(
                            function () {
                                if (data.errorThrown) {
                                    return $.Deferred()
                                        .rejectWith(that, [data]).promise();
                                }
                                return getPromise(arguments);
                            }
                        ).pipe(resolveFunc, rejectFunc);
                }
                return this._processQueue || getPromise([this]);
            };
            data.submit = function () {
                if (this.state() !== 'pending') {
                    data.jqXHR = this.jqXHR =
                        (that._trigger(
                            'submit',
                            $.Event('submit', {delegatedEvent: e}),
                            this
                        ) !== false) && that._onSend(e, this);
                }
                return this.jqXHR || that._getXHRPromise();
            };
            data.abort = function () {
                if (this.jqXHR) {
                    return this.jqXHR.abort();
                }
                this.errorThrown = 'abort';
                that._trigger('fail', null, this);
                return that._getXHRPromise(false);
            };
            data.state = function () {
                if (this.jqXHR) {
                    return that._getDeferredState(this.jqXHR);
                }
                if (this._processQueue) {
                    return that._getDeferredState(this._processQueue);
                }
            };
            data.processing = function () {
                return !this.jqXHR && this._processQueue && that
                    ._getDeferredState(this._processQueue) === 'pending';
            };
            data.progress = function () {
                return this._progress;
            };
            data.response = function () {
                return this._response;
            };
        },

        // Parses the Range header from the server response
        // and returns the uploaded bytes:
        _getUploadedBytes: function (jqXHR) {
            var range = jqXHR.getResponseHeader('Range'),
                parts = range && range.split('-'),
                upperBytesPos = parts && parts.length > 1 &&
                    parseInt(parts[1], 10);
            return upperBytesPos && upperBytesPos + 1;
        },

        // Uploads a file in multiple, sequential requests
        // by splitting the file up in multiple blob chunks.
        // If the second parameter is true, only tests if the file
        // should be uploaded in chunks, but does not invoke any
        // upload requests:
        _chunkedUpload: function (options, testOnly) {
            options.uploadedBytes = options.uploadedBytes || 0;
            var that = this,
                file = options.files[0],
                fs = file.size,
                ub = options.uploadedBytes,
                mcs = options.maxChunkSize || fs,
                slice = this._blobSlice,
                dfd = $.Deferred(),
                promise = dfd.promise(),
                jqXHR,
                upload;
            if (!(this._isXHRUpload(options) && slice && (ub || mcs < fs)) ||
                    options.data) {
                return false;
            }
            if (testOnly) {
                return true;
            }
            if (ub >= fs) {
                file.error = options.i18n('uploadedBytes');
                return this._getXHRPromise(
                    false,
                    options.context,
                    [null, 'error', file.error]
                );
            }
            // The chunk upload method:
            upload = function () {
                // Clone the options object for each chunk upload:
                var o = $.extend({}, options),
                    currentLoaded = o._progress.loaded;
                o.blob = slice.call(
                    file,
                    ub,
                    ub + mcs,
                    file.type
                );
                // Store the current chunk size, as the blob itself
                // will be dereferenced after data processing:
                o.chunkSize = o.blob.size;
                // Expose the chunk bytes position range:
                o.contentRange = 'bytes ' + ub + '-' +
                    (ub + o.chunkSize - 1) + '/' + fs;
                // Process the upload data (the blob and potential form data):
                that._initXHRData(o);
                // Add progress listeners for this chunk upload:
                that._initProgressListener(o);
                jqXHR = ((that._trigger('chunksend', null, o) !== false && $.ajax(o)) ||
                        that._getXHRPromise(false, o.context))
                    .done(function (result, textStatus, jqXHR) {
                        ub = that._getUploadedBytes(jqXHR) ||
                            (ub + o.chunkSize);
                        // Create a progress event if no final progress event
                        // with loaded equaling total has been triggered
                        // for this chunk:
                        if (currentLoaded + o.chunkSize - o._progress.loaded) {
                            that._onProgress($.Event('progress', {
                                lengthComputable: true,
                                loaded: ub - o.uploadedBytes,
                                total: ub - o.uploadedBytes
                            }), o);
                        }
                        options.uploadedBytes = o.uploadedBytes = ub;
                        o.result = result;
                        o.textStatus = textStatus;
                        o.jqXHR = jqXHR;
                        that._trigger('chunkdone', null, o);
                        that._trigger('chunkalways', null, o);
                        if (ub < fs) {
                            // File upload not yet complete,
                            // continue with the next chunk:
                            upload();
                        } else {
                            dfd.resolveWith(
                                o.context,
                                [result, textStatus, jqXHR]
                            );
                        }
                    })
                    .fail(function (jqXHR, textStatus, errorThrown) {
                        o.jqXHR = jqXHR;
                        o.textStatus = textStatus;
                        o.errorThrown = errorThrown;
                        that._trigger('chunkfail', null, o);
                        that._trigger('chunkalways', null, o);
                        dfd.rejectWith(
                            o.context,
                            [jqXHR, textStatus, errorThrown]
                        );
                    });
            };
            this._enhancePromise(promise);
            promise.abort = function () {
                return jqXHR.abort();
            };
            upload();
            return promise;
        },

        _beforeSend: function (e, data) {
            if (this._active === 0) {
                // the start callback is triggered when an upload starts
                // and no other uploads are currently running,
                // equivalent to the global ajaxStart event:
                this._trigger('start');
                // Set timer for global bitrate progress calculation:
                this._bitrateTimer = new this._BitrateTimer();
                // Reset the global progress values:
                this._progress.loaded = this._progress.total = 0;
                this._progress.bitrate = 0;
            }
            // Make sure the container objects for the .response() and
            // .progress() methods on the data object are available
            // and reset to their initial state:
            this._initResponseObject(data);
            this._initProgressObject(data);
            data._progress.loaded = data.loaded = data.uploadedBytes || 0;
            data._progress.total = data.total = this._getTotal(data.files) || 1;
            data._progress.bitrate = data.bitrate = 0;
            this._active += 1;
            // Initialize the global progress values:
            this._progress.loaded += data.loaded;
            this._progress.total += data.total;
        },

        _onDone: function (result, textStatus, jqXHR, options) {
            var total = options._progress.total,
                response = options._response;
            if (options._progress.loaded < total) {
                // Create a progress event if no final progress event
                // with loaded equaling total has been triggered:
                this._onProgress($.Event('progress', {
                    lengthComputable: true,
                    loaded: total,
                    total: total
                }), options);
            }
            response.result = options.result = result;
            response.textStatus = options.textStatus = textStatus;
            response.jqXHR = options.jqXHR = jqXHR;
            this._trigger('done', null, options);
        },

        _onFail: function (jqXHR, textStatus, errorThrown, options) {
            var response = options._response;
            if (options.recalculateProgress) {
                // Remove the failed (error or abort) file upload from
                // the global progress calculation:
                this._progress.loaded -= options._progress.loaded;
                this._progress.total -= options._progress.total;
            }
            response.jqXHR = options.jqXHR = jqXHR;
            response.textStatus = options.textStatus = textStatus;
            response.errorThrown = options.errorThrown = errorThrown;
            this._trigger('fail', null, options);
        },

        _onAlways: function (jqXHRorResult, textStatus, jqXHRorError, options) {
            // jqXHRorResult, textStatus and jqXHRorError are added to the
            // options object via done and fail callbacks
            this._trigger('always', null, options);
        },

        _onSend: function (e, data) {
            if (!data.submit) {
                this._addConvenienceMethods(e, data);
            }
            var that = this,
                jqXHR,
                aborted,
                slot,
                pipe,
                options = that._getAJAXSettings(data),
                send = function () {
                    that._sending += 1;
                    // Set timer for bitrate progress calculation:
                    options._bitrateTimer = new that._BitrateTimer();
                    jqXHR = jqXHR || (
                        ((aborted || that._trigger(
                            'send',
                            $.Event('send', {delegatedEvent: e}),
                            options
                        ) === false) &&
                        that._getXHRPromise(false, options.context, aborted)) ||
                        that._chunkedUpload(options) || $.ajax(options)
                    ).done(function (result, textStatus, jqXHR) {
                        that._onDone(result, textStatus, jqXHR, options);
                    }).fail(function (jqXHR, textStatus, errorThrown) {
                        that._onFail(jqXHR, textStatus, errorThrown, options);
                    }).always(function (jqXHRorResult, textStatus, jqXHRorError) {
                        that._onAlways(
                            jqXHRorResult,
                            textStatus,
                            jqXHRorError,
                            options
                        );
                        that._sending -= 1;
                        that._active -= 1;
                        if (options.limitConcurrentUploads &&
                                options.limitConcurrentUploads > that._sending) {
                            // Start the next queued upload,
                            // that has not been aborted:
                            var nextSlot = that._slots.shift();
                            while (nextSlot) {
                                if (that._getDeferredState(nextSlot) === 'pending') {
                                    nextSlot.resolve();
                                    break;
                                }
                                nextSlot = that._slots.shift();
                            }
                        }
                        if (that._active === 0) {
                            // The stop callback is triggered when all uploads have
                            // been completed, equivalent to the global ajaxStop event:
                            that._trigger('stop');
                        }
                    });
                    return jqXHR;
                };
            this._beforeSend(e, options);
            if (this.options.sequentialUploads ||
                    (this.options.limitConcurrentUploads &&
                    this.options.limitConcurrentUploads <= this._sending)) {
                if (this.options.limitConcurrentUploads > 1) {
                    slot = $.Deferred();
                    this._slots.push(slot);
                    pipe = slot.pipe(send);
                } else {
                    this._sequence = this._sequence.pipe(send, send);
                    pipe = this._sequence;
                }
                // Return the piped Promise object, enhanced with an abort method,
                // which is delegated to the jqXHR object of the current upload,
                // and jqXHR callbacks mapped to the equivalent Promise methods:
                pipe.abort = function () {
                    aborted = [undefined, 'abort', 'abort'];
                    if (!jqXHR) {
                        if (slot) {
                            slot.rejectWith(options.context, aborted);
                        }
                        return send();
                    }
                    return jqXHR.abort();
                };
                return this._enhancePromise(pipe);
            }
            return send();
        },

        _onAdd: function (e, data) {
            var that = this,
                result = true,
                options = $.extend({}, this.options, data),
                files = data.files,
                filesLength = files.length,
                limit = options.limitMultiFileUploads,
                limitSize = options.limitMultiFileUploadSize,
                overhead = options.limitMultiFileUploadSizeOverhead,
                batchSize = 0,
                paramName = this._getParamName(options),
                paramNameSet,
                paramNameSlice,
                fileSet,
                i,
                j = 0;
            if (limitSize && (!filesLength || files[0].size === undefined)) {
                limitSize = undefined;
            }
            if (!(options.singleFileUploads || limit || limitSize) ||
                    !this._isXHRUpload(options)) {
                fileSet = [files];
                paramNameSet = [paramName];
            } else if (!(options.singleFileUploads || limitSize) && limit) {
                fileSet = [];
                paramNameSet = [];
                for (i = 0; i < filesLength; i += limit) {
                    fileSet.push(files.slice(i, i + limit));
                    paramNameSlice = paramName.slice(i, i + limit);
                    if (!paramNameSlice.length) {
                        paramNameSlice = paramName;
                    }
                    paramNameSet.push(paramNameSlice);
                }
            } else if (!options.singleFileUploads && limitSize) {
                fileSet = [];
                paramNameSet = [];
                for (i = 0; i < filesLength; i = i + 1) {
                    batchSize += files[i].size + overhead;
                    if (i + 1 === filesLength ||
                            ((batchSize + files[i + 1].size + overhead) > limitSize) ||
                            (limit && i + 1 - j >= limit)) {
                        fileSet.push(files.slice(j, i + 1));
                        paramNameSlice = paramName.slice(j, i + 1);
                        if (!paramNameSlice.length) {
                            paramNameSlice = paramName;
                        }
                        paramNameSet.push(paramNameSlice);
                        j = i + 1;
                        batchSize = 0;
                    }
                }
            } else {
                paramNameSet = paramName;
            }
            data.originalFiles = files;
            $.each(fileSet || files, function (index, element) {
                var newData = $.extend({}, data);
                newData.files = fileSet ? element : [element];
                newData.paramName = paramNameSet[index];
                that._initResponseObject(newData);
                that._initProgressObject(newData);
                that._addConvenienceMethods(e, newData);
                result = that._trigger(
                    'add',
                    $.Event('add', {delegatedEvent: e}),
                    newData
                );
                return result;
            });
            return result;
        },

        _replaceFileInput: function (input) {
            var inputClone = input.clone(true);
            $('<form></form>').append(inputClone)[0].reset();
            // Detaching allows to insert the fileInput on another form
            // without loosing the file input value:
            input.after(inputClone).detach();
            // Avoid memory leaks with the detached file input:
            $.cleanData(input.unbind('remove'));
            // Replace the original file input element in the fileInput
            // elements set with the clone, which has been copied including
            // event handlers:
            this.options.fileInput = this.options.fileInput.map(function (i, el) {
                if (el === input[0]) {
                    return inputClone[0];
                }
                return el;
            });
            // If the widget has been initialized on the file input itself,
            // override this.element with the file input clone:
            if (input[0] === this.element[0]) {
                this.element = inputClone;
            }
        },

        _handleFileTreeEntry: function (entry, path) {
            var that = this,
                dfd = $.Deferred(),
                errorHandler = function (e) {
                    if (e && !e.entry) {
                        e.entry = entry;
                    }
                    // Since $.when returns immediately if one
                    // Deferred is rejected, we use resolve instead.
                    // This allows valid files and invalid items
                    // to be returned together in one set:
                    dfd.resolve([e]);
                },
                dirReader;
            path = path || '';
            if (entry.isFile) {
                if (entry._file) {
                    // Workaround for Chrome bug #149735
                    entry._file.relativePath = path;
                    dfd.resolve(entry._file);
                } else {
                    entry.file(function (file) {
                        file.relativePath = path;
                        dfd.resolve(file);
                    }, errorHandler);
                }
            } else if (entry.isDirectory) {
                dirReader = entry.createReader();
                dirReader.readEntries(function (entries) {
                    that._handleFileTreeEntries(
                        entries,
                        path + entry.name + '/'
                    ).done(function (files) {
                        dfd.resolve(files);
                    }).fail(errorHandler);
                }, errorHandler);
            } else {
                // Return an empy list for file system items
                // other than files or directories:
                dfd.resolve([]);
            }
            return dfd.promise();
        },

        _handleFileTreeEntries: function (entries, path) {
            var that = this;
            return $.when.apply(
                $,
                $.map(entries, function (entry) {
                    return that._handleFileTreeEntry(entry, path);
                })
            ).pipe(function () {
                return Array.prototype.concat.apply(
                    [],
                    arguments
                );
            });
        },

        _getDroppedFiles: function (dataTransfer) {
            dataTransfer = dataTransfer || {};
            var items = dataTransfer.items;
            if (items && items.length && (items[0].webkitGetAsEntry ||
                    items[0].getAsEntry)) {
                return this._handleFileTreeEntries(
                    $.map(items, function (item) {
                        var entry;
                        if (item.webkitGetAsEntry) {
                            entry = item.webkitGetAsEntry();
                            if (entry) {
                                // Workaround for Chrome bug #149735:
                                entry._file = item.getAsFile();
                            }
                            return entry;
                        }
                        return item.getAsEntry();
                    })
                );
            }
            return $.Deferred().resolve(
                $.makeArray(dataTransfer.files)
            ).promise();
        },

        _getSingleFileInputFiles: function (fileInput) {
            fileInput = $(fileInput);
            var entries = fileInput.prop('webkitEntries') ||
                    fileInput.prop('entries'),
                files,
                value;
            if (entries && entries.length) {
                return this._handleFileTreeEntries(entries);
            }
            files = $.makeArray(fileInput.prop('files'));
            if (!files.length) {
                value = fileInput.prop('value');
                if (!value) {
                    return $.Deferred().resolve([]).promise();
                }
                // If the files property is not available, the browser does not
                // support the File API and we add a pseudo File object with
                // the input value as name with path information removed:
                files = [{name: value.replace(/^.*\\/, '')}];
            } else if (files[0].name === undefined && files[0].fileName) {
                // File normalization for Safari 4 and Firefox 3:
                $.each(files, function (index, file) {
                    file.name = file.fileName;
                    file.size = file.fileSize;
                });
            }
            return $.Deferred().resolve(files).promise();
        },

        _getFileInputFiles: function (fileInput) {
            if (!(fileInput instanceof $) || fileInput.length === 1) {
                return this._getSingleFileInputFiles(fileInput);
            }
            return $.when.apply(
                $,
                $.map(fileInput, this._getSingleFileInputFiles)
            ).pipe(function () {
                return Array.prototype.concat.apply(
                    [],
                    arguments
                );
            });
        },

        _onChange: function (e) {
            var that = this,
                data = {
                    fileInput: $(e.target),
                    form: $(e.target.form)
                };
            this._getFileInputFiles(data.fileInput).always(function (files) {
                data.files = files;
                if (that.options.replaceFileInput) {
                    that._replaceFileInput(data.fileInput);
                }
                if (that._trigger(
                        'change',
                        $.Event('change', {delegatedEvent: e}),
                        data
                    ) !== false) {
                    that._onAdd(e, data);
                }
            });
        },

        _onPaste: function (e) {
            var items = e.originalEvent && e.originalEvent.clipboardData &&
                    e.originalEvent.clipboardData.items,
                data = {files: []};
            if (items && items.length) {
                $.each(items, function (index, item) {
                    var file = item.getAsFile && item.getAsFile();
                    if (file) {
                        data.files.push(file);
                    }
                });
                if (this._trigger(
                        'paste',
                        $.Event('paste', {delegatedEvent: e}),
                        data
                    ) !== false) {
                    this._onAdd(e, data);
                }
            }
        },

        _onDrop: function (e) {
            e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;
            var that = this,
                dataTransfer = e.dataTransfer,
                data = {};
            if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {
                e.preventDefault();
                this._getDroppedFiles(dataTransfer).always(function (files) {
                    data.files = files;
                    if (that._trigger(
                            'drop',
                            $.Event('drop', {delegatedEvent: e}),
                            data
                        ) !== false) {
                        that._onAdd(e, data);
                    }
                });
            }
        },

        _onDragOver: function (e) {
            e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;
            var dataTransfer = e.dataTransfer;
            if (dataTransfer && $.inArray('Files', dataTransfer.types) !== -1 &&
                    this._trigger(
                        'dragover',
                        $.Event('dragover', {delegatedEvent: e})
                    ) !== false) {
                e.preventDefault();
                dataTransfer.dropEffect = 'copy';
            }
        },

        _initEventHandlers: function () {
            if (this._isXHRUpload(this.options)) {
                this._on(this.options.dropZone, {
                    dragover: this._onDragOver,
                    drop: this._onDrop
                });
                this._on(this.options.pasteZone, {
                    paste: this._onPaste
                });
            }
            if ($.support.fileInput) {
                this._on(this.options.fileInput, {
                    change: this._onChange
                });
            }
        },

        _destroyEventHandlers: function () {
            this._off(this.options.dropZone, 'dragover drop');
            this._off(this.options.pasteZone, 'paste');
            this._off(this.options.fileInput, 'change');
        },

        _setOption: function (key, value) {
            var reinit = $.inArray(key, this._specialOptions) !== -1;
            if (reinit) {
                this._destroyEventHandlers();
            }
            this._super(key, value);
            if (reinit) {
                this._initSpecialOptions();
                this._initEventHandlers();
            }
        },

        _initSpecialOptions: function () {
            var options = this.options;
            if (options.fileInput === undefined) {
                options.fileInput = this.element.is('input[type="file"]') ?
                        this.element : this.element.find('input[type="file"]');
            } else if (!(options.fileInput instanceof $)) {
                options.fileInput = $(options.fileInput);
            }
            if (!(options.dropZone instanceof $)) {
                options.dropZone = $(options.dropZone);
            }
            if (!(options.pasteZone instanceof $)) {
                options.pasteZone = $(options.pasteZone);
            }
        },

        _getRegExp: function (str) {
            var parts = str.split('/'),
                modifiers = parts.pop();
            parts.shift();
            return new RegExp(parts.join('/'), modifiers);
        },

        _isRegExpOption: function (key, value) {
            return key !== 'url' && $.type(value) === 'string' &&
                /^\/.*\/[igm]{0,3}$/.test(value);
        },

        _initDataAttributes: function () {
            var that = this,
                options = this.options,
                clone = $(this.element[0].cloneNode(false));
            // Initialize options set via HTML5 data-attributes:
            $.each(
                clone.data(),
                function (key, value) {
                    var dataAttributeName = 'data-' +
                        // Convert camelCase to hyphen-ated key:
                        key.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
                    if (clone.attr(dataAttributeName)) {
                        if (that._isRegExpOption(key, value)) {
                            value = that._getRegExp(value);
                        }
                        options[key] = value;
                    }
                }
            );
        },

        _create: function () {
            this._initDataAttributes();
            this._initSpecialOptions();
            this._slots = [];
            this._sequence = this._getXHRPromise(true);
            this._sending = this._active = 0;
            this._initProgressObject(this);
            this._initEventHandlers();
        },

        // This method is exposed to the widget API and allows to query
        // the number of active uploads:
        active: function () {
            return this._active;
        },

        // This method is exposed to the widget API and allows to query
        // the widget upload progress.
        // It returns an object with loaded, total and bitrate properties
        // for the running uploads:
        progress: function () {
            return this._progress;
        },

        // This method is exposed to the widget API and allows adding files
        // using the fileupload API. The data parameter accepts an object which
        // must have a files property and can contain additional options:
        // .fileupload('add', {files: filesList});
        add: function (data) {
            var that = this;
            if (!data || this.options.disabled) {
                return;
            }
            if (data.fileInput && !data.files) {
                this._getFileInputFiles(data.fileInput).always(function (files) {
                    data.files = files;
                    that._onAdd(null, data);
                });
            } else {
                data.files = $.makeArray(data.files);
                this._onAdd(null, data);
            }
        },

        // This method is exposed to the widget API and allows sending files
        // using the fileupload API. The data parameter accepts an object which
        // must have a files or fileInput property and can contain additional options:
        // .fileupload('send', {files: filesList});
        // The method returns a Promise object for the file upload call.
        send: function (data) {
            if (data && !this.options.disabled) {
                if (data.fileInput && !data.files) {
                    var that = this,
                        dfd = $.Deferred(),
                        promise = dfd.promise(),
                        jqXHR,
                        aborted;
                    promise.abort = function () {
                        aborted = true;
                        if (jqXHR) {
                            return jqXHR.abort();
                        }
                        dfd.reject(null, 'abort', 'abort');
                        return promise;
                    };
                    this._getFileInputFiles(data.fileInput).always(
                        function (files) {
                            if (aborted) {
                                return;
                            }
                            if (!files.length) {
                                dfd.reject();
                                return;
                            }
                            data.files = files;
                            jqXHR = that._onSend(null, data).then(
                                function (result, textStatus, jqXHR) {
                                    dfd.resolve(result, textStatus, jqXHR);
                                },
                                function (jqXHR, textStatus, errorThrown) {
                                    dfd.reject(jqXHR, textStatus, errorThrown);
                                }
                            );
                        }
                    );
                    return this._enhancePromise(promise);
                }
                data.files = $.makeArray(data.files);
                if (data.files.length) {
                    return this._onSend(null, data);
                }
            }
            return this._getXHRPromise(false, data && data.context);
        }

    });

}));

},{}],135:[function(require,module,exports){
/*
 * jQuery Iframe Transport Plugin 1.8.2
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/* global define, window, document */

(function (factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define(['jquery'], factory);
    } else {
        // Browser globals:
        factory(window.jQuery);
    }
}(function ($) {
    'use strict';

    // Helper variable to create unique names for the transport iframes:
    var counter = 0;

    // The iframe transport accepts four additional options:
    // options.fileInput: a jQuery collection of file input fields
    // options.paramName: the parameter name for the file form data,
    //  overrides the name property of the file input field(s),
    //  can be a string or an array of strings.
    // options.formData: an array of objects with name and value properties,
    //  equivalent to the return data of .serializeArray(), e.g.:
    //  [{name: 'a', value: 1}, {name: 'b', value: 2}]
    // options.initialIframeSrc: the URL of the initial iframe src,
    //  by default set to "javascript:false;"
    $.ajaxTransport('iframe', function (options) {
        if (options.async) {
            // javascript:false as initial iframe src
            // prevents warning popups on HTTPS in IE6:
            /*jshint scripturl: true */
            var initialIframeSrc = options.initialIframeSrc || 'javascript:false;',
            /*jshint scripturl: false */
                form,
                iframe,
                addParamChar;
            return {
                send: function (_, completeCallback) {
                    form = $('<form style="display:none;"></form>');
                    form.attr('accept-charset', options.formAcceptCharset);
                    addParamChar = /\?/.test(options.url) ? '&' : '?';
                    // XDomainRequest only supports GET and POST:
                    if (options.type === 'DELETE') {
                        options.url = options.url + addParamChar + '_method=DELETE';
                        options.type = 'POST';
                    } else if (options.type === 'PUT') {
                        options.url = options.url + addParamChar + '_method=PUT';
                        options.type = 'POST';
                    } else if (options.type === 'PATCH') {
                        options.url = options.url + addParamChar + '_method=PATCH';
                        options.type = 'POST';
                    }
                    // IE versions below IE8 cannot set the name property of
                    // elements that have already been added to the DOM,
                    // so we set the name along with the iframe HTML markup:
                    counter += 1;
                    iframe = $(
                        '<iframe src="' + initialIframeSrc +
                            '" name="iframe-transport-' + counter + '"></iframe>'
                    ).bind('load', function () {
                        var fileInputClones,
                            paramNames = $.isArray(options.paramName) ?
                                    options.paramName : [options.paramName];
                        iframe
                            .unbind('load')
                            .bind('load', function () {
                                var response;
                                // Wrap in a try/catch block to catch exceptions thrown
                                // when trying to access cross-domain iframe contents:
                                try {
                                    response = iframe.contents();
                                    // Google Chrome and Firefox do not throw an
                                    // exception when calling iframe.contents() on
                                    // cross-domain requests, so we unify the response:
                                    if (!response.length || !response[0].firstChild) {
                                        throw new Error();
                                    }
                                } catch (e) {
                                    response = undefined;
                                }
                                // The complete callback returns the
                                // iframe content document as response object:
                                completeCallback(
                                    200,
                                    'success',
                                    {'iframe': response}
                                );
                                // Fix for IE endless progress bar activity bug
                                // (happens on form submits to iframe targets):
                                $('<iframe src="' + initialIframeSrc + '"></iframe>')
                                    .appendTo(form);
                                window.setTimeout(function () {
                                    // Removing the form in a setTimeout call
                                    // allows Chrome's developer tools to display
                                    // the response result
                                    form.remove();
                                }, 0);
                            });
                        form
                            .prop('target', iframe.prop('name'))
                            .prop('action', options.url)
                            .prop('method', options.type);
                        if (options.formData) {
                            $.each(options.formData, function (index, field) {
                                $('<input type="hidden"/>')
                                    .prop('name', field.name)
                                    .val(field.value)
                                    .appendTo(form);
                            });
                        }
                        if (options.fileInput && options.fileInput.length &&
                                options.type === 'POST') {
                            fileInputClones = options.fileInput.clone();
                            // Insert a clone for each file input field:
                            options.fileInput.after(function (index) {
                                return fileInputClones[index];
                            });
                            if (options.paramName) {
                                options.fileInput.each(function (index) {
                                    $(this).prop(
                                        'name',
                                        paramNames[index] || options.paramName
                                    );
                                });
                            }
                            // Appending the file input fields to the hidden form
                            // removes them from their original location:
                            form
                                .append(options.fileInput)
                                .prop('enctype', 'multipart/form-data')
                                // enctype must be set as encoding for IE:
                                .prop('encoding', 'multipart/form-data');
                            // Remove the HTML5 form attribute from the input(s):
                            options.fileInput.removeAttr('form');
                        }
                        form.submit();
                        // Insert the file input fields at their original location
                        // by replacing the clones with the originals:
                        if (fileInputClones && fileInputClones.length) {
                            options.fileInput.each(function (index, input) {
                                var clone = $(fileInputClones[index]);
                                // Restore the original name and form properties:
                                $(input)
                                    .prop('name', clone.prop('name'))
                                    .attr('form', clone.attr('form'));
                                clone.replaceWith(input);
                            });
                        }
                    });
                    form.append(iframe).appendTo(document.body);
                },
                abort: function () {
                    if (iframe) {
                        // javascript:false as iframe src aborts the request
                        // and prevents warning popups on HTTPS in IE6.
                        // concat is used to avoid the "Script URL" JSLint error:
                        iframe
                            .unbind('load')
                            .prop('src', initialIframeSrc);
                    }
                    if (form) {
                        form.remove();
                    }
                }
            };
        }
    });

    // The iframe transport returns the iframe content document as response.
    // The following adds converters from iframe to text, json, html, xml
    // and script.
    // Please note that the Content-Type for JSON responses has to be text/plain
    // or text/html, if the browser doesn't include application/json in the
    // Accept header, else IE will show a download dialog.
    // The Content-Type for XML responses on the other hand has to be always
    // application/xml or text/xml, so IE properly parses the XML response.
    // See also
    // https://github.com/blueimp/jQuery-File-Upload/wiki/Setup#content-type-negotiation
    $.ajaxSetup({
        converters: {
            'iframe text': function (iframe) {
                return iframe && $(iframe[0].body).text();
            },
            'iframe json': function (iframe) {
                return iframe && $.parseJSON($(iframe[0].body).text());
            },
            'iframe html': function (iframe) {
                return iframe && $(iframe[0].body).html();
            },
            'iframe xml': function (iframe) {
                var xmlDoc = iframe && iframe[0];
                return xmlDoc && $.isXMLDoc(xmlDoc) ? xmlDoc :
                        $.parseXML((xmlDoc.XMLDocument && xmlDoc.XMLDocument.xml) ||
                            $(xmlDoc.body).html());
            },
            'iframe script': function (iframe) {
                return iframe && $.globalEval($(iframe[0].body).text());
            }
        }
    });

}));

},{}],136:[function(require,module,exports){
/*!
 * jQuery UI Widget 1.10.4+amd
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/jQuery.widget/
 */

(function (factory) {
    if (typeof define === "function" && define.amd) {
        // Register as an anonymous AMD module:
        define(["jquery"], factory);
    } else {
        // Browser globals:
        factory(jQuery);
    }
}(function( $, undefined ) {

var uuid = 0,
	slice = Array.prototype.slice,
	_cleanData = $.cleanData;
$.cleanData = function( elems ) {
	for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
		try {
			$( elem ).triggerHandler( "remove" );
		// http://bugs.jquery.com/ticket/8235
		} catch( e ) {}
	}
	_cleanData( elems );
};

$.widget = function( name, base, prototype ) {
	var fullName, existingConstructor, constructor, basePrototype,
		// proxiedPrototype allows the provided prototype to remain unmodified
		// so that it can be used as a mixin for multiple widgets (#8876)
		proxiedPrototype = {},
		namespace = name.split( "." )[ 0 ];

	name = name.split( "." )[ 1 ];
	fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};
	// extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,
		// copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),
		// track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	});

	basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = (function() {
			var _super = function() {
					return base.prototype[ prop ].apply( this, arguments );
				},
				_superApply = function( args ) {
					return base.prototype[ prop ].apply( this, args );
				};
			return function() {
				var __super = this._super,
					__superApply = this._superApply,
					returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		})();
	});
	constructor.prototype = $.widget.extend( basePrototype, {
		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	});

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
		});
		// remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );
};

$.widget.extend = function( target ) {
	var input = slice.call( arguments, 1 ),
		inputIndex = 0,
		inputLength = input.length,
		key,
		value;
	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :
						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );
				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string",
			args = slice.call( arguments, 1 ),
			returnValue = this;

		// allow multiple hashes to be passed on init
		options = !isMethodCall && args.length ?
			$.widget.extend.apply( null, [ options ].concat(args) ) :
			options;

		if ( isMethodCall ) {
			this.each(function() {
				var methodValue,
					instance = $.data( this, fullName );
				if ( !instance ) {
					return $.error( "cannot call methods on " + name + " prior to initialization; " +
						"attempted to call method '" + options + "'" );
				}
				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
					return $.error( "no such method '" + options + "' for " + name + " widget instance" );
				}
				methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue && methodValue.jquery ?
						returnValue.pushStack( methodValue.get() ) :
						methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} )._init();
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",
	options: {
		disabled: false,

		// callbacks
		create: null
	},
	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = uuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;
		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			});
			this.document = $( element.style ?
				// element within the document
				element.ownerDocument :
				// element is window or document
				element.document || element );
			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
		}

		this._create();
		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},
	_getCreateOptions: $.noop,
	_getCreateEventData: $.noop,
	_create: $.noop,
	_init: $.noop,

	destroy: function() {
		this._destroy();
		// we can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.unbind( this.eventNamespace )
			// 1.9 BC for #7810
			// TODO remove dual storage
			.removeData( this.widgetName )
			.removeData( this.widgetFullName )
			// support: jquery <1.6.3
			// http://bugs.jquery.com/ticket/9413
			.removeData( $.camelCase( this.widgetFullName ) );
		this.widget()
			.unbind( this.eventNamespace )
			.removeAttr( "aria-disabled" )
			.removeClass(
				this.widgetFullName + "-disabled " +
				"ui-state-disabled" );

		// clean up events and states
		this.bindings.unbind( this.eventNamespace );
		this.hoverable.removeClass( "ui-state-hover" );
		this.focusable.removeClass( "ui-state-focus" );
	},
	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key,
			parts,
			curOption,
			i;

		if ( arguments.length === 0 ) {
			// don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {
			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( arguments.length === 1 ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( arguments.length === 1 ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this.widget()
				.toggleClass( this.widgetFullName + "-disabled ui-state-disabled", !!value )
				.attr( "aria-disabled", value );
			this.hoverable.removeClass( "ui-state-hover" );
			this.focusable.removeClass( "ui-state-focus" );
		}

		return this;
	},

	enable: function() {
		return this._setOption( "disabled", false );
	},
	disable: function() {
		return this._setOption( "disabled", true );
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement,
			instance = this;

		// no suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// no element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			// accept selectors, DOM elements
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {
				// allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
							$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^(\w+)\s*(.*)$/ ),
				eventName = match[1] + instance.eventNamespace,
				selector = match[2];
			if ( selector ) {
				delegateElement.delegate( selector, eventName, handlerProxy );
			} else {
				element.bind( eventName, handlerProxy );
			}
		});
	},

	_off: function( element, eventName ) {
		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;
		element.unbind( eventName ).undelegate( eventName );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-hover" );
			},
			mouseleave: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-hover" );
			}
		});
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-focus" );
			},
			focusout: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-focus" );
			}
		});
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		// the original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}
		var hasOptions,
			effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;
		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}
		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;
		if ( options.delay ) {
			element.delay( options.delay );
		}
		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue(function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			});
		}
	};
});

}));

},{}],137:[function(require,module,exports){
/**
 * version 2.1.30
 * @license
 * =========================================================
 * bootstrap-datetimepicker.js
 * http://www.eyecon.ro/bootstrap-datepicker
 * =========================================================
 * Copyright 2012 Stefan Petre
 *
 * Contributions:
 * - updated for Bootstrap v3 by Jonathan Peterson (@Eonasdan) and (almost)
 *    completely rewritten to use Momentjs
 * - based on tarruda's bootstrap-datepicker
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =========================================================
 */
; (function (factory) {
    if (typeof define === 'function' && define.amd) {
    // AMD is used - Register as an anonymous module.
        define(['jquery', 'moment'], factory);
    } else {
        // AMD is not used - Attempt to fetch dependencies from scope.
        if(!jQuery){
            throw 'bootstrap-datetimepicker requires jQuery to be loaded first';
        }else if(!moment) {
            throw 'bootstrap-datetimepicker requires moment.js to be loaded first';
        }else{
            factory(jQuery, moment);
        }
    }
}

(function ($, moment) {
    if (typeof moment === 'undefined') {
        alert("momentjs is requried");
        throw new Error('momentjs is required');
    };

    var dpgId = 0,

    pMoment = moment,

// ReSharper disable once InconsistentNaming
    DateTimePicker = function (element, options) {
        var defaults = {
            pickDate: true,
            pickTime: true,
            useMinutes: true,
            useSeconds: false,
            minuteStepping: 1,
            startDate: new pMoment({ y: 1970 }),
            endDate: new pMoment().add(50, "y"),
            collapse: true,
            language: pMoment.lang(),
            defaultDate: "",
            disabledDates: [],
            enabledDates: false,
            icons: {},
            useStrict: false,
            direction: "auto"
        },

		icons = {
		    time: 'glyphicon glyphicon-time',
		    date: 'glyphicon glyphicon-calendar',
		    up: 'glyphicon glyphicon-chevron-up',
		    down: 'glyphicon glyphicon-chevron-down'
		},

        picker = this,

        init = function () {

            var icon = false, i, dDate, longDateFormat;
            picker.options = $.extend({}, defaults, options);
            picker.options.icons = $.extend({}, icons, picker.options.icons);

            picker.element = $(element);

            dataToOptions();

            if (!(picker.options.pickTime || picker.options.pickDate))
                throw new Error('Must choose at least one picker');

            picker.id = dpgId++;
            pMoment.lang(picker.options.language);
            picker.date = pMoment();
            picker.unset = false;
            picker.isInput = picker.element.is('input');
            picker.component = false;

            if (picker.element.hasClass('input-group')) {
                if (picker.element.find('.datepickerbutton').size() == 0) {//in case there is more then one 'input-group-addon` #48
                    picker.component = picker.element.find("[class^='input-group-']");
                }
                else {
                    picker.component = picker.element.find('.datepickerbutton');
                }
            }
            picker.format = picker.options.format;

            longDateFormat = pMoment()._lang._longDateFormat;

            if (!picker.format) {
                if (picker.isInput) picker.format = picker.element.data('format');
                else picker.format = picker.element.find('input').data('format');
                if (!picker.format) {
                    picker.format = (picker.options.pickDate ? longDateFormat.L : '');
                    if (picker.options.pickDate && picker.options.pickTime) picker.format += ' ';
                    picker.format += (picker.options.pickTime ? longDateFormat.LT : '');
                    if (picker.options.useSeconds) {
                        if (~longDateFormat.LT.indexOf(' A')) {
                            picker.format = picker.format.split(" A")[0] + ":ss A";
                        }
                        else {
                            picker.format += ':ss';
                        }
                    }
                }
            }

            picker.options.use24hours = picker.format.toLowerCase().indexOf("a") < 1;

            if (picker.component) icon = picker.component.find('span');

            if (picker.options.pickTime) {
                if (icon) icon.addClass(picker.options.icons.time);
            }
            if (picker.options.pickDate) {
                if (icon) {
                    icon.removeClass(picker.options.icons.time);
                    icon.addClass(picker.options.icons.date);
                }
            }

            picker.widget = $(getTemplate(picker.options.pickDate, picker.options.pickTime, picker.options.collapse)).appendTo('body');
            picker.minViewMode = picker.options.minViewMode || picker.element.data('date-minviewmode') || 0;
            if (typeof picker.minViewMode === 'string') {
                switch (picker.minViewMode) {
                    case 'months':
                        picker.minViewMode = 1;
                        break;
                    case 'years':
                        picker.minViewMode = 2;
                        break;
                    default:
                        picker.minViewMode = 0;
                        break;
                }
            }
            picker.viewMode = picker.options.viewMode || picker.element.data('date-viewmode') || 0;
            if (typeof picker.viewMode === 'string') {
                switch (picker.viewMode) {
                    case 'months':
                        picker.viewMode = 1;
                        break;
                    case 'years':
                        picker.viewMode = 2;
                        break;
                    default:
                        picker.viewMode = 0;
                        break;
                }
            }

            for (i = 0; i < picker.options.disabledDates.length; i++) {
                dDate = picker.options.disabledDates[i];
                dDate = pMoment(dDate);
                //if this is not a valid date then set it to the startdate -1 day so it's disabled.
                if (!dDate.isValid()) dDate = pMoment(picker.options.startDate).subtract(1, "day");
                picker.options.disabledDates[i] = dDate.format("L");
            }

            for (i = 0; i < picker.options.enabledDates.length; i++) {
                dDate = picker.options.enabledDates[i];
                dDate = pMoment(dDate);
                //if this is not a valid date then set it to the startdate -1 day so it's disabled.
                if (!dDate.isValid()) dDate = pMoment(picker.options.startDate).subtract(1, "day");
                picker.options.enabledDates[i] = dDate.format("L");
            }
            picker.startViewMode = picker.viewMode;
            picker.setStartDate(picker.options.startDate || picker.element.data('date-startdate'));
            picker.setEndDate(picker.options.endDate || picker.element.data('date-enddate'));
            fillDow();
            fillMonths();
            fillHours();
            fillMinutes();
			fillSeconds();
            update();
            showMode();
            attachDatePickerEvents();
            if (picker.options.defaultDate !== "") picker.setValue(picker.options.defaultDate);
        },

        dataToOptions = function () {
            var eData = picker.element.data();
            if (eData.pickdate !== undefined) picker.options.pickDate = eData.pickdate;
            if (eData.picktime !== undefined) picker.options.pickTime = eData.picktime;
            if (eData.useminutes !== undefined) picker.options.useMinutes = eData.useminutes;
            if (eData.useseconds !== undefined) picker.options.useSeconds = eData.useseconds;
            if (eData.minutestepping !== undefined) picker.options.minuteStepping = eData.minutestepping;
            if (eData.startdate !== undefined) picker.options.startDate = eData.startdate;
            if (eData.enddate !== undefined) picker.options.endDate = eData.enddate;
            if (eData.collapse !== undefined) picker.options.collapse = eData.collapse;
            if (eData.language !== undefined) picker.options.language = eData.language;
            if (eData.defaultdate !== undefined) picker.options.defaultDate = eData.defaultdate;
            if (eData.disableddates !== undefined) picker.options.disabledDates = eData.disableddates;
            if (eData.enableddates !== undefined) picker.options.enabledDates = eData.enableddates;
            if (eData.icons !== undefined) picker.options.icons = eData.icons;
            if (eData.usestrict !== undefined) picker.options.useStrict = eData.usestrict;
        },

        place = function () {
            var position = 'absolute',
            offset = picker.component ? picker.component.offset() : picker.element.offset(), $window = $(window);
            picker.width = picker.component ? picker.component.outerWidth() : picker.element.outerWidth();
            offset.top = offset.top + picker.element.outerHeight();
            
            // if (picker.options.direction === 'up' || picker.options.direction === 'auto' && offset.top + picker.widget.height() > $window.height()) {
        		// offset.top -= picker.widget.height() + picker.element.outerHeight();
            	// picker.widget.addClass('up');
            // } else if (picker.options.direction === 'down' || picker.options.direction === 'auto' && offset.top + picker.widget.height() <= $window.height()) {
            	// offset.top += picker.element.outerHeight();
            	// picker.widget.addClass('down');
            // }

            if (picker.options.width !== undefined) {
                picker.widget.width(picker.options.width);
            }

            if (picker.options.orientation === 'left') {
                picker.widget.addClass('left-oriented');
                offset.left = offset.left - picker.widget.width() + 20;
            }

            if (isInFixed()) {
                position = 'fixed';
                offset.top -= $window.scrollTop();
                offset.left -= $window.scrollLeft();
            }

            if ($window.width() < offset.left + picker.widget.outerWidth()) {
                offset.right = $window.width() - offset.left - picker.width;
                offset.left = 'auto';
                picker.widget.addClass('pull-right');
            } else {
                offset.right = 'auto';
                picker.widget.removeClass('pull-right');
            }

            picker.widget.css({
                position: position,
                top: offset.top,
                left: offset.left,
                right: offset.right
            });
        },

        notifyChange = function (oldDate, eventType) {
            picker.element.trigger({
                type: 'change.dp',
                date: pMoment(picker.date),
                oldDate: pMoment(oldDate)
            });

            if (eventType !== 'change')
                picker.element.change();
        },

		notifyError = function (date) {
		    picker.element.trigger({
		        type: 'error.dp',
		        date: pMoment(date)
		    });
		},

        update = function (newDate) {
            pMoment.lang(picker.options.language);
            var dateStr = newDate;
            if (!dateStr) {
                if (picker.isInput) {
                    dateStr = picker.element.val();
                } else {
                    dateStr = picker.element.find('input').val();
                }
                if (dateStr) picker.date = pMoment(dateStr, picker.format, picker.options.useStrict);
                if (!picker.date) picker.date = pMoment();
            }
            picker.viewDate = pMoment(picker.date).startOf("month");
            fillDate();
            fillTime();
        },

		fillDow = function () {
		    pMoment.lang(picker.options.language);
		    var html = $('<tr>'), weekdaysMin = pMoment.weekdaysMin(), i;
		    if (pMoment()._lang._week.dow == 0) { // starts on Sunday
		        for(i = 0; i < 7; i++) {
		            html.append('<th class="dow">' + weekdaysMin[i] + '</th>');
		        }
		    } else {
		        for (i = 1; i < 8; i++) {
		            if (i == 7) {
		                html.append('<th class="dow">' + weekdaysMin[0] + '</th>');
		            } else {
		                html.append('<th class="dow">' + weekdaysMin[i] + '</th>');
		            }
		        }
		    }
		    picker.widget.find('.datepicker-days thead').append(html);
		},

        fillMonths = function () {
            pMoment.lang(picker.options.language);
            var html = '', i = 0, monthsShort = pMoment.monthsShort();
            while (i < 12) {
                html += '<span class="month">' + monthsShort[i++] + '</span>';
            }
            picker.widget.find('.datepicker-months td').append(html);
        },

        fillDate = function () {
            pMoment.lang(picker.options.language);
            var year = picker.viewDate.year(),
                month = picker.viewDate.month(),
                startYear = picker.options.startDate.year(),
                startMonth = picker.options.startDate.month(),
                endYear = picker.options.endDate.year(),
                endMonth = picker.options.endDate.month(),
                prevMonth, nextMonth, html = [], row, clsName, i, days, yearCont, currentYear, months = pMoment.months();

            picker.widget.find('.datepicker-days').find('.disabled').removeClass('disabled');
            picker.widget.find('.datepicker-months').find('.disabled').removeClass('disabled');
            picker.widget.find('.datepicker-years').find('.disabled').removeClass('disabled');

            picker.widget.find('.datepicker-days th:eq(1)').text(
                months[month] + ' ' + year);

            prevMonth = pMoment(picker.viewDate).subtract("months", 1);
            days = prevMonth.daysInMonth();
            prevMonth.date(days).startOf('week');
            if ((year == startYear && month <= startMonth) || year < startYear) {
                picker.widget.find('.datepicker-days th:eq(0)').addClass('disabled');
            }
            if ((year == endYear && month >= endMonth) || year > endYear) {
                picker.widget.find('.datepicker-days th:eq(2)').addClass('disabled');
            }

            nextMonth = pMoment(prevMonth).add(42, "d");
            while (prevMonth.isBefore(nextMonth)) {
                if (prevMonth.weekday() === pMoment().startOf('week').weekday()) {
                    row = $('<tr>');
                    html.push(row);
                }
                clsName = '';
                if (prevMonth.year() < year || (prevMonth.year() == year && prevMonth.month() < month)) {
                    clsName += ' old';
                } else if (prevMonth.year() > year || (prevMonth.year() == year && prevMonth.month() > month)) {
                    clsName += ' new';
                }
                if (prevMonth.isSame(pMoment({ y: picker.date.year(), M: picker.date.month(), d: picker.date.date() }))) {
                    clsName += ' active';
                }
                if (isInDisableDates(prevMonth) || !isInEnableDates(prevMonth)) {
                    clsName += ' disabled';
                }
                row.append('<td class="day' + clsName + '">' + prevMonth.date() + '</td>');
                prevMonth.add(1, "d");
            }
            picker.widget.find('.datepicker-days tbody').empty().append(html);
            currentYear = pMoment().year(), months = picker.widget.find('.datepicker-months')
				.find('th:eq(1)').text(year).end().find('span').removeClass('active');
            if (currentYear === year) {
                months.eq(pMoment().month()).addClass('active');
            }
            if (currentYear - 1 < startYear) {
                picker.widget.find('.datepicker-months th:eq(0)').addClass('disabled');
            }
            if (currentYear + 1 > endYear) {
                picker.widget.find('.datepicker-months th:eq(2)').addClass('disabled');
            }
            for (i = 0; i < 12; i++) {
                if ((year == startYear && startMonth > i) || (year < startYear)) {
                    $(months[i]).addClass('disabled');
                } else if ((year == endYear && endMonth < i) || (year > endYear)) {
                    $(months[i]).addClass('disabled');
                }
            }

            html = '';
            year = parseInt(year / 10, 10) * 10;
            yearCont = picker.widget.find('.datepicker-years').find(
                'th:eq(1)').text(year + '-' + (year + 9)).end().find('td');
            picker.widget.find('.datepicker-years').find('th').removeClass('disabled');
            if (startYear > year) {
                picker.widget.find('.datepicker-years').find('th:eq(0)').addClass('disabled');
            }
            if (endYear < year + 9) {
                picker.widget.find('.datepicker-years').find('th:eq(2)').addClass('disabled');
            }
            year -= 1;
            for (i = -1; i < 11; i++) {
                html += '<span class="year' + (i === -1 || i === 10 ? ' old' : '') + (currentYear === year ? ' active' : '') + ((year < startYear || year > endYear) ? ' disabled' : '') + '">' + year + '</span>';
                year += 1;
            }
            yearCont.html(html);
        },

        fillHours = function () {
            pMoment.lang(picker.options.language);
            var table = picker.widget.find('.timepicker .timepicker-hours table'), html = '', current, i, j;
            table.parent().hide();
            if (picker.options.use24hours) {
                current = 0;
                for (i = 0; i < 6; i += 1) {
                    html += '<tr>';
                    for (j = 0; j < 4; j += 1) {
                        html += '<td class="hour">' + padLeft(current.toString()) + '</td>';
                        current++;
                    }
                    html += '</tr>';
                }
            }
            else {
                current = 1;
                for (i = 0; i < 3; i += 1) {
                    html += '<tr>';
                    for (j = 0; j < 4; j += 1) {
                        html += '<td class="hour">' + padLeft(current.toString()) + '</td>';
                        current++;
                    }
                    html += '</tr>';
                }
            }
            table.html(html);
        },

        fillMinutes = function () {
            var table = picker.widget.find('.timepicker .timepicker-minutes table'), html = '', current = 0, i, j;
            table.parent().hide();
            for (i = 0; i < 5; i++) {
                html += '<tr>';
                for (j = 0; j < 4; j += 1) {
                    html += '<td class="minute">' + padLeft(current.toString()) + '</td>';
                    current += 3;
                }
                html += '</tr>';
            }
            table.html(html);
        },

        fillSeconds = function () {
            var table = picker.widget.find('.timepicker .timepicker-seconds table'), html = '', current = 0, i, j;
            table.parent().hide();
            for (i = 0; i < 5; i++) {
                html += '<tr>';
                for (j = 0; j < 4; j += 1) {
                  html += '<td class="second">' + padLeft(current.toString()) + '</td>';
                  current += 3;
                }
                html += '</tr>';
            }
            table.html(html);
        },

        fillTime = function () {
            if (!picker.date) return;
            var timeComponents = picker.widget.find('.timepicker span[data-time-component]'),
            hour = picker.date.hours(),
            period = 'AM';
            if (!picker.options.use24hours) {
                if (hour >= 12) period = 'PM';
                if (hour === 0) hour = 12;
                else if (hour != 12) hour = hour % 12;
                picker.widget.find('.timepicker [data-action=togglePeriod]').text(period);
            }
            timeComponents.filter('[data-time-component=hours]').text(padLeft(hour));
            timeComponents.filter('[data-time-component=minutes]').text(padLeft(picker.date.minutes()));
            timeComponents.filter('[data-time-component=seconds]').text(padLeft(picker.date.second()));
        },

        click = function (e) {
            e.stopPropagation();
            e.preventDefault();
            picker.unset = false;
            var target = $(e.target).closest('span, td, th'), month, year, step, day, oldDate = pMoment(picker.date);
            if (target.length === 1) {
                if (!target.is('.disabled')) {
                    switch (target[0].nodeName.toLowerCase()) {
                        case 'th':
                            switch (target[0].className) {
                                case 'switch':
                                    showMode(1);
                                    break;
                                case 'prev':
                                case 'next':
                                    step = dpGlobal.modes[picker.viewMode].navStep;
                                    if (target[0].className === 'prev') step = step * -1;
                                    picker.viewDate.add(step, dpGlobal.modes[picker.viewMode].navFnc);
                                    fillDate();
                                    break;
                            }
                            break;
                        case 'span':
                            if (target.is('.month')) {
                                month = target.parent().find('span').index(target);
                                picker.viewDate.month(month);
                            } else {
                                year = parseInt(target.text(), 10) || 0;
                                picker.viewDate.year(year);
                            }
                            if (picker.viewMode !== 0) {
                                picker.date = pMoment({
                                    y: picker.viewDate.year(),
                                    M: picker.viewDate.month(),
                                    d: picker.viewDate.date(),
                                    h: picker.date.hours(),
                                    m: picker.date.minutes()
                                });
                                notifyChange(oldDate, e.type);
                            }
                            showMode(-1);
                            fillDate();
                            break;
                        case 'td':
                            if (target.is('.day')) {
                                day = parseInt(target.text(), 10) || 1;
                                month = picker.viewDate.month();
                                year = picker.viewDate.year();
                                if (target.is('.old')) {
                                    if (month === 0) {
                                        month = 11;
                                        year -= 1;
                                    } else {
                                        month -= 1;
                                    }
                                } else if (target.is('.new')) {
                                    if (month == 11) {
                                        month = 0;
                                        year += 1;
                                    } else {
                                        month += 1;
                                    }
                                }
                                picker.date = pMoment({
                                    y: year,
                                    M: month,
                                    d: day,
                                    h: picker.date.hours(),
                                    m: picker.date.minutes()
                                }
                                );
                                picker.viewDate = pMoment({
                                    y: year, M: month, d: Math.min(28, day)
                                });
                                fillDate();
                                set();
                                notifyChange(oldDate, e.type);
                            }
                            break;
                    }
                }
            }
        },

		actions = {
		    incrementHours: function () {
		        checkDate("add", "hours", 1);
		    },

		    incrementMinutes: function () {
		        checkDate("add", "minutes", picker.options.minuteStepping);
		    },

		    incrementSeconds: function () {
		        checkDate("add", "seconds", 1);
		    },

		    decrementHours: function () {
		        checkDate("subtract", "hours", 1);
		    },

		    decrementMinutes: function () {
		        checkDate("subtract", "minutes", picker.options.minuteStepping);
		    },

		    decrementSeconds: function () {
		        checkDate("subtract", "seconds", 1);
		    },

		    togglePeriod: function () {
		        var hour = picker.date.hours();
		        if (hour >= 12) hour -= 12;
		        else hour += 12;
		        picker.date.hours(hour);
		    },

		    showPicker: function () {
		        picker.widget.find('.timepicker > div:not(.timepicker-picker)').hide();
		        picker.widget.find('.timepicker .timepicker-picker').show();
		    },

		    showHours: function () {
		        picker.widget.find('.timepicker .timepicker-picker').hide();
		        picker.widget.find('.timepicker .timepicker-hours').show();
		    },

		    showMinutes: function () {
		        picker.widget.find('.timepicker .timepicker-picker').hide();
		        picker.widget.find('.timepicker .timepicker-minutes').show();
		    },

		    showSeconds: function () {
		        picker.widget.find('.timepicker .timepicker-picker').hide();
		        picker.widget.find('.timepicker .timepicker-seconds').show();
		    },

		    selectHour: function (e) {
		        picker.date.hours(parseInt($(e.target).text(), 10));
		        actions.showPicker.call(picker);
		    },

		    selectMinute: function (e) {
		        picker.date.minutes(parseInt($(e.target).text(), 10));
		        actions.showPicker.call(picker);
		    },

		    selectSecond: function (e) {
		        picker.date.seconds(parseInt($(e.target).text(), 10));
		        actions.showPicker.call(picker);
		    }
		},

	    doAction = function (e) {
	        var oldDate = pMoment(picker.date), action = $(e.currentTarget).data('action'), rv = actions[action].apply(picker, arguments);
	        stopEvent(e);
	        if (!picker.date) picker.date = pMoment({ y: 1970 });
	        set();
	        fillTime();
	        notifyChange(oldDate, e.type);
	        return rv;
	    },

        stopEvent = function (e) {
            e.stopPropagation();
            e.preventDefault();
        },

        change = function (e) {
            pMoment.lang(picker.options.language);
            var input = $(e.target), oldDate = pMoment(picker.date), newDate = pMoment(input.val(), picker.format, picker.options.useStrict);
            if (newDate.isValid() && !isInDisableDates(newDate) && isInEnableDates(newDate)) {
                update();
                picker.setValue(newDate);
                notifyChange(oldDate, e.type);
                set();
            }
            else {
                picker.viewDate = oldDate;
                input.val(pMoment(oldDate).format(picker.format));
                //picker.setValue(""); // unset the date when the input is erased
                notifyChange(oldDate, e.type);
                notifyError(newDate);
                picker.unset = true;
            }
        },

        showMode = function (dir) {
            if (dir) {
                picker.viewMode = Math.max(picker.minViewMode, Math.min(2, picker.viewMode + dir));
            }

            picker.widget.find('.datepicker > div').hide().filter('.datepicker-' + dpGlobal.modes[picker.viewMode].clsName).show();
        },

        attachDatePickerEvents = function () {
            var $this, $parent, expanded, closed, collapseData;
            picker.widget.on('click', '.datepicker *', $.proxy(click, this)); // this handles date picker clicks
            picker.widget.on('click', '[data-action]', $.proxy(doAction, this)); // this handles time picker clicks
            picker.widget.on('mousedown', $.proxy(stopEvent, this));
            if (picker.options.pickDate && picker.options.pickTime) {
                picker.widget.on('click.togglePicker', '.accordion-toggle', function (e) {
                    e.stopPropagation();
                    $this = $(this);
                    $parent = $this.closest('ul');
                    expanded = $parent.find('.in');
                    closed = $parent.find('.collapse:not(.in)');

                    if (expanded && expanded.length) {
                        collapseData = expanded.data('collapse');
                        if (collapseData && collapseData.transitioning) return;
                        expanded.collapse('hide');
                        closed.collapse('show');
                        $this.find('span').toggleClass(picker.options.icons.time + ' ' + picker.options.icons.date);
                        picker.element.find('.input-group-addon span').toggleClass(picker.options.icons.time + ' ' + picker.options.icons.date);
                    }
                });
            }
            if (picker.isInput) {
                picker.element.on({
                    'focus': $.proxy(picker.show, this),
                    'change': $.proxy(change, this),
                    'blur': $.proxy(picker.hide, this)
                });
            } else {
                picker.element.on({
                    'change': $.proxy(change, this)
                }, 'input');
                if (picker.component) {
                    picker.component.on('click', $.proxy(picker.show, this));
                } else {
                    picker.element.on('click', $.proxy(picker.show, this));
                }
            }
        },

        attachDatePickerGlobalEvents = function () {
            $(window).on(
                'resize.datetimepicker' + picker.id, $.proxy(place, this));
            if (!picker.isInput) {
                $(document).on(
                    'mousedown.datetimepicker' + picker.id, $.proxy(picker.hide, this));
            }
        },

        detachDatePickerEvents = function () {
            picker.widget.off('click', '.datepicker *', picker.click);
            picker.widget.off('click', '[data-action]');
            picker.widget.off('mousedown', picker.stopEvent);
            if (picker.options.pickDate && picker.options.pickTime) {
                picker.widget.off('click.togglePicker');
            }
            if (picker.isInput) {
                picker.element.off({
                    'focus': picker.show,
                    'change': picker.change
                });
            } else {
                picker.element.off({
                    'change': picker.change
                }, 'input');
                if (picker.component) {
                    picker.component.off('click', picker.show);
                } else {
                    picker.element.off('click', picker.show);
                }
            }
        },

        detachDatePickerGlobalEvents = function () {
            $(window).off('resize.datetimepicker' + picker.id);
            if (!picker.isInput) {
                $(document).off('mousedown.datetimepicker' + picker.id);
            }
        },

        isInFixed = function () {
            if (picker.element) {
                var parents = picker.element.parents(), inFixed = false, i;
                for (i = 0; i < parents.length; i++) {
                    if ($(parents[i]).css('position') == 'fixed') {
                        inFixed = true;
                        break;
                    }
                }
                ;
                return inFixed;
            } else {
                return false;
            }
        },

        set = function () {
            pMoment.lang(picker.options.language);
            var formatted = '', input;
            if (!picker.unset) formatted = pMoment(picker.date).format(picker.format);
            if (!picker.isInput) {
                if (picker.component) {
                    input = picker.element.find('input');
                    input.val(formatted);
                }
                picker.element.data('date', formatted);
            } else {
                picker.element.val(formatted);
            }
            if (!picker.options.pickTime) picker.hide();
        },

		checkDate = function (direction, unit, amount) {
		    pMoment.lang(picker.options.language);
		    var newDate;
		    if (direction == "add") {
		        newDate = pMoment(picker.date);
		        if (newDate.hours() == 23) newDate.add(amount, unit);
		        newDate.add(amount, unit);
		    }
		    else {
		        newDate = pMoment(picker.date).subtract(amount, unit);
		    }
		    if (isInDisableDates(pMoment(newDate.subtract(amount, unit))) || isInDisableDates(newDate)) {
		        notifyError(newDate.format(picker.format));
		        return;
		    }

		    if (direction == "add") {
		        picker.date.add(amount, unit);
		    }
		    else {
		        picker.date.subtract(amount, unit);
		    }
            picker.unset = false;
		},

		isInDisableDates = function (date) {
		    pMoment.lang(picker.options.language);
            if (date.isAfter(picker.options.endDate) || date.isBefore(picker.options.startDate)) return true;
		    var disabled = picker.options.disabledDates, i;
		    for (i in disabled) {
		        if (disabled[i] == pMoment(date).format("L")) {
		            return true;
		        }
		    }
		    return false;
		},

        isInEnableDates = function (date) {
            pMoment.lang(picker.options.language);
            var enabled = picker.options.enabledDates, i;
            if (enabled.length) {
                for (i in enabled) {
                    if (enabled[i] == pMoment(date).format("L")) {
                        return true;
                    }
                }
                return false;
            }
            return enabled === false ? true : false;
        },
        padLeft = function (string) {
            string = string.toString();
            if (string.length >= 2) return string;
            else return '0' + string;
        },

        getTemplate = function (pickDate, pickTime, collapse) {
            if (pickDate && pickTime) {
                return (
                    '<div class="bootstrap-datetimepicker-widget dropdown-menu" style="z-index:9999 !important;">' +
                        '<ul class="list-unstyled">' +
							'<li' + (collapse ? ' class="collapse in"' : '') + '>' +
								'<div class="datepicker">' + dpGlobal.template + '</div>' +
							'</li>' +
							'<li class="picker-switch accordion-toggle"><a class="btn" style="width:100%"><span class="' + picker.options.icons.time + '"></span></a></li>' +
							'<li' + (collapse ? ' class="collapse"' : '') + '>' +
								'<div class="timepicker">' + tpGlobal.getTemplate() + '</div>' +
							'</li>' +
                        '</ul>' +
                    '</div>'
                );
            } else if (pickTime) {
                return (
                    '<div class="bootstrap-datetimepicker-widget dropdown-menu">' +
                        '<div class="timepicker">' + tpGlobal.getTemplate() + '</div>' +
                    '</div>'
                );
            } else {
                return (
                    '<div class="bootstrap-datetimepicker-widget dropdown-menu">' +
                        '<div class="datepicker">' + dpGlobal.template + '</div>' +
                    '</div>'
                );
            }
        },

		dpGlobal = {
		    modes: [
                {
                    clsName: 'days',
                    navFnc: 'month',
                    navStep: 1
                },
                {
                    clsName: 'months',
                    navFnc: 'year',
                    navStep: 1
                },
                {
                    clsName: 'years',
                    navFnc: 'year',
                    navStep: 10
                }],
		    headTemplate:
                    '<thead>' +
						'<tr>' +
							'<th class="prev">&lsaquo;</th><th colspan="5" class="switch"></th><th class="next">&rsaquo;</th>' +
						'</tr>' +
                    '</thead>',
		    contTemplate:
        '<tbody><tr><td colspan="7"></td></tr></tbody>'
		},

        tpGlobal = {
            hourTemplate:   '<span data-action="showHours"   data-time-component="hours"   class="timepicker-hour"></span>',
            minuteTemplate: '<span data-action="showMinutes" data-time-component="minutes" class="timepicker-minute"></span>',
			secondTemplate: '<span data-action="showSeconds"  data-time-component="seconds" class="timepicker-second"></span>'
        };

        dpGlobal.template =
            '<div class="datepicker-days">' +
                '<table class="table-condensed">' + dpGlobal.headTemplate + '<tbody></tbody></table>' +
            '</div>' +
            '<div class="datepicker-months">' +
                '<table class="table-condensed">' + dpGlobal.headTemplate + dpGlobal.contTemplate + '</table>' +
            '</div>' +
            '<div class="datepicker-years">' +
				'<table class="table-condensed">' + dpGlobal.headTemplate + dpGlobal.contTemplate + '</table>' +
            '</div>';

        tpGlobal.getTemplate = function () {
            return (
                '<div class="timepicker-picker">' +
                    '<table class="table-condensed">' +
						'<tr>' +
							'<td><a href="#" class="btn" data-action="incrementHours"><span class="' + picker.options.icons.up + '"></span></a></td>' +
							'<td class="separator"></td>' +
							'<td>' + (picker.options.useMinutes ? '<a href="#" class="btn" data-action="incrementMinutes"><span class="' + picker.options.icons.up + '"></span></a>' : '') + '</td>' +
                            (picker.options.useSeconds ?
                                '<td class="separator"></td><td><a href="#" class="btn" data-action="incrementSeconds"><span class="' + picker.options.icons.up + '"></span></a></td>' : '') +
							(picker.options.use24hours ? '' : '<td class="separator"></td>') +
						'</tr>' +
						'<tr>' +
							'<td>' + tpGlobal.hourTemplate + '</td> ' +
							'<td class="separator">:</td>' +
							'<td>' + (picker.options.useMinutes ? tpGlobal.minuteTemplate : '<span class="timepicker-minute">00</span>') + '</td> ' +
                            (picker.options.useSeconds ?
                                '<td class="separator">:</td><td>' + tpGlobal.secondTemplate + '</td>' : '') +
							(picker.options.use24hours ? '' : '<td class="separator"></td>' +
							'<td><button type="button" class="btn btn-primary" data-action="togglePeriod"></button></td>') +
						'</tr>' +
						'<tr>' +
							'<td><a href="#" class="btn" data-action="decrementHours"><span class="' + picker.options.icons.down + '"></span></a></td>' +
							'<td class="separator"></td>' +
							'<td>' + (picker.options.useMinutes ? '<a href="#" class="btn" data-action="decrementMinutes"><span class="' + picker.options.icons.down + '"></span></a>' : '') + '</td>' +
                            (picker.options.useSeconds ?
                                '<td class="separator"></td><td><a href="#" class="btn" data-action="decrementSeconds"><span class="' + picker.options.icons.down + '"></span></a></td>' : '') +
							(picker.options.use24hours ? '' : '<td class="separator"></td>') +
						'</tr>' +
                    '</table>' +
                '</div>' +
                '<div class="timepicker-hours" data-action="selectHour">' +
                    '<table class="table-condensed"></table>' +
                '</div>' +
                '<div class="timepicker-minutes" data-action="selectMinute">' +
                    '<table class="table-condensed"></table>' +
                '</div>' +
                (picker.options.useSeconds ?
                    '<div class="timepicker-seconds" data-action="selectSecond"><table class="table-condensed"></table></div>' : '')
            );
        };

        picker.destroy = function () {
            detachDatePickerEvents();
            detachDatePickerGlobalEvents();
            picker.widget.remove();
            picker.element.removeData('DateTimePicker');
            if (picker.component)
                picker.component.removeData('DateTimePicker');
        };

        picker.show = function (e) {
            picker.widget.show();
            picker.height = picker.component ? picker.component.outerHeight() : picker.element.outerHeight();
            place();
            picker.element.trigger({
                type: 'show.dp',
                date: pMoment(picker.date)
            });
            attachDatePickerGlobalEvents();
            if (e) {
                stopEvent(e);
            }
        },

        picker.disable = function () {
            var input = picker.element.find('input');
            if(input.prop('disabled')) return;

            input.prop('disabled', true);
            detachDatePickerEvents();
        },

        picker.enable = function () {
            var input = picker.element.find('input');
            if(!input.prop('disabled')) return;

            input.prop('disabled', false);
            attachDatePickerEvents();
        },

        picker.hide = function (event) {
            if (event && $(event.target).is(picker.element.attr("id")))
                return;
            // Ignore event if in the middle of a picker transition
            var collapse = picker.widget.find('.collapse'), i, collapseData;
            for (i = 0; i < collapse.length; i++) {
                collapseData = collapse.eq(i).data('collapse');
                if (collapseData && collapseData.transitioning)
                    return;
            }
            picker.widget.hide();
            picker.viewMode = picker.startViewMode;
            showMode();
            picker.element.trigger({
                type: 'hide.dp',
                date: pMoment(picker.date)
            });
            detachDatePickerGlobalEvents();
        },

        picker.setValue = function (newDate) {
            pMoment.lang(picker.options.language);
            if (!newDate) {
                picker.unset = true;
            } else {
                picker.unset = false;
            }
            if (!pMoment.isMoment(newDate)) newDate = pMoment(newDate);
            if (newDate.isValid()) {
                picker.date = newDate;
                set();
                picker.viewDate = pMoment({ y: picker.date.year(), M: picker.date.month() });
                fillDate();
                fillTime();
            }
            else {
                notifyError(newDate);
            }
        },

        picker.getDate = function () {
            if (picker.unset) return null;
            return picker.date;
        },

        picker.setDate = function (date) {
            date = pMoment(date);
            if (!date) picker.setValue(null);
            else picker.setValue(date);
        },

        picker.setEnabledDates = function (dates) {
            if (!dates) picker.options.enabledDates = false;
            else picker.options.enabledDates = dates;
            if (picker.viewDate) update();
        },

        picker.setEndDate = function (date) {
            if (date == undefined) return;
            picker.options.endDate = pMoment(date);
            if (picker.viewDate) update();
        },

        picker.setStartDate = function (date) {
            if (date == undefined) return;
            picker.options.startDate = pMoment(date);
            if (picker.viewDate) update();
        };

        init();
    };

    $.fn.datetimepicker = function (options) {
        return this.each(function () {
            var $this = $(this), data = $this.data('DateTimePicker');
            if (!data) $this.data('DateTimePicker', new DateTimePicker(this, options));
        });
    };
}));
},{}],138:[function(require,module,exports){
// This file is autogenerated via the `commonjs` Grunt task. You can require() this file in a CommonJS environment.
require('../../js/transition.js')
require('../../js/alert.js')
require('../../js/button.js')
require('../../js/carousel.js')
require('../../js/collapse.js')
require('../../js/dropdown.js')
require('../../js/modal.js')
require('../../js/tooltip.js')
require('../../js/popover.js')
require('../../js/scrollspy.js')
require('../../js/tab.js')
require('../../js/affix.js')
},{"../../js/affix.js":139,"../../js/alert.js":140,"../../js/button.js":141,"../../js/carousel.js":142,"../../js/collapse.js":143,"../../js/dropdown.js":144,"../../js/modal.js":145,"../../js/popover.js":146,"../../js/scrollspy.js":147,"../../js/tab.js":148,"../../js/tooltip.js":149,"../../js/transition.js":150}],139:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: affix.js v3.3.4
 * http://getbootstrap.com/javascript/#affix
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // AFFIX CLASS DEFINITION
  // ======================

  var Affix = function (element, options) {
    this.options = $.extend({}, Affix.DEFAULTS, options)

    this.$target = $(this.options.target)
      .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))
      .on('click.bs.affix.data-api',  $.proxy(this.checkPositionWithEventLoop, this))

    this.$element     = $(element)
    this.affixed      = null
    this.unpin        = null
    this.pinnedOffset = null

    this.checkPosition()
  }

  Affix.VERSION  = '3.3.4'

  Affix.RESET    = 'affix affix-top affix-bottom'

  Affix.DEFAULTS = {
    offset: 0,
    target: window
  }

  Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {
    var scrollTop    = this.$target.scrollTop()
    var position     = this.$element.offset()
    var targetHeight = this.$target.height()

    if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false

    if (this.affixed == 'bottom') {
      if (offsetTop != null) return (scrollTop + this.unpin <= position.top) ? false : 'bottom'
      return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : 'bottom'
    }

    var initializing   = this.affixed == null
    var colliderTop    = initializing ? scrollTop : position.top
    var colliderHeight = initializing ? targetHeight : height

    if (offsetTop != null && scrollTop <= offsetTop) return 'top'
    if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom)) return 'bottom'

    return false
  }

  Affix.prototype.getPinnedOffset = function () {
    if (this.pinnedOffset) return this.pinnedOffset
    this.$element.removeClass(Affix.RESET).addClass('affix')
    var scrollTop = this.$target.scrollTop()
    var position  = this.$element.offset()
    return (this.pinnedOffset = position.top - scrollTop)
  }

  Affix.prototype.checkPositionWithEventLoop = function () {
    setTimeout($.proxy(this.checkPosition, this), 1)
  }

  Affix.prototype.checkPosition = function () {
    if (!this.$element.is(':visible')) return

    var height       = this.$element.height()
    var offset       = this.options.offset
    var offsetTop    = offset.top
    var offsetBottom = offset.bottom
    var scrollHeight = $(document.body).height()

    if (typeof offset != 'object')         offsetBottom = offsetTop = offset
    if (typeof offsetTop == 'function')    offsetTop    = offset.top(this.$element)
    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element)

    var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)

    if (this.affixed != affix) {
      if (this.unpin != null) this.$element.css('top', '')

      var affixType = 'affix' + (affix ? '-' + affix : '')
      var e         = $.Event(affixType + '.bs.affix')

      this.$element.trigger(e)

      if (e.isDefaultPrevented()) return

      this.affixed = affix
      this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null

      this.$element
        .removeClass(Affix.RESET)
        .addClass(affixType)
        .trigger(affixType.replace('affix', 'affixed') + '.bs.affix')
    }

    if (affix == 'bottom') {
      this.$element.offset({
        top: scrollHeight - height - offsetBottom
      })
    }
  }


  // AFFIX PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.affix')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.affix', (data = new Affix(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.affix

  $.fn.affix             = Plugin
  $.fn.affix.Constructor = Affix


  // AFFIX NO CONFLICT
  // =================

  $.fn.affix.noConflict = function () {
    $.fn.affix = old
    return this
  }


  // AFFIX DATA-API
  // ==============

  $(window).on('load', function () {
    $('[data-spy="affix"]').each(function () {
      var $spy = $(this)
      var data = $spy.data()

      data.offset = data.offset || {}

      if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom
      if (data.offsetTop    != null) data.offset.top    = data.offsetTop

      Plugin.call($spy, data)
    })
  })

}(jQuery);

},{}],140:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: alert.js v3.3.4
 * http://getbootstrap.com/javascript/#alerts
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // ALERT CLASS DEFINITION
  // ======================

  var dismiss = '[data-dismiss="alert"]'
  var Alert   = function (el) {
    $(el).on('click', dismiss, this.close)
  }

  Alert.VERSION = '3.3.4'

  Alert.TRANSITION_DURATION = 150

  Alert.prototype.close = function (e) {
    var $this    = $(this)
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = $(selector)

    if (e) e.preventDefault()

    if (!$parent.length) {
      $parent = $this.closest('.alert')
    }

    $parent.trigger(e = $.Event('close.bs.alert'))

    if (e.isDefaultPrevented()) return

    $parent.removeClass('in')

    function removeElement() {
      // detach from parent, fire event then clean up data
      $parent.detach().trigger('closed.bs.alert').remove()
    }

    $.support.transition && $parent.hasClass('fade') ?
      $parent
        .one('bsTransitionEnd', removeElement)
        .emulateTransitionEnd(Alert.TRANSITION_DURATION) :
      removeElement()
  }


  // ALERT PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.alert')

      if (!data) $this.data('bs.alert', (data = new Alert(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  var old = $.fn.alert

  $.fn.alert             = Plugin
  $.fn.alert.Constructor = Alert


  // ALERT NO CONFLICT
  // =================

  $.fn.alert.noConflict = function () {
    $.fn.alert = old
    return this
  }


  // ALERT DATA-API
  // ==============

  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)

}(jQuery);

},{}],141:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: button.js v3.3.4
 * http://getbootstrap.com/javascript/#buttons
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // BUTTON PUBLIC CLASS DEFINITION
  // ==============================

  var Button = function (element, options) {
    this.$element  = $(element)
    this.options   = $.extend({}, Button.DEFAULTS, options)
    this.isLoading = false
  }

  Button.VERSION  = '3.3.4'

  Button.DEFAULTS = {
    loadingText: 'loading...'
  }

  Button.prototype.setState = function (state) {
    var d    = 'disabled'
    var $el  = this.$element
    var val  = $el.is('input') ? 'val' : 'html'
    var data = $el.data()

    state = state + 'Text'

    if (data.resetText == null) $el.data('resetText', $el[val]())

    // push to event loop to allow forms to submit
    setTimeout($.proxy(function () {
      $el[val](data[state] == null ? this.options[state] : data[state])

      if (state == 'loadingText') {
        this.isLoading = true
        $el.addClass(d).attr(d, d)
      } else if (this.isLoading) {
        this.isLoading = false
        $el.removeClass(d).removeAttr(d)
      }
    }, this), 0)
  }

  Button.prototype.toggle = function () {
    var changed = true
    var $parent = this.$element.closest('[data-toggle="buttons"]')

    if ($parent.length) {
      var $input = this.$element.find('input')
      if ($input.prop('type') == 'radio') {
        if ($input.prop('checked') && this.$element.hasClass('active')) changed = false
        else $parent.find('.active').removeClass('active')
      }
      if (changed) $input.prop('checked', !this.$element.hasClass('active')).trigger('change')
    } else {
      this.$element.attr('aria-pressed', !this.$element.hasClass('active'))
    }

    if (changed) this.$element.toggleClass('active')
  }


  // BUTTON PLUGIN DEFINITION
  // ========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.button')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.button', (data = new Button(this, options)))

      if (option == 'toggle') data.toggle()
      else if (option) data.setState(option)
    })
  }

  var old = $.fn.button

  $.fn.button             = Plugin
  $.fn.button.Constructor = Button


  // BUTTON NO CONFLICT
  // ==================

  $.fn.button.noConflict = function () {
    $.fn.button = old
    return this
  }


  // BUTTON DATA-API
  // ===============

  $(document)
    .on('click.bs.button.data-api', '[data-toggle^="button"]', function (e) {
      var $btn = $(e.target)
      if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn')
      Plugin.call($btn, 'toggle')
      e.preventDefault()
    })
    .on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^="button"]', function (e) {
      $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type))
    })

}(jQuery);

},{}],142:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: carousel.js v3.3.4
 * http://getbootstrap.com/javascript/#carousel
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CAROUSEL CLASS DEFINITION
  // =========================

  var Carousel = function (element, options) {
    this.$element    = $(element)
    this.$indicators = this.$element.find('.carousel-indicators')
    this.options     = options
    this.paused      = null
    this.sliding     = null
    this.interval    = null
    this.$active     = null
    this.$items      = null

    this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this))

    this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element
      .on('mouseenter.bs.carousel', $.proxy(this.pause, this))
      .on('mouseleave.bs.carousel', $.proxy(this.cycle, this))
  }

  Carousel.VERSION  = '3.3.4'

  Carousel.TRANSITION_DURATION = 600

  Carousel.DEFAULTS = {
    interval: 5000,
    pause: 'hover',
    wrap: true,
    keyboard: true
  }

  Carousel.prototype.keydown = function (e) {
    if (/input|textarea/i.test(e.target.tagName)) return
    switch (e.which) {
      case 37: this.prev(); break
      case 39: this.next(); break
      default: return
    }

    e.preventDefault()
  }

  Carousel.prototype.cycle = function (e) {
    e || (this.paused = false)

    this.interval && clearInterval(this.interval)

    this.options.interval
      && !this.paused
      && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))

    return this
  }

  Carousel.prototype.getItemIndex = function (item) {
    this.$items = item.parent().children('.item')
    return this.$items.index(item || this.$active)
  }

  Carousel.prototype.getItemForDirection = function (direction, active) {
    var activeIndex = this.getItemIndex(active)
    var willWrap = (direction == 'prev' && activeIndex === 0)
                || (direction == 'next' && activeIndex == (this.$items.length - 1))
    if (willWrap && !this.options.wrap) return active
    var delta = direction == 'prev' ? -1 : 1
    var itemIndex = (activeIndex + delta) % this.$items.length
    return this.$items.eq(itemIndex)
  }

  Carousel.prototype.to = function (pos) {
    var that        = this
    var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'))

    if (pos > (this.$items.length - 1) || pos < 0) return

    if (this.sliding)       return this.$element.one('slid.bs.carousel', function () { that.to(pos) }) // yes, "slid"
    if (activeIndex == pos) return this.pause().cycle()

    return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos))
  }

  Carousel.prototype.pause = function (e) {
    e || (this.paused = true)

    if (this.$element.find('.next, .prev').length && $.support.transition) {
      this.$element.trigger($.support.transition.end)
      this.cycle(true)
    }

    this.interval = clearInterval(this.interval)

    return this
  }

  Carousel.prototype.next = function () {
    if (this.sliding) return
    return this.slide('next')
  }

  Carousel.prototype.prev = function () {
    if (this.sliding) return
    return this.slide('prev')
  }

  Carousel.prototype.slide = function (type, next) {
    var $active   = this.$element.find('.item.active')
    var $next     = next || this.getItemForDirection(type, $active)
    var isCycling = this.interval
    var direction = type == 'next' ? 'left' : 'right'
    var that      = this

    if ($next.hasClass('active')) return (this.sliding = false)

    var relatedTarget = $next[0]
    var slideEvent = $.Event('slide.bs.carousel', {
      relatedTarget: relatedTarget,
      direction: direction
    })
    this.$element.trigger(slideEvent)
    if (slideEvent.isDefaultPrevented()) return

    this.sliding = true

    isCycling && this.pause()

    if (this.$indicators.length) {
      this.$indicators.find('.active').removeClass('active')
      var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])
      $nextIndicator && $nextIndicator.addClass('active')
    }

    var slidEvent = $.Event('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }) // yes, "slid"
    if ($.support.transition && this.$element.hasClass('slide')) {
      $next.addClass(type)
      $next[0].offsetWidth // force reflow
      $active.addClass(direction)
      $next.addClass(direction)
      $active
        .one('bsTransitionEnd', function () {
          $next.removeClass([type, direction].join(' ')).addClass('active')
          $active.removeClass(['active', direction].join(' '))
          that.sliding = false
          setTimeout(function () {
            that.$element.trigger(slidEvent)
          }, 0)
        })
        .emulateTransitionEnd(Carousel.TRANSITION_DURATION)
    } else {
      $active.removeClass('active')
      $next.addClass('active')
      this.sliding = false
      this.$element.trigger(slidEvent)
    }

    isCycling && this.cycle()

    return this
  }


  // CAROUSEL PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.carousel')
      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)
      var action  = typeof option == 'string' ? option : options.slide

      if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))
      if (typeof option == 'number') data.to(option)
      else if (action) data[action]()
      else if (options.interval) data.pause().cycle()
    })
  }

  var old = $.fn.carousel

  $.fn.carousel             = Plugin
  $.fn.carousel.Constructor = Carousel


  // CAROUSEL NO CONFLICT
  // ====================

  $.fn.carousel.noConflict = function () {
    $.fn.carousel = old
    return this
  }


  // CAROUSEL DATA-API
  // =================

  var clickHandler = function (e) {
    var href
    var $this   = $(this)
    var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) // strip for ie7
    if (!$target.hasClass('carousel')) return
    var options = $.extend({}, $target.data(), $this.data())
    var slideIndex = $this.attr('data-slide-to')
    if (slideIndex) options.interval = false

    Plugin.call($target, options)

    if (slideIndex) {
      $target.data('bs.carousel').to(slideIndex)
    }

    e.preventDefault()
  }

  $(document)
    .on('click.bs.carousel.data-api', '[data-slide]', clickHandler)
    .on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler)

  $(window).on('load', function () {
    $('[data-ride="carousel"]').each(function () {
      var $carousel = $(this)
      Plugin.call($carousel, $carousel.data())
    })
  })

}(jQuery);

},{}],143:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: collapse.js v3.3.4
 * http://getbootstrap.com/javascript/#collapse
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // COLLAPSE PUBLIC CLASS DEFINITION
  // ================================

  var Collapse = function (element, options) {
    this.$element      = $(element)
    this.options       = $.extend({}, Collapse.DEFAULTS, options)
    this.$trigger      = $('[data-toggle="collapse"][href="#' + element.id + '"],' +
                           '[data-toggle="collapse"][data-target="#' + element.id + '"]')
    this.transitioning = null

    if (this.options.parent) {
      this.$parent = this.getParent()
    } else {
      this.addAriaAndCollapsedClass(this.$element, this.$trigger)
    }

    if (this.options.toggle) this.toggle()
  }

  Collapse.VERSION  = '3.3.4'

  Collapse.TRANSITION_DURATION = 350

  Collapse.DEFAULTS = {
    toggle: true
  }

  Collapse.prototype.dimension = function () {
    var hasWidth = this.$element.hasClass('width')
    return hasWidth ? 'width' : 'height'
  }

  Collapse.prototype.show = function () {
    if (this.transitioning || this.$element.hasClass('in')) return

    var activesData
    var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing')

    if (actives && actives.length) {
      activesData = actives.data('bs.collapse')
      if (activesData && activesData.transitioning) return
    }

    var startEvent = $.Event('show.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return

    if (actives && actives.length) {
      Plugin.call(actives, 'hide')
      activesData || actives.data('bs.collapse', null)
    }

    var dimension = this.dimension()

    this.$element
      .removeClass('collapse')
      .addClass('collapsing')[dimension](0)
      .attr('aria-expanded', true)

    this.$trigger
      .removeClass('collapsed')
      .attr('aria-expanded', true)

    this.transitioning = 1

    var complete = function () {
      this.$element
        .removeClass('collapsing')
        .addClass('collapse in')[dimension]('')
      this.transitioning = 0
      this.$element
        .trigger('shown.bs.collapse')
    }

    if (!$.support.transition) return complete.call(this)

    var scrollSize = $.camelCase(['scroll', dimension].join('-'))

    this.$element
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])
  }

  Collapse.prototype.hide = function () {
    if (this.transitioning || !this.$element.hasClass('in')) return

    var startEvent = $.Event('hide.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return

    var dimension = this.dimension()

    this.$element[dimension](this.$element[dimension]())[0].offsetHeight

    this.$element
      .addClass('collapsing')
      .removeClass('collapse in')
      .attr('aria-expanded', false)

    this.$trigger
      .addClass('collapsed')
      .attr('aria-expanded', false)

    this.transitioning = 1

    var complete = function () {
      this.transitioning = 0
      this.$element
        .removeClass('collapsing')
        .addClass('collapse')
        .trigger('hidden.bs.collapse')
    }

    if (!$.support.transition) return complete.call(this)

    this.$element
      [dimension](0)
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)
  }

  Collapse.prototype.toggle = function () {
    this[this.$element.hasClass('in') ? 'hide' : 'show']()
  }

  Collapse.prototype.getParent = function () {
    return $(this.options.parent)
      .find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]')
      .each($.proxy(function (i, element) {
        var $element = $(element)
        this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)
      }, this))
      .end()
  }

  Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {
    var isOpen = $element.hasClass('in')

    $element.attr('aria-expanded', isOpen)
    $trigger
      .toggleClass('collapsed', !isOpen)
      .attr('aria-expanded', isOpen)
  }

  function getTargetFromTrigger($trigger) {
    var href
    var target = $trigger.attr('data-target')
      || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') // strip for ie7

    return $(target)
  }


  // COLLAPSE PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.collapse')
      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false
      if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.collapse

  $.fn.collapse             = Plugin
  $.fn.collapse.Constructor = Collapse


  // COLLAPSE NO CONFLICT
  // ====================

  $.fn.collapse.noConflict = function () {
    $.fn.collapse = old
    return this
  }


  // COLLAPSE DATA-API
  // =================

  $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function (e) {
    var $this   = $(this)

    if (!$this.attr('data-target')) e.preventDefault()

    var $target = getTargetFromTrigger($this)
    var data    = $target.data('bs.collapse')
    var option  = data ? 'toggle' : $this.data()

    Plugin.call($target, option)
  })

}(jQuery);

},{}],144:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: dropdown.js v3.3.4
 * http://getbootstrap.com/javascript/#dropdowns
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // DROPDOWN CLASS DEFINITION
  // =========================

  var backdrop = '.dropdown-backdrop'
  var toggle   = '[data-toggle="dropdown"]'
  var Dropdown = function (element) {
    $(element).on('click.bs.dropdown', this.toggle)
  }

  Dropdown.VERSION = '3.3.4'

  Dropdown.prototype.toggle = function (e) {
    var $this = $(this)

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    clearMenus()

    if (!isActive) {
      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
        // if mobile we use a backdrop because click events don't delegate
        $('<div class="dropdown-backdrop"/>').insertAfter($(this)).on('click', clearMenus)
      }

      var relatedTarget = { relatedTarget: this }
      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this
        .trigger('focus')
        .attr('aria-expanded', 'true')

      $parent
        .toggleClass('open')
        .trigger('shown.bs.dropdown', relatedTarget)
    }

    return false
  }

  Dropdown.prototype.keydown = function (e) {
    if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return

    var $this = $(this)

    e.preventDefault()
    e.stopPropagation()

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    if ((!isActive && e.which != 27) || (isActive && e.which == 27)) {
      if (e.which == 27) $parent.find(toggle).trigger('focus')
      return $this.trigger('click')
    }

    var desc = ' li:not(.disabled):visible a'
    var $items = $parent.find('[role="menu"]' + desc + ', [role="listbox"]' + desc)

    if (!$items.length) return

    var index = $items.index(e.target)

    if (e.which == 38 && index > 0)                 index--                        // up
    if (e.which == 40 && index < $items.length - 1) index++                        // down
    if (!~index)                                      index = 0

    $items.eq(index).trigger('focus')
  }

  function clearMenus(e) {
    if (e && e.which === 3) return
    $(backdrop).remove()
    $(toggle).each(function () {
      var $this         = $(this)
      var $parent       = getParent($this)
      var relatedTarget = { relatedTarget: this }

      if (!$parent.hasClass('open')) return

      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this.attr('aria-expanded', 'false')
      $parent.removeClass('open').trigger('hidden.bs.dropdown', relatedTarget)
    })
  }

  function getParent($this) {
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = selector && $(selector)

    return $parent && $parent.length ? $parent : $this.parent()
  }


  // DROPDOWN PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.dropdown')

      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  var old = $.fn.dropdown

  $.fn.dropdown             = Plugin
  $.fn.dropdown.Constructor = Dropdown


  // DROPDOWN NO CONFLICT
  // ====================

  $.fn.dropdown.noConflict = function () {
    $.fn.dropdown = old
    return this
  }


  // APPLY TO STANDARD DROPDOWN ELEMENTS
  // ===================================

  $(document)
    .on('click.bs.dropdown.data-api', clearMenus)
    .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
    .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)
    .on('keydown.bs.dropdown.data-api', '[role="menu"]', Dropdown.prototype.keydown)
    .on('keydown.bs.dropdown.data-api', '[role="listbox"]', Dropdown.prototype.keydown)

}(jQuery);

},{}],145:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: modal.js v3.3.4
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // MODAL CLASS DEFINITION
  // ======================

  var Modal = function (element, options) {
    this.options             = options
    this.$body               = $(document.body)
    this.$element            = $(element)
    this.$dialog             = this.$element.find('.modal-dialog')
    this.$backdrop           = null
    this.isShown             = null
    this.originalBodyPad     = null
    this.scrollbarWidth      = 0
    this.ignoreBackdropClick = false

    if (this.options.remote) {
      this.$element
        .find('.modal-content')
        .load(this.options.remote, $.proxy(function () {
          this.$element.trigger('loaded.bs.modal')
        }, this))
    }
  }

  Modal.VERSION  = '3.3.4'

  Modal.TRANSITION_DURATION = 300
  Modal.BACKDROP_TRANSITION_DURATION = 150

  Modal.DEFAULTS = {
    backdrop: true,
    keyboard: true,
    show: true
  }

  Modal.prototype.toggle = function (_relatedTarget) {
    return this.isShown ? this.hide() : this.show(_relatedTarget)
  }

  Modal.prototype.show = function (_relatedTarget) {
    var that = this
    var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })

    this.$element.trigger(e)

    if (this.isShown || e.isDefaultPrevented()) return

    this.isShown = true

    this.checkScrollbar()
    this.setScrollbar()
    this.$body.addClass('modal-open')

    this.escape()
    this.resize()

    this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this))

    this.$dialog.on('mousedown.dismiss.bs.modal', function () {
      that.$element.one('mouseup.dismiss.bs.modal', function (e) {
        if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true
      })
    })

    this.backdrop(function () {
      var transition = $.support.transition && that.$element.hasClass('fade')

      if (!that.$element.parent().length) {
        that.$element.appendTo(that.$body) // don't move modals dom position
      }

      that.$element
        .show()
        .scrollTop(0)

      that.adjustDialog()

      if (transition) {
        that.$element[0].offsetWidth // force reflow
      }

      that.$element
        .addClass('in')
        .attr('aria-hidden', false)

      that.enforceFocus()

      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })

      transition ?
        that.$dialog // wait for modal to slide in
          .one('bsTransitionEnd', function () {
            that.$element.trigger('focus').trigger(e)
          })
          .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
        that.$element.trigger('focus').trigger(e)
    })
  }

  Modal.prototype.hide = function (e) {
    if (e) e.preventDefault()

    e = $.Event('hide.bs.modal')

    this.$element.trigger(e)

    if (!this.isShown || e.isDefaultPrevented()) return

    this.isShown = false

    this.escape()
    this.resize()

    $(document).off('focusin.bs.modal')

    this.$element
      .removeClass('in')
      .attr('aria-hidden', true)
      .off('click.dismiss.bs.modal')
      .off('mouseup.dismiss.bs.modal')

    this.$dialog.off('mousedown.dismiss.bs.modal')

    $.support.transition && this.$element.hasClass('fade') ?
      this.$element
        .one('bsTransitionEnd', $.proxy(this.hideModal, this))
        .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
      this.hideModal()
  }

  Modal.prototype.enforceFocus = function () {
    $(document)
      .off('focusin.bs.modal') // guard against infinite focus loop
      .on('focusin.bs.modal', $.proxy(function (e) {
        if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
          this.$element.trigger('focus')
        }
      }, this))
  }

  Modal.prototype.escape = function () {
    if (this.isShown && this.options.keyboard) {
      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
        e.which == 27 && this.hide()
      }, this))
    } else if (!this.isShown) {
      this.$element.off('keydown.dismiss.bs.modal')
    }
  }

  Modal.prototype.resize = function () {
    if (this.isShown) {
      $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this))
    } else {
      $(window).off('resize.bs.modal')
    }
  }

  Modal.prototype.hideModal = function () {
    var that = this
    this.$element.hide()
    this.backdrop(function () {
      that.$body.removeClass('modal-open')
      that.resetAdjustments()
      that.resetScrollbar()
      that.$element.trigger('hidden.bs.modal')
    })
  }

  Modal.prototype.removeBackdrop = function () {
    this.$backdrop && this.$backdrop.remove()
    this.$backdrop = null
  }

  Modal.prototype.backdrop = function (callback) {
    var that = this
    var animate = this.$element.hasClass('fade') ? 'fade' : ''

    if (this.isShown && this.options.backdrop) {
      var doAnimate = $.support.transition && animate

      this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />')
        .appendTo(this.$body)

      this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
        if (this.ignoreBackdropClick) {
          this.ignoreBackdropClick = false
          return
        }
        if (e.target !== e.currentTarget) return
        this.options.backdrop == 'static'
          ? this.$element[0].focus()
          : this.hide()
      }, this))

      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

      this.$backdrop.addClass('in')

      if (!callback) return

      doAnimate ?
        this.$backdrop
          .one('bsTransitionEnd', callback)
          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callback()

    } else if (!this.isShown && this.$backdrop) {
      this.$backdrop.removeClass('in')

      var callbackRemove = function () {
        that.removeBackdrop()
        callback && callback()
      }
      $.support.transition && this.$element.hasClass('fade') ?
        this.$backdrop
          .one('bsTransitionEnd', callbackRemove)
          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callbackRemove()

    } else if (callback) {
      callback()
    }
  }

  // these following methods are used to handle overflowing modals

  Modal.prototype.handleUpdate = function () {
    this.adjustDialog()
  }

  Modal.prototype.adjustDialog = function () {
    var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight

    this.$element.css({
      paddingLeft:  !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
      paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
    })
  }

  Modal.prototype.resetAdjustments = function () {
    this.$element.css({
      paddingLeft: '',
      paddingRight: ''
    })
  }

  Modal.prototype.checkScrollbar = function () {
    var fullWindowWidth = window.innerWidth
    if (!fullWindowWidth) { // workaround for missing window.innerWidth in IE8
      var documentElementRect = document.documentElement.getBoundingClientRect()
      fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)
    }
    this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth
    this.scrollbarWidth = this.measureScrollbar()
  }

  Modal.prototype.setScrollbar = function () {
    var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)
    this.originalBodyPad = document.body.style.paddingRight || ''
    if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)
  }

  Modal.prototype.resetScrollbar = function () {
    this.$body.css('padding-right', this.originalBodyPad)
  }

  Modal.prototype.measureScrollbar = function () { // thx walsh
    var scrollDiv = document.createElement('div')
    scrollDiv.className = 'modal-scrollbar-measure'
    this.$body.append(scrollDiv)
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
    this.$body[0].removeChild(scrollDiv)
    return scrollbarWidth
  }


  // MODAL PLUGIN DEFINITION
  // =======================

  function Plugin(option, _relatedTarget) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.modal')
      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
      if (typeof option == 'string') data[option](_relatedTarget)
      else if (options.show) data.show(_relatedTarget)
    })
  }

  var old = $.fn.modal

  $.fn.modal             = Plugin
  $.fn.modal.Constructor = Modal


  // MODAL NO CONFLICT
  // =================

  $.fn.modal.noConflict = function () {
    $.fn.modal = old
    return this
  }


  // MODAL DATA-API
  // ==============

  $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
    var $this   = $(this)
    var href    = $this.attr('href')
    var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) // strip for ie7
    var option  = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())

    if ($this.is('a')) e.preventDefault()

    $target.one('show.bs.modal', function (showEvent) {
      if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown
      $target.one('hidden.bs.modal', function () {
        $this.is(':visible') && $this.trigger('focus')
      })
    })
    Plugin.call($target, option, this)
  })

}(jQuery);

},{}],146:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: popover.js v3.3.4
 * http://getbootstrap.com/javascript/#popovers
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // POPOVER PUBLIC CLASS DEFINITION
  // ===============================

  var Popover = function (element, options) {
    this.init('popover', element, options)
  }

  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')

  Popover.VERSION  = '3.3.4'

  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
    placement: 'right',
    trigger: 'click',
    content: '',
    template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
  })


  // NOTE: POPOVER EXTENDS tooltip.js
  // ================================

  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)

  Popover.prototype.constructor = Popover

  Popover.prototype.getDefaults = function () {
    return Popover.DEFAULTS
  }

  Popover.prototype.setContent = function () {
    var $tip    = this.tip()
    var title   = this.getTitle()
    var content = this.getContent()

    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
    $tip.find('.popover-content').children().detach().end()[ // we use append for html objects to maintain js events
      this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'
    ](content)

    $tip.removeClass('fade top bottom left right in')

    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
    // this manually by checking the contents.
    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
  }

  Popover.prototype.hasContent = function () {
    return this.getTitle() || this.getContent()
  }

  Popover.prototype.getContent = function () {
    var $e = this.$element
    var o  = this.options

    return $e.attr('data-content')
      || (typeof o.content == 'function' ?
            o.content.call($e[0]) :
            o.content)
  }

  Popover.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.arrow'))
  }


  // POPOVER PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.popover')
      var options = typeof option == 'object' && option

      if (!data && /destroy|hide/.test(option)) return
      if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.popover

  $.fn.popover             = Plugin
  $.fn.popover.Constructor = Popover


  // POPOVER NO CONFLICT
  // ===================

  $.fn.popover.noConflict = function () {
    $.fn.popover = old
    return this
  }

}(jQuery);

},{}],147:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: scrollspy.js v3.3.4
 * http://getbootstrap.com/javascript/#scrollspy
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // SCROLLSPY CLASS DEFINITION
  // ==========================

  function ScrollSpy(element, options) {
    this.$body          = $(document.body)
    this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)
    this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)
    this.selector       = (this.options.target || '') + ' .nav li > a'
    this.offsets        = []
    this.targets        = []
    this.activeTarget   = null
    this.scrollHeight   = 0

    this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this))
    this.refresh()
    this.process()
  }

  ScrollSpy.VERSION  = '3.3.4'

  ScrollSpy.DEFAULTS = {
    offset: 10
  }

  ScrollSpy.prototype.getScrollHeight = function () {
    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
  }

  ScrollSpy.prototype.refresh = function () {
    var that          = this
    var offsetMethod  = 'offset'
    var offsetBase    = 0

    this.offsets      = []
    this.targets      = []
    this.scrollHeight = this.getScrollHeight()

    if (!$.isWindow(this.$scrollElement[0])) {
      offsetMethod = 'position'
      offsetBase   = this.$scrollElement.scrollTop()
    }

    this.$body
      .find(this.selector)
      .map(function () {
        var $el   = $(this)
        var href  = $el.data('target') || $el.attr('href')
        var $href = /^#./.test(href) && $(href)

        return ($href
          && $href.length
          && $href.is(':visible')
          && [[$href[offsetMethod]().top + offsetBase, href]]) || null
      })
      .sort(function (a, b) { return a[0] - b[0] })
      .each(function () {
        that.offsets.push(this[0])
        that.targets.push(this[1])
      })
  }

  ScrollSpy.prototype.process = function () {
    var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset
    var scrollHeight = this.getScrollHeight()
    var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()
    var offsets      = this.offsets
    var targets      = this.targets
    var activeTarget = this.activeTarget
    var i

    if (this.scrollHeight != scrollHeight) {
      this.refresh()
    }

    if (scrollTop >= maxScroll) {
      return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)
    }

    if (activeTarget && scrollTop < offsets[0]) {
      this.activeTarget = null
      return this.clear()
    }

    for (i = offsets.length; i--;) {
      activeTarget != targets[i]
        && scrollTop >= offsets[i]
        && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1])
        && this.activate(targets[i])
    }
  }

  ScrollSpy.prototype.activate = function (target) {
    this.activeTarget = target

    this.clear()

    var selector = this.selector +
      '[data-target="' + target + '"],' +
      this.selector + '[href="' + target + '"]'

    var active = $(selector)
      .parents('li')
      .addClass('active')

    if (active.parent('.dropdown-menu').length) {
      active = active
        .closest('li.dropdown')
        .addClass('active')
    }

    active.trigger('activate.bs.scrollspy')
  }

  ScrollSpy.prototype.clear = function () {
    $(this.selector)
      .parentsUntil(this.options.target, '.active')
      .removeClass('active')
  }


  // SCROLLSPY PLUGIN DEFINITION
  // ===========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.scrollspy')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.scrollspy

  $.fn.scrollspy             = Plugin
  $.fn.scrollspy.Constructor = ScrollSpy


  // SCROLLSPY NO CONFLICT
  // =====================

  $.fn.scrollspy.noConflict = function () {
    $.fn.scrollspy = old
    return this
  }


  // SCROLLSPY DATA-API
  // ==================

  $(window).on('load.bs.scrollspy.data-api', function () {
    $('[data-spy="scroll"]').each(function () {
      var $spy = $(this)
      Plugin.call($spy, $spy.data())
    })
  })

}(jQuery);

},{}],148:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: tab.js v3.3.4
 * http://getbootstrap.com/javascript/#tabs
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // TAB CLASS DEFINITION
  // ====================

  var Tab = function (element) {
    this.element = $(element)
  }

  Tab.VERSION = '3.3.4'

  Tab.TRANSITION_DURATION = 150

  Tab.prototype.show = function () {
    var $this    = this.element
    var $ul      = $this.closest('ul:not(.dropdown-menu)')
    var selector = $this.data('target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    if ($this.parent('li').hasClass('active')) return

    var $previous = $ul.find('.active:last a')
    var hideEvent = $.Event('hide.bs.tab', {
      relatedTarget: $this[0]
    })
    var showEvent = $.Event('show.bs.tab', {
      relatedTarget: $previous[0]
    })

    $previous.trigger(hideEvent)
    $this.trigger(showEvent)

    if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return

    var $target = $(selector)

    this.activate($this.closest('li'), $ul)
    this.activate($target, $target.parent(), function () {
      $previous.trigger({
        type: 'hidden.bs.tab',
        relatedTarget: $this[0]
      })
      $this.trigger({
        type: 'shown.bs.tab',
        relatedTarget: $previous[0]
      })
    })
  }

  Tab.prototype.activate = function (element, container, callback) {
    var $active    = container.find('> .active')
    var transition = callback
      && $.support.transition
      && (($active.length && $active.hasClass('fade')) || !!container.find('> .fade').length)

    function next() {
      $active
        .removeClass('active')
        .find('> .dropdown-menu > .active')
          .removeClass('active')
        .end()
        .find('[data-toggle="tab"]')
          .attr('aria-expanded', false)

      element
        .addClass('active')
        .find('[data-toggle="tab"]')
          .attr('aria-expanded', true)

      if (transition) {
        element[0].offsetWidth // reflow for transition
        element.addClass('in')
      } else {
        element.removeClass('fade')
      }

      if (element.parent('.dropdown-menu').length) {
        element
          .closest('li.dropdown')
            .addClass('active')
          .end()
          .find('[data-toggle="tab"]')
            .attr('aria-expanded', true)
      }

      callback && callback()
    }

    $active.length && transition ?
      $active
        .one('bsTransitionEnd', next)
        .emulateTransitionEnd(Tab.TRANSITION_DURATION) :
      next()

    $active.removeClass('in')
  }


  // TAB PLUGIN DEFINITION
  // =====================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.tab')

      if (!data) $this.data('bs.tab', (data = new Tab(this)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.tab

  $.fn.tab             = Plugin
  $.fn.tab.Constructor = Tab


  // TAB NO CONFLICT
  // ===============

  $.fn.tab.noConflict = function () {
    $.fn.tab = old
    return this
  }


  // TAB DATA-API
  // ============

  var clickHandler = function (e) {
    e.preventDefault()
    Plugin.call($(this), 'show')
  }

  $(document)
    .on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler)
    .on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler)

}(jQuery);

},{}],149:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: tooltip.js v3.3.4
 * http://getbootstrap.com/javascript/#tooltip
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // TOOLTIP PUBLIC CLASS DEFINITION
  // ===============================

  var Tooltip = function (element, options) {
    this.type       = null
    this.options    = null
    this.enabled    = null
    this.timeout    = null
    this.hoverState = null
    this.$element   = null

    this.init('tooltip', element, options)
  }

  Tooltip.VERSION  = '3.3.4'

  Tooltip.TRANSITION_DURATION = 150

  Tooltip.DEFAULTS = {
    animation: true,
    placement: 'top',
    selector: false,
    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    trigger: 'hover focus',
    title: '',
    delay: 0,
    html: false,
    container: false,
    viewport: {
      selector: 'body',
      padding: 0
    }
  }

  Tooltip.prototype.init = function (type, element, options) {
    this.enabled   = true
    this.type      = type
    this.$element  = $(element)
    this.options   = this.getOptions(options)
    this.$viewport = this.options.viewport && $(this.options.viewport.selector || this.options.viewport)

    if (this.$element[0] instanceof document.constructor && !this.options.selector) {
      throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!')
    }

    var triggers = this.options.trigger.split(' ')

    for (var i = triggers.length; i--;) {
      var trigger = triggers[i]

      if (trigger == 'click') {
        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
      } else if (trigger != 'manual') {
        var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'
        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'

        this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
      }
    }

    this.options.selector ?
      (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
      this.fixTitle()
  }

  Tooltip.prototype.getDefaults = function () {
    return Tooltip.DEFAULTS
  }

  Tooltip.prototype.getOptions = function (options) {
    options = $.extend({}, this.getDefaults(), this.$element.data(), options)

    if (options.delay && typeof options.delay == 'number') {
      options.delay = {
        show: options.delay,
        hide: options.delay
      }
    }

    return options
  }

  Tooltip.prototype.getDelegateOptions = function () {
    var options  = {}
    var defaults = this.getDefaults()

    this._options && $.each(this._options, function (key, value) {
      if (defaults[key] != value) options[key] = value
    })

    return options
  }

  Tooltip.prototype.enter = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)

    if (self && self.$tip && self.$tip.is(':visible')) {
      self.hoverState = 'in'
      return
    }

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }

    clearTimeout(self.timeout)

    self.hoverState = 'in'

    if (!self.options.delay || !self.options.delay.show) return self.show()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'in') self.show()
    }, self.options.delay.show)
  }

  Tooltip.prototype.leave = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }

    clearTimeout(self.timeout)

    self.hoverState = 'out'

    if (!self.options.delay || !self.options.delay.hide) return self.hide()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'out') self.hide()
    }, self.options.delay.hide)
  }

  Tooltip.prototype.show = function () {
    var e = $.Event('show.bs.' + this.type)

    if (this.hasContent() && this.enabled) {
      this.$element.trigger(e)

      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])
      if (e.isDefaultPrevented() || !inDom) return
      var that = this

      var $tip = this.tip()

      var tipId = this.getUID(this.type)

      this.setContent()
      $tip.attr('id', tipId)
      this.$element.attr('aria-describedby', tipId)

      if (this.options.animation) $tip.addClass('fade')

      var placement = typeof this.options.placement == 'function' ?
        this.options.placement.call(this, $tip[0], this.$element[0]) :
        this.options.placement

      var autoToken = /\s?auto?\s?/i
      var autoPlace = autoToken.test(placement)
      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'

      $tip
        .detach()
        .css({ top: 0, left: 0, display: 'block' })
        .addClass(placement)
        .data('bs.' + this.type, this)

      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)

      var pos          = this.getPosition()
      var actualWidth  = $tip[0].offsetWidth
      var actualHeight = $tip[0].offsetHeight

      if (autoPlace) {
        var orgPlacement = placement
        var $container   = this.options.container ? $(this.options.container) : this.$element.parent()
        var containerDim = this.getPosition($container)

        placement = placement == 'bottom' && pos.bottom + actualHeight > containerDim.bottom ? 'top'    :
                    placement == 'top'    && pos.top    - actualHeight < containerDim.top    ? 'bottom' :
                    placement == 'right'  && pos.right  + actualWidth  > containerDim.width  ? 'left'   :
                    placement == 'left'   && pos.left   - actualWidth  < containerDim.left   ? 'right'  :
                    placement

        $tip
          .removeClass(orgPlacement)
          .addClass(placement)
      }

      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)

      this.applyPlacement(calculatedOffset, placement)

      var complete = function () {
        var prevHoverState = that.hoverState
        that.$element.trigger('shown.bs.' + that.type)
        that.hoverState = null

        if (prevHoverState == 'out') that.leave(that)
      }

      $.support.transition && this.$tip.hasClass('fade') ?
        $tip
          .one('bsTransitionEnd', complete)
          .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
        complete()
    }
  }

  Tooltip.prototype.applyPlacement = function (offset, placement) {
    var $tip   = this.tip()
    var width  = $tip[0].offsetWidth
    var height = $tip[0].offsetHeight

    // manually read margins because getBoundingClientRect includes difference
    var marginTop = parseInt($tip.css('margin-top'), 10)
    var marginLeft = parseInt($tip.css('margin-left'), 10)

    // we must check for NaN for ie 8/9
    if (isNaN(marginTop))  marginTop  = 0
    if (isNaN(marginLeft)) marginLeft = 0

    offset.top  = offset.top  + marginTop
    offset.left = offset.left + marginLeft

    // $.fn.offset doesn't round pixel values
    // so we use setOffset directly with our own function B-0
    $.offset.setOffset($tip[0], $.extend({
      using: function (props) {
        $tip.css({
          top: Math.round(props.top),
          left: Math.round(props.left)
        })
      }
    }, offset), 0)

    $tip.addClass('in')

    // check to see if placing tip in new offset caused the tip to resize itself
    var actualWidth  = $tip[0].offsetWidth
    var actualHeight = $tip[0].offsetHeight

    if (placement == 'top' && actualHeight != height) {
      offset.top = offset.top + height - actualHeight
    }

    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)

    if (delta.left) offset.left += delta.left
    else offset.top += delta.top

    var isVertical          = /top|bottom/.test(placement)
    var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight
    var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'

    $tip.offset(offset)
    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)
  }

  Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {
    this.arrow()
      .css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')
      .css(isVertical ? 'top' : 'left', '')
  }

  Tooltip.prototype.setContent = function () {
    var $tip  = this.tip()
    var title = this.getTitle()

    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
    $tip.removeClass('fade in top bottom left right')
  }

  Tooltip.prototype.hide = function (callback) {
    var that = this
    var $tip = $(this.$tip)
    var e    = $.Event('hide.bs.' + this.type)

    function complete() {
      if (that.hoverState != 'in') $tip.detach()
      that.$element
        .removeAttr('aria-describedby')
        .trigger('hidden.bs.' + that.type)
      callback && callback()
    }

    this.$element.trigger(e)

    if (e.isDefaultPrevented()) return

    $tip.removeClass('in')

    $.support.transition && $tip.hasClass('fade') ?
      $tip
        .one('bsTransitionEnd', complete)
        .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
      complete()

    this.hoverState = null

    return this
  }

  Tooltip.prototype.fixTitle = function () {
    var $e = this.$element
    if ($e.attr('title') || typeof ($e.attr('data-original-title')) != 'string') {
      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
    }
  }

  Tooltip.prototype.hasContent = function () {
    return this.getTitle()
  }

  Tooltip.prototype.getPosition = function ($element) {
    $element   = $element || this.$element

    var el     = $element[0]
    var isBody = el.tagName == 'BODY'

    var elRect    = el.getBoundingClientRect()
    if (elRect.width == null) {
      // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
      elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top })
    }
    var elOffset  = isBody ? { top: 0, left: 0 } : $element.offset()
    var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }
    var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null

    return $.extend({}, elRect, scroll, outerDims, elOffset)
  }

  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
    return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2 } :
           placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 } :
           placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
        /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width }

  }

  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
    var delta = { top: 0, left: 0 }
    if (!this.$viewport) return delta

    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0
    var viewportDimensions = this.getPosition(this.$viewport)

    if (/right|left/.test(placement)) {
      var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll
      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight
      if (topEdgeOffset < viewportDimensions.top) { // top overflow
        delta.top = viewportDimensions.top - topEdgeOffset
      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow
        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset
      }
    } else {
      var leftEdgeOffset  = pos.left - viewportPadding
      var rightEdgeOffset = pos.left + viewportPadding + actualWidth
      if (leftEdgeOffset < viewportDimensions.left) { // left overflow
        delta.left = viewportDimensions.left - leftEdgeOffset
      } else if (rightEdgeOffset > viewportDimensions.width) { // right overflow
        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset
      }
    }

    return delta
  }

  Tooltip.prototype.getTitle = function () {
    var title
    var $e = this.$element
    var o  = this.options

    title = $e.attr('data-original-title')
      || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

    return title
  }

  Tooltip.prototype.getUID = function (prefix) {
    do prefix += ~~(Math.random() * 1000000)
    while (document.getElementById(prefix))
    return prefix
  }

  Tooltip.prototype.tip = function () {
    return (this.$tip = this.$tip || $(this.options.template))
  }

  Tooltip.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))
  }

  Tooltip.prototype.enable = function () {
    this.enabled = true
  }

  Tooltip.prototype.disable = function () {
    this.enabled = false
  }

  Tooltip.prototype.toggleEnabled = function () {
    this.enabled = !this.enabled
  }

  Tooltip.prototype.toggle = function (e) {
    var self = this
    if (e) {
      self = $(e.currentTarget).data('bs.' + this.type)
      if (!self) {
        self = new this.constructor(e.currentTarget, this.getDelegateOptions())
        $(e.currentTarget).data('bs.' + this.type, self)
      }
    }

    self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
  }

  Tooltip.prototype.destroy = function () {
    var that = this
    clearTimeout(this.timeout)
    this.hide(function () {
      that.$element.off('.' + that.type).removeData('bs.' + that.type)
    })
  }


  // TOOLTIP PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.tooltip')
      var options = typeof option == 'object' && option

      if (!data && /destroy|hide/.test(option)) return
      if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.tooltip

  $.fn.tooltip             = Plugin
  $.fn.tooltip.Constructor = Tooltip


  // TOOLTIP NO CONFLICT
  // ===================

  $.fn.tooltip.noConflict = function () {
    $.fn.tooltip = old
    return this
  }

}(jQuery);

},{}],150:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: transition.js v3.3.4
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
  // ============================================================

  function transitionEnd() {
    var el = document.createElement('bootstrap')

    var transEndEventNames = {
      WebkitTransition : 'webkitTransitionEnd',
      MozTransition    : 'transitionend',
      OTransition      : 'oTransitionEnd otransitionend',
      transition       : 'transitionend'
    }

    for (var name in transEndEventNames) {
      if (el.style[name] !== undefined) {
        return { end: transEndEventNames[name] }
      }
    }

    return false // explicit for ie8 (  ._.)
  }

  // http://blog.alexmaccaw.com/css-transitions
  $.fn.emulateTransitionEnd = function (duration) {
    var called = false
    var $el = this
    $(this).one('bsTransitionEnd', function () { called = true })
    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
    setTimeout(callback, duration)
    return this
  }

  $(function () {
    $.support.transition = transitionEnd()

    if (!$.support.transition) return

    $.event.special.bsTransitionEnd = {
      bindType: $.support.transition.end,
      delegateType: $.support.transition.end,
      handle: function (e) {
        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
      }
    }
  })

}(jQuery);

},{}],151:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;

function drainQueue() {
    if (draining) {
        return;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        var i = -1;
        while (++i < len) {
            currentQueue[i]();
        }
        len = queue.length;
    }
    draining = false;
}
process.nextTick = function (fun) {
    queue.push(fun);
    if (!draining) {
        setTimeout(drainQueue, 0);
    }
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],152:[function(require,module,exports){
// i18next, v1.8.1
// Copyright (c)2015 Jan Mühlemann (jamuhl).
// Distributed under MIT license
// http://i18next.com
(function(root) {

    // add indexOf to non ECMA-262 standard compliant browsers
    if (!Array.prototype.indexOf) {
        Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {
            "use strict";
            if (this == null) {
                throw new TypeError();
            }
            var t = Object(this);
            var len = t.length >>> 0;
            if (len === 0) {
                return -1;
            }
            var n = 0;
            if (arguments.length > 0) {
                n = Number(arguments[1]);
                if (n != n) { // shortcut for verifying if it's NaN
                    n = 0;
                } else if (n != 0 && n != Infinity && n != -Infinity) {
                    n = (n > 0 || -1) * Math.floor(Math.abs(n));
                }
            }
            if (n >= len) {
                return -1;
            }
            var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
            for (; k < len; k++) {
                if (k in t && t[k] === searchElement) {
                    return k;
                }
            }
            return -1;
        }
    }

    // add lastIndexOf to non ECMA-262 standard compliant browsers
    if (!Array.prototype.lastIndexOf) {
        Array.prototype.lastIndexOf = function(searchElement /*, fromIndex*/) {
            "use strict";
            if (this == null) {
                throw new TypeError();
            }
            var t = Object(this);
            var len = t.length >>> 0;
            if (len === 0) {
                return -1;
            }
            var n = len;
            if (arguments.length > 1) {
                n = Number(arguments[1]);
                if (n != n) {
                    n = 0;
                } else if (n != 0 && n != (1 / 0) && n != -(1 / 0)) {
                    n = (n > 0 || -1) * Math.floor(Math.abs(n));
                }
            }
            var k = n >= 0 ? Math.min(n, len - 1) : len - Math.abs(n);
            for (; k >= 0; k--) {
                if (k in t && t[k] === searchElement) {
                    return k;
                }
            }
            return -1;
        };
    }

    // Add string trim for IE8.
    if (typeof String.prototype.trim !== 'function') {
        String.prototype.trim = function() {
            return this.replace(/^\s+|\s+$/g, '');
        }
    }

    var $ = root.jQuery || root.Zepto
      , i18n = {}
      , resStore = {}
      , currentLng
      , replacementCounter = 0
      , languages = []
      , initialized = false
      , sync = {};



    // Export the i18next object for **CommonJS**.
    // If we're not in CommonJS, add `i18n` to the
    // global object or to jquery.
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = i18n;
        if (!$) {
            try {
                $ = require('jquery');
            } catch(e) {
                // just ignore
            }
        }

    } else {
        root.i18n = root.i18n || i18n;
    }

    if ($) {
        $.i18n = $.i18n || i18n;
    }
    sync = {

        load: function(lngs, options, cb) {
            if (options.useLocalStorage) {
                sync._loadLocal(lngs, options, function(err, store) {
                    var missingLngs = [];
                    for (var i = 0, len = lngs.length; i < len; i++) {
                        if (!store[lngs[i]]) missingLngs.push(lngs[i]);
                    }

                    if (missingLngs.length > 0) {
                        sync._fetch(missingLngs, options, function(err, fetched) {
                            f.extend(store, fetched);
                            sync._storeLocal(fetched);

                            cb(null, store);
                        });
                    } else {
                        cb(null, store);
                    }
                });
            } else {
                sync._fetch(lngs, options, function(err, store){
                    cb(null, store);
                });
            }
        },

        _loadLocal: function(lngs, options, cb) {
            var store = {}
              , nowMS = new Date().getTime();

            if(window.localStorage) {

                var todo = lngs.length;

                f.each(lngs, function(key, lng) {
                    var local = f.localStorage.getItem('res_' + lng);

                    if (local) {
                        local = JSON.parse(local);

                        if (local.i18nStamp && local.i18nStamp + options.localStorageExpirationTime > nowMS) {
                            store[lng] = local;
                        }
                    }

                    todo--; // wait for all done befor callback
                    if (todo === 0) cb(null, store);
                });
            }
        },

        _storeLocal: function(store) {
            if(window.localStorage) {
                for (var m in store) {
                    store[m].i18nStamp = new Date().getTime();
                    f.localStorage.setItem('res_' + m, JSON.stringify(store[m]));
                }
            }
            return;
        },

        _fetch: function(lngs, options, cb) {
            var ns = options.ns
              , store = {};

            if (!options.dynamicLoad) {
                var todo = ns.namespaces.length * lngs.length
                  , errors;

                // load each file individual
                f.each(ns.namespaces, function(nsIndex, nsValue) {
                    f.each(lngs, function(lngIndex, lngValue) {

                        // Call this once our translation has returned.
                        var loadComplete = function(err, data) {
                            if (err) {
                                errors = errors || [];
                                errors.push(err);
                            }
                            store[lngValue] = store[lngValue] || {};
                            store[lngValue][nsValue] = data;

                            todo--; // wait for all done befor callback
                            if (todo === 0) cb(errors, store);
                        };

                        if(typeof options.customLoad == 'function'){
                            // Use the specified custom callback.
                            options.customLoad(lngValue, nsValue, options, loadComplete);
                        } else {
                            //~ // Use our inbuilt sync.
                            sync._fetchOne(lngValue, nsValue, options, loadComplete);
                        }
                    });
                });
            } else {
                // Call this once our translation has returned.
                var loadComplete = function(err, data) {
                    cb(null, data);
                };

                if(typeof options.customLoad == 'function'){
                    // Use the specified custom callback.
                    options.customLoad(lngs, ns.namespaces, options, loadComplete);
                } else {
                    var url = applyReplacement(options.resGetPath, { lng: lngs.join('+'), ns: ns.namespaces.join('+') });
                    // load all needed stuff once
                    f.ajax({
                        url: url,
                        success: function(data, status, xhr) {
                            f.log('loaded: ' + url);
                            loadComplete(null, data);
                        },
                        error : function(xhr, status, error) {
                            f.log('failed loading: ' + url);
                            loadComplete('failed loading resource.json error: ' + error);
                        },
                        dataType: "json",
                        async : options.getAsync
                    });
                }
            }
        },

        _fetchOne: function(lng, ns, options, done) {
            var url = applyReplacement(options.resGetPath, { lng: lng, ns: ns });
            f.ajax({
                url: url,
                success: function(data, status, xhr) {
                    f.log('loaded: ' + url);
                    done(null, data);
                },
                error : function(xhr, status, error) {
                    if ((status && status == 200) || (xhr && xhr.status && xhr.status == 200)) {
                        // file loaded but invalid json, stop waste time !
                        f.error('There is a typo in: ' + url);
                    } else if ((status && status == 404) || (xhr && xhr.status && xhr.status == 404)) {
                        f.log('Does not exist: ' + url);
                    } else {
                        var theStatus = status ? status : ((xhr && xhr.status) ? xhr.status : null);
                        f.log(theStatus + ' when loading ' + url);
                    }

                    done(error, {});
                },
                dataType: "json",
                async : options.getAsync
            });
        },

        postMissing: function(lng, ns, key, defaultValue, lngs) {
            var payload = {};
            payload[key] = defaultValue;

            var urls = [];

            if (o.sendMissingTo === 'fallback' && o.fallbackLng[0] !== false) {
                for (var i = 0; i < o.fallbackLng.length; i++) {
                    urls.push({lng: o.fallbackLng[i], url: applyReplacement(o.resPostPath, { lng: o.fallbackLng[i], ns: ns })});
                }
            } else if (o.sendMissingTo === 'current' || (o.sendMissingTo === 'fallback' && o.fallbackLng[0] === false) ) {
                urls.push({lng: lng, url: applyReplacement(o.resPostPath, { lng: lng, ns: ns })});
            } else if (o.sendMissingTo === 'all') {
                for (var i = 0, l = lngs.length; i < l; i++) {
                    urls.push({lng: lngs[i], url: applyReplacement(o.resPostPath, { lng: lngs[i], ns: ns })});
                }
            }

            for (var y = 0, len = urls.length; y < len; y++) {
                var item = urls[y];
                f.ajax({
                    url: item.url,
                    type: o.sendType,
                    data: payload,
                    success: function(data, status, xhr) {
                        f.log('posted missing key \'' + key + '\' to: ' + item.url);

                        // add key to resStore
                        var keys = key.split('.');
                        var x = 0;
                        var value = resStore[item.lng][ns];
                        while (keys[x]) {
                            if (x === keys.length - 1) {
                                value = value[keys[x]] = defaultValue;
                            } else {
                                value = value[keys[x]] = value[keys[x]] || {};
                            }
                            x++;
                        }
                    },
                    error : function(xhr, status, error) {
                        f.log('failed posting missing key \'' + key + '\' to: ' + item.url);
                    },
                    dataType: "json",
                    async : o.postAsync
                });
            }
        },

        reload: reload
    };
    // defaults
    var o = {
        lng: undefined,
        load: 'all',
        preload: [],
        lowerCaseLng: false,
        returnObjectTrees: false,
        fallbackLng: ['dev'],
        fallbackNS: [],
        detectLngQS: 'setLng',
        detectLngFromLocalStorage: false,
        ns: 'translation',
        fallbackOnNull: true,
        fallbackOnEmpty: false,
        fallbackToDefaultNS: false,
        nsseparator: ':',
        keyseparator: '.',
        selectorAttr: 'data-i18n',
        debug: false,

        resGetPath: 'locales/__lng__/__ns__.json',
        resPostPath: 'locales/add/__lng__/__ns__',

        getAsync: true,
        postAsync: true,

        resStore: undefined,
        useLocalStorage: false,
        localStorageExpirationTime: 7*24*60*60*1000,

        dynamicLoad: false,
        sendMissing: false,
        sendMissingTo: 'fallback', // current | all
        sendType: 'POST',

        interpolationPrefix: '__',
        interpolationSuffix: '__',
        defaultVariables: false,
        reusePrefix: '$t(',
        reuseSuffix: ')',
        pluralSuffix: '_plural',
        pluralNotFound: ['plural_not_found', Math.random()].join(''),
        contextNotFound: ['context_not_found', Math.random()].join(''),
        escapeInterpolation: false,
        indefiniteSuffix: '_indefinite',
        indefiniteNotFound: ['indefinite_not_found', Math.random()].join(''),

        setJqueryExt: true,
        defaultValueFromContent: true,
        useDataAttrOptions: false,
        cookieExpirationTime: undefined,
        useCookie: true,
        cookieName: 'i18next',
        cookieDomain: undefined,

        objectTreeKeyHandler: undefined,
        postProcess: undefined,
        parseMissingKey: undefined,
        missingKeyHandler: sync.postMissing,

        shortcutFunction: 'sprintf' // or: defaultValue
    };
    function _extend(target, source) {
        if (!source || typeof source === 'function') {
            return target;
        }

        for (var attr in source) { target[attr] = source[attr]; }
        return target;
    }

    function _deepExtend(target, source) {
        for (var prop in source)
            if (prop in target)
                _deepExtend(target[prop], source[prop]);
            else
                target[prop] = source[prop];
        return target;
    }

    function _each(object, callback, args) {
        var name, i = 0,
            length = object.length,
            isObj = length === undefined || Object.prototype.toString.apply(object) !== '[object Array]' || typeof object === "function";

        if (args) {
            if (isObj) {
                for (name in object) {
                    if (callback.apply(object[name], args) === false) {
                        break;
                    }
                }
            } else {
                for ( ; i < length; ) {
                    if (callback.apply(object[i++], args) === false) {
                        break;
                    }
                }
            }

        // A special, fast, case for the most common use of each
        } else {
            if (isObj) {
                for (name in object) {
                    if (callback.call(object[name], name, object[name]) === false) {
                        break;
                    }
                }
            } else {
                for ( ; i < length; ) {
                    if (callback.call(object[i], i, object[i++]) === false) {
                        break;
                    }
                }
            }
        }

        return object;
    }

    var _entityMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': '&quot;',
        "'": '&#39;',
        "/": '&#x2F;'
    };

    function _escape(data) {
        if (typeof data === 'string') {
            return data.replace(/[&<>"'\/]/g, function (s) {
                return _entityMap[s];
            });
        }else{
            return data;
        }
    }

    function _ajax(options) {

        // v0.5.0 of https://github.com/goloroden/http.js
        var getXhr = function (callback) {
            // Use the native XHR object if the browser supports it.
            if (window.XMLHttpRequest) {
                return callback(null, new XMLHttpRequest());
            } else if (window.ActiveXObject) {
                // In Internet Explorer check for ActiveX versions of the XHR object.
                try {
                    return callback(null, new ActiveXObject("Msxml2.XMLHTTP"));
                } catch (e) {
                    return callback(null, new ActiveXObject("Microsoft.XMLHTTP"));
                }
            }

            // If no XHR support was found, throw an error.
            return callback(new Error());
        };

        var encodeUsingUrlEncoding = function (data) {
            if(typeof data === 'string') {
                return data;
            }

            var result = [];
            for(var dataItem in data) {
                if(data.hasOwnProperty(dataItem)) {
                    result.push(encodeURIComponent(dataItem) + '=' + encodeURIComponent(data[dataItem]));
                }
            }

            return result.join('&');
        };

        var utf8 = function (text) {
            text = text.replace(/\r\n/g, '\n');
            var result = '';

            for(var i = 0; i < text.length; i++) {
                var c = text.charCodeAt(i);

                if(c < 128) {
                        result += String.fromCharCode(c);
                } else if((c > 127) && (c < 2048)) {
                        result += String.fromCharCode((c >> 6) | 192);
                        result += String.fromCharCode((c & 63) | 128);
                } else {
                        result += String.fromCharCode((c >> 12) | 224);
                        result += String.fromCharCode(((c >> 6) & 63) | 128);
                        result += String.fromCharCode((c & 63) | 128);
                }
            }

            return result;
        };

        var base64 = function (text) {
            var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

            text = utf8(text);
            var result = '',
                    chr1, chr2, chr3,
                    enc1, enc2, enc3, enc4,
                    i = 0;

            do {
                chr1 = text.charCodeAt(i++);
                chr2 = text.charCodeAt(i++);
                chr3 = text.charCodeAt(i++);

                enc1 = chr1 >> 2;
                enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                enc4 = chr3 & 63;

                if(isNaN(chr2)) {
                    enc3 = enc4 = 64;
                } else if(isNaN(chr3)) {
                    enc4 = 64;
                }

                result +=
                    keyStr.charAt(enc1) +
                    keyStr.charAt(enc2) +
                    keyStr.charAt(enc3) +
                    keyStr.charAt(enc4);
                chr1 = chr2 = chr3 = '';
                enc1 = enc2 = enc3 = enc4 = '';
            } while(i < text.length);

            return result;
        };

        var mergeHeaders = function () {
            // Use the first header object as base.
            var result = arguments[0];

            // Iterate through the remaining header objects and add them.
            for(var i = 1; i < arguments.length; i++) {
                var currentHeaders = arguments[i];
                for(var header in currentHeaders) {
                    if(currentHeaders.hasOwnProperty(header)) {
                        result[header] = currentHeaders[header];
                    }
                }
            }

            // Return the merged headers.
            return result;
        };

        var ajax = function (method, url, options, callback) {
            // Adjust parameters.
            if(typeof options === 'function') {
                callback = options;
                options = {};
            }

            // Set default parameter values.
            options.cache = options.cache || false;
            options.data = options.data || {};
            options.headers = options.headers || {};
            options.jsonp = options.jsonp || false;
            options.async = options.async === undefined ? true : options.async;

            // Merge the various header objects.
            var headers = mergeHeaders({
                'accept': '*/*',
                'content-type': 'application/x-www-form-urlencoded;charset=UTF-8'
            }, ajax.headers, options.headers);

            // Encode the data according to the content-type.
            var payload;
            if (headers['content-type'] === 'application/json') {
                payload = JSON.stringify(options.data);
            } else {
                payload = encodeUsingUrlEncoding(options.data);
            }

            // Specially prepare GET requests: Setup the query string, handle caching and make a JSONP call
            // if neccessary.
            if(method === 'GET') {
                // Setup the query string.
                var queryString = [];
                if(payload) {
                    queryString.push(payload);
                    payload = null;
                }

                // Handle caching.
                if(!options.cache) {
                    queryString.push('_=' + (new Date()).getTime());
                }

                // If neccessary prepare the query string for a JSONP call.
                if(options.jsonp) {
                    queryString.push('callback=' + options.jsonp);
                    queryString.push('jsonp=' + options.jsonp);
                }

                // Merge the query string and attach it to the url.
                queryString = queryString.join('&');
                if (queryString.length > 1) {
                    if (url.indexOf('?') > -1) {
                        url += '&' + queryString;
                    } else {
                        url += '?' + queryString;
                    }
                }

                // Make a JSONP call if neccessary.
                if(options.jsonp) {
                    var head = document.getElementsByTagName('head')[0];
                    var script = document.createElement('script');
                    script.type = 'text/javascript';
                    script.src = url;
                    head.appendChild(script);
                    return;
                }
            }

            // Since we got here, it is no JSONP request, so make a normal XHR request.
            getXhr(function (err, xhr) {
                if(err) return callback(err);

                // Open the request.
                xhr.open(method, url, options.async);

                // Set the request headers.
                for(var header in headers) {
                    if(headers.hasOwnProperty(header)) {
                        xhr.setRequestHeader(header, headers[header]);
                    }
                }

                // Handle the request events.
                xhr.onreadystatechange = function () {
                    if(xhr.readyState === 4) {
                        var data = xhr.responseText || '';

                        // If no callback is given, return.
                        if(!callback) {
                            return;
                        }

                        // Return an object that provides access to the data as text and JSON.
                        callback(xhr.status, {
                            text: function () {
                                return data;
                            },

                            json: function () {
                                try {
                                    return JSON.parse(data)
                                } catch (e) {
                                    f.error('Can not parse JSON. URL: ' + url);
                                    return {};
                                }
                            }
                        });
                    }
                };

                // Actually send the XHR request.
                xhr.send(payload);
            });
        };

        // Define the external interface.
        var http = {
            authBasic: function (username, password) {
                ajax.headers['Authorization'] = 'Basic ' + base64(username + ':' + password);
            },

            connect: function (url, options, callback) {
                return ajax('CONNECT', url, options, callback);
            },

            del: function (url, options, callback) {
                return ajax('DELETE', url, options, callback);
            },

            get: function (url, options, callback) {
                return ajax('GET', url, options, callback);
            },

            head: function (url, options, callback) {
                return ajax('HEAD', url, options, callback);
            },

            headers: function (headers) {
                ajax.headers = headers || {};
            },

            isAllowed: function (url, verb, callback) {
                this.options(url, function (status, data) {
                    callback(data.text().indexOf(verb) !== -1);
                });
            },

            options: function (url, options, callback) {
                return ajax('OPTIONS', url, options, callback);
            },

            patch: function (url, options, callback) {
                return ajax('PATCH', url, options, callback);
            },

            post: function (url, options, callback) {
                return ajax('POST', url, options, callback);
            },

            put: function (url, options, callback) {
                return ajax('PUT', url, options, callback);
            },

            trace: function (url, options, callback) {
                return ajax('TRACE', url, options, callback);
            }
        };


        var methode = options.type ? options.type.toLowerCase() : 'get';

        http[methode](options.url, options, function (status, data) {
            // file: protocol always gives status code 0, so check for data
            if (status === 200 || (status === 0 && data.text())) {
                options.success(data.json(), status, null);
            } else {
                options.error(data.text(), status, null);
            }
        });
    }

    var _cookie = {
        create: function(name,value,minutes,domain) {
            var expires;
            if (minutes) {
                var date = new Date();
                date.setTime(date.getTime()+(minutes*60*1000));
                expires = "; expires="+date.toGMTString();
            }
            else expires = "";
            domain = (domain)? "domain="+domain+";" : "";
            document.cookie = name+"="+value+expires+";"+domain+"path=/";
        },

        read: function(name) {
            var nameEQ = name + "=";
            var ca = document.cookie.split(';');
            for(var i=0;i < ca.length;i++) {
                var c = ca[i];
                while (c.charAt(0)==' ') c = c.substring(1,c.length);
                if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length,c.length);
            }
            return null;
        },

        remove: function(name) {
            this.create(name,"",-1);
        }
    };

    var cookie_noop = {
        create: function(name,value,minutes,domain) {},
        read: function(name) { return null; },
        remove: function(name) {}
    };



    // move dependent functions to a container so that
    // they can be overriden easier in no jquery environment (node.js)
    var f = {
        extend: $ ? $.extend : _extend,
        deepExtend: _deepExtend,
        each: $ ? $.each : _each,
        ajax: $ ? $.ajax : (typeof document !== 'undefined' ? _ajax : function() {}),
        cookie: typeof document !== 'undefined' ? _cookie : cookie_noop,
        detectLanguage: detectLanguage,
        escape: _escape,
        log: function(str) {
            if (o.debug && typeof console !== "undefined") console.log(str);
        },
        error: function(str) {
            if (typeof console !== "undefined") console.error(str);
        },
        getCountyIndexOfLng: function(lng) {
            var lng_index = 0;
            if (lng === 'nb-NO' || lng === 'nn-NO' || lng === 'nb-no' || lng === 'nn-no') lng_index = 1;
            return lng_index;
        },
        toLanguages: function(lng) {
            var log = this.log;

            function applyCase(l) {
                var ret = l;

                if (typeof l === 'string' && l.indexOf('-') > -1) {
                    var parts = l.split('-');

                    ret = o.lowerCaseLng ?
                        parts[0].toLowerCase() +  '-' + parts[1].toLowerCase() :
                        parts[0].toLowerCase() +  '-' + parts[1].toUpperCase();
                } else {
                    ret = o.lowerCaseLng ? l.toLowerCase() : l;
                }

                return ret;
            }

            var languages = [];
            var whitelist = o.lngWhitelist || false;
            var addLanguage = function(language){
              //reject langs not whitelisted
              if(!whitelist || whitelist.indexOf(language) > -1){
                languages.push(language);
              }else{
                log('rejecting non-whitelisted language: ' + language);
              }
            };
            if (typeof lng === 'string' && lng.indexOf('-') > -1) {
                var parts = lng.split('-');

                if (o.load !== 'unspecific') addLanguage(applyCase(lng));
                if (o.load !== 'current') addLanguage(applyCase(parts[this.getCountyIndexOfLng(lng)]));
            } else {
                addLanguage(applyCase(lng));
            }

            for (var i = 0; i < o.fallbackLng.length; i++) {
                if (languages.indexOf(o.fallbackLng[i]) === -1 && o.fallbackLng[i]) languages.push(applyCase(o.fallbackLng[i]));
            }
            return languages;
        },
        regexEscape: function(str) {
            return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
        },
        regexReplacementEscape: function(strOrFn) {
            if (typeof strOrFn === 'string') {
                return strOrFn.replace(/\$/g, "$$$$");
            } else {
                return strOrFn;
            }
        },
        localStorage: {
            setItem: function(key, value) {
                if (window.localStorage) {
                    try {
                        window.localStorage.setItem(key, value);
                    } catch (e) {
                        f.log('failed to set value for key "' + key + '" to localStorage.');
                    }
                }
            },
            getItem: function(key, value) {
                if (window.localStorage) {
                    try {
                        return window.localStorage.getItem(key, value);
                    } catch (e) {
                        f.log('failed to get value for key "' + key + '" from localStorage.');
                        return undefined;
                    }
                }
            }
        }
    };
    function init(options, cb) {

        if (typeof options === 'function') {
            cb = options;
            options = {};
        }
        options = options || {};

        // override defaults with passed in options
        f.extend(o, options);
        delete o.fixLng; /* passed in each time */

        // override functions: .log(), .detectLanguage(), etc
        if (o.functions) {
            delete o.functions;
            f.extend(f, options.functions);
        }

        // create namespace object if namespace is passed in as string
        if (typeof o.ns == 'string') {
            o.ns = { namespaces: [o.ns], defaultNs: o.ns};
        }

        // fallback namespaces
        if (typeof o.fallbackNS == 'string') {
            o.fallbackNS = [o.fallbackNS];
        }

        // fallback languages
        if (typeof o.fallbackLng == 'string' || typeof o.fallbackLng == 'boolean') {
            o.fallbackLng = [o.fallbackLng];
        }

        // escape prefix/suffix
        o.interpolationPrefixEscaped = f.regexEscape(o.interpolationPrefix);
        o.interpolationSuffixEscaped = f.regexEscape(o.interpolationSuffix);

        if (!o.lng) o.lng = f.detectLanguage();

        languages = f.toLanguages(o.lng);
        currentLng = languages[0];
        f.log('currentLng set to: ' + currentLng);

        if (o.useCookie && f.cookie.read(o.cookieName) !== currentLng){ //cookie is unset or invalid
            f.cookie.create(o.cookieName, currentLng, o.cookieExpirationTime, o.cookieDomain);
        }
        if (o.detectLngFromLocalStorage && typeof document !== 'undefined' && window.localStorage) {
            f.localStorage.setItem('i18next_lng', currentLng);
        }

        var lngTranslate = translate;
        if (options.fixLng) {
            lngTranslate = function(key, options) {
                options = options || {};
                options.lng = options.lng || lngTranslate.lng;
                return translate(key, options);
            };
            lngTranslate.lng = currentLng;
        }

        pluralExtensions.setCurrentLng(currentLng);

        // add JQuery extensions
        if ($ && o.setJqueryExt) addJqueryFunct();

        // jQuery deferred
        var deferred;
        if ($ && $.Deferred) {
            deferred = $.Deferred();
        }

        // return immidiatly if res are passed in
        if (o.resStore) {
            resStore = o.resStore;
            initialized = true;
            if (cb) cb(lngTranslate);
            if (deferred) deferred.resolve(lngTranslate);
            if (deferred) return deferred.promise();
            return;
        }

        // languages to load
        var lngsToLoad = f.toLanguages(o.lng);
        if (typeof o.preload === 'string') o.preload = [o.preload];
        for (var i = 0, l = o.preload.length; i < l; i++) {
            var pres = f.toLanguages(o.preload[i]);
            for (var y = 0, len = pres.length; y < len; y++) {
                if (lngsToLoad.indexOf(pres[y]) < 0) {
                    lngsToLoad.push(pres[y]);
                }
            }
        }

        // else load them
        i18n.sync.load(lngsToLoad, o, function(err, store) {
            resStore = store;
            initialized = true;

            if (cb) cb(lngTranslate);
            if (deferred) deferred.resolve(lngTranslate);
        });

        if (deferred) return deferred.promise();
    }
    function preload(lngs, cb) {
        if (typeof lngs === 'string') lngs = [lngs];
        for (var i = 0, l = lngs.length; i < l; i++) {
            if (o.preload.indexOf(lngs[i]) < 0) {
                o.preload.push(lngs[i]);
            }
        }
        return init(cb);
    }

    function addResourceBundle(lng, ns, resources, deep) {
        if (typeof ns !== 'string') {
            resources = ns;
            ns = o.ns.defaultNs;
        } else if (o.ns.namespaces.indexOf(ns) < 0) {
            o.ns.namespaces.push(ns);
        }

        resStore[lng] = resStore[lng] || {};
        resStore[lng][ns] = resStore[lng][ns] || {};

        if (deep) {
            f.deepExtend(resStore[lng][ns], resources);
        } else {
            f.extend(resStore[lng][ns], resources);
        }
        if (o.useLocalStorage) {
            sync._storeLocal(resStore);
        }
    }

    function hasResourceBundle(lng, ns) {
        if (typeof ns !== 'string') {
            ns = o.ns.defaultNs;
        }

        resStore[lng] = resStore[lng] || {};
        var res = resStore[lng][ns] || {};

        var hasValues = false;
        for(var prop in res) {
            if (res.hasOwnProperty(prop)) {
                hasValues = true;
            }
        }

        return hasValues;
    }

    function getResourceBundle(lng, ns) {
        if (typeof ns !== 'string') {
            ns = o.ns.defaultNs;
        }

        resStore[lng] = resStore[lng] || {};
        return f.extend({}, resStore[lng][ns]);
    }

    function removeResourceBundle(lng, ns) {
        if (typeof ns !== 'string') {
            ns = o.ns.defaultNs;
        }

        resStore[lng] = resStore[lng] || {};
        resStore[lng][ns] = {};
        if (o.useLocalStorage) {
            sync._storeLocal(resStore);
        }
    }

    function addResource(lng, ns, key, value) {
        if (typeof ns !== 'string') {
            resource = ns;
            ns = o.ns.defaultNs;
        } else if (o.ns.namespaces.indexOf(ns) < 0) {
            o.ns.namespaces.push(ns);
        }

        resStore[lng] = resStore[lng] || {};
        resStore[lng][ns] = resStore[lng][ns] || {};

        var keys = key.split(o.keyseparator);
        var x = 0;
        var node = resStore[lng][ns];
        var origRef = node;

        while (keys[x]) {
            if (x == keys.length - 1)
                node[keys[x]] = value;
            else {
                if (node[keys[x]] == null)
                    node[keys[x]] = {};

                node = node[keys[x]];
            }
            x++;
        }
        if (o.useLocalStorage) {
            sync._storeLocal(resStore);
        }
    }

    function addResources(lng, ns, resources) {
        if (typeof ns !== 'string') {
            resource = ns;
            ns = o.ns.defaultNs;
        } else if (o.ns.namespaces.indexOf(ns) < 0) {
            o.ns.namespaces.push(ns);
        }

        for (var m in resources) {
            if (typeof resources[m] === 'string') addResource(lng, ns, m, resources[m]);
        }
    }

    function setDefaultNamespace(ns) {
        o.ns.defaultNs = ns;
    }

    function loadNamespace(namespace, cb) {
        loadNamespaces([namespace], cb);
    }

    function loadNamespaces(namespaces, cb) {
        var opts = {
            dynamicLoad: o.dynamicLoad,
            resGetPath: o.resGetPath,
            getAsync: o.getAsync,
            customLoad: o.customLoad,
            ns: { namespaces: namespaces, defaultNs: ''} /* new namespaces to load */
        };

        // languages to load
        var lngsToLoad = f.toLanguages(o.lng);
        if (typeof o.preload === 'string') o.preload = [o.preload];
        for (var i = 0, l = o.preload.length; i < l; i++) {
            var pres = f.toLanguages(o.preload[i]);
            for (var y = 0, len = pres.length; y < len; y++) {
                if (lngsToLoad.indexOf(pres[y]) < 0) {
                    lngsToLoad.push(pres[y]);
                }
            }
        }

        // check if we have to load
        var lngNeedLoad = [];
        for (var a = 0, lenA = lngsToLoad.length; a < lenA; a++) {
            var needLoad = false;
            var resSet = resStore[lngsToLoad[a]];
            if (resSet) {
                for (var b = 0, lenB = namespaces.length; b < lenB; b++) {
                    if (!resSet[namespaces[b]]) needLoad = true;
                }
            } else {
                needLoad = true;
            }

            if (needLoad) lngNeedLoad.push(lngsToLoad[a]);
        }

        if (lngNeedLoad.length) {
            i18n.sync._fetch(lngNeedLoad, opts, function(err, store) {
                var todo = namespaces.length * lngNeedLoad.length;

                // load each file individual
                f.each(namespaces, function(nsIndex, nsValue) {

                    // append namespace to namespace array
                    if (o.ns.namespaces.indexOf(nsValue) < 0) {
                        o.ns.namespaces.push(nsValue);
                    }

                    f.each(lngNeedLoad, function(lngIndex, lngValue) {
                        resStore[lngValue] = resStore[lngValue] || {};
                        resStore[lngValue][nsValue] = store[lngValue][nsValue];

                        todo--; // wait for all done befor callback
                        if (todo === 0 && cb) {
                            if (o.useLocalStorage) i18n.sync._storeLocal(resStore);
                            cb();
                        }
                    });
                });
            });
        } else {
            if (cb) cb();
        }
    }

    function setLng(lng, options, cb) {
        if (typeof options === 'function') {
            cb = options;
            options = {};
        } else if (!options) {
            options = {};
        }

        options.lng = lng;
        return init(options, cb);
    }

    function lng() {
        return currentLng;
    }

    function reload(cb) {
        resStore = {};
        setLng(currentLng, cb);
    }
    function addJqueryFunct() {
        // $.t shortcut
        $.t = $.t || translate;

        function parse(ele, key, options) {
            if (key.length === 0) return;

            var attr = 'text';

            if (key.indexOf('[') === 0) {
                var parts = key.split(']');
                key = parts[1];
                attr = parts[0].substr(1, parts[0].length-1);
            }

            if (key.indexOf(';') === key.length-1) {
                key = key.substr(0, key.length-2);
            }

            var optionsToUse;
            if (attr === 'html') {
                optionsToUse = o.defaultValueFromContent ? $.extend({ defaultValue: ele.html() }, options) : options;
                ele.html($.t(key, optionsToUse));
            } else if (attr === 'text') {
                optionsToUse = o.defaultValueFromContent ? $.extend({ defaultValue: ele.text() }, options) : options;
                ele.text($.t(key, optionsToUse));
            } else if (attr === 'prepend') {
                optionsToUse = o.defaultValueFromContent ? $.extend({ defaultValue: ele.html() }, options) : options;
                ele.prepend($.t(key, optionsToUse));
            } else if (attr === 'append') {
                optionsToUse = o.defaultValueFromContent ? $.extend({ defaultValue: ele.html() }, options) : options;
                ele.append($.t(key, optionsToUse));
            } else if (attr.indexOf("data-") === 0) {
                var dataAttr = attr.substr(("data-").length);
                optionsToUse = o.defaultValueFromContent ? $.extend({ defaultValue: ele.data(dataAttr) }, options) : options;
                var translated = $.t(key, optionsToUse);
                //we change into the data cache
                ele.data(dataAttr, translated);
                //we change into the dom
                ele.attr(attr, translated);
            } else {
                optionsToUse = o.defaultValueFromContent ? $.extend({ defaultValue: ele.attr(attr) }, options) : options;
                ele.attr(attr, $.t(key, optionsToUse));
            }
        }

        function localize(ele, options) {
            var key = ele.attr(o.selectorAttr);
            if (!key && typeof key !== 'undefined' && key !== false) key = ele.text() || ele.val();
            if (!key) return;

            var target = ele
              , targetSelector = ele.data("i18n-target");
            if (targetSelector) {
                target = ele.find(targetSelector) || ele;
            }

            if (!options && o.useDataAttrOptions === true) {
                options = ele.data("i18n-options");
            }
            options = options || {};

            if (key.indexOf(';') >= 0) {
                var keys = key.split(';');

                $.each(keys, function(m, k) {
                    if (k !== '') parse(target, k, options);
                });

            } else {
                parse(target, key, options);
            }

            if (o.useDataAttrOptions === true) ele.data("i18n-options", options);
        }

        // fn
        $.fn.i18n = function (options) {
            return this.each(function() {
                // localize element itself
                localize($(this), options);

                // localize childs
                var elements =  $(this).find('[' + o.selectorAttr + ']');
                elements.each(function() {
                    localize($(this), options);
                });
            });
        };
    }
    function applyReplacement(str, replacementHash, nestedKey, options) {
        if (!str) return str;

        options = options || replacementHash; // first call uses replacement hash combined with options
        if (str.indexOf(options.interpolationPrefix || o.interpolationPrefix) < 0) return str;

        var prefix = options.interpolationPrefix ? f.regexEscape(options.interpolationPrefix) : o.interpolationPrefixEscaped
          , suffix = options.interpolationSuffix ? f.regexEscape(options.interpolationSuffix) : o.interpolationSuffixEscaped
          , unEscapingSuffix = 'HTML'+suffix;

        var hash = replacementHash.replace && typeof replacementHash.replace === 'object' ? replacementHash.replace : replacementHash;
        f.each(hash, function(key, value) {
            var nextKey = nestedKey ? nestedKey + o.keyseparator + key : key;
            if (typeof value === 'object' && value !== null) {
                str = applyReplacement(str, value, nextKey, options);
            } else {
                if (options.escapeInterpolation || o.escapeInterpolation) {
                    str = str.replace(new RegExp([prefix, nextKey, unEscapingSuffix].join(''), 'g'), f.regexReplacementEscape(value));
                    str = str.replace(new RegExp([prefix, nextKey, suffix].join(''), 'g'), f.regexReplacementEscape(f.escape(value)));
                } else {
                    str = str.replace(new RegExp([prefix, nextKey, suffix].join(''), 'g'), f.regexReplacementEscape(value));
                }
                // str = options.escapeInterpolation;
            }
        });
        return str;
    }

    // append it to functions
    f.applyReplacement = applyReplacement;

    function applyReuse(translated, options) {
        var comma = ',';
        var options_open = '{';
        var options_close = '}';

        var opts = f.extend({}, options);
        delete opts.postProcess;

        while (translated.indexOf(o.reusePrefix) != -1) {
            replacementCounter++;
            if (replacementCounter > o.maxRecursion) { break; } // safety net for too much recursion
            var index_of_opening = translated.lastIndexOf(o.reusePrefix);
            var index_of_end_of_closing = translated.indexOf(o.reuseSuffix, index_of_opening) + o.reuseSuffix.length;
            var token = translated.substring(index_of_opening, index_of_end_of_closing);
            var token_without_symbols = token.replace(o.reusePrefix, '').replace(o.reuseSuffix, '');

            if (index_of_end_of_closing <= index_of_opening) {
                f.error('there is an missing closing in following translation value', translated);
                return '';
            }

            if (token_without_symbols.indexOf(comma) != -1) {
                var index_of_token_end_of_closing = token_without_symbols.indexOf(comma);
                if (token_without_symbols.indexOf(options_open, index_of_token_end_of_closing) != -1 && token_without_symbols.indexOf(options_close, index_of_token_end_of_closing) != -1) {
                    var index_of_opts_opening = token_without_symbols.indexOf(options_open, index_of_token_end_of_closing);
                    var index_of_opts_end_of_closing = token_without_symbols.indexOf(options_close, index_of_opts_opening) + options_close.length;
                    try {
                        opts = f.extend(opts, JSON.parse(token_without_symbols.substring(index_of_opts_opening, index_of_opts_end_of_closing)));
                        token_without_symbols = token_without_symbols.substring(0, index_of_token_end_of_closing);
                    } catch (e) {
                    }
                }
            }

            var translated_token = _translate(token_without_symbols, opts);
            translated = translated.replace(token, f.regexReplacementEscape(translated_token));
        }
        return translated;
    }

    function hasContext(options) {
        return (options.context && (typeof options.context == 'string' || typeof options.context == 'number'));
    }

    function needsPlural(options, lng) {
        return (options.count !== undefined && typeof options.count != 'string'/* && pluralExtensions.needsPlural(lng, options.count)*/);
    }

    function needsIndefiniteArticle(options) {
        return (options.indefinite_article !== undefined && typeof options.indefinite_article != 'string' && options.indefinite_article);
    }

    function exists(key, options) {
        options = options || {};

        var notFound = _getDefaultValue(key, options)
            , found = _find(key, options);

        return found !== undefined || found === notFound;
    }

    function translate(key, options) {
        options = options || {};

        if (!initialized) {
            f.log('i18next not finished initialization. you might have called t function before loading resources finished.')
            return options.defaultValue || '';
        };
        replacementCounter = 0;
        return _translate.apply(null, arguments);
    }

    function _getDefaultValue(key, options) {
        return (options.defaultValue !== undefined) ? options.defaultValue : key;
    }

    function _injectSprintfProcessor() {

        var values = [];

        // mh: build array from second argument onwards
        for (var i = 1; i < arguments.length; i++) {
            values.push(arguments[i]);
        }

        return {
            postProcess: 'sprintf',
            sprintf:     values
        };
    }

    function _translate(potentialKeys, options) {
        if (options && typeof options !== 'object') {
            if (o.shortcutFunction === 'sprintf') {
                // mh: gettext like sprintf syntax found, automatically create sprintf processor
                options = _injectSprintfProcessor.apply(null, arguments);
            } else if (o.shortcutFunction === 'defaultValue') {
                options = {
                    defaultValue: options
                }
            }
        } else {
            options = options || {};
        }

        if (typeof o.defaultVariables === 'object') {
            options = f.extend({}, o.defaultVariables, options);
        }

        if (potentialKeys === undefined || potentialKeys === null || potentialKeys === '') return '';

        if (typeof potentialKeys === 'number') {
            potentialKeys = String(potentialKeys);
        }

        if (typeof potentialKeys === 'string') {
            potentialKeys = [potentialKeys];
        }

        var key = potentialKeys[0];

        if (potentialKeys.length > 1) {
            for (var i = 0; i < potentialKeys.length; i++) {
                key = potentialKeys[i];
                if (exists(key, options)) {
                    break;
                }
            }
        }

        var notFound = _getDefaultValue(key, options)
            , found = _find(key, options)
            , lngs = options.lng ? f.toLanguages(options.lng, options.fallbackLng) : languages
            , ns = options.ns || o.ns.defaultNs
            , parts;

        // split ns and key
        if (key.indexOf(o.nsseparator) > -1) {
            parts = key.split(o.nsseparator);
            ns = parts[0];
            key = parts[1];
        }

        if (found === undefined && o.sendMissing && typeof o.missingKeyHandler === 'function') {
            if (options.lng) {
                o.missingKeyHandler(lngs[0], ns, key, notFound, lngs);
            } else {
                o.missingKeyHandler(o.lng, ns, key, notFound, lngs);
            }
        }

        var postProcessorsToApply;
        if (typeof o.postProcess === 'string' && o.postProcess !== '') {
            postProcessorsToApply = [o.postProcess];
        } else if (typeof o.postProcess === 'array' || typeof o.postProcess === 'object') {
            postProcessorsToApply = o.postProcess;
        } else {
            postProcessorsToApply = [];
        }

        if (typeof options.postProcess === 'string' && options.postProcess !== '') {
            postProcessorsToApply = postProcessorsToApply.concat([options.postProcess]);
        } else if (typeof options.postProcess === 'array' || typeof options.postProcess === 'object') {
            postProcessorsToApply = postProcessorsToApply.concat(options.postProcess);
        }

        if (found !== undefined && postProcessorsToApply.length) {
            postProcessorsToApply.forEach(function(postProcessor) {
                if (postProcessors[postProcessor]) {
                    found = postProcessors[postProcessor](found, key, options);
                }
            });
        }

        // process notFound if function exists
        var splitNotFound = notFound;
        if (notFound.indexOf(o.nsseparator) > -1) {
            parts = notFound.split(o.nsseparator);
            splitNotFound = parts[1];
        }
        if (splitNotFound === key && o.parseMissingKey) {
            notFound = o.parseMissingKey(notFound);
        }

        if (found === undefined) {
            notFound = applyReplacement(notFound, options);
            notFound = applyReuse(notFound, options);

            if (postProcessorsToApply.length) {
                var val = _getDefaultValue(key, options);
                postProcessorsToApply.forEach(function(postProcessor) {
                    if (postProcessors[postProcessor]) {
                        found = postProcessors[postProcessor](val, key, options);
                    }
                });
            }
        }

        return (found !== undefined) ? found : notFound;
    }

    function _find(key, options) {
        options = options || {};

        var optionWithoutCount, translated
            , notFound = _getDefaultValue(key, options)
            , lngs = languages;

        if (!resStore) { return notFound; } // no resStore to translate from

        // CI mode
        if (lngs[0].toLowerCase() === 'cimode') return notFound;

        // passed in lng
        if (options.lngs) lngs = options.lngs;
        if (options.lng) {
            lngs = f.toLanguages(options.lng, options.fallbackLng);

            if (!resStore[lngs[0]]) {
                var oldAsync = o.getAsync;
                o.getAsync = false;

                i18n.sync.load(lngs, o, function(err, store) {
                    f.extend(resStore, store);
                    o.getAsync = oldAsync;
                });
            }
        }

        var ns = options.ns || o.ns.defaultNs;
        if (key.indexOf(o.nsseparator) > -1) {
            var parts = key.split(o.nsseparator);
            ns = parts[0];
            key = parts[1];
        }

        if (hasContext(options)) {
            optionWithoutCount = f.extend({}, options);
            delete optionWithoutCount.context;
            optionWithoutCount.defaultValue = o.contextNotFound;

            var contextKey = ns + o.nsseparator + key + '_' + options.context;

            translated = translate(contextKey, optionWithoutCount);
            if (translated != o.contextNotFound) {
                return applyReplacement(translated, { context: options.context }); // apply replacement for context only
            } // else continue translation with original/nonContext key
        }

        if (needsPlural(options, lngs[0])) {
            optionWithoutCount = f.extend({ lngs: [lngs[0]]}, options);
            delete optionWithoutCount.count;
            optionWithoutCount._origLng = optionWithoutCount._origLng || optionWithoutCount.lng || lngs[0];
            delete optionWithoutCount.lng;
            optionWithoutCount.defaultValue = o.pluralNotFound;

            var pluralKey;
            if (!pluralExtensions.needsPlural(lngs[0], options.count)) {
                pluralKey = ns + o.nsseparator + key;
            } else {
                pluralKey = ns + o.nsseparator + key + o.pluralSuffix;
                var pluralExtension = pluralExtensions.get(lngs[0], options.count);
                if (pluralExtension >= 0) {
                    pluralKey = pluralKey + '_' + pluralExtension;
                } else if (pluralExtension === 1) {
                    pluralKey = ns + o.nsseparator + key; // singular
                }
            }

            translated = translate(pluralKey, optionWithoutCount);

            if (translated != o.pluralNotFound) {
                return applyReplacement(translated, {
                    count: options.count,
                    interpolationPrefix: options.interpolationPrefix,
                    interpolationSuffix: options.interpolationSuffix
                }); // apply replacement for count only
            } else if (lngs.length > 1) {
                // remove failed lng
                var clone = lngs.slice();
                clone.shift();
                options = f.extend(options, { lngs: clone });
                options._origLng = optionWithoutCount._origLng;
                delete options.lng;
                // retry with fallbacks
                translated = translate(ns + o.nsseparator + key, options);
                if (translated != o.pluralNotFound) return translated;
            } else {
                optionWithoutCount.lng = optionWithoutCount._origLng;
                delete optionWithoutCount._origLng;
                translated = translate(ns + o.nsseparator + key, optionWithoutCount);

                return applyReplacement(translated, {
                    count: options.count,
                    interpolationPrefix: options.interpolationPrefix,
                    interpolationSuffix: options.interpolationSuffix
                });
            }
        }

        if (needsIndefiniteArticle(options)) {
            var optionsWithoutIndef = f.extend({}, options);
            delete optionsWithoutIndef.indefinite_article;
            optionsWithoutIndef.defaultValue = o.indefiniteNotFound;
            // If we don't have a count, we want the indefinite, if we do have a count, and needsPlural is false
            var indefiniteKey = ns + o.nsseparator + key + (((options.count && !needsPlural(options, lngs[0])) || !options.count) ? o.indefiniteSuffix : "");
            translated = translate(indefiniteKey, optionsWithoutIndef);
            if (translated != o.indefiniteNotFound) {
                return translated;
            }
        }

        var found;
        var keys = key.split(o.keyseparator);
        for (var i = 0, len = lngs.length; i < len; i++ ) {
            if (found !== undefined) break;

            var l = lngs[i];

            var x = 0;
            var value = resStore[l] && resStore[l][ns];
            while (keys[x]) {
                value = value && value[keys[x]];
                x++;
            }
            if (value !== undefined) {
                var valueType = Object.prototype.toString.apply(value);
                if (typeof value === 'string') {
                    value = applyReplacement(value, options);
                    value = applyReuse(value, options);
                } else if (valueType === '[object Array]' && !o.returnObjectTrees && !options.returnObjectTrees) {
                    value = value.join('\n');
                    value = applyReplacement(value, options);
                    value = applyReuse(value, options);
                } else if (value === null && o.fallbackOnNull === true) {
                    value = undefined;
                } else if (value !== null) {
                    if (!o.returnObjectTrees && !options.returnObjectTrees) {
                        if (o.objectTreeKeyHandler && typeof o.objectTreeKeyHandler == 'function') {
                            value = o.objectTreeKeyHandler(key, value, l, ns, options);
                        } else {
                            value = 'key \'' + ns + ':' + key + ' (' + l + ')\' ' +
                                'returned an object instead of string.';
                            f.log(value);
                        }
                    } else if (valueType !== '[object Number]' && valueType !== '[object Function]' && valueType !== '[object RegExp]') {
                        var copy = (valueType === '[object Array]') ? [] : {}; // apply child translation on a copy
                        f.each(value, function(m) {
                            copy[m] = _translate(ns + o.nsseparator + key + o.keyseparator + m, options);
                        });
                        value = copy;
                    }
                }

                if (typeof value === 'string' && value.trim() === '' && o.fallbackOnEmpty === true)
                    value = undefined;

                found = value;
            }
        }

        if (found === undefined && !options.isFallbackLookup && (o.fallbackToDefaultNS === true || (o.fallbackNS && o.fallbackNS.length > 0))) {
            // set flag for fallback lookup - avoid recursion
            options.isFallbackLookup = true;

            if (o.fallbackNS.length) {

                for (var y = 0, lenY = o.fallbackNS.length; y < lenY; y++) {
                    found = _find(o.fallbackNS[y] + o.nsseparator + key, options);

                    if (found || (found==="" && o.fallbackOnEmpty === false)) {
                        /* compare value without namespace */
                        var foundValue = found.indexOf(o.nsseparator) > -1 ? found.split(o.nsseparator)[1] : found
                          , notFoundValue = notFound.indexOf(o.nsseparator) > -1 ? notFound.split(o.nsseparator)[1] : notFound;

                        if (foundValue !== notFoundValue) break;
                    }
                }
            } else {
                found = _find(key, options); // fallback to default NS
            }
            options.isFallbackLookup = false;
        }

        return found;
    }
    function detectLanguage() {
        var detectedLng;
        var whitelist = o.lngWhitelist || [];
        var userLngChoices = [];

        // get from qs
        var qsParm = [];
        if (typeof window !== 'undefined') {
            (function() {
                var query = window.location.search.substring(1);
                var params = query.split('&');
                for (var i=0; i<params.length; i++) {
                    var pos = params[i].indexOf('=');
                    if (pos > 0) {
                        var key = params[i].substring(0,pos);
                        if (key == o.detectLngQS) {
                            userLngChoices.push(params[i].substring(pos+1));
                        }
                    }
                }
            })();
        }

        // get from cookie
        if (o.useCookie && typeof document !== 'undefined') {
            var c = f.cookie.read(o.cookieName);
            if (c) userLngChoices.push(c);
        }

        // get from localStorage
        if (o.detectLngFromLocalStorage && typeof window !== 'undefined' && window.localStorage) {
            userLngChoices.push(f.localStorage.getItem('i18next_lng'));
        }

        // get from navigator
        if (typeof navigator !== 'undefined') {
            if (navigator.languages) { // chrome only; not an array, so can't use .push.apply instead of iterating
                for (var i=0;i<navigator.languages.length;i++) {
                    userLngChoices.push(navigator.languages[i]);
                }
            }
            if (navigator.userLanguage) {
                userLngChoices.push(navigator.userLanguage);
            }
            if (navigator.language) {
                userLngChoices.push(navigator.language);
            }
        }

        (function() {
            for (var i=0;i<userLngChoices.length;i++) {
                var lng = userLngChoices[i];

                if (lng.indexOf('-') > -1) {
                    var parts = lng.split('-');
                    lng = o.lowerCaseLng ?
                        parts[0].toLowerCase() +  '-' + parts[1].toLowerCase() :
                        parts[0].toLowerCase() +  '-' + parts[1].toUpperCase();
                }

                if (whitelist.length === 0 || whitelist.indexOf(lng) > -1) {
                    detectedLng = lng;
                    break;
                }
            }
        })();

        //fallback
        if (!detectedLng){
          detectedLng = o.fallbackLng[0];
        }

        return detectedLng;
    }
    // definition http://translate.sourceforge.net/wiki/l10n/pluralforms

    /* [code, name, numbers, pluralsType] */
    var _rules = [
        ["ach", "Acholi", [1,2], 1],
        ["af", "Afrikaans",[1,2], 2],
        ["ak", "Akan", [1,2], 1],
        ["am", "Amharic", [1,2], 1],
        ["an", "Aragonese",[1,2], 2],
        ["ar", "Arabic", [0,1,2,3,11,100],5],
        ["arn", "Mapudungun",[1,2], 1],
        ["ast", "Asturian", [1,2], 2],
        ["ay", "Aymará", [1], 3],
        ["az", "Azerbaijani",[1,2],2],
        ["be", "Belarusian",[1,2,5],4],
        ["bg", "Bulgarian",[1,2], 2],
        ["bn", "Bengali", [1,2], 2],
        ["bo", "Tibetan", [1], 3],
        ["br", "Breton", [1,2], 1],
        ["bs", "Bosnian", [1,2,5],4],
        ["ca", "Catalan", [1,2], 2],
        ["cgg", "Chiga", [1], 3],
        ["cs", "Czech", [1,2,5],6],
        ["csb", "Kashubian",[1,2,5],7],
        ["cy", "Welsh", [1,2,3,8],8],
        ["da", "Danish", [1,2], 2],
        ["de", "German", [1,2], 2],
        ["dev", "Development Fallback", [1,2], 2],
        ["dz", "Dzongkha", [1], 3],
        ["el", "Greek", [1,2], 2],
        ["en", "English", [1,2], 2],
        ["eo", "Esperanto",[1,2], 2],
        ["es", "Spanish", [1,2], 2],
        ["es_ar","Argentinean Spanish", [1,2], 2],
        ["et", "Estonian", [1,2], 2],
        ["eu", "Basque", [1,2], 2],
        ["fa", "Persian", [1], 3],
        ["fi", "Finnish", [1,2], 2],
        ["fil", "Filipino", [1,2], 1],
        ["fo", "Faroese", [1,2], 2],
        ["fr", "French", [1,2], 9],
        ["fur", "Friulian", [1,2], 2],
        ["fy", "Frisian", [1,2], 2],
        ["ga", "Irish", [1,2,3,7,11],10],
        ["gd", "Scottish Gaelic",[1,2,3,20],11],
        ["gl", "Galician", [1,2], 2],
        ["gu", "Gujarati", [1,2], 2],
        ["gun", "Gun", [1,2], 1],
        ["ha", "Hausa", [1,2], 2],
        ["he", "Hebrew", [1,2], 2],
        ["hi", "Hindi", [1,2], 2],
        ["hr", "Croatian", [1,2,5],4],
        ["hu", "Hungarian",[1,2], 2],
        ["hy", "Armenian", [1,2], 2],
        ["ia", "Interlingua",[1,2],2],
        ["id", "Indonesian",[1], 3],
        ["is", "Icelandic",[1,2], 12],
        ["it", "Italian", [1,2], 2],
        ["ja", "Japanese", [1], 3],
        ["jbo", "Lojban", [1], 3],
        ["jv", "Javanese", [0,1], 13],
        ["ka", "Georgian", [1], 3],
        ["kk", "Kazakh", [1], 3],
        ["km", "Khmer", [1], 3],
        ["kn", "Kannada", [1,2], 2],
        ["ko", "Korean", [1], 3],
        ["ku", "Kurdish", [1,2], 2],
        ["kw", "Cornish", [1,2,3,4],14],
        ["ky", "Kyrgyz", [1], 3],
        ["lb", "Letzeburgesch",[1,2],2],
        ["ln", "Lingala", [1,2], 1],
        ["lo", "Lao", [1], 3],
        ["lt", "Lithuanian",[1,2,10],15],
        ["lv", "Latvian", [1,2,0],16],
        ["mai", "Maithili", [1,2], 2],
        ["mfe", "Mauritian Creole",[1,2],1],
        ["mg", "Malagasy", [1,2], 1],
        ["mi", "Maori", [1,2], 1],
        ["mk", "Macedonian",[1,2],17],
        ["ml", "Malayalam",[1,2], 2],
        ["mn", "Mongolian",[1,2], 2],
        ["mnk", "Mandinka", [0,1,2],18],
        ["mr", "Marathi", [1,2], 2],
        ["ms", "Malay", [1], 3],
        ["mt", "Maltese", [1,2,11,20],19],
        ["nah", "Nahuatl", [1,2], 2],
        ["nap", "Neapolitan",[1,2], 2],
        ["nb", "Norwegian Bokmal",[1,2],2],
        ["ne", "Nepali", [1,2], 2],
        ["nl", "Dutch", [1,2], 2],
        ["nn", "Norwegian Nynorsk",[1,2],2],
        ["no", "Norwegian",[1,2], 2],
        ["nso", "Northern Sotho",[1,2],2],
        ["oc", "Occitan", [1,2], 1],
        ["or", "Oriya", [2,1], 2],
        ["pa", "Punjabi", [1,2], 2],
        ["pap", "Papiamento",[1,2], 2],
        ["pl", "Polish", [1,2,5],7],
        ["pms", "Piemontese",[1,2], 2],
        ["ps", "Pashto", [1,2], 2],
        ["pt", "Portuguese",[1,2], 2],
        ["pt_br","Brazilian Portuguese",[1,2], 2],
        ["rm", "Romansh", [1,2], 2],
        ["ro", "Romanian", [1,2,20],20],
        ["ru", "Russian", [1,2,5],4],
        ["sah", "Yakut", [1], 3],
        ["sco", "Scots", [1,2], 2],
        ["se", "Northern Sami",[1,2], 2],
        ["si", "Sinhala", [1,2], 2],
        ["sk", "Slovak", [1,2,5],6],
        ["sl", "Slovenian",[5,1,2,3],21],
        ["so", "Somali", [1,2], 2],
        ["son", "Songhay", [1,2], 2],
        ["sq", "Albanian", [1,2], 2],
        ["sr", "Serbian", [1,2,5],4],
        ["su", "Sundanese",[1], 3],
        ["sv", "Swedish", [1,2], 2],
        ["sw", "Swahili", [1,2], 2],
        ["ta", "Tamil", [1,2], 2],
        ["te", "Telugu", [1,2], 2],
        ["tg", "Tajik", [1,2], 1],
        ["th", "Thai", [1], 3],
        ["ti", "Tigrinya", [1,2], 1],
        ["tk", "Turkmen", [1,2], 2],
        ["tr", "Turkish", [1,2], 1],
        ["tt", "Tatar", [1], 3],
        ["ug", "Uyghur", [1], 3],
        ["uk", "Ukrainian",[1,2,5],4],
        ["ur", "Urdu", [1,2], 2],
        ["uz", "Uzbek", [1,2], 1],
        ["vi", "Vietnamese",[1], 3],
        ["wa", "Walloon", [1,2], 1],
        ["wo", "Wolof", [1], 3],
        ["yo", "Yoruba", [1,2], 2],
        ["zh", "Chinese", [1], 3]
    ];

    var _rulesPluralsTypes = {
        1: function(n) {return Number(n > 1);},
        2: function(n) {return Number(n != 1);},
        3: function(n) {return 0;},
        4: function(n) {return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);},
        5: function(n) {return Number(n===0 ? 0 : n==1 ? 1 : n==2 ? 2 : n%100>=3 && n%100<=10 ? 3 : n%100>=11 ? 4 : 5);},
        6: function(n) {return Number((n==1) ? 0 : (n>=2 && n<=4) ? 1 : 2);},
        7: function(n) {return Number(n==1 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);},
        8: function(n) {return Number((n==1) ? 0 : (n==2) ? 1 : (n != 8 && n != 11) ? 2 : 3);},
        9: function(n) {return Number(n >= 2);},
        10: function(n) {return Number(n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : 4) ;},
        11: function(n) {return Number((n==1 || n==11) ? 0 : (n==2 || n==12) ? 1 : (n > 2 && n < 20) ? 2 : 3);},
        12: function(n) {return Number(n%10!=1 || n%100==11);},
        13: function(n) {return Number(n !== 0);},
        14: function(n) {return Number((n==1) ? 0 : (n==2) ? 1 : (n == 3) ? 2 : 3);},
        15: function(n) {return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && (n%100<10 || n%100>=20) ? 1 : 2);},
        16: function(n) {return Number(n%10==1 && n%100!=11 ? 0 : n !== 0 ? 1 : 2);},
        17: function(n) {return Number(n==1 || n%10==1 ? 0 : 1);},
        18: function(n) {return Number(0 ? 0 : n==1 ? 1 : 2);},
        19: function(n) {return Number(n==1 ? 0 : n===0 || ( n%100>1 && n%100<11) ? 1 : (n%100>10 && n%100<20 ) ? 2 : 3);},
        20: function(n) {return Number(n==1 ? 0 : (n===0 || (n%100 > 0 && n%100 < 20)) ? 1 : 2);},
        21: function(n) {return Number(n%100==1 ? 1 : n%100==2 ? 2 : n%100==3 || n%100==4 ? 3 : 0); }
    };

    var pluralExtensions = {

        rules: (function () {
            var l, rules = {};
            for (l=_rules.length; l-- ;) {
                rules[_rules[l][0]] = {
                    name: _rules[l][1],
                    numbers: _rules[l][2],
                    plurals: _rulesPluralsTypes[_rules[l][3]]
                }
            }
            return rules;
        }()),

        // you can add your own pluralExtensions
        addRule: function(lng, obj) {
            pluralExtensions.rules[lng] = obj;
        },

        setCurrentLng: function(lng) {
            if (!pluralExtensions.currentRule || pluralExtensions.currentRule.lng !== lng) {
                var parts = lng.split('-');

                pluralExtensions.currentRule = {
                    lng: lng,
                    rule: pluralExtensions.rules[parts[0]]
                };
            }
        },

        needsPlural: function(lng, count) {
            var parts = lng.split('-');

            var ext;
            if (pluralExtensions.currentRule && pluralExtensions.currentRule.lng === lng) {
                ext = pluralExtensions.currentRule.rule;
            } else {
                ext = pluralExtensions.rules[parts[f.getCountyIndexOfLng(lng)]];
            }

            if (ext && ext.numbers.length <= 1) {
                return false;
            } else {
                return this.get(lng, count) !== 1;
            }
        },

        get: function(lng, count) {
            var parts = lng.split('-');

            function getResult(l, c) {
                var ext;
                if (pluralExtensions.currentRule && pluralExtensions.currentRule.lng === lng) {
                    ext = pluralExtensions.currentRule.rule;
                } else {
                    ext = pluralExtensions.rules[l];
                }
                if (ext) {
                    var i;
                    if (ext.noAbs) {
                        i = ext.plurals(c);
                    } else {
                        i = ext.plurals(Math.abs(c));
                    }

                    var number = ext.numbers[i];
                    if (ext.numbers.length === 2 && ext.numbers[0] === 1) {
                        if (number === 2) {
                            number = -1; // regular plural
                        } else if (number === 1) {
                            number = 1; // singular
                        }
                    }//console.log(count + '-' + number);
                    return number;
                } else {
                    return c === 1 ? '1' : '-1';
                }
            }

            return getResult(parts[f.getCountyIndexOfLng(lng)], count);
        }

    };
    var postProcessors = {};
    var addPostProcessor = function(name, fc) {
        postProcessors[name] = fc;
    };
    // sprintf support
    var sprintf = (function() {
        function get_type(variable) {
            return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
        }
        function str_repeat(input, multiplier) {
            for (var output = []; multiplier > 0; output[--multiplier] = input) {/* do nothing */}
            return output.join('');
        }

        var str_format = function() {
            if (!str_format.cache.hasOwnProperty(arguments[0])) {
                str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
            }
            return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
        };

        str_format.format = function(parse_tree, argv) {
            var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;
            for (i = 0; i < tree_length; i++) {
                node_type = get_type(parse_tree[i]);
                if (node_type === 'string') {
                    output.push(parse_tree[i]);
                }
                else if (node_type === 'array') {
                    match = parse_tree[i]; // convenience purposes only
                    if (match[2]) { // keyword argument
                        arg = argv[cursor];
                        for (k = 0; k < match[2].length; k++) {
                            if (!arg.hasOwnProperty(match[2][k])) {
                                throw(sprintf('[sprintf] property "%s" does not exist', match[2][k]));
                            }
                            arg = arg[match[2][k]];
                        }
                    }
                    else if (match[1]) { // positional argument (explicit)
                        arg = argv[match[1]];
                    }
                    else { // positional argument (implicit)
                        arg = argv[cursor++];
                    }

                    if (/[^s]/.test(match[8]) && (get_type(arg) != 'number')) {
                        throw(sprintf('[sprintf] expecting number but found %s', get_type(arg)));
                    }
                    switch (match[8]) {
                        case 'b': arg = arg.toString(2); break;
                        case 'c': arg = String.fromCharCode(arg); break;
                        case 'd': arg = parseInt(arg, 10); break;
                        case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;
                        case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;
                        case 'o': arg = arg.toString(8); break;
                        case 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break;
                        case 'u': arg = Math.abs(arg); break;
                        case 'x': arg = arg.toString(16); break;
                        case 'X': arg = arg.toString(16).toUpperCase(); break;
                    }
                    arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+'+ arg : arg);
                    pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';
                    pad_length = match[6] - String(arg).length;
                    pad = match[6] ? str_repeat(pad_character, pad_length) : '';
                    output.push(match[5] ? arg + pad : pad + arg);
                }
            }
            return output.join('');
        };

        str_format.cache = {};

        str_format.parse = function(fmt) {
            var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
            while (_fmt) {
                if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
                    parse_tree.push(match[0]);
                }
                else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
                    parse_tree.push('%');
                }
                else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
                    if (match[2]) {
                        arg_names |= 1;
                        var field_list = [], replacement_field = match[2], field_match = [];
                        if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                            field_list.push(field_match[1]);
                            while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                                if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                                    field_list.push(field_match[1]);
                                }
                                else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
                                    field_list.push(field_match[1]);
                                }
                                else {
                                    throw('[sprintf] huh?');
                                }
                            }
                        }
                        else {
                            throw('[sprintf] huh?');
                        }
                        match[2] = field_list;
                    }
                    else {
                        arg_names |= 2;
                    }
                    if (arg_names === 3) {
                        throw('[sprintf] mixing positional and named placeholders is not (yet) supported');
                    }
                    parse_tree.push(match);
                }
                else {
                    throw('[sprintf] huh?');
                }
                _fmt = _fmt.substring(match[0].length);
            }
            return parse_tree;
        };

        return str_format;
    })();

    var vsprintf = function(fmt, argv) {
        argv.unshift(fmt);
        return sprintf.apply(null, argv);
    };

    addPostProcessor("sprintf", function(val, key, opts) {
        if (!opts.sprintf) return val;

        if (Object.prototype.toString.apply(opts.sprintf) === '[object Array]') {
            return vsprintf(val, opts.sprintf);
        } else if (typeof opts.sprintf === 'object') {
            return sprintf(val, opts.sprintf);
        }

        return val;
    });
    // public api interface
    i18n.init = init;
    i18n.setLng = setLng;
    i18n.preload = preload;
    i18n.addResourceBundle = addResourceBundle;
    i18n.hasResourceBundle = hasResourceBundle;
    i18n.getResourceBundle = getResourceBundle;
    i18n.addResource = addResource;
    i18n.addResources = addResources;
    i18n.removeResourceBundle = removeResourceBundle;
    i18n.loadNamespace = loadNamespace;
    i18n.loadNamespaces = loadNamespaces;
    i18n.setDefaultNamespace = setDefaultNamespace;
    i18n.t = translate;
    i18n.translate = translate;
    i18n.exists = exists;
    i18n.detectLanguage = f.detectLanguage;
    i18n.pluralExtensions = pluralExtensions;
    i18n.sync = sync;
    i18n.functions = f;
    i18n.lng = lng;
    i18n.addPostProcessor = addPostProcessor;
    i18n.applyReplacement = f.applyReplacement;
    i18n.options = o;

})(typeof exports === 'undefined' ? window : exports);

},{"jquery":"jquery"}],153:[function(require,module,exports){
/*! jquery.atwho - v0.4.7 - 2014-02-22
* Copyright (c) 2014 chord.luo <chord.luo@gmail.com>; 
* homepage: http://ichord.github.com/At.js 
* Licensed MIT
*/

(function() {
  (function(factory) {
    if (typeof define === 'function' && define.amd) {
      return define(['jquery'], factory);
    } else {
      return factory(window.jQuery);
    }
  })(function($) {

var $CONTAINER, Api, App, Atwho, Controller, DEFAULT_CALLBACKS, KEY_CODE, Model, View,
  __slice = [].slice;

App = (function() {
  function App(inputor) {
    this.current_flag = null;
    this.controllers = {};
    this.alias_maps = {};
    this.$inputor = $(inputor);
    this.listen();
  }

  App.prototype.controller = function(at) {
    return this.controllers[this.alias_maps[at] || at || this.current_flag];
  };

  App.prototype.set_context_for = function(at) {
    this.current_flag = at;
    return this;
  };

  App.prototype.reg = function(flag, setting) {
    var controller, _base;
    controller = (_base = this.controllers)[flag] || (_base[flag] = new Controller(this, flag));
    if (setting.alias) {
      this.alias_maps[setting.alias] = flag;
    }
    controller.init(setting);
    return this;
  };

  App.prototype.listen = function() {
    return this.$inputor.on('keyup.atwhoInner', (function(_this) {
      return function(e) {
        return _this.on_keyup(e);
      };
    })(this)).on('keydown.atwhoInner', (function(_this) {
      return function(e) {
        return _this.on_keydown(e);
      };
    })(this)).on('scroll.atwhoInner', (function(_this) {
      return function(e) {
        var _ref;
        return (_ref = _this.controller()) != null ? _ref.view.hide() : void 0;
      };
    })(this)).on('blur.atwhoInner', (function(_this) {
      return function(e) {
        var c;
        if (c = _this.controller()) {
          return c.view.hide(c.get_opt("display_timeout"));
        }
      };
    })(this));
  };

  App.prototype.shutdown = function() {
    var c, _, _ref;
    _ref = this.controllers;
    for (_ in _ref) {
      c = _ref[_];
      c.destroy();
    }
    return this.$inputor.off('.atwhoInner');
  };

  App.prototype.dispatch = function() {
    return $.map(this.controllers, (function(_this) {
      return function(c) {
        if (c.look_up()) {
          return _this.set_context_for(c.at);
        }
      };
    })(this));
  };

  App.prototype.on_keyup = function(e) {
    var _ref;
    switch (e.keyCode) {
      case KEY_CODE.ESC:
        e.preventDefault();
        if ((_ref = this.controller()) != null) {
          _ref.view.hide();
        }
        break;
      case KEY_CODE.DOWN:
      case KEY_CODE.UP:
        $.noop();
        break;
      default:
        this.dispatch();
    }
  };

  App.prototype.on_keydown = function(e) {
    var view, _ref;
    view = (_ref = this.controller()) != null ? _ref.view : void 0;
    if (!(view && view.visible())) {
      return;
    }
    switch (e.keyCode) {
      case KEY_CODE.ESC:
        e.preventDefault();
        view.hide();
        break;
      case KEY_CODE.UP:
        e.preventDefault();
        view.prev();
        break;
      case KEY_CODE.DOWN:
        e.preventDefault();
        view.next();
        break;
      case KEY_CODE.TAB:
      case KEY_CODE.ENTER:
        if (!view.visible()) {
          return;
        }
        e.preventDefault();
        view.choose();
        break;
      default:
        $.noop();
    }
  };

  return App;

})();

Controller = (function() {
  var uuid, _uuid;

  _uuid = 0;

  uuid = function() {
    return _uuid += 1;
  };

  function Controller(app, at) {
    this.app = app;
    this.at = at;
    this.$inputor = this.app.$inputor;
    this.oDocument = this.$inputor[0].ownerDocument;
    this.oWindow = this.oDocument.defaultView || this.oDocument.parentWindow;
    this.id = this.$inputor[0].id || uuid();
    this.setting = null;
    this.query = null;
    this.pos = 0;
    this.cur_rect = null;
    this.range = null;
    $CONTAINER.append(this.$el = $("<div id='atwho-ground-" + this.id + "'></div>"));
    this.model = new Model(this);
    this.view = new View(this);
  }

  Controller.prototype.init = function(setting) {
    this.setting = $.extend({}, this.setting || $.fn.atwho["default"], setting);
    this.view.init();
    return this.model.reload(this.setting.data);
  };

  Controller.prototype.destroy = function() {
    this.trigger('beforeDestroy');
    this.model.destroy();
    return this.view.destroy();
  };

  Controller.prototype.call_default = function() {
    var args, error, func_name;
    func_name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    try {
      return DEFAULT_CALLBACKS[func_name].apply(this, args);
    } catch (_error) {
      error = _error;
      return $.error("" + error + " Or maybe At.js doesn't have function " + func_name);
    }
  };

  Controller.prototype.trigger = function(name, data) {
    var alias, event_name;
    if (data == null) {
      data = [];
    }
    data.push(this);
    alias = this.get_opt('alias');
    event_name = alias ? "" + name + "-" + alias + ".atwho" : "" + name + ".atwho";
    return this.$inputor.trigger(event_name, data);
  };

  Controller.prototype.callbacks = function(func_name) {
    return this.get_opt("callbacks")[func_name] || DEFAULT_CALLBACKS[func_name];
  };

  Controller.prototype.get_opt = function(at, default_value) {
    var e;
    try {
      return this.setting[at];
    } catch (_error) {
      e = _error;
      return null;
    }
  };

  Controller.prototype.content = function() {
    if (this.$inputor.is('textarea, input')) {
      return this.$inputor.val();
    } else {
      return this.$inputor.text();
    }
  };

  Controller.prototype.catch_query = function() {
    var caret_pos, content, end, query, start, subtext;
    content = this.content();
    caret_pos = this.$inputor.caret('pos');
    subtext = content.slice(0, caret_pos);
    query = this.callbacks("matcher").call(this, this.at, subtext, this.get_opt('start_with_space'));
    if (typeof query === "string" && query.length <= this.get_opt('max_len', 20)) {
      start = caret_pos - query.length;
      end = start + query.length;
      this.pos = start;
      query = {
        'text': query.toLowerCase(),
        'head_pos': start,
        'end_pos': end
      };
      this.trigger("matched", [this.at, query.text]);
    } else {
      this.view.hide();
    }
    return this.query = query;
  };

  Controller.prototype.rect = function() {
    var c, scale_bottom;
    if (!(c = this.$inputor.caret('offset', this.pos - 1))) {
      return;
    }
    if (this.$inputor.attr('contentEditable') === 'true') {
      c = (this.cur_rect || (this.cur_rect = c)) || c;
    }
    scale_bottom = document.selection ? 0 : 2;
    return {
      left: c.left,
      top: c.top,
      bottom: c.top + c.height + scale_bottom
    };
  };

  Controller.prototype.reset_rect = function() {
    if (this.$inputor.attr('contentEditable') === 'true') {
      return this.cur_rect = null;
    }
  };

  Controller.prototype.mark_range = function() {
    if (this.$inputor.attr('contentEditable') === 'true') {
      if (this.oWindow.getSelection) {
        this.range = this.oWindow.getSelection().getRangeAt(0);
      }
      if (this.oDocument.selection) {
        return this.ie8_range = this.oDocument.selection.createRange();
      }
    }
  };

  Controller.prototype.insert_content_for = function($li) {
    var data, data_value, tpl;
    data_value = $li.data('value');
    tpl = this.get_opt('insert_tpl');
    if (this.$inputor.is('textarea, input') || !tpl) {
      return data_value;
    }
    data = $.extend({}, $li.data('item-data'), {
      'atwho-data-value': data_value,
      'atwho-at': this.at
    });
    return this.callbacks("tpl_eval").call(this, tpl, data);
  };

  Controller.prototype.insert = function(content, $li) {
    var $inputor, $insert_node, class_name, content_node, insert_node, pos, range, sel, source, start_str, text;
    $inputor = this.$inputor;
    if ($inputor.attr('contentEditable') === 'true') {
      class_name = "atwho-view-flag atwho-view-flag-" + (this.get_opt('alias') || this.at);
      content_node = "" + content + "<span contenteditable='false'>&nbsp;<span>";
      insert_node = "<span contenteditable='false' class='" + class_name + "'>" + content_node + "</span>";
      $insert_node = $(insert_node, this.oDocument).data('atwho-data-item', $li.data('item-data'));
      if (this.oDocument.selection) {
        $insert_node = $("<span contenteditable='true'></span>", this.oDocument).html($insert_node);
      }
    }
    if ($inputor.is('textarea, input')) {
      content = '' + content;
      source = $inputor.val();
      start_str = source.slice(0, Math.max(this.query.head_pos - this.at.length, 0));
      text = "" + start_str + content + " " + (source.slice(this.query['end_pos'] || 0));
      $inputor.val(text);
      $inputor.caret('pos', start_str.length + content.length + 1);
    } else if (range = this.range) {
      pos = range.startOffset - (this.query.end_pos - this.query.head_pos) - this.at.length;
      range.setStart(range.endContainer, Math.max(pos, 0));
      range.setEnd(range.endContainer, range.endOffset);
      range.deleteContents();
      range.insertNode($insert_node[0]);
      range.collapse(false);
      sel = this.oWindow.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
    } else if (range = this.ie8_range) {
      range.moveStart('character', this.query.end_pos - this.query.head_pos - this.at.length);
      range.pasteHTML(content_node);
      range.collapse(false);
      range.select();
    }
    if (!$inputor.is(':focus')) {
      $inputor.focus();
    }
    return $inputor.change();
  };

  Controller.prototype.render_view = function(data) {
    var search_key;
    search_key = this.get_opt("search_key");
    data = this.callbacks("sorter").call(this, this.query.text, data.slice(0, 1001), search_key);
    return this.view.render(data.slice(0, this.get_opt('limit')));
  };

  Controller.prototype.look_up = function() {
    var query, _callback;
    if (!(query = this.catch_query())) {
      return;
    }
    _callback = function(data) {
      if (data && data.length > 0) {
        return this.render_view(data);
      } else {
        return this.view.hide();
      }
    };
    this.model.query(query.text, $.proxy(_callback, this));
    return query;
  };

  return Controller;

})();

Model = (function() {
  function Model(context) {
    this.context = context;
    this.at = this.context.at;
    this.storage = this.context.$inputor;
  }

  Model.prototype.destroy = function() {
    return this.storage.data(this.at, null);
  };

  Model.prototype.saved = function() {
    return this.fetch() > 0;
  };

  Model.prototype.query = function(query, callback) {
    var data, search_key, _remote_filter;
    data = this.fetch();
    search_key = this.context.get_opt("search_key");
    data = this.context.callbacks('filter').call(this.context, query, data, search_key) || [];
    _remote_filter = this.context.callbacks('remote_filter');
    if (data.length > 0 || (!_remote_filter && data.length === 0)) {
      return callback(data);
    } else {
      return _remote_filter.call(this.context, query, callback);
    }
  };

  Model.prototype.fetch = function() {
    return this.storage.data(this.at) || [];
  };

  Model.prototype.save = function(data) {
    return this.storage.data(this.at, this.context.callbacks("before_save").call(this.context, data || []));
  };

  Model.prototype.load = function(data) {
    if (!(this.saved() || !data)) {
      return this._load(data);
    }
  };

  Model.prototype.reload = function(data) {
    return this._load(data);
  };

  Model.prototype._load = function(data) {
    if (typeof data === "string") {
      return $.ajax(data, {
        dataType: "json"
      }).done((function(_this) {
        return function(data) {
          return _this.save(data);
        };
      })(this));
    } else {
      return this.save(data);
    }
  };

  return Model;

})();

View = (function() {
  function View(context) {
    this.context = context;
    this.$el = $("<div class='atwho-view'><ul class='atwho-view-ul'></ul></div>");
    this.timeout_id = null;
    this.context.$el.append(this.$el);
    this.bind_event();
  }

  View.prototype.init = function() {
    var id;
    id = this.context.get_opt("alias") || this.context.at.charCodeAt(0);
    return this.$el.attr({
      'id': "at-view-" + id
    });
  };

  View.prototype.destroy = function() {
    return this.$el.remove();
  };

  View.prototype.bind_event = function() {
    var $menu;
    $menu = this.$el.find('ul');
    return $menu.on('mouseenter.atwho-view', 'li', function(e) {
      $menu.find('.cur').removeClass('cur');
      return $(e.currentTarget).addClass('cur');
    }).on('click', (function(_this) {
      return function(e) {
        _this.choose();
        return e.preventDefault();
      };
    })(this));
  };

  View.prototype.visible = function() {
    return this.$el.is(":visible");
  };

  View.prototype.choose = function() {
    var $li, content;
    $li = this.$el.find(".cur");
    content = this.context.insert_content_for($li);
    this.context.insert(this.context.callbacks("before_insert").call(this.context, content, $li), $li);
    this.context.trigger("inserted", [$li]);
    return this.hide();
  };

  View.prototype.reposition = function(rect) {
    var offset;
    if (rect.bottom + this.$el.height() - $(window).scrollTop() > $(window).height()) {
      rect.bottom = rect.top - this.$el.height();
    }
    offset = {
      left: rect.left,
      top: rect.bottom
    };
    this.$el.offset(offset);
    return this.context.trigger("reposition", [offset]);
  };

  View.prototype.next = function() {
    var cur, next;
    cur = this.$el.find('.cur').removeClass('cur');
    next = cur.next();
    if (!next.length) {
      next = this.$el.find('li:first');
    }
    return next.addClass('cur');
  };

  View.prototype.prev = function() {
    var cur, prev;
    cur = this.$el.find('.cur').removeClass('cur');
    prev = cur.prev();
    if (!prev.length) {
      prev = this.$el.find('li:last');
    }
    return prev.addClass('cur');
  };

  View.prototype.show = function() {
    var rect;
    this.context.mark_range();
    if (!this.visible()) {
      this.$el.show();
    }
    if (rect = this.context.rect()) {
      return this.reposition(rect);
    }
  };

  View.prototype.hide = function(time) {
    var callback;
    if (isNaN(time && this.visible())) {
      this.context.reset_rect();
      return this.$el.hide();
    } else {
      callback = (function(_this) {
        return function() {
          return _this.hide();
        };
      })(this);
      clearTimeout(this.timeout_id);
      return this.timeout_id = setTimeout(callback, time);
    }
  };

  View.prototype.render = function(list) {
    var $li, $ul, item, li, tpl, _i, _len;
    if (!($.isArray(list) && list.length > 0)) {
      this.hide();
      return;
    }
    this.$el.find('ul').empty();
    $ul = this.$el.find('ul');
    tpl = this.context.get_opt('tpl');
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      item = list[_i];
      item = $.extend({}, item, {
        'atwho-at': this.context.at
      });
      li = this.context.callbacks("tpl_eval").call(this.context, tpl, item);
      $li = $(this.context.callbacks("highlighter").call(this.context, li, this.context.query.text));
      $li.data("item-data", item);
      $ul.append($li);
    }
    this.show();
    return $ul.find("li:first").addClass("cur");
  };

  return View;

})();

KEY_CODE = {
  DOWN: 40,
  UP: 38,
  ESC: 27,
  TAB: 9,
  ENTER: 13
};

DEFAULT_CALLBACKS = {
  before_save: function(data) {
    var item, _i, _len, _results;
    if (!$.isArray(data)) {
      return data;
    }
    _results = [];
    for (_i = 0, _len = data.length; _i < _len; _i++) {
      item = data[_i];
      if ($.isPlainObject(item)) {
        _results.push(item);
      } else {
        _results.push({
          name: item
        });
      }
    }
    return _results;
  },
  matcher: function(flag, subtext, should_start_with_space) {
    var match, regexp;
    flag = flag.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
    if (should_start_with_space) {
      flag = '(?:^|\\s)' + flag;
    }
    regexp = new RegExp(flag + '([A-Za-z0-9_\+\-]*)$|' + flag + '([^\\x00-\\xff]*)$', 'gi');
    match = regexp.exec(subtext);
    if (match) {
      return match[2] || match[1];
    } else {
      return null;
    }
  },
  filter: function(query, data, search_key) {
    var item, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = data.length; _i < _len; _i++) {
      item = data[_i];
      if (~item[search_key].toLowerCase().indexOf(query)) {
        _results.push(item);
      }
    }
    return _results;
  },
  remote_filter: null,
  sorter: function(query, items, search_key) {
    var item, _i, _len, _results;
    if (!query) {
      return items;
    }
    _results = [];
    for (_i = 0, _len = items.length; _i < _len; _i++) {
      item = items[_i];
      item.atwho_order = item[search_key].toLowerCase().indexOf(query);
      if (item.atwho_order > -1) {
        _results.push(item);
      }
    }
    return _results.sort(function(a, b) {
      return a.atwho_order - b.atwho_order;
    });
  },
  tpl_eval: function(tpl, map) {
    var error;
    try {
      return tpl.replace(/\$\{([^\}]*)\}/g, function(tag, key, pos) {
        return map[key];
      });
    } catch (_error) {
      error = _error;
      return "";
    }
  },
  highlighter: function(li, query) {
    var regexp;
    if (!query) {
      return li;
    }
    regexp = new RegExp(">\\s*(\\w*)(" + query.replace("+", "\\+") + ")(\\w*)\\s*<", 'ig');
    return li.replace(regexp, function(str, $1, $2, $3) {
      return '> ' + $1 + '<strong>' + $2 + '</strong>' + $3 + ' <';
    });
  },
  before_insert: function(value, $li) {
    return value;
  }
};

Api = {
  load: function(at, data) {
    var c;
    if (c = this.controller(at)) {
      return c.model.load(data);
    }
  },
  getInsertedItemsWithIDs: function(at) {
    var c, ids, items;
    if (!(c = this.controller(at))) {
      return [null, null];
    }
    if (at) {
      at = "-" + (c.get_opt('alias') || c.at);
    }
    ids = [];
    items = $.map(this.$inputor.find("span.atwho-view-flag" + (at || "")), function(item) {
      var data;
      data = $(item).data('atwho-data-item');
      if (ids.indexOf(data.id) > -1) {
        return;
      }
      if (data.id) {
        ids.push = data.id;
      }
      return data;
    });
    return [ids, items];
  },
  getInsertedItems: function(at) {
    return Api.getInsertedItemsWithIDs.apply(this, [at])[1];
  },
  getInsertedIDs: function(at) {
    return Api.getInsertedItemsWithIDs.apply(this, [at])[0];
  },
  run: function() {
    return this.dispatch();
  },
  destroy: function() {
    this.shutdown();
    return this.$inputor.data('atwho', null);
  }
};

Atwho = {
  init: function(options) {
    var $this, app;
    app = ($this = $(this)).data("atwho");
    if (!app) {
      $this.data('atwho', (app = new App(this)));
    }
    app.reg(options.at, options);
    return this;
  }
};

$CONTAINER = $("<div id='atwho-container'></div>");

$.fn.atwho = function(method) {
  var result, _args;
  _args = arguments;
  $('body').append($CONTAINER);
  result = null;
  this.filter('textarea, input, [contenteditable=true]').each(function() {
    var app;
    if (typeof method === 'object' || !method) {
      return Atwho.init.apply(this, _args);
    } else if (Api[method]) {
      if (app = $(this).data('atwho')) {
        return result = Api[method].apply(app, Array.prototype.slice.call(_args, 1));
      }
    } else {
      return $.error("Method " + method + " does not exist on jQuery.caret");
    }
  });
  return result || this;
};

$.fn.atwho["default"] = {
  at: void 0,
  alias: void 0,
  data: null,
  tpl: "<li data-value='${atwho-at}${name}'>${name}</li>",
  insert_tpl: "<span>${atwho-data-value}</span>",
  callbacks: DEFAULT_CALLBACKS,
  search_key: "name",
  start_with_space: true,
  limit: 5,
  max_len: 20,
  display_timeout: 300
};

  });
}).call(this);

},{}],154:[function(require,module,exports){
/*! jquery.caret 2014-03-14 */
(function(){!function(a){return"function"==typeof define&&define.amd?define(["jquery"],a):a(window.jQuery)}(function(a){"use strict";var b,c,d,e,f,g,h,i,j;return j="caret",b=function(){function b(a){this.$inputor=a,this.domInputor=this.$inputor[0]}return b.prototype.setPos=function(){return this.domInputor},b.prototype.getIEPosition=function(){return a.noop()},b.prototype.getPosition=function(){return a.noop()},b.prototype.getOldIEPos=function(){var a,b;return b=g.selection.createRange(),a=g.body.createTextRange(),a.moveToElementText(this.domInputor),a.setEndPoint("EndToEnd",b),a.text.length},b.prototype.getPos=function(){var a,b,c;return(c=this.range())?(a=c.cloneRange(),a.selectNodeContents(this.domInputor),a.setEnd(c.endContainer,c.endOffset),b=a.toString().length,a.detach(),b):g.selection?this.getOldIEPos():void 0},b.prototype.getOldIEOffset=function(){var a,b;return a=g.selection.createRange().duplicate(),a.moveStart("character",-1),b=a.getBoundingClientRect(),{height:b.bottom-b.top,left:b.left,top:b.top}},b.prototype.getOffset=function(){var b,c,d,e;if(i.getSelection&&(d=this.range())){if(d.endOffset-1<0)return null;b=d.cloneRange(),b.setStart(d.endContainer,d.endOffset-1),b.setEnd(d.endContainer,d.endOffset),e=b.getBoundingClientRect(),c={height:e.height,left:e.left+e.width,top:e.top},b.detach()}else g.selection&&(c=this.getOldIEOffset());return c&&!h&&(c.top+=a(i).scrollTop(),c.left+=a(i).scrollLeft()),c},b.prototype.range=function(){var a;if(i.getSelection)return a=i.getSelection(),a.rangeCount>0?a.getRangeAt(0):null},b}(),c=function(){function b(a){this.$inputor=a,this.domInputor=this.$inputor[0]}return b.prototype.getIEPos=function(){var a,b,c,d,e,f,h;return b=this.domInputor,f=g.selection.createRange(),e=0,f&&f.parentElement()===b&&(d=b.value.replace(/\r\n/g,"\n"),c=d.length,h=b.createTextRange(),h.moveToBookmark(f.getBookmark()),a=b.createTextRange(),a.collapse(!1),e=h.compareEndPoints("StartToEnd",a)>-1?c:-h.moveStart("character",-c)),e},b.prototype.getPos=function(){return g.selection?this.getIEPos():this.domInputor.selectionStart},b.prototype.setPos=function(a){var b,c;return b=this.domInputor,g.selection?(c=b.createTextRange(),c.move("character",a),c.select()):b.setSelectionRange&&b.setSelectionRange(a,a),b},b.prototype.getIEOffset=function(a){var b,c,d,e;return c=this.domInputor.createTextRange(),a||(a=this.getPos()),c.move("character",a),d=c.boundingLeft,e=c.boundingTop,b=c.boundingHeight,{left:d,top:e,height:b}},b.prototype.getOffset=function(b){var c,d,e;return c=this.$inputor,g.selection?(d=this.getIEOffset(b),d.top+=a(i).scrollTop()+c.scrollTop(),d.left+=a(i).scrollLeft()+c.scrollLeft(),d):(d=c.offset(),e=this.getPosition(b),d={left:d.left+e.left-c.scrollLeft(),top:d.top+e.top-c.scrollTop(),height:e.height})},b.prototype.getPosition=function(a){var b,c,e,f,g,h;return b=this.$inputor,e=function(a){return a.replace(/</g,"&lt").replace(/>/g,"&gt").replace(/`/g,"&#96").replace(/"/g,"&quot").replace(/\r\n|\r|\n/g,"<br />")},void 0===a&&(a=this.getPos()),h=b.val().slice(0,a),f="<span>"+e(h)+"</span>",f+="<span id='caret'>|</span>",g=new d(b),c=g.create(f).rect()},b.prototype.getIEPosition=function(a){var b,c,d,e,f;return d=this.getIEOffset(a),c=this.$inputor.offset(),e=d.left-c.left,f=d.top-c.top,b=d.height,{left:e,top:f,height:b}},b}(),d=function(){function b(a){this.$inputor=a}return b.prototype.css_attr=["overflowY","height","width","paddingTop","paddingLeft","paddingRight","paddingBottom","marginTop","marginLeft","marginRight","marginBottom","fontFamily","borderStyle","borderWidth","wordWrap","fontSize","lineHeight","overflowX","text-align"],b.prototype.mirrorCss=function(){var b,c=this;return b={position:"absolute",left:-9999,top:0,zIndex:-2e4,"white-space":"pre-wrap"},a.each(this.css_attr,function(a,d){return b[d]=c.$inputor.css(d)}),b},b.prototype.create=function(b){return this.$mirror=a("<div></div>"),this.$mirror.css(this.mirrorCss()),this.$mirror.html(b),this.$inputor.after(this.$mirror),this},b.prototype.rect=function(){var a,b,c;return a=this.$mirror.find("#caret"),b=a.position(),c={left:b.left,top:b.top,height:a.height()},this.$mirror.remove(),c},b}(),e={contentEditable:function(a){return!(!a[0].contentEditable||"true"!==a[0].contentEditable)}},f={pos:function(a){return a||0===a?this.setPos(a):this.getPos()},position:function(a){return g.selection?this.getIEPosition(a):this.getPosition(a)},offset:function(b){var c,d;return d=this.getOffset(b),h&&(c=a(h).offset(),d.top+=c.top,d.left+=c.left),d}},g=null,i=null,h=null,a.fn.caret=function(d){var j,k;g=this[0].ownerDocument,i=g.defaultView||g.parentWindow;try{h=i.frameElement}catch(l){k=l}return j=e.contentEditable(this)?new b(this):new c(this),f[d]?f[d].apply(j,Array.prototype.slice.call(arguments,1)):a.error("Method "+d+" does not exist on jQuery.caret")},a.fn.caret.EditableCaret=b,a.fn.caret.InputCaret=c,a.fn.caret.Utils=e,a.fn.caret.apis=f})}).call(this);
},{}],155:[function(require,module,exports){
(function (global){
/**
 * marked - a markdown parser
 * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/chjj/marked
 */

;(function() {

/**
 * Block-Level Grammar
 */

var block = {
  newline: /^\n+/,
  code: /^( {4}[^\n]+\n*)+/,
  fences: noop,
  hr: /^( *[-*_]){3,} *(?:\n+|$)/,
  heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
  nptable: noop,
  lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
  blockquote: /^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/,
  list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
  html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
  table: noop,
  paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
  text: /^[^\n]+/
};

block.bullet = /(?:[*+-]|\d+\.)/;
block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
block.item = replace(block.item, 'gm')
  (/bull/g, block.bullet)
  ();

block.list = replace(block.list)
  (/bull/g, block.bullet)
  ('hr', '\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))')
  ('def', '\\n+(?=' + block.def.source + ')')
  ();

block.blockquote = replace(block.blockquote)
  ('def', block.def)
  ();

block._tag = '(?!(?:'
  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
  + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b';

block.html = replace(block.html)
  ('comment', /<!--[\s\S]*?-->/)
  ('closed', /<(tag)[\s\S]+?<\/\1>/)
  ('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)
  (/tag/g, block._tag)
  ();

block.paragraph = replace(block.paragraph)
  ('hr', block.hr)
  ('heading', block.heading)
  ('lheading', block.lheading)
  ('blockquote', block.blockquote)
  ('tag', '<' + block._tag)
  ('def', block.def)
  ();

/**
 * Normal Block Grammar
 */

block.normal = merge({}, block);

/**
 * GFM Block Grammar
 */

block.gfm = merge({}, block.normal, {
  fences: /^ *(`{3,}|~{3,}) *(\S+)? *\n([\s\S]+?)\s*\1 *(?:\n+|$)/,
  paragraph: /^/
});

block.gfm.paragraph = replace(block.paragraph)
  ('(?!', '(?!'
    + block.gfm.fences.source.replace('\\1', '\\2') + '|'
    + block.list.source.replace('\\1', '\\3') + '|')
  ();

/**
 * GFM + Tables Block Grammar
 */

block.tables = merge({}, block.gfm, {
  nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
  table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
});

/**
 * Block Lexer
 */

function Lexer(options) {
  this.tokens = [];
  this.tokens.links = {};
  this.options = options || marked.defaults;
  this.rules = block.normal;

  if (this.options.gfm) {
    if (this.options.tables) {
      this.rules = block.tables;
    } else {
      this.rules = block.gfm;
    }
  }
}

/**
 * Expose Block Rules
 */

Lexer.rules = block;

/**
 * Static Lex Method
 */

Lexer.lex = function(src, options) {
  var lexer = new Lexer(options);
  return lexer.lex(src);
};

/**
 * Preprocessing
 */

Lexer.prototype.lex = function(src) {
  src = src
    .replace(/\r\n|\r/g, '\n')
    .replace(/\t/g, '    ')
    .replace(/\u00a0/g, ' ')
    .replace(/\u2424/g, '\n');

  return this.token(src, true);
};

/**
 * Lexing
 */

Lexer.prototype.token = function(src, top, bq) {
  var src = src.replace(/^ +$/gm, '')
    , next
    , loose
    , cap
    , bull
    , b
    , item
    , space
    , i
    , l;

  while (src) {
    // newline
    if (cap = this.rules.newline.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[0].length > 1) {
        this.tokens.push({
          type: 'space'
        });
      }
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      cap = cap[0].replace(/^ {4}/gm, '');
      this.tokens.push({
        type: 'code',
        text: !this.options.pedantic
          ? cap.replace(/\n+$/, '')
          : cap
      });
      continue;
    }

    // fences (gfm)
    if (cap = this.rules.fences.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'code',
        lang: cap[2],
        text: cap[3]
      });
      continue;
    }

    // heading
    if (cap = this.rules.heading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[1].length,
        text: cap[2]
      });
      continue;
    }

    // table no leading pipe (gfm)
    if (top && (cap = this.rules.nptable.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i].split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // lheading
    if (cap = this.rules.lheading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[2] === '=' ? 1 : 2,
        text: cap[1]
      });
      continue;
    }

    // hr
    if (cap = this.rules.hr.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'hr'
      });
      continue;
    }

    // blockquote
    if (cap = this.rules.blockquote.exec(src)) {
      src = src.substring(cap[0].length);

      this.tokens.push({
        type: 'blockquote_start'
      });

      cap = cap[0].replace(/^ *> ?/gm, '');

      // Pass `top` to keep the current
      // "toplevel" state. This is exactly
      // how markdown.pl works.
      this.token(cap, top, true);

      this.tokens.push({
        type: 'blockquote_end'
      });

      continue;
    }

    // list
    if (cap = this.rules.list.exec(src)) {
      src = src.substring(cap[0].length);
      bull = cap[2];

      this.tokens.push({
        type: 'list_start',
        ordered: bull.length > 1
      });

      // Get each top-level item.
      cap = cap[0].match(this.rules.item);

      next = false;
      l = cap.length;
      i = 0;

      for (; i < l; i++) {
        item = cap[i];

        // Remove the list item's bullet
        // so it is seen as the next token.
        space = item.length;
        item = item.replace(/^ *([*+-]|\d+\.) +/, '');

        // Outdent whatever the
        // list item contains. Hacky.
        if (~item.indexOf('\n ')) {
          space -= item.length;
          item = !this.options.pedantic
            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
            : item.replace(/^ {1,4}/gm, '');
        }

        // Determine whether the next list item belongs here.
        // Backpedal if it does not belong in this list.
        if (this.options.smartLists && i !== l - 1) {
          b = block.bullet.exec(cap[i + 1])[0];
          if (bull !== b && !(bull.length > 1 && b.length > 1)) {
            src = cap.slice(i + 1).join('\n') + src;
            i = l - 1;
          }
        }

        // Determine whether item is loose or not.
        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
        // for discount behavior.
        loose = next || /\n\n(?!\s*$)/.test(item);
        if (i !== l - 1) {
          next = item.charAt(item.length - 1) === '\n';
          if (!loose) loose = next;
        }

        this.tokens.push({
          type: loose
            ? 'loose_item_start'
            : 'list_item_start'
        });

        // Recurse.
        this.token(item, false, bq);

        this.tokens.push({
          type: 'list_item_end'
        });
      }

      this.tokens.push({
        type: 'list_end'
      });

      continue;
    }

    // html
    if (cap = this.rules.html.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: this.options.sanitize
          ? 'paragraph'
          : 'html',
        pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',
        text: cap[0]
      });
      continue;
    }

    // def
    if ((!bq && top) && (cap = this.rules.def.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.links[cap[1].toLowerCase()] = {
        href: cap[2],
        title: cap[3]
      };
      continue;
    }

    // table (gfm)
    if (top && (cap = this.rules.table.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i]
          .replace(/^ *\| *| *\| *$/g, '')
          .split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // top-level paragraph
    if (top && (cap = this.rules.paragraph.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'paragraph',
        text: cap[1].charAt(cap[1].length - 1) === '\n'
          ? cap[1].slice(0, -1)
          : cap[1]
      });
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      // Top-level should never reach here.
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'text',
        text: cap[0]
      });
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return this.tokens;
};

/**
 * Inline-Level Grammar
 */

var inline = {
  escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
  autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
  url: noop,
  tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
  link: /^!?\[(inside)\]\(href\)/,
  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
  nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
  strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
  em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
  code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
  br: /^ {2,}\n(?!\s*$)/,
  del: noop,
  text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
};

inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;
inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;

inline.link = replace(inline.link)
  ('inside', inline._inside)
  ('href', inline._href)
  ();

inline.reflink = replace(inline.reflink)
  ('inside', inline._inside)
  ();

/**
 * Normal Inline Grammar
 */

inline.normal = merge({}, inline);

/**
 * Pedantic Inline Grammar
 */

inline.pedantic = merge({}, inline.normal, {
  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
});

/**
 * GFM Inline Grammar
 */

inline.gfm = merge({}, inline.normal, {
  escape: replace(inline.escape)('])', '~|])')(),
  url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
  del: /^~~(?=\S)([\s\S]*?\S)~~/,
  text: replace(inline.text)
    (']|', '~]|')
    ('|', '|https?://|')
    ()
});

/**
 * GFM + Line Breaks Inline Grammar
 */

inline.breaks = merge({}, inline.gfm, {
  br: replace(inline.br)('{2,}', '*')(),
  text: replace(inline.gfm.text)('{2,}', '*')()
});

/**
 * Inline Lexer & Compiler
 */

function InlineLexer(links, options) {
  this.options = options || marked.defaults;
  this.links = links;
  this.rules = inline.normal;
  this.renderer = this.options.renderer || new Renderer;
  this.renderer.options = this.options;

  if (!this.links) {
    throw new
      Error('Tokens array requires a `links` property.');
  }

  if (this.options.gfm) {
    if (this.options.breaks) {
      this.rules = inline.breaks;
    } else {
      this.rules = inline.gfm;
    }
  } else if (this.options.pedantic) {
    this.rules = inline.pedantic;
  }
}

/**
 * Expose Inline Rules
 */

InlineLexer.rules = inline;

/**
 * Static Lexing/Compiling Method
 */

InlineLexer.output = function(src, links, options) {
  var inline = new InlineLexer(links, options);
  return inline.output(src);
};

/**
 * Lexing/Compiling
 */

InlineLexer.prototype.output = function(src) {
  var out = ''
    , link
    , text
    , href
    , cap;

  while (src) {
    // escape
    if (cap = this.rules.escape.exec(src)) {
      src = src.substring(cap[0].length);
      out += cap[1];
      continue;
    }

    // autolink
    if (cap = this.rules.autolink.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[2] === '@') {
        text = cap[1].charAt(6) === ':'
          ? this.mangle(cap[1].substring(7))
          : this.mangle(cap[1]);
        href = this.mangle('mailto:') + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      out += this.renderer.link(href, null, text);
      continue;
    }

    // url (gfm)
    if (!this.inLink && (cap = this.rules.url.exec(src))) {
      src = src.substring(cap[0].length);
      text = escape(cap[1]);
      href = text;
      out += this.renderer.link(href, null, text);
      continue;
    }

    // tag
    if (cap = this.rules.tag.exec(src)) {
      if (!this.inLink && /^<a /i.test(cap[0])) {
        this.inLink = true;
      } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
        this.inLink = false;
      }
      src = src.substring(cap[0].length);
      out += this.options.sanitize
        ? escape(cap[0])
        : cap[0];
      continue;
    }

    // link
    if (cap = this.rules.link.exec(src)) {
      src = src.substring(cap[0].length);
      this.inLink = true;
      out += this.outputLink(cap, {
        href: cap[2],
        title: cap[3]
      });
      this.inLink = false;
      continue;
    }

    // reflink, nolink
    if ((cap = this.rules.reflink.exec(src))
        || (cap = this.rules.nolink.exec(src))) {
      src = src.substring(cap[0].length);
      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = this.links[link.toLowerCase()];
      if (!link || !link.href) {
        out += cap[0].charAt(0);
        src = cap[0].substring(1) + src;
        continue;
      }
      this.inLink = true;
      out += this.outputLink(cap, link);
      this.inLink = false;
      continue;
    }

    // strong
    if (cap = this.rules.strong.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.strong(this.output(cap[2] || cap[1]));
      continue;
    }

    // em
    if (cap = this.rules.em.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.em(this.output(cap[2] || cap[1]));
      continue;
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.codespan(escape(cap[2], true));
      continue;
    }

    // br
    if (cap = this.rules.br.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.br();
      continue;
    }

    // del (gfm)
    if (cap = this.rules.del.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.del(this.output(cap[1]));
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      src = src.substring(cap[0].length);
      out += escape(this.smartypants(cap[0]));
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return out;
};

/**
 * Compile Link
 */

InlineLexer.prototype.outputLink = function(cap, link) {
  var href = escape(link.href)
    , title = link.title ? escape(link.title) : null;

  return cap[0].charAt(0) !== '!'
    ? this.renderer.link(href, title, this.output(cap[1]))
    : this.renderer.image(href, title, escape(cap[1]));
};

/**
 * Smartypants Transformations
 */

InlineLexer.prototype.smartypants = function(text) {
  if (!this.options.smartypants) return text;
  return text
    // em-dashes
    .replace(/--/g, '\u2014')
    // opening singles
    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
    // closing singles & apostrophes
    .replace(/'/g, '\u2019')
    // opening doubles
    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
    // closing doubles
    .replace(/"/g, '\u201d')
    // ellipses
    .replace(/\.{3}/g, '\u2026');
};

/**
 * Mangle Links
 */

InlineLexer.prototype.mangle = function(text) {
  var out = ''
    , l = text.length
    , i = 0
    , ch;

  for (; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = 'x' + ch.toString(16);
    }
    out += '&#' + ch + ';';
  }

  return out;
};

/**
 * Renderer
 */

function Renderer(options) {
  this.options = options || {};
}

Renderer.prototype.code = function(code, lang, escaped) {
  if (this.options.highlight) {
    var out = this.options.highlight(code, lang);
    if (out != null && out !== code) {
      escaped = true;
      code = out;
    }
  }

  if (!lang) {
    return '<pre><code>'
      + (escaped ? code : escape(code, true))
      + '\n</code></pre>';
  }

  return '<pre><code class="'
    + this.options.langPrefix
    + escape(lang, true)
    + '">'
    + (escaped ? code : escape(code, true))
    + '\n</code></pre>\n';
};

Renderer.prototype.blockquote = function(quote) {
  return '<blockquote>\n' + quote + '</blockquote>\n';
};

Renderer.prototype.html = function(html) {
  return html;
};

Renderer.prototype.heading = function(text, level, raw) {
  return '<h'
    + level
    + ' id="'
    + this.options.headerPrefix
    + raw.toLowerCase().replace(/[^\w]+/g, '-')
    + '">'
    + text
    + '</h'
    + level
    + '>\n';
};

Renderer.prototype.hr = function() {
  return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
};

Renderer.prototype.list = function(body, ordered) {
  var type = ordered ? 'ol' : 'ul';
  return '<' + type + '>\n' + body + '</' + type + '>\n';
};

Renderer.prototype.listitem = function(text) {
  return '<li>' + text + '</li>\n';
};

Renderer.prototype.paragraph = function(text) {
  return '<p>' + text + '</p>\n';
};

Renderer.prototype.table = function(header, body) {
  return '<table>\n'
    + '<thead>\n'
    + header
    + '</thead>\n'
    + '<tbody>\n'
    + body
    + '</tbody>\n'
    + '</table>\n';
};

Renderer.prototype.tablerow = function(content) {
  return '<tr>\n' + content + '</tr>\n';
};

Renderer.prototype.tablecell = function(content, flags) {
  var type = flags.header ? 'th' : 'td';
  var tag = flags.align
    ? '<' + type + ' style="text-align:' + flags.align + '">'
    : '<' + type + '>';
  return tag + content + '</' + type + '>\n';
};

// span level renderer
Renderer.prototype.strong = function(text) {
  return '<strong>' + text + '</strong>';
};

Renderer.prototype.em = function(text) {
  return '<em>' + text + '</em>';
};

Renderer.prototype.codespan = function(text) {
  return '<code>' + text + '</code>';
};

Renderer.prototype.br = function() {
  return this.options.xhtml ? '<br/>' : '<br>';
};

Renderer.prototype.del = function(text) {
  return '<del>' + text + '</del>';
};

Renderer.prototype.link = function(href, title, text) {
  if (this.options.sanitize) {
    try {
      var prot = decodeURIComponent(unescape(href))
        .replace(/[^\w:]/g, '')
        .toLowerCase();
    } catch (e) {
      return '';
    }
    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0) {
      return '';
    }
  }
  var out = '<a href="' + href + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += '>' + text + '</a>';
  return out;
};

Renderer.prototype.image = function(href, title, text) {
  var out = '<img src="' + href + '" alt="' + text + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += this.options.xhtml ? '/>' : '>';
  return out;
};

/**
 * Parsing & Compiling
 */

function Parser(options) {
  this.tokens = [];
  this.token = null;
  this.options = options || marked.defaults;
  this.options.renderer = this.options.renderer || new Renderer;
  this.renderer = this.options.renderer;
  this.renderer.options = this.options;
}

/**
 * Static Parse Method
 */

Parser.parse = function(src, options, renderer) {
  var parser = new Parser(options, renderer);
  return parser.parse(src);
};

/**
 * Parse Loop
 */

Parser.prototype.parse = function(src) {
  this.inline = new InlineLexer(src.links, this.options, this.renderer);
  this.tokens = src.reverse();

  var out = '';
  while (this.next()) {
    out += this.tok();
  }

  return out;
};

/**
 * Next Token
 */

Parser.prototype.next = function() {
  return this.token = this.tokens.pop();
};

/**
 * Preview Next Token
 */

Parser.prototype.peek = function() {
  return this.tokens[this.tokens.length - 1] || 0;
};

/**
 * Parse Text Tokens
 */

Parser.prototype.parseText = function() {
  var body = this.token.text;

  while (this.peek().type === 'text') {
    body += '\n' + this.next().text;
  }

  return this.inline.output(body);
};

/**
 * Parse Current Token
 */

Parser.prototype.tok = function() {
  switch (this.token.type) {
    case 'space': {
      return '';
    }
    case 'hr': {
      return this.renderer.hr();
    }
    case 'heading': {
      return this.renderer.heading(
        this.inline.output(this.token.text),
        this.token.depth,
        this.token.text);
    }
    case 'code': {
      return this.renderer.code(this.token.text,
        this.token.lang,
        this.token.escaped);
    }
    case 'table': {
      var header = ''
        , body = ''
        , i
        , row
        , cell
        , flags
        , j;

      // header
      cell = '';
      for (i = 0; i < this.token.header.length; i++) {
        flags = { header: true, align: this.token.align[i] };
        cell += this.renderer.tablecell(
          this.inline.output(this.token.header[i]),
          { header: true, align: this.token.align[i] }
        );
      }
      header += this.renderer.tablerow(cell);

      for (i = 0; i < this.token.cells.length; i++) {
        row = this.token.cells[i];

        cell = '';
        for (j = 0; j < row.length; j++) {
          cell += this.renderer.tablecell(
            this.inline.output(row[j]),
            { header: false, align: this.token.align[j] }
          );
        }

        body += this.renderer.tablerow(cell);
      }
      return this.renderer.table(header, body);
    }
    case 'blockquote_start': {
      var body = '';

      while (this.next().type !== 'blockquote_end') {
        body += this.tok();
      }

      return this.renderer.blockquote(body);
    }
    case 'list_start': {
      var body = ''
        , ordered = this.token.ordered;

      while (this.next().type !== 'list_end') {
        body += this.tok();
      }

      return this.renderer.list(body, ordered);
    }
    case 'list_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.token.type === 'text'
          ? this.parseText()
          : this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'loose_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'html': {
      var html = !this.token.pre && !this.options.pedantic
        ? this.inline.output(this.token.text)
        : this.token.text;
      return this.renderer.html(html);
    }
    case 'paragraph': {
      return this.renderer.paragraph(this.inline.output(this.token.text));
    }
    case 'text': {
      return this.renderer.paragraph(this.parseText());
    }
  }
};

/**
 * Helpers
 */

function escape(html, encode) {
  return html
    .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function unescape(html) {
  return html.replace(/&([#\w]+);/g, function(_, n) {
    n = n.toLowerCase();
    if (n === 'colon') return ':';
    if (n.charAt(0) === '#') {
      return n.charAt(1) === 'x'
        ? String.fromCharCode(parseInt(n.substring(2), 16))
        : String.fromCharCode(+n.substring(1));
    }
    return '';
  });
}

function replace(regex, opt) {
  regex = regex.source;
  opt = opt || '';
  return function self(name, val) {
    if (!name) return new RegExp(regex, opt);
    val = val.source || val;
    val = val.replace(/(^|[^\[])\^/g, '$1');
    regex = regex.replace(name, val);
    return self;
  };
}

function noop() {}
noop.exec = noop;

function merge(obj) {
  var i = 1
    , target
    , key;

  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }

  return obj;
}


/**
 * Marked
 */

function marked(src, opt, callback) {
  if (callback || typeof opt === 'function') {
    if (!callback) {
      callback = opt;
      opt = null;
    }

    opt = merge({}, marked.defaults, opt || {});

    var highlight = opt.highlight
      , tokens
      , pending
      , i = 0;

    try {
      tokens = Lexer.lex(src, opt)
    } catch (e) {
      return callback(e);
    }

    pending = tokens.length;

    var done = function(err) {
      if (err) {
        opt.highlight = highlight;
        return callback(err);
      }

      var out;

      try {
        out = Parser.parse(tokens, opt);
      } catch (e) {
        err = e;
      }

      opt.highlight = highlight;

      return err
        ? callback(err)
        : callback(null, out);
    };

    if (!highlight || highlight.length < 3) {
      return done();
    }

    delete opt.highlight;

    if (!pending) return done();

    for (; i < tokens.length; i++) {
      (function(token) {
        if (token.type !== 'code') {
          return --pending || done();
        }
        return highlight(token.text, token.lang, function(err, code) {
          if (err) return done(err);
          if (code == null || code === token.text) {
            return --pending || done();
          }
          token.text = code;
          token.escaped = true;
          --pending || done();
        });
      })(tokens[i]);
    }

    return;
  }
  try {
    if (opt) opt = merge({}, marked.defaults, opt);
    return Parser.parse(Lexer.lex(src, opt), opt);
  } catch (e) {
    e.message += '\nPlease report this to https://github.com/chjj/marked.';
    if ((opt || marked.defaults).silent) {
      return '<p>An error occured:</p><pre>'
        + escape(e.message + '', true)
        + '</pre>';
    }
    throw e;
  }
}

/**
 * Options
 */

marked.options =
marked.setOptions = function(opt) {
  merge(marked.defaults, opt);
  return marked;
};

marked.defaults = {
  gfm: true,
  tables: true,
  breaks: false,
  pedantic: false,
  sanitize: false,
  smartLists: false,
  silent: false,
  highlight: null,
  langPrefix: 'lang-',
  smartypants: false,
  headerPrefix: '',
  renderer: new Renderer,
  xhtml: false
};

/**
 * Expose
 */

marked.Parser = Parser;
marked.parser = Parser.parse;

marked.Renderer = Renderer;

marked.Lexer = Lexer;
marked.lexer = Lexer.lex;

marked.InlineLexer = InlineLexer;
marked.inlineLexer = InlineLexer.output;

marked.parse = marked;

if (typeof module !== 'undefined' && typeof exports === 'object') {
  module.exports = marked;
} else if (typeof define === 'function' && define.amd) {
  define(function() { return marked; });
} else {
  this.marked = marked;
}

}).call(function() {
  return this || (typeof window !== 'undefined' ? window : global);
}());

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],156:[function(require,module,exports){
//! moment.js
//! version : 2.5.0
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

(function (undefined) {

    /************************************
        Constants
    ************************************/

    var moment,
        VERSION = "2.5.0",
        global = this,
        round = Math.round,
        i,

        YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,

        // internal storage for language config files
        languages = {},

        // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module.exports && typeof require !== 'undefined'),

        // ASP.NET json date format regex
        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,

        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,

        // format tokens
        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,

        // parsing token regexes
        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
        parseTokenOneToFourDigits = /\d{1,4}/, // 0 - 9999
        parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
        parseTokenDigits = /\d+/, // nonzero number of digits
        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
        parseTokenT = /T/i, // T (ISO separator)
        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123

        //strict parsing regexes
        parseTokenOneDigit = /\d/, // 0 - 9
        parseTokenTwoDigits = /\d\d/, // 00 - 99
        parseTokenThreeDigits = /\d{3}/, // 000 - 999
        parseTokenFourDigits = /\d{4}/, // 0000 - 9999
        parseTokenSixDigits = /[+\-]?\d{6}/, // -999,999 - 999,999

        // iso 8601 regex
        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
        isoRegex = /^\s*\d{4}-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,

        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',

        isoDates = [
            'YYYY-MM-DD',
            'GGGG-[W]WW',
            'GGGG-[W]WW-E',
            'YYYY-DDD'
        ],

        // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d{1,3}/],
            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
            ['HH:mm', /(T| )\d\d:\d\d/],
            ['HH', /(T| )\d\d/]
        ],

        // timezone chunker "+10:00" > ["10", "00"] or "-1530" > ["-15", "30"]
        parseTimezoneChunker = /([\+\-]|\d\d)/gi,

        // getter and setter names
        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
        unitMillisecondFactors = {
            'Milliseconds' : 1,
            'Seconds' : 1e3,
            'Minutes' : 6e4,
            'Hours' : 36e5,
            'Days' : 864e5,
            'Months' : 2592e6,
            'Years' : 31536e6
        },

        unitAliases = {
            ms : 'millisecond',
            s : 'second',
            m : 'minute',
            h : 'hour',
            d : 'day',
            D : 'date',
            w : 'week',
            W : 'isoWeek',
            M : 'month',
            y : 'year',
            DDD : 'dayOfYear',
            e : 'weekday',
            E : 'isoWeekday',
            gg: 'weekYear',
            GG: 'isoWeekYear'
        },

        camelFunctions = {
            dayofyear : 'dayOfYear',
            isoweekday : 'isoWeekday',
            isoweek : 'isoWeek',
            weekyear : 'weekYear',
            isoweekyear : 'isoWeekYear'
        },

        // format function strings
        formatFunctions = {},

        // tokens to ordinalize and pad
        ordinalizeTokens = 'DDD w W M D d'.split(' '),
        paddedTokens = 'M D H h m s w W'.split(' '),

        formatTokenFunctions = {
            M    : function () {
                return this.month() + 1;
            },
            MMM  : function (format) {
                return this.lang().monthsShort(this, format);
            },
            MMMM : function (format) {
                return this.lang().months(this, format);
            },
            D    : function () {
                return this.date();
            },
            DDD  : function () {
                return this.dayOfYear();
            },
            d    : function () {
                return this.day();
            },
            dd   : function (format) {
                return this.lang().weekdaysMin(this, format);
            },
            ddd  : function (format) {
                return this.lang().weekdaysShort(this, format);
            },
            dddd : function (format) {
                return this.lang().weekdays(this, format);
            },
            w    : function () {
                return this.week();
            },
            W    : function () {
                return this.isoWeek();
            },
            YY   : function () {
                return leftZeroFill(this.year() % 100, 2);
            },
            YYYY : function () {
                return leftZeroFill(this.year(), 4);
            },
            YYYYY : function () {
                return leftZeroFill(this.year(), 5);
            },
            YYYYYY : function () {
                var y = this.year(), sign = y >= 0 ? '+' : '-';
                return sign + leftZeroFill(Math.abs(y), 6);
            },
            gg   : function () {
                return leftZeroFill(this.weekYear() % 100, 2);
            },
            gggg : function () {
                return this.weekYear();
            },
            ggggg : function () {
                return leftZeroFill(this.weekYear(), 5);
            },
            GG   : function () {
                return leftZeroFill(this.isoWeekYear() % 100, 2);
            },
            GGGG : function () {
                return this.isoWeekYear();
            },
            GGGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 5);
            },
            e : function () {
                return this.weekday();
            },
            E : function () {
                return this.isoWeekday();
            },
            a    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), true);
            },
            A    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), false);
            },
            H    : function () {
                return this.hours();
            },
            h    : function () {
                return this.hours() % 12 || 12;
            },
            m    : function () {
                return this.minutes();
            },
            s    : function () {
                return this.seconds();
            },
            S    : function () {
                return toInt(this.milliseconds() / 100);
            },
            SS   : function () {
                return leftZeroFill(toInt(this.milliseconds() / 10), 2);
            },
            SSS  : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            SSSS : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            Z    : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(toInt(a / 60), 2) + ":" + leftZeroFill(toInt(a) % 60, 2);
            },
            ZZ   : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
            },
            z : function () {
                return this.zoneAbbr();
            },
            zz : function () {
                return this.zoneName();
            },
            X    : function () {
                return this.unix();
            },
            Q : function () {
                return this.quarter();
            }
        },

        lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];

    function padToken(func, count) {
        return function (a) {
            return leftZeroFill(func.call(this, a), count);
        };
    }
    function ordinalizeToken(func, period) {
        return function (a) {
            return this.lang().ordinal(func.call(this, a), period);
        };
    }

    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    }
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);


    /************************************
        Constructors
    ************************************/

    function Language() {

    }

    // Moment prototype object
    function Moment(config) {
        checkOverflow(config);
        extend(this, config);
    }

    // Duration Constructor
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            years * 12;

        this._data = {};

        this._bubble();
    }

    /************************************
        Helpers
    ************************************/


    function extend(a, b) {
        for (var i in b) {
            if (b.hasOwnProperty(i)) {
                a[i] = b[i];
            }
        }

        if (b.hasOwnProperty("toString")) {
            a.toString = b.toString;
        }

        if (b.hasOwnProperty("valueOf")) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    // left zero fill a number
    // see http://jsperf.com/left-zero-filling for performance comparison
    function leftZeroFill(number, targetLength, forceSign) {
        var output = Math.abs(number) + '',
            sign = number >= 0;

        while (output.length < targetLength) {
            output = '0' + output;
        }
        return (sign ? (forceSign ? '+' : '') : '-') + output;
    }

    // helper function for _.addTime and _.subtractTime
    function addOrSubtractDurationFromMoment(mom, duration, isAdding, ignoreUpdateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months,
            minutes,
            hours;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        // store the minutes and hours so we can restore them
        if (days || months) {
            minutes = mom.minute();
            hours = mom.hour();
        }
        if (days) {
            mom.date(mom.date() + days * isAdding);
        }
        if (months) {
            mom.month(mom.month() + months * isAdding);
        }
        if (milliseconds && !ignoreUpdateOffset) {
            moment.updateOffset(mom);
        }
        // restore the minutes and hours after possibly changing dst
        if (days || months) {
            mom.minute(minutes);
            mom.hour(hours);
        }
    }

    // check if is an array
    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return  Object.prototype.toString.call(input) === '[object Date]' ||
                input instanceof Date;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function normalizeUnits(units) {
        if (units) {
            var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
            units = unitAliases[units] || camelFunctions[lowered] || lowered;
        }
        return units;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (inputObject.hasOwnProperty(prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeList(field) {
        var count, setter;

        if (field.indexOf('week') === 0) {
            count = 7;
            setter = 'day';
        }
        else if (field.indexOf('month') === 0) {
            count = 12;
            setter = 'month';
        }
        else {
            return;
        }

        moment[field] = function (format, index) {
            var i, getter,
                method = moment.fn._lang[field],
                results = [];

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            getter = function (i) {
                var m = moment().utc().set(setter, i);
                return method.call(moment.fn._lang, m, format || '');
            };

            if (index != null) {
                return getter(index);
            }
            else {
                for (i = 0; i < count; i++) {
                    results.push(getter(i));
                }
                return results;
            }
        };
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            if (coercedNumber >= 0) {
                value = Math.floor(coercedNumber);
            } else {
                value = Math.ceil(coercedNumber);
            }
        }

        return value;
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    function checkOverflow(m) {
        var overflow;
        if (m._a && m._pf.overflow === -2) {
            overflow =
                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
                m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
                m._a[HOUR] < 0 || m._a[HOUR] > 23 ? HOUR :
                m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
                m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            m._pf.overflow = overflow;
        }
    }

    function initializeParsingFlags(config) {
        config._pf = {
            empty : false,
            unusedTokens : [],
            unusedInput : [],
            overflow : -2,
            charsLeftOver : 0,
            nullInput : false,
            invalidMonth : null,
            invalidFormat : false,
            userInvalidated : false,
            iso: false
        };
    }

    function isValid(m) {
        if (m._isValid == null) {
            m._isValid = !isNaN(m._d.getTime()) &&
                m._pf.overflow < 0 &&
                !m._pf.empty &&
                !m._pf.invalidMonth &&
                !m._pf.nullInput &&
                !m._pf.invalidFormat &&
                !m._pf.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    m._pf.charsLeftOver === 0 &&
                    m._pf.unusedTokens.length === 0;
            }
        }
        return m._isValid;
    }

    function normalizeLanguage(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function makeAs(input, model) {
        return model._isUTC ? moment(input).zone(model._offset || 0) :
            moment(input).local();
    }

    /************************************
        Languages
    ************************************/


    extend(Language.prototype, {

        set : function (config) {
            var prop, i;
            for (i in config) {
                prop = config[i];
                if (typeof prop === 'function') {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
        },

        _months : "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        months : function (m) {
            return this._months[m.month()];
        },

        _monthsShort : "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        monthsShort : function (m) {
            return this._monthsShort[m.month()];
        },

        monthsParse : function (monthName) {
            var i, mom, regex;

            if (!this._monthsParse) {
                this._monthsParse = [];
            }

            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                if (!this._monthsParse[i]) {
                    mom = moment.utc([2000, i]);
                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        },

        _weekdays : "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdays : function (m) {
            return this._weekdays[m.day()];
        },

        _weekdaysShort : "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysShort : function (m) {
            return this._weekdaysShort[m.day()];
        },

        _weekdaysMin : "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        weekdaysMin : function (m) {
            return this._weekdaysMin[m.day()];
        },

        weekdaysParse : function (weekdayName) {
            var i, mom, regex;

            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
            }

            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already
                if (!this._weekdaysParse[i]) {
                    mom = moment([2000, 1]).day(i);
                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        },

        _longDateFormat : {
            LT : "h:mm A",
            L : "MM/DD/YYYY",
            LL : "MMMM D YYYY",
            LLL : "MMMM D YYYY LT",
            LLLL : "dddd, MMMM D YYYY LT"
        },
        longDateFormat : function (key) {
            var output = this._longDateFormat[key];
            if (!output && this._longDateFormat[key.toUpperCase()]) {
                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
                    return val.slice(1);
                });
                this._longDateFormat[key] = output;
            }
            return output;
        },

        isPM : function (input) {
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
            // Using charAt should be more compatible.
            return ((input + '').toLowerCase().charAt(0) === 'p');
        },

        _meridiemParse : /[ap]\.?m?\.?/i,
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        },

        _calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        calendar : function (key, mom) {
            var output = this._calendar[key];
            return typeof output === 'function' ? output.apply(mom) : output;
        },

        _relativeTime : {
            future : "in %s",
            past : "%s ago",
            s : "a few seconds",
            m : "a minute",
            mm : "%d minutes",
            h : "an hour",
            hh : "%d hours",
            d : "a day",
            dd : "%d days",
            M : "a month",
            MM : "%d months",
            y : "a year",
            yy : "%d years"
        },
        relativeTime : function (number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return (typeof output === 'function') ?
                output(number, withoutSuffix, string, isFuture) :
                output.replace(/%d/i, number);
        },
        pastFuture : function (diff, output) {
            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
        },

        ordinal : function (number) {
            return this._ordinal.replace("%d", number);
        },
        _ordinal : "%d",

        preparse : function (string) {
            return string;
        },

        postformat : function (string) {
            return string;
        },

        week : function (mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        },

        _week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        },

        _invalidDate: 'Invalid date',
        invalidDate: function () {
            return this._invalidDate;
        }
    });

    // Loads a language definition into the `languages` cache.  The function
    // takes a key and optionally values.  If not in the browser and no values
    // are provided, it will load the language file module.  As a convenience,
    // this function also returns the language values.
    function loadLang(key, values) {
        values.abbr = key;
        if (!languages[key]) {
            languages[key] = new Language();
        }
        languages[key].set(values);
        return languages[key];
    }

    // Remove a language from the `languages` cache. Mostly useful in tests.
    function unloadLang(key) {
        delete languages[key];
    }

    // Determines which language definition to use and returns it.
    //
    // With no parameters, it will return the global language.  If you
    // pass in a language key, such as 'en', it will return the
    // definition for 'en', so long as 'en' has already been loaded using
    // moment.lang.
    function getLangDefinition(key) {
        var i = 0, j, lang, next, split,
            get = function (k) {
                if (!languages[k] && hasModule) {
                    try {
                        require('./lang/' + k);
                    } catch (e) { }
                }
                return languages[k];
            };

        if (!key) {
            return moment.fn._lang;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            lang = get(key);
            if (lang) {
                return lang;
            }
            key = [key];
        }

        //pick the language from the array
        //try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
        //substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
        while (i < key.length) {
            split = normalizeLanguage(key[i]).split('-');
            j = split.length;
            next = normalizeLanguage(key[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                lang = get(split.slice(0, j).join('-'));
                if (lang) {
                    return lang;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return moment.fn._lang;
    }

    /************************************
        Formatting
    ************************************/


    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = "";
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {

        if (!m.isValid()) {
            return m.lang().invalidDate();
        }

        format = expandFormat(format, m.lang());

        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }

        return formatFunctions[format](m);
    }

    function expandFormat(format, lang) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return lang.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }


    /************************************
        Parsing
    ************************************/


    // get the regex to find the next token
    function getParseRegexForToken(token, config) {
        var a, strict = config._strict;
        switch (token) {
        case 'DDDD':
            return parseTokenThreeDigits;
        case 'YYYY':
        case 'GGGG':
        case 'gggg':
            return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
        case 'YYYYYY':
        case 'YYYYY':
        case 'GGGGG':
        case 'ggggg':
            return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
        case 'S':
            if (strict) { return parseTokenOneDigit; }
            /* falls through */
        case 'SS':
            if (strict) { return parseTokenTwoDigits; }
            /* falls through */
        case 'SSS':
        case 'DDD':
            return strict ? parseTokenThreeDigits : parseTokenOneToThreeDigits;
        case 'MMM':
        case 'MMMM':
        case 'dd':
        case 'ddd':
        case 'dddd':
            return parseTokenWord;
        case 'a':
        case 'A':
            return getLangDefinition(config._l)._meridiemParse;
        case 'X':
            return parseTokenTimestampMs;
        case 'Z':
        case 'ZZ':
            return parseTokenTimezone;
        case 'T':
            return parseTokenT;
        case 'SSSS':
            return parseTokenDigits;
        case 'MM':
        case 'DD':
        case 'YY':
        case 'GG':
        case 'gg':
        case 'HH':
        case 'hh':
        case 'mm':
        case 'ss':
        case 'ww':
        case 'WW':
            return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
        case 'M':
        case 'D':
        case 'd':
        case 'H':
        case 'h':
        case 'm':
        case 's':
        case 'w':
        case 'W':
        case 'e':
        case 'E':
            return strict ? parseTokenOneDigit : parseTokenOneOrTwoDigits;
        default :
            a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), "i"));
            return a;
        }
    }

    function timezoneMinutesFromString(string) {
        string = string || "";
        var possibleTzMatches = (string.match(parseTokenTimezone) || []),
            tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
            parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
            minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? -minutes : minutes;
    }

    // function to convert string input to date
    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;

        switch (token) {
        // MONTH
        case 'M' : // fall through to MM
        case 'MM' :
            if (input != null) {
                datePartArray[MONTH] = toInt(input) - 1;
            }
            break;
        case 'MMM' : // fall through to MMMM
        case 'MMMM' :
            a = getLangDefinition(config._l).monthsParse(input);
            // if we didn't find a month name, mark the date as invalid.
            if (a != null) {
                datePartArray[MONTH] = a;
            } else {
                config._pf.invalidMonth = input;
            }
            break;
        // DAY OF MONTH
        case 'D' : // fall through to DD
        case 'DD' :
            if (input != null) {
                datePartArray[DATE] = toInt(input);
            }
            break;
        // DAY OF YEAR
        case 'DDD' : // fall through to DDDD
        case 'DDDD' :
            if (input != null) {
                config._dayOfYear = toInt(input);
            }

            break;
        // YEAR
        case 'YY' :
            datePartArray[YEAR] = toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
            break;
        case 'YYYY' :
        case 'YYYYY' :
        case 'YYYYYY' :
            datePartArray[YEAR] = toInt(input);
            break;
        // AM / PM
        case 'a' : // fall through to A
        case 'A' :
            config._isPm = getLangDefinition(config._l).isPM(input);
            break;
        // 24 HOUR
        case 'H' : // fall through to hh
        case 'HH' : // fall through to hh
        case 'h' : // fall through to hh
        case 'hh' :
            datePartArray[HOUR] = toInt(input);
            break;
        // MINUTE
        case 'm' : // fall through to mm
        case 'mm' :
            datePartArray[MINUTE] = toInt(input);
            break;
        // SECOND
        case 's' : // fall through to ss
        case 'ss' :
            datePartArray[SECOND] = toInt(input);
            break;
        // MILLISECOND
        case 'S' :
        case 'SS' :
        case 'SSS' :
        case 'SSSS' :
            datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
            break;
        // UNIX TIMESTAMP WITH MS
        case 'X':
            config._d = new Date(parseFloat(input) * 1000);
            break;
        // TIMEZONE
        case 'Z' : // fall through to ZZ
        case 'ZZ' :
            config._useUTC = true;
            config._tzm = timezoneMinutesFromString(input);
            break;
        case 'w':
        case 'ww':
        case 'W':
        case 'WW':
        case 'd':
        case 'dd':
        case 'ddd':
        case 'dddd':
        case 'e':
        case 'E':
            token = token.substr(0, 1);
            /* falls through */
        case 'gg':
        case 'gggg':
        case 'GG':
        case 'GGGG':
        case 'GGGGG':
            token = token.substr(0, 2);
            if (input) {
                config._w = config._w || {};
                config._w[token] = input;
            }
            break;
        }
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function dateFromConfig(config) {
        var i, date, input = [], currentDate,
            yearToUse, fixYear, w, temp, lang, weekday, week;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            fixYear = function (val) {
                var int_val = parseInt(val, 10);
                return val ?
                  (val.length < 3 ? (int_val > 68 ? 1900 + int_val : 2000 + int_val) : int_val) :
                  (config._a[YEAR] == null ? moment().weekYear() : config._a[YEAR]);
            };

            w = config._w;
            if (w.GG != null || w.W != null || w.E != null) {
                temp = dayOfYearFromWeeks(fixYear(w.GG), w.W || 1, w.E, 4, 1);
            }
            else {
                lang = getLangDefinition(config._l);
                weekday = w.d != null ?  parseWeekday(w.d, lang) :
                  (w.e != null ?  parseInt(w.e, 10) + lang._week.dow : 0);

                week = parseInt(w.w, 10) || 1;

                //if we're parsing 'd', then the low day numbers may be next week
                if (w.d != null && weekday < lang._week.dow) {
                    week++;
                }

                temp = dayOfYearFromWeeks(fixYear(w.gg), week, weekday, lang._week.doy, lang._week.dow);
            }

            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = config._a[YEAR] == null ? currentDate[YEAR] : config._a[YEAR];

            if (config._dayOfYear > daysInYear(yearToUse)) {
                config._pf._overflowDayOfYear = true;
            }

            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // add the offsets to the time to be parsed so that we can have a clean array for checking isValid
        input[HOUR] += toInt((config._tzm || 0) / 60);
        input[MINUTE] += toInt((config._tzm || 0) % 60);

        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
    }

    function dateFromObject(config) {
        var normalizedInput;

        if (config._d) {
            return;
        }

        normalizedInput = normalizeObjectUnits(config._i);
        config._a = [
            normalizedInput.year,
            normalizedInput.month,
            normalizedInput.day,
            normalizedInput.hour,
            normalizedInput.minute,
            normalizedInput.second,
            normalizedInput.millisecond
        ];

        dateFromConfig(config);
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [
                now.getUTCFullYear(),
                now.getUTCMonth(),
                now.getUTCDate()
            ];
        } else {
            return [now.getFullYear(), now.getMonth(), now.getDate()];
        }
    }

    // date from string and format string
    function makeDateFromStringAndFormat(config) {

        config._a = [];
        config._pf.empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var lang = getLangDefinition(config._l),
            string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, lang).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    config._pf.unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    config._pf.empty = false;
                }
                else {
                    config._pf.unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                config._pf.unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            config._pf.unusedInput.push(string);
        }

        // handle am pm
        if (config._isPm && config._a[HOUR] < 12) {
            config._a[HOUR] += 12;
        }
        // if is 12 am, change hours to 0
        if (config._isPm === false && config._a[HOUR] === 12) {
            config._a[HOUR] = 0;
        }

        dateFromConfig(config);
        checkOverflow(config);
    }

    function unescapeFormat(s) {
        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        });
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function regexpEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    // date from string and array of format strings
    function makeDateFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            config._pf.invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = extend({}, config);
            initializeParsingFlags(tempConfig);
            tempConfig._f = config._f[i];
            makeDateFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += tempConfig._pf.charsLeftOver;

            //or tokens
            currentScore += tempConfig._pf.unusedTokens.length * 10;

            tempConfig._pf.score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    // date from iso format
    function makeDateFromString(config) {
        var i,
            string = config._i,
            match = isoRegex.exec(string);

        if (match) {
            config._pf.iso = true;
            for (i = 4; i > 0; i--) {
                if (match[i]) {
                    // match[5] should be "T" or undefined
                    config._f = isoDates[i - 1] + (match[6] || " ");
                    break;
                }
            }
            for (i = 0; i < 4; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (string.match(parseTokenTimezone)) {
                config._f += "Z";
            }
            makeDateFromStringAndFormat(config);
        }
        else {
            config._d = new Date(string);
        }
    }

    function makeDateFromInput(config) {
        var input = config._i,
            matched = aspNetJsonRegex.exec(input);

        if (input === undefined) {
            config._d = new Date();
        } else if (matched) {
            config._d = new Date(+matched[1]);
        } else if (typeof input === 'string') {
            makeDateFromString(config);
        } else if (isArray(input)) {
            config._a = input.slice(0);
            dateFromConfig(config);
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if (typeof(input) === 'object') {
            dateFromObject(config);
        } else {
            config._d = new Date(input);
        }
    }

    function makeDate(y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function makeUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    function parseWeekday(input, language) {
        if (typeof input === 'string') {
            if (!isNaN(input)) {
                input = parseInt(input, 10);
            }
            else {
                input = language.weekdaysParse(input);
                if (typeof input !== 'number') {
                    return null;
                }
            }
        }
        return input;
    }

    /************************************
        Relative Time
    ************************************/


    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {
        return lang.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime(milliseconds, withoutSuffix, lang) {
        var seconds = round(Math.abs(milliseconds) / 1000),
            minutes = round(seconds / 60),
            hours = round(minutes / 60),
            days = round(hours / 24),
            years = round(days / 365),
            args = seconds < 45 && ['s', seconds] ||
                minutes === 1 && ['m'] ||
                minutes < 45 && ['mm', minutes] ||
                hours === 1 && ['h'] ||
                hours < 22 && ['hh', hours] ||
                days === 1 && ['d'] ||
                days <= 25 && ['dd', days] ||
                days <= 45 && ['M'] ||
                days < 345 && ['MM', round(days / 30)] ||
                years === 1 && ['y'] || ['yy', years];
        args[2] = withoutSuffix;
        args[3] = milliseconds > 0;
        args[4] = lang;
        return substituteTimeAgo.apply({}, args);
    }


    /************************************
        Week of Year
    ************************************/


    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = moment(mom).add('d', daysToDayOfWeek);
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        // The only solid way to create an iso date from year is to use
        // a string format (Date.UTC handles only years > 1900). Don't ask why
        // it doesn't need Z at the end.
        var d = new Date(leftZeroFill(year, 6, true) + '-01-01').getUTCDay(),
            daysToAdd, dayOfYear;

        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;

        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    /************************************
        Top Level Functions
    ************************************/

    function makeMoment(config) {
        var input = config._i,
            format = config._f;

        if (typeof config._pf === 'undefined') {
            initializeParsingFlags(config);
        }

        if (input === null) {
            return moment.invalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = getLangDefinition().preparse(input);
        }

        if (moment.isMoment(input)) {
            config = extend({}, input);

            config._d = new Date(+input._d);
        } else if (format) {
            if (isArray(format)) {
                makeDateFromStringAndArray(config);
            } else {
                makeDateFromStringAndFormat(config);
            }
        } else {
            makeDateFromInput(config);
        }

        return new Moment(config);
    }

    moment = function (input, format, lang, strict) {
        if (typeof(lang) === "boolean") {
            strict = lang;
            lang = undefined;
        }
        return makeMoment({
            _i : input,
            _f : format,
            _l : lang,
            _strict : strict,
            _isUTC : false
        });
    };

    // creating with utc
    moment.utc = function (input, format, lang, strict) {
        var m;

        if (typeof(lang) === "boolean") {
            strict = lang;
            lang = undefined;
        }
        m = makeMoment({
            _useUTC : true,
            _isUTC : true,
            _l : lang,
            _i : input,
            _f : format,
            _strict : strict
        }).utc();

        return m;
    };

    // creating with unix timestamp (in seconds)
    moment.unix = function (input) {
        return moment(input * 1000);
    };

    // duration
    moment.duration = function (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            parseIso;

        if (moment.isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
            sign = (match[1] === "-") ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoDurationRegex.exec(input))) {
            sign = (match[1] === "-") ? -1 : 1;
            parseIso = function (inp) {
                // We'd normally use ~~inp for this, but unfortunately it also
                // converts floats to ints.
                // inp may be undefined, so careful calling replace on it.
                var res = inp && parseFloat(inp.replace(',', '.'));
                // apply sign while we're at it
                return (isNaN(res) ? 0 : res) * sign;
            };
            duration = {
                y: parseIso(match[2]),
                M: parseIso(match[3]),
                d: parseIso(match[4]),
                h: parseIso(match[5]),
                m: parseIso(match[6]),
                s: parseIso(match[7]),
                w: parseIso(match[8])
            };
        }

        ret = new Duration(duration);

        if (moment.isDuration(input) && input.hasOwnProperty('_lang')) {
            ret._lang = input._lang;
        }

        return ret;
    };

    // version number
    moment.version = VERSION;

    // default format
    moment.defaultFormat = isoFormat;

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    moment.updateOffset = function () {};

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    moment.lang = function (key, values) {
        var r;
        if (!key) {
            return moment.fn._lang._abbr;
        }
        if (values) {
            loadLang(normalizeLanguage(key), values);
        } else if (values === null) {
            unloadLang(key);
            key = 'en';
        } else if (!languages[key]) {
            getLangDefinition(key);
        }
        r = moment.duration.fn._lang = moment.fn._lang = getLangDefinition(key);
        return r._abbr;
    };

    // returns language data
    moment.langData = function (key) {
        if (key && key._lang && key._lang._abbr) {
            key = key._lang._abbr;
        }
        return getLangDefinition(key);
    };

    // compare moment object
    moment.isMoment = function (obj) {
        return obj instanceof Moment;
    };

    // for typechecking Duration objects
    moment.isDuration = function (obj) {
        return obj instanceof Duration;
    };

    for (i = lists.length - 1; i >= 0; --i) {
        makeList(lists[i]);
    }

    moment.normalizeUnits = function (units) {
        return normalizeUnits(units);
    };

    moment.invalid = function (flags) {
        var m = moment.utc(NaN);
        if (flags != null) {
            extend(m._pf, flags);
        }
        else {
            m._pf.userInvalidated = true;
        }

        return m;
    };

    moment.parseZone = function (input) {
        return moment(input).parseZone();
    };

    /************************************
        Moment Prototype
    ************************************/


    extend(moment.fn = Moment.prototype, {

        clone : function () {
            return moment(this);
        },

        valueOf : function () {
            return +this._d + ((this._offset || 0) * 60000);
        },

        unix : function () {
            return Math.floor(+this / 1000);
        },

        toString : function () {
            return this.clone().lang('en').format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        },

        toDate : function () {
            return this._offset ? new Date(+this) : this._d;
        },

        toISOString : function () {
            var m = moment(this).utc();
            if (0 < m.year() && m.year() <= 9999) {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            } else {
                return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        },

        toArray : function () {
            var m = this;
            return [
                m.year(),
                m.month(),
                m.date(),
                m.hours(),
                m.minutes(),
                m.seconds(),
                m.milliseconds()
            ];
        },

        isValid : function () {
            return isValid(this);
        },

        isDSTShifted : function () {

            if (this._a) {
                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
            }

            return false;
        },

        parsingFlags : function () {
            return extend({}, this._pf);
        },

        invalidAt: function () {
            return this._pf.overflow;
        },

        utc : function () {
            return this.zone(0);
        },

        local : function () {
            this.zone(0);
            this._isUTC = false;
            return this;
        },

        format : function (inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat);
            return this.lang().postformat(output);
        },

        add : function (input, val) {
            var dur;
            // switch args to support add('s', 1) and add(1, 's')
            if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, 1);
            return this;
        },

        subtract : function (input, val) {
            var dur;
            // switch args to support subtract('s', 1) and subtract(1, 's')
            if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, -1);
            return this;
        },

        diff : function (input, units, asFloat) {
            var that = makeAs(input, this),
                zoneDiff = (this.zone() - that.zone()) * 6e4,
                diff, output;

            units = normalizeUnits(units);

            if (units === 'year' || units === 'month') {
                // average number of days in the months in the given dates
                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2
                // difference in months
                output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
                // adjust by taking difference in days, average number of days
                // and dst in the given months.
                output += ((this - moment(this).startOf('month')) -
                        (that - moment(that).startOf('month'))) / diff;
                // same as above but with zones, to negate all dst
                output -= ((this.zone() - moment(this).startOf('month').zone()) -
                        (that.zone() - moment(that).startOf('month').zone())) * 6e4 / diff;
                if (units === 'year') {
                    output = output / 12;
                }
            } else {
                diff = (this - that);
                output = units === 'second' ? diff / 1e3 : // 1000
                    units === 'minute' ? diff / 6e4 : // 1000 * 60
                    units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
                    units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                    units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                    diff;
            }
            return asFloat ? output : absRound(output);
        },

        from : function (time, withoutSuffix) {
            return moment.duration(this.diff(time)).lang(this.lang()._abbr).humanize(!withoutSuffix);
        },

        fromNow : function (withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },

        calendar : function () {
            // We want to compare the start of today, vs this.
            // Getting start-of-today depends on whether we're zone'd or not.
            var sod = makeAs(moment(), this).startOf('day'),
                diff = this.diff(sod, 'days', true),
                format = diff < -6 ? 'sameElse' :
                    diff < -1 ? 'lastWeek' :
                    diff < 0 ? 'lastDay' :
                    diff < 1 ? 'sameDay' :
                    diff < 2 ? 'nextDay' :
                    diff < 7 ? 'nextWeek' : 'sameElse';
            return this.format(this.lang().calendar(format, this));
        },

        isLeapYear : function () {
            return isLeapYear(this.year());
        },

        isDST : function () {
            return (this.zone() < this.clone().month(0).zone() ||
                this.zone() < this.clone().month(5).zone());
        },

        day : function (input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.lang());
                return this.add({ d : input - day });
            } else {
                return day;
            }
        },

        month : function (input) {
            var utc = this._isUTC ? 'UTC' : '',
                dayOfMonth;

            if (input != null) {
                if (typeof input === 'string') {
                    input = this.lang().monthsParse(input);
                    if (typeof input !== 'number') {
                        return this;
                    }
                }

                dayOfMonth = this.date();
                this.date(1);
                this._d['set' + utc + 'Month'](input);
                this.date(Math.min(dayOfMonth, this.daysInMonth()));

                moment.updateOffset(this);
                return this;
            } else {
                return this._d['get' + utc + 'Month']();
            }
        },

        startOf: function (units) {
            units = normalizeUnits(units);
            // the following switch intentionally omits break keywords
            // to utilize falling through the cases.
            switch (units) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'month':
                this.date(1);
                /* falls through */
            case 'week':
            case 'isoWeek':
            case 'day':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
                /* falls through */
            }

            // weeks are a special case
            if (units === 'week') {
                this.weekday(0);
            } else if (units === 'isoWeek') {
                this.isoWeekday(1);
            }

            return this;
        },

        endOf: function (units) {
            units = normalizeUnits(units);
            return this.startOf(units).add((units === 'isoWeek' ? 'week' : units), 1).subtract('ms', 1);
        },

        isAfter: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) > +moment(input).startOf(units);
        },

        isBefore: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) < +moment(input).startOf(units);
        },

        isSame: function (input, units) {
            units = units || 'ms';
            return +this.clone().startOf(units) === +makeAs(input, this).startOf(units);
        },

        min: function (other) {
            other = moment.apply(null, arguments);
            return other < this ? this : other;
        },

        max: function (other) {
            other = moment.apply(null, arguments);
            return other > this ? this : other;
        },

        zone : function (input) {
            var offset = this._offset || 0;
            if (input != null) {
                if (typeof input === "string") {
                    input = timezoneMinutesFromString(input);
                }
                if (Math.abs(input) < 16) {
                    input = input * 60;
                }
                this._offset = input;
                this._isUTC = true;
                if (offset !== input) {
                    addOrSubtractDurationFromMoment(this, moment.duration(offset - input, 'm'), 1, true);
                }
            } else {
                return this._isUTC ? offset : this._d.getTimezoneOffset();
            }
            return this;
        },

        zoneAbbr : function () {
            return this._isUTC ? "UTC" : "";
        },

        zoneName : function () {
            return this._isUTC ? "Coordinated Universal Time" : "";
        },

        parseZone : function () {
            if (this._tzm) {
                this.zone(this._tzm);
            } else if (typeof this._i === 'string') {
                this.zone(this._i);
            }
            return this;
        },

        hasAlignedHourOffset : function (input) {
            if (!input) {
                input = 0;
            }
            else {
                input = moment(input).zone();
            }

            return (this.zone() - input) % 60 === 0;
        },

        daysInMonth : function () {
            return daysInMonth(this.year(), this.month());
        },

        dayOfYear : function (input) {
            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
            return input == null ? dayOfYear : this.add("d", (input - dayOfYear));
        },

        quarter : function () {
            return Math.ceil((this.month() + 1.0) / 3.0);
        },

        weekYear : function (input) {
            var year = weekOfYear(this, this.lang()._week.dow, this.lang()._week.doy).year;
            return input == null ? year : this.add("y", (input - year));
        },

        isoWeekYear : function (input) {
            var year = weekOfYear(this, 1, 4).year;
            return input == null ? year : this.add("y", (input - year));
        },

        week : function (input) {
            var week = this.lang().week(this);
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        isoWeek : function (input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        weekday : function (input) {
            var weekday = (this.day() + 7 - this.lang()._week.dow) % 7;
            return input == null ? weekday : this.add("d", input - weekday);
        },

        isoWeekday : function (input) {
            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.
            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units]();
        },

        set : function (units, value) {
            units = normalizeUnits(units);
            if (typeof this[units] === 'function') {
                this[units](value);
            }
            return this;
        },

        // If passed a language key, it will set the language for this
        // instance.  Otherwise, it will return the language configuration
        // variables for this instance.
        lang : function (key) {
            if (key === undefined) {
                return this._lang;
            } else {
                this._lang = getLangDefinition(key);
                return this;
            }
        }
    });

    // helper for adding shortcuts
    function makeGetterAndSetter(name, key) {
        moment.fn[name] = moment.fn[name + 's'] = function (input) {
            var utc = this._isUTC ? 'UTC' : '';
            if (input != null) {
                this._d['set' + utc + key](input);
                moment.updateOffset(this);
                return this;
            } else {
                return this._d['get' + utc + key]();
            }
        };
    }

    // loop through and add shortcuts (Month, Date, Hours, Minutes, Seconds, Milliseconds)
    for (i = 0; i < proxyGettersAndSetters.length; i ++) {
        makeGetterAndSetter(proxyGettersAndSetters[i].toLowerCase().replace(/s$/, ''), proxyGettersAndSetters[i]);
    }

    // add shortcut for year (uses different syntax than the getter/setter 'year' == 'FullYear')
    makeGetterAndSetter('year', 'FullYear');

    // add plural methods
    moment.fn.days = moment.fn.day;
    moment.fn.months = moment.fn.month;
    moment.fn.weeks = moment.fn.week;
    moment.fn.isoWeeks = moment.fn.isoWeek;

    // add aliased format methods
    moment.fn.toJSON = moment.fn.toISOString;

    /************************************
        Duration Prototype
    ************************************/


    extend(moment.duration.fn = Duration.prototype, {

        _bubble : function () {
            var milliseconds = this._milliseconds,
                days = this._days,
                months = this._months,
                data = this._data,
                seconds, minutes, hours, years;

            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1000;

            seconds = absRound(milliseconds / 1000);
            data.seconds = seconds % 60;

            minutes = absRound(seconds / 60);
            data.minutes = minutes % 60;

            hours = absRound(minutes / 60);
            data.hours = hours % 24;

            days += absRound(hours / 24);
            data.days = days % 30;

            months += absRound(days / 30);
            data.months = months % 12;

            years = absRound(months / 12);
            data.years = years;
        },

        weeks : function () {
            return absRound(this.days() / 7);
        },

        valueOf : function () {
            return this._milliseconds +
              this._days * 864e5 +
              (this._months % 12) * 2592e6 +
              toInt(this._months / 12) * 31536e6;
        },

        humanize : function (withSuffix) {
            var difference = +this,
                output = relativeTime(difference, !withSuffix, this.lang());

            if (withSuffix) {
                output = this.lang().pastFuture(difference, output);
            }

            return this.lang().postformat(output);
        },

        add : function (input, val) {
            // supports only 2.0-style add(1, 's') or add(moment)
            var dur = moment.duration(input, val);

            this._milliseconds += dur._milliseconds;
            this._days += dur._days;
            this._months += dur._months;

            this._bubble();

            return this;
        },

        subtract : function (input, val) {
            var dur = moment.duration(input, val);

            this._milliseconds -= dur._milliseconds;
            this._days -= dur._days;
            this._months -= dur._months;

            this._bubble();

            return this;
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units.toLowerCase() + 's']();
        },

        as : function (units) {
            units = normalizeUnits(units);
            return this['as' + units.charAt(0).toUpperCase() + units.slice(1) + 's']();
        },

        lang : moment.fn.lang,

        toIsoString : function () {
            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
            var years = Math.abs(this.years()),
                months = Math.abs(this.months()),
                days = Math.abs(this.days()),
                hours = Math.abs(this.hours()),
                minutes = Math.abs(this.minutes()),
                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);

            if (!this.asSeconds()) {
                // this is the same as C#'s (Noda) and python (isodate)...
                // but not other JS (goog.date)
                return 'P0D';
            }

            return (this.asSeconds() < 0 ? '-' : '') +
                'P' +
                (years ? years + 'Y' : '') +
                (months ? months + 'M' : '') +
                (days ? days + 'D' : '') +
                ((hours || minutes || seconds) ? 'T' : '') +
                (hours ? hours + 'H' : '') +
                (minutes ? minutes + 'M' : '') +
                (seconds ? seconds + 'S' : '');
        }
    });

    function makeDurationGetter(name) {
        moment.duration.fn[name] = function () {
            return this._data[name];
        };
    }

    function makeDurationAsGetter(name, factor) {
        moment.duration.fn['as' + name] = function () {
            return +this / factor;
        };
    }

    for (i in unitMillisecondFactors) {
        if (unitMillisecondFactors.hasOwnProperty(i)) {
            makeDurationAsGetter(i, unitMillisecondFactors[i]);
            makeDurationGetter(i.toLowerCase());
        }
    }

    makeDurationAsGetter('Weeks', 6048e5);
    moment.duration.fn.asMonths = function () {
        return (+this - this.years() * 31536e6) / 2592e6 + this.years() * 12;
    };


    /************************************
        Default Lang
    ************************************/


    // Set default language, other languages will inherit from English.
    moment.lang('en', {
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    /* EMBED_LANGUAGES */

    /************************************
        Exposing Moment
    ************************************/

    function makeGlobal(deprecate) {
        var warned = false, local_moment = moment;
        /*global ender:false */
        if (typeof ender !== 'undefined') {
            return;
        }
        // here, `this` means `window` in the browser, or `global` on the server
        // add `moment` as a global object via a string identifier,
        // for Closure Compiler "advanced" mode
        if (deprecate) {
            global.moment = function () {
                if (!warned && console && console.warn) {
                    warned = true;
                    console.warn(
                            "Accessing Moment through the global scope is " +
                            "deprecated, and will be removed in an upcoming " +
                            "release.");
                }
                return local_moment.apply(null, arguments);
            };
            extend(global.moment, local_moment);
        } else {
            global['moment'] = moment;
        }
    }

    // CommonJS module is defined
    if (hasModule) {
        module.exports = moment;
        makeGlobal(true);
    } else if (typeof define === "function" && define.amd) {
        define("moment", function (require, exports, module) {
            if (module.config && module.config() && module.config().noGlobal !== true) {
                // If user provided noGlobal, he is aware of global
                makeGlobal(module.config().noGlobal === undefined);
            }

            return moment;
        });
    } else {
        makeGlobal();
    }
}).call(this);

},{}],157:[function(require,module,exports){
/*
Copyright 2012 Igor Vaynberg

Version: 3.5.2 Timestamp: Sat Nov  1 14:43:36 EDT 2014

This software is licensed under the Apache License, Version 2.0 (the "Apache License") or the GNU
General Public License version 2 (the "GPL License"). You may choose either license to govern your
use of this software only upon the condition that you accept all of the terms of either the Apache
License or the GPL License.

You may obtain a copy of the Apache License and the GPL License at:

    http://www.apache.org/licenses/LICENSE-2.0
    http://www.gnu.org/licenses/gpl-2.0.html

Unless required by applicable law or agreed to in writing, software distributed under the
Apache License or the GPL License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the Apache License and the GPL License for
the specific language governing permissions and limitations under the Apache License and the GPL License.
*/
(function ($) {
    if(typeof $.fn.each2 == "undefined") {
        $.extend($.fn, {
            /*
            * 4-10 times faster .each replacement
            * use it carefully, as it overrides jQuery context of element on each iteration
            */
            each2 : function (c) {
                var j = $([0]), i = -1, l = this.length;
                while (
                    ++i < l
                    && (j.context = j[0] = this[i])
                    && c.call(j[0], i, j) !== false //"this"=DOM, i=index, j=jQuery object
                );
                return this;
            }
        });
    }
})(jQuery);

(function ($, undefined) {
    "use strict";
    /*global document, window, jQuery, console */

    if (window.Select2 !== undefined) {
        return;
    }

    var AbstractSelect2, SingleSelect2, MultiSelect2, nextUid, sizer,
        lastMousePosition={x:0,y:0}, $document, scrollBarDimensions,

    KEY = {
        TAB: 9,
        ENTER: 13,
        ESC: 27,
        SPACE: 32,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,
        SHIFT: 16,
        CTRL: 17,
        ALT: 18,
        PAGE_UP: 33,
        PAGE_DOWN: 34,
        HOME: 36,
        END: 35,
        BACKSPACE: 8,
        DELETE: 46,
        isArrow: function (k) {
            k = k.which ? k.which : k;
            switch (k) {
            case KEY.LEFT:
            case KEY.RIGHT:
            case KEY.UP:
            case KEY.DOWN:
                return true;
            }
            return false;
        },
        isControl: function (e) {
            var k = e.which;
            switch (k) {
            case KEY.SHIFT:
            case KEY.CTRL:
            case KEY.ALT:
                return true;
            }

            if (e.metaKey) return true;

            return false;
        },
        isFunctionKey: function (k) {
            k = k.which ? k.which : k;
            return k >= 112 && k <= 123;
        }
    },
    MEASURE_SCROLLBAR_TEMPLATE = "<div class='select2-measure-scrollbar'></div>",

    DIACRITICS = {"\u24B6":"A","\uFF21":"A","\u00C0":"A","\u00C1":"A","\u00C2":"A","\u1EA6":"A","\u1EA4":"A","\u1EAA":"A","\u1EA8":"A","\u00C3":"A","\u0100":"A","\u0102":"A","\u1EB0":"A","\u1EAE":"A","\u1EB4":"A","\u1EB2":"A","\u0226":"A","\u01E0":"A","\u00C4":"A","\u01DE":"A","\u1EA2":"A","\u00C5":"A","\u01FA":"A","\u01CD":"A","\u0200":"A","\u0202":"A","\u1EA0":"A","\u1EAC":"A","\u1EB6":"A","\u1E00":"A","\u0104":"A","\u023A":"A","\u2C6F":"A","\uA732":"AA","\u00C6":"AE","\u01FC":"AE","\u01E2":"AE","\uA734":"AO","\uA736":"AU","\uA738":"AV","\uA73A":"AV","\uA73C":"AY","\u24B7":"B","\uFF22":"B","\u1E02":"B","\u1E04":"B","\u1E06":"B","\u0243":"B","\u0182":"B","\u0181":"B","\u24B8":"C","\uFF23":"C","\u0106":"C","\u0108":"C","\u010A":"C","\u010C":"C","\u00C7":"C","\u1E08":"C","\u0187":"C","\u023B":"C","\uA73E":"C","\u24B9":"D","\uFF24":"D","\u1E0A":"D","\u010E":"D","\u1E0C":"D","\u1E10":"D","\u1E12":"D","\u1E0E":"D","\u0110":"D","\u018B":"D","\u018A":"D","\u0189":"D","\uA779":"D","\u01F1":"DZ","\u01C4":"DZ","\u01F2":"Dz","\u01C5":"Dz","\u24BA":"E","\uFF25":"E","\u00C8":"E","\u00C9":"E","\u00CA":"E","\u1EC0":"E","\u1EBE":"E","\u1EC4":"E","\u1EC2":"E","\u1EBC":"E","\u0112":"E","\u1E14":"E","\u1E16":"E","\u0114":"E","\u0116":"E","\u00CB":"E","\u1EBA":"E","\u011A":"E","\u0204":"E","\u0206":"E","\u1EB8":"E","\u1EC6":"E","\u0228":"E","\u1E1C":"E","\u0118":"E","\u1E18":"E","\u1E1A":"E","\u0190":"E","\u018E":"E","\u24BB":"F","\uFF26":"F","\u1E1E":"F","\u0191":"F","\uA77B":"F","\u24BC":"G","\uFF27":"G","\u01F4":"G","\u011C":"G","\u1E20":"G","\u011E":"G","\u0120":"G","\u01E6":"G","\u0122":"G","\u01E4":"G","\u0193":"G","\uA7A0":"G","\uA77D":"G","\uA77E":"G","\u24BD":"H","\uFF28":"H","\u0124":"H","\u1E22":"H","\u1E26":"H","\u021E":"H","\u1E24":"H","\u1E28":"H","\u1E2A":"H","\u0126":"H","\u2C67":"H","\u2C75":"H","\uA78D":"H","\u24BE":"I","\uFF29":"I","\u00CC":"I","\u00CD":"I","\u00CE":"I","\u0128":"I","\u012A":"I","\u012C":"I","\u0130":"I","\u00CF":"I","\u1E2E":"I","\u1EC8":"I","\u01CF":"I","\u0208":"I","\u020A":"I","\u1ECA":"I","\u012E":"I","\u1E2C":"I","\u0197":"I","\u24BF":"J","\uFF2A":"J","\u0134":"J","\u0248":"J","\u24C0":"K","\uFF2B":"K","\u1E30":"K","\u01E8":"K","\u1E32":"K","\u0136":"K","\u1E34":"K","\u0198":"K","\u2C69":"K","\uA740":"K","\uA742":"K","\uA744":"K","\uA7A2":"K","\u24C1":"L","\uFF2C":"L","\u013F":"L","\u0139":"L","\u013D":"L","\u1E36":"L","\u1E38":"L","\u013B":"L","\u1E3C":"L","\u1E3A":"L","\u0141":"L","\u023D":"L","\u2C62":"L","\u2C60":"L","\uA748":"L","\uA746":"L","\uA780":"L","\u01C7":"LJ","\u01C8":"Lj","\u24C2":"M","\uFF2D":"M","\u1E3E":"M","\u1E40":"M","\u1E42":"M","\u2C6E":"M","\u019C":"M","\u24C3":"N","\uFF2E":"N","\u01F8":"N","\u0143":"N","\u00D1":"N","\u1E44":"N","\u0147":"N","\u1E46":"N","\u0145":"N","\u1E4A":"N","\u1E48":"N","\u0220":"N","\u019D":"N","\uA790":"N","\uA7A4":"N","\u01CA":"NJ","\u01CB":"Nj","\u24C4":"O","\uFF2F":"O","\u00D2":"O","\u00D3":"O","\u00D4":"O","\u1ED2":"O","\u1ED0":"O","\u1ED6":"O","\u1ED4":"O","\u00D5":"O","\u1E4C":"O","\u022C":"O","\u1E4E":"O","\u014C":"O","\u1E50":"O","\u1E52":"O","\u014E":"O","\u022E":"O","\u0230":"O","\u00D6":"O","\u022A":"O","\u1ECE":"O","\u0150":"O","\u01D1":"O","\u020C":"O","\u020E":"O","\u01A0":"O","\u1EDC":"O","\u1EDA":"O","\u1EE0":"O","\u1EDE":"O","\u1EE2":"O","\u1ECC":"O","\u1ED8":"O","\u01EA":"O","\u01EC":"O","\u00D8":"O","\u01FE":"O","\u0186":"O","\u019F":"O","\uA74A":"O","\uA74C":"O","\u01A2":"OI","\uA74E":"OO","\u0222":"OU","\u24C5":"P","\uFF30":"P","\u1E54":"P","\u1E56":"P","\u01A4":"P","\u2C63":"P","\uA750":"P","\uA752":"P","\uA754":"P","\u24C6":"Q","\uFF31":"Q","\uA756":"Q","\uA758":"Q","\u024A":"Q","\u24C7":"R","\uFF32":"R","\u0154":"R","\u1E58":"R","\u0158":"R","\u0210":"R","\u0212":"R","\u1E5A":"R","\u1E5C":"R","\u0156":"R","\u1E5E":"R","\u024C":"R","\u2C64":"R","\uA75A":"R","\uA7A6":"R","\uA782":"R","\u24C8":"S","\uFF33":"S","\u1E9E":"S","\u015A":"S","\u1E64":"S","\u015C":"S","\u1E60":"S","\u0160":"S","\u1E66":"S","\u1E62":"S","\u1E68":"S","\u0218":"S","\u015E":"S","\u2C7E":"S","\uA7A8":"S","\uA784":"S","\u24C9":"T","\uFF34":"T","\u1E6A":"T","\u0164":"T","\u1E6C":"T","\u021A":"T","\u0162":"T","\u1E70":"T","\u1E6E":"T","\u0166":"T","\u01AC":"T","\u01AE":"T","\u023E":"T","\uA786":"T","\uA728":"TZ","\u24CA":"U","\uFF35":"U","\u00D9":"U","\u00DA":"U","\u00DB":"U","\u0168":"U","\u1E78":"U","\u016A":"U","\u1E7A":"U","\u016C":"U","\u00DC":"U","\u01DB":"U","\u01D7":"U","\u01D5":"U","\u01D9":"U","\u1EE6":"U","\u016E":"U","\u0170":"U","\u01D3":"U","\u0214":"U","\u0216":"U","\u01AF":"U","\u1EEA":"U","\u1EE8":"U","\u1EEE":"U","\u1EEC":"U","\u1EF0":"U","\u1EE4":"U","\u1E72":"U","\u0172":"U","\u1E76":"U","\u1E74":"U","\u0244":"U","\u24CB":"V","\uFF36":"V","\u1E7C":"V","\u1E7E":"V","\u01B2":"V","\uA75E":"V","\u0245":"V","\uA760":"VY","\u24CC":"W","\uFF37":"W","\u1E80":"W","\u1E82":"W","\u0174":"W","\u1E86":"W","\u1E84":"W","\u1E88":"W","\u2C72":"W","\u24CD":"X","\uFF38":"X","\u1E8A":"X","\u1E8C":"X","\u24CE":"Y","\uFF39":"Y","\u1EF2":"Y","\u00DD":"Y","\u0176":"Y","\u1EF8":"Y","\u0232":"Y","\u1E8E":"Y","\u0178":"Y","\u1EF6":"Y","\u1EF4":"Y","\u01B3":"Y","\u024E":"Y","\u1EFE":"Y","\u24CF":"Z","\uFF3A":"Z","\u0179":"Z","\u1E90":"Z","\u017B":"Z","\u017D":"Z","\u1E92":"Z","\u1E94":"Z","\u01B5":"Z","\u0224":"Z","\u2C7F":"Z","\u2C6B":"Z","\uA762":"Z","\u24D0":"a","\uFF41":"a","\u1E9A":"a","\u00E0":"a","\u00E1":"a","\u00E2":"a","\u1EA7":"a","\u1EA5":"a","\u1EAB":"a","\u1EA9":"a","\u00E3":"a","\u0101":"a","\u0103":"a","\u1EB1":"a","\u1EAF":"a","\u1EB5":"a","\u1EB3":"a","\u0227":"a","\u01E1":"a","\u00E4":"a","\u01DF":"a","\u1EA3":"a","\u00E5":"a","\u01FB":"a","\u01CE":"a","\u0201":"a","\u0203":"a","\u1EA1":"a","\u1EAD":"a","\u1EB7":"a","\u1E01":"a","\u0105":"a","\u2C65":"a","\u0250":"a","\uA733":"aa","\u00E6":"ae","\u01FD":"ae","\u01E3":"ae","\uA735":"ao","\uA737":"au","\uA739":"av","\uA73B":"av","\uA73D":"ay","\u24D1":"b","\uFF42":"b","\u1E03":"b","\u1E05":"b","\u1E07":"b","\u0180":"b","\u0183":"b","\u0253":"b","\u24D2":"c","\uFF43":"c","\u0107":"c","\u0109":"c","\u010B":"c","\u010D":"c","\u00E7":"c","\u1E09":"c","\u0188":"c","\u023C":"c","\uA73F":"c","\u2184":"c","\u24D3":"d","\uFF44":"d","\u1E0B":"d","\u010F":"d","\u1E0D":"d","\u1E11":"d","\u1E13":"d","\u1E0F":"d","\u0111":"d","\u018C":"d","\u0256":"d","\u0257":"d","\uA77A":"d","\u01F3":"dz","\u01C6":"dz","\u24D4":"e","\uFF45":"e","\u00E8":"e","\u00E9":"e","\u00EA":"e","\u1EC1":"e","\u1EBF":"e","\u1EC5":"e","\u1EC3":"e","\u1EBD":"e","\u0113":"e","\u1E15":"e","\u1E17":"e","\u0115":"e","\u0117":"e","\u00EB":"e","\u1EBB":"e","\u011B":"e","\u0205":"e","\u0207":"e","\u1EB9":"e","\u1EC7":"e","\u0229":"e","\u1E1D":"e","\u0119":"e","\u1E19":"e","\u1E1B":"e","\u0247":"e","\u025B":"e","\u01DD":"e","\u24D5":"f","\uFF46":"f","\u1E1F":"f","\u0192":"f","\uA77C":"f","\u24D6":"g","\uFF47":"g","\u01F5":"g","\u011D":"g","\u1E21":"g","\u011F":"g","\u0121":"g","\u01E7":"g","\u0123":"g","\u01E5":"g","\u0260":"g","\uA7A1":"g","\u1D79":"g","\uA77F":"g","\u24D7":"h","\uFF48":"h","\u0125":"h","\u1E23":"h","\u1E27":"h","\u021F":"h","\u1E25":"h","\u1E29":"h","\u1E2B":"h","\u1E96":"h","\u0127":"h","\u2C68":"h","\u2C76":"h","\u0265":"h","\u0195":"hv","\u24D8":"i","\uFF49":"i","\u00EC":"i","\u00ED":"i","\u00EE":"i","\u0129":"i","\u012B":"i","\u012D":"i","\u00EF":"i","\u1E2F":"i","\u1EC9":"i","\u01D0":"i","\u0209":"i","\u020B":"i","\u1ECB":"i","\u012F":"i","\u1E2D":"i","\u0268":"i","\u0131":"i","\u24D9":"j","\uFF4A":"j","\u0135":"j","\u01F0":"j","\u0249":"j","\u24DA":"k","\uFF4B":"k","\u1E31":"k","\u01E9":"k","\u1E33":"k","\u0137":"k","\u1E35":"k","\u0199":"k","\u2C6A":"k","\uA741":"k","\uA743":"k","\uA745":"k","\uA7A3":"k","\u24DB":"l","\uFF4C":"l","\u0140":"l","\u013A":"l","\u013E":"l","\u1E37":"l","\u1E39":"l","\u013C":"l","\u1E3D":"l","\u1E3B":"l","\u017F":"l","\u0142":"l","\u019A":"l","\u026B":"l","\u2C61":"l","\uA749":"l","\uA781":"l","\uA747":"l","\u01C9":"lj","\u24DC":"m","\uFF4D":"m","\u1E3F":"m","\u1E41":"m","\u1E43":"m","\u0271":"m","\u026F":"m","\u24DD":"n","\uFF4E":"n","\u01F9":"n","\u0144":"n","\u00F1":"n","\u1E45":"n","\u0148":"n","\u1E47":"n","\u0146":"n","\u1E4B":"n","\u1E49":"n","\u019E":"n","\u0272":"n","\u0149":"n","\uA791":"n","\uA7A5":"n","\u01CC":"nj","\u24DE":"o","\uFF4F":"o","\u00F2":"o","\u00F3":"o","\u00F4":"o","\u1ED3":"o","\u1ED1":"o","\u1ED7":"o","\u1ED5":"o","\u00F5":"o","\u1E4D":"o","\u022D":"o","\u1E4F":"o","\u014D":"o","\u1E51":"o","\u1E53":"o","\u014F":"o","\u022F":"o","\u0231":"o","\u00F6":"o","\u022B":"o","\u1ECF":"o","\u0151":"o","\u01D2":"o","\u020D":"o","\u020F":"o","\u01A1":"o","\u1EDD":"o","\u1EDB":"o","\u1EE1":"o","\u1EDF":"o","\u1EE3":"o","\u1ECD":"o","\u1ED9":"o","\u01EB":"o","\u01ED":"o","\u00F8":"o","\u01FF":"o","\u0254":"o","\uA74B":"o","\uA74D":"o","\u0275":"o","\u01A3":"oi","\u0223":"ou","\uA74F":"oo","\u24DF":"p","\uFF50":"p","\u1E55":"p","\u1E57":"p","\u01A5":"p","\u1D7D":"p","\uA751":"p","\uA753":"p","\uA755":"p","\u24E0":"q","\uFF51":"q","\u024B":"q","\uA757":"q","\uA759":"q","\u24E1":"r","\uFF52":"r","\u0155":"r","\u1E59":"r","\u0159":"r","\u0211":"r","\u0213":"r","\u1E5B":"r","\u1E5D":"r","\u0157":"r","\u1E5F":"r","\u024D":"r","\u027D":"r","\uA75B":"r","\uA7A7":"r","\uA783":"r","\u24E2":"s","\uFF53":"s","\u00DF":"s","\u015B":"s","\u1E65":"s","\u015D":"s","\u1E61":"s","\u0161":"s","\u1E67":"s","\u1E63":"s","\u1E69":"s","\u0219":"s","\u015F":"s","\u023F":"s","\uA7A9":"s","\uA785":"s","\u1E9B":"s","\u24E3":"t","\uFF54":"t","\u1E6B":"t","\u1E97":"t","\u0165":"t","\u1E6D":"t","\u021B":"t","\u0163":"t","\u1E71":"t","\u1E6F":"t","\u0167":"t","\u01AD":"t","\u0288":"t","\u2C66":"t","\uA787":"t","\uA729":"tz","\u24E4":"u","\uFF55":"u","\u00F9":"u","\u00FA":"u","\u00FB":"u","\u0169":"u","\u1E79":"u","\u016B":"u","\u1E7B":"u","\u016D":"u","\u00FC":"u","\u01DC":"u","\u01D8":"u","\u01D6":"u","\u01DA":"u","\u1EE7":"u","\u016F":"u","\u0171":"u","\u01D4":"u","\u0215":"u","\u0217":"u","\u01B0":"u","\u1EEB":"u","\u1EE9":"u","\u1EEF":"u","\u1EED":"u","\u1EF1":"u","\u1EE5":"u","\u1E73":"u","\u0173":"u","\u1E77":"u","\u1E75":"u","\u0289":"u","\u24E5":"v","\uFF56":"v","\u1E7D":"v","\u1E7F":"v","\u028B":"v","\uA75F":"v","\u028C":"v","\uA761":"vy","\u24E6":"w","\uFF57":"w","\u1E81":"w","\u1E83":"w","\u0175":"w","\u1E87":"w","\u1E85":"w","\u1E98":"w","\u1E89":"w","\u2C73":"w","\u24E7":"x","\uFF58":"x","\u1E8B":"x","\u1E8D":"x","\u24E8":"y","\uFF59":"y","\u1EF3":"y","\u00FD":"y","\u0177":"y","\u1EF9":"y","\u0233":"y","\u1E8F":"y","\u00FF":"y","\u1EF7":"y","\u1E99":"y","\u1EF5":"y","\u01B4":"y","\u024F":"y","\u1EFF":"y","\u24E9":"z","\uFF5A":"z","\u017A":"z","\u1E91":"z","\u017C":"z","\u017E":"z","\u1E93":"z","\u1E95":"z","\u01B6":"z","\u0225":"z","\u0240":"z","\u2C6C":"z","\uA763":"z","\u0386":"\u0391","\u0388":"\u0395","\u0389":"\u0397","\u038A":"\u0399","\u03AA":"\u0399","\u038C":"\u039F","\u038E":"\u03A5","\u03AB":"\u03A5","\u038F":"\u03A9","\u03AC":"\u03B1","\u03AD":"\u03B5","\u03AE":"\u03B7","\u03AF":"\u03B9","\u03CA":"\u03B9","\u0390":"\u03B9","\u03CC":"\u03BF","\u03CD":"\u03C5","\u03CB":"\u03C5","\u03B0":"\u03C5","\u03C9":"\u03C9","\u03C2":"\u03C3"};

    $document = $(document);

    nextUid=(function() { var counter=1; return function() { return counter++; }; }());


    function reinsertElement(element) {
        var placeholder = $(document.createTextNode(''));

        element.before(placeholder);
        placeholder.before(element);
        placeholder.remove();
    }

    function stripDiacritics(str) {
        // Used 'uni range + named function' from http://jsperf.com/diacritics/18
        function match(a) {
            return DIACRITICS[a] || a;
        }

        return str.replace(/[^\u0000-\u007E]/g, match);
    }

    function indexOf(value, array) {
        var i = 0, l = array.length;
        for (; i < l; i = i + 1) {
            if (equal(value, array[i])) return i;
        }
        return -1;
    }

    function measureScrollbar () {
        var $template = $( MEASURE_SCROLLBAR_TEMPLATE );
        $template.appendTo(document.body);

        var dim = {
            width: $template.width() - $template[0].clientWidth,
            height: $template.height() - $template[0].clientHeight
        };
        $template.remove();

        return dim;
    }

    /**
     * Compares equality of a and b
     * @param a
     * @param b
     */
    function equal(a, b) {
        if (a === b) return true;
        if (a === undefined || b === undefined) return false;
        if (a === null || b === null) return false;
        // Check whether 'a' or 'b' is a string (primitive or object).
        // The concatenation of an empty string (+'') converts its argument to a string's primitive.
        if (a.constructor === String) return a+'' === b+''; // a+'' - in case 'a' is a String object
        if (b.constructor === String) return b+'' === a+''; // b+'' - in case 'b' is a String object
        return false;
    }

    /**
     * Splits the string into an array of values, transforming each value. An empty array is returned for nulls or empty
     * strings
     * @param string
     * @param separator
     */
    function splitVal(string, separator, transform) {
        var val, i, l;
        if (string === null || string.length < 1) return [];
        val = string.split(separator);
        for (i = 0, l = val.length; i < l; i = i + 1) val[i] = transform(val[i]);
        return val;
    }

    function getSideBorderPadding(element) {
        return element.outerWidth(false) - element.width();
    }

    function installKeyUpChangeEvent(element) {
        var key="keyup-change-value";
        element.on("keydown", function () {
            if ($.data(element, key) === undefined) {
                $.data(element, key, element.val());
            }
        });
        element.on("keyup", function () {
            var val= $.data(element, key);
            if (val !== undefined && element.val() !== val) {
                $.removeData(element, key);
                element.trigger("keyup-change");
            }
        });
    }


    /**
     * filters mouse events so an event is fired only if the mouse moved.
     *
     * filters out mouse events that occur when mouse is stationary but
     * the elements under the pointer are scrolled.
     */
    function installFilteredMouseMove(element) {
        element.on("mousemove", function (e) {
            var lastpos = lastMousePosition;
            if (lastpos === undefined || lastpos.x !== e.pageX || lastpos.y !== e.pageY) {
                $(e.target).trigger("mousemove-filtered", e);
            }
        });
    }

    /**
     * Debounces a function. Returns a function that calls the original fn function only if no invocations have been made
     * within the last quietMillis milliseconds.
     *
     * @param quietMillis number of milliseconds to wait before invoking fn
     * @param fn function to be debounced
     * @param ctx object to be used as this reference within fn
     * @return debounced version of fn
     */
    function debounce(quietMillis, fn, ctx) {
        ctx = ctx || undefined;
        var timeout;
        return function () {
            var args = arguments;
            window.clearTimeout(timeout);
            timeout = window.setTimeout(function() {
                fn.apply(ctx, args);
            }, quietMillis);
        };
    }

    function installDebouncedScroll(threshold, element) {
        var notify = debounce(threshold, function (e) { element.trigger("scroll-debounced", e);});
        element.on("scroll", function (e) {
            if (indexOf(e.target, element.get()) >= 0) notify(e);
        });
    }

    function focus($el) {
        if ($el[0] === document.activeElement) return;

        /* set the focus in a 0 timeout - that way the focus is set after the processing
            of the current event has finished - which seems like the only reliable way
            to set focus */
        window.setTimeout(function() {
            var el=$el[0], pos=$el.val().length, range;

            $el.focus();

            /* make sure el received focus so we do not error out when trying to manipulate the caret.
                sometimes modals or others listeners may steal it after its set */
            var isVisible = (el.offsetWidth > 0 || el.offsetHeight > 0);
            if (isVisible && el === document.activeElement) {

                /* after the focus is set move the caret to the end, necessary when we val()
                    just before setting focus */
                if(el.setSelectionRange)
                {
                    el.setSelectionRange(pos, pos);
                }
                else if (el.createTextRange) {
                    range = el.createTextRange();
                    range.collapse(false);
                    range.select();
                }
            }
        }, 0);
    }

    function getCursorInfo(el) {
        el = $(el)[0];
        var offset = 0;
        var length = 0;
        if ('selectionStart' in el) {
            offset = el.selectionStart;
            length = el.selectionEnd - offset;
        } else if ('selection' in document) {
            el.focus();
            var sel = document.selection.createRange();
            length = document.selection.createRange().text.length;
            sel.moveStart('character', -el.value.length);
            offset = sel.text.length - length;
        }
        return { offset: offset, length: length };
    }

    function killEvent(event) {
        event.preventDefault();
        event.stopPropagation();
    }
    function killEventImmediately(event) {
        event.preventDefault();
        event.stopImmediatePropagation();
    }

    function measureTextWidth(e) {
        if (!sizer){
            var style = e[0].currentStyle || window.getComputedStyle(e[0], null);
            sizer = $(document.createElement("div")).css({
                position: "absolute",
                left: "-10000px",
                top: "-10000px",
                display: "none",
                fontSize: style.fontSize,
                fontFamily: style.fontFamily,
                fontStyle: style.fontStyle,
                fontWeight: style.fontWeight,
                letterSpacing: style.letterSpacing,
                textTransform: style.textTransform,
                whiteSpace: "nowrap"
            });
            sizer.attr("class","select2-sizer");
            $(document.body).append(sizer);
        }
        sizer.text(e.val());
        return sizer.width();
    }

    function syncCssClasses(dest, src, adapter) {
        var classes, replacements = [], adapted;

        classes = $.trim(dest.attr("class"));

        if (classes) {
            classes = '' + classes; // for IE which returns object

            $(classes.split(/\s+/)).each2(function() {
                if (this.indexOf("select2-") === 0) {
                    replacements.push(this);
                }
            });
        }

        classes = $.trim(src.attr("class"));

        if (classes) {
            classes = '' + classes; // for IE which returns object

            $(classes.split(/\s+/)).each2(function() {
                if (this.indexOf("select2-") !== 0) {
                    adapted = adapter(this);

                    if (adapted) {
                        replacements.push(adapted);
                    }
                }
            });
        }

        dest.attr("class", replacements.join(" "));
    }


    function markMatch(text, term, markup, escapeMarkup) {
        var match=stripDiacritics(text.toUpperCase()).indexOf(stripDiacritics(term.toUpperCase())),
            tl=term.length;

        if (match<0) {
            markup.push(escapeMarkup(text));
            return;
        }

        markup.push(escapeMarkup(text.substring(0, match)));
        markup.push("<span class='select2-match'>");
        markup.push(escapeMarkup(text.substring(match, match + tl)));
        markup.push("</span>");
        markup.push(escapeMarkup(text.substring(match + tl, text.length)));
    }

    function defaultEscapeMarkup(markup) {
        var replace_map = {
            '\\': '&#92;',
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;',
            "/": '&#47;'
        };

        return String(markup).replace(/[&<>"'\/\\]/g, function (match) {
            return replace_map[match];
        });
    }

    /**
     * Produces an ajax-based query function
     *
     * @param options object containing configuration parameters
     * @param options.params parameter map for the transport ajax call, can contain such options as cache, jsonpCallback, etc. see $.ajax
     * @param options.transport function that will be used to execute the ajax request. must be compatible with parameters supported by $.ajax
     * @param options.url url for the data
     * @param options.data a function(searchTerm, pageNumber, context) that should return an object containing query string parameters for the above url.
     * @param options.dataType request data type: ajax, jsonp, other datatypes supported by jQuery's $.ajax function or the transport function if specified
     * @param options.quietMillis (optional) milliseconds to wait before making the ajaxRequest, helps debounce the ajax function if invoked too often
     * @param options.results a function(remoteData, pageNumber, query) that converts data returned form the remote request to the format expected by Select2.
     *      The expected format is an object containing the following keys:
     *      results array of objects that will be used as choices
     *      more (optional) boolean indicating whether there are more results available
     *      Example: {results:[{id:1, text:'Red'},{id:2, text:'Blue'}], more:true}
     */
    function ajax(options) {
        var timeout, // current scheduled but not yet executed request
            handler = null,
            quietMillis = options.quietMillis || 100,
            ajaxUrl = options.url,
            self = this;

        return function (query) {
            window.clearTimeout(timeout);
            timeout = window.setTimeout(function () {
                var data = options.data, // ajax data function
                    url = ajaxUrl, // ajax url string or function
                    transport = options.transport || $.fn.select2.ajaxDefaults.transport,
                    // deprecated - to be removed in 4.0  - use params instead
                    deprecated = {
                        type: options.type || 'GET', // set type of request (GET or POST)
                        cache: options.cache || false,
                        jsonpCallback: options.jsonpCallback||undefined,
                        dataType: options.dataType||"json"
                    },
                    params = $.extend({}, $.fn.select2.ajaxDefaults.params, deprecated);

                data = data ? data.call(self, query.term, query.page, query.context) : null;
                url = (typeof url === 'function') ? url.call(self, query.term, query.page, query.context) : url;

                if (handler && typeof handler.abort === "function") { handler.abort(); }

                if (options.params) {
                    if ($.isFunction(options.params)) {
                        $.extend(params, options.params.call(self));
                    } else {
                        $.extend(params, options.params);
                    }
                }

                $.extend(params, {
                    url: url,
                    dataType: options.dataType,
                    data: data,
                    success: function (data) {
                        // TODO - replace query.page with query so users have access to term, page, etc.
                        // added query as third paramter to keep backwards compatibility
                        var results = options.results(data, query.page, query);
                        query.callback(results);
                    },
                    error: function(jqXHR, textStatus, errorThrown){
                        var results = {
                            hasError: true,
                            jqXHR: jqXHR,
                            textStatus: textStatus,
                            errorThrown: errorThrown
                        };

                        query.callback(results);
                    }
                });
                handler = transport.call(self, params);
            }, quietMillis);
        };
    }

    /**
     * Produces a query function that works with a local array
     *
     * @param options object containing configuration parameters. The options parameter can either be an array or an
     * object.
     *
     * If the array form is used it is assumed that it contains objects with 'id' and 'text' keys.
     *
     * If the object form is used it is assumed that it contains 'data' and 'text' keys. The 'data' key should contain
     * an array of objects that will be used as choices. These objects must contain at least an 'id' key. The 'text'
     * key can either be a String in which case it is expected that each element in the 'data' array has a key with the
     * value of 'text' which will be used to match choices. Alternatively, text can be a function(item) that can extract
     * the text.
     */
    function local(options) {
        var data = options, // data elements
            dataText,
            tmp,
            text = function (item) { return ""+item.text; }; // function used to retrieve the text portion of a data item that is matched against the search

         if ($.isArray(data)) {
            tmp = data;
            data = { results: tmp };
        }

         if ($.isFunction(data) === false) {
            tmp = data;
            data = function() { return tmp; };
        }

        var dataItem = data();
        if (dataItem.text) {
            text = dataItem.text;
            // if text is not a function we assume it to be a key name
            if (!$.isFunction(text)) {
                dataText = dataItem.text; // we need to store this in a separate variable because in the next step data gets reset and data.text is no longer available
                text = function (item) { return item[dataText]; };
            }
        }

        return function (query) {
            var t = query.term, filtered = { results: [] }, process;
            if (t === "") {
                query.callback(data());
                return;
            }

            process = function(datum, collection) {
                var group, attr;
                datum = datum[0];
                if (datum.children) {
                    group = {};
                    for (attr in datum) {
                        if (datum.hasOwnProperty(attr)) group[attr]=datum[attr];
                    }
                    group.children=[];
                    $(datum.children).each2(function(i, childDatum) { process(childDatum, group.children); });
                    if (group.children.length || query.matcher(t, text(group), datum)) {
                        collection.push(group);
                    }
                } else {
                    if (query.matcher(t, text(datum), datum)) {
                        collection.push(datum);
                    }
                }
            };

            $(data().results).each2(function(i, datum) { process(datum, filtered.results); });
            query.callback(filtered);
        };
    }

    // TODO javadoc
    function tags(data) {
        var isFunc = $.isFunction(data);
        return function (query) {
            var t = query.term, filtered = {results: []};
            var result = isFunc ? data(query) : data;
            if ($.isArray(result)) {
                $(result).each(function () {
                    var isObject = this.text !== undefined,
                        text = isObject ? this.text : this;
                    if (t === "" || query.matcher(t, text)) {
                        filtered.results.push(isObject ? this : {id: this, text: this});
                    }
                });
                query.callback(filtered);
            }
        };
    }

    /**
     * Checks if the formatter function should be used.
     *
     * Throws an error if it is not a function. Returns true if it should be used,
     * false if no formatting should be performed.
     *
     * @param formatter
     */
    function checkFormatter(formatter, formatterName) {
        if ($.isFunction(formatter)) return true;
        if (!formatter) return false;
        if (typeof(formatter) === 'string') return true;
        throw new Error(formatterName +" must be a string, function, or falsy value");
    }

  /**
   * Returns a given value
   * If given a function, returns its output
   *
   * @param val string|function
   * @param context value of "this" to be passed to function
   * @returns {*}
   */
    function evaluate(val, context) {
        if ($.isFunction(val)) {
            var args = Array.prototype.slice.call(arguments, 2);
            return val.apply(context, args);
        }
        return val;
    }

    function countResults(results) {
        var count = 0;
        $.each(results, function(i, item) {
            if (item.children) {
                count += countResults(item.children);
            } else {
                count++;
            }
        });
        return count;
    }

    /**
     * Default tokenizer. This function uses breaks the input on substring match of any string from the
     * opts.tokenSeparators array and uses opts.createSearchChoice to create the choice object. Both of those
     * two options have to be defined in order for the tokenizer to work.
     *
     * @param input text user has typed so far or pasted into the search field
     * @param selection currently selected choices
     * @param selectCallback function(choice) callback tho add the choice to selection
     * @param opts select2's opts
     * @return undefined/null to leave the current input unchanged, or a string to change the input to the returned value
     */
    function defaultTokenizer(input, selection, selectCallback, opts) {
        var original = input, // store the original so we can compare and know if we need to tell the search to update its text
            dupe = false, // check for whether a token we extracted represents a duplicate selected choice
            token, // token
            index, // position at which the separator was found
            i, l, // looping variables
            separator; // the matched separator

        if (!opts.createSearchChoice || !opts.tokenSeparators || opts.tokenSeparators.length < 1) return undefined;

        while (true) {
            index = -1;

            for (i = 0, l = opts.tokenSeparators.length; i < l; i++) {
                separator = opts.tokenSeparators[i];
                index = input.indexOf(separator);
                if (index >= 0) break;
            }

            if (index < 0) break; // did not find any token separator in the input string, bail

            token = input.substring(0, index);
            input = input.substring(index + separator.length);

            if (token.length > 0) {
                token = opts.createSearchChoice.call(this, token, selection);
                if (token !== undefined && token !== null && opts.id(token) !== undefined && opts.id(token) !== null) {
                    dupe = false;
                    for (i = 0, l = selection.length; i < l; i++) {
                        if (equal(opts.id(token), opts.id(selection[i]))) {
                            dupe = true; break;
                        }
                    }

                    if (!dupe) selectCallback(token);
                }
            }
        }

        if (original!==input) return input;
    }

    function cleanupJQueryElements() {
        var self = this;

        $.each(arguments, function (i, element) {
            self[element].remove();
            self[element] = null;
        });
    }

    /**
     * Creates a new class
     *
     * @param superClass
     * @param methods
     */
    function clazz(SuperClass, methods) {
        var constructor = function () {};
        constructor.prototype = new SuperClass;
        constructor.prototype.constructor = constructor;
        constructor.prototype.parent = SuperClass.prototype;
        constructor.prototype = $.extend(constructor.prototype, methods);
        return constructor;
    }

    AbstractSelect2 = clazz(Object, {

        // abstract
        bind: function (func) {
            var self = this;
            return function () {
                func.apply(self, arguments);
            };
        },

        // abstract
        init: function (opts) {
            var results, search, resultsSelector = ".select2-results";

            // prepare options
            this.opts = opts = this.prepareOpts(opts);

            this.id=opts.id;

            // destroy if called on an existing component
            if (opts.element.data("select2") !== undefined &&
                opts.element.data("select2") !== null) {
                opts.element.data("select2").destroy();
            }

            this.container = this.createContainer();

            this.liveRegion = $('.select2-hidden-accessible');
            if (this.liveRegion.length == 0) {
                this.liveRegion = $("<span>", {
                        role: "status",
                        "aria-live": "polite"
                    })
                    .addClass("select2-hidden-accessible")
                    .appendTo(document.body);
            }

            this.containerId="s2id_"+(opts.element.attr("id") || "autogen"+nextUid());
            this.containerEventName= this.containerId
                .replace(/([.])/g, '_')
                .replace(/([;&,\-\.\+\*\~':"\!\^#$%@\[\]\(\)=>\|])/g, '\\$1');
            this.container.attr("id", this.containerId);

            this.container.attr("title", opts.element.attr("title"));

            this.body = $(document.body);

            syncCssClasses(this.container, this.opts.element, this.opts.adaptContainerCssClass);

            this.container.attr("style", opts.element.attr("style"));
            this.container.css(evaluate(opts.containerCss, this.opts.element));
            this.container.addClass(evaluate(opts.containerCssClass, this.opts.element));

            this.elementTabIndex = this.opts.element.attr("tabindex");

            // swap container for the element
            this.opts.element
                .data("select2", this)
                .attr("tabindex", "-1")
                .before(this.container)
                .on("click.select2", killEvent); // do not leak click events

            this.container.data("select2", this);

            this.dropdown = this.container.find(".select2-drop");

            syncCssClasses(this.dropdown, this.opts.element, this.opts.adaptDropdownCssClass);

            this.dropdown.addClass(evaluate(opts.dropdownCssClass, this.opts.element));
            this.dropdown.data("select2", this);
            this.dropdown.on("click", killEvent);

            this.results = results = this.container.find(resultsSelector);
            this.search = search = this.container.find("input.select2-input");

            this.queryCount = 0;
            this.resultsPage = 0;
            this.context = null;

            // initialize the container
            this.initContainer();

            this.container.on("click", killEvent);

            installFilteredMouseMove(this.results);

            this.dropdown.on("mousemove-filtered", resultsSelector, this.bind(this.highlightUnderEvent));
            this.dropdown.on("touchstart touchmove touchend", resultsSelector, this.bind(function (event) {
                this._touchEvent = true;
                this.highlightUnderEvent(event);
            }));
            this.dropdown.on("touchmove", resultsSelector, this.bind(this.touchMoved));
            this.dropdown.on("touchstart touchend", resultsSelector, this.bind(this.clearTouchMoved));

            // Waiting for a click event on touch devices to select option and hide dropdown
            // otherwise click will be triggered on an underlying element
            this.dropdown.on('click', this.bind(function (event) {
                if (this._touchEvent) {
                    this._touchEvent = false;
                    this.selectHighlighted();
                }
            }));

            installDebouncedScroll(80, this.results);
            this.dropdown.on("scroll-debounced", resultsSelector, this.bind(this.loadMoreIfNeeded));

            // do not propagate change event from the search field out of the component
            $(this.container).on("change", ".select2-input", function(e) {e.stopPropagation();});
            $(this.dropdown).on("change", ".select2-input", function(e) {e.stopPropagation();});

            // if jquery.mousewheel plugin is installed we can prevent out-of-bounds scrolling of results via mousewheel
            if ($.fn.mousewheel) {
                results.mousewheel(function (e, delta, deltaX, deltaY) {
                    var top = results.scrollTop();
                    if (deltaY > 0 && top - deltaY <= 0) {
                        results.scrollTop(0);
                        killEvent(e);
                    } else if (deltaY < 0 && results.get(0).scrollHeight - results.scrollTop() + deltaY <= results.height()) {
                        results.scrollTop(results.get(0).scrollHeight - results.height());
                        killEvent(e);
                    }
                });
            }

            installKeyUpChangeEvent(search);
            search.on("keyup-change input paste", this.bind(this.updateResults));
            search.on("focus", function () { search.addClass("select2-focused"); });
            search.on("blur", function () { search.removeClass("select2-focused");});

            this.dropdown.on("mouseup", resultsSelector, this.bind(function (e) {
                if ($(e.target).closest(".select2-result-selectable").length > 0) {
                    this.highlightUnderEvent(e);
                    this.selectHighlighted(e);
                }
            }));

            // trap all mouse events from leaving the dropdown. sometimes there may be a modal that is listening
            // for mouse events outside of itself so it can close itself. since the dropdown is now outside the select2's
            // dom it will trigger the popup close, which is not what we want
            // focusin can cause focus wars between modals and select2 since the dropdown is outside the modal.
            this.dropdown.on("click mouseup mousedown touchstart touchend focusin", function (e) { e.stopPropagation(); });

            this.nextSearchTerm = undefined;

            if ($.isFunction(this.opts.initSelection)) {
                // initialize selection based on the current value of the source element
                this.initSelection();

                // if the user has provided a function that can set selection based on the value of the source element
                // we monitor the change event on the element and trigger it, allowing for two way synchronization
                this.monitorSource();
            }

            if (opts.maximumInputLength !== null) {
                this.search.attr("maxlength", opts.maximumInputLength);
            }

            var disabled = opts.element.prop("disabled");
            if (disabled === undefined) disabled = false;
            this.enable(!disabled);

            var readonly = opts.element.prop("readonly");
            if (readonly === undefined) readonly = false;
            this.readonly(readonly);

            // Calculate size of scrollbar
            scrollBarDimensions = scrollBarDimensions || measureScrollbar();

            this.autofocus = opts.element.prop("autofocus");
            opts.element.prop("autofocus", false);
            if (this.autofocus) this.focus();

            this.search.attr("placeholder", opts.searchInputPlaceholder);
        },

        // abstract
        destroy: function () {
            var element=this.opts.element, select2 = element.data("select2"), self = this;

            this.close();

            if (element.length && element[0].detachEvent && self._sync) {
                element.each(function () {
                    if (self._sync) {
                        this.detachEvent("onpropertychange", self._sync);
                    }
                });
            }
            if (this.propertyObserver) {
                this.propertyObserver.disconnect();
                this.propertyObserver = null;
            }
            this._sync = null;

            if (select2 !== undefined) {
                select2.container.remove();
                select2.liveRegion.remove();
                select2.dropdown.remove();
                element
                    .show()
                    .removeData("select2")
                    .off(".select2")
                    .prop("autofocus", this.autofocus || false);
                if (this.elementTabIndex) {
                    element.attr({tabindex: this.elementTabIndex});
                } else {
                    element.removeAttr("tabindex");
                }
                element.show();
            }

            cleanupJQueryElements.call(this,
                "container",
                "liveRegion",
                "dropdown",
                "results",
                "search"
            );
        },

        // abstract
        optionToData: function(element) {
            if (element.is("option")) {
                return {
                    id:element.prop("value"),
                    text:element.text(),
                    element: element.get(),
                    css: element.attr("class"),
                    disabled: element.prop("disabled"),
                    locked: equal(element.attr("locked"), "locked") || equal(element.data("locked"), true)
                };
            } else if (element.is("optgroup")) {
                return {
                    text:element.attr("label"),
                    children:[],
                    element: element.get(),
                    css: element.attr("class")
                };
            }
        },

        // abstract
        prepareOpts: function (opts) {
            var element, select, idKey, ajaxUrl, self = this;

            element = opts.element;

            if (element.get(0).tagName.toLowerCase() === "select") {
                this.select = select = opts.element;
            }

            if (select) {
                // these options are not allowed when attached to a select because they are picked up off the element itself
                $.each(["id", "multiple", "ajax", "query", "createSearchChoice", "initSelection", "data", "tags"], function () {
                    if (this in opts) {
                        throw new Error("Option '" + this + "' is not allowed for Select2 when attached to a <select> element.");
                    }
                });
            }

            opts = $.extend({}, {
                populateResults: function(container, results, query) {
                    var populate, id=this.opts.id, liveRegion=this.liveRegion;

                    populate=function(results, container, depth) {

                        var i, l, result, selectable, disabled, compound, node, label, innerContainer, formatted;

                        results = opts.sortResults(results, container, query);

                        // collect the created nodes for bulk append
                        var nodes = [];
                        for (i = 0, l = results.length; i < l; i = i + 1) {

                            result=results[i];

                            disabled = (result.disabled === true);
                            selectable = (!disabled) && (id(result) !== undefined);

                            compound=result.children && result.children.length > 0;

                            node=$("<li></li>");
                            node.addClass("select2-results-dept-"+depth);
                            node.addClass("select2-result");
                            node.addClass(selectable ? "select2-result-selectable" : "select2-result-unselectable");
                            if (disabled) { node.addClass("select2-disabled"); }
                            if (compound) { node.addClass("select2-result-with-children"); }
                            node.addClass(self.opts.formatResultCssClass(result));
                            node.attr("role", "presentation");

                            label=$(document.createElement("div"));
                            label.addClass("select2-result-label");
                            label.attr("id", "select2-result-label-" + nextUid());
                            label.attr("role", "option");

                            formatted=opts.formatResult(result, label, query, self.opts.escapeMarkup);
                            if (formatted!==undefined) {
                                label.html(formatted);
                                node.append(label);
                            }


                            if (compound) {

                                innerContainer=$("<ul></ul>");
                                innerContainer.addClass("select2-result-sub");
                                populate(result.children, innerContainer, depth+1);
                                node.append(innerContainer);
                            }

                            node.data("select2-data", result);
                            nodes.push(node[0]);
                        }

                        // bulk append the created nodes
                        container.append(nodes);
                        liveRegion.text(opts.formatMatches(results.length));
                    };

                    populate(results, container, 0);
                }
            }, $.fn.select2.defaults, opts);

            if (typeof(opts.id) !== "function") {
                idKey = opts.id;
                opts.id = function (e) { return e[idKey]; };
            }

            if ($.isArray(opts.element.data("select2Tags"))) {
                if ("tags" in opts) {
                    throw "tags specified as both an attribute 'data-select2-tags' and in options of Select2 " + opts.element.attr("id");
                }
                opts.tags=opts.element.data("select2Tags");
            }

            if (select) {
                opts.query = this.bind(function (query) {
                    var data = { results: [], more: false },
                        term = query.term,
                        children, placeholderOption, process;

                    process=function(element, collection) {
                        var group;
                        if (element.is("option")) {
                            if (query.matcher(term, element.text(), element)) {
                                collection.push(self.optionToData(element));
                            }
                        } else if (element.is("optgroup")) {
                            group=self.optionToData(element);
                            element.children().each2(function(i, elm) { process(elm, group.children); });
                            if (group.children.length>0) {
                                collection.push(group);
                            }
                        }
                    };

                    children=element.children();

                    // ignore the placeholder option if there is one
                    if (this.getPlaceholder() !== undefined && children.length > 0) {
                        placeholderOption = this.getPlaceholderOption();
                        if (placeholderOption) {
                            children=children.not(placeholderOption);
                        }
                    }

                    children.each2(function(i, elm) { process(elm, data.results); });

                    query.callback(data);
                });
                // this is needed because inside val() we construct choices from options and their id is hardcoded
                opts.id=function(e) { return e.id; };
            } else {
                if (!("query" in opts)) {

                    if ("ajax" in opts) {
                        ajaxUrl = opts.element.data("ajax-url");
                        if (ajaxUrl && ajaxUrl.length > 0) {
                            opts.ajax.url = ajaxUrl;
                        }
                        opts.query = ajax.call(opts.element, opts.ajax);
                    } else if ("data" in opts) {
                        opts.query = local(opts.data);
                    } else if ("tags" in opts) {
                        opts.query = tags(opts.tags);
                        if (opts.createSearchChoice === undefined) {
                            opts.createSearchChoice = function (term) { return {id: $.trim(term), text: $.trim(term)}; };
                        }
                        if (opts.initSelection === undefined) {
                            opts.initSelection = function (element, callback) {
                                var data = [];
                                $(splitVal(element.val(), opts.separator, opts.transformVal)).each(function () {
                                    var obj = { id: this, text: this },
                                        tags = opts.tags;
                                    if ($.isFunction(tags)) tags=tags();
                                    $(tags).each(function() { if (equal(this.id, obj.id)) { obj = this; return false; } });
                                    data.push(obj);
                                });

                                callback(data);
                            };
                        }
                    }
                }
            }
            if (typeof(opts.query) !== "function") {
                throw "query function not defined for Select2 " + opts.element.attr("id");
            }

            if (opts.createSearchChoicePosition === 'top') {
                opts.createSearchChoicePosition = function(list, item) { list.unshift(item); };
            }
            else if (opts.createSearchChoicePosition === 'bottom') {
                opts.createSearchChoicePosition = function(list, item) { list.push(item); };
            }
            else if (typeof(opts.createSearchChoicePosition) !== "function")  {
                throw "invalid createSearchChoicePosition option must be 'top', 'bottom' or a custom function";
            }

            return opts;
        },

        /**
         * Monitor the original element for changes and update select2 accordingly
         */
        // abstract
        monitorSource: function () {
            var el = this.opts.element, observer, self = this;

            el.on("change.select2", this.bind(function (e) {
                if (this.opts.element.data("select2-change-triggered") !== true) {
                    this.initSelection();
                }
            }));

            this._sync = this.bind(function () {

                // sync enabled state
                var disabled = el.prop("disabled");
                if (disabled === undefined) disabled = false;
                this.enable(!disabled);

                var readonly = el.prop("readonly");
                if (readonly === undefined) readonly = false;
                this.readonly(readonly);

                if (this.container) {
                    syncCssClasses(this.container, this.opts.element, this.opts.adaptContainerCssClass);
                    this.container.addClass(evaluate(this.opts.containerCssClass, this.opts.element));
                }

                if (this.dropdown) {
                    syncCssClasses(this.dropdown, this.opts.element, this.opts.adaptDropdownCssClass);
                    this.dropdown.addClass(evaluate(this.opts.dropdownCssClass, this.opts.element));
                }

            });

            // IE8-10 (IE9/10 won't fire propertyChange via attachEventListener)
            if (el.length && el[0].attachEvent) {
                el.each(function() {
                    this.attachEvent("onpropertychange", self._sync);
                });
            }

            // safari, chrome, firefox, IE11
            observer = window.MutationObserver || window.WebKitMutationObserver|| window.MozMutationObserver;
            if (observer !== undefined) {
                if (this.propertyObserver) { delete this.propertyObserver; this.propertyObserver = null; }
                this.propertyObserver = new observer(function (mutations) {
                    $.each(mutations, self._sync);
                });
                this.propertyObserver.observe(el.get(0), { attributes:true, subtree:false });
            }
        },

        // abstract
        triggerSelect: function(data) {
            var evt = $.Event("select2-selecting", { val: this.id(data), object: data, choice: data });
            this.opts.element.trigger(evt);
            return !evt.isDefaultPrevented();
        },

        /**
         * Triggers the change event on the source element
         */
        // abstract
        triggerChange: function (details) {

            details = details || {};
            details= $.extend({}, details, { type: "change", val: this.val() });
            // prevents recursive triggering
            this.opts.element.data("select2-change-triggered", true);
            this.opts.element.trigger(details);
            this.opts.element.data("select2-change-triggered", false);

            // some validation frameworks ignore the change event and listen instead to keyup, click for selects
            // so here we trigger the click event manually
            this.opts.element.click();

            // ValidationEngine ignores the change event and listens instead to blur
            // so here we trigger the blur event manually if so desired
            if (this.opts.blurOnChange)
                this.opts.element.blur();
        },

        //abstract
        isInterfaceEnabled: function()
        {
            return this.enabledInterface === true;
        },

        // abstract
        enableInterface: function() {
            var enabled = this._enabled && !this._readonly,
                disabled = !enabled;

            if (enabled === this.enabledInterface) return false;

            this.container.toggleClass("select2-container-disabled", disabled);
            this.close();
            this.enabledInterface = enabled;

            return true;
        },

        // abstract
        enable: function(enabled) {
            if (enabled === undefined) enabled = true;
            if (this._enabled === enabled) return;
            this._enabled = enabled;

            this.opts.element.prop("disabled", !enabled);
            this.enableInterface();
        },

        // abstract
        disable: function() {
            this.enable(false);
        },

        // abstract
        readonly: function(enabled) {
            if (enabled === undefined) enabled = false;
            if (this._readonly === enabled) return;
            this._readonly = enabled;

            this.opts.element.prop("readonly", enabled);
            this.enableInterface();
        },

        // abstract
        opened: function () {
            return (this.container) ? this.container.hasClass("select2-dropdown-open") : false;
        },

        // abstract
        positionDropdown: function() {
            var $dropdown = this.dropdown,
                container = this.container,
                offset = container.offset(),
                height = container.outerHeight(false),
                width = container.outerWidth(false),
                dropHeight = $dropdown.outerHeight(false),
                $window = $(window),
                windowWidth = $window.width(),
                windowHeight = $window.height(),
                viewPortRight = $window.scrollLeft() + windowWidth,
                viewportBottom = $window.scrollTop() + windowHeight,
                dropTop = offset.top + height,
                dropLeft = offset.left,
                enoughRoomBelow = dropTop + dropHeight <= viewportBottom,
                enoughRoomAbove = (offset.top - dropHeight) >= $window.scrollTop(),
                dropWidth = $dropdown.outerWidth(false),
                enoughRoomOnRight = function() {
                    return dropLeft + dropWidth <= viewPortRight;
                },
                enoughRoomOnLeft = function() {
                    return offset.left + viewPortRight + container.outerWidth(false)  > dropWidth;
                },
                aboveNow = $dropdown.hasClass("select2-drop-above"),
                bodyOffset,
                above,
                changeDirection,
                css,
                resultsListNode;

            // always prefer the current above/below alignment, unless there is not enough room
            if (aboveNow) {
                above = true;
                if (!enoughRoomAbove && enoughRoomBelow) {
                    changeDirection = true;
                    above = false;
                }
            } else {
                above = false;
                if (!enoughRoomBelow && enoughRoomAbove) {
                    changeDirection = true;
                    above = true;
                }
            }

            //if we are changing direction we need to get positions when dropdown is hidden;
            if (changeDirection) {
                $dropdown.hide();
                offset = this.container.offset();
                height = this.container.outerHeight(false);
                width = this.container.outerWidth(false);
                dropHeight = $dropdown.outerHeight(false);
                viewPortRight = $window.scrollLeft() + windowWidth;
                viewportBottom = $window.scrollTop() + windowHeight;
                dropTop = offset.top + height;
                dropLeft = offset.left;
                dropWidth = $dropdown.outerWidth(false);
                $dropdown.show();

                // fix so the cursor does not move to the left within the search-textbox in IE
                this.focusSearch();
            }

            if (this.opts.dropdownAutoWidth) {
                resultsListNode = $('.select2-results', $dropdown)[0];
                $dropdown.addClass('select2-drop-auto-width');
                $dropdown.css('width', '');
                // Add scrollbar width to dropdown if vertical scrollbar is present
                dropWidth = $dropdown.outerWidth(false) + (resultsListNode.scrollHeight === resultsListNode.clientHeight ? 0 : scrollBarDimensions.width);
                dropWidth > width ? width = dropWidth : dropWidth = width;
                dropHeight = $dropdown.outerHeight(false);
            }
            else {
                this.container.removeClass('select2-drop-auto-width');
            }

            //console.log("below/ droptop:", dropTop, "dropHeight", dropHeight, "sum", (dropTop+dropHeight)+" viewport bottom", viewportBottom, "enough?", enoughRoomBelow);
            //console.log("above/ offset.top", offset.top, "dropHeight", dropHeight, "top", (offset.top-dropHeight), "scrollTop", this.body.scrollTop(), "enough?", enoughRoomAbove);

            // fix positioning when body has an offset and is not position: static
            if (this.body.css('position') !== 'static') {
                bodyOffset = this.body.offset();
                dropTop -= bodyOffset.top;
                dropLeft -= bodyOffset.left;
            }

            if (!enoughRoomOnRight() && enoughRoomOnLeft()) {
                dropLeft = offset.left + this.container.outerWidth(false) - dropWidth;
            }

            css =  {
                left: dropLeft,
                width: width
            };

            if (above) {
                css.top = offset.top - dropHeight;
                css.bottom = 'auto';
                this.container.addClass("select2-drop-above");
                $dropdown.addClass("select2-drop-above");
            }
            else {
                css.top = dropTop;
                css.bottom = 'auto';
                this.container.removeClass("select2-drop-above");
                $dropdown.removeClass("select2-drop-above");
            }
            css = $.extend(css, evaluate(this.opts.dropdownCss, this.opts.element));

            $dropdown.css(css);
        },

        // abstract
        shouldOpen: function() {
            var event;

            if (this.opened()) return false;

            if (this._enabled === false || this._readonly === true) return false;

            event = $.Event("select2-opening");
            this.opts.element.trigger(event);
            return !event.isDefaultPrevented();
        },

        // abstract
        clearDropdownAlignmentPreference: function() {
            // clear the classes used to figure out the preference of where the dropdown should be opened
            this.container.removeClass("select2-drop-above");
            this.dropdown.removeClass("select2-drop-above");
        },

        /**
         * Opens the dropdown
         *
         * @return {Boolean} whether or not dropdown was opened. This method will return false if, for example,
         * the dropdown is already open, or if the 'open' event listener on the element called preventDefault().
         */
        // abstract
        open: function () {

            if (!this.shouldOpen()) return false;

            this.opening();

            // Only bind the document mousemove when the dropdown is visible
            $document.on("mousemove.select2Event", function (e) {
                lastMousePosition.x = e.pageX;
                lastMousePosition.y = e.pageY;
            });

            return true;
        },

        /**
         * Performs the opening of the dropdown
         */
        // abstract
        opening: function() {
            var cid = this.containerEventName,
                scroll = "scroll." + cid,
                resize = "resize."+cid,
                orient = "orientationchange."+cid,
                mask;

            this.container.addClass("select2-dropdown-open").addClass("select2-container-active");

            this.clearDropdownAlignmentPreference();

            if(this.dropdown[0] !== this.body.children().last()[0]) {
                this.dropdown.detach().appendTo(this.body);
            }

            // create the dropdown mask if doesn't already exist
            mask = $("#select2-drop-mask");
            if (mask.length === 0) {
                mask = $(document.createElement("div"));
                mask.attr("id","select2-drop-mask").attr("class","select2-drop-mask");
                mask.hide();
                mask.appendTo(this.body);
                mask.on("mousedown touchstart click", function (e) {
                    // Prevent IE from generating a click event on the body
                    reinsertElement(mask);

                    var dropdown = $("#select2-drop"), self;
                    if (dropdown.length > 0) {
                        self=dropdown.data("select2");
                        if (self.opts.selectOnBlur) {
                            self.selectHighlighted({noFocus: true});
                        }
                        self.close();
                        e.preventDefault();
                        e.stopPropagation();
                    }
                });
            }

            // ensure the mask is always right before the dropdown
            if (this.dropdown.prev()[0] !== mask[0]) {
                this.dropdown.before(mask);
            }

            // move the global id to the correct dropdown
            $("#select2-drop").removeAttr("id");
            this.dropdown.attr("id", "select2-drop");

            // show the elements
            mask.show();

            this.positionDropdown();
            this.dropdown.show();
            this.positionDropdown();

            this.dropdown.addClass("select2-drop-active");

            // attach listeners to events that can change the position of the container and thus require
            // the position of the dropdown to be updated as well so it does not come unglued from the container
            var that = this;
            this.container.parents().add(window).each(function () {
                $(this).on(resize+" "+scroll+" "+orient, function (e) {
                    if (that.opened()) that.positionDropdown();
                });
            });


        },

        // abstract
        close: function () {
            if (!this.opened()) return;

            var cid = this.containerEventName,
                scroll = "scroll." + cid,
                resize = "resize."+cid,
                orient = "orientationchange."+cid;

            // unbind event listeners
            this.container.parents().add(window).each(function () { $(this).off(scroll).off(resize).off(orient); });

            this.clearDropdownAlignmentPreference();

            $("#select2-drop-mask").hide();
            this.dropdown.removeAttr("id"); // only the active dropdown has the select2-drop id
            this.dropdown.hide();
            this.container.removeClass("select2-dropdown-open").removeClass("select2-container-active");
            this.results.empty();

            // Now that the dropdown is closed, unbind the global document mousemove event
            $document.off("mousemove.select2Event");

            this.clearSearch();
            this.search.removeClass("select2-active");
            this.opts.element.trigger($.Event("select2-close"));
        },

        /**
         * Opens control, sets input value, and updates results.
         */
        // abstract
        externalSearch: function (term) {
            this.open();
            this.search.val(term);
            this.updateResults(false);
        },

        // abstract
        clearSearch: function () {

        },

        //abstract
        getMaximumSelectionSize: function() {
            return evaluate(this.opts.maximumSelectionSize, this.opts.element);
        },

        // abstract
        ensureHighlightVisible: function () {
            var results = this.results, children, index, child, hb, rb, y, more, topOffset;

            index = this.highlight();

            if (index < 0) return;

            if (index == 0) {

                // if the first element is highlighted scroll all the way to the top,
                // that way any unselectable headers above it will also be scrolled
                // into view

                results.scrollTop(0);
                return;
            }

            children = this.findHighlightableChoices().find('.select2-result-label');

            child = $(children[index]);

            topOffset = (child.offset() || {}).top || 0;

            hb = topOffset + child.outerHeight(true);

            // if this is the last child lets also make sure select2-more-results is visible
            if (index === children.length - 1) {
                more = results.find("li.select2-more-results");
                if (more.length > 0) {
                    hb = more.offset().top + more.outerHeight(true);
                }
            }

            rb = results.offset().top + results.outerHeight(false);
            if (hb > rb) {
                results.scrollTop(results.scrollTop() + (hb - rb));
            }
            y = topOffset - results.offset().top;

            // make sure the top of the element is visible
            if (y < 0 && child.css('display') != 'none' ) {
                results.scrollTop(results.scrollTop() + y); // y is negative
            }
        },

        // abstract
        findHighlightableChoices: function() {
            return this.results.find(".select2-result-selectable:not(.select2-disabled):not(.select2-selected)");
        },

        // abstract
        moveHighlight: function (delta) {
            var choices = this.findHighlightableChoices(),
                index = this.highlight();

            while (index > -1 && index < choices.length) {
                index += delta;
                var choice = $(choices[index]);
                if (choice.hasClass("select2-result-selectable") && !choice.hasClass("select2-disabled") && !choice.hasClass("select2-selected")) {
                    this.highlight(index);
                    break;
                }
            }
        },

        // abstract
        highlight: function (index) {
            var choices = this.findHighlightableChoices(),
                choice,
                data;

            if (arguments.length === 0) {
                return indexOf(choices.filter(".select2-highlighted")[0], choices.get());
            }

            if (index >= choices.length) index = choices.length - 1;
            if (index < 0) index = 0;

            this.removeHighlight();

            choice = $(choices[index]);
            choice.addClass("select2-highlighted");

            // ensure assistive technology can determine the active choice
            this.search.attr("aria-activedescendant", choice.find(".select2-result-label").attr("id"));

            this.ensureHighlightVisible();

            this.liveRegion.text(choice.text());

            data = choice.data("select2-data");
            if (data) {
                this.opts.element.trigger({ type: "select2-highlight", val: this.id(data), choice: data });
            }
        },

        removeHighlight: function() {
            this.results.find(".select2-highlighted").removeClass("select2-highlighted");
        },

        touchMoved: function() {
            this._touchMoved = true;
        },

        clearTouchMoved: function() {
          this._touchMoved = false;
        },

        // abstract
        countSelectableResults: function() {
            return this.findHighlightableChoices().length;
        },

        // abstract
        highlightUnderEvent: function (event) {
            var el = $(event.target).closest(".select2-result-selectable");
            if (el.length > 0 && !el.is(".select2-highlighted")) {
                var choices = this.findHighlightableChoices();
                this.highlight(choices.index(el));
            } else if (el.length == 0) {
                // if we are over an unselectable item remove all highlights
                this.removeHighlight();
            }
        },

        // abstract
        loadMoreIfNeeded: function () {
            var results = this.results,
                more = results.find("li.select2-more-results"),
                below, // pixels the element is below the scroll fold, below==0 is when the element is starting to be visible
                page = this.resultsPage + 1,
                self=this,
                term=this.search.val(),
                context=this.context;

            if (more.length === 0) return;
            below = more.offset().top - results.offset().top - results.height();

            if (below <= this.opts.loadMorePadding) {
                more.addClass("select2-active");
                this.opts.query({
                        element: this.opts.element,
                        term: term,
                        page: page,
                        context: context,
                        matcher: this.opts.matcher,
                        callback: this.bind(function (data) {

                    // ignore a response if the select2 has been closed before it was received
                    if (!self.opened()) return;


                    self.opts.populateResults.call(this, results, data.results, {term: term, page: page, context:context});
                    self.postprocessResults(data, false, false);

                    if (data.more===true) {
                        more.detach().appendTo(results).html(self.opts.escapeMarkup(evaluate(self.opts.formatLoadMore, self.opts.element, page+1)));
                        window.setTimeout(function() { self.loadMoreIfNeeded(); }, 10);
                    } else {
                        more.remove();
                    }
                    self.positionDropdown();
                    self.resultsPage = page;
                    self.context = data.context;
                    this.opts.element.trigger({ type: "select2-loaded", items: data });
                })});
            }
        },

        /**
         * Default tokenizer function which does nothing
         */
        tokenize: function() {

        },

        /**
         * @param initial whether or not this is the call to this method right after the dropdown has been opened
         */
        // abstract
        updateResults: function (initial) {
            var search = this.search,
                results = this.results,
                opts = this.opts,
                data,
                self = this,
                input,
                term = search.val(),
                lastTerm = $.data(this.container, "select2-last-term"),
                // sequence number used to drop out-of-order responses
                queryNumber;

            // prevent duplicate queries against the same term
            if (initial !== true && lastTerm && equal(term, lastTerm)) return;

            $.data(this.container, "select2-last-term", term);

            // if the search is currently hidden we do not alter the results
            if (initial !== true && (this.showSearchInput === false || !this.opened())) {
                return;
            }

            function postRender() {
                search.removeClass("select2-active");
                self.positionDropdown();
                if (results.find('.select2-no-results,.select2-selection-limit,.select2-searching').length) {
                    self.liveRegion.text(results.text());
                }
                else {
                    self.liveRegion.text(self.opts.formatMatches(results.find('.select2-result-selectable:not(".select2-selected")').length));
                }
            }

            function render(html) {
                results.html(html);
                postRender();
            }

            queryNumber = ++this.queryCount;

            var maxSelSize = this.getMaximumSelectionSize();
            if (maxSelSize >=1) {
                data = this.data();
                if ($.isArray(data) && data.length >= maxSelSize && checkFormatter(opts.formatSelectionTooBig, "formatSelectionTooBig")) {
                    render("<li class='select2-selection-limit'>" + evaluate(opts.formatSelectionTooBig, opts.element, maxSelSize) + "</li>");
                    return;
                }
            }

            if (search.val().length < opts.minimumInputLength) {
                if (checkFormatter(opts.formatInputTooShort, "formatInputTooShort")) {
                    render("<li class='select2-no-results'>" + evaluate(opts.formatInputTooShort, opts.element, search.val(), opts.minimumInputLength) + "</li>");
                } else {
                    render("");
                }
                if (initial && this.showSearch) this.showSearch(true);
                return;
            }

            if (opts.maximumInputLength && search.val().length > opts.maximumInputLength) {
                if (checkFormatter(opts.formatInputTooLong, "formatInputTooLong")) {
                    render("<li class='select2-no-results'>" + evaluate(opts.formatInputTooLong, opts.element, search.val(), opts.maximumInputLength) + "</li>");
                } else {
                    render("");
                }
                return;
            }

            if (opts.formatSearching && this.findHighlightableChoices().length === 0) {
                render("<li class='select2-searching'>" + evaluate(opts.formatSearching, opts.element) + "</li>");
            }

            search.addClass("select2-active");

            this.removeHighlight();

            // give the tokenizer a chance to pre-process the input
            input = this.tokenize();
            if (input != undefined && input != null) {
                search.val(input);
            }

            this.resultsPage = 1;

            opts.query({
                element: opts.element,
                    term: search.val(),
                    page: this.resultsPage,
                    context: null,
                    matcher: opts.matcher,
                    callback: this.bind(function (data) {
                var def; // default choice

                // ignore old responses
                if (queryNumber != this.queryCount) {
                  return;
                }

                // ignore a response if the select2 has been closed before it was received
                if (!this.opened()) {
                    this.search.removeClass("select2-active");
                    return;
                }

                // handle ajax error
                if(data.hasError !== undefined && checkFormatter(opts.formatAjaxError, "formatAjaxError")) {
                    render("<li class='select2-ajax-error'>" + evaluate(opts.formatAjaxError, opts.element, data.jqXHR, data.textStatus, data.errorThrown) + "</li>");
                    return;
                }

                // save context, if any
                this.context = (data.context===undefined) ? null : data.context;
                // create a default choice and prepend it to the list
                if (this.opts.createSearchChoice && search.val() !== "") {
                    def = this.opts.createSearchChoice.call(self, search.val(), data.results);
                    if (def !== undefined && def !== null && self.id(def) !== undefined && self.id(def) !== null) {
                        if ($(data.results).filter(
                            function () {
                                return equal(self.id(this), self.id(def));
                            }).length === 0) {
                            this.opts.createSearchChoicePosition(data.results, def);
                        }
                    }
                }

                if (data.results.length === 0 && checkFormatter(opts.formatNoMatches, "formatNoMatches")) {
                    render("<li class='select2-no-results'>" + evaluate(opts.formatNoMatches, opts.element, search.val()) + "</li>");
                    return;
                }

                results.empty();
                self.opts.populateResults.call(this, results, data.results, {term: search.val(), page: this.resultsPage, context:null});

                if (data.more === true && checkFormatter(opts.formatLoadMore, "formatLoadMore")) {
                    results.append("<li class='select2-more-results'>" + opts.escapeMarkup(evaluate(opts.formatLoadMore, opts.element, this.resultsPage)) + "</li>");
                    window.setTimeout(function() { self.loadMoreIfNeeded(); }, 10);
                }

                this.postprocessResults(data, initial);

                postRender();

                this.opts.element.trigger({ type: "select2-loaded", items: data });
            })});
        },

        // abstract
        cancel: function () {
            this.close();
        },

        // abstract
        blur: function () {
            // if selectOnBlur == true, select the currently highlighted option
            if (this.opts.selectOnBlur)
                this.selectHighlighted({noFocus: true});

            this.close();
            this.container.removeClass("select2-container-active");
            // synonymous to .is(':focus'), which is available in jquery >= 1.6
            if (this.search[0] === document.activeElement) { this.search.blur(); }
            this.clearSearch();
            this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
        },

        // abstract
        focusSearch: function () {
            focus(this.search);
        },

        // abstract
        selectHighlighted: function (options) {
            if (this._touchMoved) {
              this.clearTouchMoved();
              return;
            }
            var index=this.highlight(),
                highlighted=this.results.find(".select2-highlighted"),
                data = highlighted.closest('.select2-result').data("select2-data");

            if (data) {
                this.highlight(index);
                this.onSelect(data, options);
            } else if (options && options.noFocus) {
                this.close();
            }
        },

        // abstract
        getPlaceholder: function () {
            var placeholderOption;
            return this.opts.element.attr("placeholder") ||
                this.opts.element.attr("data-placeholder") || // jquery 1.4 compat
                this.opts.element.data("placeholder") ||
                this.opts.placeholder ||
                ((placeholderOption = this.getPlaceholderOption()) !== undefined ? placeholderOption.text() : undefined);
        },

        // abstract
        getPlaceholderOption: function() {
            if (this.select) {
                var firstOption = this.select.children('option').first();
                if (this.opts.placeholderOption !== undefined ) {
                    //Determine the placeholder option based on the specified placeholderOption setting
                    return (this.opts.placeholderOption === "first" && firstOption) ||
                           (typeof this.opts.placeholderOption === "function" && this.opts.placeholderOption(this.select));
                } else if ($.trim(firstOption.text()) === "" && firstOption.val() === "") {
                    //No explicit placeholder option specified, use the first if it's blank
                    return firstOption;
                }
            }
        },

        /**
         * Get the desired width for the container element.  This is
         * derived first from option `width` passed to select2, then
         * the inline 'style' on the original element, and finally
         * falls back to the jQuery calculated element width.
         */
        // abstract
        initContainerWidth: function () {
            function resolveContainerWidth() {
                var style, attrs, matches, i, l, attr;

                if (this.opts.width === "off") {
                    return null;
                } else if (this.opts.width === "element"){
                    return this.opts.element.outerWidth(false) === 0 ? 'auto' : this.opts.element.outerWidth(false) + 'px';
                } else if (this.opts.width === "copy" || this.opts.width === "resolve") {
                    // check if there is inline style on the element that contains width
                    style = this.opts.element.attr('style');
                    if (style !== undefined) {
                        attrs = style.split(';');
                        for (i = 0, l = attrs.length; i < l; i = i + 1) {
                            attr = attrs[i].replace(/\s/g, '');
                            matches = attr.match(/^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i);
                            if (matches !== null && matches.length >= 1)
                                return matches[1];
                        }
                    }

                    if (this.opts.width === "resolve") {
                        // next check if css('width') can resolve a width that is percent based, this is sometimes possible
                        // when attached to input type=hidden or elements hidden via css
                        style = this.opts.element.css('width');
                        if (style.indexOf("%") > 0) return style;

                        // finally, fallback on the calculated width of the element
                        return (this.opts.element.outerWidth(false) === 0 ? 'auto' : this.opts.element.outerWidth(false) + 'px');
                    }

                    return null;
                } else if ($.isFunction(this.opts.width)) {
                    return this.opts.width();
                } else {
                    return this.opts.width;
               }
            };

            var width = resolveContainerWidth.call(this);
            if (width !== null) {
                this.container.css("width", width);
            }
        }
    });

    SingleSelect2 = clazz(AbstractSelect2, {

        // single

        createContainer: function () {
            var container = $(document.createElement("div")).attr({
                "class": "select2-container"
            }).html([
                "<a href='javascript:void(0)' class='select2-choice' tabindex='-1'>",
                "   <span class='select2-chosen'>&#160;</span><abbr class='select2-search-choice-close'></abbr>",
                "   <span class='select2-arrow' role='presentation'><b role='presentation'></b></span>",
                "</a>",
                "<label for='' class='select2-offscreen'></label>",
                "<input class='select2-focusser select2-offscreen' type='text' aria-haspopup='true' role='button' />",
                "<div class='select2-drop select2-display-none'>",
                "   <div class='select2-search'>",
                "       <label for='' class='select2-offscreen'></label>",
                "       <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='select2-input' role='combobox' aria-expanded='true'",
                "       aria-autocomplete='list' />",
                "   </div>",
                "   <ul class='select2-results' role='listbox'>",
                "   </ul>",
                "</div>"].join(""));
            return container;
        },

        // single
        enableInterface: function() {
            if (this.parent.enableInterface.apply(this, arguments)) {
                this.focusser.prop("disabled", !this.isInterfaceEnabled());
            }
        },

        // single
        opening: function () {
            var el, range, len;

            if (this.opts.minimumResultsForSearch >= 0) {
                this.showSearch(true);
            }

            this.parent.opening.apply(this, arguments);

            if (this.showSearchInput !== false) {
                // IE appends focusser.val() at the end of field :/ so we manually insert it at the beginning using a range
                // all other browsers handle this just fine

                this.search.val(this.focusser.val());
            }
            if (this.opts.shouldFocusInput(this)) {
                this.search.focus();
                // move the cursor to the end after focussing, otherwise it will be at the beginning and
                // new text will appear *before* focusser.val()
                el = this.search.get(0);
                if (el.createTextRange) {
                    range = el.createTextRange();
                    range.collapse(false);
                    range.select();
                } else if (el.setSelectionRange) {
                    len = this.search.val().length;
                    el.setSelectionRange(len, len);
                }
            }

            // initializes search's value with nextSearchTerm (if defined by user)
            // ignore nextSearchTerm if the dropdown is opened by the user pressing a letter
            if(this.search.val() === "") {
                if(this.nextSearchTerm != undefined){
                    this.search.val(this.nextSearchTerm);
                    this.search.select();
                }
            }

            this.focusser.prop("disabled", true).val("");
            this.updateResults(true);
            this.opts.element.trigger($.Event("select2-open"));
        },

        // single
        close: function () {
            if (!this.opened()) return;
            this.parent.close.apply(this, arguments);

            this.focusser.prop("disabled", false);

            if (this.opts.shouldFocusInput(this)) {
                this.focusser.focus();
            }
        },

        // single
        focus: function () {
            if (this.opened()) {
                this.close();
            } else {
                this.focusser.prop("disabled", false);
                if (this.opts.shouldFocusInput(this)) {
                    this.focusser.focus();
                }
            }
        },

        // single
        isFocused: function () {
            return this.container.hasClass("select2-container-active");
        },

        // single
        cancel: function () {
            this.parent.cancel.apply(this, arguments);
            this.focusser.prop("disabled", false);

            if (this.opts.shouldFocusInput(this)) {
                this.focusser.focus();
            }
        },

        // single
        destroy: function() {
            $("label[for='" + this.focusser.attr('id') + "']")
                .attr('for', this.opts.element.attr("id"));
            this.parent.destroy.apply(this, arguments);

            cleanupJQueryElements.call(this,
                "selection",
                "focusser"
            );
        },

        // single
        initContainer: function () {

            var selection,
                container = this.container,
                dropdown = this.dropdown,
                idSuffix = nextUid(),
                elementLabel;

            if (this.opts.minimumResultsForSearch < 0) {
                this.showSearch(false);
            } else {
                this.showSearch(true);
            }

            this.selection = selection = container.find(".select2-choice");

            this.focusser = container.find(".select2-focusser");

            // add aria associations
            selection.find(".select2-chosen").attr("id", "select2-chosen-"+idSuffix);
            this.focusser.attr("aria-labelledby", "select2-chosen-"+idSuffix);
            this.results.attr("id", "select2-results-"+idSuffix);
            this.search.attr("aria-owns", "select2-results-"+idSuffix);

            // rewrite labels from original element to focusser
            this.focusser.attr("id", "s2id_autogen"+idSuffix);

            elementLabel = $("label[for='" + this.opts.element.attr("id") + "']");
            this.opts.element.focus(this.bind(function () { this.focus(); }));

            this.focusser.prev()
                .text(elementLabel.text())
                .attr('for', this.focusser.attr('id'));

            // Ensure the original element retains an accessible name
            var originalTitle = this.opts.element.attr("title");
            this.opts.element.attr("title", (originalTitle || elementLabel.text()));

            this.focusser.attr("tabindex", this.elementTabIndex);

            // write label for search field using the label from the focusser element
            this.search.attr("id", this.focusser.attr('id') + '_search');

            this.search.prev()
                .text($("label[for='" + this.focusser.attr('id') + "']").text())
                .attr('for', this.search.attr('id'));

            this.search.on("keydown", this.bind(function (e) {
                if (!this.isInterfaceEnabled()) return;

                // filter 229 keyCodes (input method editor is processing key input)
                if (229 == e.keyCode) return;

                if (e.which === KEY.PAGE_UP || e.which === KEY.PAGE_DOWN) {
                    // prevent the page from scrolling
                    killEvent(e);
                    return;
                }

                switch (e.which) {
                    case KEY.UP:
                    case KEY.DOWN:
                        this.moveHighlight((e.which === KEY.UP) ? -1 : 1);
                        killEvent(e);
                        return;
                    case KEY.ENTER:
                        this.selectHighlighted();
                        killEvent(e);
                        return;
                    case KEY.TAB:
                        this.selectHighlighted({noFocus: true});
                        return;
                    case KEY.ESC:
                        this.cancel(e);
                        killEvent(e);
                        return;
                }
            }));

            this.search.on("blur", this.bind(function(e) {
                // a workaround for chrome to keep the search field focussed when the scroll bar is used to scroll the dropdown.
                // without this the search field loses focus which is annoying
                if (document.activeElement === this.body.get(0)) {
                    window.setTimeout(this.bind(function() {
                        if (this.opened()) {
                            this.search.focus();
                        }
                    }), 0);
                }
            }));

            this.focusser.on("keydown", this.bind(function (e) {
                if (!this.isInterfaceEnabled()) return;

                if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC) {
                    return;
                }

                if (this.opts.openOnEnter === false && e.which === KEY.ENTER) {
                    killEvent(e);
                    return;
                }

                if (e.which == KEY.DOWN || e.which == KEY.UP
                    || (e.which == KEY.ENTER && this.opts.openOnEnter)) {

                    if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) return;

                    this.open();
                    killEvent(e);
                    return;
                }

                if (e.which == KEY.DELETE || e.which == KEY.BACKSPACE) {
                    if (this.opts.allowClear) {
                        this.clear();
                    }
                    killEvent(e);
                    return;
                }
            }));


            installKeyUpChangeEvent(this.focusser);
            this.focusser.on("keyup-change input", this.bind(function(e) {
                if (this.opts.minimumResultsForSearch >= 0) {
                    e.stopPropagation();
                    if (this.opened()) return;
                    this.open();
                }
            }));

            selection.on("mousedown touchstart", "abbr", this.bind(function (e) {
                if (!this.isInterfaceEnabled()) {
                    return;
                }

                this.clear();
                killEventImmediately(e);
                this.close();

                if (this.selection) {
                    this.selection.focus();
                }
            }));

            selection.on("mousedown touchstart", this.bind(function (e) {
                // Prevent IE from generating a click event on the body
                reinsertElement(selection);

                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }

                if (this.opened()) {
                    this.close();
                } else if (this.isInterfaceEnabled()) {
                    this.open();
                }

                killEvent(e);
            }));

            dropdown.on("mousedown touchstart", this.bind(function() {
                if (this.opts.shouldFocusInput(this)) {
                    this.search.focus();
                }
            }));

            selection.on("focus", this.bind(function(e) {
                killEvent(e);
            }));

            this.focusser.on("focus", this.bind(function(){
                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }
                this.container.addClass("select2-container-active");
            })).on("blur", this.bind(function() {
                if (!this.opened()) {
                    this.container.removeClass("select2-container-active");
                    this.opts.element.trigger($.Event("select2-blur"));
                }
            }));
            this.search.on("focus", this.bind(function(){
                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }
                this.container.addClass("select2-container-active");
            }));

            this.initContainerWidth();
            this.opts.element.hide();
            this.setPlaceholder();

        },

        // single
        clear: function(triggerChange) {
            var data=this.selection.data("select2-data");
            if (data) { // guard against queued quick consecutive clicks
                var evt = $.Event("select2-clearing");
                this.opts.element.trigger(evt);
                if (evt.isDefaultPrevented()) {
                    return;
                }
                var placeholderOption = this.getPlaceholderOption();
                this.opts.element.val(placeholderOption ? placeholderOption.val() : "");
                this.selection.find(".select2-chosen").empty();
                this.selection.removeData("select2-data");
                this.setPlaceholder();

                if (triggerChange !== false){
                    this.opts.element.trigger({ type: "select2-removed", val: this.id(data), choice: data });
                    this.triggerChange({removed:data});
                }
            }
        },

        /**
         * Sets selection based on source element's value
         */
        // single
        initSelection: function () {
            var selected;
            if (this.isPlaceholderOptionSelected()) {
                this.updateSelection(null);
                this.close();
                this.setPlaceholder();
            } else {
                var self = this;
                this.opts.initSelection.call(null, this.opts.element, function(selected){
                    if (selected !== undefined && selected !== null) {
                        self.updateSelection(selected);
                        self.close();
                        self.setPlaceholder();
                        self.nextSearchTerm = self.opts.nextSearchTerm(selected, self.search.val());
                    }
                });
            }
        },

        isPlaceholderOptionSelected: function() {
            var placeholderOption;
            if (this.getPlaceholder() === undefined) return false; // no placeholder specified so no option should be considered
            return ((placeholderOption = this.getPlaceholderOption()) !== undefined && placeholderOption.prop("selected"))
                || (this.opts.element.val() === "")
                || (this.opts.element.val() === undefined)
                || (this.opts.element.val() === null);
        },

        // single
        prepareOpts: function () {
            var opts = this.parent.prepareOpts.apply(this, arguments),
                self=this;

            if (opts.element.get(0).tagName.toLowerCase() === "select") {
                // install the selection initializer
                opts.initSelection = function (element, callback) {
                    var selected = element.find("option").filter(function() { return this.selected && !this.disabled });
                    // a single select box always has a value, no need to null check 'selected'
                    callback(self.optionToData(selected));
                };
            } else if ("data" in opts) {
                // install default initSelection when applied to hidden input and data is local
                opts.initSelection = opts.initSelection || function (element, callback) {
                    var id = element.val();
                    //search in data by id, storing the actual matching item
                    var match = null;
                    opts.query({
                        matcher: function(term, text, el){
                            var is_match = equal(id, opts.id(el));
                            if (is_match) {
                                match = el;
                            }
                            return is_match;
                        },
                        callback: !$.isFunction(callback) ? $.noop : function() {
                            callback(match);
                        }
                    });
                };
            }

            return opts;
        },

        // single
        getPlaceholder: function() {
            // if a placeholder is specified on a single select without a valid placeholder option ignore it
            if (this.select) {
                if (this.getPlaceholderOption() === undefined) {
                    return undefined;
                }
            }

            return this.parent.getPlaceholder.apply(this, arguments);
        },

        // single
        setPlaceholder: function () {
            var placeholder = this.getPlaceholder();

            if (this.isPlaceholderOptionSelected() && placeholder !== undefined) {

                // check for a placeholder option if attached to a select
                if (this.select && this.getPlaceholderOption() === undefined) return;

                this.selection.find(".select2-chosen").html(this.opts.escapeMarkup(placeholder));

                this.selection.addClass("select2-default");

                this.container.removeClass("select2-allowclear");
            }
        },

        // single
        postprocessResults: function (data, initial, noHighlightUpdate) {
            var selected = 0, self = this, showSearchInput = true;

            // find the selected element in the result list

            this.findHighlightableChoices().each2(function (i, elm) {
                if (equal(self.id(elm.data("select2-data")), self.opts.element.val())) {
                    selected = i;
                    return false;
                }
            });

            // and highlight it
            if (noHighlightUpdate !== false) {
                if (initial === true && selected >= 0) {
                    this.highlight(selected);
                } else {
                    this.highlight(0);
                }
            }

            // hide the search box if this is the first we got the results and there are enough of them for search

            if (initial === true) {
                var min = this.opts.minimumResultsForSearch;
                if (min >= 0) {
                    this.showSearch(countResults(data.results) >= min);
                }
            }
        },

        // single
        showSearch: function(showSearchInput) {
            if (this.showSearchInput === showSearchInput) return;

            this.showSearchInput = showSearchInput;

            this.dropdown.find(".select2-search").toggleClass("select2-search-hidden", !showSearchInput);
            this.dropdown.find(".select2-search").toggleClass("select2-offscreen", !showSearchInput);
            //add "select2-with-searchbox" to the container if search box is shown
            $(this.dropdown, this.container).toggleClass("select2-with-searchbox", showSearchInput);
        },

        // single
        onSelect: function (data, options) {

            if (!this.triggerSelect(data)) { return; }

            var old = this.opts.element.val(),
                oldData = this.data();

            this.opts.element.val(this.id(data));
            this.updateSelection(data);

            this.opts.element.trigger({ type: "select2-selected", val: this.id(data), choice: data });

            this.nextSearchTerm = this.opts.nextSearchTerm(data, this.search.val());
            this.close();

            if ((!options || !options.noFocus) && this.opts.shouldFocusInput(this)) {
                this.focusser.focus();
            }

            if (!equal(old, this.id(data))) {
                this.triggerChange({ added: data, removed: oldData });
            }
        },

        // single
        updateSelection: function (data) {

            var container=this.selection.find(".select2-chosen"), formatted, cssClass;

            this.selection.data("select2-data", data);

            container.empty();
            if (data !== null) {
                formatted=this.opts.formatSelection(data, container, this.opts.escapeMarkup);
            }
            if (formatted !== undefined) {
                container.append(formatted);
            }
            cssClass=this.opts.formatSelectionCssClass(data, container);
            if (cssClass !== undefined) {
                container.addClass(cssClass);
            }

            this.selection.removeClass("select2-default");

            if (this.opts.allowClear && this.getPlaceholder() !== undefined) {
                this.container.addClass("select2-allowclear");
            }
        },

        // single
        val: function () {
            var val,
                triggerChange = false,
                data = null,
                self = this,
                oldData = this.data();

            if (arguments.length === 0) {
                return this.opts.element.val();
            }

            val = arguments[0];

            if (arguments.length > 1) {
                triggerChange = arguments[1];
            }

            if (this.select) {
                this.select
                    .val(val)
                    .find("option").filter(function() { return this.selected }).each2(function (i, elm) {
                        data = self.optionToData(elm);
                        return false;
                    });
                this.updateSelection(data);
                this.setPlaceholder();
                if (triggerChange) {
                    this.triggerChange({added: data, removed:oldData});
                }
            } else {
                // val is an id. !val is true for [undefined,null,'',0] - 0 is legal
                if (!val && val !== 0) {
                    this.clear(triggerChange);
                    return;
                }
                if (this.opts.initSelection === undefined) {
                    throw new Error("cannot call val() if initSelection() is not defined");
                }
                this.opts.element.val(val);
                this.opts.initSelection(this.opts.element, function(data){
                    self.opts.element.val(!data ? "" : self.id(data));
                    self.updateSelection(data);
                    self.setPlaceholder();
                    if (triggerChange) {
                        self.triggerChange({added: data, removed:oldData});
                    }
                });
            }
        },

        // single
        clearSearch: function () {
            this.search.val("");
            this.focusser.val("");
        },

        // single
        data: function(value) {
            var data,
                triggerChange = false;

            if (arguments.length === 0) {
                data = this.selection.data("select2-data");
                if (data == undefined) data = null;
                return data;
            } else {
                if (arguments.length > 1) {
                    triggerChange = arguments[1];
                }
                if (!value) {
                    this.clear(triggerChange);
                } else {
                    data = this.data();
                    this.opts.element.val(!value ? "" : this.id(value));
                    this.updateSelection(value);
                    if (triggerChange) {
                        this.triggerChange({added: value, removed:data});
                    }
                }
            }
        }
    });

    MultiSelect2 = clazz(AbstractSelect2, {

        // multi
        createContainer: function () {
            var container = $(document.createElement("div")).attr({
                "class": "select2-container select2-container-multi"
            }).html([
                "<ul class='select2-choices'>",
                "  <li class='select2-search-field'>",
                "    <label for='' class='select2-offscreen'></label>",
                "    <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='select2-input'>",
                "  </li>",
                "</ul>",
                "<div class='select2-drop select2-drop-multi select2-display-none'>",
                "   <ul class='select2-results'>",
                "   </ul>",
                "</div>"].join(""));
            return container;
        },

        // multi
        prepareOpts: function () {
            var opts = this.parent.prepareOpts.apply(this, arguments),
                self=this;

            // TODO validate placeholder is a string if specified
            if (opts.element.get(0).tagName.toLowerCase() === "select") {
                // install the selection initializer
                opts.initSelection = function (element, callback) {

                    var data = [];

                    element.find("option").filter(function() { return this.selected && !this.disabled }).each2(function (i, elm) {
                        data.push(self.optionToData(elm));
                    });
                    callback(data);
                };
            } else if ("data" in opts) {
                // install default initSelection when applied to hidden input and data is local
                opts.initSelection = opts.initSelection || function (element, callback) {
                    var ids = splitVal(element.val(), opts.separator, opts.transformVal);
                    //search in data by array of ids, storing matching items in a list
                    var matches = [];
                    opts.query({
                        matcher: function(term, text, el){
                            var is_match = $.grep(ids, function(id) {
                                return equal(id, opts.id(el));
                            }).length;
                            if (is_match) {
                                matches.push(el);
                            }
                            return is_match;
                        },
                        callback: !$.isFunction(callback) ? $.noop : function() {
                            // reorder matches based on the order they appear in the ids array because right now
                            // they are in the order in which they appear in data array
                            var ordered = [];
                            for (var i = 0; i < ids.length; i++) {
                                var id = ids[i];
                                for (var j = 0; j < matches.length; j++) {
                                    var match = matches[j];
                                    if (equal(id, opts.id(match))) {
                                        ordered.push(match);
                                        matches.splice(j, 1);
                                        break;
                                    }
                                }
                            }
                            callback(ordered);
                        }
                    });
                };
            }

            return opts;
        },

        // multi
        selectChoice: function (choice) {

            var selected = this.container.find(".select2-search-choice-focus");
            if (selected.length && choice && choice[0] == selected[0]) {

            } else {
                if (selected.length) {
                    this.opts.element.trigger("choice-deselected", selected);
                }
                selected.removeClass("select2-search-choice-focus");
                if (choice && choice.length) {
                    this.close();
                    choice.addClass("select2-search-choice-focus");
                    this.opts.element.trigger("choice-selected", choice);
                }
            }
        },

        // multi
        destroy: function() {
            $("label[for='" + this.search.attr('id') + "']")
                .attr('for', this.opts.element.attr("id"));
            this.parent.destroy.apply(this, arguments);

            cleanupJQueryElements.call(this,
                "searchContainer",
                "selection"
            );
        },

        // multi
        initContainer: function () {

            var selector = ".select2-choices", selection;

            this.searchContainer = this.container.find(".select2-search-field");
            this.selection = selection = this.container.find(selector);

            var _this = this;
            this.selection.on("click", ".select2-container:not(.select2-container-disabled) .select2-search-choice:not(.select2-locked)", function (e) {
                _this.search[0].focus();
                _this.selectChoice($(this));
            });

            // rewrite labels from original element to focusser
            this.search.attr("id", "s2id_autogen"+nextUid());

            this.search.prev()
                .text($("label[for='" + this.opts.element.attr("id") + "']").text())
                .attr('for', this.search.attr('id'));
            this.opts.element.focus(this.bind(function () { this.focus(); }));

            this.search.on("input paste", this.bind(function() {
                if (this.search.attr('placeholder') && this.search.val().length == 0) return;
                if (!this.isInterfaceEnabled()) return;
                if (!this.opened()) {
                    this.open();
                }
            }));

            this.search.attr("tabindex", this.elementTabIndex);

            this.keydowns = 0;
            this.search.on("keydown", this.bind(function (e) {
                if (!this.isInterfaceEnabled()) return;

                ++this.keydowns;
                var selected = selection.find(".select2-search-choice-focus");
                var prev = selected.prev(".select2-search-choice:not(.select2-locked)");
                var next = selected.next(".select2-search-choice:not(.select2-locked)");
                var pos = getCursorInfo(this.search);

                if (selected.length &&
                    (e.which == KEY.LEFT || e.which == KEY.RIGHT || e.which == KEY.BACKSPACE || e.which == KEY.DELETE || e.which == KEY.ENTER)) {
                    var selectedChoice = selected;
                    if (e.which == KEY.LEFT && prev.length) {
                        selectedChoice = prev;
                    }
                    else if (e.which == KEY.RIGHT) {
                        selectedChoice = next.length ? next : null;
                    }
                    else if (e.which === KEY.BACKSPACE) {
                        if (this.unselect(selected.first())) {
                            this.search.width(10);
                            selectedChoice = prev.length ? prev : next;
                        }
                    } else if (e.which == KEY.DELETE) {
                        if (this.unselect(selected.first())) {
                            this.search.width(10);
                            selectedChoice = next.length ? next : null;
                        }
                    } else if (e.which == KEY.ENTER) {
                        selectedChoice = null;
                    }

                    this.selectChoice(selectedChoice);
                    killEvent(e);
                    if (!selectedChoice || !selectedChoice.length) {
                        this.open();
                    }
                    return;
                } else if (((e.which === KEY.BACKSPACE && this.keydowns == 1)
                    || e.which == KEY.LEFT) && (pos.offset == 0 && !pos.length)) {

                    this.selectChoice(selection.find(".select2-search-choice:not(.select2-locked)").last());
                    killEvent(e);
                    return;
                } else {
                    this.selectChoice(null);
                }

                if (this.opened()) {
                    switch (e.which) {
                    case KEY.UP:
                    case KEY.DOWN:
                        this.moveHighlight((e.which === KEY.UP) ? -1 : 1);
                        killEvent(e);
                        return;
                    case KEY.ENTER:
                        this.selectHighlighted();
                        killEvent(e);
                        return;
                    case KEY.TAB:
                        this.selectHighlighted({noFocus:true});
                        this.close();
                        return;
                    case KEY.ESC:
                        this.cancel(e);
                        killEvent(e);
                        return;
                    }
                }

                if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e)
                 || e.which === KEY.BACKSPACE || e.which === KEY.ESC) {
                    return;
                }

                if (e.which === KEY.ENTER) {
                    if (this.opts.openOnEnter === false) {
                        return;
                    } else if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) {
                        return;
                    }
                }

                this.open();

                if (e.which === KEY.PAGE_UP || e.which === KEY.PAGE_DOWN) {
                    // prevent the page from scrolling
                    killEvent(e);
                }

                if (e.which === KEY.ENTER) {
                    // prevent form from being submitted
                    killEvent(e);
                }

            }));

            this.search.on("keyup", this.bind(function (e) {
                this.keydowns = 0;
                this.resizeSearch();
            })
            );

            this.search.on("blur", this.bind(function(e) {
                this.container.removeClass("select2-container-active");
                this.search.removeClass("select2-focused");
                this.selectChoice(null);
                if (!this.opened()) this.clearSearch();
                e.stopImmediatePropagation();
                this.opts.element.trigger($.Event("select2-blur"));
            }));

            this.container.on("click", selector, this.bind(function (e) {
                if (!this.isInterfaceEnabled()) return;
                if ($(e.target).closest(".select2-search-choice").length > 0) {
                    // clicked inside a select2 search choice, do not open
                    return;
                }
                this.selectChoice(null);
                this.clearPlaceholder();
                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }
                this.open();
                this.focusSearch();
                e.preventDefault();
            }));

            this.container.on("focus", selector, this.bind(function () {
                if (!this.isInterfaceEnabled()) return;
                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }
                this.container.addClass("select2-container-active");
                this.dropdown.addClass("select2-drop-active");
                this.clearPlaceholder();
            }));

            this.initContainerWidth();
            this.opts.element.hide();

            // set the placeholder if necessary
            this.clearSearch();
        },

        // multi
        enableInterface: function() {
            if (this.parent.enableInterface.apply(this, arguments)) {
                this.search.prop("disabled", !this.isInterfaceEnabled());
            }
        },

        // multi
        initSelection: function () {
            var data;
            if (this.opts.element.val() === "" && this.opts.element.text() === "") {
                this.updateSelection([]);
                this.close();
                // set the placeholder if necessary
                this.clearSearch();
            }
            if (this.select || this.opts.element.val() !== "") {
                var self = this;
                this.opts.initSelection.call(null, this.opts.element, function(data){
                    if (data !== undefined && data !== null) {
                        self.updateSelection(data);
                        self.close();
                        // set the placeholder if necessary
                        self.clearSearch();
                    }
                });
            }
        },

        // multi
        clearSearch: function () {
            var placeholder = this.getPlaceholder(),
                maxWidth = this.getMaxSearchWidth();

            if (placeholder !== undefined  && this.getVal().length === 0 && this.search.hasClass("select2-focused") === false) {
                this.search.val(placeholder).addClass("select2-default");
                // stretch the search box to full width of the container so as much of the placeholder is visible as possible
                // we could call this.resizeSearch(), but we do not because that requires a sizer and we do not want to create one so early because of a firefox bug, see #944
                this.search.width(maxWidth > 0 ? maxWidth : this.container.css("width"));
            } else {
                this.search.val("").width(10);
            }
        },

        // multi
        clearPlaceholder: function () {
            if (this.search.hasClass("select2-default")) {
                this.search.val("").removeClass("select2-default");
            }
        },

        // multi
        opening: function () {
            this.clearPlaceholder(); // should be done before super so placeholder is not used to search
            this.resizeSearch();

            this.parent.opening.apply(this, arguments);

            this.focusSearch();

            // initializes search's value with nextSearchTerm (if defined by user)
            // ignore nextSearchTerm if the dropdown is opened by the user pressing a letter
            if(this.search.val() === "") {
                if(this.nextSearchTerm != undefined){
                    this.search.val(this.nextSearchTerm);
                    this.search.select();
                }
            }

            this.updateResults(true);
            if (this.opts.shouldFocusInput(this)) {
                this.search.focus();
            }
            this.opts.element.trigger($.Event("select2-open"));
        },

        // multi
        close: function () {
            if (!this.opened()) return;
            this.parent.close.apply(this, arguments);
        },

        // multi
        focus: function () {
            this.close();
            this.search.focus();
        },

        // multi
        isFocused: function () {
            return this.search.hasClass("select2-focused");
        },

        // multi
        updateSelection: function (data) {
            var ids = [], filtered = [], self = this;

            // filter out duplicates
            $(data).each(function () {
                if (indexOf(self.id(this), ids) < 0) {
                    ids.push(self.id(this));
                    filtered.push(this);
                }
            });
            data = filtered;

            this.selection.find(".select2-search-choice").remove();
            $(data).each(function () {
                self.addSelectedChoice(this);
            });
            self.postprocessResults();
        },

        // multi
        tokenize: function() {
            var input = this.search.val();
            input = this.opts.tokenizer.call(this, input, this.data(), this.bind(this.onSelect), this.opts);
            if (input != null && input != undefined) {
                this.search.val(input);
                if (input.length > 0) {
                    this.open();
                }
            }

        },

        // multi
        onSelect: function (data, options) {

            if (!this.triggerSelect(data) || data.text === "") { return; }

            this.addSelectedChoice(data);

            this.opts.element.trigger({ type: "selected", val: this.id(data), choice: data });

            // keep track of the search's value before it gets cleared
            this.nextSearchTerm = this.opts.nextSearchTerm(data, this.search.val());

            this.clearSearch();
            this.updateResults();

            if (this.select || !this.opts.closeOnSelect) this.postprocessResults(data, false, this.opts.closeOnSelect===true);

            if (this.opts.closeOnSelect) {
                this.close();
                this.search.width(10);
            } else {
                if (this.countSelectableResults()>0) {
                    this.search.width(10);
                    this.resizeSearch();
                    if (this.getMaximumSelectionSize() > 0 && this.val().length >= this.getMaximumSelectionSize()) {
                        // if we reached max selection size repaint the results so choices
                        // are replaced with the max selection reached message
                        this.updateResults(true);
                    } else {
                        // initializes search's value with nextSearchTerm and update search result
                        if(this.nextSearchTerm != undefined){
                            this.search.val(this.nextSearchTerm);
                            this.updateResults();
                            this.search.select();
                        }
                    }
                    this.positionDropdown();
                } else {
                    // if nothing left to select close
                    this.close();
                    this.search.width(10);
                }
            }

            // since its not possible to select an element that has already been
            // added we do not need to check if this is a new element before firing change
            this.triggerChange({ added: data });

            if (!options || !options.noFocus)
                this.focusSearch();
        },

        // multi
        cancel: function () {
            this.close();
            this.focusSearch();
        },

        addSelectedChoice: function (data) {
            var enableChoice = !data.locked,
                enabledItem = $(
                    "<li class='select2-search-choice'>" +
                    "    <div></div>" +
                    "    <a href='#' class='select2-search-choice-close' tabindex='-1'></a>" +
                    "</li>"),
                disabledItem = $(
                    "<li class='select2-search-choice select2-locked'>" +
                    "<div></div>" +
                    "</li>");
            var choice = enableChoice ? enabledItem : disabledItem,
                id = this.id(data),
                val = this.getVal(),
                formatted,
                cssClass;

            formatted=this.opts.formatSelection(data, choice.find("div"), this.opts.escapeMarkup);
            if (formatted != undefined) {
                choice.find("div").replaceWith($("<div></div>").html(formatted));
            }
            cssClass=this.opts.formatSelectionCssClass(data, choice.find("div"));
            if (cssClass != undefined) {
                choice.addClass(cssClass);
            }

            if(enableChoice){
              choice.find(".select2-search-choice-close")
                  .on("mousedown", killEvent)
                  .on("click dblclick", this.bind(function (e) {
                  if (!this.isInterfaceEnabled()) return;

                  this.unselect($(e.target));
                  this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
                  killEvent(e);
                  this.close();
                  this.focusSearch();
              })).on("focus", this.bind(function () {
                  if (!this.isInterfaceEnabled()) return;
                  this.container.addClass("select2-container-active");
                  this.dropdown.addClass("select2-drop-active");
              }));
            }

            choice.data("select2-data", data);
            choice.insertBefore(this.searchContainer);

            val.push(id);
            this.setVal(val);
        },

        // multi
        unselect: function (selected) {
            var val = this.getVal(),
                data,
                index;
            selected = selected.closest(".select2-search-choice");

            if (selected.length === 0) {
                throw "Invalid argument: " + selected + ". Must be .select2-search-choice";
            }

            data = selected.data("select2-data");

            if (!data) {
                // prevent a race condition when the 'x' is clicked really fast repeatedly the event can be queued
                // and invoked on an element already removed
                return;
            }

            var evt = $.Event("select2-removing");
            evt.val = this.id(data);
            evt.choice = data;
            this.opts.element.trigger(evt);

            if (evt.isDefaultPrevented()) {
                return false;
            }

            while((index = indexOf(this.id(data), val)) >= 0) {
                val.splice(index, 1);
                this.setVal(val);
                if (this.select) this.postprocessResults();
            }

            selected.remove();

            this.opts.element.trigger({ type: "select2-removed", val: this.id(data), choice: data });
            this.triggerChange({ removed: data });

            return true;
        },

        // multi
        postprocessResults: function (data, initial, noHighlightUpdate) {
            var val = this.getVal(),
                choices = this.results.find(".select2-result"),
                compound = this.results.find(".select2-result-with-children"),
                self = this;

            choices.each2(function (i, choice) {
                var id = self.id(choice.data("select2-data"));
                if (indexOf(id, val) >= 0) {
                    choice.addClass("select2-selected");
                    // mark all children of the selected parent as selected
                    choice.find(".select2-result-selectable").addClass("select2-selected");
                }
            });

            compound.each2(function(i, choice) {
                // hide an optgroup if it doesn't have any selectable children
                if (!choice.is('.select2-result-selectable')
                    && choice.find(".select2-result-selectable:not(.select2-selected)").length === 0) {
                    choice.addClass("select2-selected");
                }
            });

            if (this.highlight() == -1 && noHighlightUpdate !== false && this.opts.closeOnSelect === true){
                self.highlight(0);
            }

            //If all results are chosen render formatNoMatches
            if(!this.opts.createSearchChoice && !choices.filter('.select2-result:not(.select2-selected)').length > 0){
                if(!data || data && !data.more && this.results.find(".select2-no-results").length === 0) {
                    if (checkFormatter(self.opts.formatNoMatches, "formatNoMatches")) {
                        this.results.append("<li class='select2-no-results'>" + evaluate(self.opts.formatNoMatches, self.opts.element, self.search.val()) + "</li>");
                    }
                }
            }

        },

        // multi
        getMaxSearchWidth: function() {
            return this.selection.width() - getSideBorderPadding(this.search);
        },

        // multi
        resizeSearch: function () {
            var minimumWidth, left, maxWidth, containerLeft, searchWidth,
                sideBorderPadding = getSideBorderPadding(this.search);

            minimumWidth = measureTextWidth(this.search) + 10;

            left = this.search.offset().left;

            maxWidth = this.selection.width();
            containerLeft = this.selection.offset().left;

            searchWidth = maxWidth - (left - containerLeft) - sideBorderPadding;

            if (searchWidth < minimumWidth) {
                searchWidth = maxWidth - sideBorderPadding;
            }

            if (searchWidth < 40) {
                searchWidth = maxWidth - sideBorderPadding;
            }

            if (searchWidth <= 0) {
              searchWidth = minimumWidth;
            }

            this.search.width(Math.floor(searchWidth));
        },

        // multi
        getVal: function () {
            var val;
            if (this.select) {
                val = this.select.val();
                return val === null ? [] : val;
            } else {
                val = this.opts.element.val();
                return splitVal(val, this.opts.separator, this.opts.transformVal);
            }
        },

        // multi
        setVal: function (val) {
            var unique;
            if (this.select) {
                this.select.val(val);
            } else {
                unique = [];
                // filter out duplicates
                $(val).each(function () {
                    if (indexOf(this, unique) < 0) unique.push(this);
                });
                this.opts.element.val(unique.length === 0 ? "" : unique.join(this.opts.separator));
            }
        },

        // multi
        buildChangeDetails: function (old, current) {
            var current = current.slice(0),
                old = old.slice(0);

            // remove intersection from each array
            for (var i = 0; i < current.length; i++) {
                for (var j = 0; j < old.length; j++) {
                    if (equal(this.opts.id(current[i]), this.opts.id(old[j]))) {
                        current.splice(i, 1);
                        if(i>0){
                            i--;
                        }
                        old.splice(j, 1);
                        j--;
                    }
                }
            }

            return {added: current, removed: old};
        },


        // multi
        val: function (val, triggerChange) {
            var oldData, self=this;

            if (arguments.length === 0) {
                return this.getVal();
            }

            oldData=this.data();
            if (!oldData.length) oldData=[];

            // val is an id. !val is true for [undefined,null,'',0] - 0 is legal
            if (!val && val !== 0) {
                this.opts.element.val("");
                this.updateSelection([]);
                this.clearSearch();
                if (triggerChange) {
                    this.triggerChange({added: this.data(), removed: oldData});
                }
                return;
            }

            // val is a list of ids
            this.setVal(val);

            if (this.select) {
                this.opts.initSelection(this.select, this.bind(this.updateSelection));
                if (triggerChange) {
                    this.triggerChange(this.buildChangeDetails(oldData, this.data()));
                }
            } else {
                if (this.opts.initSelection === undefined) {
                    throw new Error("val() cannot be called if initSelection() is not defined");
                }

                this.opts.initSelection(this.opts.element, function(data){
                    var ids=$.map(data, self.id);
                    self.setVal(ids);
                    self.updateSelection(data);
                    self.clearSearch();
                    if (triggerChange) {
                        self.triggerChange(self.buildChangeDetails(oldData, self.data()));
                    }
                });
            }
            this.clearSearch();
        },

        // multi
        onSortStart: function() {
            if (this.select) {
                throw new Error("Sorting of elements is not supported when attached to <select>. Attach to <input type='hidden'/> instead.");
            }

            // collapse search field into 0 width so its container can be collapsed as well
            this.search.width(0);
            // hide the container
            this.searchContainer.hide();
        },

        // multi
        onSortEnd:function() {

            var val=[], self=this;

            // show search and move it to the end of the list
            this.searchContainer.show();
            // make sure the search container is the last item in the list
            this.searchContainer.appendTo(this.searchContainer.parent());
            // since we collapsed the width in dragStarted, we resize it here
            this.resizeSearch();

            // update selection
            this.selection.find(".select2-search-choice").each(function() {
                val.push(self.opts.id($(this).data("select2-data")));
            });
            this.setVal(val);
            this.triggerChange();
        },

        // multi
        data: function(values, triggerChange) {
            var self=this, ids, old;
            if (arguments.length === 0) {
                 return this.selection
                     .children(".select2-search-choice")
                     .map(function() { return $(this).data("select2-data"); })
                     .get();
            } else {
                old = this.data();
                if (!values) { values = []; }
                ids = $.map(values, function(e) { return self.opts.id(e); });
                this.setVal(ids);
                this.updateSelection(values);
                this.clearSearch();
                if (triggerChange) {
                    this.triggerChange(this.buildChangeDetails(old, this.data()));
                }
            }
        }
    });

    $.fn.select2 = function () {

        var args = Array.prototype.slice.call(arguments, 0),
            opts,
            select2,
            method, value, multiple,
            allowedMethods = ["val", "destroy", "opened", "open", "close", "focus", "isFocused", "container", "dropdown", "onSortStart", "onSortEnd", "enable", "disable", "readonly", "positionDropdown", "data", "search"],
            valueMethods = ["opened", "isFocused", "container", "dropdown"],
            propertyMethods = ["val", "data"],
            methodsMap = { search: "externalSearch" };

        this.each(function () {
            if (args.length === 0 || typeof(args[0]) === "object") {
                opts = args.length === 0 ? {} : $.extend({}, args[0]);
                opts.element = $(this);

                if (opts.element.get(0).tagName.toLowerCase() === "select") {
                    multiple = opts.element.prop("multiple");
                } else {
                    multiple = opts.multiple || false;
                    if ("tags" in opts) {opts.multiple = multiple = true;}
                }

                select2 = multiple ? new window.Select2["class"].multi() : new window.Select2["class"].single();
                select2.init(opts);
            } else if (typeof(args[0]) === "string") {

                if (indexOf(args[0], allowedMethods) < 0) {
                    throw "Unknown method: " + args[0];
                }

                value = undefined;
                select2 = $(this).data("select2");
                if (select2 === undefined) return;

                method=args[0];

                if (method === "container") {
                    value = select2.container;
                } else if (method === "dropdown") {
                    value = select2.dropdown;
                } else {
                    if (methodsMap[method]) method = methodsMap[method];

                    value = select2[method].apply(select2, args.slice(1));
                }
                if (indexOf(args[0], valueMethods) >= 0
                    || (indexOf(args[0], propertyMethods) >= 0 && args.length == 1)) {
                    return false; // abort the iteration, ready to return first matched value
                }
            } else {
                throw "Invalid arguments to select2 plugin: " + args;
            }
        });
        return (value === undefined) ? this : value;
    };

    // plugin defaults, accessible to users
    $.fn.select2.defaults = {
        width: "copy",
        loadMorePadding: 0,
        closeOnSelect: true,
        openOnEnter: true,
        containerCss: {},
        dropdownCss: {},
        containerCssClass: "",
        dropdownCssClass: "",
        formatResult: function(result, container, query, escapeMarkup) {
            var markup=[];
            markMatch(this.text(result), query.term, markup, escapeMarkup);
            return markup.join("");
        },
        transformVal: function(val) {
            return $.trim(val);
        },
        formatSelection: function (data, container, escapeMarkup) {
            return data ? escapeMarkup(this.text(data)) : undefined;
        },
        sortResults: function (results, container, query) {
            return results;
        },
        formatResultCssClass: function(data) {return data.css;},
        formatSelectionCssClass: function(data, container) {return undefined;},
        minimumResultsForSearch: 0,
        minimumInputLength: 0,
        maximumInputLength: null,
        maximumSelectionSize: 0,
        id: function (e) { return e == undefined ? null : e.id; },
        text: function (e) {
          if (e && this.data && this.data.text) {
            if ($.isFunction(this.data.text)) {
              return this.data.text(e);
            } else {
              return e[this.data.text];
            }
          } else {
            return e.text;
          }
        },
        matcher: function(term, text) {
            return stripDiacritics(''+text).toUpperCase().indexOf(stripDiacritics(''+term).toUpperCase()) >= 0;
        },
        separator: ",",
        tokenSeparators: [],
        tokenizer: defaultTokenizer,
        escapeMarkup: defaultEscapeMarkup,
        blurOnChange: false,
        selectOnBlur: false,
        adaptContainerCssClass: function(c) { return c; },
        adaptDropdownCssClass: function(c) { return null; },
        nextSearchTerm: function(selectedObject, currentSearchTerm) { return undefined; },
        searchInputPlaceholder: '',
        createSearchChoicePosition: 'top',
        shouldFocusInput: function (instance) {
            // Attempt to detect touch devices
            var supportsTouchEvents = (('ontouchstart' in window) ||
                                       (navigator.msMaxTouchPoints > 0));

            // Only devices which support touch events should be special cased
            if (!supportsTouchEvents) {
                return true;
            }

            // Never focus the input if search is disabled
            if (instance.opts.minimumResultsForSearch < 0) {
                return false;
            }

            return true;
        }
    };

    $.fn.select2.locales = [];

    $.fn.select2.locales['en'] = {
         formatMatches: function (matches) { if (matches === 1) { return "One result is available, press enter to select it."; } return matches + " results are available, use up and down arrow keys to navigate."; },
         formatNoMatches: function () { return "No matches found"; },
         formatAjaxError: function (jqXHR, textStatus, errorThrown) { return "Loading failed"; },
         formatInputTooShort: function (input, min) { var n = min - input.length; return "Please enter " + n + " or more character" + (n == 1 ? "" : "s"); },
         formatInputTooLong: function (input, max) { var n = input.length - max; return "Please delete " + n + " character" + (n == 1 ? "" : "s"); },
         formatSelectionTooBig: function (limit) { return "You can only select " + limit + " item" + (limit == 1 ? "" : "s"); },
         formatLoadMore: function (pageNumber) { return "Loading more results…"; },
         formatSearching: function () { return "Searching…"; }
    };

    $.extend($.fn.select2.defaults, $.fn.select2.locales['en']);

    $.fn.select2.ajaxDefaults = {
        transport: $.ajax,
        params: {
            type: "GET",
            cache: false,
            dataType: "json"
        }
    };

    // exports
    window.Select2 = {
        query: {
            ajax: ajax,
            local: local,
            tags: tags
        }, util: {
            debounce: debounce,
            markMatch: markMatch,
            escapeMarkup: defaultEscapeMarkup,
            stripDiacritics: stripDiacritics
        }, "class": {
            "abstract": AbstractSelect2,
            "single": SingleSelect2,
            "multi": MultiSelect2
        }
    };

}(jQuery));

},{}],158:[function(require,module,exports){
/************************
jquery-timepicker v1.2.15
http://jonthornton.github.com/jquery-timepicker/

requires jQuery 1.7+
************************/


(function (factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['jquery'], factory);
	} else {
		// Browser globals
		factory(jQuery);
	}
}(function ($) {
	var _baseDate = _generateBaseDate();
	var _ONE_DAY = 86400;
	var _defaults =	{
		className: null,
		minTime: null,
		maxTime: null,
		durationTime: null,
		step: 30,
		showDuration: false,
		timeFormat: 'g:ia',
		scrollDefaultNow: false,
		scrollDefaultTime: false,
		selectOnBlur: false,
		disableTouchKeyboard: false,
		forceRoundTime: false,
		appendTo: 'body',
		disableTimeRanges: [],
		closeOnWindowScroll: false,
		disableTextInput: false,
		typeaheadHighlight: true
	};
	var _lang = {
		decimal: '.',
		mins: 'mins',
		hr: 'hr',
		hrs: 'hrs'
	};

	var methods =
	{
		init: function(options)
		{
			return this.each(function()
			{
				var self = $(this);

				// convert dropdowns to text input
				if (self[0].tagName == 'SELECT') {
					var attrs = { 'type': 'text', 'value': self.val() };
					var raw_attrs = self[0].attributes;

					for (var i=0; i < raw_attrs.length; i++) {
						attrs[raw_attrs[i].nodeName] = raw_attrs[i].nodeValue;
					}

					var input = $('<input />', attrs);
					self.replaceWith(input);
					self = input;
				}

				var settings = $.extend({}, _defaults);

				if (options) {
					settings = $.extend(settings, options);
				}

				if (settings.lang) {
					_lang = $.extend(_lang, settings.lang);
				}

				settings = _parseSettings(settings);

				self.data('timepicker-settings', settings);
				self.prop('autocomplete', 'off');
				self.on('click.timepicker focus.timepicker', methods.show);
				self.on('change.timepicker', _formatValue);
				self.on('keydown.timepicker', _keydownhandler);
				self.on('keyup.timepicker', _keyuphandler);
				self.addClass('ui-timepicker-input');

				_formatValue.call(self.get(0));
			});
		},

		show: function(e)
		{
			e.preventDefault();

			var self = $(this);
			var settings = self.data('timepicker-settings');

			if (_hideKeyboard(self)) {
				// block the keyboard on mobile devices
				self.blur();
			}

			var list = self.data('timepicker-list');

			// check if input is readonly
			if (self.prop('readonly')) {
				return;
			}

			// check if list needs to be rendered
			if (!list || list.length === 0 || typeof settings.durationTime === 'function') {
				_render(self);
				list = self.data('timepicker-list');
			}

			if (list.is(':visible')) {
				return;
			}

			// make sure other pickers are hidden
			methods.hide();

			list.show();

			if ((self.offset().top + self.outerHeight(true) + list.outerHeight()) > $(window).height() + $(window).scrollTop()) {
				// position the dropdown on top
				list.offset({
					'left': self.offset().left + parseInt(list.css('marginLeft').replace('px', ''), 10),
					'top': self.offset().top - list.outerHeight() + parseInt(list.css('marginTop').replace('px', ''), 10)
				});
			} else {
				// put it under the input
				list.offset({
					'left':self.offset().left + parseInt(list.css('marginLeft').replace('px', ''), 10),
					'top': self.offset().top + self.outerHeight() + parseInt(list.css('marginTop').replace('px', ''), 10)
				});
			}

			// position scrolling
			var selected = list.find('.ui-timepicker-selected');

			if (!selected.length) {
				if (_getTimeValue(self)) {
					selected = _findRow(self, list, _time2int(_getTimeValue(self)));
				} else if (settings.scrollDefaultNow) {
					selected = _findRow(self, list, _time2int(new Date()));
				} else if (settings.scrollDefaultTime !== false) {
					selected = _findRow(self, list, _time2int(settings.scrollDefaultTime));
				}
			}

			if (selected && selected.length) {
				var topOffset = list.scrollTop() + selected.position().top - selected.outerHeight();
				list.scrollTop(topOffset);
			} else {
				list.scrollTop(0);
			}

			// attach close handlers
			$('body').on('touchstart.ui-timepicker mousedown.ui-timepicker', _closeHandler);
			if (settings.closeOnWindowScroll) {
				$(window).on('scroll.ui-timepicker', _closeHandler);
			}

			self.trigger('showTimepicker');
		},

		hide: function(e)
		{
			$('.ui-timepicker-wrapper:visible').each(function() {
				var list = $(this);
				var self = list.data('timepicker-input');
				var settings = self.data('timepicker-settings');

				if (settings && settings.selectOnBlur) {
					_selectValue(self);
				}

				list.hide();
				self.trigger('hideTimepicker');
			});
		},

		option: function(key, value)
		{
			var self = this;
			var settings = self.data('timepicker-settings');
			var list = self.data('timepicker-list');

			if (typeof key == 'object') {
				settings = $.extend(settings, key);

			} else if (typeof key == 'string' && typeof value != 'undefined') {
				settings[key] = value;

			} else if (typeof key == 'string') {
				return settings[key];
			}

			settings = _parseSettings(settings);

			self.data('timepicker-settings', settings);

			if (list) {
				list.remove();
				self.data('timepicker-list', false);
			}

			return self;
		},

		getSecondsFromMidnight: function()
		{
			return _time2int(_getTimeValue(this));
		},

		getTime: function(relative_date)
		{
			var self = this;

			var time_string = _getTimeValue(self);
			if (!time_string) {
				return null;
			}

			if (!relative_date) {
				relative_date = new Date();
			}

			relative_date.setHours(0, 0, 0, 0);
			return new Date(relative_date.valueOf() + (_time2int(time_string)*1000));
		},

		setTime: function(value)
		{
			var self = this;
			var prettyTime = _int2time(_time2int(value), self.data('timepicker-settings').timeFormat);

			_setTimeValue(self, prettyTime);
			if (self.data('timepicker-list')) {
				_setSelected(self, self.data('timepicker-list'));
			}
		},

		remove: function()
		{
			var self = this;

			// check if this element is a timepicker
			if (!self.hasClass('ui-timepicker-input')) {
				return;
			}

			self.removeAttr('autocomplete', 'off');
			self.removeClass('ui-timepicker-input');
			self.removeData('timepicker-settings');
			self.off('.timepicker');

			// timepicker-list won't be present unless the user has interacted with this timepicker
			if (self.data('timepicker-list')) {
				self.data('timepicker-list').remove();
			}

			self.removeData('timepicker-list');
		}
	};

	// private methods

	function _parseSettings(settings)
	{
		if (settings.minTime) {
			settings.minTime = _time2int(settings.minTime);
		}

		if (settings.maxTime) {
			settings.maxTime = _time2int(settings.maxTime);
		}

		if (settings.durationTime && typeof settings.durationTime !== 'function') {
			settings.durationTime = _time2int(settings.durationTime);
		}

		if (settings.disableTimeRanges.length > 0) {
			// convert string times to integers
			for (var i in settings.disableTimeRanges) {
				settings.disableTimeRanges[i] = [
					_time2int(settings.disableTimeRanges[i][0]),
					_time2int(settings.disableTimeRanges[i][1])
				];
			}

			// sort by starting time
			settings.disableTimeRanges = settings.disableTimeRanges.sort(function(a, b){
				return a[0] - b[0];
			});

			// merge any overlapping ranges
			for (var i = settings.disableTimeRanges.length-1; i > 0; i--) {
				if (settings.disableTimeRanges[i][0] <= settings.disableTimeRanges[i-1][1]) {
					settings.disableTimeRanges[i-1] = [
						Math.min(settings.disableTimeRanges[i][0], settings.disableTimeRanges[i-1][0]),
						Math.max(settings.disableTimeRanges[i][1], settings.disableTimeRanges[i-1][1])
					];
					settings.disableTimeRanges.splice(i, 1);
				}
			}
		}

		return settings;
	}

	function _render(self)
	{
		var settings = self.data('timepicker-settings');
		var list = self.data('timepicker-list');

		if (list && list.length) {
			list.remove();
			self.data('timepicker-list', false);
		}

		list = $('<ul />', { 'class': 'ui-timepicker-list' });

		var wrapped_list = $('<div />', { 'class': 'ui-timepicker-wrapper', 'tabindex': -1 });
		wrapped_list.css({'display':'none', 'position': 'absolute' }).append(list);


		if (settings.className) {
			wrapped_list.addClass(settings.className);
		}

		if ((settings.minTime !== null || settings.durationTime !== null) && settings.showDuration) {
			wrapped_list.addClass('ui-timepicker-with-duration');
		}

		var durStart = settings.minTime;
		if (typeof settings.durationTime === 'function') {
			durStart = _time2int(settings.durationTime());
		} else if (settings.durationTime !== null) {
			durStart = settings.durationTime;
		}
		var start = (settings.minTime !== null) ? settings.minTime : 0;
		var end = (settings.maxTime !== null) ? settings.maxTime : (start + _ONE_DAY - 1);

		if (end <= start) {
			// make sure the end time is greater than start time, otherwise there will be no list to show
			end += _ONE_DAY;
		}

		if (end === _ONE_DAY-1 && settings.timeFormat.indexOf('H') !== -1) {
			// show a 24:00 option when using military time
			end = _ONE_DAY;
		}

		var dr = settings.disableTimeRanges;
		var drCur = 0;
		var drLen = dr.length;

		for (var i=start; i <= end; i += settings.step*60) {
			var timeInt = i;

			var row = $('<li />');
			row.data('time', (timeInt <= 86400 ? timeInt : timeInt % 86400));
			row.text(_int2time(timeInt, settings.timeFormat));

			if ((settings.minTime !== null || settings.durationTime !== null) && settings.showDuration) {
				var duration = $('<span />');
				duration.addClass('ui-timepicker-duration');
				duration.text(' ('+_int2duration(i - durStart)+')');
				row.append(duration);
			}

			if (drCur < drLen) {
				if (timeInt >= dr[drCur][1]) {
					drCur += 1;
				}

				if (dr[drCur] && timeInt >= dr[drCur][0] && timeInt < dr[drCur][1]) {
					row.addClass('ui-timepicker-disabled');
				}
			}

			list.append(row);
		}

		wrapped_list.data('timepicker-input', self);
		self.data('timepicker-list', wrapped_list);

		var appendTo = settings.appendTo;
		if (typeof appendTo === 'string') {
			appendTo = $(appendTo);
		} else if (typeof appendTo === 'function') {
			appendTo = appendTo(self);
		}
		appendTo.append(wrapped_list);
		_setSelected(self, list);

		list.on('click', 'li', function(e) {

			// hack: temporarily disable the focus handler
			// to deal with the fact that IE fires 'focus'
			// events asynchronously
			self.off('focus.timepicker');
			self.on('focus.timepicker-ie-hack', function(){
				self.off('focus.timepicker-ie-hack');
				self.on('focus.timepicker', methods.show);
			});

			if (!_hideKeyboard(self)) {
				self[0].focus();
			}

			// make sure only the clicked row is selected
			list.find('li').removeClass('ui-timepicker-selected');
			$(this).addClass('ui-timepicker-selected');

			if (_selectValue(self)) {
				self.trigger('hideTimepicker');
				wrapped_list.hide();
			}
		});
	}

	function _generateBaseDate()
	{
		return new Date(1970, 1, 1, 0, 0, 0);
	}

	// event handler to decide whether to close timepicker
	function _closeHandler(e)
	{
		var target = $(e.target);
		var input = target.closest('.ui-timepicker-input');
		if (input.length === 0 && target.closest('.ui-timepicker-wrapper').length === 0) {
			methods.hide();
			$('body').unbind('.ui-timepicker');
			$(window).unbind('.ui-timepicker');
		}
	}

	function _hideKeyboard(self)
	{
		var settings = self.data('timepicker-settings');
		return ((window.navigator.msMaxTouchPoints || 'ontouchstart' in document) && settings.disableTouchKeyboard);
	}

	function _findRow(self, list, value)
	{
		if (!value && value !== 0) {
			return false;
		}

		var settings = self.data('timepicker-settings');
		var out = false;
		var halfStep = settings.step*30;

		// loop through the menu items
		list.find('li').each(function(i, obj) {
			var jObj = $(obj);

			var offset = jObj.data('time') - value;

			// check if the value is less than half a step from each row
			if (Math.abs(offset) < halfStep || offset == halfStep) {
				out = jObj;
				return false;
			}
		});

		return out;
	}

	function _setSelected(self, list)
	{
		list.find('li').removeClass('ui-timepicker-selected');

		var timeValue = _time2int(_getTimeValue(self));
		if (timeValue === null) {
			return;
		}

		var selected = _findRow(self, list, timeValue);
		if (selected) {

			var topDelta = selected.offset().top - list.offset().top;

			if (topDelta + selected.outerHeight() > list.outerHeight() || topDelta < 0) {
				list.scrollTop(list.scrollTop() + selected.position().top - selected.outerHeight());
			}

			selected.addClass('ui-timepicker-selected');
		}
	}


	function _formatValue()
	{
		if (this.value === '') {
			return;
		}

		var self = $(this);
		var list = self.data('timepicker-list');

		if (list && list.is(':visible')) {
			return;
		}

		var seconds = _time2int(this.value);

		if (seconds === null) {
			self.trigger('timeFormatError');
			return;
		}

		var settings = self.data('timepicker-settings');
		var rangeError = false;
		// check that the time in within bounds
		if (settings.minTime !== null && seconds < settings.minTime) {
			rangeError = true;
		} else if (settings.maxTime !== null && seconds > settings.maxTime) {
			rangeError = true;
		}

		// check that time isn't within disabled time ranges
		$.each(settings.disableTimeRanges, function(){
			if (seconds >= this[0] && seconds < this[1]) {
				rangeError = true;
				return false;
			}
		});

		if (settings.forceRoundTime) {
			var offset = seconds % (settings.step*60); // step is in minutes

			if (offset >= settings.step*30) {
				// if offset is larger than a half step, round up
				seconds += (settings.step*60) - offset;
			} else {
				// round down
				seconds -= offset;
			}
		}

		var prettyTime = _int2time(seconds, settings.timeFormat);

		if (rangeError) {
			if (_setTimeValue(self, prettyTime, 'error')) {
				self.trigger('timeRangeError');
			}
		} else {
			_setTimeValue(self, prettyTime);
		}
	}

	function _getTimeValue(self)
	{
		if (self.is('input')) {
			return self.val();
		} else {
			// use the element's data attributes to store values
			return self.data('ui-timepicker-value');
		}
	}

	function _setTimeValue(self, value, source)
	{
		if (self.is('input')) {
			self.val(value);
		}

		if (self.data('ui-timepicker-value') != value) {
			self.data('ui-timepicker-value', value);
			if (source == 'select') {
				self.trigger('selectTime').trigger('changeTime').trigger('change');
			} else if (source != 'error') {
				self.trigger('changeTime');
			}

			return true;
		} else {
			self.trigger('selectTime');
			return false;
		}
	}

	/*
	*  Keyboard navigation via arrow keys
	*/
	function _keydownhandler(e)
	{
		var self = $(this);
		var list = self.data('timepicker-list');

		if (!list || !list.is(':visible')) {
			if (e.keyCode == 40) {
				if (!_hideKeyboard(self)) {
					self.focus();
				}
			} else {
				return _screenInput(e, self);
			}
		}

		switch (e.keyCode) {

			case 13: // return
				if (_selectValue(self)) {
					methods.hide.apply(this);
				}

				e.preventDefault();
				return false;

			case 38: // up
				var selected = list.find('.ui-timepicker-selected');

				if (!selected.length) {
					list.find('li').each(function(i, obj) {
						if ($(obj).position().top > 0) {
							selected = $(obj);
							return false;
						}
					});
					selected.addClass('ui-timepicker-selected');

				} else if (!selected.is(':first-child')) {
					selected.removeClass('ui-timepicker-selected');
					selected.prev().addClass('ui-timepicker-selected');

					if (selected.prev().position().top < selected.outerHeight()) {
						list.scrollTop(list.scrollTop() - selected.outerHeight());
					}
				}

				return false;

			case 40: // down
				selected = list.find('.ui-timepicker-selected');

				if (selected.length === 0) {
					list.find('li').each(function(i, obj) {
						if ($(obj).position().top > 0) {
							selected = $(obj);
							return false;
						}
					});

					selected.addClass('ui-timepicker-selected');
				} else if (!selected.is(':last-child')) {
					selected.removeClass('ui-timepicker-selected');
					selected.next().addClass('ui-timepicker-selected');

					if (selected.next().position().top + 2*selected.outerHeight() > list.outerHeight()) {
						list.scrollTop(list.scrollTop() + selected.outerHeight());
					}
				}

				return false;

			case 27: // escape
				list.find('li').removeClass('ui-timepicker-selected');
				methods.hide();
				break;

			case 9: //tab
				methods.hide();
				break;

			default:
				return _screenInput(e, self);
		}
	}

	function _screenInput(e, self)
	{
		return !self.data('timepicker-settings').disableTextInput || e.ctrlKey || e.altKey || e.metaKey || (e.keyCode != 2 && e.keyCode != 8 && e.keyCode < 46);
	}

	/*
	*	Time typeahead
	*/
	function _keyuphandler(e)
	{
		var self = $(this);
		var list = self.data('timepicker-list');

		if (!list || !list.is(':visible')) {
			return true;
		}

		if (!self.data('timepicker-settings').typeaheadHighlight) {
			list.find('li').removeClass('ui-timepicker-selected');
			return true;
		}

		switch (e.keyCode) {

			case 96: // numpad numerals
			case 97:
			case 98:
			case 99:
			case 100:
			case 101:
			case 102:
			case 103:
			case 104:
			case 105:
			case 48: // numerals
			case 49:
			case 50:
			case 51:
			case 52:
			case 53:
			case 54:
			case 55:
			case 56:
			case 57:
			case 65: // a
			case 77: // m
			case 80: // p
			case 186: // colon
			case 8: // backspace
			case 46: // delete
				_setSelected(self, list);
				break;

			default:
				// list.find('li').removeClass('ui-timepicker-selected');
				return;
		}
	}

	function _selectValue(self)
	{
		var settings = self.data('timepicker-settings');
		var list = self.data('timepicker-list');
		var timeValue = null;

		var cursor = list.find('.ui-timepicker-selected');

		if (cursor.hasClass('ui-timepicker-disabled')) {
			return false;
		}

		if (cursor.length) {
			// selected value found
			timeValue = cursor.data('time');

		} else if (_getTimeValue(self)) {

			// no selected value; fall back on input value
			timeValue = _time2int(_getTimeValue(self));

			_setSelected(self, list);
		}

		if (timeValue !== null) {
			var timeString = _int2time(timeValue, settings.timeFormat);
			_setTimeValue(self, timeString, 'select');
		}

		//self.trigger('change').trigger('selectTime');
		return true;
	}

	function _int2duration(seconds)
	{
		var minutes = Math.round(seconds/60);
		var duration;

		if (Math.abs(minutes) < 60) {
			duration = [minutes, _lang.mins];
		} else if (minutes == 60) {
			duration = ['1', _lang.hr];
		} else {
			var hours = (minutes/60).toFixed(1);
			if (_lang.decimal != '.') hours = hours.replace('.', _lang.decimal);
			duration = [hours, _lang.hrs];
		}

		return duration.join(' ');
	}

	function _int2time(seconds, format)
	{
		if (seconds === null) {
			return;
		}

		var time = new Date(_baseDate.valueOf() + (seconds*1000));
		var output = '';
		var hour, code;

		for (var i=0; i<format.length; i++) {

			code = format.charAt(i);
			switch (code) {

				case 'a':
					output += (time.getHours() > 11) ? 'pm' : 'am';
					break;

				case 'A':
					output += (time.getHours() > 11) ? 'PM' : 'AM';
					break;

				case 'g':
					hour = time.getHours() % 12;
					output += (hour === 0) ? '12' : hour;
					break;

				case 'G':
					output += time.getHours();
					break;

				case 'h':
					hour = time.getHours() % 12;

					if (hour !== 0 && hour < 10) {
						hour = '0'+hour;
					}

					output += (hour === 0) ? '12' : hour;
					break;

				case 'H':
					hour = time.getHours();
					if (seconds === _ONE_DAY) hour = 24;
					output += (hour > 9) ? hour : '0'+hour;
					break;

				case 'i':
					var minutes = time.getMinutes();
					output += (minutes > 9) ? minutes : '0'+minutes;
					break;

				case 's':
					seconds = time.getSeconds();
					output += (seconds > 9) ? seconds : '0'+seconds;
					break;

				default:
					output += code;
			}
		}

		return output;
	}

	function _time2int(timeString)
	{
		if (timeString === '') return null;
		if (!timeString || timeString+0 == timeString) return timeString;

		if (typeof(timeString) == 'object') {
			timeString = timeString.getHours()+':'+_pad2(timeString.getMinutes())+':'+_pad2(timeString.getSeconds());
		}

		timeString = timeString.toLowerCase();

		var d = new Date(0);
		var time;

		// try to parse time input
		if (timeString.indexOf(":") === -1) {
			// no colon present
			time = timeString.match(/^([0-9]):?([0-5][0-9])?:?([0-5][0-9])?\s*([pa]?)m?$/);

			if (!time) {
				time = timeString.match(/^([0-2][0-9]):?([0-5][0-9])?:?([0-5][0-9])?\s*([pa]?)m?$/);
			}
		} else {
			time = timeString.match(/^(\d{1,2})(?::([0-5][0-9]))?(?::([0-5][0-9]))?\s*([pa]?)m?$/);
		}

		if (!time) {
			return null;
		}

		var hour = parseInt(time[1]*1, 10);
		var hours;

		if (time[4]) {
			if (hour == 12) {
				hours = (time[4] == 'p') ? 12 : 0;
			} else {
				hours = (hour + (time[4] == 'p' ? 12 : 0));
			}

		} else {
			hours = hour;
		}

		var minutes = ( time[2]*1 || 0 );
		var seconds = ( time[3]*1 || 0 );
		return hours*3600 + minutes*60 + seconds;
	}

	function _pad2(n) {
		return ("0" + n).slice(-2);
	}

	// Plugin entry
	$.fn.timepicker = function(method)
	{
		if(methods[method]) { return methods[method].apply(this, Array.prototype.slice.call(arguments, 1)); }
		else if(typeof method === "object" || !method) { return methods.init.apply(this, arguments); }
		else { $.error("Method "+ method + " does not exist on jQuery.timepicker"); }
	};
}));

},{}],159:[function(require,module,exports){
//     Underscore.js 1.8.2
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.2';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var isArrayLike = function(collection) {
    var length = collection && collection.length;
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, target, fromIndex) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    return _.indexOf(obj, target, typeof fromIndex == 'number' && fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = input && input.length; i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (array == null) return [];
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = array.length; i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    if (array == null) return [];
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = array.length; i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, 'length').length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = list && list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    var i = 0, length = array && array.length;
    if (typeof isSorted == 'number') {
      i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;
    } else if (isSorted && length) {
      i = _.sortedIndex(array, item);
      return array[i] === item ? i : -1;
    }
    if (item !== item) {
      return _.findIndex(slice.call(array, i), _.isNaN);
    }
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  _.lastIndexOf = function(array, item, from) {
    var idx = array ? array.length : 0;
    if (typeof from == 'number') {
      idx = from < 0 ? idx + from + 1 : Math.min(idx, from + 1);
    }
    if (item !== item) {
      return _.findLastIndex(slice.call(array, 0, idx), _.isNaN);
    }
    while (--idx >= 0) if (array[idx] === item) return idx;
    return -1;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = array != null && array.length;
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createIndexFinder(1);

  _.findLastIndex = createIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    
    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of 
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
  
  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],"jquery":[function(require,module,exports){
module.exports = jQuery;

},{}]},{},[2])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwLXJ1bi5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHAuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9hZG1pbi9jb250cm9sbGVycy9hZG1pbl9tYWluX2NvbnRyb2xsZXIuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9hZG1pbi90ZW1wbGF0ZXMvYWRtaW5fZGFzaGJvYXJkX2FjdGl2aXRpZXMuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2FkbWluL3RlbXBsYXRlcy9hZG1pbl9kYXNoYm9hcmRfdGFibGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2FkbWluL3RlbXBsYXRlcy9hZG1pbl9kYXNoYm9hcmRfdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2FkbWluL3RlbXBsYXRlcy9hZG1pbl9tYWluX3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9hZG1pbi90ZW1wbGF0ZXMvYWRtaW5fcGFnaW5hdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2FkbWluL3RlbXBsYXRlcy9hZG1pbl90YWdfdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2FkbWluL3RlbXBsYXRlcy9hZG1pbl90YXNrX3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9hZG1pbi90ZW1wbGF0ZXMvYWRtaW5fdXNlcl9wYXNzd29yZC5odG1sIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvYWRtaW4vdGVtcGxhdGVzL2FkbWluX3VzZXJfdGFibGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2FkbWluL3RlbXBsYXRlcy9hZG1pbl91c2VyX3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9hZG1pbi92aWV3cy9hZG1pbl9kYXNoYm9hcmRfdmlldy5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2FkbWluL3ZpZXdzL2FkbWluX21haW5fdmlldy5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2FkbWluL3ZpZXdzL2FkbWluX3RhZ192aWV3LmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvYWRtaW4vdmlld3MvYWRtaW5fdGFza192aWV3LmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvYWRtaW4vdmlld3MvYWRtaW5fdXNlcl9wYXNzd29yZF92aWV3LmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvYWRtaW4vdmlld3MvYWRtaW5fdXNlcl92aWV3LmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvYXBwc19yb3V0ZXIuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9hdHRhY2htZW50L3RlbXBsYXRlcy9hdHRhY2htZW50X2l0ZW1fdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2F0dGFjaG1lbnQvdGVtcGxhdGVzL2F0dGFjaG1lbnRfc2hvd190ZW1wbGF0ZS5odG1sIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvYXR0YWNobWVudC92aWV3cy9hdHRhY2htZW50X3Nob3dfdmlldy5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2Jyb3dzZS9icm93c2VfYXBwLmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvYnJvd3NlL2NvbnRyb2xsZXJzL2Jyb3dzZV9saXN0X2NvbnRyb2xsZXIuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9icm93c2UvdGVtcGxhdGVzL2Jyb3dzZV9tYWluX3ZpZXdfdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2Jyb3dzZS90ZW1wbGF0ZXMvYnJvd3NlX3NlYXJjaF90YWcuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2Jyb3dzZS90ZW1wbGF0ZXMvbm9fc2VhcmNoX3Jlc3VsdHMuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2Jyb3dzZS90ZW1wbGF0ZXMvcHJvamVjdF9saXN0X2l0ZW0uaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2Jyb3dzZS90ZW1wbGF0ZXMvdGFza19saXN0X2l0ZW0uaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2Jyb3dzZS92aWV3cy9icm93c2VfbGlzdF92aWV3LmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvYnJvd3NlL3ZpZXdzL2Jyb3dzZV9tYWluX3ZpZXcuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9jb21tZW50cy9saXN0L2NvbnRyb2xsZXJzL2NvbW1lbnRfbGlzdF9jb250cm9sbGVyLmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvY29tbWVudHMvbGlzdC90ZW1wbGF0ZXMvY29tbWVudF9pdGVtX3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9jb21tZW50cy9saXN0L3RlbXBsYXRlcy9jb21tZW50X3dyYXBwZXJfdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2NvbW1lbnRzL2xpc3Qvdmlld3MvY29tbWVudF9pdGVtX3ZpZXcuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9jb21tZW50cy9uZXcvdGVtcGxhdGVzL2NvbW1lbnRfYWNfdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2NvbW1lbnRzL25ldy90ZW1wbGF0ZXMvY29tbWVudF9mb3JtX3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9jb21tZW50cy9uZXcvdGVtcGxhdGVzL2NvbW1lbnRfaW5saW5lX3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9jb21tZW50cy9uZXcvdmlld3MvY29tbWVudF9mb3JtX3ZpZXcuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9ldmVudHMvbGlzdC9jb250cm9sbGVycy9ldmVudF9saXN0X2NvbnRyb2xsZXIuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9ldmVudHMvbGlzdC90ZW1wbGF0ZXMvZXZlbnRfY29sbGVjdGlvbl92aWV3X3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9ldmVudHMvbGlzdC92aWV3cy9ldmVudF9jb2xsZWN0aW9uX3ZpZXcuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9ldmVudHMvbmV3L3RlbXBsYXRlcy9ldmVudF9mb3JtX3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9ldmVudHMvbmV3L3ZpZXdzL2V2ZW50X2Zvcm1fdmlldy5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2Zvb3Rlci90ZW1wbGF0ZXMvZm9vdGVyX3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9mb290ZXIvdmlld3MvZm9vdGVyX3ZpZXcuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9ob21lL2NvbnRyb2xsZXJzL2hvbWVfY29udHJvbGxlci5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2hvbWUvdGVtcGxhdGVzL2hvbWVfdmlld190ZW1wbGF0ZS5odG1sIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvaG9tZS92aWV3cy9ob21lX3ZpZXcuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9sb2dpbi9jb250cm9sbGVycy9sb2dpbl9jb250cm9sbGVyLmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvbG9naW4vdGVtcGxhdGVzL2xvZ2luX3Bhc3N3b3JkX3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9sb2dpbi90ZW1wbGF0ZXMvbG9naW5fdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL2xvZ2luL3ZpZXdzL2xvZ2luX3Bhc3N3b3JkX3ZpZXcuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9sb2dpbi92aWV3cy9sb2dpbl92aWV3LmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvbmF2L3RlbXBsYXRlcy9uYXZfdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL25hdi92aWV3cy9uYXZfdmlldy5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3Byb2ZpbGVzL2VtYWlsL3RlbXBsYXRlcy9wcm9maWxlX2VtYWlsX2Zvcm0uaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3Byb2ZpbGVzL2VtYWlsL3ZpZXdzL3Byb2ZpbGVfZW1haWxfdmlldy5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3Byb2ZpbGVzL3Nob3cvY29udHJvbGxlcnMvcHJvZmlsZV9zaG93X2NvbnRyb2xsZXIuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9wcm9maWxlcy9zaG93L3RlbXBsYXRlcy9wcm9maWxlX2FjdGl2aXR5X3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9wcm9maWxlcy9zaG93L3RlbXBsYXRlcy9wcm9maWxlX2VtYWlsX3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9wcm9maWxlcy9zaG93L3RlbXBsYXRlcy9wcm9maWxlX3Jlc2V0X3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9wcm9maWxlcy9zaG93L3RlbXBsYXRlcy9wcm9maWxlX3NldHRpbmdzX3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9wcm9maWxlcy9zaG93L3RlbXBsYXRlcy9wcm9maWxlX3Nob3dfdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3Byb2ZpbGVzL3Nob3cvdmlld3MvcHJvZmlsZV9hY3Rpdml0eV92aWV3LmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvcHJvZmlsZXMvc2hvdy92aWV3cy9wcm9maWxlX3Jlc2V0X3ZpZXcuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9wcm9maWxlcy9zaG93L3ZpZXdzL3Byb2ZpbGVfc2V0dGluZ3Nfdmlldy5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3Byb2ZpbGVzL3Nob3cvdmlld3MvcHJvZmlsZV9zaG93X3ZpZXcuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy9wcm9qZWN0L25ldy90ZW1wbGF0ZXMvcHJvamVjdF9uZXdfZm9ybV90ZW1wbGF0ZS5odG1sIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvcHJvamVjdC9uZXcvdmlld3MvcHJvamVjdF9uZXdfZm9ybV92aWV3LmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvcHJvamVjdC9zaG93L2NvbnRyb2xsZXJzL3Byb2plY3Rfc2hvd19jb250cm9sbGVyLmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvcHJvamVjdC9zaG93L3RlbXBsYXRlcy9wcm9qZWN0X2l0ZW1fY29yZW1ldGFfdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3Byb2plY3Qvc2hvdy90ZW1wbGF0ZXMvcHJvamVjdF9pdGVtX3ZpZXdfdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3Byb2plY3Qvc2hvdy90ZW1wbGF0ZXMvcHJvamVjdF9vcGVuX3Rhc2tzX3dhcm5pbmdfdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3Byb2plY3Qvc2hvdy92aWV3cy9wcm9qZWN0X2l0ZW1fY29yZW1ldGFfdmlldy5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3Byb2plY3Qvc2hvdy92aWV3cy9wcm9qZWN0X2l0ZW1fdmlldy5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3Byb2plY3Rvd25lci9zaG93L3RlbXBsYXRlcy9wcm9qZWN0b3duZXJfc2hvd190ZW1wbGF0ZS5odG1sIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvcHJvamVjdG93bmVyL3Nob3cvdmlld3MvcHJvamVjdG93bmVyX3Nob3dfdmlldy5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3RhZy9uZXcvdGVtcGxhdGVzL3RhZ19uZXdfZm9ybV90ZW1wbGF0ZS5odG1sIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvdGFnL25ldy92aWV3cy90YWdfbmV3X2Zvcm1fdmlldy5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3RhZy9zaG93L3RlbXBsYXRlcy90YWdfaXRlbV90ZW1wbGF0ZS5odG1sIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvdGFnL3Nob3cvdGVtcGxhdGVzL3RhZ19zaG93X3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy90YWcvc2hvdy92aWV3cy90YWdfc2hvd192aWV3LmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvdGFza3MvZWRpdC90ZW1wbGF0ZXMvdGFza19lZGl0X2Zvcm1fdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3Rhc2tzL2VkaXQvdGVtcGxhdGVzL3ZvbHVudGVlcl9lZGl0X2Zvcm1fdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3Rhc2tzL2VkaXQvdmlld3MvdGFza19lZGl0X2Zvcm1fdmlldy5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3Rhc2tzL2xpc3QvY29udHJvbGxlcnMvdGFza19saXN0X2NvbnRyb2xsZXIuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy90YXNrcy9saXN0L3RlbXBsYXRlcy90YXNrX2NvbGxlY3Rpb25fdmlld190ZW1wbGF0ZS5odG1sIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvdGFza3MvbGlzdC92aWV3cy90YXNrX2NvbGxlY3Rpb25fdmlldy5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3Rhc2tzL25ldy90ZW1wbGF0ZXMvdGFza19mb3JtX3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy90YXNrcy9uZXcvdmlld3MvdGFza19mb3JtX3ZpZXcuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy90YXNrcy9zaG93L2NvbnRyb2xsZXJzL3Rhc2tfc2hvd19jb250cm9sbGVyLmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvdGFza3Mvc2hvdy90ZW1wbGF0ZXMvY2hhbmdlX3N0YXRlX3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvYXBwcy90YXNrcy9zaG93L3RlbXBsYXRlcy90YXNrX3Nob3dfaXRlbV90ZW1wbGF0ZS5odG1sIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvdGFza3Mvc2hvdy90ZW1wbGF0ZXMvdXBkYXRlX25hbWVfdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3Rhc2tzL3Nob3cvdGVtcGxhdGVzL3ZvbHVudGVlcl9zdXBlcnZpc29yX25vdGlmeV90ZW1wbGF0ZS5odG1sIiwiYXNzZXRzL2pzL2JhY2tib25lL2FwcHMvdGFza3Mvc2hvdy90ZW1wbGF0ZXMvdm9sdW50ZWVyX3RleHRfdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9hcHBzL3Rhc2tzL3Nob3cvdmlld3MvdGFza19pdGVtX3ZpZXcuanMiLCJhc3NldHMvanMvYmFja2JvbmUvYmFzZS9iYXNlX2NvbXBvbmVudC5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9iYXNlL2Jhc2VfY29udHJvbGxlci5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9iYXNlL2Jhc2Vfdmlldy5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9jb21wb25lbnRzL2FsZXJ0X3RlbXBsYXRlLmh0bWwiLCJhc3NldHMvanMvYmFja2JvbmUvY29tcG9uZW50cy9tYXJrZG93bl9lZGl0b3IuanMiLCJhc3NldHMvanMvYmFja2JvbmUvY29tcG9uZW50cy9tYXJrZG93bl9lZGl0b3JfdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9jb21wb25lbnRzL21vZGFsLmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2NvbXBvbmVudHMvbW9kYWxfYWxlcnQuanMiLCJhc3NldHMvanMvYmFja2JvbmUvY29tcG9uZW50cy9tb2RhbF9hbGVydF90ZW1wbGF0ZS5odG1sIiwiYXNzZXRzL2pzL2JhY2tib25lL2NvbXBvbmVudHMvbW9kYWxfdGVtcGxhdGUuaHRtbCIsImFzc2V0cy9qcy9iYWNrYm9uZS9jb21wb25lbnRzL21vZGFsX3dpemFyZC5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9jb21wb25lbnRzL21vZGFsX3dpemFyZF90ZW1wbGF0ZS5odG1sIiwiYXNzZXRzL2pzL2JhY2tib25lL2NvbXBvbmVudHMvdGFnX2ZhY3RvcnkuanMiLCJhc3NldHMvanMvYmFja2JvbmUvY29uZmlnL2kxOG4uanNvbiIsImFzc2V0cy9qcy9iYWNrYm9uZS9jb25maWcvbG9naW4uanNvbiIsImFzc2V0cy9qcy9iYWNrYm9uZS9jb25maWcvdGFnLmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2NvbmZpZy91aS5qc29uIiwiYXNzZXRzL2pzL2JhY2tib25lL2VudGl0aWVzL2NvbW1lbnRzL2NvbW1lbnRfY29sbGVjdGlvbi5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9lbnRpdGllcy9jb21tZW50cy9jb21tZW50X21vZGVsLmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2VudGl0aWVzL2V2ZW50cy9ldmVudF9tb2RlbC5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9lbnRpdGllcy9ldmVudHMvZXZlbnRzX2NvbGxlY3Rpb24uanMiLCJhc3NldHMvanMvYmFja2JvbmUvZW50aXRpZXMvcHJvZmlsZXMvcHJvZmlsZV9tb2RlbC5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9lbnRpdGllcy9wcm9qZWN0cy9wcm9qZWN0X21vZGVsLmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL2VudGl0aWVzL3Byb2plY3RzL3Byb2plY3RzX2NvbGxlY3Rpb24uanMiLCJhc3NldHMvanMvYmFja2JvbmUvZW50aXRpZXMvdGFza3MvdGFza19tb2RlbC5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9lbnRpdGllcy90YXNrcy90YXNrc19jb2xsZWN0aW9uLmpzIiwiYXNzZXRzL2pzL2JhY2tib25lL21peGlucy9wb3BvdmVycy5qcyIsImFzc2V0cy9qcy9iYWNrYm9uZS9taXhpbnMvdGVtcGxhdGVzL3BvcG92ZXJfcHJvZmlsZS5odG1sIiwiYXNzZXRzL2pzL2JhY2tib25lL21peGlucy91dGlsaXRpZXMuanMiLCJhc3NldHMvanMvdmVuZG9yL2pxdWVyeS5zZWxlY3Rpb24uanMiLCJhc3NldHMvanMvdmVuZG9yL2pxdWVyeS50aW1lYWdvLmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jL2xpYi9hc3luYy5qcyIsIm5vZGVfbW9kdWxlcy9hdXRvbGlua2VyL2Rpc3QvQXV0b2xpbmtlci5qcyIsIm5vZGVfbW9kdWxlcy9iYWNrYm9uZS9iYWNrYm9uZS5qcyIsIm5vZGVfbW9kdWxlcy9ibHVlaW1wLWZpbGUtdXBsb2FkL2pzL2pxdWVyeS5maWxldXBsb2FkLmpzIiwibm9kZV9tb2R1bGVzL2JsdWVpbXAtZmlsZS11cGxvYWQvanMvanF1ZXJ5LmlmcmFtZS10cmFuc3BvcnQuanMiLCJub2RlX21vZHVsZXMvYmx1ZWltcC1maWxlLXVwbG9hZC9qcy92ZW5kb3IvanF1ZXJ5LnVpLndpZGdldC5qcyIsIm5vZGVfbW9kdWxlcy9ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIvc3JjL2pzL2Jvb3RzdHJhcC1kYXRldGltZXBpY2tlci5qcyIsIm5vZGVfbW9kdWxlcy9ib290c3RyYXAvZGlzdC9qcy9ucG0uanMiLCJub2RlX21vZHVsZXMvYm9vdHN0cmFwL2pzL2FmZml4LmpzIiwibm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9qcy9hbGVydC5qcyIsIm5vZGVfbW9kdWxlcy9ib290c3RyYXAvanMvYnV0dG9uLmpzIiwibm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9qcy9jYXJvdXNlbC5qcyIsIm5vZGVfbW9kdWxlcy9ib290c3RyYXAvanMvY29sbGFwc2UuanMiLCJub2RlX21vZHVsZXMvYm9vdHN0cmFwL2pzL2Ryb3Bkb3duLmpzIiwibm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9qcy9tb2RhbC5qcyIsIm5vZGVfbW9kdWxlcy9ib290c3RyYXAvanMvcG9wb3Zlci5qcyIsIm5vZGVfbW9kdWxlcy9ib290c3RyYXAvanMvc2Nyb2xsc3B5LmpzIiwibm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9qcy90YWIuanMiLCJub2RlX21vZHVsZXMvYm9vdHN0cmFwL2pzL3Rvb2x0aXAuanMiLCJub2RlX21vZHVsZXMvYm9vdHN0cmFwL2pzL3RyYW5zaXRpb24uanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2kxOG5leHQtY2xpZW50L2kxOG5leHQuY29tbW9uanMud2l0aEpRdWVyeS5qcyIsIm5vZGVfbW9kdWxlcy9qcXVlcnkuYXR3aG8vZGlzdC9qcy9qcXVlcnkuYXR3aG8uanMiLCJub2RlX21vZHVsZXMvanF1ZXJ5LmNhcmV0L2Rpc3QvanF1ZXJ5LmNhcmV0Lm1pbi5qcyIsIm5vZGVfbW9kdWxlcy9tYXJrZWQvbGliL21hcmtlZC5qcyIsIm5vZGVfbW9kdWxlcy9tb21lbnQvbW9tZW50LmpzIiwibm9kZV9tb2R1bGVzL3NlbGVjdDIvc2VsZWN0Mi5qcyIsIm5vZGVfbW9kdWxlcy90aW1lcGlja2VyL2pxdWVyeS50aW1lcGlja2VyLmpzIiwibm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvdW5kZXJzY29yZS5qcyIsImFzc2V0cy9qcy92ZW5kb3IvanF1ZXJ5LXNoaW0uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFLQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9SQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdExBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RIQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFQQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2bUJBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JTQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbk5BO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9MQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwUEE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25JQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5ZUE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFKQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlMQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25XQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzk3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMzhEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4a0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbDVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ROQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGtDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2h2QkE7QUFDQTs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4dkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcjlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2o1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGdEQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciBBcHBzUm91dGVyID0gcmVxdWlyZSgnLi9hcHBzL2FwcHNfcm91dGVyJyk7XG5cblxuQXBwbGljYXRpb24gPSB7XG5cbiAgc3RhcnRlZDogbnVsbCxcblxuICAvLyBJbml0aWFsaXplIGFuZCBmaXJlIHVwIHRoZSBhcHBsaWNhdGlvbi5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAvLyBDYWNoZSB1c2VyXG4gICAgLy8gQ2hlY2sgaWYgYSB1c2VyIGlzIGFscmVhZHkgZGVmaW5lZFxuICAgIGlmICghXy5pc1VuZGVmaW5lZChiYWNrZW5kVXNlcikpIHtcbiAgICAgIHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlciA9IGJhY2tlbmRVc2VyO1xuICAgIH1cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoc3lzdGVtTmFtZSkpIHtcbiAgICAgIHdpbmRvdy5jYWNoZS5zeXN0ZW0ubmFtZSA9IHN5c3RlbU5hbWU7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgdXNlciBldmVudHMgaGFuZGxlclxuICAgIF8uZXh0ZW5kKHdpbmRvdy5jYWNoZS51c2VyRXZlbnRzLCBCYWNrYm9uZS5FdmVudHMpO1xuXG4gICAgLy8gTWl4aW4gYmFja2JvbmUgZXZlbnRzIGludG8gb3VyIHB1YiBzdWIgaGFuZGxlclxuICAgIF8uZXh0ZW5kKGVudGl0aWVzLnJlcXVlc3QsIEJhY2tib25lLkV2ZW50cyk7XG5cbiAgICAvLyBNaXhpbiBiYWNrYm9uZSBldmVudHMgaW50byBvdXIgcmVuZGVyaW5nIGV2ZW50IGhhbmRsZXJcbiAgICBfLmV4dGVuZChyZW5kZXJpbmcsIEJhY2tib25lLkV2ZW50cyk7XG5cbiAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICBzZWxmLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuYXBwbGljYXRpb24uaW5pdGlhbGl6ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFwcGxpY2F0aW9uID0gQXBwc1JvdXRlci5pbml0aWFsaXplKCk7XG4gICAgICBzZWxmLnN0YXJ0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gQmFja2JvbmUgTXVsdGktdGVuYW50IHJvdXRlciBmaXJpbmcgdXAuXG5tb2R1bGUuZXhwb3J0cyA9IEFwcGxpY2F0aW9uO1xuIiwiLyoqXG4gKiBUaGlzIGlzIHRoZSBtYWluIGFwcGxpY2F0aW9uIGJvb3RzdHJhcFxuICogdGhhdCBnZXRzIHRoZSByZXN0IG9mIHRoZSBhcHBzLCByb3V0ZXJzLCBldGNcbiAqIHJ1bm5pbmcuXG4gKi9cblxuLy8gSW5zdGFsbCBqUXVlcnkgcGx1Z2luc1xucmVxdWlyZSgnYmx1ZWltcC1maWxlLXVwbG9hZC9qcy92ZW5kb3IvanF1ZXJ5LnVpLndpZGdldCcpO1xuaTE4biA9IHJlcXVpcmUoJ2kxOG5leHQtY2xpZW50L2kxOG5leHQuY29tbW9uanMud2l0aEpRdWVyeScpO1xubW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XG5cbi8vIEFwcFxud2luZG93LkFwcGxpY2F0aW9uICAgICAgPSB3aW5kb3cuQXBwbGljYXRpb24gfHwge307XG53aW5kb3cuY2FjaGUgICAgICAgICAgICA9IHsgdXNlckV2ZW50czoge30sIGN1cnJlbnRVc2VyOiBudWxsLCBzeXN0ZW06IHt9IH07XG5cbi8vIEV2ZW50c1xud2luZG93LmVudGl0aWVzID0geyByZXF1ZXN0OiB7fSB9O1xucmVuZGVyaW5nICAgICAgID0ge31cblxuLy8gU2V0IHVwIEJhY2tib25lIHRvIHVzZSBqUXVlcnlcbl8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5CYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG5CYWNrYm9uZS4kID0galF1ZXJ5O1xuXG4vLyBMb2FkIHRoZSBhcHBsaWNhdGlvblxudmFyIGFwcHIgPSByZXF1aXJlKCcuL2FwcC1ydW4nKTtcbmFwcHIuaW5pdGlhbGl6ZSgpO1xuIiwiXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBhc3luYyA9IHJlcXVpcmUoJ2FzeW5jJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vbWl4aW5zL3V0aWxpdGllcycpO1xudmFyIEJhc2VDb250cm9sbGVyID0gcmVxdWlyZSgnLi4vLi4vLi4vYmFzZS9iYXNlX2NvbnRyb2xsZXInKTtcbnZhciBBZG1pbk1haW5WaWV3ID0gcmVxdWlyZSgnLi4vdmlld3MvYWRtaW5fbWFpbl92aWV3Jyk7XG5cblxuQWRtaW4gPSB7fTtcblxuQWRtaW4uU2hvd0NvbnRyb2xsZXIgPSBCYXNlQ29udHJvbGxlci5leHRlbmQoe1xuXG4gIGV2ZW50czoge1xuICB9LFxuXG4gIC8vIEluaXRpYWxpemUgdGhlIGFkbWluIHZpZXdcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuYWRtaW5NYWluVmlldyA9IG5ldyBBZG1pbk1haW5WaWV3KHtcbiAgICAgIGFjdGlvbjogb3B0aW9ucy5hY3Rpb24sXG4gICAgICBlbDogdGhpcy5lbFxuICAgIH0pLnJlbmRlcigpO1xuICB9LFxuXG4gIC8vIENsZWFudXAgY29udHJvbGxlciBhbmQgdmlld3NcbiAgY2xlYW51cDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5hZG1pbk1haW5WaWV3LmNsZWFudXAoKTtcbiAgICByZW1vdmVWaWV3KHRoaXMpO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFkbWluLlNob3dDb250cm9sbGVyO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMTJcXFwiPlxcbiAgICA8aDI+PGkgY2xhc3M9XFxcImZhIGZhLW5ld3NwYXBlci1vXFxcIj48L2k+PHNwYW4gY2xhc3M9XFxcImJveC1pY29uLXRleHRcXFwiPlJlY2VudCBBY3Rpdml0eTwvc3Bhbj48L2gyPlxcbiAgICA8dWwgY2xhc3M9XFxcImFjdGl2aXR5LWZlZWQgbGlzdC11bnN0eWxlZFxcXCI+PC91bD5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcblxcbjxzY3JpcHQgdHlwZT1cXFwidGV4dC90ZW1wbGF0ZVxcXCIgaWQ9XFxcIm5ld0NvbW1lbnRcXFwiPlxcbiAgPGxpIGNsYXNzPVxcXCJib3gtcGFkLXQgYm94LXBhZC1iXFxcIj5cXG4gICAgJmxkcXVvO3t7Y29tbWVudC52YWx1ZX19JnJkcXVvOyBzYWlkIDxhIGhyZWY9XFxcIi9wcm9maWxlL3t7dXNlci5pZH19XFxcIj57e3VzZXIubmFtZSB8fCB1c2VyLnVzZXJuYW1lfX08L2E+IG9uIDxhIGhyZWY9XFxcIi97e2l0ZW1UeXBlfX1zL3t7aXRlbS5pZH19XFxcIj57e2l0ZW0udGl0bGV9fTwvYT5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY29tbWVudC1tZXRhZGF0YVxcXCI+PHRpbWUgdGl0bGU9XFxcInt7Y3JlYXRlZEF0fX1cXFwiPnt7Y3JlYXRlZEF0Rm9ybWF0dGVkfX08L3RpbWU+PC9kaXY+XFxuICA8L2xpPlxcbjwvc2NyaXB0PlxcblxcbjxzY3JpcHQgdHlwZT1cXFwidGV4dC90ZW1wbGF0ZVxcXCIgaWQ9XFxcIm5ld1ZvbHVudGVlclxcXCI+XFxuICA8bGkgY2xhc3M9XFxcImJveC1wYWQtdCBib3gtcGFkLWJcXFwiPlxcbiAgICA8YSBocmVmPVxcXCIvcHJvZmlsZS97e3VzZXIuaWR9fVxcXCI+e3t1c2VyLm5hbWUgfHwgdXNlci51c2VybmFtZX19PC9hPiBzaWduZWQgdXAgZm9yIDxhIGhyZWY9XFxcIi90YXNrcy97e3Rhc2suaWR9fVxcXCI+e3t0YXNrLnRpdGxlfX08L2E+XFxuICAgIDxkaXYgY2xhc3M9XFxcImNvbW1lbnQtbWV0YWRhdGFcXFwiPjx0aW1lIHRpdGxlPVxcXCJ7e2NyZWF0ZWRBdH19XFxcIj57e2NyZWF0ZWRBdEZvcm1hdHRlZH19PC90aW1lPjwvZGl2PlxcbiAgPC9saT5cXG48L3NjcmlwdD5cXG5cXG48c2NyaXB0IHR5cGU9XFxcInRleHQvdGVtcGxhdGVcXFwiIGlkPVxcXCJuZXdVc2VyXFxcIj5cXG4gIDxsaSBjbGFzcz1cXFwiYm94LXBhZC10IGJveC1wYWQtYlxcXCI+XFxuICAgIDxhIGhyZWY9XFxcIi9wcm9maWxlL3t7dXNlci5pZH19XFxcIj57e3VzZXIubmFtZSB8fCB1c2VyLnVzZXJuYW1lfX08L2E+IGpvaW5lZCFcXG4gICAgPGRpdiBjbGFzcz1cXFwiY29tbWVudC1tZXRhZGF0YVxcXCI+PHRpbWUgdGl0bGU9XFxcInt7Y3JlYXRlZEF0fX1cXFwiPnt7Y3JlYXRlZEF0Rm9ybWF0dGVkfX08L3RpbWU+PC9kaXY+XFxuICA8L2xpPlxcbjwvc2NyaXB0PlxcblxcbjxzY3JpcHQgdHlwZT1cXFwidGV4dC90ZW1wbGF0ZVxcXCIgaWQ9XFxcInVwZGF0ZWRVc2VyXFxcIj5cXG4gIDxsaSBjbGFzcz1cXFwiYm94LXBhZC10IGJveC1wYWQtYlxcXCI+XFxuICAgIDxhIGhyZWY9XFxcIi9wcm9maWxlL3t7dXNlci5pZH19XFxcIj57e3VzZXIubmFtZSB8fCB1c2VyLnVzZXJuYW1lfX08L2E+IHVwZGF0ZWQgdGhlaXIgcHJvZmlsZVxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb21tZW50LW1ldGFkYXRhXFxcIj48dGltZSB0aXRsZT1cXFwie3tjcmVhdGVkQXR9fVxcXCI+e3tjcmVhdGVkQXRGb3JtYXR0ZWR9fTwvdGltZT48L2Rpdj5cXG4gIDwvbGk+XFxuPC9zY3JpcHQ+XFxuXFxuPHNjcmlwdCB0eXBlPVxcXCJ0ZXh0L3RlbXBsYXRlXFxcIiBpZD1cXFwibmV3VGFza1xcXCI+XFxuICA8bGkgY2xhc3M9XFxcImJveC1wYWQtdCBib3gtcGFkLWJcXFwiPlxcbiAgICA8YSBocmVmPVxcXCIvcHJvZmlsZS97e3VzZXIuaWR9fVxcXCI+e3t1c2VyLm5hbWUgfHwgdXNlci51c2VybmFtZX19PC9hPiBwb3N0ZWQgYSBuZXcgb3Bwb3J0dW5pdHk6IDxhIGhyZWY9XFxcIi90YXNrcy97e3Rhc2suaWR9fVxcXCI+e3t0YXNrLnRpdGxlfX08L2E+XFxuICAgIDxkaXYgY2xhc3M9XFxcImNvbW1lbnQtbWV0YWRhdGFcXFwiPjx0aW1lIHRpdGxlPVxcXCJ7e2NyZWF0ZWRBdH19XFxcIj57e2NyZWF0ZWRBdEZvcm1hdHRlZH19PC90aW1lPjwvZGl2PlxcbiAgPC9saT5cXG48L3NjcmlwdD5cXG5cIjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiY29sLXNtLTYgYm94LXBhZC10IGJveC1wYWQtYlxcXCI+XFxuICAgIDxoMj48aSBjbGFzcz1cXFwiZmEgZmEtbGluZS1jaGFydFxcXCI+PC9pPjxzcGFuIGNsYXNzPVxcXCJib3gtaWNvbi10ZXh0XFxcIiBkYXRhLWkxOG49XFxcIkludGVyYWN0aW9uUGx1cmFsXFxcIj5JbnRlcmFjdGlvbnM8L3NwYW4+PC9oMj5cXG4gICAgPHVsIGNsYXNzPVxcXCJtZXRyaWNzXFxcIj5cXG4gICAgICA8bGk+VG90YWwgSW50ZXJhY3Rpb25zOiA8JS0gaW50ZXJhY3Rpb25zLmNvdW50ICU+PC9saT5cXG4gICAgICA8dWw+XFxuICAgICAgICA8bGk+PHNwYW4gZGF0YS1pMThuPVxcXCJUYXNrXFxcIj5UYXNrPC9zcGFuPiBTaWdudXBzOiA8JS0gaW50ZXJhY3Rpb25zLnNpZ251cHMgJT48L2xpPlxcbiAgICAgICAgPGxpPkFzc2lnbm1lbnRzOiA8JS0gaW50ZXJhY3Rpb25zLmFzc2lnbm1lbnRzICU+PC9saT5cXG4gICAgICAgIDxsaT5EaXNjdXNzaW9uIFBvc3RzOiA8JS0gaW50ZXJhY3Rpb25zLnBvc3RzICU+PC9saT5cXG4gICAgICAgIDxsaT5Db21wbGV0ZWQgVGFza3M6IDwlLSBpbnRlcmFjdGlvbnMuY29tcGxldGlvbnMgJT48L2xpPlxcbiAgICAgICAgPGxpPkRyYWZ0IFRhc2tzOiA8JS0gaW50ZXJhY3Rpb25zLmRyYWZ0cyAlPjwvbGk+XFxuICAgICAgICA8bGk+UHVibGlzaGVkIFRhc2tzOiA8JS0gaW50ZXJhY3Rpb25zLnB1Ymxpc2hlcyAlPjwvbGk+XFxuICAgICAgPC91bD5cXG4gICAgPC91bD5cXG4gIDwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwiY29sLXNtLTYgYm94LXBhZC10IGJveC1wYWQtYlxcXCI+XFxuICAgIDxoMj48aSBjbGFzcz1cXFwiZmEgZmEtdGFnc1xcXCI+PC9pPjxzcGFuIGNsYXNzPVxcXCJib3gtaWNvbi10ZXh0XFxcIiBkYXRhLWkxOG49XFxcIlRhc2tQbHVyYWxcXFwiPlRhc2tzPC9zcGFuPjwvaDI+XFxuICAgIDx1bCBjbGFzcz1cXFwibWV0cmljc1xcXCI+XFxuICAgICAgPGxpPlRvdGFsIENyZWF0ZWQ6IDwlLSB0YXNrcy5jb3VudCAlPjwvbGk+XFxuICAgICAgPHVsPlxcbiAgICAgICAgPGxpPkRyYWZ0OiA8JS0gdGFza3MuZHJhZnQgJT48L2xpPlxcbiAgICAgICAgPGxpPk9wZW46IDwlLSB0YXNrcy5vcGVuICU+PC9saT5cXG4gICAgICAgIDxsaT5Bc3NpZ25lZDogPCUtIHRhc2tzLmFzc2lnbmVkICU+PC9saT5cXG4gICAgICAgIDxsaT5Db21wbGV0ZWQ6IDwlLSB0YXNrcy5jb21wbGV0ZWQgJT48L2xpPlxcbiAgICAgICAgPGxpPkFyY2hpdmVkOiA8JS0gdGFza3MuYXJjaGl2ZWQgJT48L2xpPlxcbiAgICAgIDwvdWw+XFxuICAgIDwvdWw+XFxuICA8L2Rpdj5cXG48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiY29sLXNtLTYgYm94LXBhZC10IGJveC1wYWQtYlxcXCI+XFxuICAgIDxoMj48aSBjbGFzcz1cXFwiZmEgZmEtdXNlclxcXCI+PC9pPjxzcGFuIGNsYXNzPVxcXCJib3gtaWNvbi10ZXh0XFxcIj5Vc2Vyczwvc3Bhbj48L2gyPlxcbiAgICA8dWwgY2xhc3M9XFxcIm1ldHJpY3NcXFwiPlxcbiAgICAgIDxsaT5RdWFudGl0eTogPCUtIHVzZXJzLmNvdW50ICU+PC9saT5cXG4gICAgICA8dWw+PGxpPldobyBoYXZlIGNyZWF0ZWQgdGFza3M6IDwlLSB1c2Vycy53aXRoVGFza3MgJT48L2xpPjwvdWw+XFxuICAgIDwvdWw+XFxuICA8L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcImNvbC1zbS02IGJveC1wYWQtdCBib3gtcGFkLWJcXFwiPlxcbiAgICA8aDI+PGkgY2xhc3M9XFxcImZhIGZhLXJvY2tldFxcXCI+PC9pPjxzcGFuIGNsYXNzPVxcXCJib3gtaWNvbi10ZXh0XFxcIiBkYXRhLWkxOG49XFxcIlByb2plY3RQbHVyYWxcXFwiPlByb2plY3RzPC9zcGFuPjwvaDI+XFxuICAgIDx1bCBjbGFzcz1cXFwibWV0cmljc1xcXCI+XFxuICAgICAgPGxpPlRvdGFsIENyZWF0ZWQ6IDwlLSBwcm9qZWN0cy5jb3VudCAlPjwvbGk+XFxuICAgIDwvdWw+XFxuICA8L2Rpdj5cXG48L2Rpdj5cXG5cIjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJhbGVydCBhbGVydC1kYW5nZXJcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIj5cXG48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMTIgYm94IGJveC1wYWQtbHJcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTEyIHNtLW5vcGFkZGluZyBtZC1ub3BhZGRpbmdcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImZ1bGx3aWR0aCB0ZXh0LWNlbnRlciBzcGlubmVyXFxcIj5cXG4gICAgICAgIExvYWRpbmcuLi4gPGkgY2xhc3M9XFxcImZhIGZhLXNwaW5uZXIgZmEtc3BpblxcXCI+PC9pPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwibWV0cmljLWJsb2NrXFxcIj48L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcImFjdGl2aXR5LWJsb2NrXFxcIj48L2Rpdj5cXG48L2Rpdj5cXG5cIjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiY29sLXNtLTMgY29sLW1kLTNcXFwiPlxcblxcbiAgICA8bmF2IGNsYXNzPVxcXCJuYXZiYXIgYWRtaW4gbmF2YmFyLWRlZmF1bHRcXFwiIHJvbGU9XFxcIm5hdmlnYXRpb25cXFwiPlxcbiAgICAgIDwhLS0gQnJhbmQgYW5kIHRvZ2dsZSBnZXQgZ3JvdXBlZCBmb3IgYmV0dGVyIG1vYmlsZSBkaXNwbGF5IC0tPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIm5hdmJhci1oZWFkZXJcXFwiPlxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJuYXZiYXItdG9nZ2xlXFxcIiBkYXRhLXRvZ2dsZT1cXFwiY29sbGFwc2VcXFwiIGRhdGEtdGFyZ2V0PVxcXCIubmF2YmFyLWV4MS1jb2xsYXBzZVxcXCI+XFxuICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzci1vbmx5XFxcIj5Ub2dnbGUgbmF2aWdhdGlvbjwvc3Bhbj5cXG4gICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImljb24tYmFyXFxcIj48L3NwYW4+XFxuICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpY29uLWJhclxcXCI+PC9zcGFuPlxcbiAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaWNvbi1iYXJcXFwiPjwvc3Bhbj5cXG4gICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgPGgyIGNsYXNzPVxcXCJib3gtcGFkLWxyIGJveC1wYWQtdFxcXCI+QWRtaW5pc3RyYXRpb248L2gyPlxcbiAgICAgIDwvZGl2PlxcblxcbiAgICAgIDwhLS0gQ29sbGVjdCB0aGUgbmF2IGxpbmtzLCBmb3JtcywgYW5kIG90aGVyIGNvbnRlbnQgZm9yIHRvZ2dsaW5nIC0tPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbGxhcHNlIG5hdmJhci1jb2xsYXBzZSBuYXZiYXItZXgxLWNvbGxhcHNlXFxcIj5cXG4gICAgICAgIDx1bCBjbGFzcz1cXFwibmF2IG5hdmJhci1uYXZcXFwiPlxcbiAgICAgICAgICA8bGk+PGEgaHJlZj1cXFwiL2FkbWluL2Rhc2hib2FyZFxcXCIgY2xhc3M9XFxcImxpbmstYWRtaW5cXFwiIGRhdGEtdGFyZ2V0PVxcXCJkYXNoYm9hcmRcXFwiPkRhc2hib2FyZDwvYT48L2xpPlxcbiAgICAgICAgICA8bGk+PGEgaHJlZj1cXFwiL2FkbWluL3VzZXJzXFxcIiBjbGFzcz1cXFwibGluay1hZG1pblxcXCIgZGF0YS10YXJnZXQ9XFxcInVzZXJcXFwiPlVzZXIgTWFuYWdlbWVudDwvYT48L2xpPlxcbiAgICAgICAgICA8bGk+PGEgaHJlZj1cXFwiL2FkbWluL3RhZ3NcXFwiIGNsYXNzPVxcXCJsaW5rLWFkbWluXFxcIiBkYXRhLXRhcmdldD1cXFwidGFnXFxcIj5UYWcgQ29uZmlndXJhdGlvbjwvYT48L2xpPlxcbiAgICAgICAgICA8bGk+PGEgaHJlZj1cXFwiL2FkbWluL3Rhc2tzXFxcIiBjbGFzcz1cXFwibGluay1hZG1pblxcXCIgZGF0YS10YXJnZXQ9XFxcInRhc2tzXFxcIj5UYXNrczwvYT48L2xpPlxcbiAgICAgICAgPC91bD5cXG4gICAgICA8L2Rpdj48IS0tIC8ubmF2YmFyLWNvbGxhcHNlIC0tPlxcbiAgICA8L25hdj5cXG5cXG4gIDwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwiY29sLXNtLTkgY29sLW1kLTkgc20tbm9wYWRkaW5nXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiYWRtaW4tY29udGFpbmVyXFxcIiBpZD1cXFwiYWRtaW4tdXNlclxcXCI+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJhZG1pbi1jb250YWluZXJcXFwiIGlkPVxcXCJhZG1pbi10YWdcXFwiPlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiYWRtaW4tY29udGFpbmVyXFxcIiBpZD1cXFwiYWRtaW4tdGFza1xcXCI+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJhZG1pbi1jb250YWluZXJcXFwiIGlkPVxcXCJhZG1pbi1kYXNoYm9hcmRcXFwiPlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjx1bCBjbGFzcz1cXFwicGFnaW5hdGlvblxcXCIgZGF0YS1maWx0ZXI9XFxcIjwlIHEgJT5cXFwiPlxcbiAgPCUgaWYgKHBhZ2UgPiAzKSB7ICU+XFxuICA8bGk+PGEgaHJlZj1cXFwiI1xcXCI+JmxhcXVvOzwvYT48L2xpPlxcbiAgPCUgfSAlPlxcbiAgPCVcXG4gIHZhciBzdGFydCA9IE1hdGgubWF4KDEsIHBhZ2UtMik7XFxuICB2YXIgY2VpbCA9IE1hdGguY2VpbChjb3VudC90cnVlTGltaXQpO1xcbiAgaWYgKGNlaWwgPCBwYWdlICsgMikge1xcbiAgICBzdGFydCA9IE1hdGgubWF4KDEsIGNlaWwgLSA0KTtcXG4gIH1cXG4gIHZhciBtYXggPSBNYXRoLm1pbihwYWdlICsgMiwgY2VpbCk7XFxuICBpZiAoKGNlaWwgPiA1KSAmJiAoKHBhZ2UgKyAyKSA8IDUpKSB7XFxuICAgIG1heCA9IDU7XFxuICB9XFxuICAlPlxcbiAgPCUgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDw9IG1heDsgaSsrKSB7ICU+XFxuICA8bGkgPCUgaWYgKGkgPT0gcGFnZSkgeyAlPmNsYXNzPVxcXCJhY3RpdmVcXFwiPCUgfSAlPj48YSBjbGFzcz1cXFwicGFnZVxcXCIgZGF0YS1wYWdlPVxcXCI8JS0gaSAlPlxcXCIgaHJlZj1cXFwiPCUtIHVybGJhc2UgJT4/cD08JS0gaSAlPiZxPTwlLSBxICU+XFxcIj48JS0gaSAlPiA8JSBpZiAoaSA9PSBwYWdlKSB7ICU+PHNwYW4gY2xhc3M9XFxcInNyLW9ubHlcXFwiPihjdXJyZW50KTwvc3Bhbj48JSB9ICU+PC9hPjwvbGk+XFxuICA8JSB9ICU+XFxuICA8JSBpZiAoY2VpbCA+IChwYWdlICsgMikpIHsgJT5cXG4gIDxsaT48YSBocmVmPVxcXCIjXFxcIj4mcmFxdW87PC9hPjwvbGk+XFxuICA8JSB9ICU+XFxuPC91bD5cXG5cIjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJhbGVydCBhbGVydC1kYW5nZXJcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIj5cXG48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTEyIGJveCBib3gtcGFkLWxyXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMTIgYm94LXBhZC1iXFxcIj5cXG4gICAgICAgIDxoMj5GaW5kIGFuZCBhZGQgdGFnczwvaDI+XFxuICAgICAgICA8cD5TZWFyY2ggaW4gdGhlIGZpZWxkcyBiZWxvdyB0byBzZWUgZXhpc3RpbmcgdGFncy4gVHlwZSBhIG5ldyB0YWcgdmFsdWUgdG8gY3JlYXRlIGl0LjwvcD5cXG4gICAgICAgIDwlIF8odHlwZXMpLmZvckVhY2goZnVuY3Rpb24odGFnKSB7ICU+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJvdyBib3gtcGFkLWIgYm94LXBhZC10XFxcIj5cXG4gICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCI8JT0gdGFnICU+XFxcIiBjbGFzcz1cXFwiY29sLW1kLTIgY29udHJvbC1sYWJlbFxcXCI+PCU9IHRhZyAlPjo8L2xhYmVsPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0xMFxcXCI+XFxuICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwiaGlkZGVuXFxcIiBpZD1cXFwiPCU9IHRhZyAlPlxcXCIgbmFtZT1cXFwiPCU9IHRhZyAlPlxcXCIgc3R5bGU9XFxcIndpZHRoOiAxMDAlXFxcIi8+XFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLXN0YXR1cyB0ZXh0LXN1Y2Nlc3NcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwlIH0pOyAlPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImFsZXJ0IGFsZXJ0LWRhbmdlclxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPlxcbjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMTIgYm94IGJveC1wYWQtbHJcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0xMlxcXCI+XFxuXFxuICAgICAgICA8ZGl2IHJvbGU9XFxcInRhYnBhbmVsXFxcIj5cXG5cXG4gICAgICAgICAgPCEtLSBOYXYgdGFicyAtLT5cXG4gICAgICAgICAgPHVsIGNsYXNzPVxcXCJuYXYgbmF2LXRhYnMgYm94LXBhZC10XFxcIiByb2xlPVxcXCJ0YWJsaXN0XFxcIj5cXG4gICAgICAgICAgICA8bGkgcm9sZT1cXFwicHJlc2VudGF0aW9uXFxcIj5cXG4gICAgICAgICAgICAgIDxhIGhyZWY9XFxcIiNkcmFmdHNcXFwiIGFyaWEtY29udHJvbHM9XFxcIm9wZW5cXFwiIHJvbGU9XFxcInRhYlxcXCIgZGF0YS10b2dnbGU9XFxcInRhYlxcXCI+XFxuICAgICAgICAgICAgICAgIERyYWZ0czogPCUtIGRyYWZ0cy5sZW5ndGggJT5cXG4gICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgIDxsaSByb2xlPVxcXCJwcmVzZW50YXRpb25cXFwiIGNsYXNzPVxcXCJhY3RpdmVcXFwiPlxcbiAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiI29wZW5cXFwiIGFyaWEtY29udHJvbHM9XFxcIm9wZW5cXFwiIHJvbGU9XFxcInRhYlxcXCIgZGF0YS10b2dnbGU9XFxcInRhYlxcXCI+XFxuICAgICAgICAgICAgICAgIE9wZW46IDwlLSBvcGVuLmxlbmd0aCAlPlxcbiAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgPGxpIHJvbGU9XFxcInByZXNlbnRhdGlvblxcXCI+XFxuICAgICAgICAgICAgICA8YSBocmVmPVxcXCIjc2lnbnVwc1xcXCIgYXJpYS1jb250cm9scz1cXFwic2lnbnVwc1xcXCIgcm9sZT1cXFwidGFiXFxcIiBkYXRhLXRvZ2dsZT1cXFwidGFiXFxcIj5cXG4gICAgICAgICAgICAgICAgU2lnbi11cHM6IDwlLSB3aXRoU2lnbnVwcy5sZW5ndGggJT5cXG4gICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgIDxsaSByb2xlPVxcXCJwcmVzZW50YXRpb25cXFwiPlxcbiAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiI2Fzc2lnbmVkXFxcIiBhcmlhLWNvbnRyb2xzPVxcXCJhc3NpZ25lZFxcXCIgcm9sZT1cXFwidGFiXFxcIiBkYXRhLXRvZ2dsZT1cXFwidGFiXFxcIj5cXG4gICAgICAgICAgICAgICAgQXNzaWduZWQ6IDwlLSBhc3NpZ25lZC5sZW5ndGggJT5cXG4gICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgIDxsaSByb2xlPVxcXCJwcmVzZW50YXRpb25cXFwiPlxcbiAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiI2NvbXBsZXRlZFxcXCIgYXJpYS1jb250cm9scz1cXFwiY29tcGxldGVkXFxcIiByb2xlPVxcXCJ0YWJcXFwiIGRhdGEtdG9nZ2xlPVxcXCJ0YWJcXFwiPlxcbiAgICAgICAgICAgICAgICBDb21wbGV0ZWQ6IDwlLSBjb21wbGV0ZWQubGVuZ3RoICU+XFxuICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgPC91bD5cXG5cXG4gICAgICAgICAgPCEtLSBUYWIgcGFuZXMgLS0+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInRhYi1jb250ZW50IGJveC1wYWQtdFxcXCI+XFxuICAgICAgICAgICAgPGRpdiByb2xlPVxcXCJ0YWJwYW5lbFxcXCIgY2xhc3M9XFxcInRhYi1wYW5lXFxcIiBpZD1cXFwiZHJhZnRzXFxcIj5cXG4gICAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwibWV0cmljc1xcXCI+XFxuICAgICAgICAgICAgICAgIDwlIF8oZHJhZnRzKS5mb3JFYWNoKGZ1bmN0aW9uKHRhc2spIHsgJT5cXG4gICAgICAgICAgICAgICAgICA8bGk+XFxuICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCIvdGFza3MvPCUtIHRhc2suaWQgJT5cXFwiPjwlLSB0YXNrLnRpdGxlICU+PC9hPixcXG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIi9wcm9maWxlLzwlLSB0YXNrLnVzZXIuaWQgJT5cXFwiPjwlLSB0YXNrLnVzZXIubmFtZSB8fCB0YXNrLnVzZXIudXNlcm5hbWUgJT48L2E+XFxuICAgICAgICAgICAgICAgICAgICA8JSBpZiAodGFzay52b2x1bnRlZXJzLmxlbmd0aCkgeyAlPlxcbiAgICAgICAgICAgICAgICAgICAgPHA+U2lnbi11cHM6XFxuICAgICAgICAgICAgICAgICAgICAgIDwlIF8odGFzay52b2x1bnRlZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKHZvbCkgeyAlPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIi9wcm9maWxlLzwlLSB0YXNrLnVzZXIuaWQgJT5cXFwiPjwlLSB2b2wudXNlci5uYW1lIHx8IHZvbC51c2VyLnVzZXJuYW1lICU+PC9hPlxcbiAgICAgICAgICAgICAgICAgICAgICA8JSB9KTsgJT5cXG4gICAgICAgICAgICAgICAgICAgIDwvcD5cXG4gICAgICAgICAgICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgICA8JSB9KTsgJT5cXG4gICAgICAgICAgICAgIDwvdWw+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiByb2xlPVxcXCJ0YWJwYW5lbFxcXCIgY2xhc3M9XFxcInRhYi1wYW5lIGFjdGl2ZVxcXCIgaWQ9XFxcIm9wZW5cXFwiPlxcbiAgICAgICAgICAgICAgPHVsIGNsYXNzPVxcXCJtZXRyaWNzXFxcIj5cXG4gICAgICAgICAgICAgICAgPCUgXyhvcGVuKS5mb3JFYWNoKGZ1bmN0aW9uKHRhc2spIHsgJT5cXG4gICAgICAgICAgICAgICAgICA8bGk+XFxuICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCIvdGFza3MvPCUtIHRhc2suaWQgJT5cXFwiPjwlLSB0YXNrLnRpdGxlICU+PC9hPixcXG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIi9wcm9maWxlLzwlLSB0YXNrLnVzZXIuaWQgJT5cXFwiPjwlLSB0YXNrLnVzZXIubmFtZSB8fCB0YXNrLnVzZXIudXNlcm5hbWUgJT48L2E+XFxuICAgICAgICAgICAgICAgICAgICA8JSBpZiAodGFzay52b2x1bnRlZXJzLmxlbmd0aCkgeyAlPlxcbiAgICAgICAgICAgICAgICAgICAgPHA+U2lnbi11cHM6XFxuICAgICAgICAgICAgICAgICAgICAgIDwlIF8odGFzay52b2x1bnRlZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKHZvbCkgeyAlPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIi9wcm9maWxlLzwlLSB0YXNrLnVzZXIuaWQgJT5cXFwiPjwlLSB2b2wudXNlci5uYW1lIHx8IHZvbC51c2VyLnVzZXJuYW1lICU+PC9hPlxcbiAgICAgICAgICAgICAgICAgICAgICA8JSB9KTsgJT5cXG4gICAgICAgICAgICAgICAgICAgIDwvcD5cXG4gICAgICAgICAgICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgICA8JSB9KTsgJT5cXG4gICAgICAgICAgICAgIDwvdWw+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiByb2xlPVxcXCJ0YWJwYW5lbFxcXCIgY2xhc3M9XFxcInRhYi1wYW5lXFxcIiBpZD1cXFwic2lnbnVwc1xcXCI+XFxuICAgICAgICAgICAgICA8dWwgY2xhc3M9XFxcIm1ldHJpY3NcXFwiPlxcbiAgICAgICAgICAgICAgICA8JSBfKHdpdGhTaWdudXBzKS5mb3JFYWNoKGZ1bmN0aW9uKHRhc2spIHsgJT5cXG4gICAgICAgICAgICAgICAgICA8bGk+XFxuICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCIvdGFza3MvPCUtIHRhc2suaWQgJT5cXFwiPjwlLSB0YXNrLnRpdGxlICU+PC9hPixcXG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIi9wcm9maWxlLzwlLSB0YXNrLnVzZXIuaWQgJT5cXFwiPjwlLSB0YXNrLnVzZXIubmFtZSB8fCB0YXNrLnVzZXIudXNlcm5hbWUgJT48L2E+XFxuICAgICAgICAgICAgICAgICAgICA8JSBpZiAodGFzay52b2x1bnRlZXJzLmxlbmd0aCkgeyAlPlxcbiAgICAgICAgICAgICAgICAgICAgICA8cD5TaWduLXVwczpcXG4gICAgICAgICAgICAgICAgICAgICAgICA8JSBfKHRhc2sudm9sdW50ZWVycykuZm9yRWFjaChmdW5jdGlvbih2b2wpIHsgJT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIi9wcm9maWxlLzwlLSB0YXNrLnVzZXIuaWQgJT5cXFwiPjwlLSB2b2wudXNlci5uYW1lIHx8IHZvbC51c2VyLnVzZXJuYW1lICU+PC9hPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwlIH0pOyAlPlxcbiAgICAgICAgICAgICAgICAgICAgICA8L3A+XFxuICAgICAgICAgICAgICAgICAgICA8JSB9ICU+XFxuICAgICAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICAgICAgPCUgfSk7ICU+XFxuICAgICAgICAgICAgICA8L3VsPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgcm9sZT1cXFwidGFicGFuZWxcXFwiIGNsYXNzPVxcXCJ0YWItcGFuZVxcXCIgaWQ9XFxcImFzc2lnbmVkXFxcIj5cXG4gICAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwibWV0cmljc1xcXCI+XFxuICAgICAgICAgICAgICAgIDwlIF8oYXNzaWduZWQpLmZvckVhY2goZnVuY3Rpb24odGFzaykgeyAlPlxcbiAgICAgICAgICAgICAgICAgIDxsaT5cXG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIi90YXNrcy88JS0gdGFzay5pZCAlPlxcXCI+PCUtIHRhc2sudGl0bGUgJT48L2E+LFxcbiAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiL3Byb2ZpbGUvPCUtIHRhc2sudXNlci5pZCAlPlxcXCI+PCUtIHRhc2sudXNlci5uYW1lIHx8IHRhc2sudXNlci51c2VybmFtZSAlPjwvYT5cXG4gICAgICAgICAgICAgICAgICAgIDwlIGlmICh0YXNrLnZvbHVudGVlcnMubGVuZ3RoKSB7ICU+XFxuICAgICAgICAgICAgICAgICAgICAgIDxwPlNpZ24tdXBzOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwlIF8odGFzay52b2x1bnRlZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKHZvbCkgeyAlPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiL3Byb2ZpbGUvPCUtIHRhc2sudXNlci5pZCAlPlxcXCI+PCUtIHZvbC51c2VyLm5hbWUgfHwgdm9sLnVzZXIudXNlcm5hbWUgJT48L2E+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPCUgfSk7ICU+XFxuICAgICAgICAgICAgICAgICAgICAgIDwvcD5cXG4gICAgICAgICAgICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgICA8JSB9KTsgJT5cXG4gICAgICAgICAgICAgIDwvdWw+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiByb2xlPVxcXCJ0YWJwYW5lbFxcXCIgY2xhc3M9XFxcInRhYi1wYW5lXFxcIiBpZD1cXFwiY29tcGxldGVkXFxcIj5cXG4gICAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwibWV0cmljc1xcXCI+XFxuICAgICAgICAgICAgICAgIDwlIF8oY29tcGxldGVkKS5mb3JFYWNoKGZ1bmN0aW9uKHRhc2spIHsgJT5cXG4gICAgICAgICAgICAgICAgICA8bGk+XFxuICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCIvdGFza3MvPCUtIHRhc2suaWQgJT5cXFwiPjwlLSB0YXNrLnRpdGxlICU+PC9hPixcXG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIi9wcm9maWxlLzwlLSB0YXNrLnVzZXIuaWQgJT5cXFwiPjwlLSB0YXNrLnVzZXIubmFtZSB8fCB0YXNrLnVzZXIudXNlcm5hbWUgJT48L2E+XFxuICAgICAgICAgICAgICAgICAgICA8JSBpZiAodGFzay52b2x1bnRlZXJzLmxlbmd0aCkgeyAlPlxcbiAgICAgICAgICAgICAgICAgICAgICA8cD5TaWduLXVwczpcXG4gICAgICAgICAgICAgICAgICAgICAgICA8JSBfKHRhc2sudm9sdW50ZWVycykuZm9yRWFjaChmdW5jdGlvbih2b2wpIHsgJT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIi9wcm9maWxlLzwlLSB0YXNrLnVzZXIuaWQgJT5cXFwiPjwlLSB2b2wudXNlci5uYW1lIHx8IHZvbC51c2VyLnVzZXJuYW1lICU+PC9hPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwlIH0pOyAlPlxcbiAgICAgICAgICAgICAgICAgICAgICA8L3A+XFxuICAgICAgICAgICAgICAgICAgICA8JSB9ICU+XFxuICAgICAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICAgICAgPCUgfSk7ICU+XFxuICAgICAgICAgICAgICA8L3VsPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgIDwvZGl2PlxcblxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxmb3JtIGFjdGlvbj1cXFwiXFxcIiBpZD1cXFwicmVzZXQtcGFzc3dvcmRcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwibW9kYWwtYm9keVxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImFsZXJ0IGFsZXJ0LWRhbmdlclxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPlxcbiAgICA8L2Rpdj5cXG4gICAgPGZpZWxkc2V0PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwibmV3UGFzc3dvcmRcXFwiPk5ldyBQYXNzd29yZCBmb3IgPCUtIHUubmFtZSAlPjwvbGFiZWw+XFxuICAgICAgICA8aW5wdXQgdHlwZT1cXFwicGFzc3dvcmRcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIGlkPVxcXCJuZXdQYXNzd29yZFxcXCIgbmFtZT1cXFwicGFzc3dvcmRcXFwiIHBsYWNlaG9sZGVyPVxcXCJOZXcgUGFzc3dvcmRcXFwiIGRhdGEtdmFsaWRhdGU9XFxcImVtcHR5XFxcIj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJoZWxwLWJsb2NrIGVycm9yLWVtcHR5XFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI+WW91IG11c3QgZW50ZXIgYSBwYXNzd29yZC48L3NwYW4+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZmllbGRzZXQ+XFxuICA8L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWZvb3RlclxcXCI+XFxuICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1jMFxcXCIgZGF0YS1kaXNtaXNzPVxcXCJtb2RhbFxcXCI+Q2FuY2VsPC9idXR0b24+XFxuICAgIDxpbnB1dCB0eXBlPVxcXCJzdWJtaXRcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWMyXFxcIiBpZD1cXFwic3VibWl0XFxcIiB2YWx1ZT1cXFwiQ2hhbmdlIFBhc3N3b3JkXFxcIi8+XFxuICA8L2Rpdj5cXG48L2Zvcm0+XFxuXCI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHRhYmxlIGNsYXNzPVxcXCJ0YWJsZSB0YWJsZS1ob3ZlciB0YWJsZS1jb25kZW5zZWRcXFwiPlxcbiAgPHRoZWFkPlxcbiAgICA8dHI+XFxuICAgICAgPHRoIGNsYXNzPVxcXCJhZG1pbi11c2VyLWlkXFxcIj4jPC90aD5cXG4gICAgICA8dGg+TmFtZTwvdGg+XFxuICAgICAgPHRoPkVtYWlsPC90aD5cXG4gICAgICA8dGg+Q3JlYXRlZCBBdDwvdGg+XFxuICAgICAgPHRoPjxzcGFuIGRhdGEtaTE4bj1cXFwiUHJvamVjdFBsdXJhbFxcXCI+UHJvamVjdHM8L3NwYW4+IChvcGVuIC8gY2xvc2VkKTwvdGg+XFxuICAgICAgPHRoPjxzcGFuIGRhdGEtaTE4bj1cXFwiVGFza1BsdXJhbFxcXCI+VGFza3M8L3NwYW4+IChvcGVuIC8gYXNzaWduZWQgLyBjb21wbGV0ZWQgLyBhcmNoaXZlZCk8L3RoPlxcbiAgICAgIDx0aD5Wb2x1bnRlZXIgKG9wZW4gLyBhc3NpZ25lZCAvIGNvbXBsZXRlZCAvIGFyY2hpdmVkKTwvdGg+XFxuICAgICAgPHRoIGNsYXNzPVxcXCJhZG1pbi11c2VyLWNoZWNrYm94XFxcIj5FbmFibGVkPC90aD5cXG4gICAgICA8JSBpZiAobG9naW4ubG9jYWwuZW5hYmxlZCA9PT0gdHJ1ZSkgeyAlPlxcbiAgICAgIDx0aCBjbGFzcz1cXFwiYWRtaW4tdXNlci1jaGVja2JveFxcXCI+UGFzc3dvcmQ8L3RoPlxcbiAgICAgIDwlIH0gJT5cXG4gICAgICA8dGggY2xhc3M9XFxcImFkbWluLXVzZXItY2hlY2tib3hcXFwiPkFkbWluPC90aD5cXG4gICAgPC90cj5cXG4gIDwvdGhlYWQ+XFxuICA8dGJvZHk+XFxuICAgIDwlIGlmICh1c2Vycy5sZW5ndGggPT09IDApIHsgJT5cXG4gICAgPHRyIGNsYXNzPVxcXCJlbXB0eS1yb3dcXFwiPlxcbiAgICAgIDx0ZCBjb2xzcGFuPVxcXCI1XFxcIj5cXG4gICAgICAgIE5vIHVzZXJzIGZvdW5kLlxcbiAgICAgIDwvdGQ+XFxuICAgIDwvdHI+XFxuICAgIDwlIH0gJT5cXG4gICAgPCUgXy5lYWNoKHVzZXJzLCBmdW5jdGlvbiAodSkgeyAlPlxcbiAgICA8dHIgZGF0YS1pZD1cXFwiPCUtIHUuaWQgJT5cXFwiPlxcbiAgICAgIDx0ZD5cXG4gICAgICAgIDwlLSB1LmlkICU+XFxuICAgICAgPC90ZD5cXG4gICAgICA8dGQgY2xhc3M9XFxcImFkbWluLXRhYmxlLW5hbWVcXFwiPlxcbiAgICAgICAgPCUtIHUubmFtZSAlPlxcbiAgICAgIDwvdGQ+XFxuICAgICAgPHRkIGNsYXNzPVxcXCJhZG1pbi10YWJsZS11c2VybmFtZVxcXCI+XFxuICAgICAgICA8YSBjbGFzcz1cXFwibGluay1iYWNrYm9uZVxcXCIgaHJlZj1cXFwiL3Byb2ZpbGUvPCUtIHUuaWQgJT5cXFwiPjwlLSB1LnVzZXJuYW1lICU+PC9hPlxcbiAgICAgIDwvdGQ+XFxuICAgICAgPHRkIGNsYXNzPVxcXCJhZG1pbi10YWJsZS1jcmVhdGVkYXRcXFwiPlxcbiAgICAgICAgPCEtLSBkYXkgLS0+XFxuICAgICAgICA8JSB2YXIgY3JlYXRlZCA9IG5ldyBEYXRlKHUuY3JlYXRlZEF0KTsgJT5cXG4gICAgICAgIDwlPSBjcmVhdGVkLnRvTG9jYWxlRGF0ZVN0cmluZygpICU+XFxuICAgICAgICA8IS0tIHRpbWUgLS0+XFxuICAgICAgICA8JT0gY3JlYXRlZC50b0xvY2FsZVRpbWVTdHJpbmcoKSAlPlxcbiAgICAgIDwvdGQ+XFxuICAgICAgPHRkIGNsYXNzPVxcXCJhZG1pbi10YWJsZS1wcm9qZWN0c1xcXCI+XFxuICAgICAgPCUgaWYgKHUucHJvamVjdHNDcmVhdGVkT3BlbiAhPT0gMCB8fCB1LnByb2plY3RzQ3JlYXRlZENsb3NlZCAhPT0gMCkgeyAlPlxcbiAgICAgICAgPGEgY2xhc3M9XFxcImxpbmstYmFja2JvbmVcXFwiIGhyZWY9XFxcIi9wcm9maWxlLzwlLSB1LmlkICU+XFxcIj48JS0gdS5wcm9qZWN0c0NyZWF0ZWRPcGVuICU+IC8gPCUtIHUucHJvamVjdHNDcmVhdGVkQ2xvc2VkICU+PC9hPlxcbiAgICAgIDwlIH0gJT5cXG4gICAgICA8L3RkPlxcbiAgICAgIDx0ZCBjbGFzcz1cXFwiYWRtaW4tdGFibGUtdGFza3NcXFwiPlxcbiAgICAgIDwlIGlmICh1LnRhc2tzQ3JlYXRlZE9wZW4gIT09IDAgfHwgdS50YXNrc0NyZWF0ZWRBc3NpZ25lZCAhPT0gMCB8fCB1LnRhc2tzQ3JlYXRlZENvbXBsZXRlZCAhPT0gMCB8fCB1LnRhc2tzQ3JlYXRlZEFyY2hpdmVkICE9PSAwKSB7ICU+XFxuICAgICAgICA8YSBjbGFzcz1cXFwibGluay1iYWNrYm9uZVxcXCIgaHJlZj1cXFwiL3Byb2ZpbGUvPCUtIHUuaWQgJT5cXFwiPjwlLSB1LnRhc2tzQ3JlYXRlZE9wZW4gJT4gLyA8JS0gdS50YXNrc0NyZWF0ZWRBc3NpZ25lZCAlPiAvIDwlLSB1LnRhc2tzQ3JlYXRlZENvbXBsZXRlZCAlPiAvIDwlLSB1LnRhc2tzQ3JlYXRlZEFyY2hpdmVkICU+PC9hPlxcbiAgICAgIDwlIH0gJT5cXG4gICAgICA8L3RkPlxcbiAgICAgIDx0ZCBjbGFzcz1cXFwiYWRtaW4tdGFibGUtdm9sdW50ZWVyXFxcIj5cXG4gICAgICA8JSBpZiAodS52b2xDb3VudE9wZW4gIT09IDAgfHwgdS52b2xDb3VudEFzc2lnbmVkICE9PSAwIHx8IHUudm9sQ291bnRDb21wbGV0ZWQgIT09IDAgfHwgdS52b2xDb3VudEFyY2hpdmVkICE9PSAwKSB7ICU+XFxuICAgICAgICA8YSBjbGFzcz1cXFwibGluay1iYWNrYm9uZVxcXCIgaHJlZj1cXFwiL3Byb2ZpbGUvPCUtIHUuaWQgJT5cXFwiPjwlLSB1LnZvbENvdW50T3BlbiAlPiAvIDwlLSB1LnZvbENvdW50QXNzaWduZWQgJT4gLyA8JS0gdS52b2xDb3VudENvbXBsZXRlZCAlPiAvIDwlLSB1LnZvbENvdW50QXJjaGl2ZWQgJT48L2E+XFxuICAgICAgPCUgfSAlPlxcbiAgICAgIDwvdGQ+XFxuICAgICAgPHRkPlxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgYnRuLXhzIGFkbWluLXVzZXItZW5hYmxlXFxcIiBkYXRhLXRvZ2dsZT1cXFwidG9vbHRpcFxcXCIgZGF0YS1wbGFjZW1lbnQ9XFxcInRvcFxcXCIgdGl0bGU9XFxcIkVuYWJsZVxcXCIgPCUgaWYgKHUuZGlzYWJsZWQgIT09IHRydWUpIHsgJT5zdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI8JSB9ICU+PjxpIGNsYXNzPVxcXCJmYSBmYS1yZW1vdmUtc2lnbiBpY29uLXJlZCBpY29uLWNlbnRlclxcXCI+PC9pPjwvYnV0dG9uPlxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgYnRuLXhzIGFkbWluLXVzZXItZGlzYWJsZVxcXCIgZGF0YS10b2dnbGU9XFxcInRvb2x0aXBcXFwiIGRhdGEtcGxhY2VtZW50PVxcXCJ0b3BcXFwiIHRpdGxlPVxcXCJEaXNhYmxlXFxcIiA8JSBpZiAodS5kaXNhYmxlZCA9PT0gdHJ1ZSkgeyAlPnN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIjwlIH0gJT4+PGkgY2xhc3M9XFxcImZhIGZhLWNoZWNrIGljb24tZ3JlZW4gaWNvbi1jZW50ZXJcXFwiPjwvaT48L2J1dHRvbj5cXG4gICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi14cyBidG4tc3BpblxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPjxpIGNsYXNzPVxcXCJmYS1zcGluIGZhIGZhLXNwaW5uZXIgaWNvbi1jZW50ZXJcXFwiPjwvaT48L2J1dHRvbj5cXG4gICAgICA8L3RkPlxcbiAgICAgIDwlIGlmIChsb2dpbi5sb2NhbC5lbmFibGVkID09PSB0cnVlKSB7ICU+XFxuICAgICAgPHRkPlxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgYnRuLXhzIGFkbWluLXVzZXItcmVzZXRwd1xcXCIgZGF0YS10b2dnbGU9XFxcInRvb2x0aXBcXFwiIGRhdGEtcGxhY2VtZW50PVxcXCJ0b3BcXFwiIHRpdGxlPVxcXCJSZXNldCBQYXNzd29yZFxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLWNoZWNrIGZhLWNvZ1xcXCI+PC9pPjwvYnV0dG9uPlxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgYnRuLXhzIGFkbWluLXVzZXItdW5sb2NrXFxcIiBkYXRhLXRvZ2dsZT1cXFwidG9vbHRpcFxcXCIgZGF0YS1wbGFjZW1lbnQ9XFxcInRvcFxcXCIgdGl0bGU9XFxcIlVubG9jayBVc2VyIChjbGVhciBwYXNzd29yZCBhdHRlbXB0cylcXFwiIDwlIGlmICh1LmxvY2tlZCAhPT0gdHJ1ZSkgeyAlPnN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIjwlIH0gJT4+PGkgY2xhc3M9XFxcImZhIGZhLWNoZWNrIGljb24tcmVkIGZhLWxvY2tcXFwiPjwvaT48L2J1dHRvbj5cXG4gICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi14cyBidG4tc3BpblxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1zcGluIGZhLXNwaW5uZXIgaWNvbi1jZW50ZXJcXFwiPjwvaT48L2J1dHRvbj5cXG4gICAgICA8L3RkPlxcbiAgICAgIDwlIH0gJT5cXG4gICAgICA8dGQ+XFxuICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBidG4teHMgYWRtaW4tdXNlci1ybWFkbWluXFxcIiBkYXRhLXRvZ2dsZT1cXFwidG9vbHRpcFxcXCIgZGF0YS1wbGFjZW1lbnQ9XFxcInRvcFxcXCIgdGl0bGU9XFxcIlJlbW92ZSBBZG1pbiBQcml2aWxlZGdlc1xcXCIgPCUgaWYgKHUuaXNBZG1pbiAhPT0gdHJ1ZSkgeyAlPnN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIjwlIH0gJT4+PGkgY2xhc3M9XFxcImZhIGZhLWNoZWNrIGljb24tZ3JlZW4gaWNvbi1jZW50ZXJcXFwiPjwvaT48L2J1dHRvbj5cXG4gICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi14cyBhZG1pbi11c2VyLW1rYWRtaW5cXFwiIGRhdGEtdG9nZ2xlPVxcXCJ0b29sdGlwXFxcIiBkYXRhLXBsYWNlbWVudD1cXFwidG9wXFxcIiB0aXRsZT1cXFwiTWFrZSBBZG1pblxcXCIgPCUgaWYgKHUuaXNBZG1pbiA9PT0gdHJ1ZSkgeyAlPnN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIjwlIH0gJT4+PGkgY2xhc3M9XFxcImZhIGZhLXRpbWVzLWNpcmNsZSBpY29uLXJlZCBpY29uLWNlbnRlclxcXCI+PC9pPjwvYnV0dG9uPlxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgYnRuLXhzIGJ0bi1zcGluXFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXNwaW4gZmEtc3Bpbm5lciBpY29uLWNlbnRlclxcXCI+PC9pPjwvYnV0dG9uPlxcbiAgICAgIDwvdGQ+XFxuICAgIDwvdHI+XFxuICAgIDwlIH0pOyAlPlxcbiAgPC90Ym9keT5cXG48L3RhYmxlPlxcblwiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImFsZXJ0IGFsZXJ0LWRhbmdlclxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPlxcbjwvZGl2PlxcbjxkaXYgaWQ9XFxcInJlc2V0LXBhc3N3b3JkLWNvbnRhaW5lclxcXCI+PC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0xMiBib3ggYm94LXBhZC1sclxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLWxnLTggY29sLW1kLTcgY29sLXNtLTUgc20tbm9wYWRkaW5nIG1kLW5vcGFkZGluZ1xcXCI+XFxuXFxuICAgICAgPGZvcm0gY2xhc3M9XFxcImZvcm0taW5saW5lIGZ1bGx3aWR0aFxcXCIgcm9sZT1cXFwiZm9ybVxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwIGZ1bGx3aWR0aFxcXCI+XFxuICAgICAgICAgIDxsYWJlbCBjbGFzcz1cXFwic3Itb25seVxcXCIgZm9yPVxcXCJ1c2VyLWZpbHRlclxcXCI+RmlsdGVyPC9sYWJlbD5cXG4gICAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2wgZnVsbHdpZHRoXFxcIiBpZD1cXFwidXNlci1maWx0ZXJcXFwiIHBsYWNlaG9sZGVyPVxcXCJGaWx0ZXJcXFwiPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9mb3JtPlxcblxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1sZy00IGNvbC1tZC01IGNvbC1zbS03IHNtLW5vcGFkZGluZyBtZC1ub3BhZGRpbmctcmlnaHRcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwicHVsbC1yaWdodFxcXCIgaWQ9XFxcInVzZXItcGFnZVxcXCI+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTEyIHNtLW5vcGFkZGluZyBtZC1ub3BhZGRpbmdcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiZnVsbHdpZHRoIHRleHQtY2VudGVyIHNwaW5uZXJcXFwiPlxcbiAgICAgICAgICBMb2FkaW5nLi4uIDxpIGNsYXNzPVxcXCJmYSBmYS1zcGlubmVyIGZhLXNwaW5cXFwiPjwvaT5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMTIgc20tbm9wYWRkaW5nIG1kLW5vcGFkZGluZ1xcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0YWJsZS1yZXNwb25zaXZlXFxcIj5cXG5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZGl2PlwiO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vbWl4aW5zL3V0aWxpdGllcycpO1xudmFyIE1vZGFsQ29tcG9uZW50ID0gcmVxdWlyZSgnLi4vLi4vLi4vY29tcG9uZW50cy9tb2RhbCcpO1xudmFyIEFkbWluRGFzaGJvYXJkVGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvYWRtaW5fZGFzaGJvYXJkX3RlbXBsYXRlLmh0bWwnKTtcbnZhciBBZG1pbkRhc2hib2FyZFRhYmxlID0gcmVxdWlyZSgnLi4vdGVtcGxhdGVzL2FkbWluX2Rhc2hib2FyZF90YWJsZS5odG1sJyk7XG52YXIgQWRtaW5EYXNoYm9hcmRBY3Rpdml0aWVzID0gcmVxdWlyZSgnLi4vdGVtcGxhdGVzL2FkbWluX2Rhc2hib2FyZF9hY3Rpdml0aWVzLmh0bWwnKTtcbnZhciBMb2dpbkNvbmZpZyA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbmZpZy9sb2dpbi5qc29uJyk7XG5cblxudmFyIEFkbWluRGFzaGJvYXJkVmlldyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcblxuICBldmVudHM6IHtcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5kYXRhID0ge1xuICAgICAgcGFnZTogMVxuICAgIH07XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIEJhY2tib25lLmhpc3RvcnkubmF2aWdhdGUoJy9hZG1pbi9kYXNoYm9hcmQnKTtcbiAgICB0aGlzLiRlbC5zaG93KCk7XG4gICAgaWYgKHRoaXMucmVuZGVyZWQgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIHVzZXI6IHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlcixcbiAgICAgIGxvZ2luOiBMb2dpbkNvbmZpZ1xuICAgIH07XG4gICAgdmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZShBZG1pbkRhc2hib2FyZFRlbXBsYXRlKShkYXRhKTtcbiAgICB0aGlzLiRlbC5odG1sKHRlbXBsYXRlKTtcbiAgICB0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcbiAgICAvLyBmZXRjaCBkYXRhXG4gICAgdGhpcy5mZXRjaERhdGEoc2VsZiwgdGhpcy5kYXRhKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICByZW5kZXJNZXRyaWNzOiBmdW5jdGlvbiAoc2VsZiwgZGF0YSkge1xuICAgIHZhciB0ZW1wbGF0ZSA9IF8udGVtcGxhdGUoQWRtaW5EYXNoYm9hcmRUYWJsZSkoZGF0YSk7XG4gICAgc2VsZi4kKFwiLm1ldHJpYy1ibG9ja1wiKS5odG1sKHRlbXBsYXRlKTtcbiAgICB0aGlzLiRlbC5pMThuKCk7XG4gICAgLy8gaGlkZSBzcGlubmVyIGFuZCBzaG93IHJlc3VsdHNcbiAgICBzZWxmLiQoXCIuc3Bpbm5lclwiKS5oaWRlKCk7XG4gICAgc2VsZi4kKFwiLm1ldHJpYy1ibG9ja1wiKS5zaG93KCk7XG4gIH0sXG5cbiAgcmVuZGVyQWN0aXZpdGllczogZnVuY3Rpb24gKHNlbGYsIGRhdGEpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBfLnRlbXBsYXRlKEFkbWluRGFzaGJvYXJkQWN0aXZpdGllcyk7XG4gICAgc2VsZi4kKFwiLmFjdGl2aXR5LWJsb2NrXCIpLmh0bWwodGVtcGxhdGUpO1xuICAgIF8oZGF0YSkuZm9yRWFjaChmdW5jdGlvbihhY3Rpdml0eSkge1xuICAgICAgaWYgKCFhY3Rpdml0eSkgcmV0dXJuO1xuICAgICAgLy8gU3RyaXAgSFRNTCBmcm9tIGNvbW1lbnRzXG4gICAgICBpZiAoYWN0aXZpdHkuY29tbWVudCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhY3Rpdml0eS5jb21tZW50LnZhbHVlLnJlcGxhY2UoLzwoPzoufFxcbikqPz4vZ20sICcnKTtcbiAgICAgICAgYWN0aXZpdHkuY29tbWVudC52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgLy8gRm9ybWF0IHRpbWVzdGFtcFxuICAgICAgYWN0aXZpdHkuY3JlYXRlZEF0Rm9ybWF0dGVkID0gJC50aW1lYWdvKGFjdGl2aXR5LmNyZWF0ZWRBdCk7XG4gICAgICB2YXIgdGVtcGxhdGUgPSBzZWxmLiQoJyMnICsgYWN0aXZpdHkudHlwZSkudGV4dCgpLFxuICAgICAgICAgIGNvbnRlbnQgPSBfLnRlbXBsYXRlKHRlbXBsYXRlLCB7IGVzY2FwZTogL1xce1xceyguKz8pXFx9XFx9L2cgfSkoYWN0aXZpdHkpO1xuICAgICAgc2VsZi4kKCcuYWN0aXZpdHktYmxvY2sgLmFjdGl2aXR5LWZlZWQnKS5hcHBlbmQoY29udGVudCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLiRlbC5pMThuKCk7XG4gICAgLy8gaGlkZSBzcGlubmVyIGFuZCBzaG93IHJlc3VsdHNcbiAgICBzZWxmLiQoXCIuc3Bpbm5lclwiKS5oaWRlKCk7XG4gICAgc2VsZi4kKFwiLmFjdGl2aXR5LWJsb2NrXCIpLnNob3coKTtcbiAgfSxcblxuICBmZXRjaERhdGE6IGZ1bmN0aW9uIChzZWxmLCBkYXRhKSB7XG4gICAgJC5hamF4KHtcbiAgICAgIHVybDogJy9hcGkvYWRtaW4vbWV0cmljcycsXG4gICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHNlbGYuZGF0YSA9IGRhdGE7XG4gICAgICAgICQuYWpheCh7XG4gICAgICAgICAgdXJsOiAnL2FwaS9hZG1pbi9pbnRlcmFjdGlvbnMnLFxuICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihpbnRlcmFjdGlvbnMpIHtcbiAgICAgICAgICAgIGRhdGEuaW50ZXJhY3Rpb25zID0gaW50ZXJhY3Rpb25zO1xuICAgICAgICAgICAgaW50ZXJhY3Rpb25zLmNvdW50ID0gXyhpbnRlcmFjdGlvbnMpLnJlZHVjZShmdW5jdGlvbihzdW0sIHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHN1bSArIHZhbHVlO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICBzZWxmLnJlbmRlck1ldHJpY3Moc2VsZiwgZGF0YSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKHhociwgc3RhdHVzLCBlcnJvcikge1xuICAgICAgICAgICAgc2VsZi5oYW5kbGVFcnJvcihzZWxmLCB4aHIsIHN0YXR1cywgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZXJyb3I6IGZ1bmN0aW9uICh4aHIsIHN0YXR1cywgZXJyb3IpIHtcbiAgICAgICAgc2VsZi5oYW5kbGVFcnJvcihzZWxmLCB4aHIsIHN0YXR1cywgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICAgICQuYWpheCh7XG4gICAgICB1cmw6ICcvYXBpL2FkbWluL2FjdGl2aXRpZXMnLFxuICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBzZWxmLmRhdGEgPSBkYXRhO1xuICAgICAgICBzZWxmLnJlbmRlckFjdGl2aXRpZXMoc2VsZiwgZGF0YSk7XG4gICAgICB9LFxuICAgICAgZXJyb3I6IGZ1bmN0aW9uICh4aHIsIHN0YXR1cywgZXJyb3IpIHtcbiAgICAgICAgc2VsZi5oYW5kbGVFcnJvcihzZWxmLCB4aHIsIHN0YXR1cywgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIGhhbmRsZUVycm9yOiBmdW5jdGlvbiAoc2VsZiwgeGhyLCBzdGF0dXMsIGVycm9yKSB7XG4gICAgLy8gc2hvdyB0aGUgYWxlcnQgbWVzc2FnZSBhbmQgaGlkZSB0aGUgc3Bpbm5lclxuICAgIHNlbGYuJCgnLmFsZXJ0JykuaHRtbChlcnJvci5tZXNzYWdlIHx8IGVycm9yKTtcbiAgICBzZWxmLiQoJy5hbGVydCcpLnNob3coKTtcbiAgICBzZWxmLiQoJy5zcGlubmVyJykuaGlkZSgpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZG1pbkRhc2hib2FyZFZpZXc7XG4iLCJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uL21peGlucy91dGlsaXRpZXMnKTtcbnZhciBBZG1pblVzZXJWaWV3ID0gcmVxdWlyZSgnLi9hZG1pbl91c2VyX3ZpZXcnKTtcbnZhciBBZG1pblRhZ1ZpZXcgPSByZXF1aXJlKCcuL2FkbWluX3RhZ192aWV3Jyk7XG52YXIgQWRtaW5UYXNrVmlldyA9IHJlcXVpcmUoJy4vYWRtaW5fdGFza192aWV3Jyk7XG52YXIgQWRtaW5EYXNoYm9hcmRWaWV3ID0gcmVxdWlyZSgnLi9hZG1pbl9kYXNoYm9hcmRfdmlldycpO1xudmFyIEFkbWluTWFpblRlbXBsYXRlID0gcmVxdWlyZSgnLi4vdGVtcGxhdGVzL2FkbWluX21haW5fdGVtcGxhdGUuaHRtbCcpO1xuXG5cbnZhciBBZG1pbk1haW5WaWV3ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuXG4gIGV2ZW50czoge1xuICAgICdjbGljayAubGluay1hZG1pbicgICAgICAgICAgICAgOiAnbGluaydcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGEgPSB7XG5cbiAgICB9O1xuICAgIHZhciB0ZW1wbGF0ZSA9IF8udGVtcGxhdGUoQWRtaW5NYWluVGVtcGxhdGUpKGRhdGEpO1xuICAgIHRoaXMuJGVsLmh0bWwodGVtcGxhdGUpO1xuICAgIHRoaXMucm91dGVUYXJnZXQodGhpcy5vcHRpb25zLmFjdGlvbiB8fCAnJyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcm91dGVUYXJnZXQ6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgdGFyZ2V0ID0gJ2Rhc2hib2FyZCc7XG4gICAgfVxuICAgIHZhciB0ID0gJCgodGhpcy4kKFwiW2RhdGEtdGFyZ2V0PVwiICsgdGFyZ2V0ICsgXCJdXCIpKVswXSk7XG4gICAgLy8gcmVtb3ZlIGFjdGl2ZSBjbGFzc2VzXG4gICAgJCgkKHQucGFyZW50cygndWwnKVswXSkuZmluZCgnbGknKSkucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgIC8vIG1ha2UgdGhlIGN1cnJlbnQgbGluayBhY3RpdmVcbiAgICAkKHQucGFyZW50KCdsaScpWzBdKS5hZGRDbGFzcygnYWN0aXZlJyk7XG4gICAgaWYgKHRhcmdldCA9PSAndXNlcicpIHtcbiAgICAgIGlmICghdGhpcy5hZG1pblVzZXJWaWV3KSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZUFkbWluVXNlclZpZXcoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGlkZU90aGVycygpO1xuICAgICAgdGhpcy5hZG1pblVzZXJWaWV3LnJlbmRlcigpO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0ID09ICd0YWcnKSB7XG4gICAgICBpZiAoIXRoaXMuYWRtaW5UYWdWaWV3KSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZUFkbWluVGFnVmlldygpO1xuICAgICAgfVxuICAgICAgdGhpcy5oaWRlT3RoZXJzKCk7XG4gICAgICB0aGlzLmFkbWluVGFnVmlldy5yZW5kZXIoKTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldCA9PSAndGFza3MnKSB7XG4gICAgICBpZiAoIXRoaXMuYWRtaW5UYXNrVmlldykge1xuICAgICAgICB0aGlzLmluaXRpYWxpemVBZG1pblRhc2tWaWV3KCk7XG4gICAgICB9XG4gICAgICB0aGlzLmhpZGVPdGhlcnMoKTtcbiAgICAgIHRoaXMuYWRtaW5UYXNrVmlldy5yZW5kZXIoKTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldCA9PSAnZGFzaGJvYXJkJykge1xuICAgICAgaWYgKCF0aGlzLmFkbWluRGFzaGJvYXJkVmlldykge1xuICAgICAgICB0aGlzLmluaXRpYWxpemVBZG1pbkRhc2hib2FyZFZpZXcoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGlkZU90aGVycygpO1xuICAgICAgdGhpcy5hZG1pbkRhc2hib2FyZFZpZXcucmVuZGVyKCk7XG4gICAgfVxuICB9LFxuXG4gIGxpbms6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB2YXIgdCA9ICQoZS5jdXJyZW50VGFyZ2V0KTtcbiAgICB0aGlzLnJvdXRlVGFyZ2V0KHQuZGF0YSgndGFyZ2V0JykpO1xuICB9LFxuXG4gIGhpZGVPdGhlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLiQoXCIuYWRtaW4tY29udGFpbmVyXCIpLmhpZGUoKTtcbiAgfSxcblxuICBpbml0aWFsaXplQWRtaW5Vc2VyVmlldzogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmFkbWluVXNlclZpZXcpIHtcbiAgICAgIHRoaXMuYWRtaW5Vc2VyVmlldy5jbGVhbnVwKCk7XG4gICAgfVxuICAgIHRoaXMuYWRtaW5Vc2VyVmlldyA9IG5ldyBBZG1pblVzZXJWaWV3KHtcbiAgICAgIGVsOiBcIiNhZG1pbi11c2VyXCJcbiAgICB9KTtcbiAgfSxcblxuICBpbml0aWFsaXplQWRtaW5UYWdWaWV3OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuYWRtaW5UYWdWaWV3KSB7XG4gICAgICB0aGlzLmFkbWluVGFnVmlldy5jbGVhbnVwKCk7XG4gICAgfVxuICAgIHRoaXMuYWRtaW5UYWdWaWV3ID0gbmV3IEFkbWluVGFnVmlldyh7XG4gICAgICBlbDogXCIjYWRtaW4tdGFnXCJcbiAgICB9KTtcbiAgfSxcblxuICBpbml0aWFsaXplQWRtaW5UYXNrVmlldzogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmFkbWluVGFza1ZpZXcpIHtcbiAgICAgIHRoaXMuYWRtaW5UYXNrVmlldy5jbGVhbnVwKCk7XG4gICAgfVxuICAgIHRoaXMuYWRtaW5UYXNrVmlldyA9IG5ldyBBZG1pblRhc2tWaWV3KHtcbiAgICAgIGVsOiBcIiNhZG1pbi10YXNrXCJcbiAgICB9KTtcbiAgfSxcblxuICBpbml0aWFsaXplQWRtaW5EYXNoYm9hcmRWaWV3OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuYWRtaW5EYXNoYm9hcmRWaWV3KSB7XG4gICAgICB0aGlzLmFkbWluRGFzaGJvYXJkVmlldy5jbGVhbnVwKCk7XG4gICAgfVxuICAgIHRoaXMuYWRtaW5EYXNoYm9hcmRWaWV3ID0gbmV3IEFkbWluRGFzaGJvYXJkVmlldyh7XG4gICAgICBlbDogXCIjYWRtaW4tZGFzaGJvYXJkXCJcbiAgICB9KTtcbiAgfSxcblxuICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuYWRtaW5Vc2VyVmlldykgdGhpcy5hZG1pblVzZXJWaWV3LmNsZWFudXAoKTtcbiAgICBpZiAodGhpcy5hZG1pblRhZ1ZpZXcpIHRoaXMuYWRtaW5UYWdWaWV3LmNsZWFudXAoKTtcbiAgICBpZiAodGhpcy5hZG1pblRhc2tWaWV3KSB0aGlzLmFkbWluVGFza1ZpZXcuY2xlYW51cCgpO1xuICAgIGlmICh0aGlzLmFkbWluRGFzaGJvYXJkVmlldykgdGhpcy5hZG1pbkRhc2hib2FyZFZpZXcuY2xlYW51cCgpO1xuICAgIHJlbW92ZVZpZXcodGhpcyk7XG4gIH0sXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZG1pbk1haW5WaWV3O1xuIiwiXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgQWRtaW5UYWdUZW1wbGF0ZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy9hZG1pbl90YWdfdGVtcGxhdGUuaHRtbCcpO1xudmFyIFRhZ0ZhY3RvcnkgPSByZXF1aXJlKCcuLi8uLi8uLi9jb21wb25lbnRzL3RhZ19mYWN0b3J5Jyk7XG5cblxudmFyIEFkbWluVGFnVmlldyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcblxuICBldmVudHM6IHtcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy50YWdGYWN0b3J5ID0gbmV3IFRhZ0ZhY3RvcnkoKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdHlwZXMgPSBbXG4gICAgICAnYWdlbmN5JyxcbiAgICAgICdza2lsbCcsXG4gICAgICAndG9waWMnXG4gICAgXTtcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIHR5cGVzOiB0eXBlc1xuICAgIH07XG4gICAgdmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZShBZG1pblRhZ1RlbXBsYXRlKShkYXRhKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy4kZWwuaHRtbCh0ZW1wbGF0ZSk7XG4gICAgdGhpcy4kZWwuc2hvdygpO1xuXG4gICAgXyh0eXBlcykuZm9yRWFjaCh0aGlzLnRhZ1NlbGVjdG9yLCB0aGlzKTtcblxuICAgIEJhY2tib25lLmhpc3RvcnkubmF2aWdhdGUoJy9hZG1pbi90YWcnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICB0YWdTZWxlY3RvcjogZnVuY3Rpb24odHlwZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAkKCcjJyArIHR5cGUpLnNlbGVjdDIoe1xuICAgICAgcGxhY2Vob2xkZXI6ICdTZWFyY2ggZm9yIGEgdGFnJyxcbiAgICAgIG1pbmltdW1JbnB1dExlbmd0aDogMixcbiAgICAgIGZvcm1hdFJlc3VsdDogZnVuY3Rpb24gKG9iaiwgY29udGFpbmVyLCBxdWVyeSkge1xuICAgICAgICByZXR1cm4gb2JqLm5hbWU7XG4gICAgICB9LFxuICAgICAgZm9ybWF0U2VsZWN0aW9uOiBmdW5jdGlvbiAob2JqLCBjb250YWluZXIsIHF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiBvYmoubmFtZTtcbiAgICAgIH0sXG4gICAgICBjcmVhdGVTZWFyY2hDaG9pY2U6IGZ1bmN0aW9uICh0ZXJtLCB2YWx1ZXMpIHtcbiAgICAgICAgdmFyIHZhbHMgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlLnZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKHZhbHMuaW5kZXhPZih0ZXJtLnRvTG93ZXJDYXNlKCkpID49MCkgPyBmYWxzZSA6IHtcbiAgICAgICAgICB1bm1hdGNoZWQ6IHRydWUsXG4gICAgICAgICAgdGFnVHlwZTogdHlwZSxcbiAgICAgICAgICBpZDogdGVybSxcbiAgICAgICAgICB2YWx1ZTogdGVybSxcbiAgICAgICAgICBuYW1lOiBcIjxiPlwiK3Rlcm0rXCI8L2I+IDxpPmNsaWNrIHRvIGNyZWF0ZSBhIG5ldyB0YWcgd2l0aCB0aGlzIHZhbHVlPC9pPlwiXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgYWpheDoge1xuICAgICAgICB1cmw6ICcvYXBpL2FjL3RhZycsXG4gICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgIGRhdGE6IGZ1bmN0aW9uICh0ZXJtKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBxOiB0ZXJtXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzdWx0czogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICByZXR1cm4geyByZXN1bHRzOiBkYXRhIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KS5vbignY2hhbmdlJywgZnVuY3Rpb24oZSkge1xuICAgICAgdmFyICRlbCA9IHNlbGYuJChlLmN1cnJlbnRUYXJnZXQpO1xuICAgICAgc2VsZi50YWdGYWN0b3J5LmFkZFRhZ0VudGl0aWVzKGUuYWRkZWQsIHNlbGYsIGZ1bmN0aW9uKCkge1xuICAgICAgICAkKCcjJyArIHR5cGUpLnNlbGVjdDIoJ2RhdGEnLCBudWxsKTtcbiAgICAgICAgaWYgKGUuYWRkZWQgJiYgZS5hZGRlZC52YWx1ZSA9PT0gZS5hZGRlZC5pZCkge1xuICAgICAgICAgICRlbC5uZXh0KCcuZm9ybS1zdGF0dXMnKS50ZXh0KCdBZGRlZCB0YWc6ICcgKyBlLmFkZGVkLnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkZWwubmV4dCgnLmZvcm0tc3RhdHVzJykudGV4dCgnJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIGNsZWFudXA6IGZ1bmN0aW9uICgpIHtcbiAgICByZW1vdmVWaWV3KHRoaXMpO1xuICB9LFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQWRtaW5UYWdWaWV3O1xuIiwiXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgQWRtaW5UYXNrVGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvYWRtaW5fdGFza190ZW1wbGF0ZS5odG1sJyk7XG5cblxudmFyIEFkbWluVGFza1ZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG5cbiAgZXZlbnRzOiB7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuZGF0YSA9IHtcbiAgICAgIHBhZ2U6IDFcbiAgICB9O1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAkLmFqYXgoe1xuICAgICAgdXJsOiAnL2FwaS9hZG1pbi90YXNrcycsXG4gICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgc3VjY2VzczogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZShBZG1pblRhc2tUZW1wbGF0ZSkoZGF0YSk7XG4gICAgICAgIHNlbGYuJGVsLmh0bWwodGVtcGxhdGUpO1xuICAgICAgICBzZWxmLiRlbC5zaG93KCk7XG4gICAgICB9LFxuICAgICAgZXJyb3I6IGZ1bmN0aW9uICh4aHIsIHN0YXR1cywgZXJyb3IpIHtcbiAgICAgICAgc2VsZi5oYW5kbGVFcnJvcihzZWxmLCB4aHIsIHN0YXR1cywgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgQmFja2JvbmUuaGlzdG9yeS5uYXZpZ2F0ZSgnL2FkbWluL3Rhc2tzJyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgY2xlYW51cDogZnVuY3Rpb24gKCkge1xuICAgIHJlbW92ZVZpZXcodGhpcyk7XG4gIH0sXG5cbiAgaGFuZGxlRXJyb3I6IGZ1bmN0aW9uIChzZWxmLCB4aHIsIHN0YXR1cywgZXJyb3IpIHtcbiAgICAvLyBzaG93IHRoZSBhbGVydCBtZXNzYWdlIGFuZCBoaWRlIHRoZSBzcGlubmVyXG4gICAgc2VsZi4kKCcuYWxlcnQnKS5odG1sKGVycm9yLm1lc3NhZ2UgfHwgZXJyb3IpO1xuICAgIHNlbGYuJCgnLmFsZXJ0Jykuc2hvdygpO1xuICAgIHNlbGYuJCgnLnNwaW5uZXInKS5oaWRlKCk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQWRtaW5UYXNrVmlldztcbiIsIlxudmFyIEJvb3RzdHJhcCA9IHJlcXVpcmUoJ2Jvb3RzdHJhcCcpO1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vbWl4aW5zL3V0aWxpdGllcycpO1xudmFyIEFkbWluVXNlclBhc3N3b3JkID0gcmVxdWlyZSgnLi4vdGVtcGxhdGVzL2FkbWluX3VzZXJfcGFzc3dvcmQuaHRtbCcpO1xuXG5cbnZhciBBZG1pblVzZXJQYXNzd29yZFZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG5cbiAgZXZlbnRzOiB7XG4gICAgXCJibHVyICNuZXdQYXNzd29yZFwiICAgICAgICAgICAgIDogXCJ2XCIsXG4gICAgXCJzdWJtaXQgI3Jlc2V0LXBhc3N3b3JkXCIgICAgICAgIDogXCJwb3N0XCJcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBhZG1pbjogdGhpcy5vcHRpb25zLmFkbWluLFxuICAgICAgdTogdGhpcy5vcHRpb25zLnVzZXJcbiAgICB9XG4gICAgdmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZShBZG1pblVzZXJQYXNzd29yZCkoZGF0YSk7XG4gICAgdGhpcy4kZWwuaHRtbCh0ZW1wbGF0ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgdjogZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gdmFsaWRhdGUoZSk7XG4gIH0sXG5cbiAgcG9zdDogZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIC8vIHZhbGlkYXRlIGlucHV0IGZpZWxkc1xuICAgIHZhciB2YWxpZGF0ZUlkcyA9IFsnI25ld1Bhc3N3b3JkJ107XG4gICAgdmFyIGFib3J0ID0gZmFsc2U7XG4gICAgZm9yIChpIGluIHZhbGlkYXRlSWRzKSB7XG4gICAgICB2YXIgaUFib3J0ID0gdmFsaWRhdGUoeyBjdXJyZW50VGFyZ2V0OiB2YWxpZGF0ZUlkc1tpXSB9KTtcbiAgICAgIGFib3J0ID0gYWJvcnQgfHwgaUFib3J0O1xuICAgIH1cbiAgICBpZiAoYWJvcnQgPT09IHRydWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBleGVjdXRlIHBhc3N3b3JkIHJlc2V0XG4gICAgdmFyIGRhdGE7XG4gICAgZGF0YSA9IHtcbiAgICAgIGlkOiB0aGlzLm9wdGlvbnMudXNlci5pZCxcbiAgICAgIHBhc3N3b3JkOiB0aGlzLiQoXCIjbmV3UGFzc3dvcmRcIikudmFsKClcbiAgICB9O1xuXG4gICAgJC5hamF4KHtcbiAgICAgIHVybDogJy9hcGkvdXNlci9yZXNldFBhc3N3b3JkJyxcbiAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIC8vIGNvbGxhcHNlIG1vZGFsXG4gICAgICAgICAgJChcIiNyZXNldC1wYXNzd29yZC1tb2RhbFwiKS5tb2RhbCgnaGlkZScpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLnByb2Nlc3NFcnJvcih7IG1lc3NhZ2U6ICdBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSB0cnlpbmcgdG8gc2F2ZSB0aGUgcGFzc3dvcmQ6IHRoZSBzZXJ2ZXIgcHJvdmlkZWQgYW4gdW5leHBlY3RlZCByZXNwb25zZS4nfSlcbiAgICAgIH0sXG4gICAgICBlcnJvcjogZnVuY3Rpb24gKHhociwgc3RhdHVzLCBlcnJvcikge1xuICAgICAgICBzZWxmLnByb2Nlc3NFcnJvcih4aHIucmVzcG9uc2VKU09OKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICB9LFxuXG4gIHByb2Nlc3NFcnJvcjogZnVuY3Rpb24gKGUpIHtcbiAgICB0aGlzLiQoXCIuYWxlcnRcIikuaHRtbChlLm1lc3NhZ2UgfHwgZSk7XG4gICAgdGhpcy4kKFwiLmFsZXJ0XCIpLnNob3coKTtcbiAgfSxcblxuICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZG1pblVzZXJQYXNzd29yZFZpZXc7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgTW9kYWxDb21wb25lbnQgPSByZXF1aXJlKCcuLi8uLi8uLi9jb21wb25lbnRzL21vZGFsJyk7XG52YXIgQWRtaW5Vc2VyUGFzc3dvcmRWaWV3ID0gcmVxdWlyZSgnLi9hZG1pbl91c2VyX3Bhc3N3b3JkX3ZpZXcnKTtcbnZhciBBZG1pblVzZXJUZW1wbGF0ZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy9hZG1pbl91c2VyX3RlbXBsYXRlLmh0bWwnKTtcbnZhciBBZG1pblVzZXJUYWJsZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy9hZG1pbl91c2VyX3RhYmxlLmh0bWwnKTtcbnZhciBQYWdpbmF0ZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy9hZG1pbl9wYWdpbmF0ZS5odG1sJyk7XG52YXIgTG9naW5Db25maWcgPSByZXF1aXJlKCcuLi8uLi8uLi9jb25maWcvbG9naW4uanNvbicpO1xuXG5cbnZhciBBZG1pblVzZXJWaWV3ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuXG4gIGV2ZW50czoge1xuICAgIFwiY2xpY2sgYS5wYWdlXCIgICAgICAgICAgICAgIDogXCJjbGlja1BhZ2VcIixcbiAgICBcImNsaWNrIC5saW5rLWJhY2tib25lXCIgICAgICA6IGxpbmtCYWNrYm9uZSxcbiAgICBcImNsaWNrIC5hZG1pbi11c2VyLW1rYWRtaW5cIiA6IFwiYWRtaW5DcmVhdGVcIixcbiAgICBcImNsaWNrIC5hZG1pbi11c2VyLXJtYWRtaW5cIiA6IFwiYWRtaW5SZW1vdmVcIixcbiAgICBcImNsaWNrIC5hZG1pbi11c2VyLWVuYWJsZVwiICA6IFwiYWRtaW5FbmFibGVcIixcbiAgICBcImNsaWNrIC5hZG1pbi11c2VyLWRpc2FibGVcIiA6IFwiYWRtaW5EaXNhYmxlXCIsXG4gICAgXCJjbGljayAuYWRtaW4tdXNlci11bmxvY2tcIiAgOiBcImFkbWluVW5sb2NrXCIsXG4gICAgXCJjbGljayAuYWRtaW4tdXNlci1yZXNldHB3XCIgOiBcInJlc2V0UGFzc3dvcmRcIixcbiAgICBcImtleXVwICN1c2VyLWZpbHRlclwiICAgICAgICA6IFwiZmlsdGVyXCJcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5kYXRhID0ge1xuICAgICAgcGFnZTogMVxuICAgIH07XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIEJhY2tib25lLmhpc3RvcnkubmF2aWdhdGUoJy9hZG1pbi91c2VyJyk7XG4gICAgdGhpcy4kZWwuc2hvdygpO1xuICAgIGlmICh0aGlzLnJlbmRlcmVkID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICB1c2VyOiB3aW5kb3cuY2FjaGUuY3VycmVudFVzZXIsXG4gICAgICBsb2dpbjogTG9naW5Db25maWdcbiAgICB9O1xuICAgIHZhciB0ZW1wbGF0ZSA9IF8udGVtcGxhdGUoQWRtaW5Vc2VyVGVtcGxhdGUpKGRhdGEpO1xuICAgIHRoaXMuJGVsLmh0bWwodGVtcGxhdGUpO1xuICAgIHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuICAgIC8vIGZldGNoIHVzZXIgZGF0YVxuICAgIHRoaXMuZmV0Y2hEYXRhKHNlbGYsIHRoaXMuZGF0YSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcmVuZGVyVXNlcnM6IGZ1bmN0aW9uIChzZWxmLCBkYXRhKSB7XG4gICAgZGF0YS51cmxiYXNlID0gJy9hZG1pbi91c2Vycyc7XG4gICAgZGF0YS5xID0gZGF0YS5xIHx8ICcnO1xuICAgIC8vIGlmIHRoZSBsaW1pdCBvZiByZXN1bHRzIGNvbWluZyBiYWNrIGhhc24ndCBiZWVuIHNldCB5ZXRcbiAgICAvLyB1c2UgdGhlIHNlcnZlcidzIGRlZmF1bHRcbiAgICBpZiAoIXNlbGYubGltaXQpIHtcbiAgICAgIHNlbGYubGltaXQgPSBkYXRhLmxpbWl0O1xuICAgIH1cbiAgICBkYXRhLnRydWVMaW1pdCA9IHNlbGYubGltaXQ7XG4gICAgZGF0YS5sb2dpbiA9IExvZ2luQ29uZmlnO1xuICAgIGRhdGEudXNlciA9IHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlcjtcbiAgICAvLyByZW5kZXIgdGhlIHRhYmxlXG4gICAgdmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZShBZG1pblVzZXJUYWJsZSkoZGF0YSk7XG4gICAgLy8gcmVuZGVyIHRoZSBwYWdpbmF0aW9uXG4gICAgdmFyIHBhZ2luYXRlID0gXy50ZW1wbGF0ZShQYWdpbmF0ZSkoZGF0YSk7XG4gICAgc2VsZi4kKFwiI3VzZXItcGFnZVwiKS5odG1sKHBhZ2luYXRlKTtcbiAgICBzZWxmLiQoXCIudGFibGUtcmVzcG9uc2l2ZVwiKS5odG1sKHRlbXBsYXRlKTtcbiAgICBzZWxmLiQoXCIuYnRuXCIpLnRvb2x0aXAoKTtcbiAgICAvLyBoaWRlIHNwaW5uZXIgYW5kIHNob3cgcmVzdWx0c1xuICAgIHNlbGYuJChcIi5zcGlubmVyXCIpLmhpZGUoKTtcbiAgICBzZWxmLiQoXCIudGFibGUtcmVzcG9uc2l2ZVwiKS5zaG93KCk7XG4gICAgc2VsZi4kZWwuaTE4bigpO1xuICB9LFxuXG4gIGNsaWNrUGFnZTogZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgLy8gaWYgbWV0YSBvciBjb250cm9sIGlzIGhlbGQsIG9yIGlmIHRoZSBtaWRkbGUgbW91c2UgYnV0dG9uIGlzIHByZXNzZWQsXG4gICAgLy8gbGV0IHRoZSBsaW5rIHByb2Nlc3Mgbm9ybWFsbHkuXG4gICAgLy8gZWc6IG9wZW4gYSBuZXcgdGFiIG9yIHdpbmRvdyBiYXNlZCBvbiB0aGUgYnJvd3NlciBwcmVmc1xuICAgIGlmICgoZS5tZXRhS2V5ID09PSB0cnVlKSB8fCAoZS5jdHJsS2V5ID09PSB0cnVlKSB8fCAoZS53aGljaCA9PSAyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIC8vIGxvYWQgdGhpcyBwYWdlIG9mIGRhdGFcbiAgICB0aGlzLmZldGNoRGF0YShzZWxmLCB7XG4gICAgICBwYWdlOiAkKGUuY3VycmVudFRhcmdldCkuZGF0YSgncGFnZScpLFxuICAgICAgcTogJCgkKGUuY3VycmVudFRhcmdldCkucGFyZW50KCd1bCcpWzBdKS5kYXRhKCdmaWx0ZXInKSxcbiAgICAgIGxpbWl0OiB0aGlzLmxpbWl0XG4gICAgfSk7XG4gIH0sXG5cbiAgZmlsdGVyOiBmdW5jdGlvbiAoZSkge1xuICAgIC8vIGdldCB0aGUgaW5wdXQgYm94IHZhbHVlXG4gICAgdmFyIHZhbCA9ICQoZS5jdXJyZW50VGFyZ2V0KS52YWwoKS50cmltKCk7XG4gICAgLy8gaWYgdGhlIGZpbHRlciBpcyB0aGUgc2FtZSwgZG9uJ3QgZG8gYW55dGhpbmdcbiAgICBpZiAodmFsID09IHRoaXMucSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnEgPSB2YWw7XG4gICAgLy8gaGlkZSB0aGUgdGFibGUgYW5kIHNob3cgdGhlIHNwaW5uZXJcbiAgICB0aGlzLiQoXCIudGFibGUtcmVzcG9uc2l2ZVwiKS5oaWRlKCk7XG4gICAgdGhpcy4kKFwiLnNwaW5uZXJcIikuc2hvdygpO1xuICAgIC8vIGZldGNoIHRoaXMgcXVlcnksIHN0YXJ0aW5nIGZyb20gdGhlIGJlZ2lubmluZyBwYWdlXG4gICAgdGhpcy5mZXRjaERhdGEodGhpcywge1xuICAgICAgcTogdmFsXG4gICAgfSk7XG4gIH0sXG5cbiAgZmV0Y2hEYXRhOiBmdW5jdGlvbiAoc2VsZiwgZGF0YSkge1xuICAgIC8vIHBlcmZvcm0gdGhlIGFqYXggcmVxdWVzdCB0byBmZXRjaCB0aGUgdXNlciBsaXN0XG4gICAgJC5hamF4KHtcbiAgICAgIHVybDogJy9hcGkvYWRtaW4vdXNlcnMnLFxuICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBzZWxmLmRhdGEgPSBkYXRhO1xuICAgICAgICBzZWxmLnJlbmRlclVzZXJzKHNlbGYsIGRhdGEpO1xuICAgICAgfSxcbiAgICAgIGVycm9yOiBmdW5jdGlvbiAoeGhyLCBzdGF0dXMsIGVycm9yKSB7XG4gICAgICAgIHNlbGYuaGFuZGxlRXJyb3Ioc2VsZiwgeGhyLCBzdGF0dXMsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBoYW5kbGVFcnJvcjogZnVuY3Rpb24gKHNlbGYsIHhociwgc3RhdHVzLCBlcnJvcikge1xuICAgIC8vIHNob3cgdGhlIGFsZXJ0IG1lc3NhZ2UgYW5kIGhpZGUgdGhlIHNwaW5uZXJcbiAgICBzZWxmLiQoJy5hbGVydCcpLmh0bWwoZXJyb3IubWVzc2FnZSB8fCBlcnJvcik7XG4gICAgc2VsZi4kKCcuYWxlcnQnKS5zaG93KCk7XG4gICAgc2VsZi4kKCcuc3Bpbm5lcicpLmhpZGUoKTtcbiAgfSxcblxuICBhZG1pbkNyZWF0ZTogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHZhciB0ID0gJChlLmN1cnJlbnRUYXJnZXQpO1xuICAgIHZhciBpZCA9ICQodC5wYXJlbnRzKCd0cicpWzBdKS5kYXRhKCdpZCcpO1xuICAgIHRoaXMudXBkYXRlVXNlcih0LCB7XG4gICAgICBpZDogaWQsXG4gICAgICBpc0FkbWluOiB0cnVlLFxuICAgICAgdXJsOiAnL2FwaS9hZG1pbi9hZG1pbi8nICsgaWQgKyAnP2FjdGlvbj10cnVlJ1xuICAgIH0pO1xuICB9LFxuXG4gIGFkbWluUmVtb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIHQgPSAkKGUuY3VycmVudFRhcmdldCk7XG4gICAgdmFyIGlkID0gJCh0LnBhcmVudHMoJ3RyJylbMF0pLmRhdGEoJ2lkJyk7XG4gICAgdGhpcy51cGRhdGVVc2VyKHQsIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIGlzQWRtaW46IGZhbHNlLFxuICAgICAgdXJsOiAnL2FwaS9hZG1pbi9hZG1pbi8nICsgaWQgKyAnP2FjdGlvbj1mYWxzZSdcbiAgICB9KTtcbiAgfSxcblxuICBhZG1pbkVuYWJsZTogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHZhciB0ID0gJChlLmN1cnJlbnRUYXJnZXQpO1xuICAgIHZhciBpZCA9ICQodC5wYXJlbnRzKCd0cicpWzBdKS5kYXRhKCdpZCcpO1xuICAgIHRoaXMudXBkYXRlVXNlcih0LCB7XG4gICAgICBpZDogaWQsXG4gICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICB1cmw6ICcvYXBpL3VzZXIvZW5hYmxlLycgKyBpZFxuICAgIH0pO1xuICB9LFxuXG4gIGFkbWluRGlzYWJsZTogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHZhciB0ID0gJChlLmN1cnJlbnRUYXJnZXQpO1xuICAgIHZhciBpZCA9ICQodC5wYXJlbnRzKCd0cicpWzBdKS5kYXRhKCdpZCcpO1xuICAgIHRoaXMudXBkYXRlVXNlcih0LCB7XG4gICAgICBpZDogaWQsXG4gICAgICBkaXNhYmxlZDogdHJ1ZSxcbiAgICAgIHVybDogJy9hcGkvdXNlci9kaXNhYmxlLycgKyBpZFxuICAgIH0pO1xuICB9LFxuXG4gIGFkbWluVW5sb2NrOiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIHQgPSAkKGUuY3VycmVudFRhcmdldCk7XG4gICAgdmFyIGlkID0gJCh0LnBhcmVudHMoJ3RyJylbMF0pLmRhdGEoJ2lkJyk7XG4gICAgdGhpcy51cGRhdGVVc2VyKHQsIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIHBhc3N3b3JkQXR0ZW1wdHM6IDAsXG4gICAgICB1cmw6ICcvYXBpL2FkbWluL3VubG9jay8nICsgaWRcbiAgICB9KTtcblxuICB9LFxuXG4gIHVwZGF0ZVVzZXI6IGZ1bmN0aW9uICh0LCBkYXRhKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzcGlubmVyID0gJCgkKHQucGFyZW50KClbMF0pLmNoaWxkcmVuKCcuYnRuLXNwaW4nKVswXSlcbiAgICBzcGlubmVyLnNob3coKTtcbiAgICB0LmhpZGUoKTtcbiAgICBpZiAoZGF0YS51cmwpIHtcbiAgICAgICQuYWpheCh7XG4gICAgICAgIHVybDogZGF0YS51cmwsXG4gICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgLy8gaGlkZSB0aGUgc3Bpbm5lclxuICAgICAgICAgIHNwaW5uZXIuaGlkZSgpO1xuICAgICAgICAgIC8vIHNob3cgdGhlIG9wcG9zaXRlIGJ1dHRvblxuICAgICAgICAgIGlmIChkYXRhLmRpc2FibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAkKHQuc2libGluZ3MoXCIuYWRtaW4tdXNlci1lbmFibGVcIilbMF0pLnNob3coKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRhdGEuZGlzYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAkKHQuc2libGluZ3MoXCIuYWRtaW4tdXNlci1kaXNhYmxlXCIpWzBdKS5zaG93KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkYXRhLmlzQWRtaW4gPT09IHRydWUpIHtcbiAgICAgICAgICAgICQodC5zaWJsaW5ncyhcIi5hZG1pbi11c2VyLXJtYWRtaW5cIilbMF0pLnNob3coKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRhdGEuaXNBZG1pbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICQodC5zaWJsaW5ncyhcIi5hZG1pbi11c2VyLW1rYWRtaW5cIilbMF0pLnNob3coKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbiAoeGhyLCBzdGF0dXMsIGVycm9yKSB7XG4gICAgICAgICAgc2VsZi5oYW5kbGVFcnJvcihzZWxmLCB4aHIsIHN0YXR1cywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgcmVzZXRQYXNzd29yZDogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICh0aGlzLnBhc3N3b3JkVmlldykgeyB0aGlzLnBhc3N3b3JkVmlldy5jbGVhbnVwKCk7IH1cbiAgICBpZiAodGhpcy5tb2RhbENvbXBvbmVudCkgdGhpcy5tb2RhbENvbXBvbmVudC5jbGVhbnVwKCk7XG5cbiAgICB2YXIgdHIgPSAkKCQoZS5jdXJyZW50VGFyZ2V0KS5wYXJlbnRzKCd0cicpWzBdKTtcbiAgICB2YXIgdXNlciA9IHtcbiAgICAgIGlkOiB0ci5kYXRhKCdpZCcpLFxuICAgICAgbmFtZTogJCh0ci5maW5kKCd0ZC5hZG1pbi10YWJsZS1uYW1lJylbMF0pLnRleHQoKS50cmltKClcbiAgICB9O1xuXG4gICAgLy8gc2V0IHVwIHRoZSBtb2RhbFxuICAgIHRoaXMubW9kYWxDb21wb25lbnQgPSBuZXcgTW9kYWxDb21wb25lbnQoe1xuICAgICAgZWw6IFwiI3Jlc2V0LXBhc3N3b3JkLWNvbnRhaW5lclwiLFxuICAgICAgaWQ6IFwicmVzZXQtcGFzc3dvcmQtbW9kYWxcIixcbiAgICAgIG1vZGFsVGl0bGU6IFwiUmVzZXQgUGFzc3dvcmRcIlxuICAgIH0pLnJlbmRlcigpO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSB0aGUgdmlldyBpbnNpZGUgdGhlIG1vZGFsXG4gICAgdGhpcy5wYXNzd29yZFZpZXcgPSBuZXcgQWRtaW5Vc2VyUGFzc3dvcmRWaWV3KHtcbiAgICAgIGVsOiBcIi5tb2RhbC10ZW1wbGF0ZVwiLFxuICAgICAgdXNlcjogdXNlclxuICAgIH0pLnJlbmRlcigpO1xuXG4gICAgLy8gcmVuZGVyIHRoZSBtb2RhbFxuICAgIHRoaXMuJChcIiNyZXNldC1wYXNzd29yZC1tb2RhbFwiKS5tb2RhbCgnc2hvdycpO1xuICB9LFxuXG4gIGNsZWFudXA6IGZ1bmN0aW9uICgpIHtcbiAgICByZW1vdmVWaWV3KHRoaXMpO1xuICB9LFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQWRtaW5Vc2VyVmlldztcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciBpMThuT3B0aW9uID0gcmVxdWlyZSgnLi4vY29uZmlnL2kxOG4uanNvbicpO1xudmFyIEJyb3dzZUFwcCA9IHJlcXVpcmUoJy4vYnJvd3NlL2Jyb3dzZV9hcHAnKTtcblxuXG52YXIgaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJvdXRlciwgYnJvd3NlO1xuXG4gIC8vIEluaXRpYWxpemUgdGhlIGludGVybmF0aW9uYWxpemF0aW9uIGxpYnJhcnkgYW5kIHN0YXJ0IEJhY2tib25lIHdoZW4gaXQncyBkb25lIGluaXRpYWxpemluZy5cbiAgJC5pMThuLmluaXQoaTE4bk9wdGlvbiwgZnVuY3Rpb24odCkge1xuICAgIC8vIEhlcmUgd2UgYXJlIGdvaW5nIHRvIGZpcmUgdXAgYWxsIHRoZSByb3V0ZXJzIGZvciBvdXIgYXBwIHRvIGxpc3RlblxuICAgIC8vIGluIG9uIHRoZWlyIHJlc3BlY3RpdmUgYXBwbGljYXRpb25zLiAgV2UgYXJlIC10ZXN0aW5nLSB0aGlzIGZ1bmN0aW9uYWxpdHlcbiAgICAvLyBieSB1c2luZyB0aGUgcHJvZmlsZSBhcHBsaWNhdGlvbiBhcyBhIHN0YXJ0aW5nIHBvaW50ICh2ZXJ5IHNpbXBsZSwgMSByb3V0ZSkuXG4gICAgYnJvd3NlID0gQnJvd3NlQXBwLmluaXRpYWxpemUoKTtcblxuICAgIHJldHVybiBCYWNrYm9uZS5oaXN0b3J5LnN0YXJ0KHsgcHVzaFN0YXRlOiB0cnVlIH0pO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGluaXRpYWxpemU6IGluaXRpYWxpemVcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHRyPlxcbiAgPHRkPlxcbiAgICA8c3BhbiBjbGFzcz1cXFwiZmlsZS10YWcgYzMtYmcgd2hpdGVcXFwiPmZpbGU8L3NwYW4+XFxuICA8L3RkPlxcbiAgPHRkIGNsYXNzPVxcXCJhdHRhY2htZW50LW5hbWVcXFwiPlxcbiAgICA8YSBocmVmPVxcXCIvYXBpL2ZpbGUvZ2V0LzwlPSBhLmZpbGUuaWQgJT5cXFwiIGNsYXNzPVxcXCJmaWxlLWxpbmtcXFwiIGRhdGEtaWQ9XFxcIjwlPSBhLmZpbGUuaWQgJT5cXFwiPlxcbiAgICAgIDwlPSBhLmZpbGUubmFtZSAlPlxcbiAgICAgIDwlIGlmICh1c2VyICYmICgoYS51c2VySWQgPT0gYS51c2VySWQpIHx8IG93bmVyKSkgeyAlPlxcbiAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJmaWxlLWRlbGV0ZVxcXCIgZGF0YS1pZD1cXFwiPCU9IGEuaWQgJT5cXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1yZW1vdmVcXFwiPjwvaT48L2E+XFxuICAgICAgPCUgfSAlPlxcbiAgICAgIDxici8+XFxuICAgICAgPHRpbWUgY2xhc3M9XFxcInRpbWVhZ29cXFwiIGRhdGV0aW1lPVxcXCI8JS0gYS5jcmVhdGVkQXQgJT5cXFwiPjwlLSBhLmNyZWF0ZWRBdCAlPjwvdGltZT5cXG4gICAgPC9hPlxcbiAgPC90ZD5cXG4gIDx0ZCBjbGFzcz1cXFwiZmlsZS1wZXJzb25cXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJwcm9qZWN0LXBlb3BsZS1kaXZcXFwiIGRhdGEtdXNlcmlkPVxcXCI8JS0gYS51c2VySWQgJT5cXFwiPlxcbiAgICAgIDxpbWcgc3JjPVxcXCIvYXBpL3VzZXIvcGhvdG8vPCU9IGEudXNlcklkICU+XFxcIiBjbGFzcz1cXFwicHJvamVjdC1wZW9wbGVcXFwiIC8+XFxuICAgIDwvZGl2PlxcbiAgPC90ZD5cXG48L3RyPlxcblwiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImJveC1wYWQtbHIgYm9yZGVyLWJvdHRvbVxcXCI+XFxuICA8aDI+XFxuICAgIEF0dGFjaG1lbnRzXFxuICAgIDxkaXYgY2xhc3M9XFxcImJ0biBidG4tYzAgYnRuLXNtIGZpbGUtYWRkIGF0dGFjaG1lbnQtZmlsZWJ0biBmaWxlaW5wdXQtYnV0dG9uXFxcIiBzdHlsZT1cXFwiPCUgaWYgKCF1c2VyKSB7ICU+ZGlzcGxheTpub25lOzwlIH0gJT5cXFwiPlxcbiAgICAgIEFkZCBGaWxlXFxuICAgICAgPGlucHV0IGlkPVxcXCJhdHRhY2htZW50LWZpbGV1cGxvYWRcXFwiIHR5cGU9XFxcImZpbGVcXFwiIG5hbWU9XFxcImZpbGVzW11cXFwiIHRpdGxlPVxcXCJBdHRhY2ggRmlsZXNcXFwiPlxcbiAgICA8L2Rpdj5cXG4gIDwvaDI+XFxuPC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwiYXR0YWNobWVudC1maWxldXBsb2FkIGJveC1wYWQtbHIgYm94LXBhZC10XFxcIj5cXG4gIDxkaXYgc3R5bGU9XFxcImRpc3BsYXk6IG5vbmU7XFxcIiBjbGFzcz1cXFwicHJvZ3Jlc3MgcHJvZ3Jlc3Mtc3RyaXBlZCBhY3RpdmVcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJwcm9ncmVzcy1iYXJcXFwiIHN0eWxlPVxcXCJ3aWR0aDogMFxcXCI+PC9kaXY+XFxuICA8L2Rpdj5cXG48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJib3gtcGFkLWxyXFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcImZpbGUtdXBsb2FkLWFsZXJ0IGFsZXJ0IGFsZXJ0LXdhcm5pbmdcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIj5cXG4gICAgPHNwYW4+PC9zcGFuPlxcbiAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImNsb3NlXFxcIiBkYXRhLWRpc21pc3M9XFxcImFsZXJ0XFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+JnRpbWVzOzwvYnV0dG9uPlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwiYm94LXBhZC1sciBib3gtcGFkLXQgZmlsZS1saXN0XFxcIj5cXG4gIDx0YWJsZSBjbGFzcz1cXFwidGFibGUgdGFibGUtaG92ZXIgdGFibGUtY29uZGVuc2VkXFxcIj5cXG4gICAgPHRib2R5IGNsYXNzPVxcXCJhdHRhY2htZW50LXRib2R5XFxcIj5cXG4gICAgICA8dHIgY2xhc3M9XFxcImF0dGFjaG1lbnQtbm9uZVxcXCI+PHRkPk5vIEF0dGFjaG1lbnRzPC90ZD48L3RyPlxcbiAgICA8L3Rib2R5PlxcbiAgPC90YWJsZT5cXG48L2Rpdj5cXG5cIjtcbiIsIlxudmFyIEJvb3RzdHJhcCA9IHJlcXVpcmUoJ2Jvb3RzdHJhcCcpO1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIganFJZnJhbWUgPSByZXF1aXJlKCdibHVlaW1wLWZpbGUtdXBsb2FkL2pzL2pxdWVyeS5pZnJhbWUtdHJhbnNwb3J0Jyk7XG52YXIganFGVSA9IHJlcXVpcmUoJ2JsdWVpbXAtZmlsZS11cGxvYWQvanMvanF1ZXJ5LmZpbGV1cGxvYWQuanMnKTtcbnZhciBUaW1lQWdvID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vdmVuZG9yL2pxdWVyeS50aW1lYWdvJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vbWl4aW5zL3V0aWxpdGllcycpO1xudmFyIGFzeW5jID0gcmVxdWlyZSgnYXN5bmMnKTtcbnZhciBQb3BvdmVycyA9IHJlcXVpcmUoJy4uLy4uLy4uL21peGlucy9wb3BvdmVycycpO1xudmFyIEFJVGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvYXR0YWNobWVudF9pdGVtX3RlbXBsYXRlLmh0bWwnKTtcbnZhciBBU1RlbXBsYXRlID0gcmVxdWlyZSgnLi4vdGVtcGxhdGVzL2F0dGFjaG1lbnRfc2hvd190ZW1wbGF0ZS5odG1sJyk7XG5cblxudmFyIHBvcG92ZXJzID0gbmV3IFBvcG92ZXJzKCk7XG5cbnZhciBBdHRhY2htZW50U2hvd1ZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG5cbiAgZXZlbnRzOiB7XG4gICAgJ2NsaWNrIC5maWxlLWRlbGV0ZScgICAgICAgICAgICAgICAgOiAnZGVsZXRlQXR0YWNobWVudCcsXG4gICAgXCJtb3VzZWVudGVyIC5wcm9qZWN0LXBlb3BsZS1kaXZcIiAgICA6IHBvcG92ZXJzLnBvcG92ZXJQZW9wbGVPbixcbiAgICBcImNsaWNrIC5wcm9qZWN0LXBlb3BsZS1kaXZcIiAgICAgICAgIDogcG9wb3ZlcnMucG9wb3ZlckNsaWNrLFxuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmRhdGEgPSBvcHRpb25zLmRhdGE7XG4gICAgdGhpcy5hY3Rpb24gPSBvcHRpb25zLmFjdGlvbjtcbiAgICB0aGlzLmVkaXQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmFjdGlvbikge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hY3Rpb24gPT0gJ2VkaXQnKSB7XG4gICAgICAgIHRoaXMuZWRpdCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGluaXRpYWxpemVGaWxlczogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAkLmFqYXgoe1xuICAgICAgdXJsOiAnL2FwaS9hdHRhY2htZW50L2ZpbmRBbGxCeScgKyB0aGlzLm9wdGlvbnMudGFyZ2V0ICsgJ0lkLycgKyB0aGlzLm9wdGlvbnMuaWRcbiAgICB9KS5kb25lKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBpZiAoZGF0YSAmJiAoZGF0YS5sZW5ndGggPiAwKSkge1xuICAgICAgICAkKFwiLmF0dGFjaG1lbnQtbm9uZVwiKS5oaWRlKCk7XG4gICAgICB9XG4gICAgICBfLmVhY2goZGF0YSwgZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gc2VsZi5yZW5kZXJBdHRhY2htZW50KGYpO1xuICAgICAgICAkKFwiLmF0dGFjaG1lbnQtdGJvZHlcIikuYXBwZW5kKHRlbXBsYXRlKTtcbiAgICAgIH0pO1xuICAgICAgJChcInRpbWUudGltZWFnb1wiKS50aW1lYWdvKCk7XG4gICAgICBwb3BvdmVycy5wb3BvdmVyUGVvcGxlSW5pdChcIi5wcm9qZWN0LXBlb3BsZS1kaXZcIik7XG4gICAgfSk7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZUZpbGVVcGxvYWQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cblxuICAgICQoJyNhdHRhY2htZW50LWZpbGV1cGxvYWQnKS5maWxldXBsb2FkKHtcbiAgICAgIHVybDogXCIvYXBpL2ZpbGUvY3JlYXRlXCIsXG4gICAgICBkYXRhVHlwZTogJ3RleHQnLFxuICAgICAgYWNjZXB0RmlsZVR5cGVzOiAvKFxcLnxcXC8pKGdpZnxqcGU/Z3xwbmcpJC9pLFxuICAgICAgYWRkOiBmdW5jdGlvbiAoZSwgZGF0YSkge1xuICAgICAgICBzZWxmLiQoJy5hdHRhY2htZW50LWZpbGV1cGxvYWQgPiAucHJvZ3Jlc3MnKS5zaG93KCk7XG4gICAgICAgIGRhdGEuc3VibWl0KCk7XG4gICAgICB9LFxuICAgICAgcHJvZ3Jlc3NhbGw6IGZ1bmN0aW9uIChlLCBkYXRhKSB7XG4gICAgICAgIHZhciBwcm9ncmVzcyA9IHBhcnNlSW50KGRhdGEubG9hZGVkIC8gZGF0YS50b3RhbCAqIDEwMCwgMTApO1xuICAgICAgICBzZWxmLiQoJy5hdHRhY2htZW50LWZpbGV1cGxvYWQgLnByb2dyZXNzLWJhcicpLmNzcyhcbiAgICAgICAgICAnd2lkdGgnLFxuICAgICAgICAgIHByb2dyZXNzICsgJyUnXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgZG9uZTogZnVuY3Rpb24gKGUsIGRhdGEpIHtcbiAgICAgICAgLy8gZm9yIElFOC85IHRoYXQgdXNlIGlmcmFtZVxuICAgICAgICBpZiAoZGF0YS5kYXRhVHlwZSA9PSAnaWZyYW1lIHRleHQnKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IEpTT04ucGFyc2UoZGF0YS5yZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZvciBtb2Rlcm4gWEhSIGJyb3dzZXJzXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBKU09OLnBhcnNlKCQoZGF0YS5yZXN1bHQpLnRleHQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzdG9yZSBpZCBpbiB0aGUgZGF0YWJhc2Ugd2l0aCB0aGUgZmlsZVxuICAgICAgICB2YXIgYURhdGEgPSB7XG4gICAgICAgICAgZmlsZUlkOiByZXN1bHRbMF0uaWRcbiAgICAgICAgfTtcbiAgICAgICAgYURhdGFbc2VsZi5vcHRpb25zLnRhcmdldCArICdJZCddID0gc2VsZi5vcHRpb25zLmlkO1xuICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgIHVybDogJy9hcGkvYXR0YWNobWVudCcsXG4gICAgICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KGFEYXRhKSxcbiAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgfSkuZG9uZShmdW5jdGlvbiAoYXR0YWNobWVudCkge1xuICAgICAgICAgIHNlbGYuJCgnLmF0dGFjaG1lbnQtZmlsZXVwbG9hZCA+IC5wcm9ncmVzcycpLmhpZGUoKTtcbiAgICAgICAgICBzZWxmLnJlbmRlck5ld0F0dGFjaG1lbnQocmVzdWx0WzBdLCBhdHRhY2htZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZmFpbDogZnVuY3Rpb24gKGUsIGRhdGEpIHtcbiAgICAgICAgLy8gbm90aWZ5IHRoZSB1c2VyIHRoYXQgdGhlIHVwbG9hZCBmYWlsZWRcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBkYXRhLmVycm9yVGhyb3duO1xuICAgICAgICBzZWxmLiQoJy5hdHRhY2htZW50LWZpbGV1cGxvYWQgPiAucHJvZ3Jlc3MnKS5oaWRlKCk7XG4gICAgICAgIGlmIChkYXRhLmpxWEhSLnN0YXR1cyA9PSA0MTMpIHtcbiAgICAgICAgICBtZXNzYWdlID0gXCJUaGUgdXBsb2FkZWQgZmlsZSBleGNlZWRzIHRoZSBtYXhpbXVtIGZpbGUgc2l6ZS5cIjtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLiQoXCIuZmlsZS11cGxvYWQtYWxlcnQgPiBzcGFuXCIpLmh0bWwobWVzc2FnZSlcbiAgICAgICAgc2VsZi4kKFwiLmZpbGUtdXBsb2FkLWFsZXJ0XCIpLnNob3coKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIGRhdGEgPSB7XG4gICAgICB1c2VyOiB3aW5kb3cuY2FjaGUuY3VycmVudFVzZXJcbiAgICB9O1xuICAgIHZhciB0ZW1wbGF0ZSA9IF8udGVtcGxhdGUoQVNUZW1wbGF0ZSkoZGF0YSk7XG4gICAgdGhpcy4kZWwuaHRtbCh0ZW1wbGF0ZSk7XG4gICAgdGhpcy5pbml0aWFsaXplRmlsZVVwbG9hZCgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZUZpbGVzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcmVuZGVyQXR0YWNobWVudDogZnVuY3Rpb24gKGF0dGFjaG1lbnQpIHtcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIGE6IGF0dGFjaG1lbnQsXG4gICAgICB1c2VyOiB3aW5kb3cuY2FjaGUuY3VycmVudFVzZXIsXG4gICAgICBvd25lcjogdGhpcy5vcHRpb25zLm93bmVyXG4gICAgfTtcbiAgICB2YXIgdGVtcGwgPSBfLnRlbXBsYXRlKEFJVGVtcGxhdGUpKGRhdGEpO1xuICAgIHJldHVybiB0ZW1wbDtcbiAgfSxcblxuICByZW5kZXJOZXdBdHRhY2htZW50OiBmdW5jdGlvbiAoZmlsZSwgYXR0YWNobWVudCkge1xuICAgIGF0dGFjaG1lbnQuZmlsZSA9IGZpbGU7XG4gICAgdmFyIHRlbXBsID0gdGhpcy5yZW5kZXJBdHRhY2htZW50KGF0dGFjaG1lbnQpO1xuICAgICQoXCIuYXR0YWNobWVudC1ub25lXCIpLmhpZGUoKTtcbiAgICAvLyBwdXQgbmV3IGF0IHRoZSB0b3Agb2YgdGhlIGxpc3QgcmF0aGVyIHRoYW4gdGhlIGJvdHRvbVxuICAgICQoXCIuYXR0YWNobWVudC10Ym9keVwiKS5wcmVwZW5kKHRlbXBsKTtcbiAgICAkKFwidGltZS50aW1lYWdvXCIpLnRpbWVhZ28oKTtcbiAgICBwb3BvdmVycy5wb3BvdmVyUGVvcGxlSW5pdChcIi5wcm9qZWN0LXBlb3BsZS1kaXZcIik7XG4gIH0sXG5cbiAgZGVsZXRlQXR0YWNobWVudDogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgeyBlLnByZXZlbnREZWZhdWx0KCk7IH1cbiAgICAkLmFqYXgoe1xuICAgICAgdXJsOiAnL2FwaS9hdHRhY2htZW50LycgKyAkKGUuY3VycmVudFRhcmdldCkuZGF0YSgnaWQnKSxcbiAgICAgIHR5cGU6ICdERUxFVEUnLFxuICAgICAgc3VjY2VzczogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGZyb20gdGhlIERPTVxuICAgICAgICB2YXIgbGVuID0gJCgkKGUuY3VycmVudFRhcmdldCkucGFyZW50cygndGJvZHknKVswXSkuY2hpbGRyZW4oKS5sZW5ndGg7XG4gICAgICAgICQoZS5jdXJyZW50VGFyZ2V0KS5wYXJlbnRzKCd0cicpWzBdLnJlbW92ZSgpO1xuICAgICAgICBpZiAobGVuID09IDIpIHtcbiAgICAgICAgICAkKFwiLmF0dGFjaG1lbnQtbm9uZVwiKS5zaG93KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBdHRhY2htZW50U2hvd1ZpZXc7XG4iLCJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL21peGlucy91dGlsaXRpZXMnKTtcbnZhciBOYXZWaWV3ID0gcmVxdWlyZSgnLi4vbmF2L3ZpZXdzL25hdl92aWV3Jyk7XG52YXIgRm9vdGVyVmlldyA9IHJlcXVpcmUoJy4uL2Zvb3Rlci92aWV3cy9mb290ZXJfdmlldycpO1xudmFyIEJyb3dzZUxpc3RDb250cm9sbGVyID0gcmVxdWlyZSgnLi9jb250cm9sbGVycy9icm93c2VfbGlzdF9jb250cm9sbGVyJyk7XG52YXIgUHJvamVjdE1vZGVsID0gcmVxdWlyZSgnLi4vLi4vZW50aXRpZXMvcHJvamVjdHMvcHJvamVjdF9tb2RlbCcpO1xudmFyIFByb2plY3RTaG93Q29udHJvbGxlciA9IHJlcXVpcmUoJy4uL3Byb2plY3Qvc2hvdy9jb250cm9sbGVycy9wcm9qZWN0X3Nob3dfY29udHJvbGxlcicpO1xudmFyIFByb2ZpbGVTaG93Q29udHJvbGxlciA9IHJlcXVpcmUoJy4uL3Byb2ZpbGVzL3Nob3cvY29udHJvbGxlcnMvcHJvZmlsZV9zaG93X2NvbnRyb2xsZXInKTtcbnZhciBUYXNrTW9kZWwgPSByZXF1aXJlKCcuLi8uLi9lbnRpdGllcy90YXNrcy90YXNrX21vZGVsJyk7XG52YXIgVGFza1Nob3dDb250cm9sbGVyID0gcmVxdWlyZSgnLi4vdGFza3Mvc2hvdy9jb250cm9sbGVycy90YXNrX3Nob3dfY29udHJvbGxlcicpO1xudmFyIFRhc2tFZGl0Rm9ybVZpZXcgPSByZXF1aXJlKCcuLi90YXNrcy9lZGl0L3ZpZXdzL3Rhc2tfZWRpdF9mb3JtX3ZpZXcnKTtcbnZhciBBZG1pbk1haW5Db250cm9sbGVyID0gcmVxdWlyZSgnLi4vYWRtaW4vY29udHJvbGxlcnMvYWRtaW5fbWFpbl9jb250cm9sbGVyJyk7XG52YXIgSG9tZUNvbnRyb2xsZXIgPSByZXF1aXJlKCcuLi9ob21lL2NvbnRyb2xsZXJzL2hvbWVfY29udHJvbGxlcicpO1xuXG5cbnZhciBCcm93c2VSb3V0ZXIgPSBCYWNrYm9uZS5Sb3V0ZXIuZXh0ZW5kKHtcblxuICByb3V0ZXM6IHtcbiAgICAnJyAgICAgICAgICAgICAgICAgICA6ICdzaG93SG9tZScsXG4gICAgJ3Byb2plY3RzKC8pJyAgICAgICAgICAgICAgIDogJ2xpc3RQcm9qZWN0cycsXG4gICAgJ3Byb2plY3RzLzppZCgvKScgICAgICAgICAgIDogJ3Nob3dQcm9qZWN0JyxcbiAgICAncHJvamVjdHMvOmlkLzphY3Rpb24oLyknICAgOiAnc2hvd1Byb2plY3QnLFxuICAgICd0YXNrcygvKScgICAgICAgICAgICAgICAgICA6ICdsaXN0VGFza3MnLFxuICAgICd0YXNrcy86aWQoLyknICAgICAgICAgICAgICA6ICdzaG93VGFzaycsXG4gICAgJ3Rhc2tzLzppZC86YWN0aW9uKC8pJyAgICAgIDogJ3Nob3dUYXNrJyxcbiAgICAncHJvZmlsZSgvKScgICAgICAgICAgICAgICAgOiAnc2hvd1Byb2ZpbGUnLFxuICAgICdwcm9maWxlLzppZCgvKScgICAgICAgICAgICA6ICdzaG93UHJvZmlsZScsXG4gICAgJ3Byb2ZpbGUvOmlkKC8pLzphY3Rpb24nICAgIDogJ3Nob3dQcm9maWxlJyxcbiAgICAnYWRtaW4oLyknICAgICAgICAgICAgICAgICAgOiAnc2hvd0FkbWluJyxcbiAgICAnYWRtaW4oLyk6YWN0aW9uKC8pJyAgICAgICAgOiAnc2hvd0FkbWluJ1xuICB9LFxuXG4gIGRhdGE6IHsgc2F2ZWQ6IGZhbHNlIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubmF2VmlldyA9IG5ldyBOYXZWaWV3KHtcbiAgICAgIGVsOiAnLm5hdmlnYXRpb24nXG4gICAgfSkucmVuZGVyKCk7XG4gICAgdGhpcy5mb290ZXJWaWV3ID0gbmV3IEZvb3RlclZpZXcoe1xuICAgICAgZWw6ICcjZm9vdGVyJ1xuICAgIH0pLnJlbmRlcigpO1xuICB9LFxuXG4gIGNsZWFudXBDaGlsZHJlbjogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmJyb3dzZUxpc3RDb250cm9sbGVyKSB7IHRoaXMuYnJvd3NlTGlzdENvbnRyb2xsZXIuY2xlYW51cCgpOyB9XG4gICAgaWYgKHRoaXMucHJvamVjdFNob3dDb250cm9sbGVyKSB7IHRoaXMucHJvamVjdFNob3dDb250cm9sbGVyLmNsZWFudXAoKTsgfVxuICAgIGlmICh0aGlzLnByb2ZpbGVTaG93Q29udHJvbGxlcikgeyB0aGlzLnByb2ZpbGVTaG93Q29udHJvbGxlci5jbGVhbnVwKCk7IH1cbiAgICBpZiAodGhpcy50YXNrU2hvd0NvbnRyb2xsZXIpIHsgdGhpcy50YXNrU2hvd0NvbnRyb2xsZXIuY2xlYW51cCgpOyB9XG4gICAgaWYgKHRoaXMuaG9tZUNvbnRyb2xsZXIpIHsgdGhpcy5ob21lQ29udHJvbGxlci5jbGVhbnVwKCk7IH1cbiAgICB0aGlzLmRhdGEgPSB7IHNhdmVkOiBmYWxzZSB9O1xuICB9LFxuXG4gIHNob3dIb21lOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jbGVhbnVwQ2hpbGRyZW4oKTtcbiAgICB0aGlzLmhvbWVDb250cm9sbGVyID0gbmV3IEhvbWVDb250cm9sbGVyKHt0YXJnZXQ6ICdob21lJywgZWw6ICcjY29udGFpbmVyJywgcm91dGVyOiB0aGlzLCBkYXRhOiB0aGlzLmRhdGEgfSk7XG4gIH0sXG5cbiAgbGlzdFByb2plY3RzOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jbGVhbnVwQ2hpbGRyZW4oKTtcbiAgICB0aGlzLmJyb3dzZUxpc3RDb250cm9sbGVyID0gbmV3IEJyb3dzZUxpc3RDb250cm9sbGVyKHtcbiAgICAgIHRhcmdldDogJ3Byb2plY3RzJyxcbiAgICAgIGVsOiAnI2NvbnRhaW5lcicsXG4gICAgICBkYXRhOiB0aGlzLmRhdGFcbiAgICB9KTtcbiAgfSxcblxuICBsaXN0VGFza3M6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNsZWFudXBDaGlsZHJlbigpO1xuICAgIHRoaXMuYnJvd3NlTGlzdENvbnRyb2xsZXIgPSBuZXcgQnJvd3NlTGlzdENvbnRyb2xsZXIoe1xuICAgICAgdGFyZ2V0OiAndGFza3MnLFxuICAgICAgZWw6ICcjY29udGFpbmVyJyxcbiAgICAgIGRhdGE6IHRoaXMuZGF0YVxuICAgIH0pO1xuICB9LFxuXG4gIHNob3dQcm9qZWN0OiBmdW5jdGlvbiAoaWQsIGFjdGlvbikge1xuICAgIHRoaXMuY2xlYW51cENoaWxkcmVuKCk7XG4gICAgdmFyIG1vZGVsID0gbmV3IFByb2plY3RNb2RlbCgpO1xuICAgIG1vZGVsLnNldCh7IGlkOiBpZCB9KTtcbiAgICB0aGlzLnByb2plY3RTaG93Q29udHJvbGxlciA9IG5ldyBQcm9qZWN0U2hvd0NvbnRyb2xsZXIoeyBtb2RlbDogbW9kZWwsIHJvdXRlcjogdGhpcywgaWQ6IGlkLCBhY3Rpb246IGFjdGlvbiwgZGF0YTogdGhpcy5kYXRhIH0pO1xuICB9LFxuXG4gIHNob3dUYXNrOiBmdW5jdGlvbiAoaWQsIGFjdGlvbikge1xuICAgIHRoaXMuY2xlYW51cENoaWxkcmVuKCk7XG4gICAgdmFyIG1vZGVsID0gbmV3IFRhc2tNb2RlbCgpO1xuICAgIG1vZGVsLnNldCh7IGlkOiBpZCB9KTtcbiAgICB0aGlzLnRhc2tTaG93Q29udHJvbGxlciA9IG5ldyBUYXNrU2hvd0NvbnRyb2xsZXIoeyBtb2RlbDogbW9kZWwsIHJvdXRlcjogdGhpcywgaWQ6IGlkLCBhY3Rpb246IGFjdGlvbiwgZGF0YTogdGhpcy5kYXRhIH0pO1xuICB9LFxuXG4gIHNob3dQcm9maWxlOiBmdW5jdGlvbiAoaWQsIGFjdGlvbikge1xuICAgIHRoaXMuY2xlYW51cENoaWxkcmVuKCk7XG4gICAgLy8gbm9ybWFsaXplIGlucHV0XG4gICAgaWYgKGlkKSB7XG4gICAgICBpZCA9IGlkLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIGlmIChhY3Rpb24pIHtcbiAgICAgIGFjdGlvbiA9IGFjdGlvbi50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICAvLyBub3JtYWxpemUgYWN0aW9ucyB0aGF0IGRvbid0IGhhdmUgaWRzXG4gICAgaWYgKCFhY3Rpb24gJiYgaWQpIHtcbiAgICAgIGlmIChpZCA9PSAnZWRpdCcpIHtcbiAgICAgICAgYWN0aW9uID0gaWQ7XG4gICAgICAgIGlkID0gd2luZG93LmNhY2hlLmN1cnJlbnRVc2VyLmlkO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaWQgPT0gJ3NldHRpbmdzJykge1xuICAgICAgICBhY3Rpb24gPSBpZDtcbiAgICAgICAgaWQgPSB3aW5kb3cuY2FjaGUuY3VycmVudFVzZXIuaWQ7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucHJvZmlsZVNob3dDb250cm9sbGVyID0gbmV3IFByb2ZpbGVTaG93Q29udHJvbGxlcih7IGlkOiBpZCwgYWN0aW9uOiBhY3Rpb24sIGRhdGE6IHRoaXMuZGF0YSB9KTtcbiAgfSxcblxuICBzaG93QWRtaW46IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICB0aGlzLmNsZWFudXBDaGlsZHJlbigpO1xuICAgIHRoaXMuYWRtaW5NYWluQ29udHJvbGxlciA9IG5ldyBBZG1pbk1haW5Db250cm9sbGVyKHtcbiAgICAgIGVsOiBcIiNjb250YWluZXJcIixcbiAgICAgIGFjdGlvbjogYWN0aW9uXG4gICAgfSk7XG4gIH1cblxufSk7XG5cbnZhciBpbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcm91dGVyID0gbmV3IEJyb3dzZVJvdXRlcigpO1xuICByZXR1cm4gcm91dGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5pdGlhbGl6ZTogaW5pdGlhbGl6ZVxufTtcblxuIiwiXG52YXIgQm9vdHN0cmFwID0gcmVxdWlyZSgnYm9vdHN0cmFwJyk7XG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgQmFzZUNvbnRyb2xsZXIgPSByZXF1aXJlKCcuLi8uLi8uLi9iYXNlL2Jhc2VfY29udHJvbGxlcicpO1xudmFyIEJyb3dzZU1haW5WaWV3ID0gcmVxdWlyZSgnLi4vdmlld3MvYnJvd3NlX21haW5fdmlldycpO1xudmFyIFByb2plY3RzQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uLy4uL2VudGl0aWVzL3Byb2plY3RzL3Byb2plY3RzX2NvbGxlY3Rpb24nKTtcbnZhciBUYXNrc0NvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi8uLi9lbnRpdGllcy90YXNrcy90YXNrc19jb2xsZWN0aW9uJyk7XG52YXIgVGFza01vZGVsID0gcmVxdWlyZSgnLi4vLi4vLi4vZW50aXRpZXMvdGFza3MvdGFza19tb2RlbCcpO1xudmFyIFByb2plY3RGb3JtVmlldyA9IHJlcXVpcmUoJy4uLy4uL3Byb2plY3QvbmV3L3ZpZXdzL3Byb2plY3RfbmV3X2Zvcm1fdmlldycpO1xudmFyIFRhc2tGb3JtVmlldyA9IHJlcXVpcmUoJy4uLy4uL3Rhc2tzL25ldy92aWV3cy90YXNrX2Zvcm1fdmlldycpO1xudmFyIE1vZGFsV2l6YXJkQ29tcG9uZW50ID0gcmVxdWlyZSgnLi4vLi4vLi4vY29tcG9uZW50cy9tb2RhbF93aXphcmQnKTtcbnZhciBNb2RhbENvbXBvbmVudCA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbXBvbmVudHMvbW9kYWwnKTtcblxuXG5Ccm93c2UgPSB7fTtcblxuQnJvd3NlLkxpc3RDb250cm9sbGVyID0gQmFzZUNvbnRyb2xsZXIuZXh0ZW5kKHtcblxuICBldmVudHM6IHtcbiAgICBcImNsaWNrIC5saW5rLWJhY2tib25lXCIgIDogbGlua0JhY2tib25lLFxuICAgIFwiY2xpY2sgLnByb2plY3QtYmFja2dyb3VuZC1pbWFnZVwiIDogXCJzaG93UHJvamVjdFwiLFxuICAgIFwiY2xpY2sgLnRhc2stYm94XCIgICAgICAgOiBcInNob3dUYXNrXCIsXG4gICAgXCJjbGljayAuYWRkLXByb2plY3RcIiAgICA6IFwiYWRkUHJvamVjdFwiLFxuICAgIFwiY2xpY2sgLmFkZC1vcHBvcnR1bml0eVwiOiBcImFkZFRhc2tcIlxuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICggb3B0aW9ucyApIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgLy8gdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnRhcmdldCA9IG9wdGlvbnMudGFyZ2V0O1xuICAgIHRoaXMuZmlyZVVwQ29sbGVjdGlvbigpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZVZpZXcoKTtcblxuICAgIHRoaXMuY29sbGVjdGlvbi50cmlnZ2VyKCdicm93c2U6JyArIHRoaXMudGFyZ2V0ICsgXCI6ZmV0Y2hcIik7XG5cbiAgICB0aGlzLmxpc3RlblRvKHRoaXMucHJvamVjdHNDb2xsZWN0aW9uLCBcInByb2plY3Q6c2F2ZTpzdWNjZXNzXCIsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAvLyBoaWRlIHRoZSBtb2RhbFxuICAgICAgJCgnI2FkZFByb2plY3QnKS5iaW5kKCdoaWRkZW4uYnMubW9kYWwnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgQmFja2JvbmUuaGlzdG9yeS5uYXZpZ2F0ZSgncHJvamVjdHMvJyArIGRhdGEuYXR0cmlidXRlcy5pZCwgeyB0cmlnZ2VyOiB0cnVlIH0pO1xuICAgICAgfSkubW9kYWwoJ2hpZGUnKTtcbiAgICB9KTtcblxuICAgIHRoaXMubGlzdGVuVG8odGhpcy50YXNrc0NvbGxlY3Rpb24sIFwidGFzazpzYXZlOnN1Y2Nlc3NcIiwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIC8vIGhpZGUgdGhlIG1vZGFsXG4gICAgICAkKCcjYWRkVGFzaycpLmJpbmQoJ2hpZGRlbi5icy5tb2RhbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBCYWNrYm9uZS5oaXN0b3J5Lm5hdmlnYXRlKCd0YXNrcy8nICsgZGF0YSwgeyB0cmlnZ2VyOiB0cnVlIH0pO1xuICAgICAgfSkubW9kYWwoJ2hpZGUnKTtcbiAgICB9KTtcblxuICB9LFxuXG4gIGluaXRpYWxpemVWaWV3OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuYnJvd3NlTWFpblZpZXcpIHtcbiAgICAgIHRoaXMuYnJvd3NlTWFpblZpZXcuY2xlYW51cCgpO1xuICAgIH1cbiAgICB0aGlzLmJyb3dzZU1haW5WaWV3ID0gbmV3IEJyb3dzZU1haW5WaWV3KHtcbiAgICAgIGVsOiBcIiNjb250YWluZXJcIixcbiAgICAgIHRhcmdldDogdGhpcy50YXJnZXQsXG4gICAgICBjb2xsZWN0aW9uOiB0aGlzLmNvbGxlY3Rpb25cbiAgICB9KS5yZW5kZXIoKTtcbiAgfSxcblxuICBmaXJlVXBDb2xsZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMucHJvamVjdHNDb2xsZWN0aW9uID0gbmV3IFByb2plY3RzQ29sbGVjdGlvbigpO1xuICAgIHRoaXMudGFza3NDb2xsZWN0aW9uID0gbmV3IFRhc2tzQ29sbGVjdGlvbigpO1xuICAgIGlmICh0aGlzLnRhcmdldCA9PSAncHJvamVjdHMnKSB7XG4gICAgICB0aGlzLmNvbGxlY3Rpb24gPSB0aGlzLnByb2plY3RzQ29sbGVjdGlvbjtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy50YXJnZXQgPT0gJ3Rhc2tzJykge1xuICAgICAgdGhpcy5jb2xsZWN0aW9uID0gdGhpcy50YXNrc0NvbGxlY3Rpb247XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5jb2xsZWN0aW9uID0gbmV3IFByb2ZpbGVzQ29sbGVjdGlvbigpO1xuICAgIH1cbiAgICB0aGlzLmxpc3RlblRvT25jZSh0aGlzLmNvbGxlY3Rpb24sICdicm93c2U6JyArIHRoaXMudGFyZ2V0ICsgXCI6ZmV0Y2hcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5jb2xsZWN0aW9uLmZldGNoKHtcbiAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICBzZWxmLmNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuICAgICAgICAgIHNlbGYuYnJvd3NlTWFpblZpZXcucmVuZGVyTGlzdChzZWxmLmNvbGxlY3Rpb24udG9KU09OKCkpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH0sXG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy89IEJFR0lOIENMQVNTIE1FVEhPRFNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgc2hvd1Byb2plY3Q6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB2YXIgaWQgPSAkKCQoZS5jdXJyZW50VGFyZ2V0KS5wYXJlbnRzKCdsaS5wcm9qZWN0LWJveCcpWzBdKS5kYXRhKCdpZCcpO1xuICAgIEJhY2tib25lLmhpc3RvcnkubmF2aWdhdGUoJ3Byb2plY3RzLycgKyBpZCwgeyB0cmlnZ2VyOiB0cnVlIH0pO1xuICB9LFxuXG4gIHNob3dUYXNrOiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIGlkID0gJChlLmN1cnJlbnRUYXJnZXQpLmRhdGEoJ2lkJykgfHwgJCgkKGUuY3VycmVudFRhcmdldCkucGFyZW50cygnbGkudGFzay1ib3gnKVswXSkuZGF0YSgnaWQnKTtcbiAgICBCYWNrYm9uZS5oaXN0b3J5Lm5hdmlnYXRlKCd0YXNrcy8nICsgaWQsIHsgdHJpZ2dlcjogdHJ1ZSB9KTtcbiAgfSxcblxuICBhZGRQcm9qZWN0OiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBpZiAodGhpcy5wcm9qZWN0Rm9ybVZpZXcpIHRoaXMucHJvamVjdEZvcm1WaWV3LmNsZWFudXAoKTtcbiAgICBpZiAodGhpcy5tb2RhbENvbXBvbmVudCkgdGhpcy5tb2RhbENvbXBvbmVudC5jbGVhbnVwKCk7XG5cbiAgICB0aGlzLm1vZGFsQ29tcG9uZW50ID0gbmV3IE1vZGFsQ29tcG9uZW50KHtcbiAgICAgIGVsOiBcIi53cmFwcGVyLWFkZFByb2plY3RcIixcbiAgICAgIGlkOiBcImFkZFByb2plY3RcIixcbiAgICAgIG1vZGFsVGl0bGU6IFwiQWRkIFwiICsgaTE4bi50KFwiUHJvamVjdFwiKVxuICAgIH0pLnJlbmRlcigpO1xuXG4gICAgdGhpcy5wcm9qZWN0Rm9ybVZpZXcgPSBuZXcgUHJvamVjdEZvcm1WaWV3KHtcbiAgICAgIGVsOiBcIi5tb2RhbC10ZW1wbGF0ZVwiLFxuICAgICAgY29sbGVjdGlvbjogdGhpcy5wcm9qZWN0c0NvbGxlY3Rpb25cbiAgICB9KS5yZW5kZXIoKTtcblxuICB9LFxuXG4gIGFkZFRhc2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIGlmICh0aGlzLnRhc2tGb3JtVmlldykgdGhpcy50YXNrRm9ybVZpZXcuY2xlYW51cCgpO1xuICAgIGlmICh0aGlzLm1vZGFsV2l6YXJkQ29tcG9uZW50KSB0aGlzLm1vZGFsV2l6YXJkQ29tcG9uZW50LmNsZWFudXAoKTtcblxuICAgIHRoaXMudGFza01vZGVsID0gbmV3IFRhc2tNb2RlbCgpO1xuICAgIHRoaXMubW9kYWxXaXphcmRDb21wb25lbnQgPSBuZXcgTW9kYWxXaXphcmRDb21wb25lbnQoe1xuICAgICAgZWw6IFwiLndyYXBwZXItYWRkVGFza1wiLFxuICAgICAgaWQ6IFwiYWRkVGFza1wiLFxuICAgICAgZHJhZnQ6IHRydWUsXG4gICAgICBtb2RhbFRpdGxlOiAnTmV3ICcgKyBpMThuLnQoJ09wcG9ydHVuaXR5JyksXG4gICAgICBtb2RlbDogdGhpcy50YXNrTW9kZWwsXG4gICAgICBjb2xsZWN0aW9uOiB0aGlzLnRhc2tzQ29sbGVjdGlvbixcbiAgICAgIG1vZGVsTmFtZTogJ3Rhc2snLFxuICAgICAgZGF0YTogZnVuY3Rpb24gKHBhcmVudCkgeyByZXR1cm4ge1xuICAgICAgICB0aXRsZTogcGFyZW50LiQoXCIjdGFzay10aXRsZVwiKS52YWwoKSxcbiAgICAgICAgZGVzY3JpcHRpb246IHBhcmVudC4kKFwiI3Rhc2stZGVzY3JpcHRpb25cIikudmFsKCksXG4gICAgICAgIC8vIHRoZXNlIHRhc2tzIGFyZSBvcnBoYW5lZFxuICAgICAgICBwcm9qZWN0SWQ6IG51bGxcbiAgICAgIH0gfVxuICAgIH0pLnJlbmRlcigpO1xuXG4gICAgdGhpcy50YXNrRm9ybVZpZXcgPSBuZXcgVGFza0Zvcm1WaWV3KHtcbiAgICAgIGVsOiBcIiNhZGRUYXNrIC5tb2RhbC1ib2R5XCIsXG4gICAgICBwcm9qZWN0SWQ6IG51bGwsXG4gICAgICBtb2RlbDogdGhpcy50YXNrTW9kZWwsXG4gICAgICB0YXNrczogdGhpcy50YXNrc0NvbGxlY3Rpb25cbiAgICB9KS5yZW5kZXIoKTtcbiAgICB0aGlzLm1vZGFsV2l6YXJkQ29tcG9uZW50LnNldENoaWxkVmlldyh0aGlzLnRhc2tGb3JtVmlldyk7XG4gICAgdGhpcy5tb2RhbFdpemFyZENvbXBvbmVudC5zZXROZXh0KHRoaXMudGFza0Zvcm1WaWV3LmNoaWxkTmV4dCk7XG4gICAgdGhpcy5tb2RhbFdpemFyZENvbXBvbmVudC5zZXRTdWJtaXQodGhpcy50YXNrRm9ybVZpZXcuY2hpbGROZXh0KTtcbiAgfSxcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy89IFVUSUxJVFkgTUVUSE9EU1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgY2xlYW51cDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMudGFza0Zvcm1WaWV3KSB7IHRoaXMudGFza0Zvcm1WaWV3LmNsZWFudXAoKTsgfVxuICAgIGlmICh0aGlzLm1vZGFsV2l6YXJkQ29tcG9uZW50KSB7IHRoaXMubW9kYWxXaXphcmRDb21wb25lbnQuY2xlYW51cCgpOyB9XG4gICAgaWYgKHRoaXMucHJvamVjdEZvcm1WaWV3KSB7IHRoaXMucHJvamVjdEZvcm1WaWV3LmNsZWFudXAoKTsgfVxuICAgIGlmICh0aGlzLm1vZGFsQ29tcG9uZW50KSB7IHRoaXMubW9kYWxDb21wb25lbnQuY2xlYW51cCgpOyB9XG4gICAgaWYgKHRoaXMuYnJvd3NlTWFpblZpZXcpIHsgdGhpcy5icm93c2VNYWluVmlldy5jbGVhbnVwKCk7IH1cbiAgICByZW1vdmVWaWV3KHRoaXMpO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJyb3dzZS5MaXN0Q29udHJvbGxlcjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJ3cmFwcGVyLWFkZFByb2plY3RcXFwiPjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcIndyYXBwZXItYWRkVGFza1xcXCI+PC9kaXY+XFxuXFxuPGRpdiBjbGFzcz1cXFwicm93IHNlYXJjaC1yb3dcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTMgY29sLW1kLXB1c2gtOSBicm93c2UtYnV0dG9uc1xcXCI+XFxuICAgIDwlIGlmICh1aS5wcm9qZWN0LnNob3cpIHsgJT5cXG4gICAgPGEgaHJlZj1cXFwiI2FkZFByb2plY3RcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWMyIGFkZC1wcm9qZWN0XFxcIiBkYXRhLXRvZ2dsZT1cXFwibW9kYWxcXFwiIGRhdGEtYmFja2Ryb3A9XFxcInN0YXRpY1xcXCIgc3R5bGU9XFxcIjwlIGlmICghdXNlcikgeyAlPmRpc3BsYXk6IG5vbmU7PCUgfSAlPlxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXBsdXNcXFwiPjwvaT4gPHNwYW4gZGF0YS1pMThuPVxcXCJQcm9qZWN0XFxcIj5Qcm9qZWN0PC9zcGFuPjwvYT5cXG4gICAgPCUgfSAlPlxcbiAgICA8YSBocmVmPVxcXCIjYWRkVGFza1xcXCIgY2xhc3M9XFxcImJ0biBidG4tYzIgYWRkLW9wcG9ydHVuaXR5XFxcIiBkYXRhLXRvZ2dsZT1cXFwibW9kYWxcXFwiIGRhdGEtYmFja2Ryb3A9XFxcInN0YXRpY1xcXCIgc3R5bGU9XFxcIjwlIGlmICghdXNlcikgeyAlPmRpc3BsYXk6IG5vbmU7PCUgfSAlPlxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXBsdXNcXFwiPjwvaT4gPHNwYW4gZGF0YS1pMThuPVxcXCJUYXNrXFxcIj5PcHBvcnR1bml0eTwvc3Bhbj48L2E+XFxuICA8L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcImNvbC1tZC05IGNvbC1tZC1wdWxsLTNcXFwiPlxcbiAgICA8Zm9ybSBjbGFzcz1cXFwiZm9ybS1ob3Jpem9udGFsXFxcIiByb2xlPVxcXCJmb3JtXFxcIiBpZD1cXFwic2VhcmNoLWZvcm1cXFwiPlxcblxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXAgcm93XFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1zbS0xMCBjb2wtbWQtMTAgY29sLWxnLTkgaW5wdXQtc2VhcmNoXFxcIj5cXG4gICAgICAgICAgPGlucHV0IHR5cGU9XFxcImhpZGRlblxcXCIgaWQ9XFxcInNlYXJjaFxcXCIgdGl0bGU9XFxcIlNlYXJjaFxcXCIgc3R5bGU9XFxcIndpZHRoOiAxMDAlXFxcIi8+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1zbS0yIGNvbC1tZC0yIGNvbC1sZy0zIGJ0bi1zZWFyY2hcXFwiPlxcbiAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwic3VibWl0XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1jMVxcXCIgdGl0bGU9XFxcIlNlYXJjaFxcXCIgdmFsdWU9XFxcIlNlYXJjaFxcXCIvPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuXFxuICAgIDwvZm9ybT5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuXFxuICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMyBjb2wtbWQtcHVzaC05IGJveFxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImJvcmRlci1ib3R0b20gYm94LXBhZC1sclxcXCI+XFxuICAgICAgPGgyPkZpbHRlcnM8L2gyPlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiYm94LXBhZC10XFxcIj5cXG4gICAgICA8JSBpZiAoIHRhcmdldCA9PSBcXFwidGFza3NcXFwiICkgeyU+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiYm94LXBhZC1sclxcXCIgaWQ9XFxcInN0YXRlRmlsdGVyc1xcXCI+XFxuICAgICAgICA8JSBfLmVhY2godWkuc3RhdGVzLCBmdW5jdGlvbiAodCkgeyAlPlxcbiAgICAgICAgICA8bGFiZWwgY2xhc3M9XFxcIjwlIGlmICggdC52YWx1ZSA9PSBcXFwiZHJhZnRcXFwiICkgeyAlPmhpZGRlbiBkcmFmdC1maWx0ZXI8JSB9ICU+XFxcIj5cXG4gICAgICAgICAgICA8aW5wdXQgdHlwZT0nY2hlY2tib3gnIG5hbWU9J3N0YXRlPCUtIHQubGFiZWwgJT4nIGNsYXNzPSdzdGF0ZUZpbHRlcicgdmFsdWU9JzwlLSB0LnZhbHVlICU+J1xcbiAgICAgICAgICAgIDwlIGlmICggdC52YWx1ZSA9PSBcXFwib3BlblxcXCIgKSB7JT5cXG4gICAgICAgICAgICAgIDwlLSBjaGVja2VkPVxcXCJjaGVja2VkXFxcIiAlPlxcbiAgICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgICA+IDwlLSB0LmxhYmVsICU+XFxuICAgICAgICAgIDwvbGFiZWw+XFxuICAgICAgICA8JSB9KTsgJT5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8JSB9ICU+XFxuICAgICAgPGRpdiBpZD1cXFwic2VhcmNoLXByb2pzLXdyYXBwZXJcXFwiIGNsYXNzPVxcXCJib3gtcGFkLWxyXFxcIj5cXG4gICAgICAgIDx1bCBpZD1cXFwic2VhcmNoLXByb2pzXFxcIiBjbGFzcz1cXFwibmF2IG5hdi1waWxscyBuYXYtc3RhY2tlZCBuYXYtc2VhcmNoXFxcIj5cXG4gICAgICAgIDwvdWw+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiYm94LXBhZC1sclxcXCI+XFxuICAgICAgICA8dWwgaWQ9XFxcInNlYXJjaC10YWdzXFxcIiBjbGFzcz1cXFwibmF2IG5hdi1waWxscyBuYXYtc3RhY2tlZCBuYXYtc2VhcmNoXFxcIj5cXG4gICAgICAgIDwvdWw+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiYm94LXBhZC1sciBzZWFyY2gtY2xlYXJcXFwiIHN0eWxlPVxcXCJkaXNwbGF5OiBub25lO1xcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJhbGlnbi1yaWdodFxcXCI+XFxuICAgICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGlkPVxcXCJzZWFyY2gtY2xlYXJcXFwiIGNsYXNzPVxcXCJidG4gYnRuLXNtIGJ0bi1jMFxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXJlbW92ZVxcXCI+PC9pPiBDbGVhciBTZWFyY2ggQ3JpdGVyaWE8L2E+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG5cXG4gIDxkaXYgY2xhc3M9XFxcImNvbC1tZC05IGNvbC1tZC1wdWxsLTNcXFwiPlxcbiAgICA8ZGl2IGlkPVxcXCJicm93c2Utc2VhcmNoLXNwaW5uZXJcXFwiIGNsYXNzPVxcXCJmdWxsd2lkdGggdGV4dC1jZW50ZXJcXFwiPlxcbiAgICAgIExvYWRpbmcuLi4gPGkgY2xhc3M9XFxcImZhIGZhLXNwaW5uZXIgZmEtc3BpblxcXCI+PC9pPlxcbiAgICA8L2Rpdj5cXG4gICAgPHVsIGlkPVxcXCJicm93c2UtbGlzdFxcXCI+XFxuICAgIDwvdWw+XFxuICA8L2Rpdj5cXG5cXG48L2Rpdj5cXG5cIjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8bGkgZGF0YS1pZD1cXFwiPCU9IGRhdGEuaWQgJT5cXFwiPlxcbiAgPCU9IGZvcm1hdCAlPlxcbiAgPGRpdiBjbGFzcz1cXFwicHVsbC1yaWdodFxcXCI+XFxuICAgIDxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJzZWFyY2gtdGFnLXJlbW92ZVxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXJlbW92ZVxcXCI+PC9pPjwvYT5cXG4gIDwvZGl2PlxcbjwvbGk+XFxuXCI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHNwYW4gZGF0YS1pMThuPSdbaHRtbF1ub1NlYXJjaFJlc3VsdHMudGV4dCc+XFxuPGgyPk9vcHMgd2UgZGlkbid0IGZpbmQgYW55IHJlc3VsdHM8L2gyPlxcbjxwPk1heWJlIHlvdXIgc2VhcmNoIHdhcyB0b28gc3BlY2lmaWMuIFlvdSBjb3VsZCB0cnkgaW5jbHVkaW5nIG1vcmUgZmlsdGVycyBsaWtlIDxiPkNvbXBsZXRlZDwvYj4gb3IgPGI+QXJjaGl2ZWQ8L2I+LiBNYXliZSB0aGVyZSBhcmUgdG9vIG1hbnkgc2VhcmNoIHRlcm1zLCB0cnkgcmVtb3Zpbmcgc29tZSBvciB1c2luZyBtb3JlIGdlbmVyYWwgdGVybXMuPC9wPlxcbjxwPlN0aWxsIG5vdCBmaW5kaW5nIHdoYXQgeW91IHdhbnRlZD88L3A+XFxuPHA+RGlkIHlvdSBtZWFuIHRvOjwvcD5cXG48L3NwYW4+XFxuXFx0PHVsPlxcblxcdFxcdDwlIGlmICh1aS5wcm9qZWN0LnNob3cpIHsgJT5cXG5cXHRcXHQ8bGk+TG9vayBmb3IgPHNwYW4gZGF0YS1pMThuPVxcXCJQcm9qZWN0SW5kZWZpbml0ZVxcXCI+YSBQcm9qZWN0PC9zcGFuPj8gVHJ5IGdvaW5nIHRvIEJyb3dzZSA8c3BhbiBkYXRhLWkxOG49XFxcIlByb2plY3RQbHVyYWxcXFwiPlByb2plY3RzPC9zcGFuPiBvciBjbGlja2luZyA8YSBocmVmPScvcHJvamVjdHMnPmhlcmU8L2E+IC48L2xpPlxcblxcdFxcdDwlIH0gJT5cXG5cXHRcXHQ8bGk+TG9vayBmb3IgPHNwYW4gZGF0YS1pMThuPVxcXCJUYXNrSW5kZWZpbml0ZVxcXCI+YSBUYXNrPC9zcGFuPj8gVHJ5IGdvaW5nIHRvIEJyb3dzZSA8c3BhbiBkYXRhLWkxOG49XFxcIlRhc2tQbHVyYWxcXFwiPlRhc2tzPC9zcGFuPiBvciBjbGlja2luZyA8YSBocmVmPScvdGFza3MnPmhlcmU8L2E+IC4gPC9saT5cXG5cXHRcXHQ8JSBpZiAodWkuZmFxLnNob3cpIHsgJT5cXG5cXHRcXHQ8bGk+R2V0IGFuIGFuc3dlciB0byBhIGdlbmVyYWwgcXVlc3Rpb24/IFRyeSByZWFkaW5nIHRoZSBGQVEgYnkgY2xpY2tpbmcgPGEgaHJlZj0nPCUtIHVpLmZhcS51cmwgJT4nPmhlcmU8L2E+IC48L2xpPlxcblxcdFxcdDwlIH0gJT5cXG5cXHRcXHQ8bGk+R2V0IGFuIGFuc3dlciB0byBhIHNwZWNpZmljIHF1ZXN0aW9uIHlvdSBjYW4ndCBmaW5kIGVsc2V3aGVyZT8gVHJ5aW5nIDxhIGhyZWY9J21haWx0bzo8JS0gdWkuc3lzdGVtRW1haWwgJT4nPnNlbmRpbmcgYW4gZW1haWwgdG8gdGhlIHRlYW0gLjwvYT48L2xpPlxcblxcdDwvdWw+XCI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGxpIGRhdGEtaWQ9XFxcIjwlLSBpdGVtLmlkICU+XFxcIiBjbGFzcz1cXFwiYm94IHByb2plY3QtYm94XFxcIj5cXG4gIDwlIGlmIChpdGVtLmNvdmVySWQpIHsgJT5cXG4gIDxkaXYgY2xhc3M9XFxcInByb2plY3QtYmFja2dyb3VuZC1pbWFnZSBib3JkZXItYm90dG9tXFxcIiBzdHlsZT1cXFwiYmFja2dyb3VuZC1pbWFnZTogdXJsKC9hcGkvZmlsZS9nZXQvPCU9IGl0ZW0uY292ZXJJZCAlPilcXFwiPlxcbiAgPCUgfSBlbHNlIHsgJT5cXG4gIDxkaXYgY2xhc3M9XFxcInByb2plY3QtYmFja2dyb3VuZC1pbWFnZSBib3JkZXItYm90dG9tIHByb2plY3QtYmFja2dyb3VuZC1pbWFnZS1kZWZhdWx0XFxcIj5cXG4gIDwlIH0gJT5cXG4gIDwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwicHJvamVjdC10aXRsZVxcXCI+XFxuICAgIDxhIGhyZWY9XFxcIi9wcm9qZWN0cy88JS0gaXRlbS5pZCAlPlxcXCIgY2xhc3M9XFxcImxpbmstYmFja2JvbmUgYzFcXFwiPlxcbiAgICAgIDwlLSBpdGVtLnRpdGxlICU+XFxuICAgIDwvYT5cXG4gIDwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwicHJvamVjdC1saXN0LWRlc2NyaXB0aW9uXFxcIj5cXG4gICAgPCU9IGl0ZW0uZGVzY3JpcHRpb25IdG1sICU+XFxuICA8L2Rpdj5cXG5cXG4gIDxkaXYgY2xhc3M9XFxcInByb2plY3QtbGlzdC1ib3R0b20td3JhcHBlciBib3JkZXItdG9wXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwicHJvamVjdC1saXN0LWNvdW50c1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwicHJvamVjdC1saXN0LWNvdW50cy1jb2xcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwicHJvamVjdC1saXN0LWNvdW50IGMyXFxcIj5cXG4gICAgICAgICAgPCUtIGl0ZW0udGFza0NvdW50ICU+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInByb2plY3QtbGlzdC1jb3VudC10ZXh0IGMyXFxcIj5cXG4gICAgICAgICAgb3BwPCUgaWYgKGl0ZW0udGFza0NvdW50ICE9IDEpIHsgJT5zPCUgfSAlPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwicHJvamVjdC1saXN0LWNvdW50cy1jb2xcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwicHJvamVjdC1saXN0LWNvdW50IGMyXFxcIj5cXG4gICAgICAgICAgPCUtIGl0ZW0uY29tbWVudENvdW50ICU+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInByb2plY3QtbGlzdC1jb3VudC10ZXh0IGMyXFxcIj5cXG4gICAgICAgICAgY29tbWVudDwlIGlmIChpdGVtLmNvbW1lbnRDb3VudCAhPSAxKSB7ICU+czwlIH0gJT5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInByb2plY3QtbGlzdC1jb3VudHMtY29sXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInByb2plY3QtbGlzdC1jb3VudCBjMlxcXCI+XFxuICAgICAgICAgIDwlLSBpdGVtLm93bmVyQ291bnQgJT5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwicHJvamVjdC1saXN0LWNvdW50LXRleHQgYzIgIFxcXCI+XFxuICAgICAgICAgIDwlIGlmIChpdGVtLm93bmVyQ291bnQgIT0gMSkgeyAlPnBlb3BsZTwlIH0gZWxzZSB7ICU+cGVyc29uPCUgfSAlPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC9saT5cIjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8bGkgZGF0YS1pZD1cXFwiPCUtIGl0ZW0uaWQgJT5cXFwiIGNsYXNzPVxcXCJib3ggdGFzay1ib3hcXFwiPlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ0YXNrLWxpc3QtdGl0bGUgdGFzay10aXRsZS1vdmVyZmxvdy1tdWx0aVxcXCI+XFxuICAgICAgPGEgaHJlZj1cXFwiL3Rhc2tzLzwlLSBpdGVtLmlkICU+XFxcIiBjbGFzcz1cXFwibGluay1iYWNrYm9uZSBjMVxcXCI+XFxuICAgICAgICA8JS0gaXRlbS50aXRsZSAlPlxcbiAgICAgIDwvYT5cXG4gICAgPC9kaXY+XFxuXFxuICA8ZGl2IGNsYXNzPVxcXCJ0YXNrLWxpc3QtZGVzY3JpcHRpb24gdGFzay1kZXNjLW92ZXJmbG93LW11bHRpXFxcIj5cXG4gICAgPCU9IGl0ZW0uZGVzY3JpcHRpb25IdG1sICU+XFxuICA8L2Rpdj5cXG5cXG4gIDxkaXYgY2xhc3M9XFxcInRhc2stbGlzdC1ib3R0b20gYm9yZGVyLXRvcFxcXCI+XFxuXFxuICAgIDwlIF8uZWFjaCh0YWdTaG93LCBmdW5jdGlvbiAodGFnVHlwZSkgeyAlPlxcblxcbiAgICAgIDwlIGlmICh0YWdzW3RhZ1R5cGVdKSB7ICU+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwidGFzay1saXN0LXRhZ3MgYzAgdGFzay1zaW5nbGUtb3ZlcmZsb3dcXFwiPlxcbiAgICAgICAgPGkgY2xhc3M9XFxcInRhc2stbGlzdC1pY29uLWNlbnRlciA8JT0gdGFnQ29uZmlnLnRhZ3NbdGFnVHlwZV0uaWNvbiAlPlxcXCI+PC9pPlxcbiAgICAgICAgPCUgXy5lYWNoKHRhZ3NbdGFnVHlwZV0sIGZ1bmN0aW9uICh0LCBpKSB7ICU+XFxuICAgICAgICAgIDwlPSB0Lm5hbWUgJT48JSBpZiAoaSArIDEgPCB0YWdzW3RhZ1R5cGVdLmxlbmd0aCkgeyAlPiw8JSB9ICU+XFxuICAgICAgICA8JSB9KTsgJT5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8JSB9ICU+XFxuXFxuICAgIDwlIH0pOyAlPlxcblxcbiAgPC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJ0YXNrLWxpc3QtYm90dG9tLXBlcnNvbiBib3JkZXItdG9wXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwidGFzay1saXN0LXBlcnNvblxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwicHJvamVjdC1wZW9wbGUtZGl2IGZsb2F0LWxlZnRcXFwiIGRhdGEtdXNlcmlkPVxcXCI8JT0gaXRlbS51c2VySWQgJT5cXFwiIHN0eWxlPVxcXCJ0ZXh0LWFsaWduOiByaWdodDtcXFwiPlxcbiAgICAgICAgPGltZyBzcmM9XFxcIi9hcGkvdXNlci9waG90by88JT0gaXRlbS51c2VySWQgJT5cXFwiIGNsYXNzPVxcXCJwcm9qZWN0LXBlb3BsZVxcXCIvPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInRhc2stbGlzdC1yZXF1ZXN0Ym94XFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInRhc2stbGlzdC1yZXF1ZXN0ZWRcXFwiPnJlcXVlc3RlZCBieTwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidGFzay1saXN0LW5hbWVcXFwiPjwlLSBpdGVtLnVzZXIubmFtZSAlPjwvZGl2PlxcbiAgICAgICAgPCUgaWYgKGl0ZW0udXNlci5hZ2VuY3kpIHsgJT5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInRhc2stbGlzdC1hZ2VuY3kgdGFzay1zaW5nbGUtb3ZlcmZsb3dcXFwiPjwlPSBpdGVtLnVzZXIuYWdlbmN5LnRhZy5uYW1lICU+PC9kaXY+XFxuICAgICAgICA8JSB9ICU+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcblxcbiAgPC9kaXY+XFxuXFxuPC9saT5cIjtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciBhc3luYyA9IHJlcXVpcmUoJ2FzeW5jJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgVUlDb25maWcgPSByZXF1aXJlKCcuLi8uLi8uLi9jb25maWcvdWkuanNvbicpO1xudmFyIG1hcmtlZCA9IHJlcXVpcmUoJ21hcmtlZCcpO1xudmFyIFRhZ0NvbmZpZyA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbmZpZy90YWcnKTtcbnZhciBQcm9qZWN0TGlzdEl0ZW0gPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvcHJvamVjdF9saXN0X2l0ZW0uaHRtbCcpO1xudmFyIFRhc2tMaXN0SXRlbSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy90YXNrX2xpc3RfaXRlbS5odG1sJyk7XG52YXIgTm9MaXN0SXRlbSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy9ub19zZWFyY2hfcmVzdWx0cy5odG1sJyk7XG5cblxudmFyIEJyb3dzZUxpc3RWaWV3ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHBhZ2VTaXplID0gMjc7XG4gICAgaWYgKFVJQ29uZmlnLmJyb3dzZSAmJiBVSUNvbmZpZy5icm93c2UucGFnZVNpemUpXG4gICAgICBwYWdlU2l6ZSA9IFVJQ29uZmlnLmJyb3dzZS5wYWdlU2l6ZTtcblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5kYXRhID0ge1xuICAgICAgcGFnZVNpemU6IHBhZ2VTaXplLFxuICAgICAgcGFnZTogMVxuICAgIH1cbiAgICAkKHdpbmRvdykub24oJ3Njcm9sbCcsZnVuY3Rpb24oZSl7XG4gICAgICBzZWxmLnNjcm9sbENoZWNrKGUpO1xuICAgIH0pO1xuICB9LFxuXG4gIG9yZ2FuaXplVGFnczogZnVuY3Rpb24gKHRhZ3MpIHtcbiAgICAvLyBwdXQgdGhlIHRhZ3MgaW50byB0aGVpciB0eXBlc1xuICAgIHZhciBvdXRUYWdzID0ge307XG4gICAgZm9yICh0IGluIHRhZ3MpIHtcbiAgICAgIGlmICghKF8uaGFzKG91dFRhZ3MsIHRhZ3NbdF0udGFnLnR5cGUpKSkge1xuICAgICAgICBvdXRUYWdzW3RhZ3NbdF0udGFnLnR5cGVdID0gW107XG4gICAgICB9XG4gICAgICBvdXRUYWdzW3RhZ3NbdF0udGFnLnR5cGVdLnB1c2godGFnc1t0XS50YWcpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0VGFncztcbiAgfSxcblxuICBzY3JvbGxDaGVjazogZnVuY3Rpb24oZSkge1xuICAgIHZhciBjdXJyZW50U2Nyb2xsUG9zID0gJCh3aW5kb3cpLnNjcm9sbFRvcCgpO1xuICAgIHZhciBjdXJyZW50TWF4SGVpZ2h0ID0gJCgnI2NvbnRhaW5lcicpLmhlaWdodCgpO1xuICAgIHZhciBidWZmZXIgICAgICAgICAgID0gNjAwO1xuXG4gICAgaWYgKCAodGhpcy5vcHRpb25zLmNvbGxlY3Rpb24ubGVuZ3RoIC8gdGhpcy5kYXRhLnBhZ2UpID4gMSAmJiBNYXRoLmNlaWwodGhpcy5vcHRpb25zLmNvbGxlY3Rpb24ubGVuZ3RoIC8gdGhpcy5kYXRhLnBhZ2VTaXplKSA+PSB0aGlzLmRhdGEucGFnZSAmJiBjdXJyZW50U2Nyb2xsUG9zICsgYnVmZmVyID4gY3VycmVudE1heEhlaWdodCApe1xuICAgICAgdGhpcy5kYXRhLnBhZ2UgKz0gMTtcbiAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuXG4gICAgLy9zZXR0aW5ncyBmb3IgaW5maW5pdGUgc2Nyb2xsXG4gICAgaWYgKCBVSUNvbmZpZy5icm93c2UgJiYgVUlDb25maWcuYnJvd3NlLnVzZUluZmluaXRlU2Nyb2xsICkge1xuICAgICAgaWYgKCB0aGlzLmRhdGEucGFnZSA9PSAxICl7XG4gICAgICAgIHZhciBzdGFydCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc3RhcnQgPSAodGhpcy5kYXRhLnBhZ2UtMSkgKiB0aGlzLmRhdGEucGFnZVNpemU7XG4gICAgICB9XG4gICAgICB2YXIgbGltaXQgICAgPSBzdGFydCArIHRoaXMuZGF0YS5wYWdlU2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy9yZXNldCBwYWdlIHRvIDEgYW5kIHJldHVyblxuICAgICAgaWYgKCB0aGlzLmRhdGEucGFnZSA+IDEgKSB7XG4gICAgICAgIHRoaXMuZGF0YS5wYWdlID0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgbGltaXQgPSB0aGlzLm9wdGlvbnMuY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICB2YXIgc3RhcnQgPSAwO1xuICAgIH1cblxuICAgIGlmICggdGhpcy5vcHRpb25zLmNvbGxlY3Rpb24ubGVuZ3RoID09IDAgKXtcbiAgICAgIHZhciBzZXR0aW5ncyA9IHtcbiAgICAgICAgdWk6IFVJQ29uZmlnXG4gICAgICB9XG4gICAgICBjb21waWxlZFRlbXBsYXRlID0gXy50ZW1wbGF0ZShOb0xpc3RJdGVtKShzZXR0aW5ncyk7XG4gICAgICB0aGlzLiRlbC5hcHBlbmQoY29tcGlsZWRUZW1wbGF0ZSk7XG4gICAgfSBlbHNlIHtcblxuICAgICAgZm9yICggaSA9IHN0YXJ0OyBpIDwgbGltaXQ7IGkrKyApe1xuXG4gICAgICBpZiAoIHR5cGVvZiB0aGlzLm9wdGlvbnMuY29sbGVjdGlvbltpXSA9PSAndW5kZWZpbmVkJyApeyBicmVhazsgfVxuICAgICAgICB2YXIgaXRlbSA9IHtcbiAgICAgICAgICBpdGVtOiB0aGlzLm9wdGlvbnMuY29sbGVjdGlvbltpXSxcbiAgICAgICAgICB1c2VyOiB3aW5kb3cuY2FjaGUuY3VycmVudFVzZXIsXG4gICAgICAgICAgdGFnQ29uZmlnOiBUYWdDb25maWcsXG4gICAgICAgICAgdGFnU2hvdzogWydsb2NhdGlvbicsICdza2lsbCcsICd0b3BpYycsICd0YXNrLXRpbWUtZXN0aW1hdGUnLCAndGFzay10aW1lLXJlcXVpcmVkJ11cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNvbGxlY3Rpb25baV0udGFncykge1xuICAgICAgICAgIGl0ZW0udGFncyA9IHRoaXMub3JnYW5pemVUYWdzKHRoaXMub3B0aW9ucy5jb2xsZWN0aW9uW2ldLnRhZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW0udGFncyA9W107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb2xsZWN0aW9uW2ldLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgaXRlbS5pdGVtLmRlc2NyaXB0aW9uSHRtbCA9IG1hcmtlZCh0aGlzLm9wdGlvbnMuY29sbGVjdGlvbltpXS5kZXNjcmlwdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbXBpbGVkVGVtcGxhdGUgPSAnJztcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50YXJnZXQgPT0gJ3Byb2plY3RzJykge1xuICAgICAgICAgIGNvbXBpbGVkVGVtcGxhdGUgPSBfLnRlbXBsYXRlKFByb2plY3RMaXN0SXRlbSkoaXRlbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tcGlsZWRUZW1wbGF0ZSA9IF8udGVtcGxhdGUoVGFza0xpc3RJdGVtKShpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRlbC5hcHBlbmQoY29tcGlsZWRUZW1wbGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuJGVsLmkxOG4oKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBCcm93c2VMaXN0VmlldztcbiIsInZhciBzZWxlY3QyID0gcmVxdWlyZSgnc2VsZWN0MicpO1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vbWl4aW5zL3V0aWxpdGllcycpO1xudmFyIFVJQ29uZmlnID0gcmVxdWlyZSgnLi4vLi4vLi4vY29uZmlnL3VpLmpzb24nKTtcbnZhciBQb3BvdmVycyA9IHJlcXVpcmUoJy4uLy4uLy4uL21peGlucy9wb3BvdmVycycpO1xudmFyIFRhZ0NvbmZpZyA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbmZpZy90YWcnKTtcbnZhciBCcm93c2VMaXN0VmlldyA9IHJlcXVpcmUoJy4vYnJvd3NlX2xpc3RfdmlldycpO1xudmFyIEJyb3dzZU1haW5UZW1wbGF0ZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy9icm93c2VfbWFpbl92aWV3X3RlbXBsYXRlLmh0bWwnKTtcbnZhciBCcm93c2VTZWFyY2hUYWcgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvYnJvd3NlX3NlYXJjaF90YWcuaHRtbCcpO1xuXG5cbnZhciBwb3BvdmVycyA9IG5ldyBQb3BvdmVycygpO1xuXG52YXIgQnJvd3NlTWFpblZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG5cbiAgZXZlbnRzOiB7XG4gICAgXCJzdWJtaXQgI3NlYXJjaC1mb3JtXCIgICAgICAgICAgICAgOiBcInNlYXJjaFwiLFxuICAgIFwiY2xpY2sgLnNlYXJjaC10YWctcmVtb3ZlXCIgICAgICAgIDogXCJzZWFyY2hUYWdSZW1vdmVcIixcbiAgICBcImNsaWNrIC5zZWFyY2gtY2xlYXJcIiAgICAgICAgICAgICA6IFwic2VhcmNoQ2xlYXJcIixcbiAgICBcImNoYW5nZSAuc3RhdGVGaWx0ZXJcIiAgICAgICAgICAgICA6IFwic2VhcmNoVGFnUmVtb3ZlXCIsXG4gICAgXCJtb3VzZWVudGVyIC5wcm9qZWN0LXBlb3BsZS1kaXZcIiAgOiBwb3BvdmVycy5wb3BvdmVyUGVvcGxlT24sXG4gICAgXCJjbGljayAgICAgIC5wcm9qZWN0LXBlb3BsZS1kaXZcIiAgOiBwb3BvdmVycy5wb3BvdmVyQ2xpY2ssXG4gICAgXCJrZXl1cCAuc2VsZWN0Mi1jb250YWluZXJcIiAgICAgICAgOiBcInN1Ym1pdE9uRW50ZXJcIlxuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIHRhcmdldDogdGhpcy5vcHRpb25zLnRhcmdldCxcbiAgICAgIHVzZXI6IHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlcixcbiAgICAgIHVpOiBVSUNvbmZpZ1xuICAgIH07XG4gICAgdGhpcy5jb21waWxlZFRlbXBsYXRlID0gXy50ZW1wbGF0ZShCcm93c2VNYWluVGVtcGxhdGUpKG9wdGlvbnMpXG4gICAgdGhpcy4kZWwuaHRtbCh0aGlzLmNvbXBpbGVkVGVtcGxhdGUpO1xuICAgIHRoaXMuJGVsLmkxOG4oKTtcblxuICAgIHRoaXMuaW5pdGlhbGl6ZVNlYXJjaCgpO1xuXG4gICAgLy8gQWxsb3cgY2hhaW5pbmcuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgZm9ybWF0OiBmdW5jdGlvbiAoc2VsZiwgb2JqZWN0LCBjb250YWluZXIsIHF1ZXJ5KSB7XG4gICAgdmFyIG5hbWUgPSBvYmplY3QubmFtZSB8fCBvYmplY3QudGl0bGU7XG4gICAgdmFyIGljb24gPSB0aGlzLnRhZ0ljb25bb2JqZWN0LnR5cGVdO1xuICAgIGlmIChvYmplY3QudGFyZ2V0ID09ICdwcm9qZWN0Jykge1xuICAgICAgaWNvbiA9ICdmYSBmYS1mb2xkZXItbyc7XG4gICAgfSBlbHNlIGlmIChvYmplY3QudGFyZ2V0ID09ICd0YXNrJykge1xuICAgICAgaWNvbiA9ICdmYSBmYS10YWcnO1xuICAgIH1cbiAgICByZXR1cm4gJzxpIGNsYXNzPVwiJyArIGljb24gKyAnXCI+PC9pPiA8c3BhbiBjbGFzcz1cImJveC1pY29uLXRleHRcIj4nICsgbmFtZSArICc8L3NwYW4+JztcbiAgfSxcblxuICBpbml0aWFsaXplU2VhcmNoOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5zZWFyY2hUZXJtcyA9IFtdO1xuICAgIHRoaXMudGFncyA9IFtdO1xuXG4gICAgLy8gZmlndXJlIG91dCB3aGljaCB0YWdzIGFwcGx5XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBUYWdDb25maWdbdGhpcy5vcHRpb25zLnRhcmdldF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFRhZ0NvbmZpZy50YWdzW1RhZ0NvbmZpZ1t0aGlzLm9wdGlvbnMudGFyZ2V0XVtpXV0pO1xuICAgIH1cblxuICAgIC8vIGV4dHJhY3QgdGFnIGljb25zIGFuZCBjbGFzc2VzXG4gICAgdGhpcy50YWdJY29uID0ge307XG4gICAgdGhpcy50YWdDbGFzcyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50YWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnRhZ0ljb25bdGhpcy50YWdzW2ldLnR5cGVdID0gdGhpcy50YWdzW2ldLmljb247XG4gICAgICB0aGlzLnRhZ0NsYXNzW3RoaXMudGFnc1tpXS50eXBlXSA9IHRoaXMudGFnc1tpXVsnY2xhc3MnXTtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0UmVzdWx0ID0gZnVuY3Rpb24gKG9iamVjdCwgY29udGFpbmVyLCBxdWVyeSkge1xuICAgICAgcmV0dXJuIHNlbGYuZm9ybWF0KHNlbGYsIG9iamVjdCwgY29udGFpbmVyLCBxdWVyeSk7XG4gICAgfTtcblxuICAgIC8vIEluaXRpYWxpemUgU2VsZWN0MlxuICAgICQoXCIjc2VhcmNoXCIpLnNlbGVjdDIoe1xuICAgICAgcGxhY2Vob2xkZXI6ICdJXFwnbSBsb29raW5nIGZvci4uLicsXG4gICAgICBtdWx0aXBsZTogdHJ1ZSxcbiAgICAgIGZvcm1hdFJlc3VsdDogZm9ybWF0UmVzdWx0LFxuICAgICAgZm9ybWF0U2VsZWN0aW9uOiBmdW5jdGlvbihvYmplY3QsY29udGFpbmVyLHF1ZXJ5KSB7XG4gICAgICAgICAgLy9udWxsIG9iamVjdC50YXJnZXQgdG8gcmVtb3ZlIHRoZSB0YXNrIC8gcHJvamVjdCBpY29ucyB0aGF0IGdldCByZWFkZGVkIHdoZW4gdGVybXMgZ29cbiAgICAgICAgICAvLyAgICAgdG8gdGhlIHNlYXJjaCBib3ggb24gdGhlIHJpZ2h0XG4gICAgICAgICAgb2JqZWN0LnRhcmdldCA9IG51bGw7XG4gICAgICAgICAgb2JqZWN0LnR5cGUgICA9IG9iamVjdC5uYW1lIHx8IG9iamVjdC50aXRsZTtcbiAgICAgICAgICBvYmplY3QuaWQgICAgID0gb2JqZWN0Lm5hbWUgfHwgb2JqZWN0LnRpdGxlO1xuICAgICAgICAgIG9iamVjdC52YWx1ZSAgPSBvYmplY3QubmFtZSB8fCBvYmplY3QudGl0bGU7XG4gICAgICAgICAgb2JqZWN0LnVubWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdC5uYW1lIHx8IG9iamVjdC50aXRsZTtcbiAgICAgIH0sXG4gICAgICBjcmVhdGVTZWFyY2hDaG9pY2U6IGZ1bmN0aW9uICh0ZXJtKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdW5tYXRjaGVkOiB0cnVlLGlkOiB0ZXJtLCB2YWx1ZTogdGVybSwgbmFtZTogXCI8Yj5cIit0ZXJtK1wiPC9iPiA8aT5jbGljayB0byB0ZXh0IHNlYXJjaCBmb3IgdGhpcyB2YWx1ZS48L2k+XCIgfTtcbiAgICAgIH0sXG4gICAgICBhamF4OiB7XG4gICAgICAgIHVybDogJy9hcGkvYWMvc2VhcmNoLycgKyBzZWxmLm9wdGlvbnMudGFyZ2V0LFxuICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICBkYXRhOiBmdW5jdGlvbiAodGVybSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBUYWdDb25maWdbc2VsZi5vcHRpb25zLnRhcmdldF0uam9pbigpLFxuICAgICAgICAgICAgcTogdGVybVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHJlc3VsdHM6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIHsgcmVzdWx0czogZGF0YSB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkub24oXCJzZWxlY3QyLXNlbGVjdGluZ1wiLCBmdW5jdGlvbiAoZSl7XG4gICAgICAgIGlmICggZS5jaG9pY2UuaGFzT3duUHJvcGVydHkoXCJ1bm1hdGNoZWRcIikgJiYgZS5jaG9pY2UudW5tYXRjaGVkICl7XG4gICAgICAgICAgLy9yZW1vdmUgdGhlIGhpbnQgYmVmb3JlIGFkZGluZyBpdCB0byB0aGUgbGlzdFxuICAgICAgICAgIGUuY2hvaWNlLm5hbWUgPSBlLnZhbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH0sXG5cbiAgc3VibWl0T25FbnRlcjogZnVuY3Rpb24gKGUpIHtcbiAgICBpZihlLmtleUNvZGUgPT09IDEzKSB7XG4gICAgICB0aGlzLnNlYXJjaChlKTtcbiAgICB9XG4gIH0sXG5cbiAgc2VhcmNoOiBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIC8vIGdldCB2YWx1ZXMgZnJvbSBzZWxlY3QyXG4gICAgdmFyIGRhdGEgPSAkKFwiI3NlYXJjaFwiKS5zZWxlY3QyKFwiZGF0YVwiKTtcbiAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAkKFwiI3NlYXJjaC1ub25lXCIpLmhpZGUoKTtcbiAgICAgICQoXCIuc2VhcmNoLWNsZWFyXCIpLnNob3coKTtcbiAgICB9XG4gICAgXy5lYWNoKGRhdGEsIGZ1bmN0aW9uIChkKSB7XG4gICAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICAgIC8vIGNoZWNrIGlmIHRoaXMgc2VhcmNoIHRlcm0gYWxyZWFkeSBpcyBjaG9zZW5cbiAgICAgIGZvciAodmFyIGkgaW4gc2VsZi5zZWFyY2hUZXJtcykge1xuICAgICAgICBpZiAoc2VsZi5zZWFyY2hUZXJtc1tpXS5pZCA9PSBkLmlkKSB7XG4gICAgICAgICAgaWYgKHNlbGYuc2VhcmNoVGVybXNbaV0udGl0bGUgJiYgKHNlbGYuc2VhcmNoVGVybXNbaV0udGl0bGUgPT0gZC50aXRsZSkpIHtcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoc2VsZi5zZWFyY2hUZXJtc1tpXS5uYW1lICYmIChzZWxmLnNlYXJjaFRlcm1zW2ldLm5hbWUgPT0gZC5uYW1lKSkge1xuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gcmV0dXJuIGlmIHRoZSBzZWFyY2ggdGVybSBpcyBmb3VuZFxuICAgICAgaWYgKGZvdW5kKSByZXR1cm47XG4gICAgICAvLyBhZGQgaXQgdG8gb3VyIGxpc3Qgb2Ygc2VhcmNoIHRlcm1zXG4gICAgICBzZWxmLnNlYXJjaFRlcm1zLnB1c2goZCk7XG4gICAgICAvLyByZW5kZXIgdGhlIHNlYXJjaCB0ZXJtIGluIHRoZSBsaXN0XG4gICAgICB2YXIgdGVtcGxEYXRhID0ge1xuICAgICAgICBkYXRhOiBkLFxuICAgICAgICBmb3JtYXQ6IHNlbGYuZm9ybWF0KHNlbGYsIGQpXG4gICAgICB9O1xuICAgICAgdmFyIHRlbXBsID0gXy50ZW1wbGF0ZShCcm93c2VTZWFyY2hUYWcpKHRlbXBsRGF0YSk7XG4gICAgICBpZiAoZC50YXJnZXQgPT0gJ3RhZ2VudGl0eScpIHtcbiAgICAgICAgJChcIiNzZWFyY2gtdGFnc1wiKS5hcHBlbmQodGVtcGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJChcIiNzZWFyY2gtcHJvanNcIikuYXBwZW5kKHRlbXBsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAkKFwiI3NlYXJjaFwiKS5zZWxlY3QyKFwiZGF0YVwiLFwiXCIpO1xuICAgIHNlbGYuc2VhcmNoRXhlYyhzZWxmLnNlYXJjaFRlcm1zKTtcbiAgfSxcblxuICByZW5kZXJMaXN0OiBmdW5jdGlvbiAoY29sbGVjdGlvbikge1xuICAgIC8vIGNyZWF0ZSBhIG5ldyB2aWV3IGZvciB0aGUgcmV0dXJuZWQgZGF0YVxuICAgIGlmICh0aGlzLmJyb3dzZUxpc3RWaWV3KSB7IHRoaXMuYnJvd3NlTGlzdFZpZXcuY2xlYW51cCgpOyB9XG5cbiAgICB2YXIgZmlsdGVyZWRDb2xsZWN0aW9uID0gdGhpcy5hcHBseVN0YXRlRmlsdGVycyhjb2xsZWN0aW9uKTtcblxuICAgIHRoaXMuYnJvd3NlTGlzdFZpZXcgPSBuZXcgQnJvd3NlTGlzdFZpZXcoe1xuICAgICAgZWw6ICcjYnJvd3NlLWxpc3QnLFxuICAgICAgdGFyZ2V0OiB0aGlzLm9wdGlvbnMudGFyZ2V0LFxuICAgICAgY29sbGVjdGlvbjogZmlsdGVyZWRDb2xsZWN0aW9uLFxuICAgIH0pO1xuICAgIC8vIFNob3cgZHJhZnQgZmlsdGVyXG4gICAgdmFyIGRyYWZ0ID0gXyhjb2xsZWN0aW9uKS5jaGFpbigpXG4gICAgICAgICAgLnBsdWNrKCdzdGF0ZScpXG4gICAgICAgICAgLmluZGV4T2YoJ2RyYWZ0JykudmFsdWUoKSA+PSAwO1xuICAgICQoXCIuZHJhZnQtZmlsdGVyXCIpLnRvZ2dsZUNsYXNzKCdoaWRkZW4nLCAhZHJhZnQpO1xuICAgICQoXCIjYnJvd3NlLXNlYXJjaC1zcGlubmVyXCIpLmhpZGUoKTtcbiAgICAkKFwiI2Jyb3dzZS1saXN0XCIpLnNob3coKTtcbiAgICB0aGlzLmJyb3dzZUxpc3RWaWV3LnJlbmRlcigpO1xuICAgIHBvcG92ZXJzLnBvcG92ZXJQZW9wbGVJbml0KFwiLnByb2plY3QtcGVvcGxlLWRpdlwiKTtcbiAgfSxcblxuICBzZWFyY2hFeGVjOiBmdW5jdGlvbiAodGVybXMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoIXRlcm1zIHx8ICh0ZXJtcy5sZW5ndGggPT0gMCkpIHtcbiAgICAgIC8vIHJlLXJlbmRlciB0aGUgY29sbGVjdGlvblxuICAgICAgc2VsZi5yZW5kZXJMaXN0KHRoaXMub3B0aW9ucy5jb2xsZWN0aW9uLnRvSlNPTigpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgYSBzZWFyY2ggb2JqZWN0XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBpdGVtczogW10sXG4gICAgICB0YWdzOiBbXSxcbiAgICAgIGZyZWVUZXh0OiBbXSxcbiAgICAgIHRhcmdldDogc2VsZi5vcHRpb25zLnRhcmdldFxuICAgIH07XG4gICAgXy5lYWNoKHRlcm1zLCBmdW5jdGlvbiAodCkge1xuICAgICAgaWYgKCB0LnVubWF0Y2hlZCApIHtcbiAgICAgICAgZGF0YS5mcmVlVGV4dC5wdXNoKHQudmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YS5pdGVtcy5wdXNoKHQuaWQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgICQuYWpheCh7XG4gICAgICB1cmw6ICcvYXBpL3NlYXJjaCcsXG4gICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICBkYXRhOiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgfSkuZG9uZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgLy8gcmVuZGVyIHRoZSBzZWFyY2ggcmVzdWx0c1xuICAgICAgc2VsZi5yZW5kZXJMaXN0KGRhdGEpO1xuICAgIH0pO1xuICB9LFxuXG4gIGFwcGx5U3RhdGVGaWx0ZXJzOiBmdW5jdGlvbiAoZGF0YSkge1xuXG4gICAgaWYgKCAhXy5pc09iamVjdChkYXRhKSB8fCAhJChcIiNzdGF0ZUZpbHRlcnNcIikubGVuZ3RoICl7IHJldHVybiBkYXRhOyB9XG4gICAgdmFyIGtlZXBlcnMgPSBbXTtcbiAgICAvL2dldCBjaGVjayBzdGF0ZUZpbHRlciBpbnB1dHNcbiAgICB2YXIgaW5wdXRzID0gJChcIi5zdGF0ZUZpbHRlcjpjaGVja2VkXCIpO1xuXG4gICAgXy5lYWNoKGRhdGEsZnVuY3Rpb24oaXRlbSl7XG4gICAgICBfLmVhY2goaW5wdXRzLGZ1bmN0aW9uKHRlc3Qpe1xuICAgICAgICAgaWYgKCBpdGVtLnN0YXRlID09IHRlc3QudmFsdWUgKXtcbiAgICAgICAgICAga2VlcGVycy5wdXNoKGl0ZW0pO1xuICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ga2VlcGVycztcbiAgfSxcblxuICBzZWFyY2hUYWdSZW1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICggJChlLmN1cnJlbnRUYXJnZXQpLmhhc0NsYXNzKFwic3RhdGVGaWx0ZXJcIikgKXtcbiAgICAgIGlmICggJChcIiNzZWFyY2gtdGFnc1wiKS5sZW5ndGggPiAwICkge1xuICAgICAgICB2YXIgcGFyZW50ID0gJChcIiNzZWFyY2gtdGFnc1wiKTtcbiAgICAgICAgdmFyIGlkID0gXCJzZWFyY2gtdGFnc1wiO1xuICAgICAgICB2YXIgcHJvamVjdCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFyZW50ID0gJChlLmN1cnJlbnRUYXJnZXQpLnBhcmVudHMoJ2xpJylbMF07XG4gICAgICB2YXIgaWQgPSAkKHBhcmVudCkuZGF0YSgnaWQnKTtcbiAgICAgIHZhciB0eXBlID0gJCgkKGUuY3VycmVudFRhcmdldCkucGFyZW50cygndWwnKVswXSkuYXR0cignaWQnKTtcbiAgICAgIHZhciBwcm9qZWN0ID0gZmFsc2U7XG5cbiAgICAgIGlmICh0eXBlID09ICdzZWFyY2gtcHJvanMnKSB7XG4gICAgICAgIHByb2plY3QgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSBpbiBzZWxmLnNlYXJjaFRlcm1zKSB7XG4gICAgICBpZiAoc2VsZi5zZWFyY2hUZXJtc1tpXS5pZCA9PSBpZCkge1xuICAgICAgICBpZiAocHJvamVjdCAmJiBzZWxmLnNlYXJjaFRlcm1zW2ldLnRpdGxlKSB7XG4gICAgICAgICAgc2VsZi5zZWFyY2hUZXJtcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZi5zZWFyY2hUZXJtc1tpXS5uYW1lKSB7XG4gICAgICAgICAgc2VsZi5zZWFyY2hUZXJtcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoICEkKGUuY3VycmVudFRhcmdldCkuaGFzQ2xhc3MoXCJzdGF0ZUZpbHRlclwiKSApe1xuICAgICAgcGFyZW50LnJlbW92ZSgpO1xuICAgIH1cbiAgICBpZiAoc2VsZi5zZWFyY2hUZXJtcy5sZW5ndGggPT0gMCkge1xuICAgICAgJChcIiNzZWFyY2gtbm9uZVwiKS5zaG93KCk7XG4gICAgICAkKFwiLnNlYXJjaC1jbGVhclwiKS5oaWRlKCk7XG4gICAgfVxuICAgIHNlbGYuc2VhcmNoRXhlYyhzZWxmLnNlYXJjaFRlcm1zKTtcbiAgfSxcblxuICBzZWFyY2hDbGVhcjogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuc2VhcmNoVGVybXMgPSBbXTtcbiAgICAkKFwiI3NlYXJjaC1wcm9qc1wiKS5jaGlsZHJlbigpLnJlbW92ZSgpO1xuICAgICQoXCIjc2VhcmNoLXRhZ3NcIikuY2hpbGRyZW4oKS5yZW1vdmUoKTtcbiAgICAkKFwiI3NlYXJjaC1ub25lXCIpLnNob3coKTtcbiAgICAkKFwiLnNlYXJjaC1jbGVhclwiKS5oaWRlKCk7XG4gICAgdGhpcy5zZWFyY2hFeGVjKHNlbGYuc2VhcmNoVGVybXMpO1xuICB9LFxuXG4gIGNsZWFudXA6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmJyb3dzZUxpc3RWaWV3KSB7IHRoaXMuYnJvd3NlTGlzdFZpZXcuY2xlYW51cCgpOyB9XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBCcm93c2VNYWluVmlldztcbiIsIlxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vbWl4aW5zL3V0aWxpdGllcycpO1xudmFyIFRpbWVBZ28gPSByZXF1aXJlKCcuLi8uLi8uLi8uLi8uLi92ZW5kb3IvanF1ZXJ5LnRpbWVhZ28nKTtcbnZhciBQb3BvdmVycyA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL21peGlucy9wb3BvdmVycycpO1xudmFyIENvbW1lbnRDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vZW50aXRpZXMvY29tbWVudHMvY29tbWVudF9jb2xsZWN0aW9uJyk7XG52YXIgQ29tbWVudEZvcm1WaWV3ID0gcmVxdWlyZSgnLi4vLi4vbmV3L3ZpZXdzL2NvbW1lbnRfZm9ybV92aWV3Jyk7XG52YXIgQ29tbWVudEl0ZW1WaWV3ID0gcmVxdWlyZSgnLi4vdmlld3MvY29tbWVudF9pdGVtX3ZpZXcnKTtcbnZhciBDb21tZW50V3JhcHBlciA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy9jb21tZW50X3dyYXBwZXJfdGVtcGxhdGUuaHRtbCcpO1xuXG5cbnZhciBwb3BvdmVycyA9IG5ldyBQb3BvdmVycygpO1xuXG5Db21tZW50ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuXG4gIGVsOiBcIi5jb21tZW50LWxpc3Qtd3JhcHBlclwiLFxuXG4gIGV2ZW50czoge1xuICAgIFwiY2xpY2sgLm5ldy10b3BpY1wiICAgICAgICAgICAgICAgICAgOiBcIm5ld1RvcGljXCIsXG4gICAgXCJjbGljayAuY29tbWVudC1leHBhbmRcIiAgICAgICAgICAgICA6IFwidG9waWNFeHBhbmRcIixcbiAgICBcImNsaWNrIC5jb21tZW50LWNvbnRyYWN0XCIgICAgICAgICAgIDogXCJ0b3BpY0NvbnRyYWN0XCIsXG4gICAgXCJtb3VzZWVudGVyIC5jb21tZW50LXVzZXItbGlua1wiICAgICA6IHBvcG92ZXJzLnBvcG92ZXJQZW9wbGVPbixcbiAgICBcImNsaWNrIC5jb21tZW50LXVzZXItbGlua1wiICAgICAgICAgIDogcG9wb3ZlcnMucG9wb3ZlckNsaWNrLFxuICAgIFwiY2xpY2sgLmxpbmstYmFja2JvbmVcIiAgICAgICAgICAgICAgOiBsaW5rQmFja2JvbmUsXG4gICAgXCJjbGljayBhW2hyZWY9JyNyZXBseS10by1jb21tZW50J11cIiA6IFwicmVwbHlcIlxuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICB0aGlzLmluaXRpYWxpemVSZW5kZXIoKTtcbiAgICB0aGlzLmluaXRpYWxpemVDb21tZW50Q29sbGVjdGlvbigpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZUxpc3RlbmVycygpO1xuXG4gICAgLy8gUG9wdWxhdGluZyB0aGUgRE9NIGFmdGVyIGEgY29tbWVudCB3YXMgY3JlYXRlZC5cbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29tbWVudENvbGxlY3Rpb24sIFwiY29tbWVudDpzYXZlOnN1Y2Nlc3NcIiwgZnVuY3Rpb24gKG1vZGVsLCBtb2RlbEpzb24sIGN1cnJlbnRUYXJnZXQpIHtcbiAgICAgIGlmIChtb2RlbEpzb24udG9waWMpIHtcbiAgICAgICAgLy8gY2xlYW51cCB0aGUgdG9waWMgZm9ybVxuICAgICAgICBpZiAodGhpcy50b3BpY0Zvcm0pIHRoaXMudG9waWNGb3JtLmNsZWFudXAoKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuYWRkTmV3Q29tbWVudFRvRG9tKG1vZGVsSnNvbiwgY3VycmVudFRhcmdldCk7XG4gICAgfSk7XG5cbiAgfSxcblxuICBpbml0aWFsaXplUmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBfLnRlbXBsYXRlKENvbW1lbnRXcmFwcGVyKSh7IHVzZXI6IHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlciB9KTtcbiAgICB0aGlzLiRlbC5odG1sKHRlbXBsYXRlKTtcbiAgfSxcblxuICBpbml0aWFsaXplQ29tbWVudENvbGxlY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5jb21tZW50Q29sbGVjdGlvbikgeyB0aGlzLnJlbmRlclZpZXcoKSB9XG4gICAgZWxzZSB7IHRoaXMuY29tbWVudENvbGxlY3Rpb24gPSBuZXcgQ29tbWVudENvbGxlY3Rpb24oKTsgfVxuXG4gICAgdGhpcy5jb21tZW50Q29sbGVjdGlvbi5mZXRjaCh7XG4gICAgICB1cmw6ICcvYXBpL2NvbW1lbnQvZmluZEFsbEJ5JyArIHRoaXMub3B0aW9ucy50YXJnZXQgKyAnSWQvJyArIHRoaXMub3B0aW9ucy5pZCxcbiAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XG4gICAgICAgIHNlbGYuY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gICAgICAgIHNlbGYucmVuZGVyVmlldyhjb2xsZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBpbml0aWFsaXplTGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29tbWVudENvbGxlY3Rpb24sIFwiY29tbWVudDp0b3BpYzpuZXdcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB0b3BpYzogdHJ1ZVxuICAgICAgfTtcbiAgICAgIGRhdGFbc2VsZi5vcHRpb25zLnRhcmdldCArICdJZCddID0gc2VsZi5vcHRpb25zLmlkO1xuXG4gICAgICAvLyBUT0RPOiBETTogRml4IHRoaXMgdG8gYWRkIHRvIHRoZSBjb2xsZWN0aW9uIGFwcHJvcHJpYXRlbHksXG4gICAgICAvLyBhbmQgZmV0Y2gvcmUtcmVuZGVyIGFzIG5lZWRlZC4gIFRoaXMgaXMgYSBoYWNrIHRvIGdldCBpdCB0byB3b3JrXG4gICAgICAkLmFqYXgoe1xuICAgICAgICB1cmw6ICcvYXBpL2NvbW1lbnQnLFxuICAgICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIHByb2Nlc3NEYXRhOiBmYWxzZSxcbiAgICAgICAgZGF0YTogSlNPTi5zdHJpbmdpZnkoZGF0YSlcbiAgICAgIH0pLmRvbmUoZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBzZWxmLmNvbW1lbnRDb2xsZWN0aW9uLmZldGNoKHtcbiAgICAgICAgICB1cmw6ICcvYXBpL2NvbW1lbnQvZmluZEFsbEJ5JyArIHNlbGYub3B0aW9ucy50YXJnZXQgKyAnSWQvJyArIHNlbGYub3B0aW9ucy5pZCxcbiAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoY29sbGVjdGlvbikge1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSxcblxuICByZW5kZXJWaWV3OiBmdW5jdGlvbiAoY29sbGVjdGlvbikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLnBhcmVudE1hcCA9IHt9O1xuICAgIHRoaXMudG9waWNzID0gW107XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBjb21tZW50czogY29sbGVjdGlvbi50b0pTT04oKVswXS5jb21tZW50c1xuICAgIH07XG5cbiAgICAvLyBjb21wdXRlIHRoZSBkZXB0aCBvZiBlYWNoIGNvbW1lbnQgdG8gdXNlIGFzIG1ldGFkYXRhIHdoZW4gcmVuZGVyaW5nXG4gICAgLy8gaW4gdGhlIHByb2Nlc3MsIGNyZWF0ZSBhIG1hcCBvZiB0aGUgaWRzIG9mIGVhY2ggY29tbWVudCdzIGNoaWxkcmVuXG4gICAgdmFyIGRlcHRoID0ge307XG4gICAgaWYgKCFkYXRhLmNvbW1lbnRzKSB7XG4gICAgICBkYXRhLmNvbW1lbnRzID0gW107XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5jb21tZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKGRhdGEuY29tbWVudHNbaV0udG9waWMgPT09IHRydWUpIHtcbiAgICAgICAgZGVwdGhbZGF0YS5jb21tZW50c1tpXS5pZF0gPSAwO1xuICAgICAgICBkYXRhLmNvbW1lbnRzW2ldWydkZXB0aCddID0gZGVwdGhbZGF0YS5jb21tZW50c1tpXS5pZF07XG4gICAgICAgIHRoaXMudG9waWNzLnB1c2goZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZXB0aFtkYXRhLmNvbW1lbnRzW2ldLmlkXSA9IGRlcHRoW2RhdGEuY29tbWVudHNbaV0ucGFyZW50SWRdICsgMTtcbiAgICAgICAgZGF0YS5jb21tZW50c1tpXVsnZGVwdGgnXSA9IGRlcHRoW2RhdGEuY29tbWVudHNbaV0uaWRdO1xuICAgICAgICAvLyBhdWdtZW50IHRoZSBwYXJlbnRNYXAgd2l0aCB0aGlzIGNvbW1lbnRcbiAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQodGhpcy5wYXJlbnRNYXBbZGF0YS5jb21tZW50c1tpXS5wYXJlbnRJZF0pKSB7XG4gICAgICAgICAgdGhpcy5wYXJlbnRNYXBbZGF0YS5jb21tZW50c1tpXS5wYXJlbnRJZF0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcmVudE1hcFtkYXRhLmNvbW1lbnRzW2ldLnBhcmVudElkXS5wdXNoKGRhdGEuY29tbWVudHNbaV0uaWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGhpZGUgdGhlIGxvYWRpbmcgc3Bpbm5lclxuICAgIHRoaXMuJCgnLmNvbW1lbnQtc3Bpbm5lcicpLmhpZGUoKTtcblxuICAgIHRoaXMuY29tbWVudFZpZXdzID0gW107XG4gICAgdGhpcy5jb21tZW50Rm9ybXMgPSBbXTtcbiAgICBpZiAoZGF0YS5jb21tZW50cy5sZW5ndGggPT0gMCkge1xuICAgICAgdGhpcy4kKCcjY29tbWVudC1lbXB0eScpLnNob3coKTtcbiAgICB9XG4gICAgXy5lYWNoKGRhdGEuY29tbWVudHMsIGZ1bmN0aW9uIChjb21tZW50LCBpKSB7XG4gICAgICBzZWxmLnJlbmRlckNvbW1lbnQoc2VsZiwgY29tbWVudCwgY29sbGVjdGlvbiwgc2VsZi5wYXJlbnRNYXApO1xuICAgIH0pO1xuXG4gICAgdGhpcy5pbml0aWFsaXplQ29tbWVudFVJQWRkaXRpb25zKCk7XG4gIH0sXG5cbiAgcmVuZGVyQ29tbWVudDogZnVuY3Rpb24gKHNlbGYsIGNvbW1lbnQsIGNvbGxlY3Rpb24sIG1hcCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAvLyBjb3VudCB0aGUgbnVtYmVyIG9mIHJlcGxpZXMgaW4gYSB0b3BpYywgcmVjdXJzaXZlbHlcbiAgICB2YXIgY291bnRDaGlsZHJlbiA9IGZ1bmN0aW9uIChtYXAsIGNvbW1lbnQpIHtcbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKG1hcFtjb21tZW50XSkpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICB2YXIgY291bnQgPSBtYXBbY29tbWVudF0ubGVuZ3RoO1xuICAgICAgXy5lYWNoKG1hcFtjb21tZW50XSwgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgY291bnQgKz0gY291bnRDaGlsZHJlbihtYXAsIGMpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gY291bnQ7XG4gICAgfTtcbiAgICAvLyBpZiB0aGlzIGlzIGEgdG9waWMsIGNvdW50IHRoZSBjaGlsZHJlbiBmb3IgcmVuZGVyaW5nXG4gICAgaWYgKGNvbW1lbnQudG9waWMgPT09IHRydWUpIHtcbiAgICAgIGNvbW1lbnQubnVtQ2hpbGRyZW4gPSBjb3VudENoaWxkcmVuKG1hcCwgY29tbWVudC5pZCk7XG4gICAgfVxuICAgIC8vIFJlbmRlciB0aGUgdG9waWMgdmlldyBhbmQgdGhlbiBpbiB0aGF0IHZpZXcgc3BldyBvdXQgYWxsIG9mIGl0cyBjaGlsZHJlbi5cbiAgICB2YXIgY29tbWVudElWID0gbmV3IENvbW1lbnRJdGVtVmlldyh7XG4gICAgICBlbDogXCIjY29tbWVudC1saXN0LVwiICsgKGNvbW1lbnQudG9waWMgPyAnbnVsbCcgOiBjb21tZW50LnBhcmVudElkKSxcbiAgICAgIG1vZGVsOiBjb21tZW50LFxuICAgICAgdGFyZ2V0OiB0aGlzLm9wdGlvbnMudGFyZ2V0LFxuICAgICAgcHJvamVjdElkOiBjb21tZW50LnByb2plY3RJZCxcbiAgICAgIHRhc2tJZDogY29tbWVudC50YXNrSWQsXG4gICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uXG4gICAgfSkucmVuZGVyKCk7XG4gICAgc2VsZi5jb21tZW50Vmlld3MucHVzaChjb21tZW50SVYpO1xuICAgIGlmIChjb21tZW50LmRlcHRoIDw9IDEpIHtcbiAgICAgIC8vIFBsYWNlIHRoZSBjb21tZW50Rm9ybSBhdCB0aGUgYm90dG9tIG9mIHRoZSBsaXN0IG9mIGNvbW1lbnRzIGZvciB0aGF0IHRvcGljLlxuICAgICAgdmFyIGNvbW1lbnRGViA9IG5ldyBDb21tZW50Rm9ybVZpZXcoe1xuICAgICAgICBlbDogJyNjb21tZW50LWZvcm0tJyArIGNvbW1lbnQuaWQsXG4gICAgICAgIHRhcmdldDogdGhpcy5vcHRpb25zLnRhcmdldCxcbiAgICAgICAgcHJvamVjdElkOiBjb21tZW50LnByb2plY3RJZCxcbiAgICAgICAgdGFza0lkOiBjb21tZW50LnRhc2tJZCxcbiAgICAgICAgcGFyZW50SWQ6IGNvbW1lbnQuaWQsXG4gICAgICAgIGNvbGxlY3Rpb246IGNvbGxlY3Rpb24sXG4gICAgICAgIGRlcHRoOiBjb21tZW50WydkZXB0aCddXG4gICAgICB9KTtcbiAgICAgIHNlbGYuY29tbWVudEZvcm1zLnB1c2goY29tbWVudEZWKTtcbiAgICB9XG4gICAgcmV0dXJuICQoXCIjY29tbWVudC1saXN0LVwiICsgKGNvbW1lbnQudG9waWMgPyAnbnVsbCcgOiBjb21tZW50LnBhcmVudElkKSk7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZUNvbW1lbnRVSUFkZGl0aW9uczogZnVuY3Rpb24gKCRjb21tZW50KSB7XG4gICAgaWYgKF8uaXNVbmRlZmluZWQoJGNvbW1lbnQpKSB7XG4gICAgICB0aGlzLiQoXCJ0aW1lLnRpbWVhZ29cIikudGltZWFnbygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkY29tbWVudC5maW5kKFwidGltZS50aW1lYWdvXCIpLnRpbWVhZ28oKTtcbiAgICB9XG4gICAgcG9wb3ZlcnMucG9wb3ZlclBlb3BsZUluaXQoXCIuY29tbWVudC11c2VyLWxpbmtcIik7XG4gICAgcG9wb3ZlcnMucG9wb3ZlclBlb3BsZUluaXQoXCIucHJvamVjdC1wZW9wbGUtZGl2XCIpO1xuICB9LFxuXG4gIHRvcGljRXhwYW5kOiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgLy8gdG9nZ2xlIGFsbCB0aGUgc3VibGlzdHNcbiAgICB2YXIgdGFyZ2V0ID0gJCgkKGUuY3VycmVudFRhcmdldCkucGFyZW50cygnbGknKVswXSlcbiAgICAkKGUuY3VycmVudFRhcmdldCkuaGlkZSgpO1xuICAgICQodGFyZ2V0LmZpbmQoJy5jb21tZW50LWNvbnRyYWN0JylbMF0pLnNob3coKTtcbiAgICAkKHRhcmdldC5jaGlsZHJlbignLmNvbW1lbnQtc3VibGlzdC13cmFwcGVyJylbMF0pLnNsaWRlVG9nZ2xlKCk7XG4gIH0sXG5cbiAgdG9waWNDb250cmFjdDogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIC8vIHRvZ2dsZSBhbGwgdGhlIHN1Ymxpc3RzXG4gICAgdmFyIHRhcmdldCA9ICQoJChlLmN1cnJlbnRUYXJnZXQpLnBhcmVudHMoJ2xpJylbMF0pXG4gICAgJChlLmN1cnJlbnRUYXJnZXQpLmhpZGUoKTtcbiAgICAkKHRhcmdldC5maW5kKCcuY29tbWVudC1leHBhbmQnKVswXSkuc2hvdygpO1xuICAgICQodGFyZ2V0LmNoaWxkcmVuKCcuY29tbWVudC1zdWJsaXN0LXdyYXBwZXInKVswXSkuc2xpZGVUb2dnbGUoKTtcbiAgfSxcblxuICByZXBseTogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIC8vIFRoZSBjb21tZW50IGZvcm0gaXMgYWRqYWNlbnQsIG5vdCBhIGNoaWxkIG9mIHRoZSBjdXJyZW50IHRhcmdldC5cbiAgICAvLyBzbyBmaW5kIHRoZSBsaSBjb250YWluZXIsIGFuZCB0aGVuIHRoZSBmb3JtIGluc2lkZVxuICAgIHZhciB0YXJnZXQgPSAkKCQoJChlLmN1cnJlbnRUYXJnZXQpLnBhcmVudHMoJ2xpLmNvbW1lbnQtaXRlbScpWzBdKS5jaGlsZHJlbignLmNvbW1lbnQtZm9ybScpWzBdKTtcbiAgICBpZiAodGFyZ2V0LmRhdGEoJ2NsaWNrZWQnKSA9PSAndHJ1ZScpIHtcbiAgICAgIHRhcmdldC5oaWRlKCk7XG4gICAgICB0YXJnZXQuZGF0YSgnY2xpY2tlZCcsICdmYWxzZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQuc2hvdygpO1xuICAgICAgdGFyZ2V0LmRhdGEoJ2NsaWNrZWQnLCAndHJ1ZScpO1xuICAgIH1cbiAgfSxcblxuICBuZXdUb3BpYzogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgaWYgKHRoaXMudG9waWNGb3JtKSB0aGlzLnRvcGljRm9ybS5jbGVhbnVwKCk7XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBlbDogJy50b3BpYy1mb3JtLXdyYXBwZXInLFxuICAgICAgdGFyZ2V0OiB0aGlzLm9wdGlvbnMudGFyZ2V0LFxuICAgICAgY29sbGVjdGlvbjogdGhpcy5jb2xsZWN0aW9uLFxuICAgICAgdG9waWM6IHRydWUsXG4gICAgICBkZXB0aDogLTFcbiAgICB9XG4gICAgb3B0aW9uc1t0aGlzLm9wdGlvbnMudGFyZ2V0ICsgJ0lkJ10gPSB0aGlzLm9wdGlvbnMuaWQ7XG4gICAgdGhpcy50b3BpY0Zvcm0gPSBuZXcgQ29tbWVudEZvcm1WaWV3KG9wdGlvbnMpO1xuICB9LFxuXG4gIGFkZE5ld0NvbW1lbnRUb0RvbTogZnVuY3Rpb24gKG1vZGVsSnNvbiwgY3VycmVudFRhcmdldCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBtb2RlbEpzb25bJ3VzZXInXSA9IHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlcjtcbiAgICAvLyBpbmNyZW1lbnQgdGhlIGNvbW1lbnQgY291bnRlclxuICAgIGlmICgkKGN1cnJlbnRUYXJnZXQpLmRhdGEoJ2RlcHRoJykgPj0gMCkge1xuICAgICAgdmFyIGl0ZW1Db250YWluZXIgPSAkKGN1cnJlbnRUYXJnZXQpLnBhcmVudHMoJy5jb21tZW50LWl0ZW0uYm9yZGVyLWxlZnQnKVswXTtcbiAgICAgIHZhciBjb3VudFNwYW4gPSAkKGl0ZW1Db250YWluZXIpLmZpbmQoJy5jb21tZW50LWNvdW50LW51bScpWzBdO1xuICAgICAgJChjb3VudFNwYW4pLmh0bWwocGFyc2VJbnQoJChjb3VudFNwYW4pLnRleHQoKSkgKyAxKTtcbiAgICB9XG4gICAgLy8gc2V0IHRoZSBkZXB0aCBiYXNlZCBvbiB0aGUgcG9zaXRpb24gaW4gdGhlIHRyZWVcbiAgICBtb2RlbEpzb25bJ2RlcHRoJ10gPSAkKGN1cnJlbnRUYXJnZXQpLmRhdGEoJ2RlcHRoJykgKyAxO1xuICAgIC8vIHVwZGF0ZSB0aGUgcGFyZW50TWFwIGZvciBzb3J0aW5nXG4gICAgaWYgKCFfLmlzTnVsbChtb2RlbEpzb24ucGFyZW50SWQpKSB7XG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZCh0aGlzLnBhcmVudE1hcFttb2RlbEpzb24ucGFyZW50SWRdKSkge1xuICAgICAgICB0aGlzLnBhcmVudE1hcFttb2RlbEpzb24ucGFyZW50SWRdID0gW107XG4gICAgICB9XG4gICAgICB0aGlzLnBhcmVudE1hcFttb2RlbEpzb24ucGFyZW50SWRdLnB1c2gobW9kZWxKc29uLmlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50b3BpY3MucHVzaChtb2RlbEpzb24pO1xuICAgIH1cbiAgICAvLyBoaWRlIHRoZSBlbXB0eSBwbGFjZWhvbGRlciwganVzdCBpbiBjYXNlIGl0IGlzIHN0aWxsIHNob3dpbmdcbiAgICAkKFwiI2NvbW1lbnQtZW1wdHlcIikuaGlkZSgpO1xuICAgIC8vIHJlbmRlciBjb21tZW50IGFuZCBVSSBhZGRvbnNcbiAgICB2YXIgJGNvbW1lbnQgPSBzZWxmLnJlbmRlckNvbW1lbnQoc2VsZiwgbW9kZWxKc29uLCBzZWxmLmNvbGxlY3Rpb24sIHNlbGYucGFyZW50TWFwKTtcbiAgICBzZWxmLmluaXRpYWxpemVDb21tZW50VUlBZGRpdGlvbnMoJGNvbW1lbnQpO1xuXG4gICAgLy8gQ2xlYXIgb3V0IHRoZSBjdXJyZW50IGRpdlxuICAgICQoY3VycmVudFRhcmdldCkuZmluZChcImRpdltjb250ZW50RWRpdGFibGU9dHJ1ZV1cIikudGV4dChcIlwiKTtcbiAgfSxcblxuICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSBpbiB0aGlzLmNvbW1lbnRGb3Jtcy5yZXZlcnNlKCkpIHtcbiAgICAgIGlmICh0aGlzLmNvbW1lbnRGb3Jtc1tpXSkgeyB0aGlzLmNvbW1lbnRGb3Jtc1tpXS5jbGVhbnVwKCk7IH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSBpbiB0aGlzLmNvbW1lbnRWaWV3cy5yZXZlcnNlKCkpIHtcbiAgICAgIGlmICh0aGlzLmNvbW1lbnRWaWV3c1tpXSkgeyB0aGlzLmNvbW1lbnRWaWV3c1tpXS5jbGVhbnVwKCk7IH1cbiAgICB9XG4gICAgaWYgKHRoaXMudG9waWNGb3JtKSB7XG4gICAgICB0aGlzLnRvcGljRm9ybS5jbGVhbnVwKCk7XG4gICAgfVxuICAgIHJlbW92ZVZpZXcodGhpcyk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tbWVudDtcblxuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxsaSBjbGFzcz1cXFwiY29tbWVudC1pdGVtIGNsZWFyZml4IDwlIGlmICh0b3BpYykgeyAlPmJvcmRlci1sZWZ0IGJveC1wYWQtbHI8JSB9IGVsc2UgeyAlPmJvcmRlci10b3A8JSB9ICU+XFxcIj5cXG5cXG4gIDxkaXYgY2xhc3M9XFxcImNvbW1lbnQtY29udGVudFxcXCI+XFxuICAgIDwlIGlmICh0b3BpYykgeyAlPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb21tZW50LWV4cGFuZFxcXCI+XFxuICAgICAgPHNwYW4gY2xhc3M9XFxcImNvbnRlbnRcXFwiPmV4cGFuZDwvc3Bhbj4gPGkgY2xhc3M9XFxcImZhIGZhLWFuZ2xlLWRvdWJsZS1kb3duXFxcIj48L2k+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb21tZW50LWNvbnRyYWN0XFxcIj5cXG4gICAgICA8c3BhbiBjbGFzcz1cXFwiY29udGVudFxcXCI+Y29udHJhY3Q8L3NwYW4+IDxpIGNsYXNzPVxcXCJmYSBmYS1hbmdsZS1kb3VibGUtdXBcXFwiPjwvaT5cXG4gICAgPC9kaXY+XFxuICAgIDwlIH0gJT5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY29tbWVudC1pbWFnZVxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwicHJvamVjdC1wZW9wbGUtZGl2XFxcIiBkYXRhLXVzZXJpZD1cXFwiPCUtIHVzZXJJZCAlPlxcXCI+XFxuICAgICAgICA8aW1nIHNyYz1cXFwiL2FwaS91c2VyL3Bob3RvLzwlPSB1c2VySWQgJT5cXFwiIGFsdD1cXFwiPCUtIHVzZXIubmFtZSAlPlxcXCIgY2xhc3M9XFxcInByb2plY3QtcGVvcGxlXFxcIiAvPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY29tbWVudC1pbm5lciA8JSBpZiAodG9waWMpIHsgJT50b3BpYzwlIH0lPlxcXCI+XFxuICAgICAgPHNwYW4gY2xhc3M9XFxcInVzZXItdXNlcm5hbWVcXFwiIGRhdGEtdXNlcmlkPVxcXCI8JS0gdXNlcklkICU+XFxcIj5cXG4gICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJjb21tZW50LXVzZXItbGlua1xcXCIgZGF0YS11c2VyaWQ9XFxcIjwlLSB1c2VySWQgJT5cXFwiPlxcbiAgICAgICAgICA8JSBpZiAodXNlci5uYW1lKSB7ICU+XFxuICAgICAgICAgICAgPCUtIHVzZXIubmFtZSAlPlxcbiAgICAgICAgICA8JSB9IGVsc2UgeyAlPlxcbiAgICAgICAgICAgIDwlLSB1c2VyLnVzZXJuYW1lICU+XFxuICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgIDwvYT5cXG4gICAgICA8L3NwYW4+XFxuXFxuICAgICAgPCU9IHZhbHVlSHRtbCAlPlxcblxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbW1lbnQtbWV0YWRhdGFcXFwiPlxcbiAgICAgICAgPHRpbWUgY2xhc3M9XFxcInRpbWVhZ28gY29tbWVudC1jcmVhdGVkLWF0XFxcIiBkYXRldGltZT1cXFwiPCUtIGNyZWF0ZWRBdCAlPlxcXCI+PCUtIGNyZWF0ZWRBdCAlPjwvdGltZT5cXG4gICAgICAgIDwlIGlmICh0b3BpYykgeyAlPlxcbiAgICAgICAgJmJ1bGw7Jm5ic3A7XFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwiY29tbWVudC1jb3VudFxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLWNvbW1lbnRzXFxcIj48L2k+IDxzcGFuIGNsYXNzPVxcXCJjb21tZW50LWNvdW50LW51bVxcXCI+PCUtIG51bUNoaWxkcmVuICU+PC9zcGFuPiBjb21tZW50czwvc3Bhbj5cXG4gICAgICAgIDwlIH0gJT5cXG4gICAgICAgIDwlIGlmIChkZXB0aCA9PSAxKSAgeyAlPlxcbiAgICAgICAgPCUgaWYgKGN1cnJlbnRVc2VyKSB7ICU+XFxuICAgICAgICAmYnVsbDtcXG4gICAgICAgIDxhIGhyZWY9XFxcIiNyZXBseS10by1jb21tZW50XFxcIiBjbGFzcz1cXFwicmVwbHktdG8tPCU9IGlkICU+XFxcIiBkYXRhLWRlcHRoPVxcXCI8JT0gZGVwdGggJT5cXFwiPlJlcGx5PC9hPlxcbiAgICAgICAgPCUgfSAlPlxcbiAgICAgICAgPCUgfSAlPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcblxcbiAgPGRpdiBjbGFzcz1cXFwiY29tbWVudC1zdWJsaXN0LXdyYXBwZXJcXFwiPlxcblxcbiAgICA8dWwgaWQ9XFxcImNvbW1lbnQtbGlzdC08JT0gaWQgJT5cXFwiPjwvdWw+XFxuICA8L2Rpdj5cXG5cXG4gIDxkaXYgY2xhc3M9XFxcImNvbW1lbnQtZm9ybVxcXCIgPCUgaWYgKChkZXB0aCA+PSAxKSB8fCAoIWN1cnJlbnRVc2VyKSkgeyAlPnN0eWxlPVxcXCJkaXNwbGF5OiBub25lO1xcXCI8JSB9ICU+IGlkPVxcXCJjb21tZW50LWZvcm0tPCU9IGlkICU+XFxcIj48L2Rpdj5cXG5cXG48L2xpPlxcblwiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImJveC1wYWQtbHIgYm9yZGVyLWJvdHRvbVxcXCI+XFxuICA8aDI+RGlzY3Vzc2lvblxcbiAgPCUgaWYgKHVzZXIpIHsgJT5cXG4gIDxidXR0b24gY2xhc3M9XFxcImJ0biBidG4tYzAgYnRuLXNtIGZpbGUtYWRkIG5ldy10b3BpY1xcXCIgaWQ9XFxcInByb2plY3QtdG9waWMtbmV3XFxcIj5OZXcgVG9waWM8L2J1dHRvbj5cXG4gIDwlIH0gJT5cXG4gIDwvaDI+XFxuPC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwiYm94LXBhZC1sciBib3gtcGFkLXQgdG9waWMtZm9ybS13cmFwcGVyXFxcIj48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJjb21tZW50LXNwaW5uZXIgZnVsbHdpZHRoIHRleHQtY2VudGVyXFxcIj5cXG4gIExvYWRpbmcgZGlzY3Vzc2lvbi4uLiA8aSBjbGFzcz1cXFwiZmEgZmEtc3Bpbm5lciBmYS1zcGluXFxcIj48L2k+XFxuPC9kaXY+XFxuPHVsIGlkPVxcXCJjb21tZW50LWxpc3QtbnVsbFxcXCI+XFxuICA8bGkgY2xhc3M9XFxcImNvbW1lbnQtaXRlbSBjbGVhcmZpeCBib3JkZXItbGVmdCBib3gtcGFkLWxyXFxcIiBpZD1cXFwiY29tbWVudC1lbXB0eVxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPlxcbiAgICBObyBkaXNjdXNzaW9uIHlldC4gIFN0YXJ0IGEgdG9waWMhXFxuICA8L2xpPlxcbjwvdWw+XFxuXCI7XG4iLCJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciB1dGlsaXRpZXMgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgQXV0b2xpbmtlciA9IHJlcXVpcmUoJ2F1dG9saW5rZXInKTtcbnZhciBDb21tZW50SXRlbVRlbXBsYXRlID0gcmVxdWlyZSgnLi4vdGVtcGxhdGVzL2NvbW1lbnRfaXRlbV90ZW1wbGF0ZS5odG1sJyk7XG5cblxudmFyIENvbW1lbnRJdGVtVmlldyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm1vZGVsLmN1cnJlbnRVc2VyID0gd2luZG93LmNhY2hlLmN1cnJlbnRVc2VyO1xuICAgIHRoaXMubW9kZWwudmFsdWVIdG1sID0gQXV0b2xpbmtlci5saW5rKHRoaXMubW9kZWwudmFsdWUpO1xuICAgIGlmICh0aGlzLm1vZGVsLnRvcGljKSB7XG4gICAgICB2YXIgY29tcGlsZWRUZW1wbGF0ZSA9IF8udGVtcGxhdGUoQ29tbWVudEl0ZW1UZW1wbGF0ZSkodGhpcy5tb2RlbCk7XG4gICAgICB0aGlzLiRlbC5hcHBlbmQoY29tcGlsZWRUZW1wbGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIGlmICh0aGlzLm1vZGVsLnBhcmVudElkID09PSBwYXJzZUludCgkKFwiI2NvbW1lbnQtbGlzdC1cIiArIHRoaXMubW9kZWwucGFyZW50SWQpLmF0dHIoXCJpZFwiKS5zcGxpdChcIi1cIilbJChcIiNjb21tZW50LWxpc3QtXCIrdGhpcy5tb2RlbC5wYXJlbnRJZCkuYXR0cihcImlkXCIpLnNwbGl0KFwiLVwiKS5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgdmFyIG5ld1RlbXBsYXRlID0gXy50ZW1wbGF0ZShDb21tZW50SXRlbVRlbXBsYXRlKSh0aGlzLm1vZGVsKTtcbiAgICAgICAgJChcIiNjb21tZW50LWxpc3QtXCIgKyB0aGlzLm1vZGVsLnBhcmVudElkKS5hcHBlbmQobmV3VGVtcGxhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb21tZW50SXRlbVZpZXc7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGxpIGRhdGEtdmFsdWU9JzwlLSB2YWx1ZSAlPic+XFxuICA8ZGl2IGNsYXNzPVxcXCJhYy1jb250YWluZXJcXFwiPlxcbiAgICA8JSBpZiAoaW1hZ2UgIT09IG51bGwpIHsgJT5cXG4gICAgPGltZyBzcmM9XFxcIjwlLSBpbWFnZSAlPlxcXCIgYWx0PVxcXCI8JS0gdmFsdWUgJT5cXFwiIGNsYXNzPVxcXCJhYy1pbWFnZVxcXCIvPlxcbiAgICA8JSB9IGVsc2UgaWYgKHRhcmdldCA9PSAncHJvamVjdCcpIHsgJT5cXG4gICAgPGltZyBzcmM9XFxcIi9pbWFnZXMvcHJvamVjdF9kZWZhdWx0LnBuZ1xcXCIgYWx0PVxcXCI8JS0gdmFsdWUgJT5cXFwiIGNsYXNzPVxcXCJhYy1pbWFnZVxcXCIvPlxcbiAgICA8JSB9IGVsc2UgeyAlPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJhYy1pbWFnZVxcXCI+PC9kaXY+XFxuICAgIDwlIH0gJT5cXG4gICAgPGRpdiBjbGFzcz1cXFwiYWMtY29udGVudFxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiYWMtdGl0bGVcXFwiPlxcbiAgICAgICAgPCUtIHZhbHVlICU+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiYWMtZGVzY3JpcHRpb25cXFwiPlxcbiAgICAgICAgPCUgaWYgKCh0YXJnZXQgPT0gJ3Byb2plY3QnKSB8fCAodGFyZ2V0ID09ICd1c2VyJykpIHsgJT5cXG4gICAgICAgIDwlPSBkZXNjcmlwdGlvbiAlPlxcbiAgICAgICAgPCUgfSAlPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvbGk+XCI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcImNvbC1sZy0xMiBcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJhbGVydCBhbGVydC1kYW5nZXIgY29tbWVudC1hbGVydC1lbXB0eVxcXCI+XFxuICAgICAgWW91IG11c3QgZW50ZXIgdGV4dCBiZWZvcmUgc3VibWl0dGluZyBhIGNvbW1lbnQuXFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcImNvbC1sZy0xMiBcXFwiPlxcbiAgICA8Zm9ybSBhY3Rpb249XFxcIlxcXCIgY2xhc3M9XFxcImZvcm0taW5saW5lIGNvbW1lbnQtc3VibWl0IDwlIGlmIChmb3JtLnRvcGljKSB7ICU+Y29tbWVudC1mb3JtLXRvcGljPCUgfSAlPlxcXCIgcm9sZT1cXFwiZm9ybVxcXCIgZGF0YS1kZXB0aD1cXFwiPCU9IGZvcm0uZGVwdGggJT5cXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImlucHV0LWdyb3VwXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbW1lbnQtaW5wdXQgZm9ybS1jb250cm9sIGlucHV0LXNtXFxcIiBjb250ZW50RWRpdGFibGU9XFxcInRydWVcXFwiPjwvZGl2PlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcImlucHV0LWdyb3VwLWJ0blxcXCI+XFxuICAgICAgICAgIDxpbnB1dCBjbGFzcz1cXFwiYnRuIGJ0bi1jMiBidG4tc21cXFwiIHR5cGU9XFxcInN1Ym1pdFxcXCIgdmFsdWU9XFxcIjwlIGlmIChmb3JtLnRvcGljKSB7ICU+IFN0YXJ0IFRvcGljIDwlIH0gZWxzZSBpZiAoZm9ybS5kZXB0aCA9PSAxKSB7ICU+IFJlcGx5IDwlIH0gZWxzZSB7ICU+QWRkIENvbW1lbnQ8JSB9ICU+XFxcIiB0aXRsZT1cXFwiPCUgaWYgKGZvcm0udG9waWMpIHsgJT4gU3RhcnQgVG9waWMgPCUgfSBlbHNlIGlmIChmb3JtLmRlcHRoID09IDEpIHsgJT4gUmVwbHkgPCUgfSBlbHNlIHsgJT5BZGQgQ29tbWVudDwlIH0gJT5cXFwiPlxcbiAgICAgICAgPC9zcGFuPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Zvcm0+XFxuICA8L2Rpdj5cXG48L2Rpdj5cXG5cIjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8JSBpZiAodGFyZ2V0ID09ICd1c2VyJykge1xcbiAgJT48YSBocmVmPVxcXCI8JS0gbGluayAlPlxcXCIgY2xhc3M9XFxcImNvbW1lbnQtdXNlci1saW5rXFxcIiBkYXRhLXVzZXJpZD08JS0gaWQgJT4+QDwlLSB2YWx1ZSAlPjwvYT48JSB9XFxuICBlbHNlIGlmICh0YXJnZXQgPT0gJ3Byb2plY3QnKSB7XFxuICAlPjxhIGhyZWY9XFxcIjwlLSBsaW5rICU+XFxcIiBjbGFzcz1cXFwibGluay1iYWNrYm9uZVxcXCI+PCUtIHZhbHVlICU+PC9hPjwlIH1cXG4gIGVsc2Uge1xcbiAgJT48YSBocmVmPVxcXCI8JS0gbGluayAlPlxcXCI+PCUtIHZhbHVlICU+PC9hPjwlIH0gJT5cIjtcbiIsIi8vIFRoaXMgaXMgdGhlIGNvbW1lbnQsIGFuZCB0b3BpYyBmb3JtLlxuLy8gV2Uga25vdyB3aGF0IHRvIGRvIGJhc2VkIG9uIGEgZmxhZyBiZWluZyBwYXNzZWQgaW50byB0aGlzIHZpZXdcbi8vIHZpYSB0aGUgY29udHJvbGxlci4gIFRoYXQgZmxhZyBpczpcbi8vIHRoaXMub3B0aW9ucy50b3BpYyA9IHRydWVcblxuXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIganFDYXJldCA9IHJlcXVpcmUoJ2pxdWVyeS5jYXJldC9kaXN0L2pxdWVyeS5jYXJldC5taW4nKTtcbnZhciBqcUF0ID0gcmVxdWlyZSgnanF1ZXJ5LmF0d2hvL2Rpc3QvanMvanF1ZXJ5LmF0d2hvJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgbWFya2VkID0gcmVxdWlyZSgnbWFya2VkJyk7XG52YXIgQ29tbWVudENvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9lbnRpdGllcy9jb21tZW50cy9jb21tZW50X2NvbGxlY3Rpb24nKTtcbnZhciBDb21tZW50Rm9ybVRlbXBsYXRlID0gcmVxdWlyZSgnLi4vdGVtcGxhdGVzL2NvbW1lbnRfZm9ybV90ZW1wbGF0ZS5odG1sJyk7XG52YXIgQ29tbWVudEFjVGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvY29tbWVudF9hY190ZW1wbGF0ZS5odG1sJyk7XG52YXIgQ29tbWVudElubGluZVRlbXBsYXRlID0gcmVxdWlyZSgnLi4vdGVtcGxhdGVzL2NvbW1lbnRfaW5saW5lX3RlbXBsYXRlLmh0bWwnKTtcblxuXG52YXIgQ29tbWVudEZvcm1WaWV3ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuXG4gIGV2ZW50czoge1xuICAgIFwic3VibWl0IC5jb21tZW50LXN1Ym1pdFwiOiBcInBvc3RcIlxuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnJlbmRlcigpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZGF0YSA9IHsgZm9ybTogdGhpcy5vcHRpb25zIH07XG4gICAgdmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZShDb21tZW50Rm9ybVRlbXBsYXRlKShkYXRhKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMudG9waWMpIHtcbiAgICAgIHRoaXMuJGVsLnByZXBlbmQodGVtcGxhdGUpLmFwcGVuZChcIjxkaXYgY2xhc3M9J2NsZWFyZml4Jz48L2Rpdj5cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJGVsLmFwcGVuZCh0ZW1wbGF0ZSk7XG4gICAgfVxuXG4gICAgdmFyIGdlblRlbXBsYXRlID0gZnVuY3Rpb24gKHRlbXBsYXRlLCBkYXRhKSB7XG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgLy8gdXNlIHRoZSBhZ2VuY3kvb2ZmaWNlIG5hbWUgYXMgdGhlIGRlc2NyaXB0aW9uXG4gICAgICAvLyBpZiBub25lIGV4aXN0cywgdXNlIHRoZSBqb2IgdGl0bGUuXG4gICAgICAvLyBvdGhlcndpc2UgbGVhdmUgYmxhbmsuXG4gICAgICBpZiAoZGF0YS50YXJnZXQgPT0gJ3VzZXInKSB7XG4gICAgICAgIGlmIChkYXRhLmFnZW5jeSkge1xuICAgICAgICAgIGRhdGEuZGVzY3JpcHRpb24gPSBkYXRhLmFnZW5jeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhLnRpdGxlKSB7XG4gICAgICAgICAgZGF0YS5kZXNjcmlwdGlvbiA9IGRhdGEudGl0bGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGF0YS5kZXNjcmlwdGlvbiA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBjb252ZXJ0IGRlc2NyaXB0aW9ucyB0byBtYXJrZG93bi9odG1sXG4gICAgICBpZiAoZGF0YS50YXJnZXQgPT0gJ3Byb2plY3QnKSB7XG4gICAgICAgIGlmIChkYXRhLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgZGF0YS5kZXNjcmlwdGlvbiA9IG1hcmtlZChkYXRhLmRlc2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGEuY292ZXJJZCkge1xuICAgICAgICAgIGRhdGEuY292ZXJJZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghZGF0YS5pbWFnZSkge1xuICAgICAgICBkYXRhLmltYWdlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIHJlbmRlciB0ZW1wbGF0ZVxuICAgICAgcmV0dXJuIF8udGVtcGxhdGUodGVtcGxhdGUpKGRhdGEpO1xuICAgIH07XG5cbiAgICB0aGlzLiQoXCIuY29tbWVudC1pbnB1dFwiKS5hdHdobyh7XG4gICAgICBhdDogJ0AnLFxuICAgICAgc2VhcmNoX2tleTogJ3ZhbHVlJyxcbiAgICAgIHRwbDogQ29tbWVudEFjVGVtcGxhdGUsXG4gICAgICBpbnNlcnRfdHBsOiBDb21tZW50SW5saW5lVGVtcGxhdGUsXG4gICAgICBsaW1pdDogMTAsXG4gICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgdHBsX2V2YWw6IGdlblRlbXBsYXRlLFxuICAgICAgICBzb3J0ZXI6IGZ1bmN0aW9uIChxdWVyeSwgaXRlbXMsIHNlYXJjaF9rZXkpIHtcbiAgICAgICAgICAvLyBkb24ndCBzb3J0LCB1c2UgdGhlIG9yZGVyIGZyb20gdGhlIHNlcnZlclxuICAgICAgICAgIHJldHVybiBpdGVtcztcbiAgICAgICAgfSxcbiAgICAgICAgaGlnaGxpZ2h0ZXI6IGZ1bmN0aW9uIChsaSwgcXVlcnkpIHtcbiAgICAgICAgICByZXR1cm4gbGk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGhpZ2hsaWdodGVyOiBmdW5jdGlvbiAobGksIHF1ZXJ5KSB7XG4gICAgICAgIC8vICAgdmFyIHJlZ2V4cDtcbiAgICAgICAgLy8gICBpZiAoIXF1ZXJ5KSB7XG4gICAgICAgIC8vICAgICByZXR1cm4gbGk7XG4gICAgICAgIC8vICAgfVxuICAgICAgICAvLyAgIC8vIGp1c3Qgd2FudCB0byBmaW5kIGFsbCBjYXNlIGluc2Vuc2l0aXZlIG1hdGNoZXMgYW5kIHJlcGxhY2Ugd2l0aCA8c3Ryb25nPlxuICAgICAgICAvLyAgIC8vIHNldCB1cCB0aGUgcXVlcnkgYXMgYSByZWd1bGFyIGV4cHJlc3Npb25cbiAgICAgICAgLy8gICB2YXIgcmUgPSBuZXcgUmVnRXhwKCcoJyArIHF1ZXJ5LnJlcGxhY2UoLyhbLiorP149IToke30oKXxcXFtcXF1cXC9cXFxcXSkvZywgXCJcXFxcJDFcIikgKyAnKScsICdpZycpO1xuICAgICAgICAvLyAgIC8vIHBhcnNlIHRoZSBsaSBzdHJpbmcgaW50byBhIERPTSBub2RlXG4gICAgICAgIC8vICAgdmFyIGxpRG9tID0gJC5wYXJzZUhUTUwobGkpO1xuICAgICAgICAvLyAgIHZhciB0ZXh0ID0gJChsaURvbVswXSkudGV4dCgpLnJlcGxhY2UocmUsIFwiPHN0cm9uZz4kMTwvc3Ryb25nPlwiKTtcbiAgICAgICAgLy8gICAkKGxpRG9tWzBdKS5odG1sKHRleHQpO1xuICAgICAgICAvLyAgIHJldHVybiBsaURvbVswXTtcbiAgICAgICAgLy8gfSxcbiAgICAgICAgcmVtb3RlX2ZpbHRlcjogZnVuY3Rpb24gKHF1ZXJ5LCBjYWxsYmFjaykge1xuICAgICAgICAgIC8vIGdldCBkYXRhIGZyb20gdGhlIHNlcnZlclxuICAgICAgICAgICQuZ2V0SlNPTihcIi9hcGkvYWMvaW5saW5lXCIsIHsgcTogcXVlcnkgfSwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIF8uZWFjaChkYXRhLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAvLyBBdC5qcyBleHBlY3RzIHRoZSBuYW1lIHRvIGJlIHNldCBmb3IgdGhlIG1hdGNoZXIgZm5cbiAgICAgICAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQoZC5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGQubmFtZSA9IGQudmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KS5vbihcImluc2VydGVkLmF0d2hvXCIsIGZ1bmN0aW9uKGV2ZW50LCAkbGkpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBoYWNrIHRvIGhpZGUgdGhlIHNwYWNlIGFmdGVyIGluc2VydGluZyBhbiBlbGVtZW50LlxuICAgICAgdmFyIGlkcyA9IHNlbGYuJChcInNwYW4uYXR3aG8tdmlldy1mbGFnID4gc3Bhbjp2aXNpYmxlXCIpO1xuICAgICAgLy8gaW5zZXJ0IGEgbm9uLWJyZWFraW5nIHNwYWNlIGFmdGVyIHRoZSBpbnNlcnRlZCBlbGVtZW50LCBidXQgbm90IHdpdGhpbiBpdFxuICAgICAgLy8gdGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gZGVsZXRlIHRoYXQgc3BhY2UgaWYgdGhleSB3YW50IHRvLCB3aXRob3V0IGRlbGV0aW5nXG4gICAgICAvLyB0aGUgcmVmZXJlbmNlZCBlbGVtZW50XG4gICAgICBpZHMucGFyZW50KCkuYWZ0ZXIoJyZuYnNwOycpO1xuICAgICAgaWRzLmhpZGUoKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHBvc3Q6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIHZhciBjb21tZW50SHRtbCA9IHRoaXMuJChcIi5jb21tZW50LWlucHV0XCIpLmh0bWwoKTtcbiAgICB2YXIgY29tbWVudFRleHQgPSB0aGlzLiQoXCIuY29tbWVudC1pbnB1dFwiKS50ZXh0KCkudHJpbSgpO1xuXG4gICAgLy8gYWJvcnQgaWYgdGhlIGNvbW1lbnQgaXMgZW1wdHlcbiAgICBpZiAoIWNvbW1lbnRUZXh0KSB7XG4gICAgICB0aGlzLiQoJy5jb21tZW50LWFsZXJ0LWVtcHR5Jykuc2hvdygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYXJlbnRJZDtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMucGFyZW50SWQpIHtcbiAgICAgIHBhcmVudElkID0gcGFyc2VJbnQodGhpcy5vcHRpb25zLnBhcmVudElkKTtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIGNvbW1lbnQgICA6IGNvbW1lbnRIdG1sLFxuICAgICAgdG9waWMgICAgIDogZmFsc2VcbiAgICB9O1xuICAgIGRhdGFbdGhpcy5vcHRpb25zLnRhcmdldCArICdJZCddID0gdGhpcy5vcHRpb25zW3RoaXMub3B0aW9ucy50YXJnZXQgKyAnSWQnXTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMudG9waWMpIHtcbiAgICAgIGRhdGEudG9waWMgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhLnBhcmVudElkID0gcGFyZW50SWQ7XG4gICAgfVxuICAgIHRoaXMuJCgnLmNvbW1lbnQtYWxlcnQtZW1wdHknKS5oaWRlKCk7XG5cbiAgICB2YXIgY3VycmVudFRhcmdldCA9IGUuY3VycmVudFRhcmdldDtcbiAgICB0aGlzLmNvbGxlY3Rpb24udHJpZ2dlcihcImNvbW1lbnQ6c2F2ZVwiLCBkYXRhLCBjdXJyZW50VGFyZ2V0KTtcbiAgfSxcblxuICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb21tZW50Rm9ybVZpZXc7XG4iLCJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL21peGlucy91dGlsaXRpZXMnKTtcbnZhciBQb3BvdmVycyA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL21peGlucy9wb3BvdmVycycpO1xudmFyIEV2ZW50c0NvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9lbnRpdGllcy9ldmVudHMvZXZlbnRzX2NvbGxlY3Rpb24nKTtcbnZhciBFdmVudENvbGxlY3Rpb25WaWV3ID0gcmVxdWlyZSgnLi4vdmlld3MvZXZlbnRfY29sbGVjdGlvbl92aWV3Jyk7XG52YXIgTW9kYWxDb21wb25lbnQgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb21wb25lbnRzL21vZGFsJyk7XG52YXIgRXZlbnRGb3JtVmlldyA9IHJlcXVpcmUoJy4uLy4uL25ldy92aWV3cy9ldmVudF9mb3JtX3ZpZXcnKTtcblxuXG52YXIgcG9wb3ZlcnMgPSBuZXcgUG9wb3ZlcnMoKTtcblxuRXZlbnRMaXN0ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuXG4gIGVsOiBcIiNldmVudC1saXN0LXdyYXBwZXJcIixcblxuICBldmVudHM6IHtcbiAgICAnY2xpY2sgLmFkZC1ldmVudCcgICAgICAgICAgICAgICAgOiAnYWRkJyxcbiAgICAnY2xpY2sgLnJzdnAnICAgICAgICAgICAgICAgICAgICAgOiAndG9nZ2xlUlNWUCcsXG4gICAgJ21vdXNlZW50ZXIgLmRhdGEtZXZlbnQtZmxhZy10cnVlJzogJ2J1dHRvblJTVlBPbicsXG4gICAgJ21vdXNlbGVhdmUgLmRhdGEtZXZlbnQtZmxhZy10cnVlJzogJ2J1dHRvblJTVlBPZmYnLFxuICAgIFwibW91c2VlbnRlciAucHJvamVjdC1wZW9wbGUtZGl2XCIgIDogcG9wb3ZlcnMucG9wb3ZlclBlb3BsZU9uLFxuICAgIFwiY2xpY2sgLnByb2plY3QtcGVvcGxlLWRpdlwiICAgICAgIDogcG9wb3ZlcnMucG9wb3ZlckNsaWNrXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKHNldHRpbmdzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMub3B0aW9ucyA9IF8uZXh0ZW5kKHNldHRpbmdzLCB0aGlzLmRlZmF1bHRzKTtcbiAgICB0aGlzLnJlcXVlc3RFdmVudHNDb2xsZWN0aW9uRGF0YSgpO1xuICB9LFxuXG4gIHJlcXVlc3RFdmVudHNDb2xsZWN0aW9uRGF0YTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmNvbGxlY3Rpb24gPSBuZXcgRXZlbnRzQ29sbGVjdGlvbigpO1xuICAgIHRoaXMuY29sbGVjdGlvbi5mZXRjaCh7XG4gICAgICB1cmw6ICcvYXBpL2V2ZW50L2ZpbmRBbGxCeVByb2plY3RJZC8nICsgcGFyc2VJbnQodGhpcy5vcHRpb25zLnByb2plY3RJZCksXG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoY29sbGVjdGlvbikge1xuICAgICAgICBzZWxmLmNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuICAgICAgICBzZWxmLnJlbmRlckV2ZW50Q29sbGVjdGlvblZpZXcoY29sbGVjdGlvbik7XG4gICAgICB9XG4gICAgfSlcbiAgfSxcblxuICByZW5kZXJFdmVudENvbGxlY3Rpb25WaWV3OiBmdW5jdGlvbiAoY29sbGVjdGlvbikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29sbGVjdGlvbiwgXCJldmVudDpzYXZlOnN1Y2Nlc3NcIiwgZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAkKCcjYWRkRXZlbnQnKS5iaW5kKCdoaWRkZW4uYnMubW9kYWwnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5yZXF1ZXN0RXZlbnRzQ29sbGVjdGlvbkRhdGEoKTtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRGb3JtVmlldykgdGhpcy5ldmVudEZvcm1WaWV3LmNsZWFudXAoKTtcbiAgICAgICAgaWYgKHRoaXMubW9kYWxDb21wb25lbnQpIHRoaXMubW9kYWxDb21wb25lbnQuY2xlYW51cCgpO1xuICAgICAgfSkubW9kYWwoJ2hpZGUnKTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmV2ZW50Q29sbGVjdGlvblZpZXcpIHtcbiAgICAgIHRoaXMuZXZlbnRDb2xsZWN0aW9uVmlldy5jbGVhbnVwKCk7XG4gICAgfVxuXG4gICAgdGhpcy5ldmVudENvbGxlY3Rpb25WaWV3ID0gbmV3IEV2ZW50Q29sbGVjdGlvblZpZXcoe1xuICAgICAgZWw6IFwiI2V2ZW50LWxpc3Qtd3JhcHBlclwiLFxuICAgICAgb25SZW5kZXI6IHRydWUsXG4gICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLFxuICAgICAgcHJvamVjdElkOiB0aGlzLm9wdGlvbnMucHJvamVjdElkXG4gICAgfSk7XG5cbiAgICBwb3BvdmVycy5wb3BvdmVyUGVvcGxlSW5pdChcIi5wcm9qZWN0LXBlb3BsZS1kaXZcIik7XG4gIH0sXG5cbiAgYWRkOiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAvLyBjbGVhbnVwIGV4aXN0aW5nIHZpZXdzXG4gICAgaWYgKHRoaXMuZXZlbnRGb3JtVmlldykgdGhpcy5ldmVudEZvcm1WaWV3LmNsZWFudXAoKTtcbiAgICBpZiAodGhpcy5tb2RhbENvbXBvbmVudCkgdGhpcy5tb2RhbENvbXBvbmVudC5jbGVhbnVwKCk7XG5cbiAgICAvLyBpbnN0YW50aWF0ZSB0aGUgbW9kYWwgd2l0aCB0aGUgZXZlbnQgZm9ybSB2aWV3XG4gICAgdGhpcy5tb2RhbENvbXBvbmVudCA9IG5ldyBNb2RhbENvbXBvbmVudCh7XG4gICAgICBlbDogXCIjZXZlbnQtbW9kYWwtYWRkXCIsXG4gICAgICBpZDogXCJhZGRFdmVudFwiLFxuICAgICAgbW9kYWxUaXRsZTogJ0FkZCBFdmVudCdcbiAgICB9KS5yZW5kZXIoKTtcblxuICAgIHRoaXMuZXZlbnRGb3JtVmlldyA9IG5ldyBFdmVudEZvcm1WaWV3KHtcbiAgICAgIGVsOiBcIiNldmVudC1tb2RhbC1hZGQgLm1vZGFsLXRlbXBsYXRlXCIsXG4gICAgICBwcm9qZWN0SWQ6IHRoaXMub3B0aW9ucy5wcm9qZWN0SWQsXG4gICAgICBjb2xsZWN0aW9uOiB0aGlzLmNvbGxlY3Rpb25cbiAgICB9KS5yZW5kZXIoKTtcbiAgfSxcblxuICB1cGRhdGVQZW9wbGU6IGZ1bmN0aW9uIChlLCBpbmMpIHtcbiAgICB2YXIgcGVvcGxlRGl2ID0gJCgkKGUuY3VycmVudFRhcmdldCkucGFyZW50cygnLmV2ZW50JylbMF0pLmZpbmQoJy5ldmVudC1wZW9wbGUnKVswXTtcbiAgICB2YXIgbnVtRGl2ID0gJChwZW9wbGVEaXYpLmNoaWxkcmVuKCcuZXZlbnQtcGVvcGxlLW51bWJlcicpO1xuICAgIHZhciBuZXdOdW0gPSBwYXJzZUludCgkKG51bURpdikuaHRtbCgpKTtcbiAgICBpZiAoaW5jKSB7XG4gICAgICBuZXdOdW0rK1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdOdW0tLTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYWxsb3cgcmFjZSBjb25kaXRpb25zIHRvIHNldCB0aGUgbnVtYmVyIG9mIHBlb3BsZSBiZWxvdyB6ZXJvXG4gICAgaWYgKG5ld051bSA8IDApIHtcbiAgICAgIG5ld051bSA9IDA7XG4gICAgfVxuICAgICQobnVtRGl2KS5odG1sKG5ld051bSk7XG4gICAgdmFyIHRleHREaXYgPSAkKHBlb3BsZURpdikuY2hpbGRyZW4oJy5ldmVudC1wZW9wbGUtdGV4dCcpWzBdO1xuICAgIGlmIChuZXdOdW0gPT0gMSkge1xuICAgICAgJCh0ZXh0RGl2KS5odG1sKCQodGV4dERpdikuZGF0YSgnc2luZ3VsYXInKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICQodGV4dERpdikuaHRtbCgkKHRleHREaXYpLmRhdGEoJ3BsdXJhbCcpKTtcbiAgICB9XG4gIH0sXG5cbiAgYnV0dG9uUlNWUE9uOiBmdW5jdGlvbiAoZSkge1xuICAgICQoZS5jdXJyZW50VGFyZ2V0KS5idXR0b24oJ2hvdmVyJyk7XG4gIH0sXG5cbiAgYnV0dG9uUlNWUE9mZjogZnVuY3Rpb24gKGUpIHtcbiAgICAkKGUuY3VycmVudFRhcmdldCkuYnV0dG9uKCdnb2luZycpO1xuICB9LFxuXG4gIHRvZ2dsZVJTVlA6IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgLy8gZ2V0IHRoZSBpZCBmcm9tIHRoZSBwYXJlbnQgZXZlbnQgZGl2XG4gICAgdmFyIGlkID0gJCgkKGUuY3VycmVudFRhcmdldCkucGFyZW50cygnZGl2LmV2ZW50JylbMF0pLmRhdGEoJ2lkJyk7XG4gICAgaWYgKCQoXCIucnN2cFwiKS5oYXNDbGFzcyhcImRhdGEtZXZlbnQtZmxhZy10cnVlXCIpID09PSBmYWxzZSkge1xuICAgICAgJChcIi5yc3ZwXCIpLnJlbW92ZUNsYXNzKFwiZGF0YS1ldmVudC1mbGFnLWZhbHNlXCIpO1xuICAgICAgJChcIi5yc3ZwXCIpLmFkZENsYXNzKFwiZGF0YS1ldmVudC1mbGFnLXRydWVcIik7XG4gICAgICAkKGUuY3VycmVudFRhcmdldCkuYnV0dG9uKCdnb2luZycpO1xuICAgICAgc2VsZi51cGRhdGVQZW9wbGUoZSwgdHJ1ZSk7XG4gICAgICAkLmFqYXgoe1xuICAgICAgICB1cmw6ICcvYXBpL2V2ZW50L2F0dGVuZC8nICsgaWQsXG4gICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAkKFwiLnJzdnBcIikucmVtb3ZlQ2xhc3MoXCJkYXRhLWV2ZW50LWZsYWctdHJ1ZVwiKTtcbiAgICAgICQoXCIucnN2cFwiKS5hZGRDbGFzcyhcImRhdGEtZXZlbnQtZmxhZy1mYWxzZVwiKTtcbiAgICAgICQoZS5jdXJyZW50VGFyZ2V0KS5idXR0b24oJ3JzdnAnKTtcbiAgICAgIHNlbGYudXBkYXRlUGVvcGxlKGUsIGZhbHNlKTtcbiAgICAgICQuYWpheCh7XG4gICAgICAgIHVybDogJy9hcGkvZXZlbnQvY2FuY2VsLycgKyBpZCxcbiAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH0sXG5cbiAgY2xlYW51cDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmV2ZW50Q29sbGVjdGlvblZpZXcpIHRoaXMuZXZlbnRDb2xsZWN0aW9uVmlldy5jbGVhbnVwKCk7XG4gICAgaWYgKHRoaXMuZXZlbnRGb3JtVmlldykgdGhpcy5ldmVudEZvcm1WaWV3LmNsZWFudXAoKTtcbiAgICBpZiAodGhpcy5tb2RhbENvbXBvbmVudCkgdGhpcy5tb2RhbENvbXBvbmVudC5jbGVhbnVwKCk7XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudExpc3RcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJib3gtcGFkLWxyIGJvcmRlci1ib3R0b21cXFwiPlxcbiAgPGgyPlxcbiAgICBVcGNvbWluZyBFdmVudHNcXG4gICAgPCUgaWYgKHVzZXIpIHsgJT5cXG4gICAgPGEgaHJlZj1cXFwiI2FkZEV2ZW50XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1jMCBidG4tc20gZmlsZS1hZGQgYWRkLWV2ZW50XFxcIiBkYXRhLXRvZ2dsZT1cXFwibW9kYWxcXFwiIGRhdGEtYmFja2Ryb3A9XFxcInN0YXRpY1xcXCI+QWRkIEV2ZW50PC9hPlxcbiAgICA8JSB9ICU+XFxuICA8L2gyPlxcbjwvZGl2PlxcblxcbjxkaXYgaWQ9XFxcImV2ZW50LW1vZGFsLWFkZFxcXCI+PC9kaXY+XFxuXFxuPGRpdiBjbGFzcz1cXFwidGFzay1zY3JvbGxcXFwiPlxcblxcbiAgPCUgaWYgKGV2ZW50cy5sZW5ndGggPT0gMCkgeyAlPlxcblxcbiAgPGRpdiBjbGFzcz1cXFwiZXZlbnQgYm9yZGVyLWxlZnRcXFwiIGRhdGEtaWQ9XFxcIm51bGxcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJldmVudC10aXRsZVxcXCI+XFxuICAgICAgTm8gZXZlbnRzIHNjaGVkdWxlZC5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG5cXG4gIDwlIH0gZWxzZSB7ICU+XFxuXFxuICA8JSBfLmVhY2goZXZlbnRzLCBmdW5jdGlvbiAoZXZlbnQsIGl0ZXJhdG9yKSB7ICU+XFxuICA8ZGl2IGNsYXNzPVxcXCJldmVudCBib3JkZXItbGVmdFxcXCIgZGF0YS1pZD1cXFwiPCU9IGV2ZW50LmlkICU+XFxcIj5cXG4gICAgPCUgaWYgKHVzZXIpIHsgJT5cXG4gICAgPGRpdiBjbGFzcz1cXFwiZXZlbnQtYnV0dG9uIHB1bGwtcmlnaHRcXFwiPlxcbiAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ0biBidG4tYzIgYnRuLXNtIHJzdnAgZGF0YS1ldmVudC1mbGFnLTwlPSBldmVudC5yc3ZwICU+XFxcIiBkYXRhLWdvaW5nLXRleHQ9XFxcIjxpIGNsYXNzPSdmYSBmYS1jaGVjayc+PC9pPiBJJ20gZ29pbmdcXFwiIGRhdGEtcnN2cC10ZXh0PVxcXCJSU1ZQXFxcIiBkYXRhLWhvdmVyLXRleHQ9XFxcIkNhbmNlbCBSU1ZQXFxcIj48JSBpZiAoZXZlbnQucnN2cCkgeyAlPjxpIGNsYXNzPSdmYSBmYS1jaGVjayc+PC9pPiBJJ20gZ29pbmc8JSB9IGVsc2UgeyAlPlJTVlA8JSB9ICU+PC9idXR0b24+XFxuICAgIDwvZGl2PlxcbiAgICA8JSB9ICU+XFxuICAgIDxkaXYgY2xhc3M9XFxcImV2ZW50LXRpdGxlXFxcIj5cXG4gICAgICA8JS0gZXZlbnQudGl0bGUgJT5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcImV2ZW50LWRlc2NyaXB0aW9uXFxcIj5cXG4gICAgICA8JS0gZXZlbnQuZGVzY3JpcHRpb24gJT5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcImV2ZW50LXRhZ1xcXCI+XFxuICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWNhbGVuZGFyXFxcIj48L2k+XFxuICAgICAgPHNwYW4gY2xhc3M9XFxcImJveC1pY29uLXRleHRcXFwiPlxcbiAgICAgIDwhLS0gZGF5IC0tPlxcbiAgICAgIDwlIHZhciBzdCA9IG5ldyBEYXRlKGV2ZW50LnN0YXJ0KTsgdmFyIGV0ID0gbmV3IERhdGUoZXZlbnQuZW5kKTsgJT5cXG4gICAgICA8JT0gc3QudG9Mb2NhbGVEYXRlU3RyaW5nKCkgJT5cXG4gICAgICA8JSBpZiAoc3QudG9Mb2NhbGVEYXRlU3RyaW5nKCkgIT0gZXQudG9Mb2NhbGVEYXRlU3RyaW5nKCkpIHsgJT5cXG4gICAgICAtIDwlPSBldC50b0xvY2FsZURhdGVTdHJpbmcoKSAlPlxcbiAgICAgIDwlIH0gJT5cXG4gICAgICA8IS0tIHRpbWUgLS0+XFxuICAgICAgPCU9IHN0LnRvTG9jYWxlVGltZVN0cmluZygpICU+XFxuICAgICAgPCUgaWYgKHN0LnRvTG9jYWxlRGF0ZVN0cmluZygpID09IGV0LnRvTG9jYWxlRGF0ZVN0cmluZygpKSB7ICU+XFxuICAgICAgLSA8JT0gZXQudG9Mb2NhbGVUaW1lU3RyaW5nKCkgJT5cXG4gICAgICA8JSB9ICU+XFxuICAgICAgPC9zcGFuPlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiZXZlbnQtdGFnXFxcIj5cXG4gICAgICA8c3BhbiBjbGFzcz1cXFwiZmEgZmEtbWFwLW1hcmtlclxcXCI+PC9zcGFuPlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJib3gtaWNvbi10ZXh0XFxcIj5cXG4gICAgICA8JT0gZXZlbnQubG9jYXRpb24gJT5cXG4gICAgICA8L3NwYW4+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJldmVudC10YWdcXFwiPlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJldmVudC1pY29uLWNlbnRlclxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLW1hbGVcXFwiPjwvaT48L3NwYW4+XFxuICAgICAgPHNwYW4gY2xhc3M9XFxcImJveC1pY29uLXRleHQgZXZlbnQtcGVvcGxlXFxcIj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJldmVudC1wZW9wbGUtbnVtYmVyXFxcIj48JT0gZXZlbnQucnN2cHMubGVuZ3RoICU+PC9zcGFuPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcImV2ZW50LXBlb3BsZS10ZXh0XFxcIiBkYXRhLXBsdXJhbD1cXFwicGVvcGxlXFxcIiBkYXRhLXNpbmd1bGFyPVxcXCJwZXJzb25cXFwiPlxcbiAgICAgICAgPCUgaWYgKGV2ZW50LnJzdnBzLmxlbmd0aCA9PSAxKSB7ICU+XFxuICAgICAgICAgIHBlcnNvblxcbiAgICAgICAgPCUgfSBlbHNlIHsgJT5cXG4gICAgICAgICAgcGVvcGxlXFxuICAgICAgICA8JSB9ICU+XFxuICAgICAgICA8L3NwYW4+XFxuICAgICAgICBnb2luZ1xcbiAgICAgIDwvc3Bhbj5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG4gIDwlIH0pOyAlPlxcblxcbiAgPCUgfSAlPlxcbjwvZGl2PlxcblwiO1xuIiwiXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgRXZlbnRMaXN0VGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvZXZlbnRfY29sbGVjdGlvbl92aWV3X3RlbXBsYXRlLmh0bWwnKTtcblxuXG52YXIgRXZlbnRDb2xsZWN0aW9uVmlldyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcblxuICBlbDogXCIjZXZlbnQtbGlzdC13cmFwcGVyXCIsXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV2ZW50c0pTT04gPSB7XG4gICAgICBldmVudHM6IHRoaXMub3B0aW9ucy5jb2xsZWN0aW9uLnRvSlNPTigpLFxuICAgICAgcHJvamVjdElkOiB0aGlzLm9wdGlvbnMucHJvamVjdElkLFxuICAgICAgdXNlcjogd2luZG93LmNhY2hlLmN1cnJlbnRVc2VyXG4gICAgfVxuXG4gICAgdGhpcy5jb21waWxlZFRlbXBsYXRlID0gXy50ZW1wbGF0ZShFdmVudExpc3RUZW1wbGF0ZSkoZXZlbnRzSlNPTik7XG4gICAgdGhpcy4kZWwuaHRtbCh0aGlzLmNvbXBpbGVkVGVtcGxhdGUpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgY2xlYW51cDogZnVuY3Rpb24gKCkge1xuICAgIHJlbW92ZVZpZXcodGhpcyk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRDb2xsZWN0aW9uVmlldztcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8Zm9ybSBpZD1cXFwiZXZlbnQtZm9ybVxcXCIgY2xhc3M9XFxcImZvcm0taG9yaXpvbnRhbFxcXCIgc3R5bGU9XFxcImRpc3BsYXk6IGJsb2NrO1xcXCI+XFxuXFxuICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1ib2R5XFxcIj5cXG5cXG4gICAgPGZpZWxkc2V0PlxcblxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwiZXZlbnQtdGl0bGVcXFwiIGNsYXNzPVxcXCJjb2wtbGctMiBjb250cm9sLWxhYmVsXFxcIj5UaXRsZTwvbGFiZWw+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbGctMTBcXFwiPlxcbiAgICAgICAgICA8aW5wdXQgaWQ9XFxcImV2ZW50LXRpdGxlXFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBkYXRhLXZhbGlkYXRlPVxcXCJlbXB0eSxjb3VudDEwMFxcXCI+XFxuICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJoZWxwLWJsb2NrIGVycm9yLWVtcHR5XFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI+WW91IG11c3QgZW50ZXIgYW4gZXZlbnQgdGl0bGUuPC9zcGFuPlxcbiAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaGVscC1ibG9jayBlcnJvci1jb3VudDEwMFxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPlRoZSBldmVudCB0aXRsZSBtdXN0IGJlIGxlc3MgdGhhbiAxMDAgY2hhcmFjdGVycy48L3NwYW4+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcImV2ZW50LWRlc2NyaXB0aW9uXFxcIiBjbGFzcz1cXFwiY29sLWxnLTIgY29udHJvbC1sYWJlbFxcXCI+RGVzY3JpcHRpb248L2xhYmVsPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLWxnLTEwXFxcIj5cXG4gICAgICAgICAgPHRleHRhcmVhIGlkPVxcXCJldmVudC1kZXNjcmlwdGlvblxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgdHlwZT1cXFwidGV4dFxcXCIgZGF0YS12YWxpZGF0ZT1cXFwiZW1wdHksY291bnQyNTBcXFwiIHJvd3M9XFxcIjNcXFwiPjwvdGV4dGFyZWE+XFxuICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJoZWxwLWJsb2NrIGVycm9yLWVtcHR5XFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI+WW91IG11c3QgZW50ZXIgYW4gZXZlbnQgZGVzY3JpcHRpb24uPC9zcGFuPlxcbiAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaGVscC1ibG9jayBlcnJvci1jb3VudDEwMFxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPlRoZSBldmVudCBkZXNjcmlwdGlvbiBtdXN0IGJlIGxlc3MgdGhhbiAyNTAgY2hhcmFjdGVycy48L3NwYW4+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcImV2ZW50LXN0YXJ0XFxcIiBjbGFzcz1cXFwiY29sLW1kLTIgY29udHJvbC1sYWJlbFxcXCI+VGltZTwvbGFiZWw+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMiBwYWRkaW5nLXJpZ2h0LW5vbmVcXFwiPlxcbiAgICAgICAgICA8aW5wdXQgaWQ9XFxcImV2ZW50LXN0YXJ0XFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sIGZ1bGx3aWR0aFxcXCIgdHlwZT1cXFwidGV4dFxcXCI+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0yIHBhZGRpbmctbm9uZVxcXCIgaWQ9XFxcImRpdi1ldmVudC1zdGFydC10aW1lXFxcIj5cXG4gICAgICAgICAgPGlucHV0IGlkPVxcXCJldmVudC1zdGFydC10aW1lXFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sIGZ1bGx3aWR0aCB0aW1lcGlja2VyXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTEgY29udHJvbC1sYWJlbFxcXCI+XFxuICAgICAgICAgIHRvXFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0yIHBhZGRpbmctbm9uZVxcXCIgaWQ9XFxcImRpdi1ldmVudC1lbmQtdGltZVxcXCI+XFxuICAgICAgICAgIDxpbnB1dCBpZD1cXFwiZXZlbnQtZW5kLXRpbWVcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2wgZnVsbHdpZHRoIHRpbWVwaWNrZXJcXFwiIHR5cGU9XFxcInRleHRcXFwiPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMiBwYWRkaW5nLW5vbmVcXFwiPlxcbiAgICAgICAgICA8aW5wdXQgaWQ9XFxcImV2ZW50LWVuZFxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbCBmdWxsd2lkdGhcXFwiIHR5cGU9XFxcInRleHRcXFwiPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuXFxuICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCIgc3R5bGU9XFxcIm1hcmdpbi10b3A6IC0xMHB4O1xcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMTAgY29sLW1kLW9mZnNldC0yIGV2ZW50LXRpbWV6b25lXFxcIj5cXG4gICAgICAgICAgWW91ciB0aW1lIHpvbmUgaXMgc2V0IHRvIDxzcGFuIGNsYXNzPVxcXCJ0aW1lem9uZVxcXCI+Tm9uZTwvc3Bhbj4uXFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcImV2ZW50LWxvY2F0aW9uXFxcIiBjbGFzcz1cXFwiY29sLWxnLTIgY29udHJvbC1sYWJlbFxcXCI+TG9jYXRpb248L2xhYmVsPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLWxnLTEwXFxcIj5cXG4gICAgICAgICAgPGlucHV0IGlkPVxcXCJldmVudC1sb2NhdGlvblxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgdHlwZT1cXFwidGV4dFxcXCIgZGF0YS12YWxpZGF0ZT1cXFwiZW1wdHlcXFwiPlxcbiAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaGVscC1ibG9jayBlcnJvci1lbXB0eVxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPllvdSBtdXN0IGVudGVyIGFuIGV2ZW50IGxvY2F0aW9uLjwvc3Bhbj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcblxcbiAgICA8L2ZpZWxkc2V0PlxcbiAgPC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1mb290ZXJcXFwiPlxcbiAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tYzAgd2l6YXJkLWNhbmNlbFxcXCIgZGF0YS1kaXNtaXNzPVxcXCJtb2RhbFxcXCI+Q2FuY2VsPC9idXR0b24+XFxuICAgIDxidXR0b24gY2xhc3M9XFxcImJ0biBidG4tYzJcXFwiIHR5cGU9XFxcInN1Ym1pdFxcXCI+QWRkIEV2ZW50PC9idXR0b24+XFxuICA8L2Rpdj5cXG5cXG48L2Zvcm0+XFxuXCI7XG4iLCJcbnZhciBCb290c3RyYXAgPSByZXF1aXJlKCdib290c3RyYXAnKTtcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL21peGlucy91dGlsaXRpZXMnKTtcbnZhciBEYXRlUGlja2VyID0gcmVxdWlyZSgnYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyL3NyYy9qcy9ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXInKTtcbnZhciBUaW1lUGlja2VyID0gcmVxdWlyZSgndGltZXBpY2tlci9qcXVlcnkudGltZXBpY2tlcicpO1xudmFyIEV2ZW50c0NvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9lbnRpdGllcy9ldmVudHMvZXZlbnRzX2NvbGxlY3Rpb24nKTtcbnZhciBFdmVudEZvcm1UZW1wbGF0ZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy9ldmVudF9mb3JtX3RlbXBsYXRlLmh0bWwnKTtcblxuXG52YXIgRXZlbnRGb3JtVmlldyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcblxuICBlbDogXCIjZXZlbnQtbGlzdC13cmFwcGVyXCIsXG5cbiAgZXZlbnRzOiB7XG4gICAgLy8gZmllbGQgdmFsaWRhdGlvblxuICAgIFwiYmx1ciAjZXZlbnQtdGl0bGVcIiAgICAgICA6IFwidlwiLFxuICAgIFwiYmx1ciAjZXZlbnQtZGVzY3JpcHRpb25cIiA6IFwidlwiLFxuICAgIFwiYmx1ciAjZXZlbnQtbG9jYXRpb25cIiAgICA6IFwidlwiLFxuICAgIC8vIGZvcm0gc3VibWlzc2lvblxuICAgIFwic3VibWl0ICNldmVudC1mb3JtXCIgICAgICA6IFwicG9zdFwiXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuXG4gIGluaXRpYWxpemVUaW1lWm9uZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBvZmZzZXQgPSAobmV3IERhdGUoKSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICB2YXIgdGltZXpvbmVzID0ge1xuICAgICAgICAnLTEyJzogJ1BhY2lmaWMvS3dhamFsZWluJyxcbiAgICAgICAgJy0xMSc6ICdQYWNpZmljL1NhbW9hJyxcbiAgICAgICAgJy0xMCc6ICdQYWNpZmljL0hvbm9sdWx1JyxcbiAgICAgICAgJy05JzogJ0FtZXJpY2EvSnVuZWF1JyxcbiAgICAgICAgJy04JzogJ0FtZXJpY2EvTG9zIEFuZ2VsZXMnLFxuICAgICAgICAnLTcnOiAnQW1lcmljYS9EZW52ZXInLFxuICAgICAgICAnLTYnOiAnQW1lcmljYS9NZXhpY28gQ2l0eScsXG4gICAgICAgICctNSc6ICdBbWVyaWNhL05ldyBZb3JrJyxcbiAgICAgICAgJy00JzogJ0FtZXJpY2EvQ2FyYWNhcycsXG4gICAgICAgICctMy41JzogJ0FtZXJpY2EvU3QgSm9obnMnLFxuICAgICAgICAnLTMnOiAnQW1lcmljYS9BcmdlbnRpbmEvQnVlbm9zIEFpcmVzJyxcbiAgICAgICAgJy0yJzogJ0F0bGFudGljL0F6b3JlcycsXG4gICAgICAgICctMSc6ICdBdGxhbnRpYy9Bem9yZXMnLFxuICAgICAgICAnMCc6ICdFdXJvcGUvTG9uZG9uJyxcbiAgICAgICAgJzEnOiAnRXVyb3BlL1BhcmlzJyxcbiAgICAgICAgJzInOiAnRXVyb3BlL0hlbHNpbmtpJyxcbiAgICAgICAgJzMnOiAnRXVyb3BlL01vc2NvdycsXG4gICAgICAgICczLjUnOiAnQXNpYS9UZWhyYW4nLFxuICAgICAgICAnNCc6ICdBc2lhL0Jha3UnLFxuICAgICAgICAnNC41JzogJ0FzaWEvS2FidWwnLFxuICAgICAgICAnNSc6ICdBc2lhL0thcmFjaGknLFxuICAgICAgICAnNS41JzogJ0FzaWEvQ2FsY3V0dGEnLFxuICAgICAgICAnNic6ICdBc2lhL0NvbG9tYm8nLFxuICAgICAgICAnNyc6ICdBc2lhL0Jhbmdrb2snLFxuICAgICAgICAnOCc6ICdBc2lhL1NpbmdhcG9yZScsXG4gICAgICAgICc5JzogJ0FzaWEvVG9reW8nLFxuICAgICAgICAnOS41JzogJ0F1c3RyYWxpYS9EYXJ3aW4nLFxuICAgICAgICAnMTAnOiAnUGFjaWZpYy9HdWFtJyxcbiAgICAgICAgJzExJzogJ0FzaWEvTWFnYWRhbicsXG4gICAgICAgICcxMic6ICdBc2lhL0thbWNoYXRrYSdcbiAgICB9O1xuICAgIC8vIGNyZWF0ZSBhIHRpbWV6b25lIHN0cmluZyBmb3IgZGlzcGxheVxuICAgIHZhciB0eiA9IHRpbWV6b25lc1stb2Zmc2V0IC8gNjBdO1xuICAgIHR6ICs9ICcgKCc7XG4gICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICB0eiArPSAnKyc7XG4gICAgfVxuICAgIHR6ICs9ICgtb2Zmc2V0LzYwKSArICc6MDApJztcbiAgICAkKCcudGltZXpvbmUnKS5odG1sKHR6KTtcblxuICAgIC8vIHNldCBpbnB1dCBwaWNrZXJzIGZvciB0aW1lXG4gICAgJCgnI2V2ZW50LXN0YXJ0LXRpbWUnKS50aW1lcGlja2VyKHtcbiAgICAgIHNlbGVjdE9uQmx1cjogdHJ1ZSxcbiAgICAgIGFwcGVuZFRvOiAnI2Rpdi1ldmVudC1zdGFydC10aW1lJ1xuICAgIH0pO1xuICAgICQoJyNldmVudC1lbmQtdGltZScpLnRpbWVwaWNrZXIoe1xuICAgICAgc2VsZWN0T25CbHVyOiB0cnVlLFxuICAgICAgc2hvd0R1cmF0aW9uOiB0cnVlLFxuICAgICAgZHVyYXRpb25UaW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICgkKCcjZXZlbnQtc3RhcnQtdGltZScpLnZhbCgpKTtcbiAgICAgIH0sXG4gICAgICBhcHBlbmRUbzogJyNkaXYtZXZlbnQtZW5kLXRpbWUnXG4gICAgfSk7XG4gICAgLy8gZ2V0IHRoZSBzdGFydCB0aW1lIGJ5IHJvdW5kaW5nIHRoZSBjdXJyZW50IHRpbWUgdG8gdGhlIG5lYXJlc3QgMzAgbWludXRlc1xuICAgIHZhciBjb2VmZiA9IDEwMDAgKiA2MCAqIDMwO1xuICAgIHZhciBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpOyAgLy9vciB1c2UgYW55IG90aGVyIGRhdGVcbiAgICBzdGFydFRpbWUgPSBuZXcgRGF0ZShNYXRoLmNlaWwoc3RhcnRUaW1lLmdldFRpbWUoKSAvIGNvZWZmKSAqIGNvZWZmKVxuICAgIC8vIHRoZSBpbml0aWFsIGVuZCB0aW1lIHNob3VsZCBiZSAxIGhvdXIgYWZ0ZXIgdGhlIGluaXRpYWwgc3RhcnQgdGltZVxuICAgIHZhciBlbmRUaW1lID0gbmV3IERhdGUoc3RhcnRUaW1lLmdldFRpbWUoKSArIDEwMDAqNjAqNjApO1xuICAgICQoJyNldmVudC1zdGFydC10aW1lJykudGltZXBpY2tlcignc2V0VGltZScsIHN0YXJ0VGltZSk7XG4gICAgJCgnI2V2ZW50LWVuZC10aW1lJykudGltZXBpY2tlcignc2V0VGltZScsIGVuZFRpbWUpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgZGF0ZSBwaWNrZXJzXG4gICAgdmFyIHN0YXJ0RGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgJCgnI2V2ZW50LXN0YXJ0JykuZGF0ZXRpbWVwaWNrZXIoe1xuICAgICAgcGlja0RhdGU6IHRydWUsXG4gICAgICBwaWNrVGltZTogZmFsc2UsXG4gICAgICBzdGFydERhdGU6IHN0YXJ0RGF0ZVxuICAgIH0pO1xuICAgICQoJyNldmVudC1lbmQnKS5kYXRldGltZXBpY2tlcih7XG4gICAgICBwaWNrRGF0ZTogdHJ1ZSxcbiAgICAgIHBpY2tUaW1lOiBmYWxzZSxcbiAgICAgIHN0YXJ0RGF0ZTogc3RhcnREYXRlXG4gICAgfSk7XG4gICAgLy8gU2V0IHRoZSBpbml0aWFsIGRhdGUgdG8gbm93ICh0b2RheSlcbiAgICAkKCcjZXZlbnQtc3RhcnQnKS5kYXRhKFwiRGF0ZVRpbWVQaWNrZXJcIikuc2V0RGF0ZShzdGFydERhdGUpO1xuICAgICQoJyNldmVudC1lbmQnKS5kYXRhKFwiRGF0ZVRpbWVQaWNrZXJcIikuc2V0RGF0ZShzdGFydERhdGUpO1xuXG4gICAgLy8gV2hlbiB0aGUgc3RhcnQgZGF0ZSBjaGFuZ2VzLFxuICAgIC8vIHNldCB0aGUgZW5kIGRhdGUgdG8gYmUgYXQgbGVhc3QgdGhlIHN0YXJ0IGRhdGVcbiAgICAkKCcjZXZlbnQtc3RhcnQnKS5vbihcImNoYW5nZS5kcFwiLGZ1bmN0aW9uIChlKSB7XG4gICAgICAkKCcjZXZlbnQtZW5kJykuZGF0YShcIkRhdGVUaW1lUGlja2VyXCIpLnNldFN0YXJ0RGF0ZShlLmRhdGUpO1xuICAgICAgdmFyIGRpZmYgPSAkKCcjZXZlbnQtZW5kJykuZGF0YShcIkRhdGVUaW1lUGlja2VyXCIpLmdldERhdGUoKS51bml4KCkgLSBlLmRhdGUudW5peCgpO1xuICAgICAgaWYgKGRpZmYgPCAwKSB7XG4gICAgICAgICQoJyNldmVudC1lbmQnKS5kYXRhKFwiRGF0ZVRpbWVQaWNrZXJcIikuc2V0RGF0ZShlLmRhdGUpO1xuICAgICAgfVxuICAgICAgJChlLmN1cnJlbnRUYXJnZXQpLmJsdXIoKTtcbiAgICB9KTtcbiAgICAvLyBXaGVuIHRoZSBlbmQgZGF0ZSBjaGFuZ2VzLFxuICAgIC8vIEVuYWJsZS9kaXNhYmxlIGR1cmF0aW9uIGluIHRoZSB0aW1lcGlja2VyIGJhc2VkIG9uIHdoZXRoZXIgdGhlXG4gICAgLy8gc3RhcnQgYW5kIGVuZCBkYXRlcyBtYXRjaFxuICAgICQoJyNldmVudC1lbmQnKS5vbihcImNoYW5nZS5kcFwiLGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgZGlmZiA9IGUuZGF0ZS51bml4KCkgLSAkKCcjZXZlbnQtc3RhcnQnKS5kYXRhKFwiRGF0ZVRpbWVQaWNrZXJcIikuZ2V0RGF0ZSgpLnVuaXgoKTtcbiAgICAgIGlmIChkaWZmID09PSAwKSB7XG4gICAgICAgICQoJyNldmVudC1lbmQtdGltZScpLnRpbWVwaWNrZXIoJ29wdGlvbicsICdzaG93RHVyYXRpb24nLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICQoJyNldmVudC1lbmQtdGltZScpLnRpbWVwaWNrZXIoJ29wdGlvbicsICdzaG93RHVyYXRpb24nLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICAkKGUuY3VycmVudFRhcmdldCkuYmx1cigpO1xuICAgIH0pO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciB0ZW1wbGF0ZSA9IF8udGVtcGxhdGUoRXZlbnRGb3JtVGVtcGxhdGUpO1xuICAgIHRoaXMuJGVsLmh0bWwodGVtcGxhdGUpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZVRpbWVab25lKCk7XG4gIH0sXG5cbiAgdjogZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gdmFsaWRhdGUoZSk7XG4gIH0sXG5cbiAgcG9zdDogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgLy8gdmFsaWRhdGUgdGhlIGZpZWxkczsgaWYgYW55IGlzIG5vdCB2YWxpZGF0ZWQsIGFib3J0IGZvcm0gc3VibWlzc2lvblxuICAgIHZhciB2YWxpZGF0ZUlkcyA9IFsnI2V2ZW50LXRpdGxlJywgJyNldmVudC1kZXNjcmlwdGlvbicsICcjZXZlbnQtbG9jYXRpb24nXTtcbiAgICB2YXIgYWJvcnQgPSBmYWxzZTtcbiAgICBmb3IgKGkgaW4gdmFsaWRhdGVJZHMpIHtcbiAgICAgIHZhciBpQWJvcnQgPSB2YWxpZGF0ZSh7IGN1cnJlbnRUYXJnZXQ6IHZhbGlkYXRlSWRzW2ldIH0pO1xuICAgICAgYWJvcnQgPSBhYm9ydCB8fCBpQWJvcnQ7XG4gICAgfVxuICAgIGlmIChhYm9ydCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHByb2Nlc3MgdGhlIGZvcm07IGNyZWF0ZSB0aW1lIG9iamVjdHNcbiAgICB2YXIgc3RhcnQgPSAkKCcjZXZlbnQtc3RhcnQnKS5kYXRhKFwiRGF0ZVRpbWVQaWNrZXJcIikuZ2V0RGF0ZSgpLmNsb25lKCkudG9EYXRlKCk7XG4gICAgdmFyIGVuZCA9ICQoJyNldmVudC1zdGFydCcpLmRhdGEoXCJEYXRlVGltZVBpY2tlclwiKS5nZXREYXRlKCkuY2xvbmUoKS50b0RhdGUoKTtcbiAgICBzdGFydCA9ICQoJyNldmVudC1zdGFydC10aW1lJykudGltZXBpY2tlcignZ2V0VGltZScsIHN0YXJ0KTtcbiAgICBlbmQgPSAkKCcjZXZlbnQtZW5kLXRpbWUnKS50aW1lcGlja2VyKCdnZXRUaW1lJywgZW5kKTtcblxuICAgIHZhciBkYXRhID0ge1xuICAgICAgdGl0bGUgICAgICAgOiAkKFwiI2V2ZW50LXRpdGxlXCIpLnZhbCgpLFxuICAgICAgZGVzY3JpcHRpb24gOiAkKFwiI2V2ZW50LWRlc2NyaXB0aW9uXCIpLnZhbCgpLFxuICAgICAgc3RhcnQgICAgICAgOiBzdGFydC50b0lTT1N0cmluZygpLFxuICAgICAgZW5kICAgICAgICAgOiBlbmQudG9JU09TdHJpbmcoKSxcbiAgICAgIGxvY2F0aW9uICAgIDogJChcIiNldmVudC1sb2NhdGlvblwiKS52YWwoKSxcbiAgICAgIHByb2plY3RJZCAgIDogdGhpcy5vcHRpb25zLnByb2plY3RJZFxuICAgIH07XG5cbiAgICB0aGlzLmNvbGxlY3Rpb24udHJpZ2dlcihcImV2ZW50OnNhdmVcIiwgZGF0YSk7XG4gIH0sXG5cbiAgY2xlYW51cDogZnVuY3Rpb24gKCkge1xuICAgIHJlbW92ZVZpZXcodGhpcyk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRGb3JtVmlldztcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8Zm9vdGVyIGNsYXNzPVxcXCJjb250YWluZXJcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTEyXFxcIj5cXG4gICAgICA8YSBocmVmPVxcXCJodHRwczovL2dpdGh1Yi5jb20vMThGL21pZGFzXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtZ2l0aHViXFxcIj48L2k+IHBvd2VyZWQgYnkgbWlkYXM8L2E+XFxuICAgICAgfFxcbiAgICAgIHZlcnNpb24gPCUtIHZlcnNpb24udmVyc2lvbiAlPiAoPGEgaHJlZj1cXFwiaHR0cHM6Ly9naXRodWIuY29tLzE4Ri9taWRhcy9jb21taXQvPCUtIHZlcnNpb24uZ2l0TG9uZyAlPlxcXCI+PCUtIHZlcnNpb24uZ2l0U2hvcnQgJT48L2E+KVxcbiAgICAgIDwlIGlmIChsb2dpbi50ZXJtcy5lbmFibGVkID09PSB0cnVlKSB7ICU+XFxuICAgICAgfFxcbiAgICAgIDxhIGhyZWY9XFxcIjwlPSBsb2dpbi50ZXJtcy5saW5rICU+XFxcIj48JT0gbG9naW4udGVybXMubmFtZSAlPjwvYT5cXG4gICAgICA8JSB9ICU+XFxuICAgICAgfFxcbiAgICAgIExvY2F0aW9ucyBwcm92aWRlZCBieSA8YSBocmVmPVxcXCJodHRwOi8vd3d3Lmdlb25hbWVzLm9yZy9cXFwiPkdlb05hbWVzPC9hPi5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG48L2Zvb3Rlcj5cXG5cIjtcbiIsIlxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vbWl4aW5zL3V0aWxpdGllcycpO1xudmFyIExvZ2luID0gcmVxdWlyZSgnLi4vLi4vLi4vY29uZmlnL2xvZ2luLmpzb24nKTtcbnZhciBGb290ZXJUZW1wbGF0ZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy9mb290ZXJfdGVtcGxhdGUuaHRtbCcpO1xuXG5cbnZhciBGb290ZXJWaWV3ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuXG4gIGV2ZW50czoge1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIHZlcnNpb246IHZlcnNpb24sXG4gICAgICBsb2dpbjogTG9naW5cbiAgICB9O1xuICAgIHZhciBjb21waWxlZFRlbXBsYXRlID0gXy50ZW1wbGF0ZShGb290ZXJUZW1wbGF0ZSkoZGF0YSk7XG4gICAgdGhpcy4kZWwuaHRtbChjb21waWxlZFRlbXBsYXRlKTtcblxuICAgIGZ1bmN0aW9uIHJlc2l6ZUVsZW1lbnRzKCkge1xuICAgICAgaGVhZGVySGVpZ2h0ID0gJCgnLm5hdmJhcicpLmhlaWdodCgpO1xuICAgICAgZm9vdGVySGVpZ2h0ID0gJCgnZm9vdGVyJykuaGVpZ2h0KCk7XG4gICAgICBpZiAoKCQoZG9jdW1lbnQuYm9keSkuaGVpZ2h0KCkgKyBmb290ZXJIZWlnaHQpIDwgJCh3aW5kb3cpLmhlaWdodCgpKSB7XG4gICAgICAgIHNlbGYuJGVsLmFkZENsYXNzKCduYXZiYXItZml4ZWQtYm90dG9tJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLiRlbC5yZW1vdmVDbGFzcygnbmF2YmFyLWZpeGVkLWJvdHRvbScpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXNpemVFbGVtZW50cygpO1xuICAgICQoXCIuY29udGFpbmVyXCIpLmJpbmQoXCJET01TdWJ0cmVlTW9kaWZpZWRcIiwgcmVzaXplRWxlbWVudHMpO1xuICB9LFxuXG4gIGNsZWFudXA6IGZ1bmN0aW9uICgpIHtcbiAgICByZW1vdmVWaWV3KHRoaXMpO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZvb3RlclZpZXc7XG5cbiIsIlxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgYXN5bmMgPSByZXF1aXJlKCdhc3luYycpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uL21peGlucy91dGlsaXRpZXMnKTtcbnZhciBCYXNlQ29udHJvbGxlciA9IHJlcXVpcmUoJy4uLy4uLy4uL2Jhc2UvYmFzZV9jb250cm9sbGVyJyk7XG52YXIgSG9tZVZpZXcgPSByZXF1aXJlKCcuLi92aWV3cy9ob21lX3ZpZXcnKTtcblxuXG5Ib21lID0ge307XG5cbkhvbWUuQ29udHJvbGxlciA9IEJhc2VDb250cm9sbGVyLmV4dGVuZCh7XG5cbiAgZXZlbnRzOiB7XG4gIH0sXG5cbiAgLy8gVGhlIGluaXRpYWxpemUgbWV0aG9kIGlzIG1haW5seSB1c2VkIGZvciBldmVudCBiaW5kaW5ncyAoZm9yIGVmZmljaWVuY3kpXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuaG9tZVZpZXcgPSBuZXcgSG9tZVZpZXcoKS5yZW5kZXIoKTtcbiAgfSxcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy89IFV0aWxpdHkgTWV0aG9kc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgY2xlYW51cDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuaG9tZVZpZXcpIHRoaXMuaG9tZVZpZXcuY2xlYW51cCgpO1xuICAgIHJlbW92ZVZpZXcodGhpcyk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gSG9tZS5Db250cm9sbGVyO1xuXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiICA8ZGl2IGNsYXNzPVxcXCJjb250YWluZXItZmx1aWQgcGFkZGluZy1sZWZ0LW5vbmUgcGFkZGluZy1yaWdodC1ub25lXFxcIiBpZD1cXFwiaG9tZVxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcInNwbGFzaC13cmFwXFxcIiBpZD1cXFwic3BsYXNoMVxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwic3BsYXNoLWNlbnRlclxcXCI+XFxuICAgICAgPGgxIGNsYXNzPVxcXCJ0ZXh0LWNlbnRlclxcXCIgZGF0YS1pMThuPVxcXCJob21lLmhlYWRsaW5lXFxcIj5IYXNzbGUgRnJlZSBDb2xsYWJvcmF0aW9uPC9oMT5cXG4gICAgICA8cCBjbGFzcz1cXFwibGVhZCB0ZXh0LWNlbnRlclxcXCIgZGF0YS1pMThuPVxcXCJob21lLnN1YmhlYWRcXFwiPldvcmsgd2l0aCBvdGhlciBmZWRlcmFsIGVtcGxveWVlcyBvbiBwcm9qZWN0cyB5b3UgYXJlIHBhc3Npb25hdGUgYWJvdXQuPC9wPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInRleHQtY2VudGVyXFxcIj48YSBjbGFzcz1cXFwibG9naW5cXFwiIGhyZWY9XFxcIi9hdXRoXFxcIj48YnV0dG9uIGNsYXNzPVxcXCJidG4gYnRuLW1pZGFzXFxcIiBpZD1cXFwiY2VudGVyXFxcIiBkYXRhLWkxOG49XFxcImhvbWUuY2FsbFRvQWN0aW9uXFxcIj5HZXQgU3RhcnRlZCBUb2RheTwvYnV0dG9uPjwvYT48L2Rpdj5cXG4gICAgICA8IS0tZGl2IGNsYXNzPVxcXCJ0ZXh0LWNlbnRlciB0ZXh0LW9uLWRhcmsgdGV4dC1tdXRlZFxcXCI+PGEgaHJlZj1cXFwiI1xcXCI+TGVhcm4gTW9yZTwvYT48L2Rpdi0tPlxcbiAgICA8L2Rpdj48IS0tIC8jc3BsYXNoIC0tPlxcbiAgICA8L2Rpdj48IS0tIC8uc3BsYXNoLXdyYXAgLS0+XFxuXFxuICA8ZGl2IGNsYXNzPVxcXCJpbmxpbmUtYmxvY2stY2VudGVyXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwidmFsdWUtcHJvcFxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpY29uXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtY29tbWVudHNcXFwiPjwvaT48L2Rpdj4gPCEtLSBpY29uIC0tPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidGV4dFxcXCI+TWFrZSBDb25uZWN0aW9uczwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwidmFsdWUtcHJvcFxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpY29uXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtY29nc1xcXCI+PC9pPjwvZGl2PiA8IS0tIGljb24gLS0+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0ZXh0XFxcIj5CdWlsZCBTa2lsbHM8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcInZhbHVlLXByb3BcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiaWNvblxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLWxpbmUtY2hhcnRcXFwiPjwvaT48L2Rpdj4gPCEtLSBpY29uIC0tPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidGV4dFxcXCI+TWFrZSBhIERpZmZlcmVuY2U8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcInRleHQtY2VudGVyXFxcIj48YSBjbGFzcz1cXFwibG9naW5cXFwiIGhyZWY9XFxcIi9hdXRoXFxcIj48YnV0dG9uIGNsYXNzPVxcXCJidG4gYnRuLW1pZGFzXFxcIiBpZD1cXFwiY2VudGVyXFxcIiBkYXRhLWkxOG49XFxcImhvbWUuY2FsbFRvQWN0aW9uXFxcIj5HZXQgU3RhcnRlZCBUb2RheTwvYnV0dG9uPjwvYT48L2Rpdj5cXG5cXG5cXG4gIDwvZGl2PjwhLS0gLy5jb250YWluZXItZmx1aWQtLT5cXG5cIjtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciBhc3luYyA9IHJlcXVpcmUoJ2FzeW5jJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgVUlDb25maWcgPSByZXF1aXJlKCcuLi8uLi8uLi9jb25maWcvdWkuanNvbicpO1xudmFyIExvZ2luID0gcmVxdWlyZSgnLi4vLi4vLi4vY29uZmlnL2xvZ2luLmpzb24nKTtcbnZhciBMb2dpbkNvbnRyb2xsZXIgPSByZXF1aXJlKCcuLi8uLi9sb2dpbi9jb250cm9sbGVycy9sb2dpbl9jb250cm9sbGVyJyk7XG52YXIgSG9tZVRlbXBsYXRlID0gcmVxdWlyZSgnLi4vdGVtcGxhdGVzL2hvbWVfdmlld190ZW1wbGF0ZS5odG1sJyk7XG5cblxudmFyIEhvbWVWaWV3ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuXG4gIGVsOiBcIiNjb250YWluZXJcIixcblxuICBldmVudHM6IHtcbiAgICAnY2xpY2sgLmxvZ2luJyAgICAgICAgICA6ICdsb2dpbkNsaWNrJ1xuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmxpc3RlblRvKHdpbmRvdy5jYWNoZS51c2VyRXZlbnRzLCBcInVzZXI6bG9naW46c3VjY2Vzc1wiLCBmdW5jdGlvbiAodXNlcikge1xuICAgICAgQmFja2JvbmUuaGlzdG9yeS5uYXZpZ2F0ZShVSUNvbmZpZy5ob21lLmxvZ2dlZF9pbl9wYXRoLCB7IHRyaWdnZXI6IHRydWUgfSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbXBpbGVkVGVtcGxhdGU7XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBob3N0bmFtZTogd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lLFxuICAgICAgdXNlcjogd2luZG93LmNhY2hlLmN1cnJlbnRVc2VyIHx8IHt9LFxuICAgIH07XG5cbiAgICB0aGlzLiRlbC5hZGRDbGFzcygnaG9tZScpO1xuICAgIGNvbXBpbGVkVGVtcGxhdGUgPSBfLnRlbXBsYXRlKEhvbWVUZW1wbGF0ZSkoZGF0YSk7XG4gICAgdGhpcy4kZWwuaHRtbChjb21waWxlZFRlbXBsYXRlKTtcbiAgICB0aGlzLiRlbC5pMThuKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBsb2dpbkNsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlcikge1xuICAgICAgLy8gd2UncmUgYWxyZWFkeSBsb2dnZWQgaW5cbiAgICAgIEJhY2tib25lLmhpc3RvcnkubmF2aWdhdGUoVUlDb25maWcuaG9tZS5sb2dnZWRfaW5fcGF0aCwgeyB0cmlnZ2VyOiB0cnVlIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZ2luKCk7XG4gICAgfVxuICB9LFxuXG4gIGxvZ2luOiBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgIGlmICh0aGlzLmxvZ2luQ29udHJvbGxlcikge1xuICAgICAgdGhpcy5sb2dpbkNvbnRyb2xsZXIuY2xlYW51cCgpO1xuICAgIH1cbiAgICB0aGlzLmxvZ2luQ29udHJvbGxlciA9IG5ldyBMb2dpbkNvbnRyb2xsZXIoe1xuICAgICAgZWw6ICcjbG9naW4td3JhcHBlcicsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlXG4gICAgfSk7XG4gIH0sXG5cbiAgY2xlYW51cDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuJGVsLnJlbW92ZUNsYXNzKCdob21lJyk7XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfSxcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhvbWVWaWV3O1xuIiwiXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgQm9vdHN0cmFwID0gcmVxdWlyZSgnYm9vdHN0cmFwJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgQmFzZUNvbnRyb2xsZXIgPSByZXF1aXJlKCcuLi8uLi8uLi9iYXNlL2Jhc2VfY29udHJvbGxlcicpO1xudmFyIExvZ2luVmlldyA9IHJlcXVpcmUoJy4uL3ZpZXdzL2xvZ2luX3ZpZXcnKTtcbnZhciBsb2dpbiA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbmZpZy9sb2dpbi5qc29uJyk7XG52YXIgTW9kYWxDb21wb25lbnQgPSByZXF1aXJlKCcuLi8uLi8uLi9jb21wb25lbnRzL21vZGFsJyk7XG5cblxuTG9naW4gPSBCYXNlQ29udHJvbGxlci5leHRlbmQoe1xuXG4gIGV2ZW50czoge1xuICAgIFwiY2xpY2sgI3JlZ2lzdGVyLWNhbmNlbFwiICAgOiBcInNob3dMb2dpblwiLFxuICAgIFwiY2xpY2sgI2xvZ2luLXJlZ2lzdGVyXCIgICAgOiBcInNob3dSZWdpc3RlclwiLFxuICAgIFwiY2xpY2sgI2ZvcmdvdC1kb25lLWNhbmNlbFwiOiBcInNob3dMb2dpblwiLFxuICAgIFwiY2xpY2sgI2ZvcmdvdC1jYW5jZWxcIiAgICAgOiBcInNob3dMb2dpblwiLFxuICAgIFwiY2xpY2sgI2ZvcmdvdC1wYXNzd29yZFwiICAgOiBcInNob3dGb3Jnb3RcIlxuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICggb3B0aW9ucyApIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmluaXRpYWxpemVWaWV3KCk7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZVZpZXc6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHRoaXMubG9naW5WaWV3KSB7XG4gICAgICB0aGlzLmxvZ2luVmlldy5jbGVhbnVwKCk7XG4gICAgICB0aGlzLm1vZGFsQ29tcG9uZW50LmNsZWFudXAoKTtcbiAgICB9XG5cbiAgICAvLyBpbml0aWFsaXplIHRoZSBtb2RhbFxuICAgIGlmICghXy5pc1VuZGVmaW5lZCh0aGlzLm9wdGlvbnMubWVzc2FnZSkpIHtcbiAgICAgIHZhciBkaXNhYmxlQ2xvc2UgPSB0aGlzLm9wdGlvbnMubWVzc2FnZS5kaXNhYmxlQ2xvc2UgfHwgZmFsc2U7XG4gICAgfVxuICAgIHRoaXMubW9kYWxDb21wb25lbnQgPSBuZXcgTW9kYWxDb21wb25lbnQoe1xuICAgICAgZWw6IHRoaXMuZWwsXG4gICAgICBpZDogXCJsb2dpblwiLFxuICAgICAgbW9kYWxUaXRsZTogXCJMb2dpbiBvciBSZWdpc3RlclwiLFxuICAgICAgZGlzYWJsZUNsb3NlOiBkaXNhYmxlQ2xvc2VcbiAgICB9KS5yZW5kZXIoKTtcblxuICAgIC8vIHB1dCB0aGUgbG9naW4gdmlldyBpbnNpZGUgdGhlIG1vZGFsXG4gICAgdGhpcy5sb2dpblZpZXcgPSBuZXcgTG9naW5WaWV3KHtcbiAgICAgIGVsOiBcIi5tb2RhbC10ZW1wbGF0ZVwiLFxuICAgICAgbG9naW46IGxvZ2luLFxuICAgICAgbWVzc2FnZTogdGhpcy5vcHRpb25zLm1lc3NhZ2VcbiAgICB9KS5yZW5kZXIoKTtcbiAgICB0aGlzLiQoXCIjcmVnaXN0cmF0aW9uLXZpZXdcIikuaGlkZSgpO1xuICAgIHRoaXMuJChcIiNmb3Jnb3Qtdmlld1wiKS5oaWRlKCk7XG4gICAgdGhpcy4kKFwiI2ZvcmdvdC1kb25lLXZpZXdcIikuaGlkZSgpO1xuICAgICQoXCIjbG9naW5cIikubW9kYWwoJ3Nob3cnKTtcblxuICAgIHNlbGYubGlzdGVuVG8od2luZG93LmNhY2hlLnVzZXJFdmVudHMsIFwidXNlcjpsb2dpblwiLCBmdW5jdGlvbiAodXNlcikge1xuICAgICAgLy8gaGlkZSB0aGUgbW9kYWxcbiAgICAgIHNlbGYuc3RvcExpc3RlbmluZyh3aW5kb3cuY2FjaGUudXNlckV2ZW50cyk7XG4gICAgICAvLyB3aW5kb3cuY2FjaGUudXNlckV2ZW50cy5zdG9wTGlzdGVuaW5nKCk7XG4gICAgICAkKCcjbG9naW4nKS5iaW5kKCdoaWRkZW4uYnMubW9kYWwnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gcmVsb2FkIHRoZSBwYWdlIGFmdGVyIGxvZ2luXG4gICAgICAgIEJhY2tib25lLmhpc3RvcnkubG9hZFVybCgpO1xuICAgICAgICB3aW5kb3cuY2FjaGUudXNlckV2ZW50cy50cmlnZ2VyKFwidXNlcjpsb2dpbjpzdWNjZXNzXCIsIHVzZXIpO1xuICAgICAgICBzZWxmLmNsZWFudXAoKTtcbiAgICAgIH0pLm1vZGFsKCdoaWRlJyk7XG4gICAgfSk7XG4gIH0sXG5cbiAgc2hvd1JlZ2lzdGVyOiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy4kKFwiI2xvZ2luLXZpZXdcIikuaGlkZSgpO1xuICAgIHRoaXMuJChcIiNsb2dpbi1mb290ZXJcIikuaGlkZSgpO1xuICAgIHRoaXMuJChcIiNyZWdpc3RyYXRpb24tdmlld1wiKS5zaG93KCk7XG4gICAgdGhpcy4kKFwiI3JlZ2lzdHJhdGlvbi1mb290ZXJcIikuc2hvdygpO1xuICAgIHRoaXMuJChcIiNmb3Jnb3Qtdmlld1wiKS5oaWRlKCk7XG4gICAgdGhpcy4kKFwiI2ZvcmdvdC1mb290ZXJcIikuaGlkZSgpO1xuICAgIHRoaXMuJChcIiNmb3Jnb3QtZG9uZS12aWV3XCIpLmhpZGUoKTtcbiAgICB0aGlzLiQoXCIjZm9yZ290LWRvbmUtZm9vdGVyXCIpLmhpZGUoKTtcbiAgfSxcblxuICBzaG93TG9naW46IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLiQoXCIjbG9naW4tdmlld1wiKS5zaG93KCk7XG4gICAgdGhpcy4kKFwiI2xvZ2luLWZvb3RlclwiKS5zaG93KCk7XG4gICAgdGhpcy4kKFwiI3JlZ2lzdHJhdGlvbi12aWV3XCIpLmhpZGUoKTtcbiAgICB0aGlzLiQoXCIjcmVnaXN0cmF0aW9uLWZvb3RlclwiKS5oaWRlKCk7XG4gICAgdGhpcy4kKFwiI2ZvcmdvdC12aWV3XCIpLmhpZGUoKTtcbiAgICB0aGlzLiQoXCIjZm9yZ290LWZvb3RlclwiKS5oaWRlKCk7XG4gICAgdGhpcy4kKFwiI2ZvcmdvdC1kb25lLXZpZXdcIikuaGlkZSgpO1xuICAgIHRoaXMuJChcIiNmb3Jnb3QtZG9uZS1mb290ZXJcIikuaGlkZSgpO1xuICB9LFxuXG4gIHNob3dGb3Jnb3Q6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLiQoXCIjZm9yZ290LXZpZXdcIikuc2hvdygpO1xuICAgIHRoaXMuJChcIiNmb3Jnb3QtZm9vdGVyXCIpLnNob3coKTtcbiAgICB0aGlzLiQoXCIjcmVnaXN0cmF0aW9uLXZpZXdcIikuaGlkZSgpO1xuICAgIHRoaXMuJChcIiNyZWdpc3RyYXRpb24tZm9vdGVyXCIpLmhpZGUoKTtcbiAgICB0aGlzLiQoXCIjbG9naW4tdmlld1wiKS5oaWRlKCk7XG4gICAgdGhpcy4kKFwiI2xvZ2luLWZvb3RlclwiKS5oaWRlKCk7XG4gICAgdGhpcy4kKFwiI2ZvcmdvdC1kb25lLXZpZXdcIikuaGlkZSgpO1xuICAgIHRoaXMuJChcIiNmb3Jnb3QtZG9uZS1mb290ZXJcIikuaGlkZSgpO1xuICB9LFxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLz0gVVRJTElUWSBNRVRIT0RTXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBjbGVhbnVwOiBmdW5jdGlvbigpIHtcbiAgICAvLyBkb24ndCBkbyBhbnl0aGluZ1xuICAgIGlmICh0aGlzLmxvZ2luVmlldykgeyB0aGlzLmxvZ2luVmlldy5jbGVhbnVwKCk7IH1cbiAgICBpZiAodGhpcy5tb2RhbENvbXBvbmVudCkgeyB0aGlzLm1vZGFsQ29tcG9uZW50LmNsZWFudXAoKTsgfVxuICAgIHJlbW92ZVZpZXcodGhpcyk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTG9naW47XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcImNvbC1zbS05IHNtLW5vcGFkZGluZ1xcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICAgIDxsYWJlbCBmb3I9XFxcInJwYXNzd29yZFxcXCIgY2xhc3M9XFxcImNvbnRyb2wtbGFiZWxcXFwiPlBhc3N3b3JkPC9sYWJlbD5cXG4gICAgICA8aW5wdXQgdHlwZT1cXFwicGFzc3dvcmRcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2wgdmFsaWRhdGVcXFwiIGlkPVxcXCJycGFzc3dvcmRcXFwiIG5hbWU9XFxcInBhc3N3b3JkXFxcIiBwbGFjZWhvbGRlcj1cXFwiUGFzc3dvcmRcXFwiIGRhdGEtdmFsaWRhdGU9XFxcImVtcHR5LHBhc3N3b3JkLGNvbmZpcm1cXFwiLz5cXG4gICAgICA8c3BhbiBjbGFzcz1cXFwiaGVscC1ibG9jayBlcnJvci1lbXB0eVxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPllvdSBtdXN0IGVudGVyIGEgcGFzc3dvcmQuPC9zcGFuPlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJoZWxwLWJsb2NrIGVycm9yLXBhc3N3b3JkXFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI+WW91ciBwYXNzd29yZCBkb2VzIG5vdCBtZWV0IHBhc3N3b3JkIHJ1bGVzLjwvc3Bhbj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICAgIDxsYWJlbCBmb3I9XFxcInJwYXNzd29yZC1jb25maXJtXFxcIiBjbGFzcz1cXFwiY29udHJvbC1sYWJlbFxcXCI+Q29uZmlybSBQYXNzd29yZDwvbGFiZWw+XFxuICAgICAgPGlucHV0IHR5cGU9XFxcInBhc3N3b3JkXFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiBpZD1cXFwicnBhc3N3b3JkLWNvbmZpcm1cXFwiIHBsYWNlaG9sZGVyPVxcXCJDb25maXJtIFBhc3N3b3JkXFxcIi8+XFxuICAgICAgPHNwYW4gY2xhc3M9XFxcImhlbHAtYmxvY2sgZXJyb3ItY29uZmlybVxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPllvdXIgcGFzc3dvcmQgZG9lcyBub3QgbWF0Y2ggdGhlIHBhc3N3b3JkIGVudGVyZWQgYWJvdmUuPC9zcGFuPlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwiY29sLXNtLTMgbm9wYWRkaW5nXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwicGFzc3dvcmQtcnVsZXMtdGl0bGVcXFwiPlxcbiAgICAgIE11c3QgQ29udGFpbjpcXG4gICAgPC9kaXY+XFxuICAgIDx1bCBjbGFzcz1cXFwicGFzc3dvcmQtcnVsZXNcXFwiPlxcbiAgICAgIDxsaSBjbGFzcz1cXFwic3VjY2VzcyBydWxlLXVzZXJuYW1lXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtY2hlY2tcXFwiPjwvaT4gTm90IHlvdXIgZW1haWw8L2xpPlxcbiAgICAgIDxsaSBjbGFzcz1cXFwiZXJyb3IgcnVsZS11c2VybmFtZVxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXJlbW92ZVxcXCI+PC9pPiBOb3QgeW91ciBlbWFpbDwvbGk+XFxuICAgICAgPGxpIGNsYXNzPVxcXCJzdWNjZXNzIHJ1bGUtbGVuZ3RoXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtY2hlY2tcXFwiPjwvaT4gOCBjaGFyYWN0ZXJzIG9yIG1vcmU8L2xpPlxcbiAgICAgIDxsaSBjbGFzcz1cXFwiZXJyb3IgcnVsZS1sZW5ndGhcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1yZW1vdmVcXFwiPjwvaT4gOCBjaGFyYWN0ZXJzIG9yIG1vcmU8L2xpPlxcbiAgICAgIDxsaSBjbGFzcz1cXFwic3VjY2VzcyBydWxlLXVwcGVyXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtY2hlY2tcXFwiPjwvaT4gVXBwZXJjYXNlPC9saT5cXG4gICAgICA8bGkgY2xhc3M9XFxcImVycm9yIHJ1bGUtdXBwZXJcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1yZW1vdmVcXFwiPjwvaT4gVXBwZXJjYXNlPC9saT5cXG4gICAgICA8bGkgY2xhc3M9XFxcInN1Y2Nlc3MgcnVsZS1sb3dlclxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLWNoZWNrXFxcIj48L2k+IExvd2VyY2FzZTwvbGk+XFxuICAgICAgPGxpIGNsYXNzPVxcXCJlcnJvciBydWxlLWxvd2VyXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtcmVtb3ZlXFxcIj48L2k+IExvd2VyY2FzZTwvbGk+XFxuICAgICAgPGxpIGNsYXNzPVxcXCJzdWNjZXNzIHJ1bGUtbnVtYmVyXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtY2hlY2tcXFwiPjwvaT4gQSBOdW1iZXI8L2xpPlxcbiAgICAgIDxsaSBjbGFzcz1cXFwiZXJyb3IgcnVsZS1udW1iZXJcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1yZW1vdmVcXFwiPjwvaT4gQSBOdW1iZXI8L2xpPlxcbiAgICAgIDxsaSBjbGFzcz1cXFwic3VjY2VzcyBydWxlLXN5bWJvbFxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLWNoZWNrXFxcIj48L2k+IEEgU3ltYm9sPC9saT5cXG4gICAgICA8bGkgY2xhc3M9XFxcImVycm9yIHJ1bGUtc3ltYm9sXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtcmVtb3ZlXFxcIj48L2k+IEEgU3ltYm9sPC9saT5cXG4gICAgPC91bD5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxmb3JtIHJvbGU9XFxcImZvcm1cXFwiIGlkPVxcXCJsb2dpbi1wYXNzd29yZC1mb3JtXFxcIj5cXG48ZGl2IGNsYXNzPVxcXCJtb2RhbC1ib2R5IHBhZGRpbmctYm90dG9tLW5vbmVcXFwiIGlkPVxcXCJsb2dpbi12aWV3XFxcIj5cXG5cXG4gIDwlIGlmIChtZXNzYWdlICYmICFfLmlzVW5kZWZpbmVkKG1lc3NhZ2UubWVzc2FnZSkpIHsgJT5cXG4gIDxkaXYgY2xhc3M9XFxcImFsZXJ0IGFsZXJ0LXdhcm5pbmdcXFwiPlxcbiAgICA8JT0gbWVzc2FnZS5tZXNzYWdlICU+XFxuICA8L2Rpdj5cXG4gIDwlIH0gJT5cXG5cXG4gIDwlIGlmIChsb2dpbi5vYXV0aC5sZW5ndGggPiAwKSB7ICU+XFxuICA8ZGl2IGNsYXNzPVxcXCJsb2dpbi1vYXV0aFxcXCI+TG9naW4gd2l0aFxcbiAgPCUgXy5lYWNoKGxvZ2luLm9hdXRoLCBmdW5jdGlvbiAoZSkgeyAlPlxcbiAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY29sLXNtLW9mZnNldC0zIGNvbC1zbS02XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJsb2dpbi1vcHRpb25cXFwiPlxcbiAgICAgICAgPGEgaHJlZj1cXFwiPCU9IGxvZ2luLmNvbmZpZ1tlXS5lbmRwb2ludCAlPlxcXCIgY2xhc3M9XFxcImJ0biBidG4tYzAgYnRuLWxvZ2luXFxcIj5cXG4gICAgICAgICAgPGltZyBzcmM9XFxcIjwlPSBsb2dpbi5jb25maWdbZV0uaW1hZ2UgJT5cXFwiIGFsdD1cXFwiPCU9IGxvZ2luLmNvbmZpZ1tlXS5uYW1lICU+XFxcIiBjbGFzcz1cXFwiYnRuLWxvZ2luLXJlc3BvbnNpdmVcXFwiLz5cXG4gICAgICAgIDwvYT5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG4gIDwlIH0pOyAlPlxcbiAgPC9kaXY+XFxuICA8JSB9ICU+XFxuXFxuICA8JSBpZiAobG9naW4ubG9jYWwuZW5hYmxlZCA9PT0gdHJ1ZSkgeyAlPlxcbiAgICA8JSBpZiAobG9naW4ub2F1dGgubGVuZ3RoID4gMCkgeyAlPlxcbiAgICA8aHIvPlxcbiAgICA8JSB9ICU+XFxuICAgIDxkaXYgY2xhc3M9XFxcImFsZXJ0IGFsZXJ0LWRhbmdlclxcXCIgaWQ9XFxcImxvZ2luLWVycm9yXFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI+PC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJ1c2VybmFtZVxcXCIgY2xhc3M9XFxcImNvbnRyb2wtbGFiZWxcXFwiIGRhdGEtaTE4bj1cXFwibG9naW5Nb2RhbC5lbWFpbEFkZHJlc3NcXFwiPkVtYWlsIEFkZHJlc3M8L2xhYmVsPlxcbiAgICAgICAgPGlucHV0IHR5cGU9XFxcImVtYWlsXFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiBpZD1cXFwidXNlcm5hbWVcXFwiIG5hbWU9XFxcInVzZXJuYW1lXFxcIiBwbGFjZWhvbGRlcj1cXFwiRW1haWwgQWRkcmVzc1xcXCIvPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXAgbWFyZ2luLWJvdHRvbS1ub25lXFxcIj5cXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcInBhc3N3b3JkXFxcIiBjbGFzcz1cXFwiY29udHJvbC1sYWJlbFxcXCI+UGFzc3dvcmQ8L2xhYmVsPlxcbiAgICAgICAgPGlucHV0IHR5cGU9XFxcInBhc3N3b3JkXFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiBpZD1cXFwicGFzc3dvcmRcXFwiIG5hbWU9XFxcInBhc3N3b3JkXFxcIiBwbGFjZWhvbGRlcj1cXFwiUGFzc3dvcmRcXFwiLz5cXG4gICAgICAgIDxhIGhyZWY9XFxcIiNmb3Jnb3QtcGFzc3dvcmRcXFwiIGNsYXNzPVxcXCJmb3Jnb3QtcGFzc3dvcmRcXFwiIGlkPVxcXCJmb3Jnb3QtcGFzc3dvcmRcXFwiPkZvcmdvdCB5b3VyIHBhc3N3b3JkPzwvYT5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWZvb3RlciBtb2RhbC1mb290ZXItZ3JleVxcXCIgaWQ9XFxcImxvZ2luLWZvb3RlclxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0xMlxcXCI+XFxuICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwic3VibWl0XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1jMiBwdWxsLXJpZ2h0XFxcIj5TaWduIGluPC9idXR0b24+XFxuICAgICAgICAgIDxwIGNsYXNzPVxcXCJwdWxsLWxlZnQgbG9naW4tcmVnaXN0ZXItbGFiZWxcXFwiIGlkPVxcXCJsb2dpbi1yZWdpc3Rlci1sYWJlbFxcXCI+XFxuICAgICAgICAgICAgTmVlZCBhbiBhY2NvdW50PyBcXG4gICAgICAgICAgICA8YSBocmVmPVxcXCIjbG9naW4tcmVnaXN0ZXJcXFwiIGlkPVxcXCJsb2dpbi1yZWdpc3RlclxcXCI+XFxuICAgICAgICAgICAgICA8c3Ryb25nPlNpZ24gdXAgbm93PC9zdHJvbmc+XFxuICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICA8L3A+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICA8JSB9IGVsc2UgeyAlPlxcbiAgPC9kaXY+XFxuICA8JSB9ICU+XFxuPC9mb3JtPlxcblxcbjxmb3JtIHJvbGU9XFxcImZvcm1cXFwiIGlkPVxcXCJyZWdpc3RyYXRpb24tZm9ybVxcXCI+XFxuPGRpdiBjbGFzcz1cXFwibW9kYWwtYm9keSBwYWRkaW5nLWJvdHRvbS1ub25lXFxcIiBpZD1cXFwicmVnaXN0cmF0aW9uLXZpZXdcXFwiPlxcbiAgICA8aDI+Q3JlYXRlIGEgTmV3IEFjY291bnQ8L2gyPlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1zbS0xMlxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgICAgPGxhYmVsIGZvcj1cXFwicm5hbWVcXFwiIGNsYXNzPVxcXCJjb250cm9sLWxhYmVsXFxcIiBkYXRhLWkxOG49XFxcImxvZ2luTW9kYWwubmFtZVxcXCI+TmFtZTwvbGFiZWw+XFxuICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sIHZhbGlkYXRlXFxcIiBpZD1cXFwicm5hbWVcXFwiIG5hbWU9XFxcInJuYW1lXFxcIiBwbGFjZWhvbGRlcj1cXFwiRnVsbCBOYW1lXFxcIiBkYXRhLXZhbGlkYXRlPVxcXCJlbXB0eVxcXCI+XFxuICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJoZWxwLWJsb2NrIGVycm9yLWVtcHR5XFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI+UGxlYXNlIGVudGVyIHlvdXIgZnVsbCBuYW1lLjwvc3Bhbj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1zbS0xMlxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgICAgPGxhYmVsIGZvcj1cXFwicnVzZXJuYW1lXFxcIiBjbGFzcz1cXFwiY29udHJvbC1sYWJlbFxcXCIgZGF0YS1pMThuPVxcXCJsb2dpbk1vZGFsLmVtYWlsQWRkcmVzc1xcXCI+RW1haWwgQWRkcmVzczwvbGFiZWw+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImlucHV0LWdyb3VwXFxcIj5cXG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbCB2YWxpZGF0ZVxcXCIgaWQ9XFxcInJ1c2VybmFtZVxcXCIgbmFtZT1cXFwidXNlcm5hbWVcXFwiIHBsYWNlaG9sZGVyPVxcXCJFbWFpbCBBZGRyZXNzXFxcIiBkYXRhLXZhbGlkYXRlPVxcXCJidXR0b25cXFwiLz5cXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXAtYnRuXFxcIj5cXG4gICAgICAgICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRhbmdlclxcXCIgaWQ9XFxcInJ1c2VybmFtZS1idXR0b25cXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+XFxuICAgICAgICAgICAgICAgIDxpIGlkPVxcXCJydXNlcm5hbWUtY2hlY2tcXFwiIGNsYXNzPVxcXCJmYSBmYS10aW1lc1xcXCI+PC9pPlxcbiAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJoZWxwLWJsb2NrIGVycm9yLWJ1dHRvblxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPlRoZSBlbWFpbCBhZGRyZXNzIGlzIG5vdCB2YWxpZCBvciBpcyBhbHJlYWR5IGluIHVzZS48L3NwYW4+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInBhc3N3b3JkLXZpZXdcXFwiPlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY2hlY2tib3hcXFwiPlxcbiAgICAgIDxsYWJlbD5cXG4gICAgICAgIDwlIGlmIChsb2dpbi50ZXJtcy5lbmFibGVkID09PSB0cnVlKSB7ICU+XFxuICAgICAgICA8aW5wdXQgdHlwZT1cXFwiY2hlY2tib3hcXFwiIGlkPVxcXCJydGVybXNcXFwiIGNsYXNzPVxcXCJ2YWxpZGF0ZVxcXCIgZGF0YS12YWxpZGF0ZT1cXFwiY2hlY2tlZFxcXCI+IDxzcGFuIGRhdGEtaTE4bj1cXFwibG9naW5Nb2RhbC50b3NDaGVja2JveFxcXCI+WWVzLCBJIGFncmVlIHRvIHRoZSA8L3NwYW4+PGEgaHJlZj1cXFwiPCU9IGxvZ2luLnRlcm1zLmxpbmsgJT5cXFwiPjwlPSBsb2dpbi50ZXJtcy5uYW1lICU+PC9hPi5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJoZWxwLWJsb2NrIGVycm9yLWNoZWNrZWRcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIj5Zb3UgbXVzdCBhY2NlcHQgdGhlIDwlPSBsb2dpbi50ZXJtcy5uYW1lICU+IHRvIHJlZ2lzdGVyLjwvc3Bhbj5cXG4gICAgICAgIDwlIH0gJT5cXG4gICAgICA8L2xhYmVsPlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cCBtYXJnaW4tYm90dG9tLW5vbmVcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtc20tMTJcXFwiPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJhbGVydCBhbGVydC1kYW5nZXJcXFwiIGlkPVxcXCJyZWdpc3RyYXRpb24tZXJyb3JcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIj48L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJtb2RhbC1mb290ZXIgbW9kYWwtZm9vdGVyLWdyZXlcXFwiIGlkPVxcXCJyZWdpc3RyYXRpb24tZm9vdGVyXFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtc20tMTJcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInB1bGwtcmlnaHRcXFwiPlxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGlkPVxcXCJyZWdpc3Rlci1jYW5jZWxcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWMwXFxcIj5DYW5jZWw8L2J1dHRvbj5cXG4gICAgICAgIDxidXR0b24gdHlwZT1cXFwic3VibWl0XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1jMlxcXCI+UmVnaXN0ZXI8L2J1dHRvbj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG48L2Rpdj5cXG48L2Zvcm0+XFxuXFxuPGZvcm0gcm9sZT1cXFwiZm9ybVxcXCIgaWQ9XFxcImZvcmdvdC1mb3JtXFxcIj5cXG48ZGl2IGNsYXNzPVxcXCJtb2RhbC1ib2R5IHBhZGRpbmctYm90dG9tLW5vbmVcXFwiIGlkPVxcXCJmb3Jnb3Qtdmlld1xcXCI+XFxuICAgIDxoMj5SZXNldCBZb3VyIFBhc3N3b3JkPC9oMj5cXG5cXG4gICAgPHA+UGxlYXNlIGVudGVyIHlvdXIgZW1haWwgYWRkcmVzcyBhbmQgd2UnbGwgc2VuZCB5b3UgYSBsaW5rIHRvIHJlc2V0IHlvdXIgcGFzc3dvcmQ8L3A+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICAgIDxsYWJlbCBmb3I9XFxcImZ1c2VybmFtZVxcXCIgY2xhc3M9XFxcImNvbnRyb2wtbGFiZWxcXFwiPkVtYWlsIEFkZHJlc3M8L2xhYmVsPlxcbiAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sIHZhbGlkYXRlXFxcIiBpZD1cXFwiZnVzZXJuYW1lXFxcIiBuYW1lPVxcXCJ1c2VybmFtZVxcXCIgcGxhY2Vob2xkZXI9XFxcIkVtYWlsIEFkZHJlc3NcXFwiIGRhdGEtdmFsaWRhdGU9XFxcImJ1dHRvblxcXCIvPlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cCBtYXJnaW4tYm90dG9tLW5vbmVcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtc20tMTJcXFwiPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJhbGVydCBhbGVydC1kYW5nZXJcXFwiIGlkPVxcXCJmb3Jnb3QtZXJyb3JcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIj48L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJtb2RhbC1mb290ZXIgbW9kYWwtZm9vdGVyLWdyZXlcXFwiIGlkPVxcXCJmb3Jnb3QtZm9vdGVyXFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtc20tMTJcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInB1bGwtcmlnaHRcXFwiPlxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGlkPVxcXCJmb3Jnb3QtY2FuY2VsXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1jMFxcXCI+Q2FuY2VsPC9idXR0b24+XFxuICAgICAgICA8YnV0dG9uIHR5cGU9XFxcInN1Ym1pdFxcXCIgY2xhc3M9XFxcImJ0biBidG4tYzJcXFwiPlJlc2V0IFBhc3N3b3JkPC9idXR0b24+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuPC9mb3JtPlxcblxcbjxkaXYgY2xhc3M9XFxcIm1vZGFsLWJvZHkgcGFkZGluZy1ib3R0b20tbm9uZVxcXCIgaWQ9XFxcImZvcmdvdC1kb25lLXZpZXdcXFwiPlxcbiAgICA8aDI+UmVzZXQgWW91ciBQYXNzd29yZDwvaDI+XFxuXFxuICAgIDxwPlxcbiAgICAgIFRoYW5rIHlvdSEgQW4gZW1haWwgd2lsbCBhcnJpdmUgc2hvcnRseSB3aXRoIGEgbGluayB0byByZXNldCB5b3VyIHBhc3N3b3JkLlxcbiAgICA8L3A+XFxuICAgIDxwPlxcbiAgICAgIElmIHlvdSBkb24ndCByZWNlaXZlIGFuIGVtYWlsIHNob3J0bHksIGNoZWNrIHlvdXIgc3BhbSBmb2xkZXIuXFxuICAgIDwvcD5cXG48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJtb2RhbC1mb290ZXIgbW9kYWwtZm9vdGVyLWdyZXlcXFwiIGlkPVxcXCJmb3Jnb3QtZG9uZS1mb290ZXJcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImNvbC1zbS0xMlxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwicHVsbC1yaWdodFxcXCI+XFxuICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgaWQ9XFxcImZvcmdvdC1kb25lLWNhbmNlbFxcXCIgY2xhc3M9XFxcImJ0biBidG4tYzJcXFwiPlJldHVybiB0byBMb2dpbjwvYnV0dG9uPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZGl2PlwiO1xuIiwiXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgTG9naW5QYXNzd29yZFRlbXBsYXRlID0gcmVxdWlyZSgnLi4vdGVtcGxhdGVzL2xvZ2luX3Bhc3N3b3JkX3RlbXBsYXRlLmh0bWwnKTtcblxuXG52YXIgTG9naW5QYXNzd29yZFZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciB0ZW1wbGF0ZSA9IF8udGVtcGxhdGUoTG9naW5QYXNzd29yZFRlbXBsYXRlKTtcbiAgICB0aGlzLiRlbC5odG1sKHRlbXBsYXRlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfSxcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExvZ2luUGFzc3dvcmRWaWV3O1xuXG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgTG9naW5QYXNzd29yZFZpZXcgPSByZXF1aXJlKCcuL2xvZ2luX3Bhc3N3b3JkX3ZpZXcnKTtcbnZhciBMb2dpblRlbXBsYXRlID0gcmVxdWlyZSgnLi4vdGVtcGxhdGVzL2xvZ2luX3RlbXBsYXRlLmh0bWwnKTtcbnZhciBNb2RhbENvbXBvbmVudCA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbXBvbmVudHMvbW9kYWwnKTtcblxuXG52YXIgTG9naW5WaWV3ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuXG4gIGV2ZW50czoge1xuICAgICdjbGljayAub2F1dGgtbGluaycgICAgICAgICAgICAgIDogJ2xpbmsnLFxuICAgICdrZXl1cCAjcm5hbWUnICAgICAgICAgICAgICAgICAgIDogJ2NoZWNrTmFtZScsXG4gICAgJ2NoYW5nZSAjcm5hbWUnICAgICAgICAgICAgICAgICAgOiAnY2hlY2tOYW1lJyxcbiAgICAnYmx1ciAjcm5hbWUnICAgICAgICAgICAgICAgICAgICA6ICdjaGVja05hbWUnLFxuICAgICdrZXl1cCAjcnVzZXJuYW1lJyAgICAgICAgICAgICAgIDogJ2NoZWNrVXNlcm5hbWUnLFxuICAgICdjaGFuZ2UgI3J1c2VybmFtZScgICAgICAgICAgICAgIDogJ2NoZWNrVXNlcm5hbWUnLFxuICAgICdjbGljayAjcnVzZXJuYW1lLWJ1dHRvbicgICAgICAgIDogJ2NsaWNrVXNlcm5hbWUnLFxuICAgICdrZXl1cCAjcnBhc3N3b3JkJyAgICAgICAgICAgICAgIDogJ2NoZWNrUGFzc3dvcmQnLFxuICAgICdibHVyICNycGFzc3dvcmQnICAgICAgICAgICAgICAgIDogJ2NoZWNrUGFzc3dvcmQnLFxuICAgICdrZXl1cCAjcnBhc3N3b3JkLWNvbmZpcm0nICAgICAgIDogJ2NoZWNrUGFzc3dvcmRDb25maXJtJyxcbiAgICAnYmx1ciAjcnBhc3N3b3JkLWNvbmZpcm0nICAgICAgICA6ICdjaGVja1Bhc3N3b3JkQ29uZmlybScsXG4gICAgJ3N1Ym1pdCAjbG9naW4tcGFzc3dvcmQtZm9ybScgICAgOiAnc3VibWl0TG9naW4nLFxuICAgICdzdWJtaXQgI3JlZ2lzdHJhdGlvbi1mb3JtJyAgICAgIDogJ3N1Ym1pdFJlZ2lzdGVyJyxcbiAgICAnc3VibWl0ICNmb3Jnb3QtZm9ybScgICAgICAgICAgICA6ICdzdWJtaXRGb3Jnb3QnXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIGxvZ2luOiB0aGlzLm9wdGlvbnMubG9naW4sXG4gICAgICBtZXNzYWdlOiB0aGlzLm9wdGlvbnMubWVzc2FnZVxuICAgIH07XG4gICAgdmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZShMb2dpblRlbXBsYXRlKShkYXRhKTtcbiAgICB0aGlzLiRlbC5odG1sKHRlbXBsYXRlKTtcbiAgICB0aGlzLiRlbC5pMThuKCk7XG4gICAgdGhpcy5sb2dpblBhc3N3b3JkVmlldyA9IG5ldyBMb2dpblBhc3N3b3JkVmlldyh7XG4gICAgICBlbDogdGhpcy4kKFwiLnBhc3N3b3JkLXZpZXdcIilcbiAgICB9KS5yZW5kZXIoKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuJChcIiN1c2VybmFtZVwiKS5mb2N1cygpO1xuICAgIH0sIDUwMCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgbGluazogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHZhciBsaW5rID0gJChlLmN1cnJlbnRUYXJnZXQpLmF0dHIoJ2hyZWYnKTtcbiAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGxpbms7XG4gIH0sXG5cbiAgdjogZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gdmFsaWRhdGUoZSk7XG4gIH0sXG5cbiAgc3VibWl0TG9naW46IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICB1c2VybmFtZTogdGhpcy4kKFwiI3VzZXJuYW1lXCIpLnZhbCgpLFxuICAgICAgcGFzc3dvcmQ6IHRoaXMuJChcIiNwYXNzd29yZFwiKS52YWwoKSxcbiAgICAgIGpzb246IHRydWVcbiAgICB9O1xuICAgICQuYWpheCh7XG4gICAgICB1cmw6ICcvYXBpL2F1dGgvbG9jYWwnLFxuICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pLmRvbmUoZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcbiAgICAgIC8vIFNldCB0aGUgdXNlciBvYmplY3QgYW5kIHRyaWdnZXIgdGhlIHVzZXIgbG9naW4gZXZlbnRcbiAgICAgIHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlciA9IHN1Y2Nlc3M7XG4gICAgICB3aW5kb3cuY2FjaGUudXNlckV2ZW50cy50cmlnZ2VyKFwidXNlcjpsb2dpblwiLCBzdWNjZXNzKTtcbiAgICB9KS5mYWlsKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgdmFyIGQgPSBKU09OLnBhcnNlKGVycm9yLnJlc3BvbnNlVGV4dCk7XG4gICAgICBzZWxmLiQoXCIjbG9naW4tZXJyb3JcIikuaHRtbChkLm1lc3NhZ2UpO1xuICAgICAgc2VsZi4kKFwiI2xvZ2luLWVycm9yXCIpLnNob3coKTtcbiAgICB9KTtcbiAgfSxcblxuICBzdWJtaXRSZWdpc3RlcjogZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICRzdWJtaXRCdXR0b24gPSBzZWxmLiQoJyNyZWdpc3RyYXRpb24tZm9ybSBbdHlwZT1cInN1Ym1pdFwiXScpO1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAkc3VibWl0QnV0dG9uLnByb3AoJ2Rpc2FibGVkJywgdHJ1ZSk7XG4gICAgLy8gdmFsaWRhdGUgaW5wdXQgZmllbGRzXG4gICAgdmFyIHZhbGlkYXRlSWRzID0gWycjcm5hbWUnLCAnI3J1c2VybmFtZScsICcjcnBhc3N3b3JkJ107XG4gICAgLy8gT25seSB2YWxpZGF0ZSB0ZXJtcyAmIGNvbmRpdGlvbnMgaWYgaXQgaXMgZW5hYmxlZFxuICAgIGlmICh0aGlzLm9wdGlvbnMubG9naW4udGVybXMuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgdmFsaWRhdGVJZHMucHVzaCgnI3J0ZXJtcycpO1xuICAgIH1cbiAgICB2YXIgYWJvcnQgPSBmYWxzZTtcbiAgICBmb3IgKGkgaW4gdmFsaWRhdGVJZHMpIHtcbiAgICAgIHZhciBpQWJvcnQgPSB2YWxpZGF0ZSh7IGN1cnJlbnRUYXJnZXQ6IHZhbGlkYXRlSWRzW2ldIH0pO1xuICAgICAgYWJvcnQgPSBhYm9ydCB8fCBpQWJvcnQ7XG4gICAgfVxuICAgIHZhciBwYXNzd29yZFN1Y2Nlc3MgPSB0aGlzLmNoZWNrUGFzc3dvcmQoKTtcbiAgICB2YXIgcGFyZW50ID0gJCh0aGlzLiQoXCIjcnBhc3N3b3JkXCIpLnBhcmVudHMoJy5mb3JtLWdyb3VwJylbMF0pO1xuICAgIGlmIChwYXNzd29yZFN1Y2Nlc3MgIT09IHRydWUpIHtcbiAgICAgIHBhcmVudC5hZGRDbGFzcygnaGFzLWVycm9yJyk7XG4gICAgICAkKHBhcmVudC5maW5kKCcuZXJyb3ItcGFzc3dvcmQnKVswXSkuc2hvdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkKHBhcmVudC5maW5kKCcuZXJyb3ItcGFzc3dvcmQnKVswXSkuaGlkZSgpO1xuICAgIH1cbiAgICB2YXIgcGFzc3dvcmRDb25maXJtU3VjY2VzcyA9IHRoaXMuY2hlY2tQYXNzd29yZENvbmZpcm0oKTtcbiAgICB2YXIgcGFzc3dvcmRDb25maXJtUGFyZW50ID0gJCh0aGlzLiQoXCIjcnBhc3N3b3JkLWNvbmZpcm1cIikucGFyZW50cygnLmZvcm0tZ3JvdXAnKVswXSk7XG4gICAgaWYgKHBhc3N3b3JkQ29uZmlybVN1Y2Nlc3MgIT09IHRydWUpIHtcbiAgICAgIHBhc3N3b3JkQ29uZmlybVBhcmVudC5hZGRDbGFzcygnaGFzLWVycm9yJyk7XG4gICAgICAkKHBhc3N3b3JkQ29uZmlybVBhcmVudC5maW5kKCcuZXJyb3ItcGFzc3dvcmQnKVswXSkuc2hvdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkKHBhc3N3b3JkQ29uZmlybVBhcmVudC5maW5kKCcuZXJyb3ItcGFzc3dvcmQnKVswXSkuaGlkZSgpO1xuICAgIH1cbiAgICBpZiAoYWJvcnQgPT09IHRydWUgfHwgcGFzc3dvcmRTdWNjZXNzICE9PSB0cnVlIHx8IHBhc3N3b3JkQ29uZmlybVN1Y2Nlc3MgIT09IHRydWUpIHtcbiAgICAgICRzdWJtaXRCdXR0b24ucHJvcCgnZGlzYWJsZWQnLCBmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgZGF0YSBvYmplY3Qgd2l0aCB0aGUgcmVxdWlyZWQgZmllbGRzXG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBuYW1lOiB0aGlzLiQoXCIjcm5hbWVcIikudmFsKCksXG4gICAgICB1c2VybmFtZTogdGhpcy4kKFwiI3J1c2VybmFtZVwiKS52YWwoKSxcbiAgICAgIHBhc3N3b3JkOiB0aGlzLiQoXCIjcnBhc3N3b3JkXCIpLnZhbCgpLFxuICAgICAganNvbjogdHJ1ZVxuICAgIH07XG4gICAgLy8gQWRkIGluIGFkZGl0aW9uYWwsIG9wdGlvbmFsIGZpZWxkc1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9naW4udGVybXMuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgZGF0YVsndGVybXMnXSA9ICh0aGlzLiQoXCIjcnRlcm1zXCIpLnZhbCgpID09IFwib25cIik7XG4gICAgfVxuICAgIC8vIFBvc3QgdGhlIHJlZ2lzdHJhdGlvbiByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXJcbiAgICAkLmFqYXgoe1xuICAgICAgdXJsOiAnL2FwaS9hdXRoL3JlZ2lzdGVyJyxcbiAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KS5kb25lKGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAvLyBTZXQgdGhlIHVzZXIgb2JqZWN0IGFuZCB0cmlnZ2VyIHRoZSB1c2VyIGxvZ2luIGV2ZW50XG4gICAgICB3aW5kb3cuY2FjaGUuY3VycmVudFVzZXIgPSBzdWNjZXNzO1xuICAgICAgd2luZG93LmNhY2hlLnVzZXJFdmVudHMudHJpZ2dlcihcInVzZXI6bG9naW5cIiwgc3VjY2Vzcyk7XG4gICAgfSkuZmFpbChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHZhciBkID0gSlNPTi5wYXJzZShlcnJvci5yZXNwb25zZVRleHQpO1xuICAgICAgc2VsZi4kKFwiI3JlZ2lzdHJhdGlvbi1lcnJvclwiKS5odG1sKGQubWVzc2FnZSk7XG4gICAgICBzZWxmLiQoXCIjcmVnaXN0cmF0aW9uLWVycm9yXCIpLnNob3coKTtcbiAgICAgICRzdWJtaXRCdXR0b24ucHJvcCgnZGlzYWJsZWQnLCBmYWxzZSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgc3VibWl0Rm9yZ290OiBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHZhciBkYXRhID0ge1xuICAgICAgdXNlcm5hbWU6IHRoaXMuJChcIiNmdXNlcm5hbWVcIikudmFsKClcbiAgICB9O1xuICAgIC8vIFBvc3QgdGhlIHJlZ2lzdHJhdGlvbiByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXJcbiAgICAkLmFqYXgoe1xuICAgICAgdXJsOiAnL2FwaS9hdXRoL2ZvcmdvdCcsXG4gICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSkuZG9uZShmdW5jdGlvbiAoc3VjY2Vzcykge1xuICAgICAgLy8gU2V0IHRoZSB1c2VyIG9iamVjdCBhbmQgdHJpZ2dlciB0aGUgdXNlciBsb2dpbiBldmVudFxuICAgICAgc2VsZi4kKFwiI2ZvcmdvdC12aWV3XCIpLmhpZGUoKTtcbiAgICAgIHNlbGYuJChcIiNmb3Jnb3QtZm9vdGVyXCIpLmhpZGUoKTtcbiAgICAgIHNlbGYuJChcIiNmb3Jnb3QtZG9uZS12aWV3XCIpLnNob3coKTtcbiAgICAgIHNlbGYuJChcIiNmb3Jnb3QtZG9uZS1mb290ZXJcIikuc2hvdygpO1xuICAgIH0pLmZhaWwoZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICB2YXIgZCA9IEpTT04ucGFyc2UoZXJyb3IucmVzcG9uc2VUZXh0KTtcbiAgICAgIHNlbGYuJChcIiNmb3Jnb3QtZXJyb3JcIikuaHRtbChkLm1lc3NhZ2UpO1xuICAgICAgc2VsZi4kKFwiI2ZvcmdvdC1lcnJvclwiKS5zaG93KCk7XG4gICAgfSk7XG4gIH0sXG5cbiAgY2hlY2tOYW1lOiBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBuYW1lID0gdGhpcy4kKFwiI3JuYW1lXCIpLnZhbCgpO1xuICAgIGlmIChuYW1lICYmIG5hbWUgIT09ICcnKSB7XG4gICAgICAkKFwiI3JuYW1lXCIpLmNsb3Nlc3QoXCIuZm9ybS1ncm91cFwiKS5maW5kKFwiLmhlbHAtYmxvY2tcIikuaGlkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkKFwiI3JuYW1lXCIpLmNsb3Nlc3QoXCIuZm9ybS1ncm91cFwiKS5maW5kKFwiLmhlbHAtYmxvY2tcIikuc2hvdygpO1xuICAgIH1cbiAgfSxcblxuICBjaGVja1VzZXJuYW1lOiBmdW5jdGlvbiAoZSkge1xuICAgIHZhciB1c2VybmFtZSA9ICQoXCIjcnVzZXJuYW1lXCIpLnZhbCgpO1xuICAgICQuYWpheCh7XG4gICAgICB1cmw6ICcvYXBpL3VzZXIvdXNlcm5hbWUvJyArIHVzZXJuYW1lLFxuICAgIH0pLmRvbmUoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICQoXCIjcnVzZXJuYW1lLWJ1dHRvblwiKS5yZW1vdmVDbGFzcygnYnRuLXN1Y2Nlc3MnKTtcbiAgICAgICQoXCIjcnVzZXJuYW1lLWJ1dHRvblwiKS5yZW1vdmVDbGFzcygnYnRuLWRhbmdlcicpO1xuICAgICAgJChcIiNydXNlcm5hbWUtY2hlY2tcIikucmVtb3ZlQ2xhc3MoJ2ZhIGZhLWNoZWNrJyk7XG4gICAgICAkKFwiI3J1c2VybmFtZS1jaGVja1wiKS5yZW1vdmVDbGFzcygnZmEgZmEtdGltZXMnKTtcbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIC8vIHVzZXJuYW1lIGlzIHRha2VuXG4gICAgICAgICQoXCIjcnVzZXJuYW1lLWJ1dHRvblwiKS5hZGRDbGFzcygnYnRuLWRhbmdlcicpO1xuICAgICAgICAkKFwiI3J1c2VybmFtZS1jaGVja1wiKS5hZGRDbGFzcygnZmEgZmEtdGltZXMnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVzZXJuYW1lIGlzIGF2YWlsYWJsZVxuICAgICAgICAkKFwiI3J1c2VybmFtZS1idXR0b25cIikuYWRkQ2xhc3MoJ2J0bi1zdWNjZXNzJyk7XG4gICAgICAgICQoXCIjcnVzZXJuYW1lLWNoZWNrXCIpLmFkZENsYXNzKCdmYSBmYS1jaGVjaycpO1xuICAgICAgICAkKFwiI3J1c2VybmFtZVwiKS5jbG9zZXN0KFwiLmZvcm0tZ3JvdXBcIikucmVtb3ZlQ2xhc3MoJ2hhcy1lcnJvcicpO1xuICAgICAgICAkKFwiI3J1c2VybmFtZVwiKS5jbG9zZXN0KFwiLmZvcm0tZ3JvdXBcIikuZmluZChcIi5oZWxwLWJsb2NrXCIpLmhpZGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBjaGVja1Bhc3N3b3JkOiBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBydWxlcyA9IHZhbGlkYXRlUGFzc3dvcmQodGhpcy4kKFwiI3J1c2VybmFtZVwiKS52YWwoKSwgdGhpcy4kKFwiI3JwYXNzd29yZFwiKS52YWwoKSk7XG4gICAgdmFyIHZhbHVlc0FycmF5ID0gXy52YWx1ZXMocnVsZXMpO1xuICAgIHZhciB2YWxpZFJ1bGVzID0gXy5ldmVyeSh2YWx1ZXNBcnJheSk7XG4gICAgdmFyIHN1Y2Nlc3MgPSB0cnVlO1xuICAgIGlmICh2YWxpZFJ1bGVzID09PSB0cnVlKSB7XG4gICAgICAkKFwiI3JwYXNzd29yZFwiKS5jbG9zZXN0KFwiLmZvcm0tZ3JvdXBcIikucmVtb3ZlQ2xhc3MoJ2hhcy1lcnJvcicpO1xuICAgICAgJChcIiNycGFzc3dvcmRcIikuY2xvc2VzdChcIi5mb3JtLWdyb3VwXCIpLmZpbmQoXCIuaGVscC1ibG9ja1wiKS5oaWRlKCk7XG4gICAgfVxuICAgIF8uZWFjaChydWxlcywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLiQoXCIucGFzc3dvcmQtcnVsZXMgLnN1Y2Nlc3MucnVsZS1cIiArIGtleSkuc2hvdygpO1xuICAgICAgICB0aGlzLiQoXCIucGFzc3dvcmQtcnVsZXMgLmVycm9yLnJ1bGUtXCIgKyBrZXkpLmhpZGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuJChcIi5wYXNzd29yZC1ydWxlcyAuc3VjY2Vzcy5ydWxlLVwiICsga2V5KS5oaWRlKCk7XG4gICAgICAgIHRoaXMuJChcIi5wYXNzd29yZC1ydWxlcyAuZXJyb3IucnVsZS1cIiArIGtleSkuc2hvdygpO1xuICAgICAgfVxuICAgICAgc3VjY2VzcyA9IHN1Y2Nlc3MgJiYgdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN1Y2Nlc3M7XG4gIH0sXG5cbiAgY2hlY2tQYXNzd29yZENvbmZpcm06IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHN1Y2Nlc3MgPSB0cnVlO1xuICAgIHZhciBwYXNzd29yZCA9IHRoaXMuJChcIiNycGFzc3dvcmRcIikudmFsKCk7XG4gICAgdmFyIGNvbmZpcm0gPSB0aGlzLiQoXCIjcnBhc3N3b3JkLWNvbmZpcm1cIikudmFsKClcbiAgICBpZiAocGFzc3dvcmQgPT09IGNvbmZpcm0pIHtcbiAgICAgICQoXCIjcnBhc3N3b3JkLWNvbmZpcm1cIikuY2xvc2VzdChcIi5mb3JtLWdyb3VwXCIpLmZpbmQoXCIuaGVscC1ibG9ja1wiKS5oaWRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICQoXCIjcnBhc3N3b3JkLWNvbmZpcm1cIikuY2xvc2VzdChcIi5mb3JtLWdyb3VwXCIpLmZpbmQoXCIuaGVscC1ibG9ja1wiKS5zaG93KCk7XG4gICAgICBzdWNjZXNzID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzdWNjZXNzO1xuICB9LFxuXG4gIGNsaWNrVXNlcm5hbWU6IGZ1bmN0aW9uIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9LFxuXG4gIGNsZWFudXA6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5sb2dpblBhc3N3b3JkVmlldykgeyB0aGlzLmxvZ2luUGFzc3dvcmRWaWV3LmNsZWFudXAoKTsgfVxuICAgIHJlbW92ZVZpZXcodGhpcyk7XG4gIH0sXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBMb2dpblZpZXc7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBpZD1cXFwibG9naW4td3JhcHBlclxcXCI+PC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwibmF2YmFyIG5hdmJhci1kZWZhdWx0IG5hdmJhci1zdGF0aWMtdG9wXFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcImNvbnRhaW5lclxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcIm5hdmJhci1oZWFkZXJcXFwiPlxcbiAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwibmF2YmFyLXRvZ2dsZVxcXCIgZGF0YS10b2dnbGU9XFxcImNvbGxhcHNlXFxcIiBkYXRhLXRhcmdldD1cXFwiLm5hdmJhci1jb2xsYXBzZVxcXCI+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaWNvbi1iYXJcXFwiPjwvc3Bhbj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpY29uLWJhclxcXCI+PC9zcGFuPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcImljb24tYmFyXFxcIj48L3NwYW4+XFxuICAgICAgPC9idXR0b24+XFxuICAgICAgPGEgY2xhc3M9XFxcIm5hdmJhci1icmFuZFxcXCIgaHJlZj1cXFwiL1xcXCIgdGl0bGU9XFxcIjwlLSBzeXN0ZW1OYW1lICU+IEhvbWVcXFwiPlxcbiAgICAgIDwvYT5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcIm5hdmJhci1jb2xsYXBzZSBjb2xsYXBzZSBwdWxsLXJpZ2h0XFxcIj5cXG4gICAgICA8dWwgY2xhc3M9XFxcIm5hdiBuYXZiYXItbmF2XFxcIj5cXG5cXG4gICAgICAgIDwlIGlmICh1aS5wcm9qZWN0LnNob3cpIHsgJT5cXG4gICAgICAgIDxsaSBjbGFzcz1cXFwicHJvamVjdHNcXFwiPlxcbiAgICAgICAgICA8YSBocmVmPVxcXCIvcHJvamVjdHNcXFwiIGNsYXNzPVxcXCJuYXYtbGlua1xcXCI+XFxuICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLXJvY2tldFxcXCI+PC9pPlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJuYXZiYXItdGl0bGUtc21hbGxcXFwiIGRhdGEtaTE4bj1cXFwiQnJvd3NlXFxcIj5Ccm93c2U8L3NwYW4+PGJyLz5cXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwibmF2YmFyLXRpdGxlLWJpZ1xcXCIgZGF0YS1pMThuPVxcXCJQcm9qZWN0UGx1cmFsXFxcIj5Qcm9qZWN0czwvc3Bhbj5cXG4gICAgICAgICAgPC9hPlxcbiAgICAgICAgPC9saT5cXG4gICAgICAgIDwlIH0gJT5cXG4gICAgICAgIDxsaSBjbGFzcz1cXFwidGFza3NcXFwiPlxcbiAgICAgICAgICA8YSBocmVmPVxcXCIvdGFza3NcXFwiIGNsYXNzPVxcXCJuYXYtbGlua1xcXCI+XFxuICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLXRhZ3NcXFwiPjwvaT5cXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwibmF2YmFyLXRpdGxlLXNtYWxsXFxcIiBkYXRhLWkxOG49XFxcIkJyb3dzZVxcXCI+QnJvd3NlPC9zcGFuPjxici8+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcIm5hdmJhci10aXRsZS1iaWdcXFwiIGRhdGEtaTE4bj1cXFwiVGFza1BsdXJhbFxcXCI+VGFza3M8L3NwYW4+XFxuICAgICAgICAgIDwvYT5cXG4gICAgICAgIDwvbGk+XFxuXFxuICAgICAgICA8bGkgY2xhc3M9XFxcImRpdmlkZXItdmVydGljYWwgbmF2YmFyLXRleHRcXFwiPjwvbGk+XFxuICAgICAgICA8JSBpZiAodXNlcikgeyAlPlxcbiAgICAgICAgICA8bGkgY2xhc3M9XFxcInByb2ZpbGUgZHJvcGRvd25cXFwiPjxhIGhyZWY9XFxcIi9wcm9maWxlXFxcIiBpZD1cXFwibmF2YmFyLXByb2ZpbGVcXFwiIHJvbGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImRyb3Bkb3duLXRvZ2dsZVxcXCIgZGF0YS10b2dnbGU9XFxcImRyb3Bkb3duXFxcIj5cXG4gICAgICAgICAgICA8aW1nIHNyYz1cXFwiL2FwaS91c2VyL3Bob3RvLzwlLSB1c2VyLmlkICU+XFxcIiBjbGFzcz1cXFwibmF2YmFyLXBlb3BsZVxcXCIvPiAmbmJzcDtcXG4gICAgICAgICAgICAgIDwlIGlmICh1c2VyLm5hbWUpIHsgJT48JS0gdXNlci5uYW1lICU+XFxuICAgICAgICAgICAgICA8JSB9IGVsc2UgeyAlPjwlLSB1c2VyLnVzZXJuYW1lICU+XFxuICAgICAgICAgICAgICA8JSB9ICU+XFxuICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwiZHJvcGRvd24tbWVudVxcXCIgcm9sZT1cXFwibWVudVxcXCIgYXJpYS1sYWJlbGxlZGJ5PVxcXCJuYXZiYXItcHJvZmlsZVxcXCI+XFxuICAgICAgICAgICAgICA8bGkgcm9sZT1cXFwicHJlc2VudGF0aW9uXFxcIj48YSByb2xlPVxcXCJtZW51aXRlbVxcXCIgY2xhc3M9XFxcIm5hdi1saW5rXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiIGhyZWY9XFxcIi9wcm9maWxlXFxcIj5Qcm9maWxlPC9hPjwvbGk+XFxuICAgICAgICAgICAgICA8JSBpZiAodXNlci5pc0FkbWluID09PSB0cnVlKSB7ICU+XFxuICAgICAgICAgICAgICA8bGkgcm9sZT1cXFwicHJlc2VudGF0aW9uXFxcIiBjbGFzcz1cXFwiZGl2aWRlclxcXCI+PC9saT5cXG4gICAgICAgICAgICAgIDxsaSByb2xlPVxcXCJwcmVzZW50YXRpb25cXFwiPjxhIHJvbGU9XFxcIm1lbnVpdGVtXFxcIlxcbiAgICAgICAgICAgICAgICAgdGFiaW5kZXg9XFxcIi0xXFxcIiBocmVmPVxcXCIvYWRtaW5cXFwiIGNsYXNzPVxcXCJuYXYtbGlua1xcXCI+QWRtaW5pc3RyYXRpb248L2E+PC9saT5cXG4gICAgICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgICAgIDwlIGlmIChsb2dpbi5sb2NhbC5sb2dvdXQpIHsgJT5cXG4gICAgICAgICAgICAgIDxsaSByb2xlPVxcXCJwcmVzZW50YXRpb25cXFwiIGNsYXNzPVxcXCJkaXZpZGVyXFxcIj48L2xpPlxcbiAgICAgICAgICAgICAgPGxpIHJvbGU9XFxcInByZXNlbnRhdGlvblxcXCI+PGEgcm9sZT1cXFwibWVudWl0ZW1cXFwiXFxuICAgICAgICAgICAgICAgICB0YWJpbmRleD1cXFwiLTFcXFwiIGhyZWY9XFxcIi9hdXRoL2xvZ291dFxcXCIgY2xhc3M9XFxcImxvZ291dFxcXCI+TG9nb3V0PC9hPjwvbGk+XFxuICAgICAgICAgICAgICA8JSB9ICU+XFxuICAgICAgICAgICAgPC91bD5cXG4gICAgICAgICAgPC9saT5cXG4gICAgICAgIDwlIH0gZWxzZSB7ICU+XFxuICAgICAgICAgIDwlIGlmIChsb2dpbi5zaWduaW4gIT09IGZhbHNlKSB7ICU+XFxuICAgICAgICAgIDxsaSBjbGFzcz1cXFwibmF2YmFyLTFsaW5lXFxcIj48YSBocmVmPVxcXCIvYXV0aFxcXCIgY2xhc3M9XFxcImxvZ2luXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtcGx1cy1jaXJjbGVcXFwiPjwvaT4gU2lnbiBJbjwvYT48L2xpPlxcbiAgICAgICAgICA8JSB9ICU+XFxuICAgICAgICA8JSB9OyAlPlxcbiAgICAgIDwvdWw+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgVUlDb25maWcgPSByZXF1aXJlKCcuLi8uLi8uLi9jb25maWcvdWkuanNvbicpO1xudmFyIExvZ2luID0gcmVxdWlyZSgnLi4vLi4vLi4vY29uZmlnL2xvZ2luLmpzb24nKTtcbnZhciBMb2dpbkNvbnRyb2xsZXIgPSByZXF1aXJlKCcuLi8uLi9sb2dpbi9jb250cm9sbGVycy9sb2dpbl9jb250cm9sbGVyJyk7XG52YXIgTmF2VGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvbmF2X3RlbXBsYXRlLmh0bWwnKTtcblxuXG52YXIgTmF2VmlldyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcblxuICBldmVudHM6IHtcbiAgICAnY2xpY2sgLm5hdmJhci1icmFuZCcgICA6IGxpbmtCYWNrYm9uZSxcbiAgICAnY2xpY2sgLm5hdi1saW5rJyAgICAgICA6IGxpbmtCYWNrYm9uZSxcbiAgICAnY2xpY2sgLmxvZ2luJyAgICAgICAgICA6ICdsb2dpbkNsaWNrJyxcbiAgICAnY2xpY2sgLmxvZ291dCcgICAgICAgICA6ICdsb2dvdXQnXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgIHRoaXMubGlzdGVuVG8od2luZG93LmNhY2hlLnVzZXJFdmVudHMsIFwidXNlcjpsb2dpbjpzdWNjZXNzXCIsIGZ1bmN0aW9uICh1c2VyRGF0YSkge1xuICAgICAgc2VsZi5kb1JlbmRlcih7IHVzZXI6IHVzZXJEYXRhIH0pO1xuICAgIH0pO1xuXG4gICAgdGhpcy5saXN0ZW5Ubyh3aW5kb3cuY2FjaGUudXNlckV2ZW50cywgXCJ1c2VyOmxvZ291dFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLmRvUmVuZGVyKHsgdXNlcjogbnVsbCB9KTtcbiAgICAgIEJhY2tib25lLmhpc3RvcnkubG9hZFVybCgpO1xuICAgICAgd2luZG93LmNhY2hlLnVzZXJFdmVudHMudHJpZ2dlcihcInVzZXI6bG9nb3V0OnN1Y2Nlc3NcIik7XG4gICAgfSk7XG5cbiAgICAvLyByZXF1ZXN0IHRoYXQgdGhlIHVzZXIgbG9nIGluIHRvIHNlZSB0aGUgcGFnZVxuICAgIHRoaXMubGlzdGVuVG8od2luZG93LmNhY2hlLnVzZXJFdmVudHMsIFwidXNlcjpyZXF1ZXN0OmxvZ2luXCIsIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAvLyB0cmlnZ2VyIHRoZSBsb2dpbiBtb2RhbFxuICAgICAgc2VsZi5sb2dpbihtZXNzYWdlKTtcbiAgICB9KTtcblxuICAgIC8vIHVwZGF0ZSB0aGUgbmF2YmFyIHdoZW4gdGhlIHByb2ZpbGUgY2hhbmdlc1xuICAgIHRoaXMubGlzdGVuVG8od2luZG93LmNhY2hlLnVzZXJFdmVudHMsIFwidXNlcjpwcm9maWxlOnNhdmVcIiwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIC8vIHJlc2V0IHRoZSBjdXJyZW50VXNlciBvYmplY3RcbiAgICAgIHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlciA9IGRhdGE7XG4gICAgICAvLyByZS1yZW5kZXIgdGhlIHZpZXdcbiAgICAgIHNlbGYucmVuZGVyKCk7XG4gICAgfSk7XG5cbiAgICAvLyB1cGRhdGUgdGhlIHVzZXIncyBwaG90byB3aGVuIHRoZXkgY2hhbmdlIGl0XG4gICAgdGhpcy5saXN0ZW5Ubyh3aW5kb3cuY2FjaGUudXNlckV2ZW50cywgXCJ1c2VyOnByb2ZpbGU6cGhvdG86c2F2ZVwiLCBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAkKFwiLm5hdmJhci1wZW9wbGVcIikuYXR0cignc3JjJywgdXJsKTtcbiAgICB9KTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5kb1JlbmRlcih7IHVzZXI6IHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlciwgc3lzdGVtTmFtZTogd2luZG93LmNhY2hlLnN5c3RlbS5uYW1lIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGRvUmVuZGVyOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRhdGEubG9naW4gPSBMb2dpbjtcbiAgICBkYXRhLnVpID0gVUlDb25maWc7XG4gICAgdmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZShOYXZUZW1wbGF0ZSkoZGF0YSk7XG4gICAgdGhpcy4kZWwuaHRtbCh0ZW1wbGF0ZSk7XG4gICAgdGhpcy4kZWwuaTE4bigpO1xuICAgICQoXCIubmF2IGxpXCIpLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgJChcIi5uYXYgbGlcIikucmVtb3ZlQ2xhc3MoXCJhY3RpdmVcIik7XG4gICAgICAkKHRoaXMpLmFkZENsYXNzKFwiYWN0aXZlXCIpO1xuICAgIH0pO1xuICB9LFxuXG4gIGxvZ2luQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLmxvZ2luKCk7XG4gIH0sXG5cbiAgbG9naW46IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMubG9naW5Db250cm9sbGVyKSB7XG4gICAgICB0aGlzLmxvZ2luQ29udHJvbGxlci5jbGVhbnVwKCk7XG4gICAgfVxuICAgIHRoaXMubG9naW5Db250cm9sbGVyID0gbmV3IExvZ2luQ29udHJvbGxlcih7XG4gICAgICBlbDogJyNsb2dpbi13cmFwcGVyJyxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICB9KTtcbiAgfSxcblxuICBsb2dvdXQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAkLmFqYXgoe1xuICAgICAgdXJsOiAnL2FwaS9hdXRoL2xvZ291dD9qc29uPXRydWUnLFxuICAgIH0pLmRvbmUoZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcbiAgICAgIHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlciA9IG51bGw7XG4gICAgICB3aW5kb3cuY2FjaGUudXNlckV2ZW50cy50cmlnZ2VyKFwidXNlcjpsb2dvdXRcIik7XG4gICAgfSkuZmFpbChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICB9KTtcbiAgfSxcblxuICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMubG9naW5Db250cm9sbGVyKSB7IHRoaXMubG9naW5Db250cm9sbGVyLmNsZWFudXAoKTsgfVxuICAgIHJlbW92ZVZpZXcodGhpcyk7XG4gIH0sXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBOYXZWaWV3O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxmb3JtIHJvbGU9XFxcImZvcm1cXFwiIGFjdGlvbj1cXFwiXFxcIiBpZD1cXFwiZW1haWwtZm9ybVxcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1ib2R5XFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiYWxlcnQgYWxlcnQtd2FybmluZ1xcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPjwvZGl2PlxcbiAgICA8ZmllbGRzZXQ+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJlbWFpbFxcXCI+RW1haWwgQWRkcmVzczwvbGFiZWw+XFxuICAgICAgICA8aW5wdXQgdHlwZT1cXFwiZW1haWxcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIGlkPVxcXCJlbWFpbFxcXCIgbmFtZT1cXFwiZW1haWxcXFwiIHBsYWNlaG9sZGVyPVxcXCJuYW1lQGRvbWFpbi5jb21cXFwiLz5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9maWVsZHNldD5cXG4gIDwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwibW9kYWwtZm9vdGVyXFxcIj5cXG4gICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWMwXFxcIiBkYXRhLWRpc21pc3M9XFxcIm1vZGFsXFxcIj5DYW5jZWw8L2J1dHRvbj5cXG4gICAgPGlucHV0IHR5cGU9XFxcInN1Ym1pdFxcXCIgY2xhc3M9XFxcImJ0biBidG4tYzJcXFwiIGlkPVxcXCJzdWJtaXRcXFwiIHZhbHVlPVxcXCJBZGQgRW1haWwgQWRkcmVzc1xcXCIvPlxcbiAgPC9kaXY+XFxuPC9mb3JtPlxcblwiO1xuIiwiXG52YXIgQm9vdHN0cmFwID0gcmVxdWlyZSgnYm9vdHN0cmFwJyk7XG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgRW1haWxGb3JtVGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvcHJvZmlsZV9lbWFpbF9mb3JtLmh0bWwnKTtcblxuXG52YXIgRW1haWxGb3JtVmlldyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcblxuICBldmVudHM6IHtcbiAgICBcInN1Ym1pdCAjZW1haWwtZm9ybVwiIDogXCJwb3N0XCJcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMudGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQ7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBfLnRlbXBsYXRlKEVtYWlsRm9ybVRlbXBsYXRlKSh7fSk7XG4gICAgdGhpcy4kZWwuaHRtbCh0ZW1wbGF0ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcG9zdDogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHZhciBkYXRhO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuJChcIi5hbGVydFwiKS5oaWRlKCk7XG4gICAgZGF0YSA9IHtcbiAgICAgIGVtYWlsOiAkKGUuY3VycmVudFRhcmdldCkuZmluZChcIiNlbWFpbFwiKS52YWwoKSxcbiAgICB9XG5cbiAgICAkLmFqYXgoe1xuICAgICAgdXJsOiAnL2FwaS91c2VyZW1haWwnLFxuICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgLy8gUGFzcyB0aGUgdGFnIGJhY2tcbiAgICAgICAgc2VsZi5vcHRpb25zLm1vZGVsLnRyaWdnZXIoc2VsZi50YXJnZXQgKyBcIjplbWFpbDpuZXdcIiwgcmVzdWx0KTtcbiAgICAgIH0sXG4gICAgICBlcnJvcjogZnVuY3Rpb24gKHJlcSwgc3RhdHVzLCBlcnJvcikge1xuICAgICAgICBzZWxmLiQoXCIuYWxlcnRcIikuaHRtbChyZXEucmVzcG9uc2VKU09OLm1lc3NhZ2UpO1xuICAgICAgICBzZWxmLiQoXCIuYWxlcnRcIikuc2hvdygpO1xuICAgICAgICBzZWxmLm9wdGlvbnMubW9kZWwudHJpZ2dlcihzZWxmLnRhcmdldCArIFwiOmVtYWlsOmVycm9yXCIsIHJlcS5yZXNwb25zZUpTT04pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gIH0sXG5cbiAgY2xlYW51cDogZnVuY3Rpb24gKCkge1xuICAgIHJlbW92ZVZpZXcodGhpcyk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRW1haWxGb3JtVmlldztcbiIsIlxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIEJhc2VDb250cm9sbGVyID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vYmFzZS9iYXNlX2NvbnRyb2xsZXInKTtcbnZhciBQcm9maWxlTW9kZWwgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9lbnRpdGllcy9wcm9maWxlcy9wcm9maWxlX21vZGVsJyk7XG52YXIgUHJvZmlsZVZpZXcgPSByZXF1aXJlKCcuLi92aWV3cy9wcm9maWxlX3Nob3dfdmlldycpO1xudmFyIFByb2ZpbGVTZXR0aW5nc1ZpZXcgPSByZXF1aXJlKCcuLi92aWV3cy9wcm9maWxlX3NldHRpbmdzX3ZpZXcnKTtcbnZhciBQcm9maWxlUmVzZXRWaWV3ID0gcmVxdWlyZSgnLi4vdmlld3MvcHJvZmlsZV9yZXNldF92aWV3Jyk7XG52YXIgTG9naW4gPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb25maWcvbG9naW4uanNvbicpO1xudmFyIEFsZXJ0VGVtcGxhdGUgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb21wb25lbnRzL2FsZXJ0X3RlbXBsYXRlLmh0bWwnKTtcblxuUHJvZmlsZSA9IEJhc2VDb250cm9sbGVyLmV4dGVuZCh7XG5cbiAgLy8gSGVyZSB3ZSBhcmUgZGVmaW5pbmcgd2V0aGVyIG9yIG5vdCB0aGlzIGlzIGEgZnVsbC1yZWdpb24gb2JqZWN0XG4gIC8vIG9yIGEgc3ViLXJlZ2lvbiBvZiBhbm90aGVyIHJlZ2lvbi5cbiAgcmVnaW9uOiB0cnVlLFxuICBzdWJSZWdpb246IGZhbHNlLFxuXG4gIGVsOiBcIiNjb250YWluZXJcIixcblxuICBldmVudHM6IHtcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5yb3V0ZUlkID0gb3B0aW9ucy5pZDtcbiAgICB0aGlzLmFjdGlvbiA9IG9wdGlvbnMuYWN0aW9uO1xuICAgIHRoaXMuZGF0YSA9IG9wdGlvbnMuZGF0YTtcbiAgICB0aGlzLmluaXRpYWxpemVDb250cm9sbGVyKCk7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZUNvbnRyb2xsZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBDbGVhbiB1cCBwcmV2aW91cyB2aWV3c1xuICAgIGlmICh0aGlzLnByb2ZpbGVWaWV3KSB7IHRoaXMucHJvZmlsZVZpZXcuY2xlYW51cCgpOyB9XG4gICAgaWYgKHRoaXMuc2V0dGluZ3NWaWV3KSB7IHRoaXMuc2V0dGluZ3NWaWV3LmNsZWFudXAoKTsgfVxuICAgIGlmICh0aGlzLnByb2ZpbGVSZXNldFZpZXcpIHsgdGhpcy5wcm9maWxlUmVzZXRWaWV3LmNsZWFudXAoKTsgfVxuICAgIC8vIElmIHRoZSBhY3Rpb24gZG9lcyBub3QgcmVxdWlyZSB0aGUgcHJvZmlsZSBtb2RlbCwgZGlzcGxheSB0aGF0IGFjdGlvblxuICAgIGlmICh0aGlzLnJvdXRlSWQgPT0gJ3Jlc2V0Jykge1xuICAgICAgdGhpcy5wcm9maWxlUmVzZXRWaWV3ID0gbmV3IFByb2ZpbGVSZXNldFZpZXcoe1xuICAgICAgICBlbDogdGhpcy4kZWwsXG4gICAgICAgIHJvdXRlSWQ6IHRoaXMucm91dGVJZCxcbiAgICAgICAgYWN0aW9uOiB0aGlzLmFjdGlvbixcbiAgICAgICAgZGF0YTogdGhpcy5kYXRhXG4gICAgICB9KS5yZW5kZXIoKTtcbiAgICB9XG4gICAgLy8gb3RoZXJ3aXNlIGxvYWQgdGhlIHByb2ZpbGUgbW9kZWwgYW5kIGRpc3BsYXkgdGhlIGFwcHJvcHJpYXRlIHZpZXdcbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZVByb2ZpbGVNb2RlbEluc3RhbmNlKCk7XG4gICAgfVxuICB9LFxuXG4gIGluaXRpYWxpemVQcm9maWxlTW9kZWxJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICh0aGlzLm1vZGVsKSB0aGlzLm1vZGVsLnJlbW92ZSgpO1xuICAgIHRoaXMubW9kZWwgPSBuZXcgUHJvZmlsZU1vZGVsKCk7XG5cbiAgICAvLyBwcmV2ZW50IGRpcmVjdGx5IGVkaXRpbmcgcHJvZmlsZXMgd2hlbiBkaXNhYmxlZFxuICAgIGlmICgoTG9naW4ucHJvZmlsZS5lZGl0ID09PSBmYWxzZSkgJiYgKHRoaXMuYWN0aW9uID09ICdlZGl0JykpIHtcbiAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICBhbGVydDoge1xuICAgICAgICAgIG1lc3NhZ2U6IFwiPHN0cm9uZz5EaXJlY3QgZWRpdGluZyBvZiBwcm9maWxlcyBpcyBkaXNhYmxlZC48L3N0cm9uZz4gIDxhIGhyZWY9XFxcIlwiICsgTG9naW4ucHJvZmlsZS5lZGl0VXJsICsgXCJcXFwiIHRpdGxlPVxcXCJFZGl0IFByb2ZpbGVcXFwiPkNsaWNrIGhlcmUgdG8gZWRpdCB5b3VyIHByb2ZpbGU8L2E+XCJcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciB0ZW1wbGF0ZSA9IF8udGVtcGxhdGUoQWxlcnRUZW1wbGF0ZSkoZGF0YSlcbiAgICAgIHRoaXMuJGVsLmh0bWwodGVtcGxhdGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyB2YXIgZmV0Y2hJZCA9IG51bGw7XG4gICAgLy8gaWYgKHRoaXMuaWQgJiYgdGhpcy5pZCAhPSAnZWRpdCcpIHsgZmV0Y2hJZCA9IHRoaXMuaWQ7IH1cbiAgICB0aGlzLm1vZGVsLnRyaWdnZXIoXCJwcm9maWxlOmZldGNoXCIsIHRoaXMucm91dGVJZCk7XG4gICAgLy8gcHJvY2VzcyBhIHN1Y2Nlc3NmdWwgbW9kZWwgZmV0Y2gsIGFuZCBkaXNwbGF5IHRoZSBtb2RlbFxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbCwgXCJwcm9maWxlOmZldGNoOnN1Y2Nlc3NcIiwgZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAvLyBAaW5zdGFuY2VcbiAgICAgIHNlbGYubW9kZWwgPSBtb2RlbDtcbiAgICAgIHZhciBtb2RlbEpzb24gPSBtb2RlbC50b0pTT04oKTtcbiAgICAgIGZvciAoaSBpbiBtb2RlbEpzb24udGFncykge1xuICAgICAgICBpZiAobW9kZWxKc29uLnRhZ3NbaV0udGFnLnR5cGUgPT0gJ2FnZW5jeScpIHtcbiAgICAgICAgICBzZWxmLm1vZGVsLmFnZW5jeSA9IG1vZGVsSnNvbi50YWdzW2ldLnRhZztcbiAgICAgICAgICBzZWxmLm1vZGVsLmFnZW5jeVsndGFnSWQnXSA9IG1vZGVsSnNvbi50YWdzW2ldLmlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1vZGVsSnNvbi50YWdzW2ldLnRhZy50eXBlID09ICdsb2NhdGlvbicpIHtcbiAgICAgICAgICBzZWxmLm1vZGVsLmxvY2F0aW9uID0gbW9kZWxKc29uLnRhZ3NbaV0udGFnO1xuICAgICAgICAgIHNlbGYubW9kZWwubG9jYXRpb25bJ3RhZ0lkJ10gPSBtb2RlbEpzb24udGFnc1tpXS5pZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2VsZi5pbml0aWFsaXplUHJvZmlsZVZpZXdJbnN0YW5jZSgpO1xuICAgIH0pO1xuICAgIC8vIGlmIHRoZSBwcm9maWxlIGZldGNoIGZhaWxzLCBjaGVjayBpZiBpdCBpcyBkdWUgdG8gdGhlIHVzZXJcbiAgICAvLyBub3QgYmVpbmcgbG9nZ2VkIGluXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCBcInByb2ZpbGU6ZmV0Y2g6ZXJyb3JcIiwgZnVuY3Rpb24gKG1vZGVsLCByZXNwb25zZSkge1xuICAgICAgLy8gaWYgdGhlIHVzZXIgaXNuJ3QgbG9nZ2VkIGluLCB0cmlnZ2VyIHRoZSBsb2dpbiB3aW5kb3dcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMykge1xuICAgICAgICB3aW5kb3cuY2FjaGUudXNlckV2ZW50cy50cmlnZ2VyKFwidXNlcjpyZXF1ZXN0OmxvZ2luXCIsIHtcbiAgICAgICAgICBtZXNzYWdlOiBcIllvdSBtdXN0IGJlIGxvZ2dlZCBpbiB0byB2aWV3IHByb2ZpbGVzXCIsXG4gICAgICAgICAgZGlzYWJsZUNsb3NlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICBhbGVydDoge1xuICAgICAgICAgIG1lc3NhZ2U6IFwiPHN0cm9uZz5VbmFibGUgdG8gbG9hZCBwcm9maWxlLiAgUGxlYXNlIHJlbG9hZCB0aGlzIHBhZ2UgdG8gdHJ5IGFnYWluLjwvc3Ryb25nPjxici8+RXJyb3I6IFwiXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICAvLyBjaGVjayBpZiB0aGUgcmVzcG9uc2UgcHJvdmlkZWQgYW4gZXJyb3JcbiAgICAgIGlmIChyZXNwb25zZS5yZXNwb25zZVRleHQpIHtcbiAgICAgICAgdmFyIGVyciA9IEpTT04ucGFyc2UocmVzcG9uc2UucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgaWYgKGVyci5tZXNzYWdlKSB7XG4gICAgICAgICAgZGF0YS5hbGVydC5tZXNzYWdlICs9IGVyci5tZXNzYWdlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgdGVtcGxhdGUgPSBfLnRlbXBsYXRlKEFsZXJ0VGVtcGxhdGUpKGRhdGEpXG4gICAgICBzZWxmLiRlbC5odG1sKHRlbXBsYXRlKTtcbiAgICB9KTtcbiAgfSxcblxuICBpbml0aWFsaXplUHJvZmlsZVZpZXdJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmFjdGlvbiA9PSAnc2V0dGluZ3MnKSB7XG4gICAgICB0aGlzLnNldHRpbmdzVmlldyA9IG5ldyBQcm9maWxlU2V0dGluZ3NWaWV3KHtcbiAgICAgICAgZWw6IHRoaXMuJGVsLFxuICAgICAgICBtb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgICAgcm91dGVJZDogdGhpcy5yb3V0ZUlkLFxuICAgICAgICBhY3Rpb246IHRoaXMuYWN0aW9uLFxuICAgICAgICBkYXRhOiB0aGlzLmRhdGFcbiAgICAgIH0pLnJlbmRlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByb2ZpbGVWaWV3ID0gbmV3IFByb2ZpbGVWaWV3KHtcbiAgICAgICAgZWw6IHRoaXMuJGVsLFxuICAgICAgICBtb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgICAgcm91dGVJZDogdGhpcy5yb3V0ZUlkLFxuICAgICAgICBhY3Rpb246IHRoaXMuYWN0aW9uLFxuICAgICAgICBkYXRhOiB0aGlzLmRhdGFcbiAgICAgIH0pLnJlbmRlcigpO1xuICAgIH1cbiAgfSxcblxuICBjbGVhbnVwOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5wcm9maWxlVmlldykgeyB0aGlzLnByb2ZpbGVWaWV3LmNsZWFudXAoKTsgfVxuICAgIGlmICh0aGlzLnNldHRpbmdzVmlldykgeyB0aGlzLnNldHRpbmdzVmlldy5jbGVhbnVwKCk7IH1cbiAgICByZW1vdmVWaWV3KHRoaXMpO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb2ZpbGU7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHVsIGNsYXNzPVxcXCJuYXYgbmF2LXRhYnNcXFwiPlxcbiAgPGxpIGNsYXNzPVxcXCJhY3RpdmVcXFwiPjxhIGhyZWY9XFxcIiM8JT0gaGFuZGxlICU+LXRhYi1vcGVuXFxcIiBkYXRhLXRvZ2dsZT1cXFwidGFiXFxcIj5PcGVuPC9hPjwvbGk+XFxuICA8bGk+PGEgaHJlZj1cXFwiIzwlPSBoYW5kbGUgJT4tdGFiLWNsb3NlZFxcXCIgZGF0YS10b2dnbGU9XFxcInRhYlxcXCI+Q2xvc2VkPC9hPjwvbGk+XFxuPC91bD5cXG5cXG48ZGl2IGNsYXNzPVxcXCJ0YWItY29udGVudFxcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJ0YWItcGFuZSBhY3RpdmVcXFwiIGlkPVxcXCI8JT0gaGFuZGxlICU+LXRhYi1vcGVuXFxcIj5cXG4gICAgPHRhYmxlIGNsYXNzPVxcXCJ0YWJsZSB0YWJsZS1jb25kZW5zZWQgdGFibGUtaG92ZXJcXFwiPlxcbiAgICAgIDwlIGlmICggY291bnQub3BlbiA+IDAgfHwgY291bnQuYXNzaWduZWQgPiAwIHx8IGNvdW50LmRyYWZ0ID4gMCkgeyAlPlxcbiAgICAgICAgPHRoZWFkPlxcbiAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgPHRoIGRhdGEtaTE4bj1cXFwiPCU9IHRhcmdldENhcGl0YWxpemVkICU+XFxcIj5Qcm9qZWN0PC90aD5cXG4gICAgICAgICAgICA8dGg+Q3JlYXRlZDwvdGg+XFxuICAgICAgICAgICAgPHRoPkxpa2VzPC90aD5cXG4gICAgICAgICAgPC90cj5cXG4gICAgICAgIDwvdGhlYWQ+XFxuICAgICAgICA8dGJvZHk+XFxuICAgICAgICA8JSBmb3IgKHZhciBpIGluIGRhdGEpIHsgJT5cXG4gICAgICAgICAgPCUgaWYgKGRhdGFbaV0uc3RhdGUgPT0gJ2NvbXBsZXRlZCcgfHwgZGF0YVtpXS5zdGF0ZSA9PSAnYXJjaGl2ZWQnKSB7IGNvbnRpbnVlOyB9ICU+XFxuICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICA8dGQ+XFxuICAgICAgICAgICAgICA8JSBpZiAoZGF0YVtpXS5zdGF0ZSA9PSAnZHJhZnQnKSB7ICU+XFxuICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwibGFiZWwgbGFiZWwtd2FybmluZ1xcXCI+ZHJhZnQ8L3NwYW4+XFxuICAgICAgICAgICAgICA8JSB9ICU+XFxuICAgICAgICAgICAgICA8YSBocmVmPVxcXCI8JT0gdGFyZ2V0ICU+cy88JT0gZGF0YVtpXS5pZCAlPlxcXCIgY2xhc3M9XFxcImFjdGl2aXR5LWxpbmtcXFwiIGRhdGEtaWQ9XFxcIjwlPSBkYXRhW2ldLmlkICU+XFxcIj48JT0gZGF0YVtpXS50aXRsZSAlPjwvYT5cXG4gICAgICAgICAgICA8L3RkPlxcbiAgICAgICAgICAgIDx0ZD5cXG4gICAgICAgICAgICAgIDwlIHZhciBjcmVhdGVkID0gbmV3IERhdGUoZGF0YVtpXS5jcmVhdGVkQXQpOyAlPlxcbiAgICAgICAgICAgICAgPCU9IGNyZWF0ZWQudG9Mb2NhbGVEYXRlU3RyaW5nKCkgJT4gPCU9IGNyZWF0ZWQudG9Mb2NhbGVUaW1lU3RyaW5nKCkgJT48L3RkPlxcbiAgICAgICAgICAgIDx0ZD48JT0gZGF0YVtpXS5saWtlQ291bnQgJT48L3RkPlxcbiAgICAgICAgICA8L3RyPlxcbiAgICAgICAgPCUgfSAlPlxcbiAgICAgICAgPC90Ym9keT5cXG4gICAgICA8JSB9IGVsc2UgeyAlPlxcbiAgICAgICAgPHRib2R5PlxcbiAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgPHRkPk5vIDwlPSB0YXJnZXRzRnJpZW5kbHkgJT48L3RkPlxcbiAgICAgICAgICA8L3RyPlxcbiAgICAgICAgPC90Ym9keT5cXG4gICAgICA8JSB9ICU+XFxuICAgIDwvdGFibGU+XFxuICA8L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcInRhYi1wYW5lXFxcIiBpZD1cXFwiPCU9IGhhbmRsZSAlPi10YWItY2xvc2VkXFxcIj5cXG4gICAgPHRhYmxlIGNsYXNzPVxcXCJ0YWJsZSB0YWJsZS1jb25kZW5zZWQgdGFibGUtaG92ZXJcXFwiPlxcbiAgICAgIDwlIGlmIChjb3VudC5jb21wbGV0ZWQgPiAwIHx8IGNvdW50LmFyY2hpdmVkID4gMCkgeyAlPlxcbiAgICAgICAgPHRoZWFkPlxcbiAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgPHRoIGRhdGEtaTE4bj1cXFwiPCU9IHRhcmdldENhcGl0YWxpemVkICU+XFxcIj5Qcm9qZWN0PC90aD5cXG4gICAgICAgICAgICA8dGg+Q3JlYXRlZDwvdGg+XFxuICAgICAgICAgICAgPHRoPkxpa2VzPC90aD5cXG4gICAgICAgICAgPC90cj5cXG4gICAgICAgIDwvdGhlYWQ+XFxuICAgICAgICA8dGJvZHk+XFxuICAgICAgICA8JSBmb3IgKHZhciBpIGluIGRhdGEpIHsgJT5cXG4gICAgICAgICAgPCUgaWYgKGRhdGFbaV0uc3RhdGUgIT09ICdjb21wbGV0ZWQnICYmIGRhdGFbaV0uc3RhdGUgIT09ICdhcmNoaXZlZCcpIHsgY29udGludWU7IH0gJT5cXG4gICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgIDx0ZD5cXG4gICAgICAgICAgICAgIDxhIGhyZWY9XFxcIjwlPSB0YXJnZXQgJT5zLzwlPSBkYXRhW2ldLmlkICU+XFxcIiBjbGFzcz1cXFwiYWN0aXZpdHktbGlua1xcXCIgZGF0YS1pZD1cXFwiPCU9IGRhdGFbaV0uaWQgJT5cXFwiPjwlPSBkYXRhW2ldLnRpdGxlICU+PC9hPlxcbiAgICAgICAgICAgIDwvdGQ+XFxuICAgICAgICAgICAgPHRkPjwlPSBkYXRhW2ldLmNyZWF0ZWRBdCAlPjwvdGQ+XFxuICAgICAgICAgICAgPHRkPjwlPSBkYXRhW2ldLmxpa2VDb3VudCAlPjwvdGQ+XFxuICAgICAgICAgIDwvdHI+XFxuICAgICAgICA8JSB9ICU+XFxuICAgICAgICA8L3Rib2R5PlxcbiAgICAgIDwlIH0gZWxzZSB7ICU+XFxuICAgICAgICA8dGJvZHk+XFxuICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICA8dGQ+Tm8gPCU9IHRhcmdldHNGcmllbmRseSAlPjwvdGQ+XFxuICAgICAgICAgIDwvdHI+XFxuICAgICAgICA8L3Rib2R5PlxcbiAgICAgIDwlIH0gJT5cXG4gICAgPC90YWJsZT5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcInJhZGlvXFxcIj5cXG4gIDxsYWJlbD5cXG4gICAgPGlucHV0IHR5cGU9XFxcInJhZGlvXFxcIiBuYW1lPVxcXCJwcmltYXJ5RW1haWxcXFwiIGlkPVxcXCJlbWFpbC08JS0gZW1haWwuaWQgJT5cXFwiIHZhbHVlPVxcXCI8JS0gZW1haWwuZW1haWwgJT5cXFwiIDwlIGlmIChlbWFpbC5pc1ByaW1hcnkpIHsgJT5jaGVja2VkPCUgfSAlPj5cXG4gICAgPGEgaHJlZj1cXFwiI1xcXCIgY2xhc3M9XFxcImVtYWlsLXJlbW92ZVxcXCIgaWQ9XFxcImVtYWlsLXJlbW92ZS08JS0gZW1haWwuaWQgJT5cXFwiIGRhdGEtaWQ9XFxcIjwlLSBlbWFpbC5pZCAlPlxcXCI+PHNwYW4gY2xhc3M9XFxcImZhIGZhLXRyYXNoXFxcIj48L3NwYW4+PC9hPiA8JS0gZW1haWwuZW1haWwgJT5cXG4gIDwvbGFiZWw+XFxuPC9kaXY+XFxuXCI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG5cXG4gIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC02IGNvbC1tZC1vZmZzZXQtMyBib3hcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImJveC1tYWluXFxcIj5cXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInByb2ZpbGUtcmVzZXQgY2VudGVyXFxcIiBpZD1cXFwicHJvZmlsZS1yZXNldC1jaGVja1xcXCI+XFxuICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1zcGluIGZhLXNwaW5uZXJcXFwiPjwvaT4gTG9va2luZyB1cCBwYXNzd29yZCByZXNldCBjb2RlLi4uXFxuICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInByb2ZpbGUtcmVzZXQgZXJyb3JcXFwiIGlkPVxcXCJwcm9maWxlLXJlc2V0LWNoZWNrLWVycm9yXFxcIiBzdHlsZT1cXFwiZGlzcGxheTogbm9uZTtcXFwiPlxcbiAgICAgICAgICBUaGlzIGlzIG5vdCBhIHZhbGlkIHBhc3N3b3JkIHJlc2V0IGNvZGUuICBQbGVhc2UgdHJ5IHJlc2V0dGluZyB5b3VyIHBhc3N3b3JkIGFnYWluIGFuZCBjbGlja2luZyBvbiB0aGUgbGluayBpbiB0aGUgZW1haWwuXFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInByb2ZpbGUtcmVzZXQgZXJyb3JcXFwiIGlkPVxcXCJwcm9maWxlLXJlc2V0LXN1Ym1pdC1lcnJvclxcXCIgc3R5bGU9XFxcImRpc3BsYXk6IG5vbmU7XFxcIj5cXG4gICAgICAgICAgQW4gZXJyb3Igb2NjdXJyZWQgcmVzZXR0aW5nIHlvdXIgcGFzc3dvcmQuICBQbGVhc2UgcmVsb2FkIHRoaXMgcGFnZSBhbmQgdHJ5IGFnYWluLlxcbiAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwcm9maWxlLXJlc2V0XFxcIiBpZD1cXFwicHJvZmlsZS1yZXNldC1kaWFsb2dcXFwiIHN0eWxlPVxcXCJkaXNwbGF5OiBub25lO1xcXCI+XFxuICAgICAgICAgIDxmb3JtIGlkPVxcXCJmb3JtLXBhc3N3b3JkLXJlc2V0XFxcIiB0aXRsZT1cXFwiUGFzc3dvcmQgUmVzZXRcXFwiPlxcbiAgICAgICAgICAgIDxoMT5cXG4gICAgICAgICAgICAgIFBsZWFzZSBzZXQgYSBuZXcgcGFzc3dvcmQgZm9yIHlvdXIgYWNjb3VudC5cXG4gICAgICAgICAgICA8L2gxPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInBhc3N3b3JkLXZpZXdcXFwiPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXY+XFxuICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwic3VibWl0XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1jMVxcXCIgdmFsdWU9XFxcIlJlc2V0IFBhc3N3b3JkXFxcIi8+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDwvZm9ybT5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwicHJvZmlsZS1yZXNldCBjZW50ZXJcXFwiIGlkPVxcXCJwcm9maWxlLXJlc2V0LXN1Ym1pdFxcXCIgc3R5bGU9XFxcImRpc3BsYXk6IG5vbmU7XFxcIj5cXG4gICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLXNwaW4gZmEtc3Bpbm5lclxcXCI+PC9pPiBQZXJmb3JtaW5nIHBhc3N3b3JkIHJlc2V0LiAgUGxlYXNlIHN0YW5kIGJ5Li4uXFxuICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG5cXG48L2Rpdj5cXG5cIjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcblxcbiAgPGRpdiBjbGFzcz1cXFwiYWxlcnQgYWxlcnQtaW5mb1xcXCI+XFxuICAgIFByb2ZpbGUgc2V0dGluZ3MgYXJlIG5vdCB5ZXQgaW1wbGVtZW50ZWQuICBQbGVhc2UgY29udGFjdCB0aGUgYWRtaW5pc3RyYXRvciBvZiB0aGlzIHN5c3RlbSB0byB1cGRhdGUgeW91ciBlbWFpbCBzZXR0aW5ncy4gIE91ciBhcG9sb2dpZXMsIHN0YXkgdHVuZWQhXFxuICA8L2Rpdj5cXG5cXG48L2Rpdj5cXG5cIjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcblxcbiAgPCUgaWYgKHVzZXIuaXNBZG1pbikgeyAlPlxcbiAgPGRpdiBjbGFzcz1cXFwiYWxlcnQgYWxlcnQtaW5mb1xcXCI+XFxuICAgIFlvdSBhcmUgYW4gYWRtaW5pc3RyYXRvci5cXG4gICAgPCUgaWYgKHVzZXIuaWQgIT09IGRhdGEuaWQpIHsgJT5cXG4gICAgICA8JSBpZiAoZWRpdCA9PT0gdHJ1ZSkgeyAlPlxcbiAgICAgICAgPHN0cm9uZz5Zb3UgYXJlIGVkaXRpbmcgYW5vdGhlciB1c2VyJ3MgcHJvZmlsZS48L3N0cm9uZz5cXG4gICAgICA8JSB9IGVsc2UgeyAlPlxcbiAgICAgICAgWW91IGFyZSB2aWV3aW5nIGFub3RoZXIgdXNlcidzIHByb2ZpbGUuXFxuICAgICAgPCUgfSAlPlxcbiAgICA8JSB9ICU+XFxuICA8L2Rpdj5cXG4gIDwlIH0gJT5cXG5cXG4gIDwlIGlmIChzYXZlZCkgeyAlPlxcbiAgPGRpdiBjbGFzcz1cXFwiYWxlcnQgYWxlcnQtc3VjY2Vzc1xcXCI+WW91ciBwcm9maWxlIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSB1cGRhdGVkLjwvZGl2PlxcbiAgPCUgfSAlPlxcblxcbiAgPGRpdiBjbGFzcz1cXFwiY29sLXNtLTMgY29sLW1kLTQgcHJvamVjdC1zaWRlYmFyXFxcIj5cXG4gICAgPCEtLSBMRUZUIFNJREVCQVIgLS0+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTEyIGJveCBwcm9qZWN0LWhlYWRlci13cmFwcGVyXFxcIj5cXG4gICAgICAgIDxkaXYgaWQ9XFxcInByb2plY3QtaGVhZGVyXFxcIiBzdHlsZT1cXFwiYmFja2dyb3VuZC1pbWFnZTp1cmwoJy9hcGkvdXNlci9waG90by88JS0gZGF0YS5pZCAlPicpO1xcXCI+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImJ0biBidG4tYzIgZmlsZWlucHV0LWJ1dHRvblxcXCIgPCUgaWYgKCEoKGRhdGEuaXNPd25lciB8fCB1c2VyLmlzQWRtaW4pICYmIGVkaXQpKSB7ICU+c3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPCUgfSAlPj5cXG4gICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtY2FtZXJhIGZhLWxnXFxcIiB0aXRsZT1cXFwiQ2hhbmdlIENvdmVyIFBob3RvXFxcIiBpZD1cXFwiZmlsZXVwbG9hZC1pY29uXFxcIj48L2k+XFxuICAgICAgICAgICAgPGlucHV0IGlkPVxcXCJmaWxldXBsb2FkXFxcIiB0eXBlPVxcXCJmaWxlXFxcIiBuYW1lPVxcXCJmaWxlc1tdXFxcIiB0aXRsZT1cXFwiVXBsb2FkIFBob3RvXFxcIj5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgaWQ9XFxcImZpbGUtdXBsb2FkLXByb2dyZXNzLWNvbnRhaW5lclxcXCIgc3R5bGU9XFxcImRpc3BsYXk6IG5vbmU7XFxcIiBjbGFzcz1cXFwicHJvZ3Jlc3MgcHJvZ3Jlc3Mtc3RyaXBlZCBhY3RpdmVcXFwiPlxcbiAgICAgICAgICA8ZGl2IGlkPVxcXCJmaWxlLXVwbG9hZC1wcm9ncmVzc1xcXCIgY2xhc3M9XFxcInByb2dyZXNzLWJhclxcXCIgc3R5bGU9XFxcIndpZHRoOiAwXFxcIj48L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBpZD1cXFwiZmlsZS11cGxvYWQtYWxlcnRcXFwiIGNsYXNzPVxcXCJhbGVydCBhbGVydC13YXJuaW5nXFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTEyIGJveFxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJib3gtbWFpbiB0YWctd3JhcHBlclxcXCI+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG5cXG4gIDxkaXYgY2xhc3M9XFxcImNvbC1zbS05IGNvbC1tZC04XFxcIj5cXG4gICAgPCEtLSBSSUdIVCBNQUlOIEJBUiAtLT5cXG4gICAgPCUgaWYgKGVkaXQpIHsgJT4gPCEtLSBpbiBlZGl0IG1vZGUgLS0+XFxuICAgIDxkaXYgY2xhc3M9XFxcImJveCBib3gtbWFpblxcXCI+XFxuICAgICAgPGRpdiBpZD1cXFwiZW1haWxNb2RhbFxcXCI+PC9kaXY+XFxuXFxuICAgICAgPGZvcm0gY2xhc3M9XFxcImZvcm0taG9yaXpvbnRhbFxcXCIgcm9sZT1cXFwiZm9ybVxcXCIgaWQ9XFxcInByb2ZpbGUtZm9ybVxcXCI+XFxuICAgICAgICA8aDE+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sIGlucHV0LWxnXFxcIiBpZD1cXFwibmFtZVxcXCIgbmFtZT1cXFwibmFtZVxcXCIgcGxhY2Vob2xkZXI9XFxcIllvdXIgRnVsbCBOYW1lXFxcIiB2YWx1ZT1cXFwiPCUgaWYgKGRhdGEubmFtZSkgeyAlPjwlLSBkYXRhLm5hbWUgJT48JSB9ICU+XFxcIiB0aXRsZT1cXFwiWW91ciBGdWxsIE5hbWVcXFwiLz5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2gxPlxcblxcbiAgICAgICAgPGgyPiBCaW8gPC9oMj5cXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJ0aXRsZVxcXCIgY2xhc3M9XFxcImNvbC1tZC0zIGNvbnRyb2wtbGFiZWxcXFwiPlRpdGxlPC9sYWJlbD5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTlcXFwiPlxcbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiBpZD1cXFwidGl0bGVcXFwiIG5hbWU9XFxcInRpdGxlXFxcIiBwbGFjZWhvbGRlcj1cXFwiVGl0bGVcXFwiIHZhbHVlPVxcXCI8JSBpZiAoZGF0YS50aXRsZSkgeyAlPjwlLSBkYXRhLnRpdGxlICU+PCUgfSAlPlxcXCIvPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuICAgICAgICAgIDxsYWJlbCBmb3I9XFxcImNvbXBhbnlcXFwiIGNsYXNzPVxcXCJjb2wtbWQtMyBjb250cm9sLWxhYmVsXFxcIj5BZ2VuY3k8L2xhYmVsPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtOVxcXCI+XFxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcImhpZGRlblxcXCIgaWQ9XFxcImNvbXBhbnlcXFwiIG5hbWU9XFxcImNvbXBhbnlcXFwiIHN0eWxlPVxcXCJ3aWR0aDogMTAwJVxcXCIvPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuICAgICAgICAgIDxsYWJlbCBmb3I9XFxcImxvY2F0aW9uXFxcIiBjbGFzcz1cXFwiY29sLW1kLTMgY29udHJvbC1sYWJlbFxcXCI+TG9jYXRpb248L2xhYmVsPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtOVxcXCI+XFxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcImhpZGRlblxcXCIgaWQ9XFxcImxvY2F0aW9uXFxcIiBuYW1lPVxcXCJsb2NhdGlvblxcXCIgc3R5bGU9XFxcIndpZHRoOiAxMDAlXFxcIi8+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgICAgPGxhYmVsIGZvcj1cXFwiYmlvXFxcIiBjbGFzcz1cXFwiY29sLW1kLTMgY29udHJvbC1sYWJlbFxcXCI+QSBicmllZiBwdWJsaWMgYmlvZ3JhcGh5PC9sYWJlbD5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTlcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm1hcmtkb3duLWVkaXRcXFwiPjwvZGl2PlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgPGgyPiBBY2NvdW50IEluZm9ybWF0aW9uIDwvaDI+XFxuXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgICAgPGxhYmVsIGZvcj1cXFwicHJvZmlsZS1lbWFpbFxcXCIgY2xhc3M9XFxcImNvbC1tZC0zIGNvbnRyb2wtbGFiZWxcXFwiPkVtYWlsPC9sYWJlbD5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTlcXFwiPlxcbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiBpZD1cXFwicHJvZmlsZS1lbWFpbFxcXCIgbmFtZT1cXFwiZW1haWxcXFwiXFxuICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cXFwiRW1haWxcXFwiIHZhbHVlPVxcXCI8JSBpZiAoZW1haWwpIHsgJT48JS0gZW1haWwuZW1haWwgJT48JSB9ICU+XFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGlkPVxcXCJlbWFpbC11cGRhdGUtYWxlcnRcXFwiIGNsYXNzPVxcXCJhbGVydCBhbGVydC13YXJuaW5nXFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI+PC9kaXY+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgICAgPCUgaWYgKGxvZ2luLm9hdXRoLmxlbmd0aCA+IDApIHsgJT5cXG4gICAgICAgICAgPGxhYmVsIGZvcj1cXFwic2VydmljZXNcXFwiIGNsYXNzPVxcXCJjb2wtbWQtMyBjb250cm9sLWxhYmVsXFxcIj5Db25uZWN0ZWQgQWNjb3VudHM8L2xhYmVsPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtOVxcXCIgaWQ9XFxcInNlcnZpY2VzXFxcIj5cXG4gICAgICAgICAgICA8Zm9ybSBjbGFzcz1cXFwiZm9ybS1ob3Jpem9udGFsXFxcIiByb2xlPVxcXCJmb3JtXFxcIj5cXG4gICAgICAgICAgICA8JSBfLmVhY2gobG9naW4ub2F1dGgsIGZ1bmN0aW9uIChhKSB7ICU+XFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLXhzLTggY29sLXNtLTkgY29sLW1kLTlcXFwiPlxcbiAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPVxcXCI8JT0gbG9naW4uY29uZmlnW2FdLmltYWdlICU+XFxcIiBhbHQ9XFxcIjwlPSBsb2dpbi5jb25maWdbYV0ubmFtZSAlPlxcXCIgc3R5bGU9XFxcImhlaWdodDogMzBweFxcXCIvPlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLXhzLTQgY29sLXNtLTMgY29sLW1kLTNcXFwiPlxcbiAgICAgICAgICAgICAgICAgIDwlIGlmIChfLmNvbnRhaW5zKGRhdGEuYXV0aHMsIGEpKSB7ICU+XFxuICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgY2xhc3M9XFxcImJ0biBidG4tZGFuZ2VyIGJ0bi1zbSByZW1vdmVBdXRoIHB1bGwtcmlnaHRcXFwiIGRhdGEtc2VydmljZT1cXFwiPCU9IGEgJT5cXFwiPjxzcGFuIGNsYXNzPVxcXCJmYSBmYS1yZW1vdmVcXFwiPjwvc3Bhbj4gRGlzY29ubmVjdDwvYT5cXG4gICAgICAgICAgICAgICAgICA8JSB9IGVsc2UgeyAlPlxcbiAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIjwlPSBsb2dpbi5jb25maWdbYV0uZW5kcG9pbnQgJT5cXFwiIGNsYXNzPVxcXCJidG4gYnRuLXN1Y2Nlc3MgYnRuLXNtIHB1bGwtcmlnaHRcXFwiPjxzcGFuIGNsYXNzPVxcXCJmYSBmYS1wbHVzXFxcIj48L3NwYW4+IENvbm5lY3Q8L2E+XFxuICAgICAgICAgICAgICAgICAgPCUgfSAlPlxcbiAgICAgICAgICAgICAgICAgIDwhLS0gPCU9IGxvZ2luLmNvbmZpZ1thXS5uYW1lICU+IC0tPlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwlIH0pOyAlPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPCUgfSAlPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLW9mZnNldC0zIGNvbC1tZC05XFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwdWxsLXJpZ2h0XFxcIj5cXG4gICAgICAgICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWMwXFxcIiBpZD1cXFwicHJvZmlsZS1jYW5jZWxcXFwiPkRpc2NhcmQgQ2hhbmdlczwvYT5cXG5cXG4gICAgICAgICAgICAgIDxidXR0b24gaWQ9XFxcInN1Ym1pdFxcXCIgdHlwZT1cXFwic3VibWl0XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1jMlxcXCIgZGlzYWJsZWQ9XFxcImRpc2FibGVkXFxcIiBkYXRhLWxvYWRpbmctdGV4dD1cXFwiPGkgY2xhc3M9J2ZhIGZhLXNwaW5uZXIgZmEtc3Bpbic+PC9pPiBTYXZpbmcuLi5cXFwiIGRhdGEtc3VjY2Vzcy10ZXh0PVxcXCJTYXZlZCFcXFwiIGRhdGEtZmFpbC10ZXh0PVxcXCJTYXZlIEZhaWxlZC5cXFwiPlNhdmUgUHJvZmlsZTwvYnV0dG9uPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcblxcbiAgICAgIDwvZm9ybT5cXG4gICAgPC9kaXY+XFxuICAgIDwlIH0gZWxzZSB7ICU+IDwhLS0gbm90IGluIGVkaXQgbW9kZSAtLT5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtOSBzbS1ub3BhZGRpbmcgbWQtbm9wYWRkaW5nXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImJveCBib3gtbWFpblxcXCI+XFxuICAgICAgICAgIDxoMT48JSBpZiAoZGF0YS5uYW1lKSB7ICU+PCUtIGRhdGEubmFtZSAlPjwlIH0gZWxzZSB7ICU+PCUtIGRhdGEudXNlcm5hbWUgJT48JSB9ICU+PC9oMT5cXG5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwicHJvZmlsZS1qb2J0aXRsZVxcXCI+PCUgaWYgKGRhdGEudGl0bGUpIHsgJT48aSBjbGFzcz1cXFwiZmEgZmEtYnJpZWZjYXNlXFxcIj48L2k+IDxzcGFuIGNsYXNzPVxcXCJib3gtaWNvbi10ZXh0XFxcIj48JS0gZGF0YS50aXRsZSAlPjwvc3Bhbj48JSB9ICU+PC9kaXY+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInByb2ZpbGUtY29tcGFueVxcXCI+PCUgaWYgKGRhdGEuYWdlbmN5KSB7ICU+PGkgY2xhc3M9XFxcImljb24tbGlicmFyeVxcXCI+PC9pPiA8c3BhbiBjbGFzcz1cXFwiYm94LWljb24tdGV4dFxcXCI+PCUtIGRhdGEuYWdlbmN5LnRhZy5uYW1lICU+PC9zcGFuPjwlIH0gJT48L2Rpdj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwicHJvZmlsZS1sb2NhdGlvblxcXCI+PCUgaWYgKGRhdGEubG9jYXRpb24pIHsgJT48c3BhbiBjbGFzcz1cXFwiZmEgZmEtbWFwLW1hcmtlclxcXCI+PC9zcGFuPiA8c3BhbiBjbGFzcz1cXFwiYm94LWljb24tdGV4dFxcXCI+PCUtIGRhdGEubG9jYXRpb24udGFnLm5hbWUgJT48L3NwYW4+PCUgfSAlPjwvZGl2PlxcblxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwcm9maWxlLWJpbyBib3gtcGFkLXRcXFwiPlxcbiAgICAgICAgICAgIDwlIGlmIChkYXRhLmJpb0h0bWwpIHsgJT48JT0gZGF0YS5iaW9IdG1sICU+PCUgfSBlbHNlIHsgJT5UaGlzIHBlcnNvbiBkb2Vzbid0IGhhdmUgYSBiaW8geWV0LjwlIH0gJT5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMyBzbS1ub3BhZGRpbmcgbWQtbm9wYWRkaW5nIHBhZGRpbmctbGVmdC1ub25lXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImJveCBwYWRkaW5nLW5vbmVcXFwiPlxcbjwhLS1cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwibmF2YmFyLXNpZGUgbGlrZS1yb3cgYm9yZGVyLWJvdHRvbVxcXCI+XFxuICAgICAgICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgaWQ9XFxcImxpa2UtYnV0dG9uXFxcIiBjbGFzcz1cXFwibGlrZS1idXR0b25cXFwiPlxcbiAgICAgICAgICAgICAgPGkgaWQ9XFxcImxpa2UtYnV0dG9uLWljb25cXFwiIGNsYXNzPVxcXCJmYSBmYS1zdGFyLW8gZmEtbGcgZ29sZFxcXCI+PC9pPlxcbiAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwibGlrZS1udW1iZXJcXFwiIGlkPVxcXCJsaWtlLW51bWJlclxcXCI+PCUtIGRhdGEubGlrZUNvdW50ICU+PC9zcGFuPlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJsaWtlLXBsdXJhbFxcXCIgaWQ9XFxcImxpa2UtdGV4dFxcXCIgZGF0YS1wbHVyYWw9XFxcImZvbGxvd2Vyc1xcXCIgZGF0YS1zaW5ndWxhcj1cXFwiZm9sbG93ZXJcXFwiPmZvbGxvd2Vyczwvc3Bhbj5cXG4gICAgICAgICAgPC9kaXY+XFxuLS0+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm5hdmJhci1zaWRlIDwlIGlmIChkYXRhLmlzT3duZXIgfHwgdXNlci5pc0FkbWluKSB7ICU+Ym9yZGVyLWJvdHRvbTwlIH0gJT5cXFwiPlxcbiAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwibmF2IG5hdi1waWxscyBuYXYtc3RhY2tlZFxcXCI+XFxuICAgICAgICAgICAgICA8bGk+XFxuICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGlkPVxcXCJlbWFpbFxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLWVudmVsb3BlLW9cXFwiPjwvaT4gPHNwYW4gY2xhc3M9XFxcImJveC1pY29uLXRleHRcXFwiPlNoYXJlPC9zcGFuPjwvYT5cXG4gICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgICA8JSBpZiAoZGF0YS5pc093bmVyIHx8IHVzZXIuaXNBZG1pbikgeyAlPlxcbiAgICAgICAgICAgICAgPGxpPlxcbiAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCIvYXBpL2V2ZW50L2ljYWwvXFxcIj48c3BhbiBjbGFzcz1cXFwiZmEgZmEtY2FsZW5kYXJcXFwiPjwvc3Bhbj4gPHNwYW4gY2xhc3M9XFxcImJveC1pY29uLXRleHRcXFwiPkNhbGVuZGFyPC9zcGFuPjwvYT5cXG4gICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgPC91bD5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm5hdmJhci1zaWRlXFxcIj5cXG4gICAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwibmF2IG5hdi1waWxscyBuYXYtc3RhY2tlZFxcXCI+XFxuICAgICAgICAgICAgICA8bGk+XFxuICAgICAgICAgICAgICAgIDwlIGlmIChsb2dpbi5wcm9maWxlLmVkaXQgPT09IHRydWUpIHsgJT5cXG4gICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiL3Byb2ZpbGUvPCUtIGRhdGEuaWQgJT4vZWRpdFxcXCIgY2xhc3M9XFxcImxpbmstYmFja2JvbmVcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1wZW5jaWxcXFwiPjwvaT4gPHNwYW4gY2xhc3M9XFxcImJveC1pY29uLXRleHRcXFwiPkVkaXQgUHJvZmlsZTwvc3Bhbj48L2E+XFxuICAgICAgICAgICAgICAgIDwlIH0gZWxzZSBpZiAobG9naW4ucHJvZmlsZS5lZGl0VXJsKSB7ICU+XFxuICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIjwlPSBsb2dpbi5wcm9maWxlLmVkaXRVcmwgJT5cXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtcGVuY2lsXFxcIj48L2k+IDxzcGFuIGNsYXNzPVxcXCJib3gtaWNvbi10ZXh0XFxcIj5FZGl0IFByb2ZpbGU8L3NwYW4+PC9hPlxcbiAgICAgICAgICAgICAgICA8JSB9ICU+XFxuICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgPCUgfSAlPlxcbiAgICAgICAgICAgIDwvdWw+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8JSBpZiAoZGF0YS5pc093bmVyKSB7ICU+XFxuICAgIDxkaXYgY2xhc3M9XFxcImJveFxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiYm94LXBhZC1sciBib3JkZXItYm90dG9tXFxcIj5cXG4gICAgICAgIDxoMj5BY2NvdW50IEluZm9ybWF0aW9uPC9oMj5cXG4gICAgICA8L2Rpdj5cXG5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJib3gtcGFkLWxyIGJveC1wYWQtdFxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wteHMtMyBjb2wtc20tMyBjb2wtbWQtM1xcXCI+XFxuICAgICAgICAgICAgRW1haWw8JSBpZiAoZGF0YS5lbWFpbHMubGVuZ3RoID4gMSkgeyAlPnM8JSB9JT46XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wteHMtOSBjb2wtc20tOSBjb2wtbWQtOVxcXCI+XFxuICAgICAgICAgICAgPCUgZm9yICh2YXIgZSA9IDA7IGUgPCBkYXRhLmVtYWlscy5sZW5ndGg7IGUrKykgeyAlPlxcbiAgICAgICAgICAgICAgPCUgaWYgKGRhdGEuZW1haWxzW2VdLmlzUHJpbWFyeSkgeyAlPng8JSB9ICU+XFxuICAgICAgICAgICAgICA8JS0gZGF0YS5lbWFpbHNbZV0uZW1haWwgJT48YnIvPlxcbiAgICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgICA8JSBpZiAoZGF0YS5lbWFpbHMubGVuZ3RoID09IDApIHsgJT5cXG4gICAgICAgICAgICBObyBlbWFpbCBhZGRyZXNzZXNcXG4gICAgICAgICAgICA8JSB9ICU+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICA8JSBpZiAobG9naW4ub2F1dGgubGVuZ3RoID4gMCkgeyAlPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLXhzLTMgY29sLXNtLTMgY29sLW1kLTNcXFwiPlxcbiAgICAgICAgICAgIENvbm5lY3RlZCBBY2NvdW50czpcXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC14cy05IGNvbC1zbS05IGNvbC1tZC05XFxcIj5cXG4gICAgICAgICAgICA8JSBpZiAoZGF0YS5hdXRocy5sZW5ndGggPT09IDApIHsgJT5cXG4gICAgICAgICAgICAgIE5vIGNvbm5lY3RlZCBhY2NvdW50cy5cXG4gICAgICAgICAgICA8JSB9ICU+XFxuICAgICAgICAgICAgPCUgXy5lYWNoKGxvZ2luLm9hdXRoLCBmdW5jdGlvbiAoYSkgeyAlPlxcbiAgICAgICAgICAgICAgPCUgaWYgKF8uY29udGFpbnMoZGF0YS5hdXRocywgYSkpIHsgJT5cXG4gICAgICAgICAgICAgIDxkaXY+XFxuICAgICAgICAgICAgICAgIDwlPSBsb2dpbi5jb25maWdbYV0ubmFtZSAlPlxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwibGFiZWwgbGFiZWwtc3VjY2Vzc1xcXCI+Q29ubmVjdGVkPC9zcGFuPlxcbiAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICA8JSB9ICU+XFxuICAgICAgICAgICAgPCUgfSk7ICU+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8JSB9ICU+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8JSB9ICU+XFxuXFxuICAgIDwlIGlmICh1aS5wcm9qZWN0LnNob3cpIHsgJT5cXG4gICAgPGRpdiBjbGFzcz1cXFwiYm94XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJib3gtcGFkLWxyIGJvcmRlci1ib3R0b21cXFwiPlxcbiAgICAgICAgPGgyPjxzcGFuIGRhdGEtaTE4bj1cXFwiUHJvamVjdFBsdXJhbFxcXCI+UHJvamVjdHM8L3NwYW4+PC9oMj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJib3gtcGFkLWxyIGJveC1wYWQtdFxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwcm9qZWN0LWFjdGl2aXR5LXdyYXBwZXJcXFwiPjwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPCUgfSAlPlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJib3hcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImJveC1wYWQtbHIgYm9yZGVyLWJvdHRvbVxcXCI+XFxuICAgICAgICA8aDI+PHNwYW4gZGF0YS1pMThuPVxcXCJUYXNrUGx1cmFsXFxcIj5PcHBvcnR1bml0aWVzPC9zcGFuPiBWb2x1bnRlZXJlZCBGb3I8L2gyPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImJveC1wYWQtbHIgYm94LXBhZC10XFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInRhc2stYWN0aXZpdHktd3JhcHBlclxcXCI+PC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJib3hcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImJveC1wYWQtbHIgYm9yZGVyLWJvdHRvbVxcXCI+XFxuICAgICAgICA8aDI+PHNwYW4gZGF0YS1pMThuPVxcXCJUYXNrUGx1cmFsXFxcIj5PcHBvcnR1bml0aWVzPC9zcGFuPiBDcmVhdGVkPC9oMj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJib3gtcGFkLWxyIGJveC1wYWQtdFxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0YXNrLWNyZWF0ZWRhY3Rpdml0eS13cmFwcGVyXFxcIj48L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDwlIH0gJT4gPCEtLSAvZWRpdCBjaGVjayAtLT5cXG5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vbWl4aW5zL3V0aWxpdGllcycpO1xudmFyIFVJQ29uZmlnID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29uZmlnL3VpLmpzb24nKTtcbnZhciBhc3luYyA9IHJlcXVpcmUoJ2FzeW5jJyk7XG52YXIgQWN0VGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvcHJvZmlsZV9hY3Rpdml0eV90ZW1wbGF0ZS5odG1sJyk7XG5cblxudmFyIFByb2ZpbGVBY3Rpdml0eVZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG5cbiAgZXZlbnRzOiB7XG4gICAgJ2NsaWNrIC5hY3Rpdml0eS1saW5rJyAgICA6ICdsaW5rJ1xuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBzb3J0IGluaXRpYWxseSBieSBkYXRlLCBkZXNjZW5kaW5nLlxuICAgIHZhciByZXN1bHRzID0gdGhpcy5vcHRpb25zLmRhdGEuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKGIuY3JlYXRlZEF0KSAtIG5ldyBEYXRlKGEuY3JlYXRlZEF0KTtcbiAgICB9KTtcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIHVpOiBVSUNvbmZpZyxcbiAgICAgIHRhcmdldDogdGhpcy5vcHRpb25zLnRhcmdldCxcbiAgICAgIHRhcmdldEZyaWVuZGx5OiBpMThuLnQodGhpcy5vcHRpb25zLnRhcmdldCksXG4gICAgICB0YXJnZXRzRnJpZW5kbHk6IGkxOG4udCh0aGlzLm9wdGlvbnMudGFyZ2V0ICsgJ1BsdXJhbCcpLFxuICAgICAgdGFyZ2V0Q2FwaXRhbGl6ZWQ6IHRoaXMub3B0aW9ucy50YXJnZXQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0aGlzLm9wdGlvbnMudGFyZ2V0LnNsaWNlKDEpLFxuICAgICAgaGFuZGxlOiB0aGlzLm9wdGlvbnMuaGFuZGxlLFxuICAgICAgZGF0YTogcmVzdWx0cyxcbiAgICAgIGNvdW50OiB7fVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBpIGluIHRoaXMub3B0aW9ucy5kYXRhKSB7XG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChkYXRhLmNvdW50W3RoaXMub3B0aW9ucy5kYXRhW2ldLnN0YXRlXSkpIHtcbiAgICAgICAgZGF0YS5jb3VudFt0aGlzLm9wdGlvbnMuZGF0YVtpXS5zdGF0ZV0gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YS5jb3VudFt0aGlzLm9wdGlvbnMuZGF0YVtpXS5zdGF0ZV0rK1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdGVtcGxhdGUgPSBfLnRlbXBsYXRlKEFjdFRlbXBsYXRlKShkYXRhKTtcbiAgICB0aGlzLiRlbC5odG1sKHRlbXBsYXRlKTtcbiAgICB0aGlzLiRlbC5pMThuKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBsaW5rOiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgQmFja2JvbmUuaGlzdG9yeS5uYXZpZ2F0ZSh0aGlzLm9wdGlvbnMudGFyZ2V0ICsgJ3MvJyArICQoZS5jdXJyZW50VGFyZ2V0KS5kYXRhKCdpZCcpLCB7IHRyaWdnZXI6IHRydWUgfSk7XG4gIH0sXG5cbiAgY2xlYW51cDogZnVuY3Rpb24gKCkge1xuICAgIHJlbW92ZVZpZXcodGhpcyk7XG4gIH0sXG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb2ZpbGVBY3Rpdml0eVZpZXc7XG4iLCJcbnZhciBhc3luYyA9IHJlcXVpcmUoJ2FzeW5jJyk7XG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgTG9naW5QYXNzd29yZFZpZXcgPSByZXF1aXJlKCcuLi8uLi8uLi9sb2dpbi92aWV3cy9sb2dpbl9wYXNzd29yZF92aWV3Jyk7XG52YXIgUHJvZmlsZVJlc2V0VGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvcHJvZmlsZV9yZXNldF90ZW1wbGF0ZS5odG1sJyk7XG5cblxudmFyIFByb2ZpbGVSZXNldFZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG5cbiAgZXZlbnRzOiB7XG4gICAgJ2tleXVwICNycGFzc3dvcmQnICAgICAgICAgICAgICAgOiAnY2hlY2tQYXNzd29yZCcsXG4gICAgJ2JsdXIgI3JwYXNzd29yZCcgICAgICAgICAgICAgICAgOiAnY2hlY2tQYXNzd29yZCcsXG4gICAgJ3N1Ym1pdCAjZm9ybS1wYXNzd29yZC1yZXNldCcgICAgOiAnc3VibWl0UmVzZXQnXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuZGF0YSA9IG9wdGlvbnMuZGF0YTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIHVzZXI6IHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlciB8fCB7fVxuICAgIH07XG4gICAgdmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZShQcm9maWxlUmVzZXRUZW1wbGF0ZSkoZGF0YSk7XG4gICAgdGhpcy4kZWwuaHRtbCh0ZW1wbGF0ZSk7XG4gICAgdGhpcy5sb2dpblBhc3N3b3JkVmlldyA9IG5ldyBMb2dpblBhc3N3b3JkVmlldyh7XG4gICAgICBlbDogdGhpcy4kKFwiLnBhc3N3b3JkLXZpZXdcIilcbiAgICB9KS5yZW5kZXIoKTtcbiAgICB0aGlzLmNoZWNrVmFsaWRDb2RlKHRoaXMub3B0aW9ucy5hY3Rpb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGNoZWNrUGFzc3dvcmQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHJ1bGVzID0gdmFsaWRhdGVQYXNzd29yZCh0aGlzLnRva2VuLmVtYWlsLCB0aGlzLiQoXCIjcnBhc3N3b3JkXCIpLnZhbCgpKTtcbiAgICB2YXIgc3VjY2VzcyA9IHRydWU7XG4gICAgXy5lYWNoKHJ1bGVzLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuJChcIi5wYXNzd29yZC1ydWxlcyAuc3VjY2Vzcy5ydWxlLVwiICsga2V5KS5zaG93KCk7XG4gICAgICAgIHRoaXMuJChcIi5wYXNzd29yZC1ydWxlcyAuZXJyb3IucnVsZS1cIiArIGtleSkuaGlkZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4kKFwiLnBhc3N3b3JkLXJ1bGVzIC5zdWNjZXNzLnJ1bGUtXCIgKyBrZXkpLmhpZGUoKTtcbiAgICAgICAgdGhpcy4kKFwiLnBhc3N3b3JkLXJ1bGVzIC5lcnJvci5ydWxlLVwiICsga2V5KS5zaG93KCk7XG4gICAgICB9XG4gICAgICBzdWNjZXNzID0gc3VjY2VzcyAmJiB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gc3VjY2VzcztcbiAgfSxcblxuICBjaGVja1ZhbGlkQ29kZTogZnVuY3Rpb24gKGNvZGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgLy8gY2hlY2sgaWYgdGhlIGNvZGUgaXMgdmFsaWQgYW5kIHVwZGF0ZSB0aGUgRE9NIGFjY29yZGluZ2x5XG4gICAgJC5hamF4KHtcbiAgICAgIHVybDogJy9hcGkvYXV0aC9jaGVja1Rva2VuLycgKyBjb2RlLFxuICAgICAgc3VjY2VzczogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgc2VsZi4kKFwiI3Byb2ZpbGUtcmVzZXQtY2hlY2tcIikuaGlkZSgpO1xuICAgICAgICAvLyB0cnVlIG1lYW5zIHRoZSB0b2tlbiBpcyBhIHZhbGlkIHJlc2V0IHRva2VuXG4gICAgICAgIGlmIChkYXRhID09PSBmYWxzZSkge1xuICAgICAgICAgIHNlbGYuJChcIiNwcm9maWxlLXJlc2V0LWNoZWNrLWVycm9yXCIpLnNob3coKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzZWxmLnRva2VuID0gZGF0YTtcbiAgICAgICAgICBzZWxmLiQoXCIjcHJvZmlsZS1yZXNldC1kaWFsb2dcIikuc2hvdygpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZXJyb3I6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHNlbGYuJChcIiNwcm9maWxlLXJlc2V0LWNoZWNrXCIpLmhpZGUoKTtcbiAgICAgICAgc2VsZi4kKFwiI3Byb2ZpbGUtcmVzZXQtY2hlY2stZXJyb3JcIikuc2hvdygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIHN1Ym1pdFJlc2V0OiBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgdmFyIHBhc3N3b3JkU3VjY2VzcyA9IHRoaXMuY2hlY2tQYXNzd29yZCgpO1xuICAgIHZhciBwYXJlbnQgPSAkKHRoaXMuJChcIiNycGFzc3dvcmRcIikucGFyZW50cygnLmZvcm0tZ3JvdXAnKVswXSk7XG4gICAgaWYgKHBhc3N3b3JkU3VjY2VzcyAhPT0gdHJ1ZSkge1xuICAgICAgcGFyZW50LmFkZENsYXNzKCdoYXMtZXJyb3InKTtcbiAgICAgICQocGFyZW50LmZpbmQoJy5lcnJvci1wYXNzd29yZCcpWzBdKS5zaG93KCk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgICQocGFyZW50LmZpbmQoJy5lcnJvci1wYXNzd29yZCcpWzBdKS5oaWRlKCk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgZGF0YSBvYmplY3Qgd2l0aCB0aGUgcmVxdWlyZWQgZmllbGRzXG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICB0b2tlbjogdGhpcy5vcHRpb25zLmFjdGlvbixcbiAgICAgIHBhc3N3b3JkOiB0aGlzLiQoXCIjcnBhc3N3b3JkXCIpLnZhbCgpLFxuICAgICAganNvbjogdHJ1ZVxuICAgIH07XG4gICAgc2VsZi4kKFwiI3Byb2ZpbGUtcmVzZXQtc3VibWl0XCIpLnNob3coKTtcbiAgICBzZWxmLiQoXCIjcHJvZmlsZS1yZXNldC1zdWJtaXQtZXJyb3JcIikuaGlkZSgpO1xuICAgICQuYWpheCh7XG4gICAgICB1cmw6ICcvYXBpL2F1dGgvcmVzZXQvJyxcbiAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBzZWxmLiQoXCIjcHJvZmlsZS1yZXNldC1zdWJtaXRcIikuaGlkZSgpO1xuICAgICAgICAvLyB0cnVlIG1lYW5zIHRoZSB0b2tlbiBpcyBhIHZhbGlkIHJlc2V0IHRva2VuXG4gICAgICAgIGlmIChkYXRhID09PSBmYWxzZSkge1xuICAgICAgICAgIHNlbGYuJChcIiNwcm9maWxlLXJlc2V0LXN1Ym1pdC1lcnJvclwiKS5zaG93KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gbmF2aWdhdGUgdG8gdGhlIHByb2plY3RzIG1haW4gcGFnZVxuICAgICAgICAgIEJhY2tib25lLmhpc3RvcnkubmF2aWdhdGUoJy8nLCB7IHRyaWdnZXI6IHRydWUgfSk7XG4gICAgICAgICAgLy8gc2hvdyBsb2cgaW4gc2NyZWVuIHdpdGggbm90aWNlIHRvIGxvZyBpbi5cbiAgICAgICAgICB3aW5kb3cuY2FjaGUudXNlckV2ZW50cy50cmlnZ2VyKFwidXNlcjpyZXF1ZXN0OmxvZ2luXCIsIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiWW91ciBwYXNzd29yZCBoYXMgYmVlbiByZXNldC4gIFBsZWFzZSBsb2cgaW4gdG8gY29udGludWUuXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGVycm9yOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBzZWxmLiQoXCIjcHJvZmlsZS1yZXNldC1zdWJtaXRcIikuaGlkZSgpO1xuICAgICAgICBzZWxmLiQoXCIjcHJvZmlsZS1yZXNldC1zdWJtaXQtZXJyb3JcIikuc2hvdygpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gIH0sXG5cbiAgY2xlYW51cDogZnVuY3Rpb24gKCkge1xuICAgIHJlbW92ZVZpZXcodGhpcyk7XG4gIH0sXG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb2ZpbGVSZXNldFZpZXc7XG5cbiIsIlxudmFyIGFzeW5jID0gcmVxdWlyZSgnYXN5bmMnKTtcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL21peGlucy91dGlsaXRpZXMnKTtcbnZhciBQcm9maWxlU2V0dGluZ3NUZW1wbGF0ZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy9wcm9maWxlX3NldHRpbmdzX3RlbXBsYXRlLmh0bWwnKTtcblxuXG52YXIgUHJvZmlsZVNldHRpbmdzVmlldyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcblxuICBldmVudHM6IHtcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5kYXRhID0gb3B0aW9ucy5kYXRhO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhID0ge1xuICAgICAgdXNlcjogd2luZG93LmNhY2hlLmN1cnJlbnRVc2VyIHx8IHt9XG4gICAgfVxuICAgIHZhciB0ZW1wbGF0ZSA9IF8udGVtcGxhdGUoUHJvZmlsZVNldHRpbmdzVGVtcGxhdGUpKGRhdGEpO1xuICAgIHRoaXMuJGVsLmh0bWwodGVtcGxhdGUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGNsZWFudXA6IGZ1bmN0aW9uICgpIHtcbiAgICByZW1vdmVWaWV3KHRoaXMpO1xuICB9LFxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9maWxlU2V0dGluZ3NWaWV3O1xuXG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgVUlDb25maWcgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb25maWcvdWkuanNvbicpO1xudmFyIGFzeW5jID0gcmVxdWlyZSgnYXN5bmMnKTtcbnZhciBqcUlmcmFtZSA9IHJlcXVpcmUoJ2JsdWVpbXAtZmlsZS11cGxvYWQvanMvanF1ZXJ5LmlmcmFtZS10cmFuc3BvcnQnKTtcbnZhciBqcUZVID0gcmVxdWlyZSgnYmx1ZWltcC1maWxlLXVwbG9hZC9qcy9qcXVlcnkuZmlsZXVwbG9hZC5qcycpO1xudmFyIE1hcmtkb3duRWRpdG9yID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29tcG9uZW50cy9tYXJrZG93bl9lZGl0b3InKTtcbnZhciBtYXJrZWQgPSByZXF1aXJlKCdtYXJrZWQnKTtcbnZhciBUYWdTaG93VmlldyA9IHJlcXVpcmUoJy4uLy4uLy4uL3RhZy9zaG93L3ZpZXdzL3RhZ19zaG93X3ZpZXcnKTtcbnZhciBQcm9maWxlVGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvcHJvZmlsZV9zaG93X3RlbXBsYXRlLmh0bWwnKTtcbnZhciBFbWFpbFRlbXBsYXRlID0gcmVxdWlyZSgnLi4vdGVtcGxhdGVzL3Byb2ZpbGVfZW1haWxfdGVtcGxhdGUuaHRtbCcpO1xudmFyIExvZ2luID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29uZmlnL2xvZ2luLmpzb24nKTtcbnZhciBNb2RhbENvbXBvbmVudCA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2NvbXBvbmVudHMvbW9kYWwnKTtcbnZhciBQQVZpZXcgPSByZXF1aXJlKCcuL3Byb2ZpbGVfYWN0aXZpdHlfdmlldycpO1xudmFyIEVtYWlsRm9ybVZpZXcgPSByZXF1aXJlKCcuLi8uLi9lbWFpbC92aWV3cy9wcm9maWxlX2VtYWlsX3ZpZXcnKTtcbnZhciBUYWdGYWN0b3J5ID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29tcG9uZW50cy90YWdfZmFjdG9yeScpO1xuXG5cbnZhciBQcm9maWxlU2hvd1ZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG5cbiAgZXZlbnRzOiB7XG4gICAgXCJzdWJtaXQgI3Byb2ZpbGUtZm9ybVwiICAgICAgIDogXCJwcm9maWxlU3VibWl0XCIsXG4gICAgXCJjbGljayAjcHJvZmlsZS1zYXZlXCIgICAgICAgIDogXCJwcm9maWxlU2F2ZVwiLFxuICAgIFwiY2xpY2sgLmxpbmstYmFja2JvbmVcIiAgICAgICA6IGxpbmtCYWNrYm9uZSxcbiAgICBcImNsaWNrICNwcm9maWxlLWNhbmNlbFwiICAgICAgOiBcInByb2ZpbGVDYW5jZWxcIixcbiAgICBcImNsaWNrICNsaWtlLWJ1dHRvblwiICAgICAgICAgOiBcImxpa2VcIixcbiAgICBcImtleXVwICNuYW1lLCAjdGl0bGUsICNiaW9cIiAgOiBcImZpZWxkTW9kaWZpZWRcIixcbiAgICBcImNsaWNrIC5yZW1vdmVBdXRoXCIgICAgICAgICAgOiBcInJlbW92ZUF1dGhcIlxuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmRhdGEgPSBvcHRpb25zLmRhdGE7XG4gICAgdGhpcy50YWdGYWN0b3J5ID0gbmV3IFRhZ0ZhY3RvcnkoKTtcbiAgICB0aGlzLmRhdGEubmV3SXRlbVRhZ3MgPSBbXTtcbiAgICB0aGlzLmVkaXQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmFjdGlvbiA9PSAnZWRpdCcpIHtcbiAgICAgIHRoaXMuZWRpdCA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLmRhdGEuc2F2ZWQpIHtcbiAgICAgIHRoaXMuc2F2ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5kYXRhLnNhdmVkID0gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhID0ge1xuICAgICAgbG9naW46IExvZ2luLFxuICAgICAgZGF0YTogdGhpcy5tb2RlbC50b0pTT04oKSxcbiAgICAgIHVzZXI6IHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlciB8fCB7fSxcbiAgICAgIGVkaXQ6IHRoaXMuZWRpdCxcbiAgICAgIHNhdmVkOiB0aGlzLnNhdmVkLFxuICAgICAgdWk6IFVJQ29uZmlnXG4gICAgfVxuXG4gICAgZGF0YS5lbWFpbCA9IChkYXRhLmRhdGEuZW1haWxzICYmIGRhdGEuZGF0YS5lbWFpbHMubGVuZ3RoKSA/IGRhdGEuZGF0YS5lbWFpbHNbMF0gOiAnJztcblxuICAgIGlmIChkYXRhLmRhdGEuYmlvKSB7XG4gICAgICBkYXRhLmRhdGEuYmlvSHRtbCA9IG1hcmtlZChkYXRhLmRhdGEuYmlvKTtcbiAgICB9XG4gICAgdmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZShQcm9maWxlVGVtcGxhdGUpKGRhdGEpO1xuICAgIHRoaXMuJGVsLmh0bWwodGVtcGxhdGUpO1xuICAgIHRoaXMuJGVsLmkxOG4oKTtcblxuICAgIC8vIGluaXRpYWxpemUgc3ViIGNvbXBvbmVudHNcbiAgICB0aGlzLmluaXRpYWxpemVGaWxlVXBsb2FkKCk7XG4gICAgdGhpcy5pbml0aWFsaXplRm9ybSgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZVNlbGVjdDIoKTtcbiAgICB0aGlzLmluaXRpYWxpemVMaWtlcygpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZVRhZ3MoKTtcbiAgICB0aGlzLmluaXRpYWxpemVQQVZpZXcoKTtcbiAgICB0aGlzLmluaXRpYWxpemVUZXh0QXJlYSgpO1xuICAgIHRoaXMudXBkYXRlUGhvdG8oKTtcbiAgICB0aGlzLnVwZGF0ZVByb2ZpbGVFbWFpbCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGluaXRpYWxpemVGaWxlVXBsb2FkOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgJCgnI2ZpbGV1cGxvYWQnKS5maWxldXBsb2FkKHtcbiAgICAgICAgdXJsOiBcIi9hcGkvZmlsZS9jcmVhdGVcIixcbiAgICAgICAgZGF0YVR5cGU6ICd0ZXh0JyxcbiAgICAgICAgYWNjZXB0RmlsZVR5cGVzOiAvKFxcLnxcXC8pKGdpZnxqcGU/Z3xwbmcpJC9pLFxuICAgICAgICBmb3JtRGF0YTogeyAndHlwZSc6ICdpbWFnZV9zcXVhcmUnIH0sXG4gICAgICAgIGFkZDogZnVuY3Rpb24gKGUsIGRhdGEpIHtcbiAgICAgICAgICBzZWxmLiQoJyNmaWxlLXVwbG9hZC1wcm9ncmVzcy1jb250YWluZXInKS5zaG93KCk7XG4gICAgICAgICAgZGF0YS5zdWJtaXQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJvZ3Jlc3NhbGw6IGZ1bmN0aW9uIChlLCBkYXRhKSB7XG4gICAgICAgICAgdmFyIHByb2dyZXNzID0gcGFyc2VJbnQoZGF0YS5sb2FkZWQgLyBkYXRhLnRvdGFsICogMTAwLCAxMCk7XG4gICAgICAgICAgc2VsZi4kKCcjZmlsZS11cGxvYWQtcHJvZ3Jlc3MnKS5jc3MoXG4gICAgICAgICAgICAnd2lkdGgnLFxuICAgICAgICAgICAgcHJvZ3Jlc3MgKyAnJSdcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBkb25lOiBmdW5jdGlvbiAoZSwgZGF0YSkge1xuICAgICAgICAgIC8vIGZvciBJRTgvOSB0aGF0IHVzZSBpZnJhbWVcbiAgICAgICAgICBpZiAoZGF0YS5kYXRhVHlwZSA9PSAnaWZyYW1lIHRleHQnKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gSlNPTi5wYXJzZShkYXRhLnJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGZvciBtb2Rlcm4gWEhSIGJyb3dzZXJzXG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gSlNPTi5wYXJzZSgkKGRhdGEucmVzdWx0KS50ZXh0KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLm1vZGVsLnRyaWdnZXIoXCJwcm9maWxlOnVwZGF0ZVdpdGhQaG90b0lkXCIsIHJlc3VsdFswXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZhaWw6IGZ1bmN0aW9uIChlLCBkYXRhKSB7XG4gICAgICAgICAgLy8gbm90aWZ5IHRoZSB1c2VyIHRoYXQgdGhlIHVwbG9hZCBmYWlsZWRcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IGRhdGEuZXJyb3JUaHJvd247XG4gICAgICAgICAgc2VsZi4kKCcjZmlsZS11cGxvYWQtcHJvZ3Jlc3MtY29udGFpbmVyJykuaGlkZSgpO1xuICAgICAgICAgIGlmIChkYXRhLmpxWEhSLnN0YXR1cyA9PSA0MTMpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIlRoZSB1cGxvYWRlZCBmaWxlIGV4Y2VlZHMgdGhlIG1heGltdW0gZmlsZSBzaXplLlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLiQoXCIjZmlsZS11cGxvYWQtYWxlcnRcIikuaHRtbChtZXNzYWdlKVxuICAgICAgICAgIHNlbGYuJChcIiNmaWxlLXVwbG9hZC1hbGVydFwiKS5zaG93KCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICB9LFxuXG4gIHVwZGF0ZVByb2ZpbGVFbWFpbDogZnVuY3Rpb24oKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgJC5hamF4KHtcbiAgICAgIHVybDogZW5jb2RlVVJJKCcvYXBpL2VtYWlsL21ha2VVUkw/ZW1haWw9Y29udGFjdFVzZXJBYm91dFByb2ZpbGUmc3ViamVjdD1DaGVjayBPdXQgXCInKyBzZWxmLm1vZGVsLmF0dHJpYnV0ZXMubmFtZSArICdcIicgK1xuICAgICAgJyZwcm9maWxlVGl0bGU9JyArIChzZWxmLm1vZGVsLmF0dHJpYnV0ZXMudGl0bGUgfHwgJycpICtcbiAgICAgICcmcHJvZmlsZUxpbms9JyArIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIHdpbmRvdy5sb2NhdGlvbi5ob3N0ICsgXCJcIiArIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArXG4gICAgICAnJnByb2ZpbGVOYW1lPScgKyAoc2VsZi5tb2RlbC5hdHRyaWJ1dGVzLm5hbWUgfHwgJycpICtcbiAgICAgICcmcHJvZmlsZUxvY2F0aW9uPScgKyAoc2VsZi5tb2RlbC5hdHRyaWJ1dGVzLmxvY2F0aW9uID8gc2VsZi5tb2RlbC5hdHRyaWJ1dGVzLmxvY2F0aW9uLnRhZy5uYW1lIDogJycpICtcbiAgICAgICcmcHJvZmlsZUFnZW5jeT0nICsgKHNlbGYubW9kZWwuYWdlbmN5ID8gc2VsZi5tb2RlbC5hZ2VuY3kubmFtZSA6ICcnKSksXG4gICAgICB0eXBlOiAnR0VUJ1xuICAgIH0pLmRvbmUoIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBzZWxmLiQoJyNlbWFpbCcpLmF0dHIoJ2hyZWYnLCBkYXRhKTtcbiAgICB9KTtcbiAgfSxcblxuICBpbml0aWFsaXplVGFnczogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMudGFnVmlldykgeyB0aGlzLnRhZ1ZpZXcuY2xlYW51cCgpOyB9XG4gICAgdGhpcy50YWdWaWV3ID0gbmV3IFRhZ1Nob3dWaWV3KHtcbiAgICAgIG1vZGVsOiB0aGlzLm1vZGVsLFxuICAgICAgZWw6ICcudGFnLXdyYXBwZXInLFxuICAgICAgdGFyZ2V0OiAncHJvZmlsZScsXG4gICAgICB0YXJnZXRJZDogJ3VzZXJJZCcsXG4gICAgICBlZGl0OiB0aGlzLmVkaXQsXG4gICAgICB1cmw6ICcvYXBpL3RhZy9maW5kQWxsQnlVc2VySWQvJ1xuICAgIH0pO1xuICAgIHRoaXMudGFnVmlldy5yZW5kZXIoKTtcbiAgfSxcblxuICBpbml0aWFsaXplUEFWaWV3OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucHJvamVjdFZpZXcpIHsgdGhpcy5wcm9qZWN0Vmlldy5jbGVhbnVwKCk7IH1cbiAgICBpZiAodGhpcy50YXNrVmlldykgeyB0aGlzLnRhc2tWaWV3LmNsZWFudXAoKTsgfVxuICAgIGlmICh0aGlzLnZvbFZpZXcpIHsgdGhpcy52b2xWaWV3LmNsZWFudXAoKTsgfVxuICAgICQuYWpheCgnL2FwaS91c2VyL2FjdGl2aXRpZXMvJyArIHRoaXMubW9kZWwuYXR0cmlidXRlcy5pZCkuZG9uZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgdGhpcy5wcm9qZWN0VmlldyA9IG5ldyBQQVZpZXcoe1xuICAgICAgICBtb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgICAgZWw6ICcucHJvamVjdC1hY3Rpdml0eS13cmFwcGVyJyxcbiAgICAgICAgdGFyZ2V0OiAncHJvamVjdCcsXG4gICAgICAgIGhhbmRsZTogJ3Byb2plY3QnLFxuICAgICAgICBkYXRhOiBkYXRhLnByb2plY3RzXG4gICAgICB9KTtcbiAgICAgIHRoaXMucHJvamVjdFZpZXcucmVuZGVyKCk7XG4gICAgICB0aGlzLnRhc2tWaWV3ID0gbmV3IFBBVmlldyh7XG4gICAgICAgIG1vZGVsOiB0aGlzLm1vZGVsLFxuICAgICAgICBlbDogJy50YXNrLWNyZWF0ZWRhY3Rpdml0eS13cmFwcGVyJyxcbiAgICAgICAgdGFyZ2V0OiAndGFzaycsXG4gICAgICAgIGhhbmRsZTogJ3Rhc2snLFxuICAgICAgICBkYXRhOiBkYXRhLnRhc2tzXG4gICAgICB9KTtcbiAgICAgIHRoaXMudGFza1ZpZXcucmVuZGVyKCk7XG4gICAgICB0aGlzLnZvbFZpZXcgPSBuZXcgUEFWaWV3KHtcbiAgICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICAgIGVsOiAnLnRhc2stYWN0aXZpdHktd3JhcHBlcicsXG4gICAgICAgIHRhcmdldDogJ3Rhc2snLFxuICAgICAgICBoYW5kbGU6ICd2b2xUYXNrJyxcbiAgICAgICAgZGF0YTogZGF0YS52b2xUYXNrc1xuICAgICAgfSk7XG4gICAgICB0aGlzLnZvbFZpZXcucmVuZGVyKCk7XG5cbiAgICB9KTtcbiAgfSxcblxuICB1cGRhdGVQaG90bzogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLm1vZGVsLm9uKFwicHJvZmlsZTp1cGRhdGVkUGhvdG9cIiwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHZhciB1cmwgPSAnL2FwaS91c2VyL3Bob3RvLycgKyBkYXRhLmF0dHJpYnV0ZXMuaWQ7XG4gICAgICAvLyBmb3JjZSB0aGUgbmV3IGltYWdlIHRvIGJlIGxvYWRlZFxuICAgICAgJC5nZXQodXJsLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAkKFwiI3Byb2plY3QtaGVhZGVyXCIpLmNzcygnYmFja2dyb3VuZC1pbWFnZScsIFwidXJsKCdcIiArIHVybCArIFwiJylcIik7XG4gICAgICAgICQoJyNmaWxlLXVwbG9hZC1wcm9ncmVzcy1jb250YWluZXInKS5oaWRlKCk7XG4gICAgICAgIC8vIG5vdGlmeSBsaXN0ZW5lcnMgb2YgdGhlIG5ldyB1c2VyIGltYWdlLCBidXQgb25seSBmb3IgdGhlIGN1cnJlbnQgdXNlclxuICAgICAgICBpZiAoc2VsZi5tb2RlbC50b0pTT04oKS5pZCA9PSB3aW5kb3cuY2FjaGUuY3VycmVudFVzZXIuaWQpIHtcbiAgICAgICAgICB3aW5kb3cuY2FjaGUudXNlckV2ZW50cy50cmlnZ2VyKFwidXNlcjpwcm9maWxlOnBob3RvOnNhdmVcIiwgdXJsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZUZvcm06IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICQoXCIjdG9waWNzXCIpLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgc2VsZi5tb2RlbC50cmlnZ2VyKFwicHJvZmlsZTppbnB1dDpjaGFuZ2VkXCIsIGUpO1xuICAgIH0pO1xuXG4gICAgJChcIiNza2lsbHNcIikub24oJ2NoYW5nZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBzZWxmLm1vZGVsLnRyaWdnZXIoXCJwcm9maWxlOmlucHV0OmNoYW5nZWRcIiwgZSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmxpc3RlblRvKHNlbGYubW9kZWwsIFwicHJvZmlsZTpzYXZlOnN1Y2Nlc3NcIiwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIC8vIEJvb3RzdHJhcCAuYnV0dG9uKCkgaGFzIGV4ZWN1dGlvbiBvcmRlciBpc3N1ZSBzaW5jZSBpdFxuICAgICAgLy8gdXNlcyBzZXRUaW1lb3V0IHRvIGNoYW5nZSB0aGUgdGV4dCBvZiBidXR0b25zLlxuICAgICAgLy8gbWFrZSBzdXJlIGF0dHIoKSBydW5zIGxhc3RcbiAgICAgICQoXCIjc3VibWl0XCIpLmJ1dHRvbignc3VjY2VzcycpO1xuICAgICAgLy8gbm90aWZ5IGxpc3RlbmVycyBpZiB0aGUgY3VycmVudCB1c2VyIGhhcyBiZWVuIHVwZGF0ZWRcbiAgICAgIGlmIChzZWxmLm1vZGVsLnRvSlNPTigpLmlkID09IHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlci5pZCkge1xuICAgICAgICB3aW5kb3cuY2FjaGUudXNlckV2ZW50cy50cmlnZ2VyKFwidXNlcjpwcm9maWxlOnNhdmVcIiwgZGF0YS50b0pTT04oKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0YWdzID0gW1xuICAgICAgICAkKFwiI2NvbXBhbnlcIikuc2VsZWN0MignZGF0YScpLFxuICAgICAgICAkKFwiI2xvY2F0aW9uXCIpLnNlbGVjdDIoJ2RhdGEnKVxuICAgICAgXTtcbiAgICAgIHNlbGYubW9kZWwudHJpZ2dlcihcInByb2ZpbGU6dGFnczpzYXZlXCIsIHRhZ3MpO1xuICAgIH0pO1xuXG4gICAgc2VsZi5vbignbmV3VGFnU2F2ZURvbmUnLGZ1bmN0aW9uICgpe1xuXG4gICAgICB0YWdzICAgICAgICAgPSBbXTtcbiAgICAgIHZhciB0ZW1wVGFncyA9IFtdO1xuXG4gICAgICAvL2dldCBuZXdseSBjcmVhdGVkIHRhZ3MgZnJvbSBiaWcgdGhyZWUgdHlwZXNcbiAgICAgIF8uZWFjaChzZWxmLmRhdGEubmV3SXRlbVRhZ3MsIGZ1bmN0aW9uKG5ld0l0ZW1UYWcpe1xuICAgICAgICB0YWdzLnB1c2gobmV3SXRlbVRhZyk7XG4gICAgICB9KTtcblxuICAgICAgdGVtcFRhZ3MucHVzaC5hcHBseSh0ZW1wVGFncyxzZWxmLiQoXCIjdGFnX3RvcGljXCIpLnNlbGVjdDIoJ2RhdGEnKSk7XG4gICAgICB0ZW1wVGFncy5wdXNoLmFwcGx5KHRlbXBUYWdzLHNlbGYuJChcIiN0YWdfc2tpbGxcIikuc2VsZWN0MignZGF0YScpKTtcbiAgICAgIHRlbXBUYWdzLnB1c2guYXBwbHkodGVtcFRhZ3Msc2VsZi4kKFwiI3RhZ19sb2NhdGlvblwiKS5zZWxlY3QyKCdkYXRhJykpO1xuICAgICAgdGVtcFRhZ3MucHVzaC5hcHBseSh0ZW1wVGFncyxzZWxmLiQoXCIjdGFnX2FnZW5jeVwiKS5zZWxlY3QyKCdkYXRhJykpO1xuXG4gICAgICAvL3NlZSBpZiB0aGVyZSBhcmUgYW55IHByZXZpb3VzbHkgY3JlYXRlZCBiaWcgdGhyZWUgdGFncyBhbmQgYWRkIHRoZW0gdG8gdGhlIHRhZyBhcnJheVxuICAgICAgXy5lYWNoKHRlbXBUYWdzLGZ1bmN0aW9uKHRlbXBUYWcpe1xuICAgICAgICAgIGlmICggdGVtcFRhZy5pZCAhPT0gdGVtcFRhZy5uYW1lICl7XG4gICAgICAgICAgdGFncy5wdXNoKHRlbXBUYWcpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdmFyIHRhZ01hcCA9IHt9O1xuXG4gICAgICAgIC8vIGlmIGEgZGlmZmVyZW50IHByb2ZpbGUgaXMgYmVpbmcgZWRpdGVkLCBhZGQgaXRzIHVzZXJJZFxuICAgICAgICBpZiAoc2VsZi5tb2RlbC50b0pTT04oKS5pZCAhPT0gd2luZG93LmNhY2hlLmN1cnJlbnRVc2VyLmlkKSB7XG4gICAgICAgICAgdGFnTWFwLnVzZXJJZCA9IHNlbGYubW9kZWwudG9KU09OKCkuaWQ7XG4gICAgICAgIH1cblxuICAgICAgYXN5bmMuZm9yRWFjaCh0YWdzLCBmdW5jdGlvbih0YWcsIGNhbGxiYWNrKXtcbiAgICAgICAgLy9kaWZmQWRkLHNlbGYubW9kZWwuYXR0cmlidXRlcy5pZCxcInRhc2tJZFwiLGNhbGxiYWNrXG4gICAgICAgIHJldHVybiBzZWxmLnRhZ0ZhY3RvcnkuYWRkVGFnKHRhZyx0YWdNYXAudXNlcklkLFwidXNlcklkXCIsY2FsbGJhY2spO1xuICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIHNlbGYubW9kZWwudHJpZ2dlcihcInByb2ZpbGU6dGFnczpzYXZlOnN1Y2Nlc3NcIiwgZXJyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGhpcy5saXN0ZW5UbyhzZWxmLm1vZGVsLCBcInByb2ZpbGU6dGFnczpzYXZlXCIsIGZ1bmN0aW9uICh0YWdzKSB7XG5cbiAgICAgIHZhciBuZXdUYWdzID0gW107XG5cbiAgICAgIG5ld1RhZ3MgPSBuZXdUYWdzLmNvbmNhdChcbiAgICAgICAgc2VsZi4kKFwiI3RhZ190b3BpY1wiKS5zZWxlY3QyKCdkYXRhJyksXG4gICAgICAgIHNlbGYuJChcIiN0YWdfc2tpbGxcIikuc2VsZWN0MignZGF0YScpLFxuICAgICAgICBzZWxmLiQoXCIjdGFnX2xvY2F0aW9uXCIpLnNlbGVjdDIoJ2RhdGEnKSxcbiAgICAgICAgc2VsZi4kKFwiI2xvY2F0aW9uXCIpLnNlbGVjdDIoJ2RhdGEnKSxcbiAgICAgICAgc2VsZi4kKFwiI3RhZ19hZ2VuY3lcIikuc2VsZWN0MignZGF0YScpXG4gICAgICApO1xuXG4gICAgICB2YXIgcmVtb3ZlVGFnID0gZnVuY3Rpb24odHlwZSwgZG9uZSkge1xuICAgICAgICBpZiAoc2VsZi5tb2RlbFt0eXBlXSkge1xuICAgICAgICAgIC8vIGRlbGV0ZSB0aGUgZXhpc3RpbmcgdGFnXG4gICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgIHVybDogJy9hcGkvdGFnLycgKyBzZWxmLm1vZGVsW3R5cGVdLnRhZ0lkLFxuICAgICAgICAgICAgdHlwZTogJ0RFTEVURScsXG4gICAgICAgICAgfSkuZG9uZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFkZFRhZyA9IGZ1bmN0aW9uICh0YWcsIGRvbmUpIHtcbiAgICAgICAgLy8gdGhlIHRhZyBpcyBpbnZhbGlkIG9yIGhhc24ndCBiZWVuIHNlbGVjdGVkXG4gICAgICAgIGlmICghdGFnIHx8ICF0YWcuaWQpIHtcbiAgICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSB0YWcgYWxyZWFkeSBpcyBzdG9yZWQgaW4gdGhlIGRiXG4gICAgICAgIGlmICh0YWcudGFnSWQpIHtcbiAgICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0YWdNYXAgPSB7XG4gICAgICAgICAgdGFnSWQ6IHRhZy5pZFxuICAgICAgICB9O1xuICAgICAgICAvLyBpZiBhIGRpZmZlcmVudCBwcm9maWxlIGlzIGJlaW5nIGVkaXRlZCwgYWRkIGl0cyB1c2VySWRcbiAgICAgICAgaWYgKHNlbGYubW9kZWwudG9KU09OKCkuaWQgIT09IHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlci5pZCkge1xuICAgICAgICAgIHRhZ01hcC51c2VySWQgPSBzZWxmLm1vZGVsLnRvSlNPTigpLmlkO1xuICAgICAgICB9XG4gICAgICAgICQuYWpheCh7XG4gICAgICAgICAgdXJsOiAnL2FwaS90YWcnLFxuICAgICAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgICAgICBkYXRhOiB0YWdNYXBcbiAgICAgICAgfSkuZG9uZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGFzeW5jLmZvckVhY2goXG4gICAgICAgIG5ld1RhZ3MsXG4gICAgICAgIGZ1bmN0aW9uKG5ld1RhZywgY2FsbGJhY2spIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi50YWdGYWN0b3J5LmFkZFRhZ0VudGl0aWVzKG5ld1RhZyxzZWxmLGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIG5leHQoZXJyKTtcblxuICAgICAgICAgIHRhZ3MgPSBfLmZpbHRlcih0YWdzLCBmdW5jdGlvbih0YWcpIHtcbiAgICAgICAgICAgIHJldHVybiAodGFnICYmIHRhZy5pZCAhPT0gdGFnLm5hbWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFzeW5jLmVhY2goWydhZ2VuY3knLCdsb2NhdGlvbiddLCByZW1vdmVUYWcsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGFzeW5jLmVhY2godGFncywgYWRkVGFnLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgIHNlbGYudHJpZ2dlcihcIm5ld1RhZ1NhdmVEb25lXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICB9KTtcblxuICAgIHRoaXMubGlzdGVuVG8oc2VsZi5tb2RlbCwgXCJwcm9maWxlOnRhZ3M6c2F2ZTpzdWNjZXNzXCIsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7ICQoXCIjcHJvZmlsZS1zYXZlLCAjc3VibWl0XCIpLmF0dHIoXCJkaXNhYmxlZFwiLCBcImRpc2FibGVkXCIpIH0sMCk7XG4gICAgICAkKFwiI3Byb2ZpbGUtc2F2ZSwgI3N1Ym1pdFwiKS5yZW1vdmVDbGFzcyhcImJ0bi1wcmltYXJ5XCIpO1xuICAgICAgJChcIiNwcm9maWxlLXNhdmUsICNzdWJtaXRcIikuYWRkQ2xhc3MoXCJidG4tc3VjY2Vzc1wiKTtcbiAgICAgIHNlbGYuZGF0YS5zYXZlZCA9IHRydWU7XG4gICAgICBCYWNrYm9uZS5oaXN0b3J5Lm5hdmlnYXRlKCdwcm9maWxlLycgKyBzZWxmLm1vZGVsLnRvSlNPTigpLmlkLCB7IHRyaWdnZXI6IHRydWUgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmxpc3RlblRvKHNlbGYubW9kZWwsIFwicHJvZmlsZTpzYXZlOmZhaWxcIiwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICQoXCIjc3VibWl0XCIpLmJ1dHRvbignZmFpbCcpO1xuICAgIH0pO1xuICAgIHRoaXMubGlzdGVuVG8oc2VsZi5tb2RlbCwgXCJwcm9maWxlOnJlbW92ZUF1dGg6c3VjY2Vzc1wiLCBmdW5jdGlvbiAoZGF0YSwgaWQpIHtcbiAgICAgIHNlbGYucmVuZGVyKCk7XG4gICAgfSk7XG4gICAgdGhpcy5saXN0ZW5UbyhzZWxmLm1vZGVsLCBcInByb2ZpbGU6aW5wdXQ6Y2hhbmdlZFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgJChcIiNwcm9maWxlLXNhdmUsICNzdWJtaXRcIikuYnV0dG9uKCdyZXNldCcpO1xuICAgICAgJChcIiNwcm9maWxlLXNhdmUsICNzdWJtaXRcIikucmVtb3ZlQXR0cihcImRpc2FibGVkXCIpO1xuICAgICAgJChcIiNwcm9maWxlLXNhdmUsICNzdWJtaXRcIikucmVtb3ZlQ2xhc3MoXCJidG4tc3VjY2Vzc1wiKTtcbiAgICAgICQoXCIjcHJvZmlsZS1zYXZlLCAjc3VibWl0XCIpLmFkZENsYXNzKFwiYnRuLWMyXCIpO1xuICAgIH0pO1xuICB9LFxuXG4gIGluaXRpYWxpemVMaWtlczogZnVuY3Rpb24oKSB7XG4gICAgJChcIiNsaWtlLW51bWJlclwiKS50ZXh0KHRoaXMubW9kZWwuYXR0cmlidXRlcy5saWtlQ291bnQpO1xuICAgIGlmIChwYXJzZUludCh0aGlzLm1vZGVsLmF0dHJpYnV0ZXMubGlrZUNvdW50KSA9PT0gMSkge1xuICAgICAgJChcIiNsaWtlLXRleHRcIikudGV4dCgkKFwiI2xpa2UtdGV4dFwiKS5kYXRhKCdzaW5ndWxhcicpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJChcIiNsaWtlLXRleHRcIikudGV4dCgkKFwiI2xpa2UtdGV4dFwiKS5kYXRhKCdwbHVyYWwnKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1vZGVsLmF0dHJpYnV0ZXMubGlrZSkge1xuICAgICAgJChcIiNsaWtlLWJ1dHRvbi1pY29uXCIpLnJlbW92ZUNsYXNzKCdmYSBmYS1zdGFyLW8nKTtcbiAgICAgICQoXCIjbGlrZS1idXR0b24taWNvblwiKS5hZGRDbGFzcygnZmEgZmEtc3RhcicpO1xuICAgIH1cbiAgfSxcblxuICBpbml0aWFsaXplU2VsZWN0MjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBmb3JtYXRSZXN1bHQgPSBmdW5jdGlvbiAob2JqZWN0LCBjb250YWluZXIsIHF1ZXJ5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWU7XG4gICAgfTtcblxuICAgIHZhciBtb2RlbEpzb24gPSB0aGlzLm1vZGVsLnRvSlNPTigpO1xuXG4gICAgdmFyIGxvY2F0aW9uU2V0dGluZ3MgPSB7XG4gICAgICBwbGFjZWhvbGRlcjogJ1NlbGVjdCBhIExvY2F0aW9uJyxcbiAgICAgIGZvcm1hdFJlc3VsdDogZm9ybWF0UmVzdWx0LFxuICAgICAgZm9ybWF0U2VsZWN0aW9uOiBmb3JtYXRSZXN1bHQsXG4gICAgICBtaW5pbXVtSW5wdXRMZW5ndGg6IDEsXG4gICAgICBkYXRhOiBbIGxvY2F0aW9uIF0sXG4gICAgICBjcmVhdGVTZWFyY2hDaG9pY2U6IGZ1bmN0aW9uICh0ZXJtLCB2YWx1ZXMpIHtcbiAgICAgICAgdmFyIHZhbHMgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlLnZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vdW5tYXRjaGVkID0gdHJ1ZSBpcyB0aGUgZmxhZyBmb3Igc2F2aW5nIHRoZXNlIFwibmV3XCIgdGFncyB0byB0YWdFbnRpdHkgd2hlbiB0aGUgb3BwIGlzIHNhdmVkXG4gICAgICAgIHJldHVybiAodmFscy5pbmRleE9mKHRlcm0udG9Mb3dlckNhc2UoKSkgPj0wKSA/IGZhbHNlIDoge1xuICAgICAgICAgIHRhZ1R5cGU6ICdsb2NhdGlvbicsXG4gICAgICAgICAgaWQ6IHRlcm0sXG4gICAgICAgICAgdmFsdWU6IHRlcm0sXG4gICAgICAgICAgdGVtcDogdHJ1ZSxcbiAgICAgICAgICBuYW1lOiBcIjxiPlwiK3Rlcm0rXCI8L2I+IDxpPnNlYXJjaCBmb3IgdGhpcyBsb2NhdGlvbjwvaT5cIlxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGFqYXg6IHtcbiAgICAgICAgdXJsOiAnL2FwaS9hYy90YWcnLFxuICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICBkYXRhOiBmdW5jdGlvbiAodGVybSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnbG9jYXRpb24nLFxuICAgICAgICAgICAgcTogdGVybVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHJlc3VsdHM6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIHsgcmVzdWx0czogZGF0YSB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgICQoXCIjY29tcGFueVwiKS5zZWxlY3QyKHtcbiAgICAgIHBsYWNlaG9sZGVyOiAnU2VsZWN0IGFuIEFnZW5jeScsXG4gICAgICBmb3JtYXRSZXN1bHQ6IGZvcm1hdFJlc3VsdCxcbiAgICAgIGZvcm1hdFNlbGVjdGlvbjogZm9ybWF0UmVzdWx0LFxuICAgICAgbWluaW11bUlucHV0TGVuZ3RoOiAyLFxuICAgICAgYWpheDoge1xuICAgICAgICB1cmw6ICcvYXBpL2FjL3RhZycsXG4gICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgIGRhdGE6IGZ1bmN0aW9uICh0ZXJtKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdhZ2VuY3knLFxuICAgICAgICAgICAgcTogdGVybVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHJlc3VsdHM6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIHsgcmVzdWx0czogZGF0YSB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKG1vZGVsSnNvbi5hZ2VuY3kpIHtcbiAgICAgICQoXCIjY29tcGFueVwiKS5zZWxlY3QyKCdkYXRhJywgbW9kZWxKc29uLmFnZW5jeS50YWcpO1xuICAgIH1cblxuICAgICQoXCIjdG9waWNzXCIpLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgc2VsZi5tb2RlbC50cmlnZ2VyKFwicHJvZmlsZTppbnB1dDpjaGFuZ2VkXCIsIGUpO1xuICAgIH0pO1xuXG4gICAgJChcIiNza2lsbHNcIikub24oJ2NoYW5nZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBzZWxmLm1vZGVsLnRyaWdnZXIoXCJwcm9maWxlOmlucHV0OmNoYW5nZWRcIiwgZSk7XG4gICAgfSk7XG5cbiAgICAkKFwiI2NvbXBhbnlcIikub24oJ2NoYW5nZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBzZWxmLm1vZGVsLnRyaWdnZXIoXCJwcm9maWxlOmlucHV0OmNoYW5nZWRcIiwgZSk7XG4gICAgfSk7XG4gICAgJCgnI2xvY2F0aW9uJykuc2VsZWN0Mihsb2NhdGlvblNldHRpbmdzKS5vbignc2VsZWN0Mi1zZWxlY3RpbmcnLCBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgJGVsID0gc2VsZi4kKGUuY3VycmVudFRhcmdldCksXG4gICAgICAgICAgZWwgPSB0aGlzO1xuICAgICAgaWYgKGUuY2hvaWNlLnRlbXApIHtcbiAgICAgICAgdGhpcy50ZW1wID0gdHJ1ZTtcbiAgICAgICAgJCgnI2xvY2F0aW9uJykuc2VsZWN0MignZGF0YScsIGUuY2hvaWNlLm5hbWUpO1xuICAgICAgICAkLmdldCgnL2FwaS9sb2NhdGlvbi9zdWdnZXN0P3E9JyArIGUuY2hvaWNlLnZhbHVlLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgZCA9IF8oZCkubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGlkOiBpdGVtLm5hbWUsXG4gICAgICAgICAgICAgIHRleHQ6IGl0ZW0ubmFtZSxcbiAgICAgICAgICAgICAgbmFtZTogaXRlbS5uYW1lLFxuICAgICAgICAgICAgICB1bm1hdGNoZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHRhZ1R5cGU6ICdsb2NhdGlvbicsXG4gICAgICAgICAgICAgIGRhdGE6IF8oaXRlbSkub21pdCgnbmFtZScpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGVsLnJlbG9hZCA9IHRydWU7XG4gICAgICAgICAgZWwub3BlbiA9IHRydWU7XG4gICAgICAgICAgJCgnI2xvY2F0aW9uJykuc2VsZWN0Mih7IGRhdGE6IGQgfSkuc2VsZWN0Mignb3BlbicpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnRlbXA7XG4gICAgICB9XG4gICAgfSkub24oJ3NlbGVjdDItb3BlbicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICghdGhpcy5yZWxvYWQgJiYgdGhpcy5vcGVuKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm9wZW47XG4gICAgICAgIGRlbGV0ZSB0aGlzLnRlbXA7XG4gICAgICAgIHZhciBjYWNoZSA9ICQoXCIjbG9jYXRpb25cIikuc2VsZWN0MignZGF0YScpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICQoXCIjbG9jYXRpb25cIikuc2VsZWN0Mihsb2NhdGlvblNldHRpbmdzKVxuICAgICAgICAgICAgLnNlbGVjdDIoJ2RhdGEnLCBjYWNoZSlcbiAgICAgICAgICAgIC5zZWxlY3QyKCdvcGVuJyk7XG4gICAgICAgIH0sIDApO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnJlbG9hZCAmJiB0aGlzLm9wZW4pIHtcbiAgICAgICAgZGVsZXRlIHRoaXMucmVsb2FkO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChtb2RlbEpzb24ubG9jYXRpb24pIHtcbiAgICAgICQoXCIjbG9jYXRpb25cIikuc2VsZWN0MignZGF0YScsIG1vZGVsSnNvbi5sb2NhdGlvbi50YWcpO1xuICAgIH1cbiAgICAkKFwiI2xvY2F0aW9uXCIpLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgc2VsZi5tb2RlbC50cmlnZ2VyKFwicHJvZmlsZTppbnB1dDpjaGFuZ2VkXCIsIGUpO1xuICAgIH0pO1xuICB9LFxuXG4gIGluaXRpYWxpemVUZXh0QXJlYTogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm1kKSB7IHRoaXMubWQuY2xlYW51cCgpOyB9XG4gICAgdGhpcy5tZCA9IG5ldyBNYXJrZG93bkVkaXRvcih7XG4gICAgICBkYXRhOiB0aGlzLm1vZGVsLnRvSlNPTigpLmJpbyxcbiAgICAgIGVsOiBcIi5tYXJrZG93bi1lZGl0XCIsXG4gICAgICBpZDogJ2JpbycsXG4gICAgICBwbGFjZWhvbGRlcjogJ0Egc2hvcnQgYmlvZ3JhcGh5LicsXG4gICAgICB0aXRsZTogJ0Jpb2dyYXBoeScsXG4gICAgICByb3dzOiA2XG4gICAgfSkucmVuZGVyKCk7XG4gIH0sXG5cbiAgZmllbGRNb2RpZmllZDogZnVuY3Rpb24gKGUpIHtcbiAgICB0aGlzLm1vZGVsLnRyaWdnZXIoXCJwcm9maWxlOmlucHV0OmNoYW5nZWRcIiwgZSk7XG4gIH0sXG5cbiAgcHJvZmlsZUNhbmNlbDogZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgQmFja2JvbmUuaGlzdG9yeS5uYXZpZ2F0ZSgncHJvZmlsZS8nICsgdGhpcy5tb2RlbC50b0pTT04oKS5pZCwgeyB0cmlnZ2VyOiB0cnVlIH0pO1xuICB9LFxuXG4gIHByb2ZpbGVTYXZlOiBmdW5jdGlvbiAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAkKFwiI3Byb2ZpbGUtZm9ybVwiKS5zdWJtaXQoKTtcbiAgfSxcblxuICBwcm9maWxlU3VibWl0OiBmdW5jdGlvbiAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAkKFwiI3Byb2ZpbGUtc2F2ZSwgI3N1Ym1pdFwiKS5idXR0b24oJ2xvYWRpbmcnKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyAkKFwiI3Byb2ZpbGUtc2F2ZSwgI3N1Ym1pdFwiKS5hdHRyKFwiZGlzYWJsZWRcIiwgXCJkaXNhYmxlZFwiKSB9LCAwKTtcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICBuYW1lOiAkKFwiI25hbWVcIikudmFsKCksXG4gICAgICAgICAgdGl0bGU6ICQoXCIjdGl0bGVcIikudmFsKCksXG4gICAgICAgICAgYmlvOiAkKFwiI2Jpb1wiKS52YWwoKVxuICAgICAgICB9LFxuICAgICAgICBlbWFpbCA9IHRoaXMubW9kZWwuZ2V0KCdlbWFpbHMnKVswXSxcbiAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoJChcIiNwcm9maWxlLWVtYWlsXCIpLnZhbCgpICE9PSBlbWFpbC5lbWFpbCkge1xuICAgICAgJC5hamF4KHtcbiAgICAgICAgdXJsOiAnL2FwaS91c2VyZW1haWwvJyArIGVtYWlsLmlkLFxuICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICBtZXRob2Q6ICdwdXQnLFxuICAgICAgICBkYXRhOiB7IGVtYWlsOiAkKFwiI3Byb2ZpbGUtZW1haWxcIikudmFsKCkgfSxcbiAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oKSB7IHNlbGYubW9kZWwudHJpZ2dlcihcInByb2ZpbGU6c2F2ZVwiLCBkYXRhKTsgfSxcbiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBtc2cgPSAnRmFpbGVkIHRvIHVwZGF0ZSB5b3VyIGVtYWlsIGFkZHJlc3MuIFBsZWFzZSB2ZXJpZnkgaXQgXFxcbiAgICAgICAgICAgICAgICAgICAgIGlzIGEgdmFsaWQgZW1haWwgYWRkcmVzcyBhbmQgdHJ5IGFnYWluLic7XG4gICAgICAgICAgJChcIiNlbWFpbC11cGRhdGUtYWxlcnRcIikuaHRtbChtc2cpO1xuICAgICAgICAgICQoXCIjZW1haWwtdXBkYXRlLWFsZXJ0XCIpLnNob3coKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubW9kZWwudHJpZ2dlcihcInByb2ZpbGU6c2F2ZVwiLCBkYXRhKTtcbiAgICB9XG4gIH0sXG5cbiAgcmVtb3ZlQXV0aDogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHZhciBub2RlID0gJChlLnRhcmdldCk7XG4gICAgLy8gd2FsayB1cCB0aGUgdHJlZSB1bnRpbCB3ZSBnZXQgdG8gdGhlIG1hcmtlZCBub2RlXG4gICAgd2hpbGUgKCEobm9kZS5oYXNDbGFzcyhcInJlbW92ZUF1dGhcIikpKSB7XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnQoKTtcbiAgICB9XG4gICAgdGhpcy5tb2RlbC50cmlnZ2VyKFwicHJvZmlsZTpyZW1vdmVBdXRoXCIsIG5vZGUuYXR0cihcImlkXCIpKTtcbiAgfSxcblxuICBsaWtlOiBmdW5jdGlvbiAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNoaWxkID0gJChlLmN1cnJlbnRUYXJnZXQpLmNoaWxkcmVuKFwiI2xpa2UtYnV0dG9uLWljb25cIik7XG4gICAgdmFyIGxpa2VudW1iZXIgPSAkKFwiI2xpa2UtbnVtYmVyXCIpO1xuICAgIC8vIE5vdCB5ZXQgbGlrZWQsIGluaXRpYXRlIGxpa2VcbiAgICBpZiAoY2hpbGQuaGFzQ2xhc3MoJ2ZhLXN0YXItbycpKSB7XG4gICAgICBjaGlsZC5yZW1vdmVDbGFzcygnZmEtc3Rhci1vJyk7XG4gICAgICBjaGlsZC5hZGRDbGFzcygnZmEgZmEtc3RhcicpO1xuICAgICAgbGlrZW51bWJlci50ZXh0KHBhcnNlSW50KGxpa2VudW1iZXIudGV4dCgpKSArIDEpO1xuICAgICAgaWYgKHBhcnNlSW50KGxpa2VudW1iZXIudGV4dCgpKSA9PT0gMSkge1xuICAgICAgICAkKFwiI2xpa2UtdGV4dFwiKS50ZXh0KCQoXCIjbGlrZS10ZXh0XCIpLmRhdGEoJ3Npbmd1bGFyJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJChcIiNsaWtlLXRleHRcIikudGV4dCgkKFwiI2xpa2UtdGV4dFwiKS5kYXRhKCdwbHVyYWwnKSk7XG4gICAgICB9XG4gICAgICAkLmFqYXgoe1xuICAgICAgICB1cmw6ICcvYXBpL2xpa2UvbGlrZXUvJyArIHNlbGYubW9kZWwuYXR0cmlidXRlcy5pZFxuICAgICAgfSkuZG9uZSggZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgLy8gbGlrZWQhXG4gICAgICAgIC8vIHJlc3BvbnNlIHNob3VsZCBiZSB0aGUgbGlrZSBvYmplY3RcbiAgICAgICAgLy8gY29uc29sZS5sb2coZGF0YS5pZCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gTGlrZWQsIGluaXRpYXRlIHVubGlrZVxuICAgIGVsc2Uge1xuICAgICAgY2hpbGQucmVtb3ZlQ2xhc3MoJ2ZhLXN0YXInKTtcbiAgICAgIGNoaWxkLmFkZENsYXNzKCdmYS1zdGFyLW8nKTtcbiAgICAgIGxpa2VudW1iZXIudGV4dChwYXJzZUludChsaWtlbnVtYmVyLnRleHQoKSkgLSAxKTtcbiAgICAgIGlmIChwYXJzZUludChsaWtlbnVtYmVyLnRleHQoKSkgPT09IDEpIHtcbiAgICAgICAgJChcIiNsaWtlLXRleHRcIikudGV4dCgkKFwiI2xpa2UtdGV4dFwiKS5kYXRhKCdzaW5ndWxhcicpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICQoXCIjbGlrZS10ZXh0XCIpLnRleHQoJChcIiNsaWtlLXRleHRcIikuZGF0YSgncGx1cmFsJykpO1xuICAgICAgfVxuICAgICAgJC5hamF4KHtcbiAgICAgICAgdXJsOiAnL2FwaS9saWtlL3VubGlrZXUvJyArIHNlbGYubW9kZWwuYXR0cmlidXRlcy5pZFxuICAgICAgfSkuZG9uZSggZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgLy8gdW4tbGlrZWQhXG4gICAgICAgIC8vIHJlc3BvbnNlIHNob3VsZCBiZSBudWxsIChlbXB0eSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgY2xlYW51cDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm1kKSB7IHRoaXMubWQuY2xlYW51cCgpOyB9XG4gICAgaWYgKHRoaXMudGFnVmlldykgeyB0aGlzLnRhZ1ZpZXcuY2xlYW51cCgpOyB9XG4gICAgaWYgKHRoaXMucHJvamVjdFZpZXcpIHsgdGhpcy5wcm9qZWN0Vmlldy5jbGVhbnVwKCk7IH1cbiAgICBpZiAodGhpcy50YXNrVmlldykgeyB0aGlzLnRhc2tWaWV3LmNsZWFudXAoKTsgfVxuICAgIGlmICh0aGlzLnZvbFZpZXcpIHsgdGhpcy52b2xWaWV3LmNsZWFudXAoKTsgfVxuICAgIHJlbW92ZVZpZXcodGhpcyk7XG4gIH0sXG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb2ZpbGVTaG93VmlldztcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8Zm9ybSBhY3Rpb249XFxcIlxcXCIgaWQ9XFxcInByb2plY3QtZm9ybVxcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1ib2R5XFxcIj5cXG4gICAgPGZpZWxkc2V0PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwicHJvamVjdC1mb3JtLXRpdGxlXFxcIj48c3BhbiBkYXRhLWkxOG49XFxcIlByb2plY3RcXFwiPlByb2plY3Q8L3NwYW4+IFRpdGxlPC9sYWJlbD5cXG4gICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBjbGFzcz1cXFwicHJvamVjdC10aXRsZS1mb3JtIGZvcm0tY29udHJvbFxcXCIgaWQ9XFxcInByb2plY3QtZm9ybS10aXRsZVxcXCIgbmFtZT1cXFwicHJvamVjdC1mb3JtLXRpdGxlXFxcIiBwbGFjZWhvbGRlcj1cXFwiVGl0bGVcXFwiIGRhdGEtdmFsaWRhdGU9XFxcImVtcHR5LGNvdW50MTAwXFxcIj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJoZWxwLWJsb2NrIGVycm9yLWVtcHR5XFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI+WW91IG11c3QgZW50ZXIgYSB0aXRsZS48L3NwYW4+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaGVscC1ibG9jayBlcnJvci1jb3VudDEwMFxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPlRoZSB0aXRsZSBtdXN0IGJlIGxlc3MgdGhhbiAxMDAgY2hhcmFjdGVycy48L3NwYW4+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJwcm9qZWN0LWZvcm0tZGVzY3JpcHRpb25cXFwiPjxzcGFuIGRhdGEtaTE4bj1cXFwiUHJvamVjdFxcXCI+UHJvamVjdDwvc3Bhbj4gRGVzY3JpcHRpb248L2xhYmVsPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwibWFya2Rvd24tZWRpdFxcXCI+PC9kaXY+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaGVscC1ibG9jayBlcnJvci1lbXB0eVxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPllvdSBtdXN0IGVudGVyIGEgZGVzY3JpcHRpb24uPC9zcGFuPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2ZpZWxkc2V0PlxcbiAgPC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1mb290ZXJcXFwiPlxcbiAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tYzBcXFwiIGRhdGEtZGlzbWlzcz1cXFwibW9kYWxcXFwiPkNhbmNlbDwvYnV0dG9uPlxcbiAgICA8aW5wdXQgdHlwZT1cXFwic3VibWl0XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1jMiBidG4tYWRkLXByb2plY3RcXFwiIGlkPVxcXCJzdWJtaXRcXFwiIHZhbHVlPVxcXCJBZGQgUHJvamVjdFxcXCIvPlxcbiAgPC9kaXY+XFxuPC9mb3JtPlxcblwiO1xuIiwidmFyIEJvb3RzdHJhcCA9IHJlcXVpcmUoJ2Jvb3RzdHJhcCcpO1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vbWl4aW5zL3V0aWxpdGllcycpO1xudmFyIE1hcmtkb3duRWRpdG9yID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29tcG9uZW50cy9tYXJrZG93bl9lZGl0b3InKTtcbnZhciBQcm9qZWN0c0NvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9lbnRpdGllcy9wcm9qZWN0cy9wcm9qZWN0c19jb2xsZWN0aW9uJyk7XG52YXIgUHJvamVjdEZvcm1UZW1wbGF0ZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy9wcm9qZWN0X25ld19mb3JtX3RlbXBsYXRlLmh0bWwnKTtcblxuXG52YXIgUHJvamVjdEZvcm1WaWV3ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuXG4gIGV2ZW50czoge1xuICAgIFwiYmx1ciAjcHJvamVjdC1mb3JtLXRpdGxlXCIgICAgICA6IFwidlwiLFxuICAgIFwiYmx1ciAjcHJvamVjdC1mb3JtLWRlc2NyaXB0aW9uXCI6IFwidlwiLFxuICAgIFwic3VibWl0ICNwcm9qZWN0LWZvcm1cIiAgICAgICAgICA6IFwicG9zdFwiXG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZShQcm9qZWN0Rm9ybVRlbXBsYXRlKTtcbiAgICB0aGlzLiRlbC5odG1sKHRlbXBsYXRlKTtcblxuICAgIHRoaXMuJGVsLmkxOG4oKTtcbiAgICB0aGlzLmluaXRpYWxpemVUZXh0QXJlYSgpO1xuICAgIHRoaXMuJChcIi5idG4tYWRkLXByb2plY3RcIikudmFsKCdBZGQgJyArIGkxOG4udCgnUHJvamVjdCcpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICB2OiBmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiB2YWxpZGF0ZShlKTtcbiAgfSxcblxuICBpbml0aWFsaXplVGV4dEFyZWE6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5tZCkgeyB0aGlzLm1kLmNsZWFudXAoKTsgfVxuICAgIHRoaXMubWQgPSBuZXcgTWFya2Rvd25FZGl0b3Ioe1xuICAgICAgZGF0YTogJycsXG4gICAgICBlbDogXCIubWFya2Rvd24tZWRpdFwiLFxuICAgICAgaWQ6ICdwcm9qZWN0LWZvcm0tZGVzY3JpcHRpb24nLFxuICAgICAgcGxhY2Vob2xkZXI6ICdBIGRlc2NyaXB0aW9uIG9mIHlvdXIgJyArIGkxOG4udCgncHJvamVjdCcpICsgJyB0aGF0IGV4cGxhaW5zIHRoZSBmb2N1cywgb2JqZWN0aXZlcywgYW5kIGRlbGl2ZXJhYmxlcy4nLFxuICAgICAgdGl0bGU6IGkxOG4udCgnUHJvamVjdCcpICsgJyBEZXNjcmlwdGlvbicsXG4gICAgICByb3dzOiA2LFxuICAgICAgdmFsaWRhdGU6IFsnZW1wdHknXVxuICAgIH0pLnJlbmRlcigpO1xuICB9LFxuXG4gIHBvc3Q6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIC8vIHZhbGlkYXRlIGlucHV0IGZpZWxkc1xuICAgIHZhciB2YWxpZGF0ZUlkcyA9IFsnI3Byb2plY3QtZm9ybS10aXRsZScsICcjcHJvamVjdC1mb3JtLWRlc2NyaXB0aW9uJ107XG4gICAgdmFyIGFib3J0ID0gZmFsc2U7XG4gICAgZm9yIChpIGluIHZhbGlkYXRlSWRzKSB7XG4gICAgICB2YXIgaUFib3J0ID0gdmFsaWRhdGUoeyBjdXJyZW50VGFyZ2V0OiB2YWxpZGF0ZUlkc1tpXSB9KTtcbiAgICAgIGFib3J0ID0gYWJvcnQgfHwgaUFib3J0O1xuICAgIH1cbiAgICBpZiAoYWJvcnQgPT09IHRydWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBwcm9jZXNzIHByb2plY3QgZm9ybVxuICAgIHZhciBkYXRhO1xuICAgIGRhdGEgPSB7XG4gICAgICB0aXRsZSAgICAgICA6IHRoaXMuJChcIi5wcm9qZWN0LXRpdGxlLWZvcm1cIikudmFsKCksXG4gICAgICBkZXNjcmlwdGlvbiA6IHRoaXMuJChcIiNwcm9qZWN0LWZvcm0tZGVzY3JpcHRpb25cIikudmFsKClcbiAgICB9O1xuXG4gICAgdGhpcy5jb2xsZWN0aW9uLnRyaWdnZXIoXCJwcm9qZWN0OnNhdmVcIiwgZGF0YSk7XG4gIH0sXG5cbiAgY2xlYW51cDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm1kKSB7IHRoaXMubWQuY2xlYW51cCgpOyB9XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9qZWN0Rm9ybVZpZXc7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBhc3luYyA9IHJlcXVpcmUoJ2FzeW5jJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vbWl4aW5zL3V0aWxpdGllcycpO1xudmFyIFBvcG92ZXJzID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vbWl4aW5zL3BvcG92ZXJzJyk7XG52YXIgQmFzZUNvbnRyb2xsZXIgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9iYXNlL2Jhc2VfY29udHJvbGxlcicpO1xudmFyIFByb2plY3RJdGVtVmlldyA9IHJlcXVpcmUoJy4uL3ZpZXdzL3Byb2plY3RfaXRlbV92aWV3Jyk7XG52YXIgUHJvamVjdEl0ZW1Db3JlTWV0YVZpZXcgPSByZXF1aXJlKCcuLi92aWV3cy9wcm9qZWN0X2l0ZW1fY29yZW1ldGFfdmlldycpO1xudmFyIFByb2plY3Rvd25lclNob3dWaWV3ID0gcmVxdWlyZSgnLi4vLi4vLi4vcHJvamVjdG93bmVyL3Nob3cvdmlld3MvcHJvamVjdG93bmVyX3Nob3dfdmlldycpO1xudmFyIEF0dGFjaG1lbnRWaWV3ID0gcmVxdWlyZSgnLi4vLi4vLi4vYXR0YWNobWVudC92aWV3cy9hdHRhY2htZW50X3Nob3dfdmlldycpO1xudmFyIFRhc2tMaXN0Q29udHJvbGxlciA9IHJlcXVpcmUoJy4uLy4uLy4uL3Rhc2tzL2xpc3QvY29udHJvbGxlcnMvdGFza19saXN0X2NvbnRyb2xsZXInKTtcbnZhciBFdmVudExpc3RDb250cm9sbGVyID0gcmVxdWlyZSgnLi4vLi4vLi4vZXZlbnRzL2xpc3QvY29udHJvbGxlcnMvZXZlbnRfbGlzdF9jb250cm9sbGVyJyk7XG52YXIgQ29tbWVudExpc3RDb250cm9sbGVyID0gcmVxdWlyZSgnLi4vLi4vLi4vY29tbWVudHMvbGlzdC9jb250cm9sbGVycy9jb21tZW50X2xpc3RfY29udHJvbGxlcicpO1xudmFyIENvbW1lbnRGb3JtVmlldyA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbW1lbnRzL25ldy92aWV3cy9jb21tZW50X2Zvcm1fdmlldycpO1xudmFyIE1vZGFsQ29tcG9uZW50ID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29tcG9uZW50cy9tb2RhbCcpO1xudmFyIE1vZGFsQWxlcnQgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb21wb25lbnRzL21vZGFsX2FsZXJ0Jyk7XG52YXIgVGFza01vZGVsID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vZW50aXRpZXMvdGFza3MvdGFza19tb2RlbCcpO1xudmFyIFByb2plY3RPcGVuVGFza3NXYXJuaW5nVGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvcHJvamVjdF9vcGVuX3Rhc2tzX3dhcm5pbmdfdGVtcGxhdGUuaHRtbCcpO1xuXG5cbnZhciBwb3BvdmVycyA9IG5ldyBQb3BvdmVycygpO1xuXG5Qcm9qZWN0ID0ge307XG5cblByb2plY3QuU2hvd0NvbnRyb2xsZXIgPSBCYXNlQ29udHJvbGxlci5leHRlbmQoe1xuXG4gIGVsOiBcIiNjb250YWluZXJcIixcblxuICAvLyBTZXQgdGhlIG1vZGVsIHRvIG51bGwsIGJlZm9yZSBpdCBpcyBmZXRjaGVkIGZyb20gdGhlIHNlcnZlci5cbiAgLy8gVGhpcyBhbGxvd3MgdXMgdG8gY2xlYXIgb3V0IHRoZSBwcmV2aW91cyBkYXRhIGZyb20gdGhlIGxpc3RfdmlldyxcbiAgLy8gYW5kIGdldCByZWFkeSBmb3IgdGhlIG5ldyBkYXRhIGZvciB0aGUgcHJvamVjdCBzaG93IHZpZXcuXG4gIG1vZGVsOiBudWxsLFxuXG4gIGV2ZW50czoge1xuICAgIFwiY2xpY2sgI2xpa2UtYnV0dG9uXCIgICAgICAgICAgICAgIDogXCJsaWtlXCIsXG4gICAgXCJrZXl1cCAuY29tbWVudC1jb250ZW50XCIgICAgICAgICAgOiBcInNlYXJjaFwiLFxuICAgIFwiY2xpY2sgI3RhZy1zYXZlXCIgICAgICAgICAgICAgICAgIDogXCJ0YWdTYXZlXCIsXG4gICAgXCJjbGljayAjdGFnLWNyZWF0ZVwiICAgICAgICAgICAgICAgOiBcInRhZ0NyZWF0ZVwiLFxuICAgIFwiY2xpY2sgLnRhZy1kZWxldGVcIiAgICAgICAgICAgICAgIDogXCJ0YWdEZWxldGVcIixcbiAgICBcImNsaWNrICNwcm9qZWN0LWNsb3NlXCIgICAgICAgICAgICA6IFwic3RhdGVDbG9zZVwiLFxuICAgIFwiY2xpY2sgI3Byb2plY3QtcmVvcGVuXCIgICAgICAgICAgIDogXCJzdGF0ZVJlb3BlblwiLFxuICAgICdjbGljayAjZWRpdFByb2plY3QnICAgICAgICAgICAgICA6ICd0b2dnbGVFZGl0TW9kZScsXG4gICAgXCJtb3VzZWVudGVyIC5wcm9qZWN0LXBlb3BsZS1kaXZcIiAgOiBwb3BvdmVycy5wb3BvdmVyUGVvcGxlT24sXG4gICAgXCJjbGljayAucHJvamVjdC1wZW9wbGUtZGl2XCIgICAgICAgOiBwb3BvdmVycy5wb3BvdmVyQ2xpY2tcbiAgfSxcblxuICAvLyBUaGUgaW5pdGlhbGl6ZSBtZXRob2QgaXMgbWFpbmx5IHVzZWQgZm9yIGV2ZW50IGJpbmRpbmdzIChmb3IgZWZmZWNpZW5jeSlcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLnJvdXRlciA9IG9wdGlvbnMucm91dGVyO1xuICAgIHRoaXMuaWQgPSBvcHRpb25zLmlkO1xuICAgIHRoaXMuZGF0YSA9IG9wdGlvbnMuZGF0YTtcbiAgICB0aGlzLmFjdGlvbiA9IG9wdGlvbnMuYWN0aW9uO1xuXG4gICAgdGhpcy5tb2RlbC50cmlnZ2VyKFwicHJvamVjdDptb2RlbDpmZXRjaFwiLCB0aGlzLm1vZGVsLmlkKTtcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsIFwicHJvamVjdDptb2RlbDpmZXRjaDpzdWNjZXNzXCIsIGZ1bmN0aW9uIChwcm9qZWN0TW9kZWwpIHtcbiAgICAgIHNlbGYubW9kZWwgPSBwcm9qZWN0TW9kZWw7XG4gICAgICBpZiAoc2VsZi5hY3Rpb24gPT0gJ2VkaXQnKSB7XG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWwudG9KU09OKCk7XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSB1c2VyIG93bnMgdGhlIHRhc2tcbiAgICAgICAgdmFyIG93bmVyID0gbW9kZWwuaXNPd25lcjtcbiAgICAgICAgaWYgKG93bmVyICE9PSB0cnVlKSB7XG4gICAgICAgICAgLy8gaWYgbm9uZSBvZiB0aGVzZSBhcHBseSwgYXJlIHRoZXkgYW4gYWRtaW4/XG4gICAgICAgICAgaWYgKHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlcikge1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlci5pc0FkbWluID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIG93bmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgbm90IHRoZSBvd25lciwgdHJpZ2dlciB0aGUgbG9naW4gZGlhbG9nLlxuICAgICAgICBpZiAob3duZXIgIT09IHRydWUpIHtcbiAgICAgICAgICB3aW5kb3cuY2FjaGUudXNlckV2ZW50cy50cmlnZ2VyKFwidXNlcjpyZXF1ZXN0OmxvZ2luXCIsIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiWW91IGFyZSBub3QgdGhlIG93bmVyIG9mIHRoaXMgcHJvamVjdC4gPGEgY2xhc3M9J2xpbmstYmFja2JvbmUnIGhyZWY9Jy9wcm9qZWN0cy9cIiArIG1vZGVsLmlkICsgXCInPlZpZXcgdGhlIHByb2plY3QgaW5zdGVhZC48L2E+XCIsXG4gICAgICAgICAgICBkaXNhYmxlQ2xvc2U6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNlbGYuaW5pdGlhbGl6ZUl0ZW1WaWV3KCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLm1vZGVsLm9uKFwicHJvamVjdDpzaG93OnJlbmRlcmVkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuaW5pdGlhbGl6ZUl0ZW1Db3JlTWV0YVZpZXcoKTtcbiAgICAgIHNlbGYuaW5pdGlhbGl6ZU93bmVycygpO1xuICAgICAgc2VsZi5pbml0aWFsaXplSXRlbVZpZXdDb250cm9sbGVycygpO1xuICAgICAgc2VsZi5pbml0aWFsaXplSGFuZGxlcnMoKTtcbiAgICAgIHNlbGYuaW5pdGlhbGl6ZUxpa2VzKCk7XG4gICAgICBzZWxmLmluaXRpYWxpemVVSSgpO1xuICAgIH0pO1xuICB9LFxuXG4gIGluaXRpYWxpemVJdGVtVmlldzogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnByb2plY3RTaG93SXRlbVZpZXcpIHRoaXMucHJvamVjdFNob3dJdGVtVmlldy5jbGVhbnVwKCk7XG4gICAgdGhpcy5wcm9qZWN0U2hvd0l0ZW1WaWV3ICA9IG5ldyBQcm9qZWN0SXRlbVZpZXcoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IHRoaXMuYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkucmVuZGVyKCk7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZUl0ZW1Db3JlTWV0YVZpZXc6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5wcm9qZWN0U2hvd0l0ZW1Db3JlTWV0YVZpZXcpIHRoaXMucHJvamVjdFNob3dJdGVtQ29yZU1ldGFWaWV3LmNsZWFudXAoKTtcbiAgICB0aGlzLnByb2plY3RTaG93SXRlbUNvcmVNZXRhVmlldyAgPSBuZXcgUHJvamVjdEl0ZW1Db3JlTWV0YVZpZXcoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IHRoaXMuYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLnJlbmRlcigpO1xuICB9LFxuXG5cbiAgaW5pdGlhbGl6ZU93bmVycyA6IGZ1bmN0aW9uKCl7XG4gICAgaWYgKHRoaXMucHJvamVjdG93bmVyU2hvd1ZpZXcpIHRoaXMucHJvamVjdG93bmVyU2hvd1ZpZXcuY2xlYW51cCgpO1xuICAgIHRoaXMucHJvamVjdG93bmVyU2hvd1ZpZXcgPSBuZXcgUHJvamVjdG93bmVyU2hvd1ZpZXcoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IHRoaXMuYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLnJlbmRlcigpO1xuICB9LFxuXG4gIGluaXRpYWxpemVJdGVtVmlld0NvbnRyb2xsZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuYWN0aW9uICE9ICdlZGl0Jykge1xuICAgICAgLy8gVGFza3NcbiAgICAgIGlmICh0aGlzLnRhc2tMaXN0Q29udHJvbGxlcikgdGhpcy50YXNrTGlzdENvbnRyb2xsZXIuY2xlYW51cCgpO1xuICAgICAgdGhpcy50YXNrTGlzdENvbnRyb2xsZXIgPSBuZXcgVGFza0xpc3RDb250cm9sbGVyKHtcbiAgICAgICAgcHJvamVjdElkOiB0aGlzLm1vZGVsLmlkXG4gICAgICB9KTtcblxuICAgICAgLy8gRXZlbnRzXG4gICAgICBpZiAodGhpcy5ldmVudExpc3RDb250cm9sbGVyKSB0aGlzLmV2ZW50TGlzdENvbnRyb2xsZXIuY2xlYW51cCgpO1xuICAgICAgdGhpcy5ldmVudExpc3RDb250cm9sbGVyID0gbmV3IEV2ZW50TGlzdENvbnRyb2xsZXIoe1xuICAgICAgICBwcm9qZWN0SWQ6IHRoaXMubW9kZWwuaWRcbiAgICAgIH0pO1xuICAgICAgLy8gQ29tbWVudHNcbiAgICAgIGlmICh0aGlzLmNvbW1lbnRMaXN0Q29udHJvbGxlcikgdGhpcy5jb21tZW50TGlzdENvbnRyb2xsZXIuY2xlYW51cCgpO1xuICAgICAgdGhpcy5jb21tZW50TGlzdENvbnRyb2xsZXIgPSBuZXcgQ29tbWVudExpc3RDb250cm9sbGVyKHtcbiAgICAgICAgdGFyZ2V0OiAncHJvamVjdCcsXG4gICAgICAgIGlkOiB0aGlzLm1vZGVsLmlkXG4gICAgICB9KTtcbiAgICAgIC8vIEF0dGFjaG1lbnRzXG4gICAgICBpZiAodGhpcy5hdHRhY2htZW50VmlldykgdGhpcy5hdHRhY2htZW50Vmlldy5jbGVhbnVwKCk7XG4gICAgICB0aGlzLmF0dGFjaG1lbnRWaWV3ID0gbmV3IEF0dGFjaG1lbnRWaWV3KHtcbiAgICAgICAgdGFyZ2V0OiAncHJvamVjdCcsXG4gICAgICAgIGlkOiB0aGlzLm1vZGVsLmF0dHJpYnV0ZXMuaWQsXG4gICAgICAgIGFjdGlvbjogdGhpcy5hY3Rpb24sXG4gICAgICAgIGRhdGE6IHRoaXMuZGF0YSxcbiAgICAgICAgb3duZXI6IHRoaXMubW9kZWwuYXR0cmlidXRlcy5pc093bmVyLFxuICAgICAgICBlbDogJy5hdHRhY2htZW50LXdyYXBwZXInXG4gICAgICB9KS5yZW5kZXIoKTtcbiAgICB9XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZUxpa2VzOiBmdW5jdGlvbigpIHtcbiAgICAkKFwiI2xpa2UtbnVtYmVyXCIpLnRleHQodGhpcy5tb2RlbC5hdHRyaWJ1dGVzLmxpa2VDb3VudCk7XG4gICAgaWYgKHBhcnNlSW50KHRoaXMubW9kZWwuYXR0cmlidXRlcy5saWtlQ291bnQpID09PSAxKSB7XG4gICAgICAkKFwiI2xpa2UtdGV4dFwiKS50ZXh0KCQoXCIjbGlrZS10ZXh0XCIpLmRhdGEoJ3Npbmd1bGFyJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkKFwiI2xpa2UtdGV4dFwiKS50ZXh0KCQoXCIjbGlrZS10ZXh0XCIpLmRhdGEoJ3BsdXJhbCcpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubW9kZWwuYXR0cmlidXRlcy5saWtlKSB7XG4gICAgICAkKFwiI2xpa2UtYnV0dG9uLWljb25cIikucmVtb3ZlQ2xhc3MoJ2ZhLXN0YXItbycpO1xuICAgICAgJChcIiNsaWtlLWJ1dHRvbi1pY29uXCIpLmFkZENsYXNzKCdmYSBmYS1zdGFyJyk7XG4gICAgfVxuICB9LFxuXG4gIGluaXRpYWxpemVIYW5kbGVyczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCBcInByb2plY3Q6dXBkYXRlOnN0YXRlOnN1Y2Nlc3NcIiwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIGlmIChkYXRhLmF0dHJpYnV0ZXMuc3RhdGUgPT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgJChcIiNsaS1wcm9qZWN0LWNsb3NlXCIpLmhpZGUoKTtcbiAgICAgICAgJChcIiNsaS1wcm9qZWN0LXJlb3BlblwiKS5zaG93KCk7XG4gICAgICAgICQoXCIjYWxlcnQtY2xvc2VkXCIpLnNob3coKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICQoXCIjbGktcHJvamVjdC1jbG9zZVwiKS5zaG93KCk7XG4gICAgICAgICQoXCIjbGktcHJvamVjdC1yZW9wZW5cIikuaGlkZSgpO1xuICAgICAgICAkKFwiI2FsZXJ0LWNsb3NlZFwiKS5oaWRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZVVJOiBmdW5jdGlvbigpIHtcbiAgICBwb3BvdmVycy5wb3BvdmVyUGVvcGxlSW5pdChcIi5wcm9qZWN0LXBlb3BsZS1kaXZcIik7XG4gIH0sXG5cbiAgdG9nZ2xlRWRpdE1vZGU6IGZ1bmN0aW9uKGUpe1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIGFjdGlvbiA9ICcnO1xuICAgIGlmICghKHRoaXMuYWN0aW9uICYmIHRoaXMuYWN0aW9uID09ICdlZGl0JykpIHtcbiAgICAgIGFjdGlvbiA9ICcvZWRpdCc7XG4gICAgfVxuICAgIEJhY2tib25lLmhpc3RvcnkubmF2aWdhdGUoJ3Byb2plY3RzLycgKyB0aGlzLmlkICsgYWN0aW9uLCB7IHRyaWdnZXI6IHRydWUgfSk7XG4gIH0sXG5cbiAgc3RhdGVDbG9zZTogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBwcm9qZWN0VGFza3MgPSBzZWxmLm1vZGVsLmhhc09wZW5UYXNrcyhzZWxmLnRhc2tMaXN0Q29udHJvbGxlci5jb2xsZWN0aW9uKTtcbiAgICBpZiAodGhpcy5tb2RhbEFsZXJ0KSB7IHRoaXMubW9kYWxBbGVydC5jbGVhbnVwKCk7IH1cbiAgICBpZiAodGhpcy5tb2RhbENvbXBvbmVudCkgeyB0aGlzLm1vZGFsQ29tcG9uZW50LmNsZWFudXAoKTsgfVxuICAgIHRoaXMubW9kYWxDb21wb25lbnQgPSBuZXcgTW9kYWxDb21wb25lbnQoe1xuICAgICAgZWw6IFwiI21vZGFsLWNsb3NlXCIsXG4gICAgICBpZDogXCJjaGVjay1jbG9zZVwiLFxuICAgICAgbW9kYWxUaXRsZTogXCJDbG9zZSBcIitpMThuLnQoXCJQcm9qZWN0XCIpXG4gICAgfSkucmVuZGVyKCk7XG5cbiAgICB2YXIgY291bnQgPSAwO1xuICAgIGlmICggcHJvamVjdFRhc2tzLmhhc09wZW5UYXNrcyApe1xuICAgICAgdmFyIG1vZGFsQ29udGVudCA9IF8udGVtcGxhdGUoUHJvamVjdE9wZW5UYXNrc1dhcm5pbmdUZW1wbGF0ZSkoe2NvdW50OiBwcm9qZWN0VGFza3MuY291bnR9KTtcbiAgICAgIHZhciBzdWJtaXRMYWJlbCA9IFwiSSBVbmRlcnN0YW5kIGFuZCBXYW50IHRvIENsb3NlIFRoaXMgXCIraTE4bi50KFwiUHJvamVjdFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1vZGFsQ29udGVudCA9ICc8cD5BcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gY2xvc2UgdGhpcyAnK2kxOG4udChcInByb2plY3RcIikrJz8gIE9uY2UgdGhlICcraTE4bi50KFwicHJvamVjdFwiKSsnIGlzIGNsb3NlZCwgcGFydGljaXBhbnRzIHdpbGwgbm8gbG9uZ2VyIGJlIGFibGUgdG8gY29udHJpYnV0ZS48L3A+JztcbiAgICAgIHZhciBzdWJtaXRMYWJlbCA9IFwiQ2xvc2UgXCIraTE4bi50KFwiUHJvamVjdFwiKTtcbiAgICB9XG5cbiAgICB0aGlzLm1vZGFsQWxlcnQgPSBuZXcgTW9kYWxBbGVydCh7XG4gICAgICBlbDogXCIjY2hlY2stY2xvc2UgLm1vZGFsLXRlbXBsYXRlXCIsXG4gICAgICBtb2RhbERpdjogJyNjaGVjay1jbG9zZScsXG4gICAgICBjb250ZW50OiBtb2RhbENvbnRlbnQsXG4gICAgICBjYW5jZWw6ICdDYW5jZWwnLFxuICAgICAgc3VibWl0OiBzdWJtaXRMYWJlbCxcbiAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAvLyB1c2VyIGNsaWNrZWQgdGhlIHN1Ym1pdCBidXR0b25cbiAgICAgICAgaWYgKCBwcm9qZWN0VGFza3MuaGFzT3BlblRhc2tzICkgeyBzZWxmLm1vZGVsLnRyaWdnZXIoXCJwcm9qZWN0OnVwZGF0ZTp0YXNrczpvcnBoYW5cIixzZWxmLnRhc2tMaXN0Q29udHJvbGxlci5jb2xsZWN0aW9uKTsgfVxuICAgICAgICBzZWxmLm1vZGVsLnRyaWdnZXIoXCJwcm9qZWN0OnVwZGF0ZTpzdGF0ZVwiLCAnY2xvc2VkJyk7XG4gICAgICAgIHNlbGYuaW5pdGlhbGl6ZUl0ZW1WaWV3KCk7XG4gICAgICB9XG4gICAgfSkucmVuZGVyKCk7XG4gIH0sXG5cbiAgc3RhdGVSZW9wZW46IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLm1vZGVsLnRyaWdnZXIoXCJwcm9qZWN0OnVwZGF0ZTpzdGF0ZVwiLCAnb3BlbicpO1xuICB9LFxuXG4gIGxpa2U6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNoaWxkID0gJChlLmN1cnJlbnRUYXJnZXQpLmNoaWxkcmVuKFwiI2xpa2UtYnV0dG9uLWljb25cIik7XG4gICAgdmFyIGxpa2VudW1iZXIgPSAkKFwiI2xpa2UtbnVtYmVyXCIpO1xuICAgIC8vIE5vdCB5ZXQgbGlrZWQsIGluaXRpYXRlIGxpa2VcbiAgICBpZiAoY2hpbGQuaGFzQ2xhc3MoJ2ZhLXN0YXItbycpKSB7XG4gICAgICBjaGlsZC5yZW1vdmVDbGFzcygnZmEtc3Rhci1vJyk7XG4gICAgICBjaGlsZC5hZGRDbGFzcygnZmEgZmEtc3RhcicpO1xuICAgICAgbGlrZW51bWJlci50ZXh0KHBhcnNlSW50KGxpa2VudW1iZXIudGV4dCgpKSArIDEpO1xuICAgICAgaWYgKHBhcnNlSW50KGxpa2VudW1iZXIudGV4dCgpKSA9PT0gMSkge1xuICAgICAgICAkKFwiI2xpa2UtdGV4dFwiKS50ZXh0KCQoXCIjbGlrZS10ZXh0XCIpLmRhdGEoJ3Npbmd1bGFyJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJChcIiNsaWtlLXRleHRcIikudGV4dCgkKFwiI2xpa2UtdGV4dFwiKS5kYXRhKCdwbHVyYWwnKSk7XG4gICAgICB9XG4gICAgICAkLmFqYXgoe1xuICAgICAgICB1cmw6ICcvYXBpL2xpa2UvbGlrZS8nICsgdGhpcy5tb2RlbC5hdHRyaWJ1dGVzLmlkXG4gICAgICB9KS5kb25lKCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAvLyBsaWtlZCFcbiAgICAgICAgLy8gcmVzcG9uc2Ugc2hvdWxkIGJlIHRoZSBsaWtlIG9iamVjdFxuICAgICAgICAvLyBjb25zb2xlLmxvZyhkYXRhLmlkKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBMaWtlZCwgaW5pdGlhdGUgdW5saWtlXG4gICAgZWxzZSB7XG4gICAgICBjaGlsZC5yZW1vdmVDbGFzcygnZmEtc3RhcicpO1xuICAgICAgY2hpbGQuYWRkQ2xhc3MoJ2ZhLXN0YXItbycpO1xuICAgICAgbGlrZW51bWJlci50ZXh0KHBhcnNlSW50KGxpa2VudW1iZXIudGV4dCgpKSAtIDEpO1xuICAgICAgaWYgKHBhcnNlSW50KGxpa2VudW1iZXIudGV4dCgpKSA9PT0gMSkge1xuICAgICAgICAkKFwiI2xpa2UtdGV4dFwiKS50ZXh0KCQoXCIjbGlrZS10ZXh0XCIpLmRhdGEoJ3Npbmd1bGFyJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJChcIiNsaWtlLXRleHRcIikudGV4dCgkKFwiI2xpa2UtdGV4dFwiKS5kYXRhKCdwbHVyYWwnKSk7XG4gICAgICB9XG4gICAgICAkLmFqYXgoe1xuICAgICAgICB1cmw6ICcvYXBpL2xpa2UvdW5saWtlLycgKyB0aGlzLm1vZGVsLmF0dHJpYnV0ZXMuaWRcbiAgICAgIH0pLmRvbmUoIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIC8vIHVuLWxpa2VkIVxuICAgICAgICAvLyByZXNwb25zZSBzaG91bGQgYmUgbnVsbCAoZW1wdHkpXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vPSBVdGlsaXR5IE1ldGhvZHNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGNsZWFudXA6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnByb2plY3RTaG93SXRlbUNvcmVNZXRhVmlldykgdGhpcy5wcm9qZWN0U2hvd0l0ZW1Db3JlTWV0YVZpZXcuY2xlYW51cCgpO1xuICAgIGlmICh0aGlzLnRhc2tMaXN0Q29udHJvbGxlcikgdGhpcy50YXNrTGlzdENvbnRyb2xsZXIuY2xlYW51cCgpO1xuICAgIGlmICh0aGlzLmV2ZW50TGlzdENvbnRyb2xsZXIpIHRoaXMuZXZlbnRMaXN0Q29udHJvbGxlci5jbGVhbnVwKCk7XG4gICAgaWYgKHRoaXMuY29tbWVudExpc3RDb250cm9sbGVyKSB0aGlzLmNvbW1lbnRMaXN0Q29udHJvbGxlci5jbGVhbnVwKCk7XG4gICAgaWYgKHRoaXMucHJvamVjdFNob3dJdGVtVmlldykgdGhpcy5wcm9qZWN0U2hvd0l0ZW1WaWV3LmNsZWFudXAoKTtcbiAgICBpZiAodGhpcy5wcm9qZWN0b3duZXJTaG93VmlldykgdGhpcy5wcm9qZWN0b3duZXJTaG93Vmlldy5jbGVhbnVwKCk7XG4gICAgaWYgKHRoaXMuYXR0YWNobWVudFZpZXcpIHRoaXMuYXR0YWNobWVudFZpZXcuY2xlYW51cCgpO1xuICAgIHJlbW92ZVZpZXcodGhpcyk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvamVjdC5TaG93Q29udHJvbGxlcjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGlkPVxcXCJwcm9qZWN0LWNvcmVtZXRhLXNob3dcXFwiIGNsYXNzPVxcXCJjb3JlbWV0YS1mb3JtLXRvZ2dsZVxcXCI+XFxuXFxuICAgIDxoMT48JT0gZGF0YS50aXRsZSAlPjwvaDE+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInByb2plY3QtZGVzY3JpcHRpb25cXFwiPlxcbiAgICAgIDwlPSBkYXRhLmRlc2NyaXB0aW9uSHRtbCAlPlxcbiAgICA8L2Rpdj5cXG5cXG5cXG48L2Rpdj4gPCEtLSAvbWFpbi1zZWN0aW9uIC0tPlxcbjxkaXYgaWQ9XFxcInByb2plY3QtY29yZW1ldGEtZm9ybVxcXCIgY2xhc3M9XFxcImNvcmVtZXRhLWZvcm0tdG9nZ2xlIGNvcmVtZXRhLWFkbWluXFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0xMlxcXCI+XFxuICAgICAgPGZvcm0gcm9sZT1cXFwiZm9ybVxcXCI+XFxuXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJhbGVydCBhbGVydC1zdWNjZXNzXFxcIiBpZD1cXFwicHJvamVjdC1jb3JlbWV0YS1zdWNjZXNzXFxcIiBzdHlsZT1cXFwiZGlzcGxheTogbm9uZTtcXFwiPlxcbiAgICAgICAgICBZb3VyIDxzcGFuIGRhdGEtaTE4bj1cXFwicHJvamVjdFxcXCI+cHJvamVjdDwvc3Bhbj4gaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IHVwZGF0ZWQhXFxuICAgICAgICAgIDxhIGNsYXNzPVxcXCJjbG9zZVxcXCIgZGF0YS1kaXNtaXNzPVxcXCJhbGVydFxcXCIgaHJlZj1cXFwiI1xcXCIgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPiZ0aW1lczs8L2E+XFxuICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgIDwhLS0gUklHSFQgTUFJTiBCQVIgLS0+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgICAgPGgyIGNsYXNzPVxcXCJib3gtcGFkLXRcXFwiPjxzcGFuIGRhdGEtaTE4bj1cXFwiUHJvamVjdFxcXCI+UHJvamVjdDwvc3Bhbj4gVGl0bGU8L2gyPlxcbiAgICAgICAgICA8aW5wdXQgaWQ9XFxcInByb2plY3QtZWRpdC1mb3JtLXRpdGxlXFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sIGlucHV0LWxnXFxcIiB2YWx1ZT1cXFwiPCU9IGRhdGEudGl0bGUgJT5cXFwiIHR5cGU9XFxcInRleHRcXFwiIGRhdGEtdmFsaWRhdGU9XFxcImVtcHR5LGNvdW50MTAwXFxcIiB0aXRsZT1cXFwiVGl0bGVcXFwiLz5cXG4gICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImhlbHAtYmxvY2sgZXJyb3ItZW1wdHlcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIj5Zb3UgbXVzdCBlbnRlciBhIDxzcGFuIGRhdGEtaTE4bj1cXFwicHJvamVjdFxcXCI+cHJvamVjdDwvc3Bhbj4gdGl0bGUuPC9zcGFuPlxcbiAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaGVscC1ibG9jayBlcnJvci1jb3VudDEwMFxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPllvdXIgdGl0bGUgbXVzdCBiZSBsZXNzIHRoYW4gMTAwIGNoYXJhY3RlcnMuPC9zcGFuPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgICAgPGgyIGNsYXNzPVxcXCJib3gtcGFkLXRcXFwiPjxzcGFuIGRhdGEtaTE4bj1cXFwiUHJvamVjdFxcXCI+UHJvamVjdDwvc3Bhbj4gRGVzY3JpcHRpb248L2gyPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtYXJrZG93bi1lZGl0XFxcIj5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJoZWxwLWJsb2NrIGVycm9yLWVtcHR5XFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI+WW91IG11c3QgZW50ZXIgYSA8c3BhbiBkYXRhLWkxOG49XFxcInByb2plY3RcXFwiPnByb2plY3Q8L3NwYW4+IGRlc2NyaXB0aW9uLjwvc3Bhbj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZm9ybT5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0xMiBmb3JtLWdyb3VwXFxcIj5cXG5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJwdWxsLXJpZ2h0IGNvcmVtZXRhLWFkbWluXFxcIiBpZD1cXFwicHJvamVjdC1jb3JlbWV0YS1idXR0b25zXFxcIj5cXG4gICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnRuIGJ0bi1jMFxcXCIgaWQ9XFxcImNvcmVtZXRhLXZpZXdcXFwiPkRpc2NhcmQgQ2hhbmdlczwvYnV0dG9uPlxcbiAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidG4gYnRuLWMyXFxcIiBpZD1cXFwiY29yZW1ldGEtc2F2ZVxcXCI+U2F2ZSA8c3BhbiBkYXRhLWkxOG49XFxcIlByb2plY3RcXFwiPlByb2plY3Q8L3NwYW4+PC9idXR0b24+XFxuICAgICAgPC9kaXY+XFxuXFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPCEtLSBBTEVSVFMgLS0+XFxuPGRpdiBjbGFzcz1cXFwiYWxlcnQgYWxlcnQtZGFuZ2VyXFxcIiBpZD1cXFwiYWxlcnQtY2xvc2VkXFxcIiBzdHlsZT1cXFwiPCUgaWYgKGRhdGEuc3RhdGUgIT0gJ2Nsb3NlZCcpIHsgJT5kaXNwbGF5OiBub25lOzwlIH0gJT5cXFwiPlRoaXMgPHNwYW4gZGF0YS1pMThuPVxcXCJwcm9qZWN0XFxcIj5wcm9qZWN0PC9zcGFuPiBpcyA8c3Ryb25nPmNsb3NlZDwvc3Ryb25nPi4gIEl0IGlzIG5vIGxvbmdlciBhY3RpdmUsIGFuZCBubyBtb3JlIG1vZGlmaWNhdGlvbnMgbWF5IGJlIG1hZGUuPC9kaXY+XFxuXFxuPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcImNvbC1zbS00IGNvbC1tZC00IGNvbC1sZy00IHByb2plY3Qtc2lkZWJhciBtZC1ub3BhZGRpbmctcmlnaHQgc20tbm9wYWRkaW5nXFxcIj5cXG4gICAgPCEtLSBMRUZUIFNJREVCQVIgLS0+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTEyIGJveCBwcm9qZWN0LWhlYWRlci13cmFwcGVyXFxcIj5cXG4gICAgICAgIDwlIGlmIChkYXRhLmNvdmVySWQpIHsgJT5cXG4gICAgICAgIDxkaXYgaWQ9XFxcInByb2plY3QtaGVhZGVyXFxcIiBzdHlsZT1cXFwiYmFja2dyb3VuZC1pbWFnZTp1cmwoJy9hcGkvZmlsZS9nZXQvPCU9IGRhdGEuY292ZXJJZCAlPicpO1xcXCI+XFxuICAgICAgICA8JSB9IGVsc2UgeyAlPlxcbiAgICAgICAgPGRpdiBpZD1cXFwicHJvamVjdC1oZWFkZXJcXFwiIHN0eWxlPVxcXCJiYWNrZ3JvdW5kLWltYWdlOnVybCgnL2ltYWdlcy9wcm9qZWN0X2RlZmF1bHQucG5nJyk7XFxcIj5cXG4gICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiYnRuIGJ0bi1jMiBmaWxlaW5wdXQtYnV0dG9uXFxcIiA8JSBpZiAoIShkYXRhLmlzT3duZXIgfHwgdXNlci5pc0FkbWluKSB8fCAhZWRpdCkgeyAlPnN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIjwlIH0gJT4+XFxuICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWNhbWVyYSBmYS1sZ1xcXCIgdGl0bGU9XFxcIkNoYW5nZSBDb3ZlciBQaG90b1xcXCIgaWQ9XFxcImZpbGV1cGxvYWQtaWNvblxcXCI+PC9pPlxcbiAgICAgICAgICAgIDxpbnB1dCBpZD1cXFwiZmlsZXVwbG9hZFxcXCIgdHlwZT1cXFwiZmlsZVxcXCIgbmFtZT1cXFwiZmlsZXNbXVxcXCIgdGl0bGU9XFxcIkNoYW5nZSBDb3ZlciBQaG90b1xcXCI+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IGlkPVxcXCJmaWxlLXVwbG9hZC1wcm9ncmVzcy1jb250YWluZXJcXFwiIHN0eWxlPVxcXCJkaXNwbGF5OiBub25lO1xcXCIgY2xhc3M9XFxcInByb2dyZXNzIHByb2dyZXNzLXN0cmlwZWQgYWN0aXZlXFxcIj5cXG4gICAgICAgICAgPGRpdiBpZD1cXFwiZmlsZS11cGxvYWQtcHJvZ3Jlc3NcXFwiIGNsYXNzPVxcXCJwcm9ncmVzcy1iYXJcXFwiIHN0eWxlPVxcXCJ3aWR0aDogMFxcXCI+PC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImZpbGUtdXBsb2FkLWFsZXJ0IGFsZXJ0IGFsZXJ0LXdhcm5pbmdcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gIDwvZGl2PlxcblxcbiAgPGRpdiBjbGFzcz1cXFwiY29sLXNtLTggY29sLW1kLTggY29sLWxnLTggbWQtbm9wYWRkaW5nIHNtLW5vcGFkZGluZ1xcXCI+XFxuXFxuICAgIDwhLS0gUklHSFQgTUFJTiBCQVIgLS0+XFxuICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLXNtLTggY29sLW1kLTkgc20tbm9wYWRkaW5nXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIm1haW4tc2VjdGlvblxcXCI+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImJveCBib3gtbWFpblxcXCIgaWQ9XFxcInByb2plY3QtY29yZW1ldGEtd3JhcHBlclxcXCI+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLXNtLTQgY29sLW1kLTMgcGFkZGluZy1sZWZ0LW5vbmUgc20tbm9wYWRkaW5nXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImJveCBwYWRkaW5nLW5vbmVcXFwiPlxcblxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJuYXZiYXItc2lkZSBsaWtlLXJvdyBib3JkZXItYm90dG9tXFxcIj5cXG4gICAgICAgICAgICA8JSBpZiAodXNlcikgeyAlPlxcbiAgICAgICAgICAgIDxidXR0b24gaWQ9XFxcImxpa2UtYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1saW5rIGxpa2UtYnV0dG9uXFxcIiB0aXRsZT1cXFwiQ2xpY2sgdG8gTGlrZSBvciBVbmxpa2VcXFwiPlxcbiAgICAgICAgICAgIDwlIH0gZWxzZSB7ICU+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImxpa2UtYnV0dG9uXFxcIj5cXG4gICAgICAgICAgICA8JSB9ICU+XFxuICAgICAgICAgICAgICA8aSBpZD1cXFwibGlrZS1idXR0b24taWNvblxcXCIgY2xhc3M9XFxcImZhIGZhLXN0YXItbyBmYS1sZyBnb2xkXFxcIj48L2k+XFxuICAgICAgICAgICAgPCUgaWYgKHVzZXIpIHsgJT5cXG4gICAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgICAgICA8JSB9IGVsc2UgeyAlPlxcbiAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgICA8JSB9ICU+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImxpa2UtbnVtYmVyXFxcIiBpZD1cXFwibGlrZS1udW1iZXJcXFwiPjwlLSBkYXRhLmxpa2VDb3VudCAlPjwvc3Bhbj5cXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwibGlrZS1wbHVyYWxcXFwiIGlkPVxcXCJsaWtlLXRleHRcXFwiIGRhdGEtcGx1cmFsPVxcXCJsaWtlc1xcXCIgZGF0YS1zaW5ndWxhcj1cXFwibGlrZVxcXCI+bGlrZXM8L3NwYW4+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJuYXZiYXItc2lkZSA8JSBpZiAoZGF0YS5pc093bmVyIHx8IHVzZXIuaXNBZG1pbikgeyAlPmJvcmRlci1ib3R0b208JSB9ICU+XFxcIj5cXG4gICAgICAgICAgICA8dWwgY2xhc3M9XFxcIm5hdiBuYXYtcGlsbHMgbmF2LXN0YWNrZWRcXFwiPlxcbiAgICAgICAgICAgICAgPGxpPlxcbiAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCIjXFxcIiBpZD1cXFwiZW1haWxcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1lbnZlbG9wZS1vXFxcIj48L2k+IDxzcGFuIGNsYXNzPVxcXCJib3gtaWNvbi10ZXh0XFxcIj5TaGFyZTwvc3Bhbj48L2E+XFxuICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgPGxpPlxcbiAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCJ3ZWJjYWw6Ly88JS0gaG9zdG5hbWUgJT4vYXBpL2V2ZW50L2ljYWwvPCUtIGRhdGEuaWQgJT5cXFwiPjxzcGFuIGNsYXNzPVxcXCJmYSBmYS1jYWxlbmRhclxcXCI+PC9zcGFuPiA8c3BhbiBjbGFzcz1cXFwiYm94LWljb24tdGV4dFxcXCI+Q2FsZW5kYXI8L3NwYW4+PC9hPlxcbiAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICA8L3VsPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPCUgaWYgKGRhdGEuaXNPd25lciB8fCB1c2VyLmlzQWRtaW4pIHsgJT5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwibmF2YmFyLXNpZGVcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgaWQ9XFxcIm1vZGFsLWNsb3NlXFxcIj48L2Rpdj5cXG4gICAgICAgICAgICA8dWwgY2xhc3M9XFxcIm5hdiBuYXYtcGlsbHMgbmF2LXN0YWNrZWRcXFwiPlxcbiAgICAgICAgICAgICAgPGxpPlxcbiAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCIjXFxcIiBpZD1cXFwiZWRpdFByb2plY3RcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1wZW5jaWxcXFwiPjwvaT4gPHNwYW4gY2xhc3M9XFxcImJveC1pY29uLXRleHRcXFwiPkVkaXQgPHNwYW4gZGF0YS1pMThuPVxcXCJQcm9qZWN0XFxcIj5Qcm9qZWN0PC9zcGFuPjwvc3Bhbj48L2E+XFxuICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgPCUgaWYgKCAhZWRpdCApIHsgJT5cXG4gICAgICAgICAgICAgIDxsaSBpZD1cXFwibGktcHJvamVjdC1jbG9zZVxcXCIgc3R5bGU9XFxcIjwlIGlmIChkYXRhLnN0YXRlID09ICdjbG9zZWQnKSB7ICU+ZGlzcGxheTogbm9uZTs8JSB9ICU+XFxcIj5cXG4gICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgaWQ9XFxcInByb2plY3QtY2xvc2VcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS10aW1lcy1jaXJjbGVcXFwiPjwvaT4gPHNwYW4gY2xhc3M9XFxcImJveC1pY29uLXRleHRcXFwiPkNsb3NlIDxzcGFuIGRhdGEtaTE4bj1cXFwiUHJvamVjdFxcXCI+UHJvamVjdDwvc3Bhbj48L3NwYW4+PC9hPlxcbiAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICAgIDxsaSBpZD1cXFwibGktcHJvamVjdC1yZW9wZW5cXFwiIHN0eWxlPVxcXCI8JSBpZiAoZGF0YS5zdGF0ZSAhPSAnY2xvc2VkJykgeyAlPmRpc3BsYXk6IG5vbmU7PCUgfSAlPlxcXCI+XFxuICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGlkPVxcXCJwcm9qZWN0LXJlb3BlblxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXNoYXJlXFxcIj48L2k+IDxzcGFuIGNsYXNzPVxcXCJib3gtaWNvbi10ZXh0XFxcIj5SZW9wZW4gPHNwYW4gZGF0YS1pMThuPVxcXCJQcm9qZWN0XFxcIj5Qcm9qZWN0PC9zcGFuPjwvc3Bhbj48L2E+XFxuICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgPCUgfSAlPlxcbiAgICAgICAgICAgICAgPCEtLVxcbiAgICAgICAgICAgICAgPGxpPlxcbiAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCIjXFxcIiBpZD1cXFwicHJvamVjdC1kZWxldGVcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS10cmFzaC1vXFxcIj48L2k+IDxzcGFuIGNsYXNzPVxcXCJib3gtaWNvbi10ZXh0XFxcIj5EZWxldGUgPHNwYW4gZGF0YS1pMThuPVxcXCJQcm9qZWN0XFxcIj5Qcm9qZWN0PC9zcGFuPjwvc3Bhbj48L2E+XFxuICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgLS0+XFxuICAgICAgICAgICAgPC91bD5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuXFxuICA8ZGl2IGNsYXNzPVxcXCJjb2wtc20tNSBjb2wtbWQtNCBtZC1ub3BhZGRpbmctcmlnaHQgc20tbm9wYWRkaW5nXFxcIj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMTIgYm94XFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImJveC1tYWluIHRhZy13cmFwcGVyXFxcIj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPCUgaWYgKCEoZGF0YS5pc093bmVyIHx8IHVzZXIuaXNBZG1pbikgfHwgIWVkaXQpIHsgJT5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMTIgYm94XFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImF0dGFjaG1lbnQtd3JhcHBlclxcXCI+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDwlIH0gJT5cXG5cXG4gIDwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwiY29sLXNtLTcgY29sLW1kLTggbWQtbm9wYWRkaW5nLXJpZ2h0IHNtLW5vcGFkZGluZ1xcXCI+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTEyIHNtLW5vcGFkZGluZyBtZC1ub3BhZGRpbmdcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiYm94XFxcIiBpZD1cXFwicHJvamVjdG93bmVyLXdyYXBwZXJcXFwiPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8JSBpZiAoIShkYXRhLmlzT3duZXIgfHwgdXNlci5pc0FkbWluKSB8fCAhZWRpdCkgeyAlPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0xMiBzbS1ub3BhZGRpbmcgbWQtbm9wYWRkaW5nXFxcIj5cXG4gICAgICAgIDwhLS0gQkVHSU4gRVZFTlRTIC0tPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiYm94XFxcIiBpZD1cXFwiZXZlbnQtbGlzdC13cmFwcGVyXFxcIj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPCEtLSBFTkQgRVZFTlRTIC0tPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMTIgc20tbm9wYWRkaW5nIG1kLW5vcGFkZGluZ1xcXCI+XFxuICAgICAgICA8IS0tIEJFR0lOIFRBU0tTIC0tPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwid3JhcHBlci1hZGRUYXNrXFxcIj48L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImJveFxcXCIgaWQ9XFxcInRhc2stbGlzdC13cmFwcGVyXFxcIiBkYXRhLXByb2plY3QtaWQ9XFxcIjwlPSBkYXRhLmlkICU+XFxcIj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPCEtLSBFTkQgVEFTS1MgLS0+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0xMiBzbS1ub3BhZGRpbmcgbWQtbm9wYWRkaW5nXFxcIj5cXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImJveCBjb21tZW50LWxpc3Qtd3JhcHBlclxcXCIgc3R5bGU9XFxcImNsZWFyOiBib3RoO1xcXCI+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDwlIH0gJT4gPCEtLSBlbmQgb2YgY2hlY2sgZm9yIGVkaXQgbW9kZSAtLT5cXG5cXG4gICAgPCEtLSBhZGQgYSBzcGFjZSBhdCB0aGUgYm90dG9tIG9mIHRoZSBwYWdlIHVudGlsIHdlIGZpZ3VyZSBvdXQgd2hhdCBnb2VzIGhlcmUgLS0+XFxuICAgIDxkaXYgc3R5bGU9XFxcImhlaWdodDogNTBweDtcXFwiPlxcbiAgICA8L2Rpdj5cXG5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXY+XFxuICA8cD5UaGlzIDxzcGFuIGRhdGEtaTE4bj1cXFwicHJvamVjdFxcXCI+cHJvamVjdDwvc3Bhbj4gaGFzIDxzdHJvbmc+PCUtIGNvdW50ICU+PC9zdHJvbmc+IG9wZW4sIG9yIGluIHByb2dyZXNzLCBvcHBvcnR1bml0aWVzLiBDbG9zaW5nIHRoaXMgPHNwYW4gZGF0YS1pMThuPVxcXCJwcm9qZWN0XFxcIj5wcm9qZWN0PC9zcGFuPiB3aWxsIGNhdXNlIGFueSBzdWNoIG9wcG9ydHVuaXRpZXMgdG8gYmUgb3JwaGFuZWQgKG5vIGxvbmdlciBhc3NvY2lhdGVkIHdpdGggYW55IDxzcGFuIGRhdGEtaTE4bj1cXFwicHJvamVjdFxcXCI+cHJvamVjdDwvc3Bhbj4pLjwvcD5cXG5cXG4gIDxwPkFyZSB5b3Ugc3VyZSB5b3Ugd2lzaCB0byBwcm9jZWVkPzwvcD5cXG5cXG48L2Rpdj5cXG5cIjtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIGFzeW5jID0gcmVxdWlyZSgnYXN5bmMnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgbWFya2VkID0gcmVxdWlyZSgnbWFya2VkJyk7XG52YXIgTWFya2Rvd25FZGl0b3IgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb21wb25lbnRzL21hcmtkb3duX2VkaXRvcicpO1xudmFyIFBvcG92ZXJzID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vbWl4aW5zL3BvcG92ZXJzJyk7XG52YXIgTW9kYWxDb21wb25lbnQgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb21wb25lbnRzL21vZGFsJyk7XG52YXIgUHJvamVjdEl0ZW1Db3JlTWV0YVRlbXBsYXRlID0gcmVxdWlyZSgnLi4vdGVtcGxhdGVzL3Byb2plY3RfaXRlbV9jb3JlbWV0YV90ZW1wbGF0ZS5odG1sJyk7XG5cblxuLy9pZihfLmlzVW5kZWZpbmVkKHBvcG92ZXJzKSl7dmFyIHBvcG92ZXJzID0gbmV3IFBvcG92ZXJzKCk7fVxuXG52YXIgUHJvamVjdEl0ZW1Db3JlTWV0YVZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG5cbiAgZWw6IFwiI3Byb2plY3QtY29yZW1ldGEtd3JhcHBlclwiLFxuICBtb2RlbCA6IG51bGwsXG5cbiAgLy8gU2V0IHRoZSBtb2RlbCB0byBudWxsLCBiZWZvcmUgaXQgaXMgZmV0Y2hlZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gIC8vIFRoaXMgYWxsb3dzIHVzIHRvIGNsZWFyIG91dCB0aGUgcHJldmlvdXMgZGF0YSBmcm9tIHRoZSBsaXN0X3ZpZXcsXG4gIC8vIGFuZCBnZXQgcmVhZHkgZm9yIHRoZSBuZXcgZGF0YSBmb3IgdGhlIHByb2plY3Qgc2hvdyB2aWV3LlxuICAvLyBtb2RlbDogbnVsbCxcblxuICBldmVudHM6IHtcbiAgICBcImJsdXIgI3Byb2plY3QtZWRpdC1mb3JtLXRpdGxlXCIgICAgICAgICAgICA6IFwidlwiLFxuICAgIFwiYmx1ciAjcHJvamVjdC1lZGl0LWZvcm0tZGVzY3JpcHRpb25cIiAgICAgIDogXCJ2XCIsXG4gICAgXCJjbGljayAjY29yZW1ldGEtc2F2ZVwiICAgICAgICAgICAgICAgICAgICAgOiBcInNhdmVDb3JlTWV0YVwiLFxuICAgIFwiY2xpY2sgI2NvcmVtZXRhLXZpZXdcIiAgICAgICAgICAgICAgICAgICAgIDogXCJ2aWV3UHJvamVjdFwiXG4gIH0sXG5cbiAgLy8gVGhlIGluaXRpYWxpemUgbWV0aG9kIGlzIG1haW5seSB1c2VkIGZvciBldmVudCBiaW5kaW5ncyAoZm9yIGVmZmVjaWVuY3kpXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5kYXRhID0gb3B0aW9ucy5kYXRhO1xuICAgIHRoaXMuYWN0aW9uID0gb3B0aW9ucy5hY3Rpb247XG4gICAgdGhpcy51c2VyID0gd2luZG93LmNhY2hlLmN1cnJlbnRVc2VyIHx8IHt9O1xuICAgIHRoaXMuZWRpdCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYWN0aW9uKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFjdGlvbiA9PSAnZWRpdCcpIHtcbiAgICAgICAgdGhpcy5lZGl0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm1vZGVsLm9uKFwicHJvamVjdDpjb3JlbWV0YTpzaG93OnJlbmRlcmVkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuaW5pdGlhbGl6ZVRleHRBcmVhKCk7XG4gICAgICBzZWxmLmluaXRpYWxpemVUb2dnbGVkRWxlbWVudHMoKTtcbiAgICB9KTtcblxuICAgIHRoaXMubW9kZWwub24oXCJwcm9qZWN0OnNhdmU6c3VjY2Vzc1wiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgc2VsZi5yZW5kZXIoKTtcbiAgICAgICQoJyNwcm9qZWN0LWNvcmVtZXRhLXN1Y2Nlc3MnKS5zaG93KCk7XG4gICAgICBzZWxmLnZpZXdQcm9qZWN0KHt9KTtcbiAgICB9KTtcblxuICAgIHRoaXMubW9kZWwub24oXCJwcm9qZWN0OnRhZ3M6c2F2ZTpzdWNjZXNzXCIsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBzZWxmLnJlbmRlcigpO1xuICAgICAgJCgnI3Byb2plY3QtY29yZW1ldGEtc3VjY2VzcycpLnNob3coKTtcbiAgICAgIHNlbGYudmlld1Byb2plY3Qoe30pO1xuICAgIH0pO1xuXG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBkYXRhOiB0aGlzLm1vZGVsLnRvSlNPTigpXG4gICAgfTtcbiAgICAvLyBjb252ZXJ0IGRlc2NyaXB0aW9uIHRvIGh0bWwgdXNpbmcgbWFya2Rvd24gc3ludGF4XG4gICAgZGF0YS5kYXRhLmRlc2NyaXB0aW9uSHRtbCA9IG1hcmtlZChkYXRhLmRhdGEuZGVzY3JpcHRpb24gfHwgJycpO1xuICAgIHZhciBjb21waWxlZFRlbXBsYXRlID0gXy50ZW1wbGF0ZShQcm9qZWN0SXRlbUNvcmVNZXRhVGVtcGxhdGUpKGRhdGEpO1xuICAgIHRoaXMuJGVsLmh0bWwoY29tcGlsZWRUZW1wbGF0ZSk7XG4gICAgdGhpcy4kZWwuaTE4bigpO1xuICAgIHRoaXMubW9kZWwudHJpZ2dlcihcInByb2plY3Q6Y29yZW1ldGE6c2hvdzpyZW5kZXJlZFwiLCBkYXRhKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGluaXRpYWxpemVUZXh0QXJlYTogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm1kKSB7IHRoaXMubWQuY2xlYW51cCgpOyB9XG4gICAgdGhpcy5tZCA9IG5ldyBNYXJrZG93bkVkaXRvcih7XG4gICAgICBkYXRhOiB0aGlzLm1vZGVsLnRvSlNPTigpLmRlc2NyaXB0aW9uLFxuICAgICAgZWw6IFwiLm1hcmtkb3duLWVkaXRcIixcbiAgICAgIGlkOiAncHJvamVjdC1lZGl0LWZvcm0tZGVzY3JpcHRpb24nLFxuICAgICAgdGl0bGU6ICdQcm9qZWN0IERlc2NyaXB0aW9uJyxcbiAgICAgIHJvd3M6IDYsXG4gICAgICB2YWxpZGF0ZTogWydlbXB0eSddXG4gICAgfSkucmVuZGVyKCk7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZVRvZ2dsZWRFbGVtZW50czogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICgodGhpcy5tb2RlbC5hdHRyaWJ1dGVzLmlzT3duZXIgfHwgdGhpcy51c2VyLmlzQWRtaW4pICYmIHRoaXMuZWRpdCl7XG4gICAgICBzZWxmLiQoJyNwcm9qZWN0LWNvcmVtZXRhLWZvcm0nKS5zaG93KCk7XG4gICAgICBzZWxmLiQoJyNwcm9qZWN0LWNvcmVtZXRhLXNob3cnKS5oaWRlKCk7XG4gICAgfVxuICAgIGVsc2V7XG4gICAgICBzZWxmLiQoJy5jb3JlbWV0YS1hZG1pbicpLmhpZGUoKTtcbiAgICB9XG4gIH0sXG5cbiAgdjogZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiB2YWxpZGF0ZShlKTtcbiAgfSxcblxuICBzYXZlQ29yZU1ldGE6IGZ1bmN0aW9uIChlKXtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICghKHRoaXMubW9kZWwuYXR0cmlidXRlcy5pc093bmVyIHx8IHRoaXMudXNlci5pc0FkbWluKSAmJiB0aGlzLmVkaXQpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIHZhbGlkYXRlIHRoZSBmb3JtIGZpZWxkc1xuICAgIHZhciB2YWxpZGF0ZUlkcyA9IFsnI3Byb2plY3QtZWRpdC1mb3JtLXRpdGxlJywgJyNwcm9qZWN0LWVkaXQtZm9ybS1kZXNjcmlwdGlvbiddO1xuICAgIHZhciBhYm9ydCA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgaW4gdmFsaWRhdGVJZHMpIHtcbiAgICAgIHZhciBpQWJvcnQgPSB2YWxpZGF0ZSh7IGN1cnJlbnRUYXJnZXQ6IHZhbGlkYXRlSWRzW2ldIH0pO1xuICAgICAgYWJvcnQgPSBhYm9ydCB8fCBpQWJvcnQ7XG4gICAgfVxuICAgIGlmIChhYm9ydCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHByb2Nlc3MgYW5kIHVwZGF0ZSB0aGUgZGF0YSBtb2RlbCBmb3IgdGhlIHByb2plY3RcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHBJZCA9IHNlbGYubW9kZWwuYXR0cmlidXRlcy5pZDtcbiAgICB2YXIgdGl0bGUgPSBzZWxmLiQoJyNwcm9qZWN0LWVkaXQtZm9ybS10aXRsZScpLnZhbCgpO1xuICAgIHZhciBkZXNjcmlwdGlvbiA9IHNlbGYuJCgnI3Byb2plY3QtZWRpdC1mb3JtLWRlc2NyaXB0aW9uJykudmFsKCk7XG4gICAgdmFyIHBhcmFtcyA9IHsgdGl0bGUgOnRpdGxlLCBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24gfTtcblxuICAgIHNlbGYubW9kZWwudHJpZ2dlcihcInByb2plY3Q6dGFnOnVwZGF0ZTpzdGFydFwiKTtcbiAgICBzZWxmLm1vZGVsLnRyaWdnZXIoXCJwcm9qZWN0Om1vZGVsOnVwZGF0ZVwiLCBwYXJhbXMpO1xuICB9LFxuXG4gIHZpZXdQcm9qZWN0OiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgQmFja2JvbmUuaGlzdG9yeS5uYXZpZ2F0ZSgncHJvamVjdHMvJyArIHRoaXMubW9kZWwuYXR0cmlidXRlcy5pZCwgeyB0cmlnZ2VyOiB0cnVlIH0pO1xuICB9LFxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLz0gVXRpbGl0eSBNZXRob2RzXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBjbGVhbnVwOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5tZCkgeyB0aGlzLm1kLmNsZWFudXAoKTsgfVxuICAgIHJlbW92ZVZpZXcodGhpcyk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvamVjdEl0ZW1Db3JlTWV0YVZpZXc7XG4iLCJ2YXIganFJZnJhbWUgPSByZXF1aXJlKCdibHVlaW1wLWZpbGUtdXBsb2FkL2pzL2pxdWVyeS5pZnJhbWUtdHJhbnNwb3J0Jyk7XG52YXIganFGVSA9IHJlcXVpcmUoJ2JsdWVpbXAtZmlsZS11cGxvYWQvanMvanF1ZXJ5LmZpbGV1cGxvYWQuanMnKTtcbnZhciBzZWxlY3QyID0gcmVxdWlyZSgnc2VsZWN0MicpO1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vbWl4aW5zL3V0aWxpdGllcycpO1xudmFyIGFzeW5jID0gcmVxdWlyZSgnYXN5bmMnKTtcbnZhciBQcm9qZWN0U2hvd1RlbXBsYXRlID0gcmVxdWlyZSgnLi4vdGVtcGxhdGVzL3Byb2plY3RfaXRlbV92aWV3X3RlbXBsYXRlLmh0bWwnKTtcbnZhciBUYWdTaG93VmlldyA9IHJlcXVpcmUoJy4uLy4uLy4uL3RhZy9zaG93L3ZpZXdzL3RhZ19zaG93X3ZpZXcnKTtcbnZhciBUYWdGYWN0b3J5ID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29tcG9uZW50cy90YWdfZmFjdG9yeScpO1xuXG5cbnZhciBQcm9qZWN0U2hvd1ZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG5cbiAgZWw6IFwiI2NvbnRhaW5lclwiLFxuXG4gIGV2ZW50czoge1xuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmRhdGEgPSBvcHRpb25zLmRhdGE7XG4gICAgdGhpcy5hY3Rpb24gPSBvcHRpb25zLmFjdGlvbjtcbiAgICB0aGlzLmVkaXQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmFjdGlvbikge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hY3Rpb24gPT0gJ2VkaXQnKSB7XG4gICAgICAgIHRoaXMuZWRpdCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudGFnRmFjdG9yeSA9IG5ldyBUYWdGYWN0b3J5KCk7XG4gICAgdGhpcy5kYXRhLm5ld0l0ZW1UYWdzID0gW107XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbXBpbGVkVGVtcGxhdGU7XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBob3N0bmFtZTogd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lLFxuICAgICAgZGF0YTogdGhpcy5tb2RlbC50b0pTT04oKSxcbiAgICAgIHVzZXI6IHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlciB8fCB7fSxcbiAgICAgIGVkaXQ6IHRoaXMuZWRpdFxuICAgIH07XG5cbiAgICBjb21waWxlZFRlbXBsYXRlID0gXy50ZW1wbGF0ZShQcm9qZWN0U2hvd1RlbXBsYXRlKShkYXRhKTtcbiAgICB0aGlzLiRlbC5odG1sKGNvbXBpbGVkVGVtcGxhdGUpO1xuICAgIHRoaXMuJGVsLmkxOG4oKTtcblxuICAgIHRoaXMuaW5pdGlhbGl6ZVRvZ2dsZSgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZVRhZ0ZhY3RvcnkoKTtcbiAgICB0aGlzLmluaXRpYWxpemVGaWxlVXBsb2FkKCk7XG4gICAgdGhpcy5pbml0aWFsaXplVGFncygpO1xuICAgIHRoaXMudXBkYXRlUGhvdG8oKTtcbiAgICB0aGlzLnVwZGF0ZVByb2plY3RFbWFpbCgpO1xuICAgIHRoaXMubW9kZWwudHJpZ2dlcihcInByb2plY3Q6c2hvdzpyZW5kZXJlZFwiKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHVwZGF0ZVBob3RvOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCBcInByb2plY3Q6dXBkYXRlZDpwaG90bzpzdWNjZXNzXCIsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICB2YXIgbW9kZWwgPSBkYXRhLnRvSlNPTigpLCB1cmw7XG4gICAgICBpZiAobW9kZWwuY292ZXJJZCkge1xuICAgICAgICB1cmwgPSAnL2FwaS9maWxlL2dldC8nICsgbW9kZWwuY292ZXJJZDtcbiAgICAgICAgJChcIiNwcm9qZWN0LWhlYWRlclwiKS5jc3MoJ2JhY2tncm91bmQtaW1hZ2UnLCBcInVybChcIiArIHVybCArIFwiKVwiKTtcbiAgICAgIH1cbiAgICAgICQoJyNmaWxlLXVwbG9hZC1wcm9ncmVzcy1jb250YWluZXInKS5oaWRlKCk7XG4gICAgfSk7XG4gIH0sXG5cbiAgdXBkYXRlUHJvamVjdEVtYWlsOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgJC5hamF4KHtcbiAgICAgIHVybDogZW5jb2RlVVJJKCcvYXBpL2VtYWlsL21ha2VVUkw/ZW1haWw9Y29udGFjdFVzZXJBYm91dFByb2plY3Qmc3ViamVjdD1DaGVjayBPdXQgXCInKyBzZWxmLm1vZGVsLmF0dHJpYnV0ZXMudGl0bGUgKyAnXCInICtcbiAgICAgICcmcHJvamVjdFRpdGxlPScgKyBzZWxmLm1vZGVsLmF0dHJpYnV0ZXMudGl0bGUgK1xuICAgICAgJyZwcm9qZWN0TGluaz0nICsgd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgd2luZG93LmxvY2F0aW9uLmhvc3QgKyBcIlwiICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICtcbiAgICAgICcmcHJvamVjdERlc2NyaXB0aW9uPScgKyAoc2VsZi5tb2RlbC5hdHRyaWJ1dGVzLmRlc2NyaXB0aW9uIHx8ICcnKSksXG4gICAgICB0eXBlOiAnR0VUJ1xuICAgIH0pLmRvbmUoIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBzZWxmLiQoJyNlbWFpbCcpLmF0dHIoJ2hyZWYnLCBkYXRhKTtcbiAgICB9KTtcblxuICB9LFxuXG4gIGluaXRpYWxpemVUYWdGYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLmxpc3RlblRvKHNlbGYubW9kZWwsIFwicHJvamVjdDp0YWc6dXBkYXRlOnN0YXJ0XCIsIGZ1bmN0aW9uICh0YWdzKSB7XG5cbiAgICAgIHZhciBuZXdUYWdzID0gW107XG4gICAgICBuZXdUYWdzID0gbmV3VGFncy5jb25jYXQoc2VsZi4kKFwiI3RhZ190b3BpY1wiKS5zZWxlY3QyKCdkYXRhJyksc2VsZi4kKFwiI3RhZ19za2lsbFwiKS5zZWxlY3QyKCdkYXRhJyksc2VsZi4kKFwiI3RhZ19sb2NhdGlvblwiKS5zZWxlY3QyKCdkYXRhJyksc2VsZi4kKFwiI3RhZ19hZ2VuY3lcIikuc2VsZWN0MignZGF0YScpKTtcblxuICAgICAgYXN5bmMuZm9yRWFjaChcbiAgICAgICAgbmV3VGFncyxcbiAgICAgICAgZnVuY3Rpb24obmV3VGFnLCBjYWxsYmFjaykge1xuICAgICAgICAgIHJldHVybiBzZWxmLnRhZ0ZhY3RvcnkuYWRkVGFnRW50aXRpZXMobmV3VGFnLHNlbGYsY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gbmV4dChlcnIpO1xuICAgICAgICAgIHNlbGYudHJpZ2dlcihcIm5ld1RhZ1NhdmVEb25lXCIpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgc2VsZi5vbignbmV3VGFnU2F2ZURvbmUnLGZ1bmN0aW9uICgpe1xuXG4gICAgICB0YWdzICAgICAgICAgPSBbXTtcbiAgICAgIHZhciB0ZW1wVGFncyA9IFtdO1xuXG4gICAgICAvL2dldCBuZXdseSBjcmVhdGVkIHRhZ3MgZnJvbSBiaWcgdGhyZWUgdHlwZXNcbiAgICAgIF8uZWFjaChzZWxmLmRhdGEubmV3SXRlbVRhZ3MsIGZ1bmN0aW9uKG5ld0l0ZW1UYWcpe1xuICAgICAgICB0YWdzLnB1c2gobmV3SXRlbVRhZyk7XG4gICAgICB9KTtcblxuICAgICAgdGVtcFRhZ3MucHVzaC5hcHBseSh0ZW1wVGFncyxzZWxmLiQoXCIjdGFnX3RvcGljXCIpLnNlbGVjdDIoJ2RhdGEnKSk7XG4gICAgICB0ZW1wVGFncy5wdXNoLmFwcGx5KHRlbXBUYWdzLHNlbGYuJChcIiN0YWdfc2tpbGxcIikuc2VsZWN0MignZGF0YScpKTtcbiAgICAgIHRlbXBUYWdzLnB1c2guYXBwbHkodGVtcFRhZ3Msc2VsZi4kKFwiI3RhZ19sb2NhdGlvblwiKS5zZWxlY3QyKCdkYXRhJykpO1xuICAgICAgdGVtcFRhZ3MucHVzaC5hcHBseSh0ZW1wVGFncyxzZWxmLiQoXCIjdGFnX2FnZW5jeVwiKS5zZWxlY3QyKCdkYXRhJykpO1xuXG4gICAgICAvL3NlZSBpZiB0aGVyZSBhcmUgYW55IHByZXZpb3VzbHkgY3JlYXRlZCBiaWcgdGhyZWUgdGFncyBhbmQgYWRkIHRoZW0gdG8gdGhlIHRhZyBhcnJheVxuICAgICAgXy5lYWNoKHRlbXBUYWdzLGZ1bmN0aW9uKHRlbXBUYWcpe1xuICAgICAgICAgIGlmICggdGVtcFRhZy5pZCAhPT0gdGVtcFRhZy5uYW1lICl7XG4gICAgICAgICAgdGFncy5wdXNoKHRlbXBUYWcpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdmFyIHRhZ01hcCA9IHt9O1xuICAgICAgdmFyIHByb2plY3RJZCA9IHNlbGYubW9kZWwuYXR0cmlidXRlcy5pZDtcblxuICAgICAgYXN5bmMuZm9yRWFjaChcbiAgICAgICAgdGFncyxcbiAgICAgICAgZnVuY3Rpb24odGFnLCBjYWxsYmFjayl7XG4gICAgICAgICAgcmV0dXJuIHNlbGYudGFnRmFjdG9yeS5hZGRUYWcodGFnLHByb2plY3RJZCxcInByb2plY3RJZFwiLGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24oZXJyKXtcbiAgICAgICAgICBzZWxmLm1vZGVsLnRyaWdnZXIoXCJwcm9qZWN0OnRhZ3M6c2F2ZTpzdWNjZXNzXCIsIGVycik7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSk7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZVRvZ2dsZTogZnVuY3Rpb24gKCkge1xuICAgIGlmKHRoaXMuZWRpdCl7XG4gICAgICB0aGlzLiQoJyNlZGl0UHJvamVjdCcpLmZpbmQoJy5ib3gtaWNvbi10ZXh0JykuaHRtbCgnVmlldyAnICsgaTE4bi50KCdQcm9qZWN0JykpO1xuICAgIH1cbiAgICBlbHNle1xuICAgICAgdGhpcy4kKCcjZWRpdFByb2plY3QnKS5maW5kKCcuYm94LWljb24tdGV4dCcpLmh0bWwoJ0VkaXQgJyArIGkxOG4udCgnUHJvamVjdCcpKTtcbiAgICB9XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZVRhZ3M6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnRhZ1ZpZXcgPSBuZXcgVGFnU2hvd1ZpZXcoe1xuICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICBlbDogJy50YWctd3JhcHBlcicsXG4gICAgICB0YXJnZXQ6ICdwcm9qZWN0JyxcbiAgICAgIHRhcmdldElkOiAncHJvamVjdElkJyxcbiAgICAgIGVkaXQ6IHRoaXMuZWRpdCxcbiAgICAgIHVybDogJy9hcGkvdGFnL2ZpbmRBbGxCeVByb2plY3RJZC8nXG4gICAgfSk7XG4gICAgdGhpcy50YWdWaWV3LnJlbmRlcigpO1xuICB9LFxuXG4gIGluaXRpYWxpemVGaWxlVXBsb2FkOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgJCgnI2ZpbGV1cGxvYWQnKS5maWxldXBsb2FkKHtcbiAgICAgICAgdXJsOiBcIi9hcGkvZmlsZS9jcmVhdGVcIixcbiAgICAgICAgZGF0YVR5cGU6ICd0ZXh0JyxcbiAgICAgICAgYWNjZXB0RmlsZVR5cGVzOiAvKFxcLnxcXC8pKGdpZnxqcGU/Z3xwbmcpJC9pLFxuICAgICAgICBmb3JtRGF0YTogeyAndHlwZSc6ICdpbWFnZScgfSxcbiAgICAgICAgYWRkOiBmdW5jdGlvbiAoZSwgZGF0YSkge1xuICAgICAgICAgIHNlbGYuJCgnI2ZpbGUtdXBsb2FkLXByb2dyZXNzLWNvbnRhaW5lcicpLnNob3coKTtcbiAgICAgICAgICBkYXRhLnN1Ym1pdCgpO1xuICAgICAgICB9LFxuICAgICAgICBwcm9ncmVzc2FsbDogZnVuY3Rpb24gKGUsIGRhdGEpIHtcbiAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSBwYXJzZUludChkYXRhLmxvYWRlZCAvIGRhdGEudG90YWwgKiAxMDAsIDEwKTtcbiAgICAgICAgICBzZWxmLiQoJyNmaWxlLXVwbG9hZC1wcm9ncmVzcycpLmNzcyhcbiAgICAgICAgICAgICd3aWR0aCcsXG4gICAgICAgICAgICBwcm9ncmVzcyArICclJ1xuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIGRvbmU6IGZ1bmN0aW9uIChlLCBkYXRhKSB7XG4gICAgICAgICAgLy8gZm9yIElFOC85IHRoYXQgdXNlIGlmcmFtZVxuICAgICAgICAgIGlmIChkYXRhLmRhdGFUeXBlID09ICdpZnJhbWUgdGV4dCcpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBKU09OLnBhcnNlKGRhdGEucmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZm9yIG1vZGVybiBYSFIgYnJvd3NlcnNcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBKU09OLnBhcnNlKCQoZGF0YS5yZXN1bHQpLnRleHQoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYubW9kZWwudHJpZ2dlcihcInByb2plY3Q6dXBkYXRlOnBob3RvSWRcIiwgcmVzdWx0WzBdKTtcbiAgICAgICAgfSxcbiAgICAgICAgZmFpbDogZnVuY3Rpb24gKGUsIGRhdGEpIHtcbiAgICAgICAgICAvLyBub3RpZnkgdGhlIHVzZXIgdGhhdCB0aGUgdXBsb2FkIGZhaWxlZFxuICAgICAgICAgIHZhciBtZXNzYWdlID0gZGF0YS5lcnJvclRocm93bjtcbiAgICAgICAgICBzZWxmLiQoJyNmaWxlLXVwbG9hZC1wcm9ncmVzcy1jb250YWluZXInKS5oaWRlKCk7XG4gICAgICAgICAgaWYgKGRhdGEuanFYSFIuc3RhdHVzID09IDQxMykge1xuICAgICAgICAgICAgbWVzc2FnZSA9IFwiVGhlIHVwbG9hZGVkIGZpbGUgZXhjZWVkcyB0aGUgbWF4aW11bSBmaWxlIHNpemUuXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYuJChcIi5maWxlLXVwbG9hZC1hbGVydFwiKS5odG1sKG1lc3NhZ2UpXG4gICAgICAgICAgc2VsZi4kKFwiLmZpbGUtdXBsb2FkLWFsZXJ0XCIpLnNob3coKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gIH0sXG5cbiAgY2xlYW51cDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnRhZ1ZpZXcpIHsgdGhpcy50YWdWaWV3LmNsZWFudXAoKTsgfVxuICAgIHJlbW92ZVZpZXcodGhpcyk7XG4gIH0sXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9qZWN0U2hvd1ZpZXc7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwiYm94LXBhZC1sciBib3JkZXItYm90dG9tXFxcIj5cXG4gIDxoMj48c3BhbiBkYXRhLWkxOG49XFxcIlByb2plY3RPd25lclBsdXJhbFxcXCI+UHJvamVjdCBPd25lcnM8L3NwYW4+XFxuICAgIDxidXR0b24gaWQ9XFxcIm93bmVyLWVkaXRcXFwiIG5hbWU9XFxcIm93bmVyLWVkaXRcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWMwIGJ0bi1zbSBmaWxlLWFkZCBvd25lci1mb3JtLXRvZ2dsZVxcXCI+QWRkIE93bmVyczwvYnV0dG9uPlxcbiAgICA8YnV0dG9uIGlkPVxcXCJvd25lci1jYW5jZWxcXFwiIG5hbWU9XFxcIm93bmVyLWNhbmNlbFxcXCIgY2xhc3M9XFxcImJ0biBidG4tYzAgYnRuLXNtIGZpbGUtYWRkIG93bmVyLWZvcm0tdG9nZ2xlXFxcIj5DYW5jZWw8L2J1dHRvbj5cXG4gICAgPGJ1dHRvbiBpZD1cXFwib3duZXItc2F2ZVxcXCIgbmFtZT1cXFwib3duZXItc2F2ZVxcXCIgY2xhc3M9XFxcImJ0biBidG4tYzIgYnRuLXNtIGZpbGUtYWRkIG93bmVyLWZvcm0tdG9nZ2xlXFxcIj5TdWJtaXQ8L2J1dHRvbj5cXG4gIDwvaDI+XFxuPC9kaXY+XFxuXFxuPGRpdiBpZD1cXFwicHJvamVjdC1vd25lcnMtZm9ybVxcXCIgY2xhc3M9XFxcImJveC1wYWQtbHIgYm94LXBhZC10IG93bmVyLWZvcm0tdG9nZ2xlXFxcIj5cXG4gIDxmb3JtIGNsYXNzPVxcXCJcXFwiIHJvbGU9XFxcImZvcm1cXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICA8aW5wdXQgc3R5bGU9XFxcIndpZHRoOiAxMDAlXFxcIiBpZD1cXFwib3duZXJzXFxcIiBuYW1lPVxcXCJvd25lcnNcXFwiIHR5cGU9XFxcImhpZGRlblxcXCIgdmFsdWU9XFxcIkFkZCBPd25lclxcXCIvPlxcbiAgICA8L2Rpdj5cXG4gIDwvZm9ybT5cXG48L2Rpdj5cXG5cXG48ZGl2IGlkPVxcXCJwcm9qZWN0LW93bmVycy1zaG93XFxcIiBjbGFzcz1cXFwiYm94LXBhZC1sciBib3gtcGFkLXQgb3duZXItZm9ybS10b2dnbGVcXFwiPlxcbiAgPCUgaWYgKGRhdGEub3duZXJzKSB7ICU+XFxuICAgIDwlIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5vd25lcnMubGVuZ3RoOyBpKyspIHsgJT5cXG4gICAgPGRpdiBjbGFzcz1cXFwicHJvamVjdC1wZW9wbGUtZGl2XFxcIiBkYXRhLXVzZXJpZD1cXFwiPCU9IGRhdGEub3duZXJzW2ldLnVzZXJJZCAlPlxcXCI+XFxuICAgICAgPGltZyBzcmM9XFxcIi9hcGkvdXNlci9waG90by88JT0gZGF0YS5vd25lcnNbaV0udXNlcklkICU+XFxcIiBjbGFzcz1cXFwicHJvamVjdC1wZW9wbGVcXFwiIGFsdD1cXFwiPCU9IGRhdGEub3duZXJzW2ldLm5hbWUgJT5cXFwiLz5cXG4gICAgICA8JSBpZiAoKGRhdGEuaXNPd25lciB8fCB1c2VyLmlzQWRtaW4pICYmIChkYXRhLm93bmVyc1tpXS51c2VySWQgIT0gY2FjaGUuY3VycmVudFVzZXIuaWQpICYmIGRhdGEuZWRpdCkgeyAlPlxcbiAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJkZWxldGUtcHJvamVjdG93bmVyIHByb2plY3Qtb3duZXItZGVsZXRlIGZhIGZhLXRpbWVzXFxcIiAgaWQ9XFxcImRlbGV0ZS1wcm9qZWN0b3duZXItPCU9IGRhdGEub3duZXJzW2ldLmlkICU+XFxcIiBkYXRhLXVpZD1cXFwiPCU9IGRhdGEub3duZXJzW2ldLnVzZXJJZCAlPlxcXCIgZGF0YS1wb2lkPVxcXCI8JT0gZGF0YS5vd25lcnNbaV0uaWQgJT5cXFwiPlxcbiAgICAgIDwvYT5cXG4gICAgICA8JSB9ICU+XFxuICAgIDwvZGl2PlxcbiAgICA8JSB9ICU+XFxuICA8JSB9ICU+XFxuPC9kaXY+XFxuXCI7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgYXN5bmMgPSByZXF1aXJlKCdhc3luYycpO1xudmFyIFBvcG92ZXJzID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vbWl4aW5zL3BvcG92ZXJzJyk7XG52YXIgTW9kYWxDb21wb25lbnQgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb21wb25lbnRzL21vZGFsJyk7XG52YXIgUHJvamVjdG93bmVyU2hvd1RlbXBsYXRlID0gcmVxdWlyZSgnLi4vdGVtcGxhdGVzL3Byb2plY3Rvd25lcl9zaG93X3RlbXBsYXRlLmh0bWwnKTtcblxuXG52YXIgUHJvamVjdG93bmVyU2hvd1ZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG5cbiAgZWw6IFwiI3Byb2plY3Rvd25lci13cmFwcGVyXCIsXG4gIG1vZGVsIDogbnVsbCxcblxuICAvLyBTZXQgdGhlIG1vZGVsIHRvIG51bGwsIGJlZm9yZSBpdCBpcyBmZXRjaGVkIGZyb20gdGhlIHNlcnZlci5cbiAgLy8gVGhpcyBhbGxvd3MgdXMgdG8gY2xlYXIgb3V0IHRoZSBwcmV2aW91cyBkYXRhIGZyb20gdGhlIGxpc3RfdmlldyxcbiAgLy8gYW5kIGdldCByZWFkeSBmb3IgdGhlIG5ldyBkYXRhIGZvciB0aGUgcHJvamVjdCBzaG93IHZpZXcuXG4gIC8vIG1vZGVsOiBudWxsLFxuXG4gIGV2ZW50czoge1xuICAgIFwiY2xpY2sgYnV0dG9uLm93bmVyLWZvcm0tdG9nZ2xlXCIgICAgICA6IFwidG9nZ2xlT3duZXJzXCIsXG4gICAgXCJjbGljayAjb3duZXItc2F2ZVwiICAgICAgICAgICAgICAgICAgIDogXCJzYXZlT3duZXJzXCIsXG4gICAgXCJjbGljayAjb3duZXItY2FuY2VsXCIgICAgICAgICAgICAgICAgIDogXCJpbml0aWFsaXplT3duZXJTZWxlY3QyXCIsXG4gICAgXCJjbGljayAuZGVsZXRlLXByb2plY3Rvd25lclwiICAgICAgICAgIDogXCJyZW1vdmVPd25lclwiXG4gIH0sXG5cbiAgLy8gVGhlIGluaXRpYWxpemUgbWV0aG9kIGlzIG1haW5seSB1c2VkIGZvciBldmVudCBiaW5kaW5ncyAoZm9yIGVmZmVjaWVuY3kpXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5kYXRhID0gb3B0aW9ucy5kYXRhO1xuICAgIHRoaXMuYWN0aW9uID0gb3B0aW9ucy5hY3Rpb247XG4gICAgdGhpcy51c2VyID0gd2luZG93LmNhY2hlLmN1cnJlbnRVc2VyIHx8IHt9O1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYWN0aW9uKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFjdGlvbiA9PSAnZWRpdCcpIHtcbiAgICAgICAgdGhpcy5lZGl0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm1vZGVsLm9uKFwicHJvamVjdG93bmVyOnNob3c6cmVuZGVyZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5pbml0aWFsaXplT3duZXJTZWxlY3QyKCk7XG4gICAgfSk7XG4gICAgLy93aGVuIG93bmVyIHNldCBpcyB1cGRhdGVkLCByZS1yZW5kZXIgYW5kIHJlLWluaXQgcG9wb3ZlcnNcbiAgICB0aGlzLm1vZGVsLm9uKFwicHJvamVjdDp1cGRhdGU6b3duZXJzOnN1Y2Nlc3NcIiwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHNlbGYucmVuZGVyKCk7XG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChwb3BvdmVycykpIHtcbiAgICAgICAgdmFyIHBvcG92ZXJzID0gbmV3IFBvcG92ZXJzKCk7XG4gICAgICAgIHBvcG92ZXJzLnBvcG92ZXJQZW9wbGVJbml0KFwiLnByb2plY3QtcGVvcGxlLWRpdlwiKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb21waWxlZFRlbXBsYXRlO1xuICAgIHZhciBkYXRhID0ge1xuICAgICAgZGF0YTogdGhpcy5tb2RlbC50b0pTT04oKSxcbiAgICAgIHVzZXI6IHRoaXMudXNlclxuICAgIH07XG4gICAgZGF0YS5kYXRhLmVkaXQgPSB0aGlzLmVkaXQ7XG4gICAgY29tcGlsZWRUZW1wbGF0ZSA9IF8udGVtcGxhdGUoUHJvamVjdG93bmVyU2hvd1RlbXBsYXRlKShkYXRhKTtcbiAgICB0aGlzLiRlbC5odG1sKGNvbXBpbGVkVGVtcGxhdGUpO1xuICAgIHRoaXMuJGVsLmkxOG4oKTtcblxuICAgIHRoaXMubW9kZWwudHJpZ2dlcihcInByb2plY3Rvd25lcjpzaG93OnJlbmRlcmVkXCIsIGRhdGEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGluaXRpYWxpemVPd25lclNlbGVjdDI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCh0aGlzLm1vZGVsLmF0dHJpYnV0ZXMuaXNPd25lciB8fCB0aGlzLnVzZXIuaXNBZG1pbikgJiYgdGhpcy5lZGl0KXtcbiAgICAgIHZhciBmb3JtYXRSZXN1bHQgPSBmdW5jdGlvbiAob2JqZWN0LCBjb250YWluZXIsIHF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiBvYmplY3QubmFtZTtcbiAgICAgIH07XG4gICAgICB2YXIgb2xkT3duZXJzID0gdGhpcy5tb2RlbC5hdHRyaWJ1dGVzLm93bmVycyB8fCBbXTtcbiAgICAgIHZhciBvbGRPd25lcklkcyA9IF8ubWFwKG9sZE93bmVycywgZnVuY3Rpb24ob3duZXIpeyByZXR1cm4gb3duZXIudXNlcklkIH0pIHx8IFtdO1xuXG4gICAgICBzZWxmLiQoXCIjb3duZXJzXCIpLnNlbGVjdDIoe1xuICAgICAgICBwbGFjZWhvbGRlcjogJ0FkZCAnICsgaTE4bi50KCdQcm9qZWN0JykgKyAnIE93bmVycycsXG4gICAgICAgIG11bHRpcGxlOiB0cnVlLFxuICAgICAgICBmb3JtYXRSZXN1bHQ6IGZvcm1hdFJlc3VsdCxcbiAgICAgICAgZm9ybWF0U2VsZWN0aW9uOiBmb3JtYXRSZXN1bHQsXG4gICAgICAgIG1pbmltdW1JbnB1dExlbmd0aDogMSxcbiAgICAgICAgYWpheDoge1xuICAgICAgICAgICAgdXJsOiAnL2FwaS9hYy91c2VyJyxcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgICAgICBkYXRhOiBmdW5jdGlvbiAodGVybSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHE6IHRlcm1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXN1bHRzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICByZXR1cm4geyByZXN1bHRzOiBfLmZpbHRlcihkYXRhLCBmdW5jdGlvbih1c2VyKXsgIHJldHVybiBfLmluZGV4T2YoIG9sZE93bmVySWRzLCB1c2VyLmlkKSA+PSAwID8gZmFsc2UgOiB0cnVlOyB9LCBzZWxmICkgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBzZWxmLiQoJyNvd25lci1lZGl0Jykuc2hvdygpO1xuXG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICBzZWxmLiQoJyNvd25lci1lZGl0JykuaGlkZSgpO1xuICAgIH1cblxuICAgIHNlbGYuJCgnI3Byb2plY3Qtb3duZXJzLWZvcm0nKS5oaWRlKCk7XG4gICAgc2VsZi4kKCcjcHJvamVjdC1vd25lcnMtc2hvdycpLnNob3coKTtcbiAgICBzZWxmLiQoJyNvd25lci1zYXZlJykuaGlkZSgpO1xuICAgIHNlbGYuJCgnI293bmVyLWNhbmNlbCcpLmhpZGUoKTtcblxuICB9LFxuXG4gIHRvZ2dsZU93bmVycyA6IGZ1bmN0aW9uKGUpe1xuICAgIGlmICghKHRoaXMubW9kZWwuYXR0cmlidXRlcy5pc093bmVyIHx8IHRoaXMudXNlci5pc0FkbWluKSAmJiB0aGlzLmVkaXQpIHJldHVybiBmYWxzZTtcbiAgICAkKCcub3duZXItZm9ybS10b2dnbGUnKS50b2dnbGUoNDAwKTtcbiAgfSxcblxuICBzYXZlT3duZXJzIDogZnVuY3Rpb24oZSl7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoISh0aGlzLm1vZGVsLmF0dHJpYnV0ZXMuaXNPd25lciB8fCB0aGlzLnVzZXIuaXNBZG1pbikgJiYgdGhpcy5lZGl0KSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHBJZCA9IHNlbGYubW9kZWwuYXR0cmlidXRlcy5pZDtcblxuICAgIHZhciBvbGRPd25lcnMgPSB0aGlzLm1vZGVsLmF0dHJpYnV0ZXMub3duZXJzIHx8IFtdO1xuICAgIHZhciBzMmRhdGEgPSAkKFwiI293bmVyc1wiKS5zZWxlY3QyKFwiZGF0YVwiKSAgfHwgW107XG4gICAgdmFyIHMyT3duZXJJZHMgPSBfLm1hcChzMmRhdGEsIGZ1bmN0aW9uKG93bmVyKXsgcmV0dXJuIG93bmVyLmlkIH0pIHx8IFtdO1xuXG4gICAgYXN5bmMuZWFjaChzMk93bmVySWRzLCBjcmVhdGVPd25lciwgZnVuY3Rpb24oKXsgc2VsZi5tb2RlbC50cmlnZ2VyKFwicHJvamVjdG93bmVyOnNob3c6Y2hhbmdlZFwiLCBvbGRPd25lcnMpOyB9KTtcblxuICAgICQoXCIjb3duZXJzXCIpLnNlbGVjdDIoXCJkYXRhXCIsIFtdKTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZU93bmVyKG93bmVySUQsIGRvbmUpe1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgJC5hamF4KHtcbiAgICAgICAgICB1cmw6ICcvYXBpL3Byb2plY3Rvd25lci8nLFxuICAgICAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBwcm9qZWN0SWQ6IHBJZCxcbiAgICAgICAgICAgIHVzZXJJZDogb3duZXJJRFxuICAgICAgICAgIH0sXG4gICAgICAgICAgc3VjY2VzcyA6IGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgdmFyIFBPSWQgPSBkYXRhLmlkO1xuICAgICAgICAgICAgb2xkT3duZXJzLnB1c2goeyBpZDpQT0lkLCB1c2VySWQ6IG93bmVySUR9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSkuZG9uZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICB9LFxuXG4gIHJlbW92ZU93bmVyOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGUuc3RvcFByb3BhZ2F0aW9uKCkpIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAkKGUuY3VycmVudFRhcmdldCkub2ZmKFwibW91c2VlbnRlclwiKTtcbiAgICAkKCcucG9wb3ZlcicpLnJlbW92ZSgpO1xuXG4gICAgdmFyIHBPSWQgPSAkKGUuY3VycmVudFRhcmdldCkuZGF0YSgncG9pZCcpO1xuICAgIHZhciB1SWQgPSAkKGUuY3VycmVudFRhcmdldCkuZGF0YSgndWlkJyk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKHR5cGVvZiBjYWNoZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB1SWQgIT09IGNhY2hlLmN1cnJlbnRVc2VyLmlkKVxuICAgIHtcbiAgICAgICQuYWpheCh7XG4gICAgICAgIHVybDogJy9hcGkvcHJvamVjdG93bmVyLycgKyBwT0lkLFxuICAgICAgICB0eXBlOiAnREVMRVRFJyxcbiAgICAgIH0pLmRvbmUoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAvLyBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgb2xkT3duZXJzID0gdGhpcy5tb2RlbC5hdHRyaWJ1dGVzLm93bmVycyB8fCBbXTtcbiAgICB2YXIgdW5jaGFuZ2VkT3duZXJzID0gXy5maWx0ZXIob2xkT3duZXJzLCBmdW5jdGlvbihvd25lcil7IHJldHVybiAoIG93bmVyLmlkICE9PSBwT0lkICk7IH0gLCB0aGlzKSAgfHwgW107XG4gICAgc2VsZi5tb2RlbC50cmlnZ2VyKFwicHJvamVjdG93bmVyOnNob3c6Y2hhbmdlZFwiLCB1bmNoYW5nZWRPd25lcnMpO1xuICB9LFxuXG5cblxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLz0gVXRpbGl0eSBNZXRob2RzXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBjbGVhbnVwOiBmdW5jdGlvbigpIHtcbiAgICByZW1vdmVWaWV3KHRoaXMpO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb2plY3Rvd25lclNob3dWaWV3O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxmb3JtIHJvbGU9XFxcImZvcm1cXFwiIGFjdGlvbj1cXFwiXFxcIiBpZD1cXFwidGFnLWZvcm1cXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwibW9kYWwtYm9keVxcXCI+XFxuICAgIDxmaWVsZHNldD5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcInRhZy1mb3JtLXR5cGVcXFwiPlRhZyBUeXBlPC9sYWJlbD5cXG4gICAgICAgIDxzZWxlY3QgaWQ9XFxcInRhZy1mb3JtLXR5cGVcXFwiIG5hbWU9XFxcInRhZy1mb3JtLXR5cGVcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiPlxcbiAgICAgICAgICA8JSBmb3IgKHZhciBpID0gMDsgaSA8IHRhZ3MubGVuZ3RoOyBpKyspIHsgJT5cXG4gICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiPCUtIHRhZ3NbaV0udHlwZSAlPlxcXCI+PCUtIHRhZ3NbaV0ubmFtZSAlPjwvb3B0aW9uPlxcbiAgICAgICAgICA8JSB9ICU+XFxuICAgICAgICA8L3NlbGVjdD5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcInRhZy1mb3JtLW5hbWVcXFwiPlxcbiAgICAgICAgICBUYWcgTmFtZVxcbiAgICAgICAgPC9sYWJlbD5cXG4gICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiBpZD1cXFwidGFnLWZvcm0tbmFtZVxcXCIgbmFtZT1cXFwidGFnLWZvcm0tbmFtZVxcXCIgcGxhY2Vob2xkZXI9XFxcIlRhZyBOYW1lXFxcIiBkYXRhLXZhbGlkYXRlPVxcXCJlbXB0eSxjb3VudDEwMFxcXCIvPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcImhlbHAtYmxvY2sgZXJyb3ItZW1wdHlcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIj5Zb3UgbXVzdCBlbnRlciBhIHRhZyBuYW1lLjwvc3Bhbj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJoZWxwLWJsb2NrIGVycm9yLWNvdW50MTAwXFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI+VGFncyBtdXN0IGJlIGxlc3MgdGhhbiAxMDAgY2hhcmFjdGVycyBpbiBsZW5ndGguPC9zcGFuPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2ZpZWxkc2V0PlxcbiAgPC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1mb290ZXJcXFwiPlxcbiAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tYzBcXFwiIGRhdGEtZGlzbWlzcz1cXFwibW9kYWxcXFwiPkNhbmNlbDwvYnV0dG9uPlxcbiAgICA8aW5wdXQgdHlwZT1cXFwic3VibWl0XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1jMlxcXCIgaWQ9XFxcInN1Ym1pdFxcXCIgdmFsdWU9XFxcIkNyZWF0ZSBUYWdcXFwiLz5cXG4gIDwvZGl2PlxcbjwvZm9ybT5cXG5cIjtcbiIsIlxudmFyIEJvb3RzdHJhcCA9IHJlcXVpcmUoJ2Jvb3RzdHJhcCcpO1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vbWl4aW5zL3V0aWxpdGllcycpO1xudmFyIFRhZ0Zvcm1UZW1wbGF0ZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy90YWdfbmV3X2Zvcm1fdGVtcGxhdGUuaHRtbCcpO1xuXG5cbnZhciBUYWdGb3JtVmlldyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcblxuICBldmVudHM6IHtcbiAgICBcImJsdXIgI3RhZy1mb3JtLW5hbWVcIiA6IFwidlwiLFxuICAgIFwic3VibWl0ICN0YWctZm9ybVwiICAgIDogXCJwb3N0XCJcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMudGFncyA9IG9wdGlvbnMudGFncztcbiAgICB0aGlzLnRhcmdldCA9IG9wdGlvbnMudGFyZ2V0O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICB0YWdzOiB0aGlzLnRhZ3NcbiAgICB9O1xuICAgIHZhciB0ZW1wbGF0ZSA9IF8udGVtcGxhdGUoVGFnRm9ybVRlbXBsYXRlKShkYXRhKTtcbiAgICB0aGlzLiRlbC5odG1sKHRlbXBsYXRlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICB2OiBmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiB2YWxpZGF0ZShlKTtcbiAgfSxcblxuICBwb3N0OiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAvLyBwZXJmb3JtIGZpZWxkIHZhbGlkYXRpb25cbiAgICB2YXIgdmFsaWRhdGVJZHMgPSBbJyN0YWctZm9ybS1uYW1lJ107XG4gICAgdmFyIGFib3J0ID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSBpbiB2YWxpZGF0ZUlkcykge1xuICAgICAgdmFyIGlBYm9ydCA9IHZhbGlkYXRlKHsgY3VycmVudFRhcmdldDogdmFsaWRhdGVJZHNbaV0gfSk7XG4gICAgICBhYm9ydCA9IGFib3J0IHx8IGlBYm9ydDtcbiAgICB9XG4gICAgaWYgKGFib3J0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYXNzZW1ibGUgZm9ybSBhbmQgc3VibWl0XG4gICAgdmFyIGRhdGE7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgZGF0YSA9IHtcbiAgICAgIHR5cGU6ICQoZS5jdXJyZW50VGFyZ2V0KS5maW5kKFwiI3RhZy1mb3JtLXR5cGVcIikudmFsKCksXG4gICAgICBuYW1lOiAkKGUuY3VycmVudFRhcmdldCkuZmluZChcIiN0YWctZm9ybS1uYW1lXCIpLnZhbCgpXG4gICAgfVxuXG4gICAgJC5hamF4KHtcbiAgICAgIHVybDogJy9hcGkvdGFnL2FkZCcsXG4gICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSkuZG9uZShmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAvLyBQYXNzIHRoZSB0YWcgYmFja1xuICAgICAgc2VsZi5vcHRpb25zLm1vZGVsLnRyaWdnZXIoc2VsZi50YXJnZXQgKyBcIjp0YWc6bmV3XCIsIHJlc3VsdCk7XG4gICAgfSk7XG5cbiAgfSxcblxuICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUYWdGb3JtVmlldztcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8bGk+PCUtIHRhZy50YWcubmFtZSAlPlxcbjwlIGlmICgoZGF0YS5pc093bmVyIHx8IHVzZXIuaXNBZG1pbikgJiYgZWRpdCkgeyAlPlxcbjxzcGFuIGNsYXNzPVxcXCJ0YWctZGVsZXRlIGZhIGZhLXRpbWVzXFxcIiBkYXRhLWlkPVxcXCI8JS0gdGFnLmlkICU+XFxcIj48L3NwYW4+XFxuPCUgfSAlPlxcbjwvbGk+XFxuXCI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPCUgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWdzLmxlbmd0aDsgaSsrKSB7ICU+XFxuPGRpdiBjbGFzcz1cXFwidGFnLXRpdGxlIDwlLSB0YWdzW2ldWydjbGFzcyddICU+XFxcIiBpZD1cXFwiPCUtIHRhZ3NbaV0uaWQgJT5cXFwiPlxcbiAgPGgyPjxpIGNsYXNzPVxcXCI8JS0gdGFnc1tpXS5pY29uICU+XFxcIj48L2k+IDxzcGFuIGNsYXNzPVxcXCJib3gtaWNvbi10ZXh0XFxcIj48JS0gdGFnc1tpXS5wbHVyYWwgJT48L3NwYW4+PC9oMj5cXG4gIDwlIGlmICgoZGF0YS5pc093bmVyIHx8IHVzZXIuaXNBZG1pbikgJiYgZWRpdCkgeyAlPlxcbiAgPGRpdiBzdHlsZT0nbWFyZ2luLWJvdHRvbTogNXB4Jz5cXG4gICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIGlkPVxcXCJ0YWdfPCUtIHRhZ3NbaV0uaWQudG9Mb3dlckNhc2UoKSAlPlxcXCIgY2xhc3M9XFxcImZ1bGx3aWR0aFxcXCIgbmFtZT1cXFwidGFnXzwlLSB0YWdzW2ldLm5hbWUudG9Mb3dlckNhc2UoKSAlPlxcXCIvPlxcbiAgPC9kaXY+XFxuICA8JSB9ICU+XFxuICA8dWwgY2xhc3M9XFxcInRhZ3NcXFwiPlxcbiAgICA8bGkgY2xhc3M9XFxcInRhZy1lbXB0eVxcXCIgaWQ9XFxcIjwlLSB0YWdzW2ldWydjbGFzcyddICU+LWVtcHR5XFxcIj5cXG4gICAgICA8JSBpZiAodGFnc1tpXVsnY2xhc3MnXSA9PT0gJ2xvY2F0aW9uJykgeyAlPkFueXdoZXJlPCUgfSBlbHNlIHsgJT5Ob25lPCUgfSAlPlxcbiAgICA8L2xpPlxcbiAgPC91bD5cXG48L2Rpdj5cXG48JSB9ICU+XFxuPCUgaWYgKGRhdGEudXNlcklkKSB7XFxuJT5cXG48ZGl2IGNsYXNzPVxcXCJ0YWctdGl0bGVcXFwiPlxcbiAgPGgyPjxpIGNsYXNzPVxcXCJmYSBmYS1jaGlsZCBcXFwiPjwvaT4gPHNwYW4gY2xhc3M9XFxcImJveC1pY29uLXRleHRcXFwiPlByb2dyZXNzPC9zcGFuPjwvaDI+XFxuICA8dWwgY2xhc3M9XFxcInRhZ3NcXFwiPlxcbiAgICA8bGkgY2xhc3M9XFxcInRhZy1lbXB0eVxcXCIgaWQ9XFxcInRhc2stbGVuZ3RoLWVtcHR5XFxcIiBzdHlsZT1cXFwiZGlzcGxheTogbm9uZTtcXFwiPk5vbmU8L2xpPlxcbiAgICA8bGk+UHVibGlzaGVkOiA8JS0gZGF0YS5wdWJsaXNoZWRBdCA/IG1vbWVudChkYXRhLnB1Ymxpc2hlZEF0KS5mb3JtYXQoJ2RkZCwgTU1NIEQsIFlZWVknKSA6ICctLScgJT48L2xpPjxicj5cXG4gICAgPGxpPkFzc2lnbmVkOiA8JS0gZGF0YS5hc3NpZ25lZEF0ID8gbW9tZW50KGRhdGEuYXNzaWduZWRBdCkuZm9ybWF0KCdkZGQsIE1NTSBELCBZWVlZJykgOiAnLS0nICU+PC9saT48YnI+XFxuICAgIDxsaT5Db21wbGV0ZWQ6IDwlLSBkYXRhLmNvbXBsZXRlZEF0ID8gbW9tZW50KGRhdGEuY29tcGxldGVkQXQpLmZvcm1hdCgnZGRkLCBNTU0gRCwgWVlZWScpIDogJy0tJyAlPjwvbGk+XFxuICA8L3VsPlxcbjwvZGl2PlxcbjwlIH0gJT5cXG5cIjtcbiIsIlxudmFyIEJvb3RzdHJhcCA9IHJlcXVpcmUoJ2Jvb3RzdHJhcCcpO1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vbWl4aW5zL3V0aWxpdGllcycpO1xudmFyIGFzeW5jID0gcmVxdWlyZSgnYXN5bmMnKTtcbnZhciBNb2RhbENvbXBvbmVudCA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2NvbXBvbmVudHMvbW9kYWwnKTtcbnZhciBUYWdDb25maWcgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb25maWcvdGFnJyk7XG52YXIgVGFnRm9ybVZpZXcgPSByZXF1aXJlKCcuLi8uLi9uZXcvdmlld3MvdGFnX25ld19mb3JtX3ZpZXcnKTtcbnZhciBUYWdUZW1wbGF0ZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy90YWdfaXRlbV90ZW1wbGF0ZS5odG1sJyk7XG52YXIgVGFnU2hvd1RlbXBsYXRlID0gcmVxdWlyZSgnLi4vdGVtcGxhdGVzL3RhZ19zaG93X3RlbXBsYXRlLmh0bWwnKTtcbnZhciBUYWdGYWN0b3J5ID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29tcG9uZW50cy90YWdfZmFjdG9yeScpO1xuXG5cbnZhciBUYWdTaG93VmlldyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcblxuICBldmVudHM6IHtcbiAgICBcImNsaWNrICN0YWctY3JlYXRlXCIgICAgIDogXCJjcmVhdGVUYWdcIixcbiAgICBcImNsaWNrICN0YWctc2F2ZVwiICAgICAgIDogXCJzYXZlVGFnXCIsXG4gICAgXCJjbGljayAudGFnLWRlbGV0ZVwiICAgICA6IFwiZGVsZXRlVGFnXCJcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5tb2RlbCA9IG9wdGlvbnMubW9kZWw7XG4gICAgdGhpcy50YXJnZXQgPSBvcHRpb25zLnRhcmdldDtcbiAgICB0aGlzLnRhcmdldElkID0gb3B0aW9ucy50YXJnZXRJZDtcbiAgICB0aGlzLmVkaXQgPSBvcHRpb25zLmVkaXQ7XG4gICAgdGhpcy50YWdGYWN0b3J5ID0gbmV3IFRhZ0ZhY3RvcnkoKTtcbiAgICB0aGlzLnRhZ3MgPSBbXTtcbiAgICAvLyBGaWd1cmUgb3V0IHdoaWNoIHRhZ3MgYXBwbHlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IFRhZ0NvbmZpZ1t0aGlzLnRhcmdldF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFRhZ0NvbmZpZy50YWdzW1RhZ0NvbmZpZ1t0aGlzLnRhcmdldF1baV1dKTtcbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBkYXRhOiB0aGlzLm1vZGVsLnRvSlNPTigpLFxuICAgICAgdGFnczogdGhpcy50YWdzLFxuICAgICAgZWRpdDogdGhpcy5lZGl0LFxuICAgICAgdXNlcjogd2luZG93LmNhY2hlLmN1cnJlbnRVc2VyIHx8IHt9XG4gICAgfTtcbiAgICB2YXIgdGVtcGxhdGUgPSBfLnRlbXBsYXRlKFRhZ1Nob3dUZW1wbGF0ZSkoZGF0YSk7XG4gICAgdGhpcy4kZWwuaHRtbCh0ZW1wbGF0ZSk7XG4gICAgdGhpcy5pbml0aWFsaXplU2VsZWN0MigpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZVRhZ3MoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBpbml0aWFsaXplU2VsZWN0MjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHNlbGYudGFnRmFjdG9yeS5jcmVhdGVUYWdEcm9wRG93bih7XG4gICAgICB0eXBlOlwic2tpbGxcIixzZWxlY3RvcjpcIiN0YWdfc2tpbGxcIix3aWR0aDogXCIxMDAlXCIsdG9rZW5TZXBhcmF0b3JzOiBbXCIsXCJdXG4gICAgfSk7XG5cbiAgICBzZWxmLnRhZ0ZhY3RvcnkuY3JlYXRlVGFnRHJvcERvd24oe1xuICAgICAgdHlwZTpcInRvcGljXCIsc2VsZWN0b3I6XCIjdGFnX3RvcGljXCIsd2lkdGg6IFwiMTAwJVwiLHRva2VuU2VwYXJhdG9yczogW1wiLFwiXVxuICAgIH0pO1xuXG4gICAgc2VsZi50YWdGYWN0b3J5LmNyZWF0ZVRhZ0Ryb3BEb3duKHt0eXBlOlwibG9jYXRpb25cIixzZWxlY3RvcjpcIiN0YWdfbG9jYXRpb25cIix3aWR0aDogXCIxMDAlXCJ9KTtcbiAgICBzZWxmLnRhZ0ZhY3RvcnkuY3JlYXRlVGFnRHJvcERvd24oe3R5cGU6XCJhZ2VuY3lcIixzZWxlY3RvcjpcIiN0YWdfYWdlbmN5XCIsd2lkdGg6IFwiMTAwJVwifSk7XG4gICAgc2VsZi5tb2RlbC50cmlnZ2VyKFwicHJvZmlsZTppbnB1dDpjaGFuZ2VkXCIpO1xuICB9LFxuXG4gIGluaXRpYWxpemVUYWdzOiBmdW5jdGlvbigpIHtcbiAgICAvLyBMb2FkIHRhZ3MgZm9yIHRoZSB2aWV3XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHRhZ0ljb24gPSB7fTtcbiAgICB2YXIgdGFnQ2xhc3MgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudGFncy5sZW5ndGg7IGkrKykge1xuICAgICAgdGFnSWNvblt0aGlzLnRhZ3NbaV0udHlwZV0gPSB0aGlzLnRhZ3NbaV0uaWNvbjtcbiAgICAgIHRhZ0NsYXNzW3RoaXMudGFnc1tpXS50eXBlXSA9IHRoaXMudGFnc1tpXVsnY2xhc3MnXTtcbiAgICB9XG5cbiAgICB2YXIgcmVuZGVyVGFnID0gZnVuY3Rpb24gKHRhZykge1xuICAgICAgdmFyIHRlbXBsRGF0YSA9IHtcbiAgICAgICAgZGF0YTogc2VsZi5tb2RlbC50b0pTT04oKSxcbiAgICAgICAgdGFnczogc2VsZi50YWdzLFxuICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgZWRpdDogc2VsZi5lZGl0LFxuICAgICAgICB1c2VyOiB3aW5kb3cuY2FjaGUuY3VycmVudFVzZXIgfHwge31cbiAgICAgIH07XG4gICAgICB2YXIgY29tcGlsZWRUZW1wbGF0ZSA9IF8udGVtcGxhdGUoVGFnVGVtcGxhdGUpKHRlbXBsRGF0YSk7XG4gICAgICB2YXIgdGFnRG9tID0gJChcIi5cIiArIHRhZy50YWcudHlwZSkuY2hpbGRyZW4oXCIudGFnc1wiKTtcbiAgICAgIHRhZ0RvbS5hcHBlbmQoY29tcGlsZWRUZW1wbGF0ZSk7XG4gICAgICAkKCcjJyArIHRhZ0NsYXNzW3RhZy50YWcudHlwZV0gKyAnLWVtcHR5JykuaGlkZSgpO1xuICAgIH07XG5cbiAgICAkLmFqYXgoe1xuICAgICAgdXJsOiB0aGlzLm9wdGlvbnMudXJsICsgdGhpcy5tb2RlbC5pZFxuICAgIH0pLmRvbmUoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBSZW5kZXIgdGFncyBvbnRvIHBhZ2VcbiAgICAgICAgcmVuZGVyVGFnKGRhdGFbaV0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBTZWxlY3QyIGZvciBBZG1pbmlzdHJhdGl2ZSBGdW5jdGlvbnNcbiAgICB2YXIgZm9ybWF0UmVzdWx0ID0gZnVuY3Rpb24gKG9iamVjdCwgY29udGFpbmVyLCBxdWVyeSkge1xuICAgICAgcmV0dXJuICc8aSBjbGFzcz1cIicgKyB0YWdJY29uW29iamVjdC50eXBlXSArICdcIj48L2k+ICcgKyBvYmplY3QubmFtZTtcbiAgICB9O1xuXG4gICAgJChcIiNpbnB1dC10YWdzXCIpLnNlbGVjdDIoe1xuICAgICAgcGxhY2Vob2xkZXI6ICdBZGQgdGFncycsXG4gICAgICBtdWx0aXBsZTogdHJ1ZSxcbiAgICAgIGZvcm1hdFJlc3VsdDogZm9ybWF0UmVzdWx0LFxuICAgICAgZm9ybWF0U2VsZWN0aW9uOiBmb3JtYXRSZXN1bHQsXG4gICAgICBhamF4OiB7XG4gICAgICAgIHVybDogJy9hcGkvYWMvdGFnJyxcbiAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgZGF0YTogZnVuY3Rpb24gKHRlcm0pIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogVGFnQ29uZmlnW3NlbGYudGFyZ2V0XS5qb2luKCksXG4gICAgICAgICAgICBxOiB0ZXJtXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzdWx0czogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICByZXR1cm4geyByZXN1bHRzOiBkYXRhIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIE5ldyB0YWdzIGFkZGVkIGluIHRvIHRoZSBEQiB2aWEgdGhlIG1vZGFsXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCB0aGlzLnRhcmdldCArIFwiOnRhZzpuZXdcIiwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIC8vIERlc3RvcnkgbW9kYWxcbiAgICAgICQoXCIubW9kYWxcIikubW9kYWwoJ2hpZGUnKTtcbiAgICAgIC8vIEFkZCB0YWcgaW50byB0aGUgZGF0YSBsaXN0XG4gICAgICB2YXIgczJkYXRhID0gJChcIiNpbnB1dC10YWdzXCIpLnNlbGVjdDIoXCJkYXRhXCIpO1xuICAgICAgczJkYXRhLnB1c2goZGF0YSk7XG4gICAgICAkKFwiI2lucHV0LXRhZ3NcIikuc2VsZWN0MihcImRhdGFcIiwgczJkYXRhKTtcbiAgICB9KTtcblxuICAgIC8vIFRhZ3Mgc2F2ZWQgdXNpbmcgdGhlIHNlbGVjdDIgZGlhbG9nXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCB0aGlzLnRhcmdldCArIFwiOnRhZzpzYXZlXCIsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFkYXRhW2ldLmV4aXN0aW5nKSB7XG4gICAgICAgICAgcmVuZGVyVGFnKGRhdGFbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAkKFwiI2lucHV0LXRhZ3NcIikuc2VsZWN0MihcInZhbFwiLCBcIlwiKTtcbiAgICB9KTtcblxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbCwgdGhpcy50YXJnZXQgKyBcIjp0YWc6ZGVsZXRlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoJChlLmN1cnJlbnRUYXJnZXQpLnBhcmVudCgnbGknKS5zaWJsaW5ncygpLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICQoZS5jdXJyZW50VGFyZ2V0KS5wYXJlbnQoJ2xpJykuc2libGluZ3MoJy50YWctZW1wdHknKS5zaG93KCk7XG4gICAgICB9XG4gICAgICAkKGUuY3VycmVudFRhcmdldCkucGFyZW50KCdsaScpLnJlbW92ZSgpO1xuICAgIH0pO1xuICB9LFxuXG4gIGNyZWF0ZVRhZzogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIFBvcCB1cCBkaWFsb2cgYm94IHRvIGNyZWF0ZSB0YWcsXG4gICAgLy8gdGhlbiBwdXQgdGFnIGludG8gdGhlIHNlbGVjdCBib3hcbiAgICBpZiAoXy5pc1VuZGVmaW5lZCh0aGlzLm1vZGFsQ29tcG9uZW50KSkge1xuICAgICAgdGhpcy5tb2RhbENvbXBvbmVudCA9IG5ldyBNb2RhbENvbXBvbmVudCh7XG4gICAgICAgIGVsOiBcIiNjb250YWluZXJcIixcbiAgICAgICAgaWQ6IFwiY3JlYXRlVGFnXCIsXG4gICAgICAgIG1vZGFsVGl0bGU6IFwiQ3JlYXRlIFRhZ1wiXG4gICAgICB9KS5yZW5kZXIoKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQodGhpcy5tb2RhbENvbXBvbmVudCkpIHtcbiAgICAgIGlmICh0aGlzLnRhZ0Zvcm1WaWV3KSB7XG4gICAgICAgIHRoaXMudGFnRm9ybVZpZXcuY2xlYW51cCgpO1xuICAgICAgfVxuICAgICAgdGhpcy50YWdGb3JtVmlldyA9IG5ldyBUYWdGb3JtVmlldyh7XG4gICAgICAgIGVsOiBcIiNjcmVhdGVUYWcgLm1vZGFsLXRlbXBsYXRlXCIsXG4gICAgICAgIG1vZGVsOiBzZWxmLm1vZGVsLFxuICAgICAgICB0YWdzOiBzZWxmLnRhZ3MsXG4gICAgICAgIHRhcmdldDogc2VsZi50YXJnZXRcbiAgICAgIH0pO1xuICAgICAgdGhpcy50YWdGb3JtVmlldy5yZW5kZXIoKTtcbiAgICB9XG4gIH0sXG5cbiAgc2F2ZVRhZzogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAvLyBDeWNsZSB0aHJvdWdoIHRhZ3MgaW4gc2VsZWN0IGJveFxuICAgIC8vIGFuZCBjYWxsIGNyZWF0ZSBvbiBlYWNoIG9uZSwgdGhlblxuICAgIC8vIHJlbmRlclxuICAgICQoXCIjdGFnLXNhdmVcIikuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XG4gICAgdmFyIGRhdGEgPSAkKFwiI2lucHV0LXRhZ3NcIikuc2VsZWN0MignZGF0YScpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgIHZhciBwcm9jZXNzVGFnID0gZnVuY3Rpb24odGFnLCBkb25lKSB7XG4gICAgICB2YXIgdGFnTWFwID0ge1xuICAgICAgICB0YWdJZDogdGFnLmlkXG4gICAgICB9O1xuICAgICAgaWYgKHNlbGYudGFyZ2V0SWQpIHtcbiAgICAgICAgdGFnTWFwW3NlbGYudGFyZ2V0SWRdID0gc2VsZi5tb2RlbC5pZDtcbiAgICAgIH1cbiAgICAgICQuYWpheCh7XG4gICAgICAgIHVybDogJy9hcGkvdGFnJyxcbiAgICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgICBkYXRhOiB0YWdNYXBcbiAgICAgIH0pLmRvbmUoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goZGF0YSk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBhc3luYy5lYWNoKGRhdGEsIHByb2Nlc3NUYWcsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGF0YS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmIChyZXN1bHRbaV0udGFnSWQgPT0gZGF0YVtqXS5pZCkge1xuICAgICAgICAgICAgcmVzdWx0W2ldLnRhZyA9IGRhdGFbal07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgICQoXCIjdGFnLXNhdmVcIikucmVtb3ZlQ2xhc3MoJ2Rpc2FibGVkJyk7XG4gICAgICBzZWxmLm1vZGVsLnRyaWdnZXIoc2VsZi5vcHRpb25zLnRhcmdldCArIFwiOnRhZzpzYXZlXCIsIHJlc3VsdCk7XG4gICAgfSk7XG5cbiAgfSxcblxuICBkZWxldGVUYWc6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgLy8gR2V0IHRoZSBkYXRhLWlkIG9mIHRoZSBjdXJyZW50VGFyZ2V0XG4gICAgLy8gYW5kIHRoZW4gY2FsbCBIVFRQIERFTEVURSBvbiB0aGF0IHRhZyBpZFxuICAgICQuYWpheCh7XG4gICAgICB1cmw6ICcvYXBpL3RhZy8nICsgJChlLmN1cnJlbnRUYXJnZXQpLmRhdGEoJ2lkJyksXG4gICAgICB0eXBlOiAnREVMRVRFJyxcbiAgICB9KS5kb25lKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBzZWxmLm1vZGVsLnRyaWdnZXIoc2VsZi5vcHRpb25zLnRhcmdldCArIFwiOnRhZzpkZWxldGVcIiwgZSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgY2xlYW51cDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnRhZ0Zvcm1WaWV3KSB7IHRoaXMudGFnRm9ybVZpZXcuY2xlYW51cCgpOyB9XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUYWdTaG93VmlldztcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8Zm9ybSBhY3Rpb249XFxcIlxcXCIgaWQ9XFxcInRhc2stZWRpdC1mb3JtXFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICA8aDIgY2xhc3M9XFxcImJveC1wYWQtdFxcXCI+XFxuICAgICAgPHNwYW4gZGF0YS1pMThuPVxcXCJUYXNrXFxcIj5PcHBvcnR1bml0eTwvc3Bhbj4gVGl0bGVcXG4gICAgPC9oMj5cXG4gICAgPGlucHV0IGlkPVxcXCJ0YXNrLXRpdGxlXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBwbGFjZWhvbGRlcj1cXFwiQSBzaG9ydCBkZXNjcmlwdGlvbiBvZiB0aGUgcHJvYmxlbS5cXFwiIHZhbHVlPVxcXCI8JS0gZGF0YS50aXRsZSAlPlxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbCBpbnB1dC1sZyB2YWxpZGF0ZVxcXCIgZGF0YS12YWxpZGF0ZT1cXFwiZW1wdHksY291bnQxMDBcXFwiLz5cXG4gICAgPHNwYW4gY2xhc3M9XFxcImhlbHAtYmxvY2sgZXJyb3ItZW1wdHlcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIj5Zb3UgbXVzdCBlbnRlciBhIHRpdGxlIGZvciB0aGlzIDxzcGFuIGRhdGEtaTE4bj1cXFwidGFza1xcXCI+b3Bwb3J0dW5pdHk8L3NwYW4+PC9zcGFuPlxcbiAgICA8c3BhbiBjbGFzcz1cXFwiaGVscC1ibG9jayBlcnJvci1jb3VudDEwMFxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPlRoZSBzaG9ydCBkZXNjcmlwdGlvbiBvZiB0aGUgcHJvYmxlbSBtdXN0IGJlIGxlc3MgdGhhbiAxMDAgY2hhcmFjdGVycy48L3NwYW4+XFxuICA8L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICA8aDIgY2xhc3M9XFxcImJveC1wYWQtdFxcXCI+XFxuICAgICAgPHNwYW4gZGF0YS1pMThuPVxcXCJUYXNrXFxcIj5PcHBvcnR1bml0eTwvc3Bhbj4gRGVzY3JpcHRpb25cXG4gICAgPC9oMj5cXG4gICAgPGRpdiBjbGFzcz1cXFwibWFya2Rvd24tZWRpdFxcXCI+PC9kaXY+XFxuICAgIDxzcGFuIGNsYXNzPVxcXCJoZWxwLWJsb2NrIGVycm9yLWVtcHR5XFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI+WW91IG11c3QgZW50ZXIgYSBkZXNjcmlwdGlvbiBmb3IgdGhpcyA8c3BhbiBkYXRhLWkxOG49XFxcInRhc2tcXFwiPm9wcG9ydHVuaXR5PC9zcGFuPjwvc3Bhbj5cXG4gIDwvZGl2PlxcbiAgPGhyIC8+XFxuXFxuICA8JSBpZiAodWkucHJvamVjdC5zaG93KSB7ICU+XFxuICBUaGlzIDxzcGFuIGRhdGEtaTE4bj1cXFwidGFza1xcXCI+b3Bwb3J0dW5pdHk8L3NwYW4+IGJlbG9uZ3MgdG8gdGhlIDxzcGFuIGRhdGEtaTE4bj1cXFwicHJvamVjdFxcXCI+cHJvamVjdDwvc3Bhbj46XFxuICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMTJcXFwiPlxcbiAgICAgIDxpbnB1dCB0eXBlPVxcXCJoaWRkZW5cXFwiIGlkPVxcXCJwcm9qZWN0SWRcXFwiIGNsYXNzPVxcXCJ0YXNrLXNraWxscyBmdWxsd2lkdGhcXFwiIC8+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuICA8JSB9ICU+XFxuXFxuICA8aHIvPlxcblxcbiAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTEyXFxcIj5cXG4gICAgICAgIDxzcGFuIGRhdGEtaTE4bj1cXFwiVGFza093bmVyXFxcIj5UYXNrIE93bmVyPC9zcGFuPlxcbiAgICAgICAgPGlucHV0IHN0eWxlPVxcXCJ3aWR0aDogMTAwJVxcXCIgaWQ9XFxcIm93bmVyXFxcIiBuYW1lPVxcXCJvd25lclxcXCIgdHlwZT1cXFwiaGlkZGVuXFxcIiB2YWx1ZT1cXFwiRWRpdCBPd25lclxcXCIvPlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcblxcbiAgPGhyLz5cXG5cXG4gIDxkaXYgY2xhc3M9XFxcInRhc2stZWRpdC1kZXNjcmlwdGlvblxcXCI+XFxuICAgIFdlIG5lZWRcXG4gICAgPHNlbGVjdCBpZD1cXFwicGVvcGxlXFxcIiBjbGFzcz1cXFwiZHJvcGRvd25cXFwiPlxcbiAgICAgIDwlIF8uZWFjaCh0YWdUeXBlc1sndGFzay1wZW9wbGUnXSwgZnVuY3Rpb24gKHQpIHsgJT5cXG4gICAgICA8b3B0aW9uIHZhbHVlPTwlPSB0LmlkICU+IDwlIGlmIChtYWRsaWJUYWdzWyd0YXNrLXBlb3BsZSddICYmIChtYWRsaWJUYWdzWyd0YXNrLXBlb3BsZSddWzBdLmlkID09IHQuaWQpKSB7ICU+c2VsZWN0ZWQ8JSB9ICU+PjwlPSB0Lm5hbWUgJT48L29wdGlvbj5cXG4gICAgICA8JSB9KTsgJT5cXG4gICAgPC9zZWxlY3Q+XFxuXFxuICAgIHRvIHdvcmsgb24gYW4gPHNwYW4gZGF0YS1pMThuPVxcXCJ0YXNrXFxcIj5vcHBvcnR1bml0eTwvc3Bhbj4gYWJvdXQ6XFxuICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTEyXFxcIj5cXG4gICAgICAgIDxpbnB1dCB0eXBlPVxcXCJoaWRkZW5cXFwiIGlkPVxcXCJ0YXNrX3RhZ190b3BpY3NcXFwiIGNsYXNzPVxcXCJ0YXNrLXNraWxscyBmdWxsd2lkdGhcXFwiIC8+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8aHIgLz5cXG5cXG4gICAgVGhlIGZvbGxvd2luZyBza2lsbHMgYXJlIHVzZWZ1bCBhbmRcXG4gICAgPHNlbGVjdCBpZD1cXFwic2tpbGxzLXJlcXVpcmVkXFxcIiBjbGFzcz1cXFwiZHJvcGRvd25cXFwiPlxcbiAgICAgIDwlIF8uZWFjaCh0YWdUeXBlc1sndGFzay1za2lsbHMtcmVxdWlyZWQnXSwgZnVuY3Rpb24gKHQpIHsgJT5cXG4gICAgICA8b3B0aW9uIHZhbHVlPTwlPSB0LmlkICU+IDwlIGlmIChtYWRsaWJUYWdzWyd0YXNrLXNraWxscy1yZXF1aXJlZCddICYmIChtYWRsaWJUYWdzWyd0YXNrLXNraWxscy1yZXF1aXJlZCddWzBdLmlkID09IHQuaWQpKSB7ICU+c2VsZWN0ZWQ8JSB9ICU+PjwlPSB0Lm5hbWUgJT48L29wdGlvbj5cXG4gICAgICA8JSB9KTsgJT5cXG4gICAgPC9zZWxlY3Q+XFxuXFxuICAgIHRvIGNvbXBsZXRlIHRoaXMgPHNwYW4gZGF0YS1pMThuPVxcXCJ0YXNrXFxcIj5vcHBvcnR1bml0eTwvc3Bhbj4geW91IHNob3VsZFxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0xMlxcXCI+XFxuICAgICAgICA8aW5wdXQgdHlwZT1cXFwiaGlkZGVuXFxcIiBpZD1cXFwidGFza190YWdfc2tpbGxzXFxcIiBjbGFzcz1cXFwidGFzay1za2lsbHMgZnVsbHdpZHRoXFxcIi8+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8aHIgLz5cXG5cXG4gICAgVGhlIDxzcGFuIGRhdGEtaTE4bj1cXFwidGFza1xcXCI+b3Bwb3J0dW5pdHk8L3NwYW4+IHdpbGwgcmVxdWlyZVxcbiAgICA8c2VsZWN0IGlkPVxcXCJ0aW1lLWVzdGltYXRlXFxcIiBjbGFzcz1cXFwiZHJvcGRvd25cXFwiPlxcbiAgICAgIDwlIF8uZWFjaCh0YWdUeXBlc1sndGFzay10aW1lLWVzdGltYXRlJ10sIGZ1bmN0aW9uICh0KSB7ICU+XFxuICAgICAgPG9wdGlvbiB2YWx1ZT08JT0gdC5pZCAlPiA8JSBpZiAobWFkbGliVGFnc1sndGFzay10aW1lLWVzdGltYXRlJ10gJiYgKG1hZGxpYlRhZ3NbJ3Rhc2stdGltZS1lc3RpbWF0ZSddWzBdLmlkID09IHQuaWQpKSB7ICU+c2VsZWN0ZWQ8JSB9ICU+PjwlPSB0Lm5hbWUgJT48L29wdGlvbj5cXG4gICAgICA8JSB9KTsgJT5cXG4gICAgPC9zZWxlY3Q+XFxuXFxuICAgIG9mXFxuICAgIDxzZWxlY3QgaWQ9XFxcInRpbWUtcmVxdWlyZWRcXFwiIGNsYXNzPVxcXCJkcm9wZG93blxcXCI+XFxuICAgICAgPCUgXy5lYWNoKHRhZ1R5cGVzWyd0YXNrLXRpbWUtcmVxdWlyZWQnXSwgZnVuY3Rpb24gKHQpIHsgJT5cXG4gICAgICA8b3B0aW9uIHZhbHVlPTwlPSB0LmlkICU+IDwlIGlmIChtYWRsaWJUYWdzWyd0YXNrLXRpbWUtcmVxdWlyZWQnXSAmJiAobWFkbGliVGFnc1sndGFzay10aW1lLXJlcXVpcmVkJ11bMF0uaWQgPT0gdC5pZCkpIHsgJT5zZWxlY3RlZDwlIH0gJT4+PCU9IHQubmFtZSAlPjwvb3B0aW9uPlxcbiAgICAgIDwlIH0pOyAlPlxcbiAgICA8L3NlbGVjdD5cXG5cXG4gICAgd29yaywgYW5kIG11c3QgYmUgY29tcGxldGVkIHdpdGhpblxcbiAgICA8c2VsZWN0IGlkPVxcXCJsZW5ndGhcXFwiIGNsYXNzPVxcXCJkcm9wZG93blxcXCI+XFxuICAgICAgPCUgXy5lYWNoKHRhZ1R5cGVzWyd0YXNrLWxlbmd0aCddLCBmdW5jdGlvbiAodCkgeyAlPlxcbiAgICAgIDxvcHRpb24gdmFsdWU9PCU9IHQuaWQgJT4gPCUgaWYgKG1hZGxpYlRhZ3NbJ3Rhc2stbGVuZ3RoJ10gJiYgKG1hZGxpYlRhZ3NbJ3Rhc2stbGVuZ3RoJ11bMF0uaWQgPT0gdC5pZCkpIHsgJT5zZWxlY3RlZDwlIH0gJT4+PCU9IHQubmFtZSAlPjwvb3B0aW9uPlxcbiAgICAgIDwlIH0pOyAlPlxcbiAgICA8L3NlbGVjdD5cXG5cXG4gICAgPGhyIC8+XFxuXFxuICAgIFBhcnRpY2lwYW50cyBtdXN0IGJlIGxvY2F0ZWQgYXQ6PGJyLz5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMTJcXFwiPlxcbiAgICAgICAgPGlucHV0IHR5cGU9XFxcImhpZGRlblxcXCIgaWQ9XFxcInRhc2tfdGFnX2xvY2F0aW9uXFxcIiBjbGFzcz1cXFwidGFzay1za2lsbHMgZnVsbHdpZHRoXFxcIi8+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8c21hbGw+TGVhdmUgZW1wdHkgaWYgcGVvcGxlIGNhbiBwYXJ0aWNpcGF0ZSBmcm9tIGFueXdoZXJlPC9zbWFsbD5cXG5cXG4gICAgPGhyLz5cXG5cXG4gICAgUHViaXNoZWQgZGF0ZTo8YnI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0xMiBwYWRkaW5nLW5vbmVcXFwiIGlkPVxcXCJkaXYtcHVibGlzaGVkQXRcXFwiPlxcbiAgICAgIDxpbnB1dCBpZD1cXFwicHVibGlzaGVkQXRcXFwiIG5hbWU9XFxcInB1Ymxpc2hlZEF0XFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sIHRpbWVwaWNrZXJcXFwiIHR5cGU9XFxcInRleHRcXFwiPlxcbiAgICA8L2Rpdj5cXG4gICAgQXNzaWduZWQgZGF0ZTo8YnI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0xMiBwYWRkaW5nLW5vbmVcXFwiIGlkPVxcXCJkaXYtYXNzaWduZWRBdFxcXCI+XFxuICAgICAgPGlucHV0IGlkPVxcXCJhc3NpZ25lZEF0XFxcIiBuYW1lPVxcXCJhc3NpZ25lZEF0XFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sIHRpbWVwaWNrZXJcXFwiIHR5cGU9XFxcInRleHRcXFwiPlxcbiAgICA8L2Rpdj5cXG4gICAgQ29tcGxldGVkIGRhdGU6PGJyPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMTIgcGFkZGluZy1ub25lXFxcIiBpZD1cXFwiZGl2LWNvbXBsZXRlZEF0XFxcIj5cXG4gICAgICA8aW5wdXQgaWQ9XFxcImNvbXBsZXRlZEF0XFxcIiBuYW1lPVxcXCJjb21wbGV0ZWRBdFxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbCB0aW1lcGlja2VyXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcImNsZWFyZml4XFxcIj5cXG4gICAgICA8aHI+XFxuICAgIDwvZGl2PlxcblxcbiAgPC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbGctMTJcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInB1bGwtcmlnaHQgYm94LXBhZC1iXFxcIj5cXG4gICAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ0biBidG4tYzBcXFwiIGlkPVxcXCJ0YXNrLXZpZXdcXFwiPkRpc2NhcmQgQ2hhbmdlczwvYnV0dG9uPlxcbiAgICAgICAgPGlucHV0IHR5cGU9XFxcInN1Ym1pdFxcXCIgY2xhc3M9XFxcImJ0biBidG4tYzJcXFwiIGRhdGEtaTE4bj1cXFwiW3ZhbHVlXVNhdmVUYXNrXFxcIiB2YWx1ZT1cXFwiU2F2ZSBPcHBvcnR1bml0eVxcXCIvPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZm9ybT5cXG5cIjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJwcm9qZWN0LXBlb3BsZS1kaXZcXFwiIGRhdGEtdXNlcmlkPVxcXCI8JT0gZGF0YS51c2VySWQgJT5cXFwiPlxcbiAgPGltZyBzcmM9XFxcIi9hcGkvdXNlci9waG90by88JT0gZGF0YS51c2VySWQgJT5cXFwiIGNsYXNzPVxcXCJwcm9qZWN0LXBlb3BsZVxcXCIgYWx0PVxcXCI8JT0gZGF0YS5vd25lci5uYW1lICU+XFxcIi8+XFxuPC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwicHJvamVjdC1wZW9wbGUtc3BhY2VcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiYmFyXFxcIj48L2Rpdj5cXG48L2Rpdj5cXG48JSBfLmVhY2goZGF0YS52b2x1bnRlZXJzLCBmdW5jdGlvbiAodikgeyAlPlxcbiAgPGRpdiBjbGFzcz1cXFwicHJvamVjdC1wZW9wbGUtZGl2XFxcIiBkYXRhLXVzZXJpZD1cXFwiPCU9IHYudXNlcklkICU+XFxcIiBkYXRhLXZvbHVzZXJpZD1cXFwiPCU9IHYudXNlcklkICU+XFxcIj5cXG4gICAgPGltZyBzcmM9XFxcIi9hcGkvdXNlci9waG90by88JT0gdi51c2VySWQgJT5cXFwiIGNsYXNzPVxcXCJwcm9qZWN0LXBlb3BsZVxcXCIgYWx0PVxcXCI8JT0gdi5uYW1lICU+XFxcIi8+XFxuICAgIDxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJkZWxldGUtdm9sdW50ZWVyIHZvbHVudGVlci1kZWxldGUgZmEgZmEtdGltZXNcXFwiICBpZD1cXFwiZGVsZXRlLXZvbHVudGVlci08JT0gdi5pZCAlPlxcXCIgZGF0YS11aWQ9XFxcIjwlPSB2LnVzZXJJZCAlPlxcXCIgZGF0YS12aWQ9XFxcIjwlPSB2LmlkICU+XFxcIj48L2E+XFxuICA8L2Rpdj5cXG48JSB9KTsgJT5cXG5cIjtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciB1dGlsaXRpZXMgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgVUlDb25maWcgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb25maWcvdWkuanNvbicpO1xudmFyIGFzeW5jID0gcmVxdWlyZSgnYXN5bmMnKTtcbnZhciBtYXJrZWQgPSByZXF1aXJlKCdtYXJrZWQnKTtcbnZhciBNYXJrZG93bkVkaXRvciA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2NvbXBvbmVudHMvbWFya2Rvd25fZWRpdG9yJyk7XG52YXIgVGFza0VkaXRGb3JtVGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvdGFza19lZGl0X2Zvcm1fdGVtcGxhdGUuaHRtbCcpO1xudmFyIFZvbHVudGVlckVkaXRGb3JtVGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvdm9sdW50ZWVyX2VkaXRfZm9ybV90ZW1wbGF0ZS5odG1sJyk7XG52YXIgVGFnRmFjdG9yeSA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2NvbXBvbmVudHMvdGFnX2ZhY3RvcnknKTtcblxuXG52YXIgVGFza0VkaXRGb3JtVmlldyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcblxuICBldmVudHM6IHtcbiAgICAnYmx1ciAudmFsaWRhdGUnICAgICAgICAgOiAndicsXG4gICAgJ2NsaWNrICN0YXNrLXZpZXcnICAgICAgIDogJ3ZpZXcnLFxuICAgICdzdWJtaXQgI3Rhc2stZWRpdC1mb3JtJyA6ICdzdWJtaXQnXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMudGFnRmFjdG9yeSA9IG5ldyBUYWdGYWN0b3J5KCk7XG4gICAgdGhpcy5kYXRhID0ge307XG4gICAgdGhpcy5kYXRhLm5ld1RhZyA9IHt9O1xuICAgIHRoaXMuaW5pdGlhbGl6ZUxpc3RlbmVycygpO1xuICAgIC8vIFJlZ2lzdGVyIGxpc3RlbmVyIHRvIHRhc2sgdXBkYXRlLCB0aGUgbGFzdCBzdGVwIG9mIHNhdmluZ1xuICAgIHRoaXMubGlzdGVuVG8odGhpcy5vcHRpb25zLm1vZGVsLCBcInRhc2s6dXBkYXRlOnN1Y2Nlc3NcIiwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIEJhY2tib25lLmhpc3RvcnkubmF2aWdhdGUoJ3Rhc2tzLycgKyBkYXRhLmF0dHJpYnV0ZXMuaWQsIHsgdHJpZ2dlcjogdHJ1ZSB9KTtcbiAgICB9KTtcbiAgfSxcblxuICB2aWV3OiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgQmFja2JvbmUuaGlzdG9yeS5uYXZpZ2F0ZSgndGFza3MvJyArIHRoaXMubW9kZWwuYXR0cmlidXRlcy5pZCwgeyB0cmlnZ2VyOiB0cnVlIH0pO1xuICB9LFxuXG4gIHY6IGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlKGUpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb21waWxlZFRlbXBsYXRlLCB2b2x1bnRlZXJUZW1wbGF0ZTtcblxuICAgIHRoaXMuZGF0YSA9IHtcbiAgICAgIGRhdGE6IHRoaXMubW9kZWwudG9KU09OKCksXG4gICAgICB0YWdUeXBlczogdGhpcy5vcHRpb25zLnRhZ1R5cGVzLFxuICAgICAgbmV3VGFnczogW10sXG4gICAgICBuZXdJdGVtVGFnczogW10sXG4gICAgICB0YWdzOiB0aGlzLm9wdGlvbnMudGFncyxcbiAgICAgIG1hZGxpYlRhZ3M6IHRoaXMub3B0aW9ucy5tYWRsaWJUYWdzLFxuICAgICAgdWk6IFVJQ29uZmlnXG4gICAgfTtcblxuICAgIHZvbHVudGVlclRlbXBsYXRlID0gXy50ZW1wbGF0ZShWb2x1bnRlZXJFZGl0Rm9ybVRlbXBsYXRlKSh0aGlzLmRhdGEpO1xuICAgIC8vJCh0aGlzLm9wdGlvbnMuZWxWb2x1bnRlZXIpLnJlbW92ZSgpO1xuICAgICQodGhpcy5vcHRpb25zLmVsVm9sdW50ZWVyKS5odG1sKHZvbHVudGVlclRlbXBsYXRlKTtcbiAgICAkKHRoaXMub3B0aW9ucy5lbFZvbHVudGVlcikuaTE4bigpO1xuXG4gICAgY29tcGlsZWRUZW1wbGF0ZSA9IF8udGVtcGxhdGUoVGFza0VkaXRGb3JtVGVtcGxhdGUpKHRoaXMuZGF0YSk7XG4gICAgdGhpcy4kZWwuaHRtbChjb21waWxlZFRlbXBsYXRlKTtcbiAgICB0aGlzLiRlbC5pMThuKCk7XG5cbiAgICAvLyBET00gbm93IGV4aXN0cywgYmVnaW4gc2VsZWN0MiBpbml0XG4gICAgdGhpcy5pbml0aWFsaXplU2VsZWN0MigpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZVRleHRBcmVhKCk7XG5cbiAgICAvLyBTZXQgdXAgdGltZSBwaWNrZXJzXG4gICAgJCgnI3B1Ymxpc2hlZEF0JykuZGF0ZXRpbWVwaWNrZXIoe1xuICAgICAgZGVmYXVsdERhdGU6IHRoaXMuZGF0YS5kYXRhLnB1Ymxpc2hlZEF0XG4gICAgfSk7XG4gICAgJCgnI2Fzc2lnbmVkQXQnKS5kYXRldGltZXBpY2tlcih7XG4gICAgICBkZWZhdWx0RGF0ZTogdGhpcy5kYXRhLmRhdGEuYXNzaWduZWRBdFxuICAgIH0pO1xuICAgICQoJyNjb21wbGV0ZWRBdCcpLmRhdGV0aW1lcGlja2VyKHtcbiAgICAgIGRlZmF1bHREYXRlOiB0aGlzLmRhdGEuZGF0YS5jb21wbGV0ZWRBdFxuICAgIH0pO1xuXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZVNlbGVjdDI6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBmb3JtYXRSZXN1bHQgPSBmdW5jdGlvbiAob2JqZWN0LCBjb250YWluZXIsIHF1ZXJ5KSB7XG4gICAgICB2YXIgZm9ybWF0dGVkID0gJzxkaXYgY2xhc3M9XCJzZWxlY3QyLXJlc3VsdC10aXRsZVwiPic7XG4gICAgICBmb3JtYXR0ZWQgKz0gb2JqZWN0Lm5hbWUgfHwgb2JqZWN0LnRpdGxlO1xuICAgICAgZm9ybWF0dGVkICs9ICc8L2Rpdj4nO1xuICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKG9iamVjdC5kZXNjcmlwdGlvbikpIHtcbiAgICAgICAgZm9ybWF0dGVkICs9ICc8ZGl2IGNsYXNzPVwic2VsZWN0Mi1yZXN1bHQtZGVzY3JpcHRpb25cIj4nICsgbWFya2VkKG9iamVjdC5kZXNjcmlwdGlvbikgKyAnPC9kaXY+JztcbiAgICAgIH1cbiAgICAgIHJldHVybiBmb3JtYXR0ZWQ7XG4gICAgfTtcblxuICAgIHRoaXMuJChcIiNwcm9qZWN0SWRcIikuc2VsZWN0Mih7XG4gICAgICBwbGFjZWhvbGRlcjogXCJTZWxlY3QgYSBwcm9qZWN0IHRvIGFzc29jaWF0ZVwiLFxuICAgICAgbXVsdGlwbGU6IGZhbHNlLFxuICAgICAgZm9ybWF0UmVzdWx0OiBmb3JtYXRSZXN1bHQsXG4gICAgICBmb3JtYXRTZWxlY3Rpb246IGZvcm1hdFJlc3VsdCxcbiAgICAgIGFsbG93Q2xlYXI6IHRydWUsXG4gICAgICBhamF4OiB7XG4gICAgICAgIHVybDogJy9hcGkvYWMvcHJvamVjdCcsXG4gICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgIGRhdGE6IGZ1bmN0aW9uICh0ZXJtKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHE6IHRlcm1cbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICByZXN1bHRzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIHJldHVybiB7IHJlc3VsdHM6IGRhdGEgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0aGlzLmRhdGEuZGF0YS5wcm9qZWN0KSB7XG4gICAgICB0aGlzLiQoXCIjcHJvamVjdElkXCIpLnNlbGVjdDIoJ2RhdGEnLCB0aGlzLmRhdGEuZGF0YS5wcm9qZWN0KTtcbiAgICB9XG5cbiAgICB0aGlzLiQoXCIjb3duZXJcIikuc2VsZWN0Mih7XG4gICAgICBwbGFjZWhvbGRlcjogXCJ0YXNrIG93bmVyXCIsXG4gICAgICBtdWx0aXBsZTogZmFsc2UsXG4gICAgICBmb3JtYXRSZXN1bHQ6IGZvcm1hdFJlc3VsdCxcbiAgICAgIGZvcm1hdFNlbGVjdGlvbjogZm9ybWF0UmVzdWx0LFxuICAgICAgYWxsb3dDbGVhcjogZmFsc2UsXG4gICAgICBhamF4OiB7XG4gICAgICAgIHVybDogJy9hcGkvYWMvdXNlcicsXG4gICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgIGRhdGE6IGZ1bmN0aW9uICh0ZXJtKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHE6IHRlcm1cbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICByZXN1bHRzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIHJldHVybiB7IHJlc3VsdHM6IGRhdGEgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0aGlzLmRhdGEuZGF0YS5vd25lcikge1xuICAgICAgdGhpcy4kKFwiI293bmVyXCIpLnNlbGVjdDIoJ2RhdGEnLCB0aGlzLmRhdGEuZGF0YS5vd25lcik7XG4gICAgfVxuXG4gICAgdGhpcy50YWdGYWN0b3J5LmNyZWF0ZVRhZ0Ryb3BEb3duKHtcbiAgICAgIHR5cGU6XCJza2lsbFwiLHNlbGVjdG9yOlwiI3Rhc2tfdGFnX3NraWxsc1wiLHdpZHRoOiBcIjEwMCVcIiwgdG9rZW5TZXBhcmF0b3JzOiBbXCIsXCJdXG4gICAgfSk7XG4gICAgaWYgKHRoaXMuZGF0YVsnbWFkbGliVGFncyddLnNraWxsKSB7XG4gICAgICB0aGlzLiQoXCIjdGFza190YWdfc2tpbGxzXCIpLnNlbGVjdDIoJ2RhdGEnLCB0aGlzLmRhdGFbJ21hZGxpYlRhZ3MnXS5za2lsbCk7XG4gICAgfVxuXG4gICAgdGhpcy50YWdGYWN0b3J5LmNyZWF0ZVRhZ0Ryb3BEb3duKHtcbiAgICAgIHR5cGU6XCJ0b3BpY1wiLCBzZWxlY3RvcjogXCIjdGFza190YWdfdG9waWNzXCIsIHdpZHRoOiBcIjEwMCVcIiwgdG9rZW5TZXBhcmF0b3JzOiBbXCIsXCJdXG4gICAgfSk7XG4gICAgaWYgKHRoaXMuZGF0YVsnbWFkbGliVGFncyddLnRvcGljKSB7XG4gICAgICB0aGlzLiQoXCIjdGFza190YWdfdG9waWNzXCIpLnNlbGVjdDIoJ2RhdGEnLCB0aGlzLmRhdGFbJ21hZGxpYlRhZ3MnXS50b3BpYyk7XG4gICAgfVxuXG4gICAgdGhpcy50YWdGYWN0b3J5LmNyZWF0ZVRhZ0Ryb3BEb3duKHt0eXBlOlwibG9jYXRpb25cIixzZWxlY3RvcjpcIiN0YXNrX3RhZ19sb2NhdGlvblwiLHdpZHRoOiBcIjEwMCVcIn0pO1xuICAgIGlmICh0aGlzLmRhdGFbJ21hZGxpYlRhZ3MnXS5sb2NhdGlvbikge1xuICAgICAgdGhpcy4kKFwiI3Rhc2tfdGFnX2xvY2F0aW9uXCIpLnNlbGVjdDIoJ2RhdGEnLCB0aGlzLmRhdGFbJ21hZGxpYlRhZ3MnXS5sb2NhdGlvbik7XG4gICAgfVxuXG4gICAgJChcIiNza2lsbHMtcmVxdWlyZWRcIikuc2VsZWN0Mih7XG4gICAgICBwbGFjZWhvbGRlcjogXCJyZXF1aXJlZC9ub3QtcmVxdWlyZWRcIixcbiAgICAgIHdpZHRoOiAnMjAwcHgnXG4gICAgfSk7XG5cbiAgICAkKFwiI3RpbWUtcmVxdWlyZWRcIikuc2VsZWN0Mih7XG4gICAgICBwbGFjZWhvbGRlcjogJ3RpbWUtcmVxdWlyZWQnLFxuICAgICAgd2lkdGg6ICcxMzBweCdcbiAgICB9KTtcblxuICAgICQoXCIjcGVvcGxlXCIpLnNlbGVjdDIoe1xuICAgICAgcGxhY2Vob2xkZXI6ICdwZW9wbGUnLFxuICAgICAgd2lkdGg6ICcxNTBweCdcbiAgICB9KTtcblxuICAgICQoXCIjbGVuZ3RoXCIpLnNlbGVjdDIoe1xuICAgICAgcGxhY2Vob2xkZXI6ICdsZW5ndGgnLFxuICAgICAgd2lkdGg6ICcxMzBweCdcbiAgICB9KTtcblxuICAgICQoXCIjdGltZS1lc3RpbWF0ZVwiKS5zZWxlY3QyKHtcbiAgICAgIHBsYWNlaG9sZGVyOiAndGltZS1lc3RpbWF0ZScsXG4gICAgICB3aWR0aDogJzIwMHB4J1xuICAgIH0pO1xuXG4gICAgJChcIiN0YXNrLWxvY2F0aW9uXCIpLnNlbGVjdDIoe1xuICAgICAgcGxhY2Vob2xkZXI6ICdsb2NhdGlvbicsXG4gICAgICB3aWR0aDogJzEzMHB4J1xuICAgIH0pO1xuXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZVRleHRBcmVhOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMubWQpIHsgdGhpcy5tZC5jbGVhbnVwKCk7IH1cbiAgICB0aGlzLm1kID0gbmV3IE1hcmtkb3duRWRpdG9yKHtcbiAgICAgIGRhdGE6IHRoaXMubW9kZWwudG9KU09OKCkuZGVzY3JpcHRpb24sXG4gICAgICBlbDogXCIubWFya2Rvd24tZWRpdFwiLFxuICAgICAgaWQ6ICd0YXNrLWRlc2NyaXB0aW9uJyxcbiAgICAgIHBsYWNlaG9sZGVyOiAnRGVzY3JpcHRpb24gb2Ygb3Bwb3J0dW5pdHkgaW5jbHVkaW5nIGdvYWxzLCBleHBlY3RlZCBvdXRjb21lcyBhbmQgZGVsaXZlcmFibGVzLicsXG4gICAgICB0aXRsZTogJ09wcG9ydHVuaXR5IERlc2NyaXB0aW9uJyxcbiAgICAgIHJvd3M6IDYsXG4gICAgICB2YWxpZGF0ZTogWydlbXB0eSddXG4gICAgfSkucmVuZGVyKCk7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZUxpc3RlbmVyczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgc2VsZi5vbihcInRhc2s6dGFnczpzYXZlOmRvbmVcIiwgZnVuY3Rpb24gKCl7XG5cbiAgICAgIHZhciBtb2RlbERhdGEgPSB7XG4gICAgICAgIHRpdGxlOiB0aGlzLiQoXCIjdGFzay10aXRsZVwiKS52YWwoKSxcbiAgICAgICAgZGVzY3JpcHRpb246IHRoaXMuJChcIiN0YXNrLWRlc2NyaXB0aW9uXCIpLnZhbCgpLFxuICAgICAgICBwdWJsaXNoZWRBdDogdGhpcy4kKFwiI3B1Ymxpc2hlZEF0XCIpLnZhbCgpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgYXNzaWduZWRBdDogdGhpcy4kKFwiI2Fzc2lnbmVkQXRcIikudmFsKCkgfHwgdW5kZWZpbmVkLFxuICAgICAgICBjb21wbGV0ZWRBdDogdGhpcy4kKFwiI2NvbXBsZXRlZEF0XCIpLnZhbCgpIHx8IHVuZGVmaW5lZFxuICAgICAgfTtcblxuICAgICAgdmFyIHByb2plY3QgPSB0aGlzLiQoXCIjcHJvamVjdElkXCIpLnNlbGVjdDIoJ2RhdGEnKTtcbiAgICAgIGlmIChwcm9qZWN0KSB7XG4gICAgICAgIG1vZGVsRGF0YS5wcm9qZWN0SWQgPSBwcm9qZWN0LmlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW9kZWxEYXRhLnByb2plY3RJZCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBvd25lciA9IHRoaXMuJChcIiNvd25lclwiKS5zZWxlY3QyKCdkYXRhJyk7XG4gICAgICBpZiAob3duZXIpIHtcbiAgICAgICAgbW9kZWxEYXRhLnVzZXJJZCA9IG93bmVyLmlkO1xuICAgICAgfVxuXG4gICAgICBvbGRUYWdzID0gdGhpcy5nZXRPbGRUYWdzKCk7XG4gICAgICB0YWdzICAgID0gdGhpcy5nZXRUYWdzRnJvbVBhZ2UoKTtcbiAgICAgIGRpZmYgICAgPSB0aGlzLnRhZ0ZhY3RvcnkuY3JlYXRlRGlmZihvbGRUYWdzLCB0YWdzKTtcblxuICAgICAgXy5lYWNoKHNlbGYuZGF0YS5uZXdJdGVtVGFncywgZnVuY3Rpb24obmV3SXRlbVRhZyl7XG4gICAgICAgIGRpZmYuYWRkLnB1c2gobmV3SXRlbVRhZy5pZCk7XG4gICAgICB9KTtcblxuICAgICAgYXN5bmMuZm9yRWFjaChcbiAgICAgICAgZGlmZi5hZGQsXG4gICAgICAgIGZ1bmN0aW9uKGRpZmZBZGQsIGNhbGxiYWNrKXtcbiAgICAgICAgICBpZiAoICFfLmlzRmluaXRlKGRpZmZBZGQpICYmIGRpZmZBZGQubmFtZSA9PSBkaWZmQWRkLmlkICkgeyByZXR1cm4gY2FsbGJhY2soKTsgfVxuICAgICAgICAgIHNlbGYudGFnRmFjdG9yeS5hZGRUYWcoZGlmZkFkZCxzZWxmLm1vZGVsLmF0dHJpYnV0ZXMuaWQsXCJ0YXNrSWRcIixjYWxsYmFjayk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uKGVycil7XG4gICAgICAgICAgc2VsZi5vcHRpb25zLm1vZGVsLnRyaWdnZXIoXCJ0YXNrOnVwZGF0ZVwiLCBtb2RlbERhdGEpO1xuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgfSk7XG4gIH0sXG5cbiAgc3VibWl0OiBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIC8vdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHRhZ3MgPSBbXTtcbiAgICB2YXIgb2xkVGFncyA9IFtdO1xuICAgIHZhciBkaWZmID0gW107XG5cbiAgICBfLmV4dGVuZCh0aGlzLCBCYWNrYm9uZS5FdmVudHMpO1xuXG4gICAgLy8gY2hlY2sgYWxsIG9mIHRoZSBmaWVsZCB2YWxpZGF0aW9uIGJlZm9yZSBzdWJtaXR0aW5nXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy4kZWwuZmluZCgnLnZhbGlkYXRlJyk7XG4gICAgdmFyIGFib3J0ID0gZmFsc2U7XG4gICAgXy5lYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHZhciBpQWJvcnQgPSB2YWxpZGF0ZSh7IGN1cnJlbnRUYXJnZXQ6IGNoaWxkIH0pO1xuICAgICAgYWJvcnQgPSBhYm9ydCB8fCBpQWJvcnQ7XG4gICAgfSk7XG4gICAgaWYgKGFib3J0ID09PSB0cnVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy92YXIgdHlwZXMgPSBbXCJ0YXNrLXNraWxscy1yZXF1aXJlZFwiLCBcInRhc2stdGltZS1yZXF1aXJlZFwiLCBcInRhc2stcGVvcGxlXCIsIFwidGFzay1sZW5ndGhcIiwgXCJ0YXNrLXRpbWUtZXN0aW1hdGVcIiwgXCJza2lsbFwiLCBcInRvcGljXCIsIFwibG9jYXRpb25cIl07XG4gICAgdGFncyA9IHRoaXMuZ2V0VGFnc0Zyb21QYWdlKCk7XG4gICAgb2xkVGFncyA9IHRoaXMuZ2V0T2xkVGFncygpO1xuXG4gICAgbmV3VGFncyA9IFtdO1xuICAgIG5ld1RhZ3MgPSBuZXdUYWdzLmNvbmNhdChzZWxmLiQoXCIjdGFza190YWdfdG9waWNzXCIpLnNlbGVjdDIoJ2RhdGEnKSxzZWxmLiQoXCIjdGFza190YWdfc2tpbGxzXCIpLnNlbGVjdDIoJ2RhdGEnKSxzZWxmLiQoXCIjdGFza190YWdfbG9jYXRpb25cIikuc2VsZWN0MignZGF0YScpKTtcblxuICAgICAgYXN5bmMuZm9yRWFjaChcbiAgICAgICAgbmV3VGFncyxcbiAgICAgICAgZnVuY3Rpb24obmV3VGFnLCBjYWxsYmFjaykge1xuICAgICAgICAgIHNlbGYudGFnRmFjdG9yeS5hZGRUYWdFbnRpdGllcyhuZXdUYWcsc2VsZixjYWxsYmFjayk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgICAgIGlmIChlcnIpIHJldHVybiBuZXh0KGVycik7XG4gICAgICAgICAgc2VsZi50cmlnZ2VyKFwidGFzazp0YWdzOnNhdmU6ZG9uZVwiKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICBkaWZmID0gdGhpcy50YWdGYWN0b3J5LmNyZWF0ZURpZmYob2xkVGFncywgdGFncyk7XG5cbiAgICBpZiAoIGRpZmYucmVtb3ZlLmxlbmd0aCA+IDAgKSB7XG4gICAgICBhc3luYy5lYWNoKGRpZmYucmVtb3ZlLCBzZWxmLnRhZ0ZhY3RvcnkucmVtb3ZlVGFnLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIC8vIGRvIG5vdGhpbmcgZm9yIG5vd1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIGdldFRhZ3NGcm9tUGFnZTogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gR2F0aGVyIHRhZ3MgZm9yIHN1Ym1pc3Npb24gYWZ0ZXIgdGhlIHRhc2sgaXMgY3JlYXRlZFxuICAgIHZhciB0YWdzID0gW107XG4gICAgdGFncy5wdXNoLmFwcGx5KHRhZ3MsdGhpcy4kKFwiI3Rhc2tfdGFnX3RvcGljc1wiKS5zZWxlY3QyKCdkYXRhJykpO1xuICAgIHRhZ3MucHVzaC5hcHBseSh0YWdzLHRoaXMuJChcIiN0YXNrX3RhZ19za2lsbHNcIikuc2VsZWN0MignZGF0YScpKTtcbiAgICB0YWdzLnB1c2guYXBwbHkodGFncyx0aGlzLiQoXCIjdGFza190YWdfbG9jYXRpb25cIikuc2VsZWN0MignZGF0YScpKTtcbiAgICB0YWdzLnB1c2guYXBwbHkodGFncyxbdGhpcy4kKFwiI3NraWxscy1yZXF1aXJlZFwiKS5zZWxlY3QyKCdkYXRhJyldKTtcbiAgICB0YWdzLnB1c2guYXBwbHkodGFncyxbdGhpcy4kKFwiI3Blb3BsZVwiKS5zZWxlY3QyKCdkYXRhJyldKTtcbiAgICB0YWdzLnB1c2guYXBwbHkodGFncyxbdGhpcy4kKFwiI3RpbWUtcmVxdWlyZWRcIikuc2VsZWN0MignZGF0YScpXSk7XG4gICAgdGFncy5wdXNoLmFwcGx5KHRhZ3MsW3RoaXMuJChcIiN0aW1lLWVzdGltYXRlXCIpLnNlbGVjdDIoJ2RhdGEnKV0pO1xuICAgIHRhZ3MucHVzaC5hcHBseSh0YWdzLFt0aGlzLiQoXCIjbGVuZ3RoXCIpLnNlbGVjdDIoJ2RhdGEnKV0pO1xuXG4gICAgcmV0dXJuIHRhZ3M7XG4gIH0sXG5cbiAgZ2V0T2xkVGFnczogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIG9sZFRhZ3MgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5vcHRpb25zLnRhZ3MpIHtcbiAgICAgICAgb2xkVGFncy5wdXNoKHtcbiAgICAgICAgICBpZDogcGFyc2VJbnQodGhpcy5vcHRpb25zLnRhZ3NbaV0uaWQpLFxuICAgICAgICAgIHRhZ0lkOiBwYXJzZUludCh0aGlzLm9wdGlvbnMudGFnc1tpXS50YWcuaWQpLFxuICAgICAgICAgIHR5cGU6IHRoaXMub3B0aW9ucy50YWdzW2ldLnRhZy50eXBlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgcmV0dXJuIG9sZFRhZ3M7XG4gIH0sXG5cbiAgY2xlYW51cDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm1kKSB7IHRoaXMubWQuY2xlYW51cCgpOyB9XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUYXNrRWRpdEZvcm1WaWV3O1xuIiwiXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgVXRpbGl0aWVzID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vbWl4aW5zL3V0aWxpdGllcycpO1xudmFyIEJvb3RzdHJhcCA9IHJlcXVpcmUoJ2Jvb3RzdHJhcCcpO1xudmFyIFRhc2tzQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2VudGl0aWVzL3Rhc2tzL3Rhc2tzX2NvbGxlY3Rpb24nKTtcbnZhciBUYXNrQ29sbGVjdGlvblZpZXcgPSByZXF1aXJlKCcuLi92aWV3cy90YXNrX2NvbGxlY3Rpb25fdmlldycpO1xudmFyIFRhc2tGb3JtVmlldyA9IHJlcXVpcmUoJy4uLy4uL25ldy92aWV3cy90YXNrX2Zvcm1fdmlldycpO1xudmFyIE1vZGFsV2l6YXJkQ29tcG9uZW50ID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29tcG9uZW50cy9tb2RhbF93aXphcmQnKTtcbnZhciBUYXNrTW9kZWwgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9lbnRpdGllcy90YXNrcy90YXNrX21vZGVsJyk7XG5cblRhc2tMaXN0ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuXG4gIGVsOiBcIiN0YXNrLWxpc3Qtd3JhcHBlclwiLFxuXG4gIGV2ZW50czoge1xuICAgICdjbGljayAuYWRkLXRhc2snIDogJ2FkZCcsXG4gICAgJ2NsaWNrIC5zaG93LXRhc2snOiAnc2hvdycsXG4gICAgJ2NsaWNrIC50YXNrJyAgICAgOiAnc2hvdycsXG4gICAgJ2NsaWNrIC53aXphcmQnICAgOiAnd2l6YXJkJ1xuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChzZXR0aW5ncykge1xuICAgIHRoaXMub3B0aW9ucyA9IF8uZXh0ZW5kKHNldHRpbmdzLCB0aGlzLmRlZmF1bHRzKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLmluaXRpYWxpemVUYXNrQ29sbGVjdGlvbkluc3RhbmNlKCk7XG4gICAgdGhpcy5pbml0aWFsaXplVGFza01vZGVsSW5zdGFuY2UoKTtcbiAgICB0aGlzLmluaXRpYWxpemVMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnJlcXVlc3RUYXNrc0NvbGxlY3Rpb25EYXRhKCk7XG5cbiAgICB0aGlzLmNvbGxlY3Rpb24ub24oXCJ0YXNrczpyZW5kZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5yZXF1ZXN0VGFza3NDb2xsZWN0aW9uRGF0YSgpXG4gICAgfSlcbiAgfSxcblxuICBpbml0aWFsaXplTGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLnRhc2tNb2RlbCwgJ3Rhc2s6dGFnczpzYXZlOnN1Y2Nlc3MnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLmluaXRpYWxpemVUYXNrTW9kZWxJbnN0YW5jZSgpO1xuICAgICAgc2VsZi5yZXF1ZXN0VGFza3NDb2xsZWN0aW9uRGF0YSgpO1xuICAgIH0pO1xuICB9LFxuXG4gIGluaXRpYWxpemVUYXNrTW9kZWxJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudGFza01vZGVsID0gbmV3IFRhc2tNb2RlbCgpO1xuICB9LFxuXG4gIGluaXRpYWxpemVUYXNrQ29sbGVjdGlvbkluc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuY29sbGVjdGlvbikge1xuICAgICAgdGhpcy5jb2xsZWN0aW9uLmluaXRpYWxpemUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb2xsZWN0aW9uID0gbmV3IFRhc2tzQ29sbGVjdGlvbigpO1xuICAgIH1cbiAgfSxcblxuICByZXF1ZXN0VGFza3NDb2xsZWN0aW9uRGF0YTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuY29sbGVjdGlvbi5mZXRjaCh7XG4gICAgICB1cmw6ICcvYXBpL3Rhc2svZmluZEFsbEJ5UHJvamVjdElkLycgKyBwYXJzZUludCh0aGlzLm9wdGlvbnMucHJvamVjdElkKSxcbiAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XG4gICAgICAgIHNlbGYudGFza3MgPSBjb2xsZWN0aW9uO1xuICAgICAgICBzZWxmLnJlbmRlclRhc2tDb2xsZWN0aW9uVmlldygpXG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgcmVuZGVyVGFza0NvbGxlY3Rpb25WaWV3OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMudGFza0NvbGxlY3Rpb25WaWV3KSB0aGlzLnRhc2tDb2xsZWN0aW9uVmlldy5jbGVhbnVwKCk7XG4gICAgdGhpcy50YXNrQ29sbGVjdGlvblZpZXcgPSBuZXcgVGFza0NvbGxlY3Rpb25WaWV3KHtcbiAgICAgIGVsOiBcIiN0YXNrLWxpc3Qtd3JhcHBlclwiLFxuICAgICAgb25SZW5kZXI6IHRydWUsXG4gICAgICBjb2xsZWN0aW9uOiBzZWxmLnRhc2tzXG4gICAgfSk7XG4gIH0sXG5cbiAgYWRkOiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMudGFza0Zvcm1WaWV3KSB0aGlzLnRhc2tGb3JtVmlldy5jbGVhbnVwKCk7XG4gICAgaWYgKHRoaXMubW9kYWxXaXphcmRDb21wb25lbnQpIHRoaXMubW9kYWxXaXphcmRDb21wb25lbnQuY2xlYW51cCgpO1xuICAgIHRoaXMubW9kYWxXaXphcmRDb21wb25lbnQgPSBuZXcgTW9kYWxXaXphcmRDb21wb25lbnQoe1xuICAgICAgZWw6IFwiLndyYXBwZXItYWRkVGFza1wiLFxuICAgICAgaWQ6IFwiYWRkVGFza1wiLFxuICAgICAgbW9kYWxUaXRsZTogJ05ldyBPcHBvcnR1bml0eScsXG4gICAgICBtb2RlbDogc2VsZi50YXNrTW9kZWwsXG4gICAgICBjb2xsZWN0aW9uOiBzZWxmLnRhc2tzLFxuICAgICAgbW9kZWxOYW1lOiAndGFzaycsXG4gICAgICBkYXRhOiBmdW5jdGlvbiAocGFyZW50KSB7IHJldHVybiB7XG4gICAgICAgIHRpdGxlOiBwYXJlbnQuJChcIiN0YXNrLXRpdGxlXCIpLnZhbCgpLFxuICAgICAgICBkZXNjcmlwdGlvbjogcGFyZW50LiQoXCIjdGFzay1kZXNjcmlwdGlvblwiKS52YWwoKSxcbiAgICAgICAgcHJvamVjdElkOiBzZWxmLm9wdGlvbnMucHJvamVjdElkXG4gICAgICB9IH1cbiAgICB9KS5yZW5kZXIoKTtcblxuICAgIHRoaXMudGFza0Zvcm1WaWV3ID0gbmV3IFRhc2tGb3JtVmlldyh7XG4gICAgICBlbDogXCIubW9kYWwtYm9keVwiLFxuICAgICAgcHJvamVjdElkOiB0aGlzLm9wdGlvbnMucHJvamVjdElkLFxuICAgICAgbW9kZWw6IHNlbGYudGFza01vZGVsLFxuICAgICAgdGFza3M6IHNlbGYudGFza3NcbiAgICB9KS5yZW5kZXIoKTtcbiAgICB0aGlzLm1vZGFsV2l6YXJkQ29tcG9uZW50LnNldENoaWxkVmlldyh0aGlzLnRhc2tGb3JtVmlldyk7XG4gICAgdGhpcy5tb2RhbFdpemFyZENvbXBvbmVudC5zZXROZXh0KHRoaXMudGFza0Zvcm1WaWV3LmNoaWxkTmV4dCk7XG4gICAgdGhpcy5tb2RhbFdpemFyZENvbXBvbmVudC5zZXRTdWJtaXQodGhpcy50YXNrRm9ybVZpZXcuY2hpbGROZXh0KTtcbiAgfSxcblxuICBzaG93OiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIHByb2plY3RJZCA9ICQoZS5jdXJyZW50VGFyZ2V0KS5kYXRhKCdwcm9qZWN0aWQnKSxcbiAgICAgICAgdGFza0lkICAgID0gJChlLmN1cnJlbnRUYXJnZXQpLmRhdGEoJ2lkJyk7XG5cbiAgICBpZiAodGFza0lkID09ICdudWxsJykgeyByZXR1cm47IH1cblxuICAgIEJhY2tib25lLmhpc3RvcnkubmF2aWdhdGUoJ3Rhc2tzLycgKyB0YXNrSWQsIHsgdHJpZ2dlcjogdHJ1ZSB9LCB0YXNrSWQpO1xuICB9LFxuXG4gIGNsZWFudXA6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy50YXNrRm9ybVZpZXcpIHRoaXMudGFza0Zvcm1WaWV3LmNsZWFudXAoKTtcbiAgICBpZiAodGhpcy5tb2RhbFdpemFyZENvbXBvbmVudCkgdGhpcy5tb2RhbFdpemFyZENvbXBvbmVudC5jbGVhbnVwKCk7XG4gICAgaWYgKHRoaXMudGFza0NvbGxlY3Rpb25WaWV3KSB0aGlzLnRhc2tDb2xsZWN0aW9uVmlldy5jbGVhbnVwKCk7XG4gICAgcmVtb3ZlVmlldyh0aGlzKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUYXNrTGlzdDtcblxuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImJveC1wYWQtbHIgYm9yZGVyLWJvdHRvbVxcXCI+XFxuICA8aDI+XFxuICAgIEF2YWlsYWJsZSBPcHBvcnR1bml0aWVzXFxuICAgIDwlIGlmICh1c2VyKSB7ICU+XFxuICAgIDxhIGhyZWY9XFxcIiNhZGRUYXNrXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1jMCBidG4tc20gZmlsZS1hZGQgYWRkLXRhc2tcXFwiIGRhdGEtdG9nZ2xlPVxcXCJtb2RhbFxcXCIgZGF0YS1iYWNrZHJvcD1cXFwic3RhdGljXFxcIj5BZGQgT3Bwb3J0dW5pdHk8L2E+XFxuICAgIDwlIH0gJT5cXG4gIDwvaDI+XFxuPC9kaXY+XFxuXFxuPGRpdiBjbGFzcz1cXFwidGFzay1zY3JvbGxcXFwiPlxcbiAgPCUgaWYgKHRhc2tzLmxlbmd0aCA9PSAwKSB7ICU+XFxuICA8ZGl2IGNsYXNzPVxcXCJ0YXNrIGJvcmRlci1sZWZ0XFxcIiBkYXRhLWlkPVxcXCJudWxsXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwidGFzay10aXRsZVxcXCI+XFxuICAgICAgTm8gY3VycmVudCBvcHBvcnR1bml0aWVzLlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbiAgPCUgfSAlPlxcbiAgPCUgXy5lYWNoKHRhc2tzLCBmdW5jdGlvbih0YXNrKSB7ICU+XFxuICA8ZGl2IGNsYXNzPVxcXCJ0YXNrIGJvcmRlci1sZWZ0XFxcIiBkYXRhLXByb2plY3RpZD1cXFwiPCU9IHRhc2sucHJvamVjdElkICU+XFxcIiBkYXRhLWlkPVxcXCI8JT0gdGFzay5pZCAlPlxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcInB1bGwtcmlnaHRcXFwiPlxcbiAgICAgIDxzdHJvbmc+PCU9IHRhc2suc3RhdGUgJT48L3N0cm9uZz5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcInRhc2stdGl0bGVcXFwiPlxcbiAgICAgIDxhIGhyZWY9XFxcIi90YXNrcy88JS0gdGFzay5pZCAlPlxcXCIgY2xhc3M9XFxcInNob3ctdGFza1xcXCIgZGF0YS1wcm9qZWN0aWQ9XFxcIjwlPSB0YXNrLnByb2plY3RJZCAlPlxcXCIgZGF0YS1pZD1cXFwiPCU9IHRhc2suaWQgJT5cXFwiPjwlLSB0YXNrLnRpdGxlICU+PC9hPlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwidGFzay1kZXNjcmlwdGlvblxcXCI+XFxuICAgICAgPCU9IHRhc2suZGVzY3JpcHRpb24gJT5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcInRhc2stdGFncy1yb3dcXFwiPlxcbiAgICAgIDx1bCBjbGFzcz1cXFwidGFncyB0YXNrLXRhZ3NcXFwiPlxcbiAgICAgICAgPCUgXy5lYWNoKHRhc2sudGFncywgZnVuY3Rpb24gKHRhZykgeyAlPlxcbiAgICAgICAgICA8bGk+PCU9IHRhZy50YWcubmFtZSAlPjwvbGk+XFxuICAgICAgICA8JSB9KTsgJT5cXG4gICAgICA8L3VsPlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbiAgPCUgfSkgJT5cXG48L2Rpdj5cXG5cIjtcbiIsIlxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vbWl4aW5zL3V0aWxpdGllcycpO1xudmFyIGFzeW5jID0gcmVxdWlyZSgnYXN5bmMnKTtcbnZhciBtYXJrZWQgPSByZXF1aXJlKCdtYXJrZWQnKTtcbnZhciBUYXNrTGlzdFRlbXBsYXRlID0gcmVxdWlyZSgnLi4vdGVtcGxhdGVzL3Rhc2tfY29sbGVjdGlvbl92aWV3X3RlbXBsYXRlLmh0bWwnKTtcblxuXG5cdHZhciBUYXNrc0NvbGxlY3Rpb25WaWV3ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuXG5cdFx0ZWw6IFwiI3Rhc2stbGlzdC13cmFwcGVyXCIsXG5cblx0XHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHRcdHRoaXMucmVxdWVzdFRhZ0RhdGEoKTtcblx0XHR9LFxuXG5cdFx0cmVxdWVzdFRhZ0RhdGE6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdFx0dGhpcy50YXNrc0pzb24gPSB7XG5cdFx0XHRcdHRhc2tzOiB0aGlzLm9wdGlvbnMuY29sbGVjdGlvbi50b0pTT04oKSxcblx0XHRcdFx0dXNlcjogd2luZG93LmNhY2hlLmN1cnJlbnRVc2VyXG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgcmVxdWVzdFRhZ0RhdGEgPSBmdW5jdGlvbiAodGFzaywgZG9uZSkge1xuXHRcdFx0XHQkLmFqYXgoe1xuXHRcdFx0XHRcdHVybDogJy9hcGkvdGFnL2ZpbmRBbGxCeVRhc2tJZC8nICsgdGFzay5pZCxcblx0XHRcdFx0XHRhc3luYzogZmFsc2UsXG5cdFx0XHRcdFx0c3VjY2VzczogZnVuY3Rpb24gKHRhZ3MpIHtcblx0XHRcdFx0XHRcdHRhc2tbJ3RhZ3MnXSA9IHRhZ3M7XG5cdFx0XHRcdFx0XHRkb25lKCk7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRlcnJvcjogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0dGFza1sndGFncyddID0gW107XG5cdFx0XHRcdFx0XHRkb25lKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0YXN5bmMuZWFjaCh0aGlzLnRhc2tzSnNvbi50YXNrcywgcmVxdWVzdFRhZ0RhdGEsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0c2VsZi5yZW5kZXIoKTtcblx0XHRcdH0pO1xuXG5cdFx0fSxcblxuXHRcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuXHRcdFx0Xy5lYWNoKHRoaXMudGFza3NKc29uLnRhc2tzLCBmdW5jdGlvbih0YXNrKSB7XG5cdFx0XHRcdHRhc2suZGVzY3JpcHRpb24gPSBtYXJrZWQodGFzay5kZXNjcmlwdGlvbik7XG5cdFx0XHR9KTtcblx0XHRcdHRoaXMuY29tcGlsZWRUZW1wbGF0ZSA9IF8udGVtcGxhdGUoVGFza0xpc3RUZW1wbGF0ZSkodGhpcy50YXNrc0pzb24pO1xuXHRcdFx0dGhpcy4kZWwuaHRtbCh0aGlzLmNvbXBpbGVkVGVtcGxhdGUpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0Y2xlYW51cDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlVmlldyh0aGlzKTtcblx0XHR9XG5cblx0fSk7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBUYXNrc0NvbGxlY3Rpb25WaWV3O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxmb3JtIGlkPVxcXCJ0YXNrLWZvcm1cXFwiIGNsYXNzPVxcXCJmb3JtLWlubGluZVxcXCIgYWN0aW9uPVxcXCIvYXBpL3Rhc2tcXFwiPlxcblxcbiAgPHNlY3Rpb24gaWQ9XFxcInNlY3Rpb24tMVxcXCIgY2xhc3M9XFxcImN1cnJlbnRcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwIGZ1bGx3aWR0aFxcXCI+XFxuICAgICAgPGxhYmVsIGZvcj1cXFwidGFzay10aXRsZVxcXCI+XFxuICAgICAgICBXaGF0IHByb2JsZW0gYXJlIHlvdSB0cnlpbmcgdG8gc29sdmU/XFxuICAgICAgPC9sYWJlbD5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTEyXFxcIj5cXG4gICAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIGlkPVxcXCJ0YXNrLXRpdGxlXFxcIiBjbGFzcz1cXFwiZnVsbHdpZHRoIGZvcm0tY29udHJvbCB2YWxpZGF0ZVxcXCIgcGxhY2Vob2xkZXI9XFxcIkEgc2hvcnQgZGVzY3JpcHRpb24gb2YgdGhlIHByb2JsZW0uXFxcIiBkYXRhLXZhbGlkYXRlPVxcXCJlbXB0eSxjb3VudDEwMFxcXCIvPlxcbiAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaGVscC1ibG9jayBlcnJvci1lbXB0eVxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPllvdSBtdXN0IGVudGVyIGEgdGl0bGUgZm9yIHRoaXMgPHNwYW4gZGF0YS1pMThuPVxcXCJ0YXNrXFxcIj5vcHBvcnR1bml0eTwvc3Bhbj48L3NwYW4+XFxuICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJoZWxwLWJsb2NrIGVycm9yLWNvdW50MTAwXFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI+VGhlIHNob3J0IGRlc2NyaXB0aW9uIG9mIHRoZSBwcm9ibGVtIG11c3QgYmUgbGVzcyB0aGFuIDEwMCBjaGFyYWN0ZXJzLjwvc3Bhbj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvc2VjdGlvbj5cXG5cXG4gIDxzZWN0aW9uIGlkPVxcXCJzZWN0aW9uLTJcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwIGZ1bGx3aWR0aFxcXCI+XFxuICAgICAgPGxhYmVsIGZvcj1cXFwicGVvcGxlXFxcIj5cXG4gICAgICAgIFdlIG5lZWRcXG4gICAgICA8L2xhYmVsPlxcbiAgICAgIDxzZWxlY3QgaWQ9XFxcInBlb3BsZVxcXCIgY2xhc3M9XFxcImRyb3Bkb3duXFxcIj5cXG4gICAgICAgIDwlIF8uZWFjaCh0YWdzWyd0YXNrLXBlb3BsZSddLCBmdW5jdGlvbiAocGVyc29uKSB7ICU+XFxuICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIjwlPSBwZXJzb24uaWQgJT5cXFwiPjwlPSBwZXJzb24ubmFtZSAlPjwvb3B0aW9uPlxcbiAgICAgICAgPCUgfSk7ICU+XFxuICAgICAgPC9zZWxlY3Q+XFxuXFxuICAgICAgPGxhYmVsIGZvcj1cXFwidG9waWNzXFxcIj5cXG4gICAgICAgIHRvIHdvcmsgb24gYW4gPHNwYW4gZGF0YS1pMThuPVxcXCJ0YXNrXFxcIj5vcHBvcnR1bml0eTwvc3Bhbj4gYWJvdXQgdGhlc2UgdG9waWNzOlxcbiAgICAgIDwvbGFiZWw+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0xMlxcXCI+XFxuICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJoaWRkZW5cXFwiIGlkPVxcXCJ0YXNrX3RhZ190b3BpY3NcXFwiIGNsYXNzPVxcXCJmdWxsd2lkdGhcXFwiIG5hbWU9XFxcInRvcGljXFxcIiAvPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8aHIvPlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwIGZ1bGx3aWR0aFxcXCI+XFxuICAgICAgPGxhYmVsIGZvcj1cXFwic2tpbGxzLXJlcXVpcmVkXFxcIj5cXG4gICAgICAgIFRoZSBmb2xsb3dpbmcgc2tpbGxzIGFyZSB1c2VmdWwgYW5kXFxuICAgICAgPC9sYWJlbD5cXG4gICAgICA8c2VsZWN0IGlkPVxcXCJza2lsbHMtcmVxdWlyZWRcXFwiIG5hbWU9XFxcInNraWxscy1yZXF1aXJlZFxcXCIgY2xhc3M9XFxcImRyb3Bkb3duXFxcIj5cXG4gICAgICAgIDwlIF8uZWFjaCh0YWdzWyd0YXNrLXNraWxscy1yZXF1aXJlZCddLCBmdW5jdGlvbihyZXF1aXJlbWVudCkgeyAlPlxcbiAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCI8JT0gcmVxdWlyZW1lbnQuaWQgJT5cXFwiPjwlPSByZXF1aXJlbWVudC5uYW1lICU+PC9vcHRpb24+XFxuICAgICAgICA8JSB9KTsgJT5cXG4gICAgICA8L3NlbGVjdD5cXG4gICAgICA8bGFiZWwgZm9yPVxcXCJza2lsbHNcXFwiPlxcbiAgICAgICAgdG8gY29tcGxldGUgdGhpcyA8c3BhbiBkYXRhLWkxOG49XFxcInRhc2tcXFwiPm9wcG9ydHVuaXR5PC9zcGFuPjpcXG4gICAgICA8L2xhYmVsPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMTJcXFwiPlxcbiAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwiaGlkZGVuXFxcIiBpZD1cXFwidGFza190YWdfc2tpbGxzXFxcIiBuYW1lPVxcXCJza2lsbHNcXFwiIGNsYXNzPVxcXCJmdWxsd2lkdGhcXFwiIC8+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICA8L3NlY3Rpb24+XFxuXFxuICA8c2VjdGlvbiBpZD1cXFwic2VjdGlvbi0zXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cCBmdWxsd2lkdGhcXFwiPlxcbiAgICAgIDxsYWJlbCBmb3I9XFxcInRpbWUtZXN0aW1hdGVcXFwiPlxcbiAgICAgICAgVGhlIDxzcGFuIGRhdGEtaTE4bj1cXFwidGFza1xcXCI+b3Bwb3J0dW5pdHk8L3NwYW4+IHdpbGwgcmVxdWlyZVxcbiAgICAgIDwvbGFiZWw+XFxuICAgICAgPHNlbGVjdCBpZD1cXFwidGltZS1lc3RpbWF0ZVxcXCIgY2xhc3M9XFxcImRyb3Bkb3duXFxcIj5cXG4gICAgICAgIDwlIF8uZWFjaCh0YWdzWyd0YXNrLXRpbWUtZXN0aW1hdGUnXSwgZnVuY3Rpb24gKHRpbWVFc3RpbWF0ZSkgeyAlPlxcbiAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCI8JT0gdGltZUVzdGltYXRlLmlkICU+XFxcIj48JT0gdGltZUVzdGltYXRlLm5hbWUgJT48L29wdGlvbj5cXG4gICAgICAgIDwlIH0pOyAlPlxcbiAgICAgIDwvc2VsZWN0PlxcblxcbiAgICAgIDxsYWJlbCBmb3I9XFxcInRpbWUtcmVxdWlyZWRcXFwiPlxcbiAgICAgICAgb2ZcXG4gICAgICA8L2xhYmVsPlxcbiAgICAgIDxzZWxlY3QgaWQ9XFxcInRpbWUtcmVxdWlyZWRcXFwiIGNsYXNzPVxcXCJkcm9wZG93blxcXCI+XFxuICAgICAgICA8JSBfLmVhY2godGFnc1sndGFzay10aW1lLXJlcXVpcmVkJ10sIGZ1bmN0aW9uICh0aW1lKSB7ICU+XFxuICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIjwlPSB0aW1lLmlkICU+XFxcIj48JT0gdGltZS5uYW1lICU+PC9vcHRpb24+XFxuICAgICAgICA8JSB9KTsgJT5cXG4gICAgICA8L3NlbGVjdD5cXG5cXG4gICAgICA8bGFiZWwgZm9yPVxcXCJsZW5ndGhcXFwiPlxcbiAgICAgICAgd29yaywgYW5kIG11c3QgYmUgY29tcGxldGVkIHdpdGhpblxcbiAgICAgIDwvbGFiZWw+XFxuICAgICAgPHNlbGVjdCBpZD1cXFwibGVuZ3RoXFxcIiBjbGFzcz1cXFwiZHJvcGRvd25cXFwiPlxcbiAgICAgICAgPCUgXy5lYWNoKHRhZ3NbJ3Rhc2stbGVuZ3RoJ10sIGZ1bmN0aW9uIChpdGVtKSB7ICU+XFxuICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIjwlPSBpdGVtLmlkICU+XFxcIj48JT0gaXRlbS5uYW1lICU+PC9vcHRpb24+XFxuICAgICAgICA8JSB9KSAlPlxcbiAgICAgIDwvc2VsZWN0PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGhyLz5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cCBmdWxsd2lkdGhcXFwiPlxcbiAgICAgIDxsYWJlbCBmb3I9XFxcInRhc2stbG9jYXRpb25cXFwiPlxcbiAgICAgICAgVGhlIHZvbHVudGVlcihzKSBtdXN0IGJlIGxvY2F0ZWRcXG4gICAgICA8L2xhYmVsPlxcbiAgICAgIDxzZWxlY3QgaWQ9XFxcInRhc2stbG9jYXRpb25cXFwiIGNsYXNzPVxcXCJkcm9wZG93blxcXCI+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJmYWxzZVxcXCI+YW55d2hlcmU8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcInRydWVcXFwiPmF0IHNwZWNpZmljIGxvY2F0aW9uKHMpPC9vcHRpb24+XFxuICAgICAgPC9zZWxlY3Q+IHRvIGNvbXBsZXRlIHRoaXMgdGFzay5cXG5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJyb3cgZWwtc3BlY2lmaWMtbG9jYXRpb25cXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTEyXFxcIj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cCB0YXNrLXNraWxscyBmdWxsd2lkdGhcXFwiPlxcbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcImxvY2F0aW9uXFxcIj5cXG4gICAgICAgICAgICAgIFRoZSBzcGVjaWZpYyBsb2NhdGlvbihzKSBhcmU6XFxuICAgICAgICAgICAgPC9sYWJlbD5cXG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwiaGlkZGVuXFxcIiBpZD1cXFwidGFza190YWdfbG9jYXRpb25cXFwiIG5hbWU9XFxcImxvY2F0aW9uXFxcIiBjbGFzcz1cXFwiZnVsbHdpZHRoXFxcIi8+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9zZWN0aW9uPlxcblxcbiAgPHNlY3Rpb24gaWQ9XFxcInNlY3Rpb24tNFxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXAgZnVsbHdpZHRoXFxcIj5cXG4gICAgICA8bGFiZWwgZm9yPVxcXCJ0YXNrLWRlc2NyaXB0aW9uXFxcIj5cXG4gICAgICAgIERlc2NyaWJlIHRoZSA8c3BhbiBkYXRhLWkxOG49XFxcInRhc2tcXFwiPm9wcG9ydHVuaXR5PC9zcGFuPiBkZXRhaWxzLCBpbmNsdWRpbmcgZ29hbHMsIGV4cGVjdGVkIG91dGNvbWVzIGFuZCBkZWxpdmVyYWJsZXMuXFxuICAgICAgPC9sYWJlbD5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTEyXFxcIj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwibWFya2Rvd24tZWRpdFxcXCI+PC9kaXY+XFxuICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJoZWxwLWJsb2NrIGVycm9yLWVtcHR5XFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI+WW91IG11c3QgZW50ZXIgYSBkZXNjcmlwdGlvbiBmb3IgdGhpcyA8c3BhbiBkYXRhLWkxOG49XFxcInRhc2tcXFwiPm9wcG9ydHVuaXR5PC9zcGFuPjwvc3Bhbj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvc2VjdGlvbj5cXG5cXG48L2Zvcm0+XFxuXCI7XG4iLCJ2YXIgQm9vdHN0cmFwID0gcmVxdWlyZSgnYm9vdHN0cmFwJyk7XG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgYXN5bmMgPSByZXF1aXJlKCdhc3luYycpO1xudmFyIHV0aWxpdGllcyA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL21peGlucy91dGlsaXRpZXMnKTtcbnZhciBNYXJrZG93bkVkaXRvciA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2NvbXBvbmVudHMvbWFya2Rvd25fZWRpdG9yJyk7XG52YXIgVGFza3NDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vZW50aXRpZXMvdGFza3MvdGFza3NfY29sbGVjdGlvbicpO1xudmFyIFRhc2tGb3JtVGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvdGFza19mb3JtX3RlbXBsYXRlLmh0bWwnKTtcbnZhciBUYWdGYWN0b3J5ID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29tcG9uZW50cy90YWdfZmFjdG9yeScpO1xuXG5cbnZhciBUYXNrRm9ybVZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG5cbiAgZWw6IFwiI3Rhc2stbGlzdC13cmFwcGVyXCIsXG5cbiAgZXZlbnRzOiB7XG4gICAgXCJjaGFuZ2UgLnZhbGlkYXRlXCIgICAgICAgIDogXCJ2XCIsXG4gICAgXCJjaGFuZ2UgI3Rhc2stbG9jYXRpb25cIiA6IFwibG9jYXRpb25DaGFuZ2VcIlxuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gXy5leHRlbmQob3B0aW9ucywgdGhpcy5kZWZhdWx0cyk7XG4gICAgdGhpcy50YXNrcyA9IHRoaXMub3B0aW9ucy50YXNrcztcbiAgICB0aGlzLnRhZ0ZhY3RvcnkgPSBuZXcgVGFnRmFjdG9yeSgpO1xuICAgIHRoaXMuZGF0YSA9IHt9O1xuICAgIHRoaXMuZGF0YS5uZXdUYWcgPSB7fTtcbiAgICB0aGlzLmRhdGEubmV3SXRlbVRhZ3MgPSBbXTtcbiAgICB0aGlzLmRhdGEuZXhpc3RpbmdUYWdzID0gW107XG4gICAgdGhpcy5pbml0aWFsaXplU2VsZWN0MkRhdGEoKTtcbiAgICB0aGlzLmluaXRpYWxpemVMaXN0ZW5lcnMoKTtcbiAgfSxcblxuICBpbml0aWFsaXplU2VsZWN0MkRhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHR5cGVzID0gW1widGFzay1za2lsbHMtcmVxdWlyZWRcIiwgXCJ0YXNrLXRpbWUtcmVxdWlyZWRcIiwgXCJ0YXNrLXBlb3BsZVwiLCBcInRhc2stbGVuZ3RoXCIsIFwidGFzay10aW1lLWVzdGltYXRlXCJdO1xuXG4gICAgdGhpcy50YWdTb3VyY2VzID0ge307XG5cbiAgICB2YXIgcmVxdWVzdEFsbFRhZ3NCeVR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgJC5hamF4KHtcbiAgICAgICAgdXJsOiAnL2FwaS9hYy90YWc/dHlwZT0nICsgdHlwZSArICcmbGlzdCcsXG4gICAgICAgIHR5cGU6ICdHRVQnLFxuICAgICAgICBhc3luYzogZmFsc2UsXG4gICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgc2VsZi50YWdTb3VyY2VzW3R5cGVdID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMuZWFjaCh0eXBlcywgcmVxdWVzdEFsbFRhZ3NCeVR5cGUsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHNlbGYucmVuZGVyKCk7XG4gICAgfSk7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZUxpc3RlbmVyczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgXy5leHRlbmQodGhpcywgQmFja2JvbmUuRXZlbnRzKTtcblxuICAgIHNlbGYub24oJ25ld1RhZ1NhdmVEb25lJyxmdW5jdGlvbiAoKXtcblxuICAgICAgdGFncyAgICAgICAgID0gW107XG4gICAgICB2YXIgdGVtcFRhZ3MgPSBbXTtcblxuICAgICAgLy9nZXQgbmV3bHkgY3JlYXRlZCB0YWdzIGZyb20gYmlnIHRocmVlIHR5cGVzXG4gICAgICBfLmVhY2goc2VsZi5kYXRhLm5ld0l0ZW1UYWdzLCBmdW5jdGlvbihuZXdJdGVtVGFnKXtcbiAgICAgICAgdGFncy5wdXNoKG5ld0l0ZW1UYWcpO1xuICAgICAgfSk7XG5cbiAgICAgIHRlbXBUYWdzLnB1c2guYXBwbHkodGVtcFRhZ3Msc2VsZi4kKFwiI3Rhc2tfdGFnX3RvcGljc1wiKS5zZWxlY3QyKCdkYXRhJykpO1xuICAgICAgdGVtcFRhZ3MucHVzaC5hcHBseSh0ZW1wVGFncyxzZWxmLiQoXCIjdGFza190YWdfc2tpbGxzXCIpLnNlbGVjdDIoJ2RhdGEnKSk7XG4gICAgICBpZiAoc2VsZi4kKFwiI3Rhc2stbG9jYXRpb25cIikuc2VsZWN0MignZGF0YScpLmlkID09ICd0cnVlJykge1xuICAgICAgICB0ZW1wVGFncy5wdXNoLmFwcGx5KHRlbXBUYWdzLHNlbGYuJChcIiN0YXNrX3RhZ19sb2NhdGlvblwiKS5zZWxlY3QyKCdkYXRhJykpO1xuICAgICAgfVxuXG4gICAgICAvL3NlZSBpZiB0aGVyZSBhcmUgYW55IHByZXZpb3VzbHkgY3JlYXRlZCBiaWcgdGhyZWUgdGFncyBhbmQgYWRkIHRoZW0gdG8gdGhlIHRhZyBhcnJheVxuICAgICAgXy5lYWNoKHRlbXBUYWdzLGZ1bmN0aW9uKHRlbXBUYWcpe1xuICAgICAgICAgIGlmICggdGVtcFRhZy5pZCAhPT0gdGVtcFRhZy5uYW1lICl7XG4gICAgICAgICAgdGFncy5wdXNoKHRlbXBUYWcpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgXy5lYWNoKHRoaXMuZGF0YS5leGlzdGluZ1RhZ3MsIGZ1bmN0aW9uKHRlbXBUYWcpIHtcbiAgICAgICAgICB0YWdzLnB1c2godGVtcFRhZyk7XG4gICAgICB9KTtcblxuICAgICAgYXN5bmMuZm9yRWFjaChcbiAgICAgICAgdGFncyxcbiAgICAgICAgZnVuY3Rpb24odGFnLCBjYWxsYmFjayl7XG4gICAgICAgICAgLy9kaWZmQWRkLHNlbGYubW9kZWwuYXR0cmlidXRlcy5pZCxcInRhc2tJZFwiLGNhbGxiYWNrXG4gICAgICAgICAgcmV0dXJuIHNlbGYudGFnRmFjdG9yeS5hZGRUYWcodGFnLHNlbGYudGVtcFRhc2tJZCxcInRhc2tJZFwiLGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24oZXJyKXtcbiAgICAgICAgICBzZWxmLm1vZGVsLnRyaWdnZXIoXCJ0YXNrOm1vZGFsOmhpZGVcIik7XG4gICAgICAgICAgc2VsZi5tb2RlbC50cmlnZ2VyKFwidGFzazp0YWdzOnNhdmU6c3VjY2Vzc1wiLCBlcnIpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLnRhc2tzLFwidGFzazpzYXZlOnN1Y2Nlc3NcIiwgZnVuY3Rpb24gKHRhc2tJZCl7XG4gICAgICAvL3RoZSBvbmx5IGNvbmNlcm4gaGVyZSBpcyB0byBhZGQgbmV3bHkgY3JlYXRlZCB0YWdzIHdoaWNoIGlzIG9ubHkgYXZhaWxhYmxlIGluIHRoZSB0aHJlZSBpdGVtcyBiZWxvd1xuICAgICAgLy9cblxuICAgICAgc2VsZi50ZW1wVGFza0lkID0gdGFza0lkO1xuXG4gICAgICAvLyBzYXZlIHRoZSB0YWdzIGZyb20gdGhlIGRyb3AgZG93bnNcbiAgICAgIHRoaXMuZGF0YS5leGlzdGluZ1RhZ3MucHVzaChzZWxmLiQoXCIjc2tpbGxzLXJlcXVpcmVkXCIpLnNlbGVjdDIoJ2RhdGEnKSk7XG4gICAgICB0aGlzLmRhdGEuZXhpc3RpbmdUYWdzLnB1c2goc2VsZi4kKFwiI3Blb3BsZVwiKS5zZWxlY3QyKCdkYXRhJykpO1xuICAgICAgdGhpcy5kYXRhLmV4aXN0aW5nVGFncy5wdXNoKHNlbGYuJChcIiN0aW1lLXJlcXVpcmVkXCIpLnNlbGVjdDIoJ2RhdGEnKSk7XG4gICAgICB0aGlzLmRhdGEuZXhpc3RpbmdUYWdzLnB1c2goc2VsZi4kKFwiI3RpbWUtZXN0aW1hdGVcIikuc2VsZWN0MignZGF0YScpKTtcbiAgICAgIHRoaXMuZGF0YS5leGlzdGluZ1RhZ3MucHVzaChzZWxmLiQoXCIjbGVuZ3RoXCIpLnNlbGVjdDIoJ2RhdGEnKSk7XG5cbiAgICAgIHZhciBuZXdUYWdzID0gW107XG5cbiAgICAgIG5ld1RhZ3MgPSBuZXdUYWdzLmNvbmNhdChzZWxmLiQoXCIjdGFza190YWdfdG9waWNzXCIpLnNlbGVjdDIoJ2RhdGEnKSxzZWxmLiQoXCIjdGFza190YWdfc2tpbGxzXCIpLnNlbGVjdDIoJ2RhdGEnKSxzZWxmLiQoXCIjdGFza190YWdfbG9jYXRpb25cIikuc2VsZWN0MignZGF0YScpKTtcblxuICAgICAgYXN5bmMuZm9yRWFjaChcbiAgICAgICAgbmV3VGFncyxcbiAgICAgICAgZnVuY3Rpb24obmV3VGFnLCBjYWxsYmFjaykge1xuICAgICAgICAgIHJldHVybiBzZWxmLnRhZ0ZhY3RvcnkuYWRkVGFnRW50aXRpZXMobmV3VGFnLHNlbGYsY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gbmV4dChlcnIpO1xuICAgICAgICAgIHNlbGYudHJpZ2dlcihcIm5ld1RhZ1NhdmVEb25lXCIpO1xuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgfSk7XG4gIH0sXG5cbiAgZ2V0VGFnc0Zyb21QYWdlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBHYXRoZXIgdGFncyBmb3Igc3VibWlzc2lvbiBhZnRlciB0aGUgdGFzayBpcyBjcmVhdGVkXG4gICAgdGFncyA9IHtcbiAgICAgIHRvcGljOiB0aGlzLiQoXCIjdGFza190YWdfdG9waWNzXCIpLnNlbGVjdDIoJ2RhdGEnKSxcbiAgICAgIHNraWxsOiB0aGlzLiQoXCIjdGFza190YWdza2lsbHNcIikuc2VsZWN0MignZGF0YScpLFxuICAgICAgbG9jYXRpb246IHRoaXMuJChcIiN0YXNrX3RhZ19sb2NhdGlvblwiKS5zZWxlY3QyKCdkYXRhJyksXG4gICAgICAndGFzay1za2lsbHMtcmVxdWlyZWQnOiBbIHRoaXMuJChcIiNza2lsbHMtcmVxdWlyZWRcIikuc2VsZWN0MignZGF0YScpIF0sXG4gICAgICAndGFzay1wZW9wbGUnOiBbIHRoaXMuJChcIiNwZW9wbGVcIikuc2VsZWN0MignZGF0YScpIF0sXG4gICAgICAndGFzay10aW1lLXJlcXVpcmVkJzogWyB0aGlzLiQoXCIjdGltZS1yZXF1aXJlZFwiKS5zZWxlY3QyKCdkYXRhJykgXSxcbiAgICAgICd0YXNrLXRpbWUtZXN0aW1hdGUnOiBbIHRoaXMuJChcIiN0aW1lLWVzdGltYXRlXCIpLnNlbGVjdDIoJ2RhdGEnKSBdLFxuICAgICAgJ3Rhc2stbGVuZ3RoJzogWyB0aGlzLiQoXCIjbGVuZ3RoXCIpLnNlbGVjdDIoJ2RhdGEnKSBdXG4gICAgfTtcblxuICAgIHJldHVybiB0YWdzO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciB0ZW1wbGF0ZSA9IF8udGVtcGxhdGUoVGFza0Zvcm1UZW1wbGF0ZSkoeyB0YWdzOiB0aGlzLnRhZ1NvdXJjZXMgfSlcbiAgICB0aGlzLiRlbC5odG1sKHRlbXBsYXRlKTtcbiAgICB0aGlzLmluaXRpYWxpemVTZWxlY3QyKCk7XG4gICAgdGhpcy5pbml0aWFsaXplVGV4dEFyZWEoKTtcblxuICAgIC8vIEltcG9ydGFudDogSGlkZSBhbGwgbm9uLWN1cnJlbnRseSBvcGVuZWQgc2VjdGlvbnMgb2Ygd2l6YXJkLlxuICAgIHRoaXMuJChcInNlY3Rpb246bm90KC5jdXJyZW50KVwiKS5oaWRlKCk7XG4gICAgdGhpcy4kZWwuaTE4bigpO1xuXG4gICAgLy8gUmV0dXJuIHRoaXMgZm9yIGNoYWluaW5nLlxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHY6IGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlKGUpO1xuICB9LFxuXG4gIGNoaWxkTmV4dDogZnVuY3Rpb24gKGUsIGN1cnJlbnQpIHtcbiAgICAvLyBmaW5kIGFsbCB0aGUgdmFsaWRhdGlvbiBlbGVtZW50c1xuICAgIHZhciBjaGlsZHJlbiA9IGN1cnJlbnQuZmluZCgnLnZhbGlkYXRlJyk7XG4gICAgdmFyIGFib3J0ID0gZmFsc2U7XG4gICAgXy5lYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHZhciBpQWJvcnQgPSB2YWxpZGF0ZSh7IGN1cnJlbnRUYXJnZXQ6IGNoaWxkIH0pO1xuICAgICAgYWJvcnQgPSBhYm9ydCB8fCBpQWJvcnQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFib3J0O1xuICB9LFxuXG4gIGluaXRpYWxpemVTZWxlY3QyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgc2VsZi50YWdGYWN0b3J5LmNyZWF0ZVRhZ0Ryb3BEb3duKHt0eXBlOlwic2tpbGxcIixzZWxlY3RvcjpcIiN0YXNrX3RhZ19za2lsbHNcIix3aWR0aDogXCIxMDAlXCIsdG9rZW5TZXBhcmF0b3JzOiBbXCIsXCJdfSk7XG4gICAgc2VsZi50YWdGYWN0b3J5LmNyZWF0ZVRhZ0Ryb3BEb3duKHt0eXBlOlwidG9waWNcIixzZWxlY3RvcjpcIiN0YXNrX3RhZ190b3BpY3NcIix3aWR0aDogXCIxMDAlXCIsdG9rZW5TZXBhcmF0b3JzOiBbXCIsXCJdfSk7XG4gICAgc2VsZi50YWdGYWN0b3J5LmNyZWF0ZVRhZ0Ryb3BEb3duKHt0eXBlOlwibG9jYXRpb25cIixzZWxlY3RvcjpcIiN0YXNrX3RhZ19sb2NhdGlvblwiLHdpZHRoOiBcIjEwMCVcIix0b2tlblNlcGFyYXRvcnM6IFtcIixcIl19KTtcblxuICAgIHNlbGYuJChcIi5lbC1zcGVjaWZpYy1sb2NhdGlvblwiKS5oaWRlKCk7XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cbiAgICAvLyBQUkUtREVGSU5FRCBTRUxFQ1QgTUVOVVMgQkVMT1cgLy9cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cbiAgICBzZWxmLiQoXCIjc2tpbGxzLXJlcXVpcmVkXCIpLnNlbGVjdDIoe1xuICAgICAgcGxhY2Vob2xkZXI6IFwiUmVxdWlyZWQvTm90IFJlcXVpcmVkXCIsXG4gICAgICB3aWR0aDogJ3Jlc29sdmUnXG4gICAgfSk7XG5cbiAgICBzZWxmLiQoXCIjdGltZS1yZXF1aXJlZFwiKS5zZWxlY3QyKHtcbiAgICAgIHBsYWNlaG9sZGVyOiAnVGltZSBDb21taXRtZW50JyxcbiAgICAgIHdpZHRoOiAncmVzb2x2ZSdcbiAgICB9KTtcblxuICAgIHNlbGYuJChcIiNwZW9wbGVcIikuc2VsZWN0Mih7XG4gICAgICBwbGFjZWhvbGRlcjogJ1BlcnNvbm5lbCBOZWVkZWQnLFxuICAgICAgd2lkdGg6ICdyZXNvbHZlJ1xuICAgIH0pO1xuXG4gICAgc2VsZi4kKFwiI2xlbmd0aFwiKS5zZWxlY3QyKHtcbiAgICAgIHBsYWNlaG9sZGVyOiAnRGVhZGxpbmUnLFxuICAgICAgd2lkdGg6ICdyZXNvbHZlJ1xuICAgIH0pO1xuXG4gICAgc2VsZi4kKFwiI3RpbWUtZXN0aW1hdGVcIikuc2VsZWN0Mih7XG4gICAgICBwbGFjZWhvbGRlcjogJ0VzdGltYXRlZCBUaW1lIFJlcXVpcmVkJyxcbiAgICAgIHdpZHRoOiAncmVzb2x2ZSdcbiAgICB9KTtcblxuICAgIHNlbGYuJChcIiN0YXNrLWxvY2F0aW9uXCIpLnNlbGVjdDIoe1xuICAgICAgcGxhY2Vob2xkZXI6ICdXb3JrIExvY2F0aW9uJyxcbiAgICAgIHdpZHRoOiAncmVzb2x2ZSdcbiAgICB9KTtcblxuICB9LFxuXG4gIGluaXRpYWxpemVUZXh0QXJlYTogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm1kKSB7IHRoaXMubWQuY2xlYW51cCgpOyB9XG4gICAgdGhpcy5tZCA9IG5ldyBNYXJrZG93bkVkaXRvcih7XG4gICAgICBkYXRhOiAnJyxcbiAgICAgIGVsOiBcIi5tYXJrZG93bi1lZGl0XCIsXG4gICAgICBpZDogJ3Rhc2stZGVzY3JpcHRpb24nLFxuICAgICAgcGxhY2Vob2xkZXI6ICdEZXNjcmlwdGlvbiBvZiAnICsgaTE4bi50KCd0YXNrJykgKyAnIGluY2x1ZGluZyBnb2FscywgZXhwZWN0ZWQgb3V0Y29tZXMgYW5kIGRlbGl2ZXJhYmxlcy4nLFxuICAgICAgdGl0bGU6IGkxOG4udCgnVGFzaycpICsgJyBEZXNjcmlwdGlvbicsXG4gICAgICByb3dzOiA2LFxuICAgICAgdmFsaWRhdGU6IFsnZW1wdHknXVxuICAgIH0pLnJlbmRlcigpO1xuICB9LFxuXG4gIGxvY2F0aW9uQ2hhbmdlOiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChfLmlzRXF1YWwoZS5jdXJyZW50VGFyZ2V0LnZhbHVlLCBcInRydWVcIikpIHtcbiAgICAgIHRoaXMuJChcIi5lbC1zcGVjaWZpYy1sb2NhdGlvblwiKS5zaG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJChcIi5lbC1zcGVjaWZpYy1sb2NhdGlvblwiKS5oaWRlKCk7XG4gICAgfVxuICB9LFxuXG4gIGNsZWFudXA6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5tZCkgeyB0aGlzLm1kLmNsZWFudXAoKTsgfVxuICAgIHJlbW92ZVZpZXcodGhpcyk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVGFza0Zvcm1WaWV3O1xuIiwidmFyIEJvb3RzdHJhcCA9IHJlcXVpcmUoJ2Jvb3RzdHJhcCcpO1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIFBvcG92ZXJzID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vbWl4aW5zL3BvcG92ZXJzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgQmFzZVZpZXcgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9iYXNlL2Jhc2VfdmlldycpO1xudmFyIENvbW1lbnRMaXN0Q29udHJvbGxlciA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbW1lbnRzL2xpc3QvY29udHJvbGxlcnMvY29tbWVudF9saXN0X2NvbnRyb2xsZXInKTtcbnZhciBBdHRhY2htZW50VmlldyA9IHJlcXVpcmUoJy4uLy4uLy4uL2F0dGFjaG1lbnQvdmlld3MvYXR0YWNobWVudF9zaG93X3ZpZXcnKTtcbnZhciBUYXNrSXRlbVZpZXcgPSByZXF1aXJlKCcuLi92aWV3cy90YXNrX2l0ZW1fdmlldycpO1xudmFyIFRhZ1Nob3dWaWV3ID0gcmVxdWlyZSgnLi4vLi4vLi4vdGFnL3Nob3cvdmlld3MvdGFnX3Nob3dfdmlldycpO1xudmFyIE1vZGFsQ29tcG9uZW50ID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29tcG9uZW50cy9tb2RhbCcpO1xudmFyIE1vZGFsQWxlcnQgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb21wb25lbnRzL21vZGFsX2FsZXJ0Jyk7XG52YXIgVGFza0VkaXRGb3JtVmlldyA9IHJlcXVpcmUoJy4uLy4uL2VkaXQvdmlld3MvdGFza19lZGl0X2Zvcm1fdmlldycpO1xudmFyIFVJQ29uZmlnID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29uZmlnL3VpLmpzb24nKTtcbnZhciBWb2x1bnRlZXJTdXBlcnZpc29yTm90aWZ5VGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvdm9sdW50ZWVyX3N1cGVydmlzb3Jfbm90aWZ5X3RlbXBsYXRlLmh0bWwnKTtcbnZhciBWb2x1bnRlZXJUZXh0VGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvdm9sdW50ZWVyX3RleHRfdGVtcGxhdGUuaHRtbCcpO1xudmFyIENoYW5nZVN0YXRlVGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvY2hhbmdlX3N0YXRlX3RlbXBsYXRlLmh0bWwnKTtcbnZhciBVcGRhdGVOYW1lVGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvdXBkYXRlX25hbWVfdGVtcGxhdGUuaHRtbCcpO1xuXG5cbnZhciBwb3BvdmVycyA9IG5ldyBQb3BvdmVycygpO1xuXG52YXIgVGFza1Nob3dDb250cm9sbGVyID0gQmFzZVZpZXcuZXh0ZW5kKHtcblxuICBlbDogXCIjY29udGFpbmVyXCIsXG5cbiAgZXZlbnRzOiB7XG4gICAgJ2NoYW5nZSAudmFsaWRhdGUnICAgICAgICAgICAgICAgIDogJ3YnLFxuICAgICdrZXl1cCAudmFsaWRhdGUnICAgICAgICAgICAgICAgICA6ICd2JyxcbiAgICAnY2xpY2sgI3Rhc2stZWRpdCcgICAgICAgICAgICAgICAgOiAnZWRpdCcsXG4gICAgJ2NsaWNrICN0YXNrLXZpZXcnICAgICAgICAgICAgICAgIDogJ3ZpZXcnLFxuICAgIFwiY2xpY2sgI2xpa2UtYnV0dG9uXCIgICAgICAgICAgICAgIDogJ2xpa2UnLFxuICAgICdjbGljayAjdm9sdW50ZWVyJyAgICAgICAgICAgICAgICA6ICd2b2x1bnRlZXInLFxuICAgICdjbGljayAjdm9sdW50ZWVyZWQnICAgICAgICAgICAgICA6ICd2b2x1bnRlZXJlZCcsXG4gICAgXCJjbGljayAjdGFzay1jbG9zZVwiICAgICAgICAgICAgICAgOiBcInN0YXRlQ2hhbmdlXCIsXG4gICAgXCJjbGljayAjdGFzay1yZW9wZW5cIiAgICAgICAgICAgICAgOiBcInN0YXRlUmVvcGVuXCIsXG4gICAgXCJjbGljayAubGluay1iYWNrYm9uZVwiICAgICAgICAgICAgOiBsaW5rQmFja2JvbmUsXG4gICAgXCJjbGljayAuZGVsZXRlLXZvbHVudGVlclwiICAgICAgICAgOiAncmVtb3ZlVm9sdW50ZWVyJyxcbiAgICBcIm1vdXNlZW50ZXIgLnByb2plY3QtcGVvcGxlLWRpdlwiICA6IHBvcG92ZXJzLnBvcG92ZXJQZW9wbGVPbixcbiAgICBcImNsaWNrIC5wcm9qZWN0LXBlb3BsZS1kaXZcIiAgICAgICA6IHBvcG92ZXJzLnBvcG92ZXJDbGlja1xuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgIHRoaXMuaW5pdGlhbGl6ZVRhc2tJdGVtVmlldygpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZUNoaWxkcmVuKCk7XG5cbiAgICAvL2xvYWQgdXNlciBzZXR0aW5ncyBzbyB0aGV5IGFyZSBhdmFpbGFibGUgYXMgbmVlZGVkXG4gICAgdGhpcy5nZXRVc2VyU2V0dGluZ3Mod2luZG93LmNhY2hlLmN1cnJlbnRVc2VyKTtcblxuICB9LFxuXG4gIGluaXRpYWxpemVFZGl0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbC50b0pTT04oKTtcbiAgICAvLyBjaGVjayBpZiB0aGUgdXNlciBvd25zIHRoZSB0YXNrXG4gICAgdmFyIG93bmVyID0gbW9kZWwuaXNPd25lcjtcbiAgICBpZiAob3duZXIgIT09IHRydWUpIHtcbiAgICAgIC8vIGlmIHRoZXkgZG9uJ3Qgb3duIHRoZSB0YXNrLCBkbyB0aGV5IG93biB0aGUgcHJvamVjdD9cbiAgICAgIGlmICghXy5pc1VuZGVmaW5lZChtb2RlbC5wcm9qZWN0KSkge1xuICAgICAgICBpZiAobW9kZWwucHJvamVjdC5pc093bmVyID09PSB0cnVlKSB7XG4gICAgICAgICAgb3duZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBpZiBub25lIG9mIHRoZXNlIGFwcGx5LCBhcmUgdGhleSBhbiBhZG1pbj9cbiAgICAgIGlmICh3aW5kb3cuY2FjaGUuY3VycmVudFVzZXIpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlci5pc0FkbWluID09PSB0cnVlKSB7XG4gICAgICAgICAgb3duZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGlmIG5vdCB0aGUgb3duZXIsIHRyaWdnZXIgdGhlIGxvZ2luIGRpYWxvZy5cbiAgICBpZiAob3duZXIgIT09IHRydWUpIHtcbiAgICAgIHdpbmRvdy5jYWNoZS51c2VyRXZlbnRzLnRyaWdnZXIoXCJ1c2VyOnJlcXVlc3Q6bG9naW5cIiwge1xuICAgICAgICBtZXNzYWdlOiBcIllvdSBhcmUgbm90IHRoZSBvd25lciBvZiB0aGlzIG9wcG9ydHVuaXR5LiA8YSBjbGFzcz0nbGluay1iYWNrYm9uZScgaHJlZj0nL3Rhc2tzL1wiICsgbW9kZWwuaWQgKyBcIic+VmlldyB0aGUgb3Bwb3J0dW5pdHkgaW5zdGVhZC48L2E+XCIsXG4gICAgICAgIGRpc2FibGVDbG9zZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGFza0VkaXRGb3JtVmlldykgdGhpcy50YXNrRWRpdEZvcm1WaWV3LmNsZWFudXAoKTtcbiAgICB0aGlzLnRhc2tFZGl0Rm9ybVZpZXcgPSBuZXcgVGFza0VkaXRGb3JtVmlldyh7XG4gICAgICBlbDogJy5lZGl0LXRhc2stc2VjdGlvbicsXG4gICAgICBlbFZvbHVudGVlcjogJyN0YXNrLXZvbHVudGVlcnMnLFxuICAgICAgZWRpdDogdHJ1ZSxcbiAgICAgIHRhc2tJZDogdGhpcy5tb2RlbC5hdHRyaWJ1dGVzLmlkLFxuICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICB0YWdzOiB0aGlzLnRhZ3MsXG4gICAgICBtYWRsaWJUYWdzOiB0aGlzLm1hZGxpYlRhZ3MsXG4gICAgICB0YWdUeXBlczogdGhpcy50YWdUeXBlc1xuICAgIH0pLnJlbmRlcigpO1xuICAgIHRoaXMuJChcIi50YXNrLXNob3ctbWFkbGliXCIpLmhpZGUoKTtcbiAgICB0aGlzLiQoXCIubGktdGFzay12aWV3XCIpLnNob3coKTtcbiAgICB0aGlzLiQoXCIubGktdGFzay1lZGl0XCIpLmhpZGUoKTtcbiAgICB0aGlzLiQoXCIudGFzay12aWV3XCIpLmhpZGUoKTtcbiAgfSxcblxuICBpbml0aWFsaXplQ2hpbGRyZW46IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICd0YXNrOnNob3c6cmVuZGVyOmRvbmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLmluaXRpYWxpemVIYW5kbGVycygpO1xuICAgICAgc2VsZi5pbml0aWFsaXplTGlrZXMoKTtcblxuICAgICAgaWYgKHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlcikge1xuICAgICAgICBzZWxmLmluaXRpYWxpemVWb2x1bnRlZXJzKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLm9wdGlvbnMuYWN0aW9uID09ICdlZGl0Jykge1xuICAgICAgICBzZWxmLmluaXRpYWxpemVFZGl0KCk7XG4gICAgICAgIHBvcG92ZXJzLnBvcG92ZXJQZW9wbGVJbml0KFwiLnByb2plY3QtcGVvcGxlLWRpdlwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvcG92ZXJzLnBvcG92ZXJQZW9wbGVJbml0KFwiLnByb2plY3QtcGVvcGxlLWRpdlwiKTtcbiAgICAgICAgaWYgKHNlbGYuY29tbWVudExpc3RDb250cm9sbGVyKSBzZWxmLmNvbW1lbnRMaXN0Q29udHJvbGxlci5jbGVhbnVwKCk7XG4gICAgICAgIHNlbGYuY29tbWVudExpc3RDb250cm9sbGVyID0gbmV3IENvbW1lbnRMaXN0Q29udHJvbGxlcih7XG4gICAgICAgICAgdGFyZ2V0OiAndGFzaycsXG4gICAgICAgICAgaWQ6IHNlbGYubW9kZWwuYXR0cmlidXRlcy5pZFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHNlbGYuYXR0YWNobWVudFZpZXcpIHNlbGYuYXR0YWNobWVudFZpZXcuY2xlYW51cCgpO1xuICAgICAgICBzZWxmLmF0dGFjaG1lbnRWaWV3ID0gbmV3IEF0dGFjaG1lbnRWaWV3KHtcbiAgICAgICAgICB0YXJnZXQ6ICd0YXNrJyxcbiAgICAgICAgICBpZDogdGhpcy5tb2RlbC5hdHRyaWJ1dGVzLmlkLFxuICAgICAgICAgIG93bmVyOiB0aGlzLm1vZGVsLmF0dHJpYnV0ZXMuaXNPd25lcixcbiAgICAgICAgICBlbDogJy5hdHRhY2htZW50LXdyYXBwZXInXG4gICAgICAgIH0pLnJlbmRlcigpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi50YWdWaWV3KSBzZWxmLnRhZ1ZpZXcuY2xlYW51cCgpO1xuICAgICAgc2VsZi50YWdWaWV3ID0gbmV3IFRhZ1Nob3dWaWV3KHtcbiAgICAgICAgbW9kZWw6IHNlbGYubW9kZWwsXG4gICAgICAgIGVsOiAnLnRhZy13cmFwcGVyJyxcbiAgICAgICAgdGFyZ2V0OiAndGFzaycsXG4gICAgICAgIHRhcmdldElkOiAndGFza0lkJyxcbiAgICAgICAgZWRpdDogZmFsc2UsXG4gICAgICAgIHVybDogJy9hcGkvdGFnL2ZpbmRBbGxCeVRhc2tJZC8nXG4gICAgICB9KS5yZW5kZXIoKTtcblxuICAgIH0pO1xuICB9LFxuXG4gIGluaXRpYWxpemVMaWtlczogZnVuY3Rpb24gKCkge1xuICAgICQoXCIjbGlrZS1udW1iZXJcIikudGV4dCh0aGlzLm1vZGVsLmF0dHJpYnV0ZXMubGlrZUNvdW50KTtcbiAgICBpZiAocGFyc2VJbnQodGhpcy5tb2RlbC5hdHRyaWJ1dGVzLmxpa2VDb3VudCkgPT09IDEpIHtcbiAgICAgICQoXCIjbGlrZS10ZXh0XCIpLnRleHQoJChcIiNsaWtlLXRleHRcIikuZGF0YSgnc2luZ3VsYXInKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICQoXCIjbGlrZS10ZXh0XCIpLnRleHQoJChcIiNsaWtlLXRleHRcIikuZGF0YSgncGx1cmFsJykpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tb2RlbC5hdHRyaWJ1dGVzLmxpa2UpIHtcbiAgICAgICQoXCIjbGlrZS1idXR0b24taWNvblwiKS5yZW1vdmVDbGFzcygnZmEgZmEtc3Rhci1vJyk7XG4gICAgICAkKFwiI2xpa2UtYnV0dG9uLWljb25cIikuYWRkQ2xhc3MoJ2ZhIGZhLXN0YXInKTtcbiAgICB9XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZVZvbHVudGVlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5tb2RlbC5hdHRyaWJ1dGVzLnZvbHVudGVlcikge1xuICAgICAgJCgnLnZvbHVudGVlci10cnVlJykuc2hvdygpO1xuICAgICAgJCgnLnZvbHVudGVlci1mYWxzZScpLmhpZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJCgnLnZvbHVudGVlci10cnVlJykuaGlkZSgpO1xuICAgICAgJCgnLnZvbHVudGVlci1mYWxzZScpLnNob3coKTtcbiAgICB9XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZUhhbmRsZXJzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsIFwidGFzazp1cGRhdGU6c3RhdGU6c3VjY2Vzc1wiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgaWYgKGRhdGEuYXR0cmlidXRlcy5zdGF0ZSA9PSAnY2xvc2VkJykge1xuICAgICAgICAkKFwiI2xpLXRhc2stY2xvc2VcIikuaGlkZSgpO1xuICAgICAgICAkKFwiI2xpLXRhc2stcmVvcGVuXCIpLnNob3coKTtcbiAgICAgICAgJChcIiNhbGVydC1jbG9zZWRcIikuc2hvdygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJChcIiNsaS10YXNrLWNsb3NlXCIpLnNob3coKTtcbiAgICAgICAgJChcIiNsaS10YXNrLXJlb3BlblwiKS5oaWRlKCk7XG4gICAgICAgICQoXCIjYWxlcnQtY2xvc2VkXCIpLmhpZGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgaW5pdGlhbGl6ZVRhc2tJdGVtVmlldzogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAvLyBHZXQgdGhlIHRhZyB0eXBlIGluZm8gZnJvbSB0aGUgdmlldyBzbyB3ZSBkb24ndCBoYXZlIHRvIHJlZmV0Y2hcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICd0YXNrOnRhZzp0eXBlcycsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBzZWxmLnRhZ1R5cGVzID0gZGF0YTtcbiAgICB9KTtcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICd0YXNrOnRhZzpkYXRhJywgZnVuY3Rpb24gKHRhZ3MsIG1hZGxpYlRhZ3MpIHtcbiAgICAgIHNlbGYudGFncyA9IHRhZ3M7XG4gICAgICBzZWxmLm1hZGxpYlRhZ3MgPSBtYWRsaWJUYWdzO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLnRhc2tJdGVtVmlldykgdGhpcy50YXNrSXRlbVZpZXcuY2xlYW51cCgpO1xuICAgIHRoaXMudGFza0l0ZW1WaWV3ID0gbmV3IFRhc2tJdGVtVmlldyh7XG4gICAgICBtb2RlbDogdGhpcy5vcHRpb25zLm1vZGVsLFxuICAgICAgcm91dGVyOiB0aGlzLm9wdGlvbnMucm91dGVyLFxuICAgICAgaWQ6IHRoaXMub3B0aW9ucy5pZCxcbiAgICAgIGVsOiB0aGlzLmVsXG4gICAgfSk7XG4gIH0sXG5cbiAgdjogZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gdmFsaWRhdGUoZSk7XG4gIH0sXG5cbiAgZWRpdDogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZUVkaXQoKTtcbiAgICBwb3BvdmVycy5wb3BvdmVyUGVvcGxlSW5pdChcIi5wcm9qZWN0LXBlb3BsZS1kaXZcIik7XG4gICAgQmFja2JvbmUuaGlzdG9yeS5uYXZpZ2F0ZSgndGFza3MvJyArIHRoaXMubW9kZWwuaWQgKyAnL2VkaXQnKTtcbiAgfSxcblxuICB2aWV3OiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgQmFja2JvbmUuaGlzdG9yeS5uYXZpZ2F0ZSgndGFza3MvJyArIHRoaXMubW9kZWwuaWQsIHsgdHJpZ2dlcjogdHJ1ZSB9KTtcbiAgfSxcblxuICBsaWtlOiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjaGlsZCA9ICQoZS5jdXJyZW50VGFyZ2V0KS5jaGlsZHJlbihcIiNsaWtlLWJ1dHRvbi1pY29uXCIpO1xuICAgIHZhciBsaWtlbnVtYmVyID0gJChcIiNsaWtlLW51bWJlclwiKTtcbiAgICAvLyBOb3QgeWV0IGxpa2VkLCBpbml0aWF0ZSBsaWtlXG4gICAgaWYgKGNoaWxkLmhhc0NsYXNzKCdmYS1zdGFyLW8nKSkge1xuICAgICAgY2hpbGQucmVtb3ZlQ2xhc3MoJ2ZhLXN0YXItbycpO1xuICAgICAgY2hpbGQuYWRkQ2xhc3MoJ2ZhLXN0YXInKTtcbiAgICAgIGxpa2VudW1iZXIudGV4dChwYXJzZUludChsaWtlbnVtYmVyLnRleHQoKSkgKyAxKTtcbiAgICAgIGlmIChwYXJzZUludChsaWtlbnVtYmVyLnRleHQoKSkgPT09IDEpIHtcbiAgICAgICAgJChcIiNsaWtlLXRleHRcIikudGV4dCgkKFwiI2xpa2UtdGV4dFwiKS5kYXRhKCdzaW5ndWxhcicpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICQoXCIjbGlrZS10ZXh0XCIpLnRleHQoJChcIiNsaWtlLXRleHRcIikuZGF0YSgncGx1cmFsJykpO1xuICAgICAgfVxuICAgICAgJC5hamF4KHtcbiAgICAgICAgdXJsOiAnL2FwaS9saWtlL2xpa2V0LycgKyB0aGlzLm1vZGVsLmF0dHJpYnV0ZXMuaWRcbiAgICAgIH0pLmRvbmUoIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIC8vIGxpa2VkIVxuICAgICAgICAvLyByZXNwb25zZSBzaG91bGQgYmUgdGhlIGxpa2Ugb2JqZWN0XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGRhdGEuaWQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIExpa2VkLCBpbml0aWF0ZSB1bmxpa2VcbiAgICBlbHNlIHtcbiAgICAgIGNoaWxkLnJlbW92ZUNsYXNzKCdmYS1zdGFyJyk7XG4gICAgICBjaGlsZC5hZGRDbGFzcygnZmEtc3Rhci1lbXB0eScpO1xuICAgICAgbGlrZW51bWJlci50ZXh0KHBhcnNlSW50KGxpa2VudW1iZXIudGV4dCgpKSAtIDEpO1xuICAgICAgaWYgKHBhcnNlSW50KGxpa2VudW1iZXIudGV4dCgpKSA9PT0gMSkge1xuICAgICAgICAkKFwiI2xpa2UtdGV4dFwiKS50ZXh0KCQoXCIjbGlrZS10ZXh0XCIpLmRhdGEoJ3Npbmd1bGFyJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJChcIiNsaWtlLXRleHRcIikudGV4dCgkKFwiI2xpa2UtdGV4dFwiKS5kYXRhKCdwbHVyYWwnKSk7XG4gICAgICB9XG4gICAgICAkLmFqYXgoe1xuICAgICAgICB1cmw6ICcvYXBpL2xpa2UvdW5saWtldC8nICsgdGhpcy5tb2RlbC5hdHRyaWJ1dGVzLmlkXG4gICAgICB9KS5kb25lKCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAvLyB1bi1saWtlZCFcbiAgICAgICAgLy8gcmVzcG9uc2Ugc2hvdWxkIGJlIG51bGwgKGVtcHR5KVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBnZXRVc2VyU2V0dGluZ3M6IGZ1bmN0aW9uICh1c2VySWQpIHtcbiAgICAvL2RvZXMgdGhpcyBiZWxvbmcgc29tZXdoZXJlIGVsc2U/XG4gICAgaWYgKCBfLmlzTnVsbCh1c2VySWQpICl7IHJldHVybiBudWxsOyB9XG4gICAgJC5hamF4KHtcbiAgICAgIHVybDogJy9hcGkvdXNlcnNldHRpbmcvJyt1c2VySWQuaWQsXG4gICAgICB0eXBlOiAnR0VUJyxcbiAgICAgIGRhdGFUeXBlOiAnanNvbidcbiAgICB9KVxuICAgIC5zdWNjZXNzKGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgXy5lYWNoKGRhdGEsZnVuY3Rpb24oc2V0dGluZyl7XG4gICAgICAgIC8vc2F2ZSBhY3RpdmUgc2V0dGluZ3MgdG8gdGhlIGN1cnJlbnQgdXNlciBvYmplY3RcbiAgICAgICAgaWYgKCBzZXR0aW5nLmlzQWN0aXZlICl7XG4gICAgICAgICAgd2luZG93LmNhY2hlLmN1cnJlbnRVc2VyW3NldHRpbmcua2V5XT1zZXR0aW5nO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSxcblxuICBkZWxldGVVc2VyU2V0dGluZ0J5S2V5OiBmdW5jdGlvbihzZXR0aW5nS2V5KSB7XG4gICAgLy90aGlzIGZ1bmN0aW9uIGV4cGVjdHMgdGhlIGVudGlyZSByb3cgZnJvbSB1c2Vyc2V0dGluZyBpbiB0aGUgZm9ybVxuICAgIC8vICAgICB3aW5kb3cuY2FjaGUuY3VycmVudFVzZXJbc2V0dGluZ0tleV0gPSB7fVxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vaWYgbm90IHNldCBza2lwXG4gICAgdmFyIHRhcmdldElkID0gICggd2luZG93LmNhY2hlLmN1cnJlbnRVc2VyW3NldHRpbmdLZXldICkgPyB3aW5kb3cuY2FjaGUuY3VycmVudFVzZXJbc2V0dGluZ0tleV0uaWQgOiBudWxsIDtcblxuICAgIGlmICggdGFyZ2V0SWQgKXtcbiAgICAgICQuYWpheCh7XG4gICAgICAgIHVybDogJy9hcGkvdXNlcnNldHRpbmcvJyt0YXJnZXRJZCxcbiAgICAgICAgdHlwZTogJ0RFTEVURScsXG4gICAgICAgIGRhdGFUeXBlOiAnanNvbidcbiAgICAgIH0pXG4gICAgfVxuXG4gIH0sXG5cbiAgc2F2ZVVzZXJTZXR0aW5nQnlLZXk6IGZ1bmN0aW9uKHVzZXJJZCwgb3B0aW9ucykge1xuICAgIC8vdGhpcyBmdW5jdGlvbiBleHBlY3RzIHRoZSBlbnRpcmUgcm93IGZyb20gdXNlcnNldHRpbmcgaW4gdGhlIGZvcm1cbiAgICAvLyAgICAgd2luZG93LmNhY2hlLmN1cnJlbnRVc2VyW3NldHRpbmdLZXldID0ge31cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvL2FyZSB2YWx1ZXMgdGhlIHNhbWUsIHN0b3BcbiAgICBpZiAoIG9wdGlvbnMubmV3VmFsdWUgPT0gb3B0aW9ucy5vbGRWYWx1ZSApIHsgcmV0dXJuIHRydWU7IH1cblxuICAgIC8vaWYgZGVsZXRlIG9sZCBpcyBzZXQsIGRlbGV0ZSBleGlzaXRuZyB2YWx1ZVxuICAgIC8vICAgZGVmYXVsdCBpcyBkZWxldGVcbiAgICBpZiAoICFvcHRpb25zLmRlbGV0ZU9sZCApe1xuICAgICAgc2VsZi5kZWxldGVVc2VyU2V0dGluZ0J5S2V5KG9wdGlvbnMuc2V0dGluZ0tleSk7XG4gICAgfVxuXG4gICAgJC5hamF4KHtcbiAgICAgICAgdXJsOiAnL2FwaS91c2Vyc2V0dGluZy8nLFxuICAgICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICB1c2VySWQ6IHVzZXJJZCxcbiAgICAgICAgICBrZXk6IG9wdGlvbnMuc2V0dGluZ0tleSxcbiAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5uZXdWYWx1ZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgfSxcblxuICB2b2x1bnRlZXI6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoIXdpbmRvdy5jYWNoZS5jdXJyZW50VXNlcikge1xuICAgICAgd2luZG93LmNhY2hlLnVzZXJFdmVudHMudHJpZ2dlcihcInVzZXI6cmVxdWVzdDpsb2dpblwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGNoaWxkID0gJChlLmN1cnJlbnRUYXJnZXQpLmNoaWxkcmVuKFwiI2xpa2UtYnV0dG9uLWljb25cIik7XG4gICAgICB2YXIgb3JpZ2luYWxFdmVudCA9IGU7XG5cbiAgICAgIGlmICh0aGlzLm1vZGFsQWxlcnQpIHsgdGhpcy5tb2RhbEFsZXJ0LmNsZWFudXAoKTsgfVxuICAgICAgaWYgKHRoaXMubW9kYWxDb21wb25lbnQpIHsgdGhpcy5tb2RhbENvbXBvbmVudC5jbGVhbnVwKCk7IH1cblxuICAgICAgLy8gSWYgdXNlcidzIHByb2ZpbGUgaGFzIG5vIG5hbWUsIGFzayB0aGVtIHRvIGVudGVyIG9uZVxuICAgICAgaWYgKCF3aW5kb3cuY2FjaGUuY3VycmVudFVzZXIubmFtZSkge1xuICAgICAgICB2YXIgbW9kYWxDb250ZW50ID0gXy50ZW1wbGF0ZShVcGRhdGVOYW1lVGVtcGxhdGUpKHt9KTtcbiAgICAgICAgdGhpcy5tb2RhbENvbXBvbmVudCA9IG5ldyBNb2RhbENvbXBvbmVudCh7XG4gICAgICAgICAgZWw6IFwiI21vZGFsLXZvbHVudGVlclwiLFxuICAgICAgICAgIGlkOiBcInVwZGF0ZS1uYW1lXCIsXG4gICAgICAgICAgbW9kYWxUaXRsZTogXCJXaGF0J3MgeW91ciBuYW1lP1wiXG4gICAgICAgIH0pLnJlbmRlcigpO1xuICAgICAgICB0aGlzLm1vZGFsQWxlcnQgPSBuZXcgTW9kYWxBbGVydCh7XG4gICAgICAgICAgZWw6IFwiI3VwZGF0ZS1uYW1lIC5tb2RhbC10ZW1wbGF0ZVwiLFxuICAgICAgICAgIG1vZGFsRGl2OiAnI3VwZGF0ZS1uYW1lJyxcbiAgICAgICAgICBjb250ZW50OiBtb2RhbENvbnRlbnQsXG4gICAgICAgICAgdmFsaWRhdGVCZWZvcmVTdWJtaXQ6IHRydWUsXG4gICAgICAgICAgY2FuY2VsOiBpMThuLnQoJ3ZvbHVudGVlck1vZGFsLmNhbmNlbCcpLFxuICAgICAgICAgIHN1Ym1pdDogaTE4bi50KCd2b2x1bnRlZXJNb2RhbC5vaycpLFxuICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9ICQoJyN1cGRhdGUtbmFtZS1maWVsZCcpLnZhbCgpO1xuICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgdXJsOiAnL2FwaS91c2VyLycgKyB3aW5kb3cuY2FjaGUuY3VycmVudFVzZXIuaWQsXG4gICAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgICAgIGRhdGE6IHsgbmFtZTogbmFtZSB9XG4gICAgICAgICAgICB9KS5kb25lKGZ1bmN0aW9uKHVzZXIpIHtcbiAgICAgICAgICAgICAgd2luZG93LmNhY2hlLmN1cnJlbnRVc2VyLm5hbWUgPSB1c2VyLm5hbWU7XG4gICAgICAgICAgICAgIHNlbGYudm9sdW50ZWVyKG9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KS5yZW5kZXIoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1vZGFsQ29tcG9uZW50ID0gbmV3IE1vZGFsQ29tcG9uZW50KHtcbiAgICAgICAgZWw6IFwiI21vZGFsLXZvbHVudGVlclwiLFxuICAgICAgICBpZDogXCJjaGVjay12b2x1bnRlZXJcIixcbiAgICAgICAgbW9kYWxUaXRsZTogaTE4bi50KFwidm9sdW50ZWVyTW9kYWwudGl0bGVcIilcbiAgICAgIH0pLnJlbmRlcigpO1xuXG4gICAgICBpZiAoIFVJQ29uZmlnLnN1cGVydmlzb3JFbWFpbC51c2VTdXBlcnZpc29yRW1haWwgKSB7XG4gICAgICAgIC8vbm90IGFzc2lnbmluZyBhcyBudWxsIGJlY2F1c2UgbnVsbCBpbmplY3RlZCBpbnRvIHRoZSBtb2RhbENvbnRlbnQgdmFyIHNob3dzIGFzIGEgbGl0ZXJhbCB2YWx1ZVxuICAgICAgICAvLyAgICB3aGVuIHdoYXQgd2Ugd2FudCBpcyBub3RoaW5nIGlmIHZhbHVlIGlzIG51bGxcbiAgICAgICAgdmFyIHN1cGVydmlzb3JFbWFpbCA9ICggd2luZG93LmNhY2hlLmN1cnJlbnRVc2VyLnN1cGVydmlzb3JFbWFpbCApID8gd2luZG93LmNhY2hlLmN1cnJlbnRVc2VyLnN1cGVydmlzb3JFbWFpbC52YWx1ZSAgOiBcIlwiO1xuICAgICAgICB2YXIgc3VwZXJ2aXNvck5hbWUgPSAoIHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlci5zdXBlcnZpc29yTmFtZSApID8gd2luZG93LmNhY2hlLmN1cnJlbnRVc2VyLnN1cGVydmlzb3JOYW1lLnZhbHVlIDogXCJcIjtcbiAgICAgICAgdmFyIHZhbGlkYXRlQmVmb3JlU3VibWl0ID0gdHJ1ZTtcbiAgICAgICAgdmFyIG1vZGFsQ29udGVudCA9IF8udGVtcGxhdGUoVm9sdW50ZWVyU3VwZXJ2aXNvck5vdGlmeVRlbXBsYXRlKSh7c3VwZXJ2aXNvckVtYWlsOiBzdXBlcnZpc29yRW1haWwsc3VwZXJ2aXNvck5hbWU6IHN1cGVydmlzb3JOYW1lfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWxpZGF0ZUJlZm9yZVN1Ym1pdCA9IGZhbHNlO1xuICAgICAgICB2YXIgbW9kYWxDb250ZW50ID0gXy50ZW1wbGF0ZShWb2x1bnRlZXJUZXh0VGVtcGxhdGUpKHt9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5tb2RhbEFsZXJ0ID0gbmV3IE1vZGFsQWxlcnQoe1xuICAgICAgICBlbDogXCIjY2hlY2stdm9sdW50ZWVyIC5tb2RhbC10ZW1wbGF0ZVwiLFxuICAgICAgICBtb2RhbERpdjogJyNjaGVjay12b2x1bnRlZXInLFxuICAgICAgICBjb250ZW50OiBtb2RhbENvbnRlbnQsXG4gICAgICAgIGNhbmNlbDogaTE4bi50KCd2b2x1bnRlZXJNb2RhbC5jYW5jZWwnKSxcbiAgICAgICAgc3VibWl0OiBpMThuLnQoJ3ZvbHVudGVlck1vZGFsLm9rJyksXG4gICAgICAgIHZhbGlkYXRlQmVmb3JlU3VibWl0OiB2YWxpZGF0ZUJlZm9yZVN1Ym1pdCxcbiAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgaWYgKCBVSUNvbmZpZy5zdXBlcnZpc29yRW1haWwudXNlU3VwZXJ2aXNvckVtYWlsICkge1xuICAgICAgICAgICAgc2VsZi5zYXZlVXNlclNldHRpbmdCeUtleSh3aW5kb3cuY2FjaGUuY3VycmVudFVzZXIuaWQse3NldHRpbmdLZXk6XCJzdXBlcnZpc29yRW1haWxcIixuZXdWYWx1ZTogJCgnI3VzZXJTdXBlclZpc29yRW1haWwnKS52YWwoKSxvbGRWYWx1ZTogc3VwZXJ2aXNvckVtYWlsfSk7XG4gICAgICAgICAgICBzZWxmLnNhdmVVc2VyU2V0dGluZ0J5S2V5KHdpbmRvdy5jYWNoZS5jdXJyZW50VXNlci5pZCx7c2V0dGluZ0tleTpcInN1cGVydmlzb3JOYW1lXCIsbmV3VmFsdWU6ICQoJyN1c2VyU3VwZXJWaXNvck5hbWUnKS52YWwoKSxvbGRWYWx1ZTogc3VwZXJ2aXNvck5hbWV9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gdXNlciBjbGlja2VkIHRoZSBzdWJtaXQgYnV0dG9uXG4gICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgIHVybDogJy9hcGkvdm9sdW50ZWVyLycsXG4gICAgICAgICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHRhc2tJZDogc2VsZi5tb2RlbC5hdHRyaWJ1dGVzLmlkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkuZG9uZSggZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICQoJy52b2x1bnRlZXItdHJ1ZScpLnNob3coKTtcbiAgICAgICAgICAgICQoJy52b2x1bnRlZXItZmFsc2UnKS5oaWRlKCk7XG4gICAgICAgICAgICB2YXIgaHRtbCA9ICc8ZGl2IGNsYXNzPVwicHJvamVjdC1wZW9wbGUtZGl2XCIgZGF0YS11c2VyaWQ9XCInICsgZGF0YS51c2VySWQgKyAnXCIgZGF0YS12b2x1c2VyaWQ9XCInICsgZGF0YS51c2VySWQgKyAnXCI+PGltZyBzcmM9XCIvYXBpL3VzZXIvcGhvdG8vJyArIGRhdGEudXNlcklkICsgJ1wiIGNsYXNzPVwicHJvamVjdC1wZW9wbGVcIi8+JztcbiAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMuYWN0aW9uID09PSBcImVkaXRcIikge1xuICAgICAgICAgICAgICBodG1sICs9ICc8YSBocmVmPVwiI1wiIGNsYXNzPVwiZGVsZXRlLXZvbHVudGVlciB2b2x1bnRlZXItZGVsZXRlIGZhIGZhLXRpbWVzXCIgIGlkPVwiZGVsZXRlLXZvbHVudGVlci0nICsgZGF0YS5pZCArICdcIiBkYXRhLXVpZD1cIicgKyBkYXRhLnVzZXJJZCArICdcIiBkYXRhLXZpZD1cIicgKyAgZGF0YS5pZCArICdcIj48L2E+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGh0bWwgKz0gJzwvZGl2Pic7XG4gICAgICAgICAgICAkKCcjdGFzay12b2x1bnRlZXJzJykuYXBwZW5kKGh0bWwpO1xuICAgICAgICAgICAgcG9wb3ZlcnMucG9wb3ZlclBlb3BsZUluaXQoXCIucHJvamVjdC1wZW9wbGUtZGl2XCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KS5yZW5kZXIoKTtcbiAgICB9XG4gIH0sXG5cbiAgdm9sdW50ZWVyZWQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAvLyBOb3QgYWJsZSB0byB1bi12b2x1bnRlZXIsIHNvIGRvIG5vdGhpbmdcbiAgfSxcblxuICByZW1vdmVWb2x1bnRlZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoZS5zdG9wUHJvcGFnYXRpb24oKSkgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICQoZS5jdXJyZW50VGFyZ2V0KS5vZmYoXCJtb3VzZWVudGVyXCIpO1xuICAgICQoJy5wb3BvdmVyJykucmVtb3ZlKCk7XG5cbiAgICB2YXIgdklkID0gJChlLmN1cnJlbnRUYXJnZXQpLmRhdGEoJ3ZpZCcpO1xuICAgIHZhciB1SWQgPSAkKGUuY3VycmVudFRhcmdldCkuZGF0YSgndWlkJyk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKHR5cGVvZiBjYWNoZSAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICB7XG4gICAgICAkLmFqYXgoe1xuICAgICAgICB1cmw6ICcvYXBpL3ZvbHVudGVlci8nICsgdklkLFxuICAgICAgICB0eXBlOiAnREVMRVRFJyxcbiAgICAgIH0pLmRvbmUoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAvLyBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgb2xkVm9scyA9IHRoaXMubW9kZWwuYXR0cmlidXRlcy52b2x1bnRlZXJzIHx8IFtdO1xuICAgIHZhciB1bmNoYW5nZWRWb2xzID0gXy5maWx0ZXIob2xkVm9scywgZnVuY3Rpb24odm9sKXsgcmV0dXJuICggdm9sLmlkICE9PSB2SWQgKTsgfSAsIHRoaXMpICB8fCBbXTtcbiAgICB0aGlzLm1vZGVsLmF0dHJpYnV0ZXMudm9sdW50ZWVycyA9IHVuY2hhbmdlZFZvbHM7XG4gICAgJCgnW2RhdGEtdm9sdXNlcmlkPVwiJyArIHVJZCArICdcIl0nKS5yZW1vdmUoKTtcbiAgICBpZiAod2luZG93LmNhY2hlLmN1cnJlbnRVc2VyLmlkID09PSB1SWQpIHtcbiAgICAgICQoJy52b2x1bnRlZXItZmFsc2UnKS5zaG93KCk7XG4gICAgICAkKCcudm9sdW50ZWVyLXRydWUnKS5oaWRlKCk7XG4gICAgfVxuICB9LFxuXG4gIHN0YXRlQ2hhbmdlOiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMubW9kYWxBbGVydCkgeyB0aGlzLm1vZGFsQWxlcnQuY2xlYW51cCgpOyB9XG4gICAgaWYgKHRoaXMubW9kYWxDb21wb25lbnQpIHsgdGhpcy5tb2RhbENvbXBvbmVudC5jbGVhbnVwKCk7IH1cbiAgICB2YXIgc3RhdGVzID0gVUlDb25maWcuc3RhdGVzO1xuICAgIGlmIChkcmFmdEFkbWluT25seSAmJiAhd2luZG93LmNhY2hlLmN1cnJlbnRVc2VyLmlzQWRtaW4pIHtcbiAgICAgIHN0YXRlcyA9IF8oc3RhdGVzKS5yZWplY3QoZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLnZhbHVlID09PSAnZHJhZnQnO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIG1vZGFsQ29udGVudCA9IF8udGVtcGxhdGUoQ2hhbmdlU3RhdGVUZW1wbGF0ZSkoe21vZGVsOnNlbGYubW9kZWwsc3RhdGVzOiBzdGF0ZXN9KTtcbiAgICB0aGlzLm1vZGFsQ29tcG9uZW50ID0gbmV3IE1vZGFsQ29tcG9uZW50KHtcbiAgICAgIGVsOiBcIiNtb2RhbC1jbG9zZVwiLFxuICAgICAgaWQ6IFwiY2hlY2stY2xvc2VcIixcbiAgICAgIG1vZGFsVGl0bGU6IFwiQ2hhbmdlIFwiK2kxOG4udChcIlRhc2tcIikrXCIgU3RhdGVcIlxuICAgIH0pLnJlbmRlcigpO1xuXG4gICAgdGhpcy5tb2RhbEFsZXJ0ID0gbmV3IE1vZGFsQWxlcnQoe1xuICAgICAgZWw6IFwiI2NoZWNrLWNsb3NlIC5tb2RhbC10ZW1wbGF0ZVwiLFxuICAgICAgbW9kYWxEaXY6ICcjY2hlY2stY2xvc2UnLFxuICAgICAgY29udGVudDogbW9kYWxDb250ZW50LFxuICAgICAgY2FuY2VsOiAnQ2FuY2VsJyxcbiAgICAgIHN1Ym1pdDogJ0NoYW5nZSAnK2kxOG4udChcIlRhc2tcIikrJyBTdGF0ZScsXG4gICAgICBjYWxsYmFjazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgLy8gdXNlciBjbGlja2VkIHRoZSBzdWJtaXQgYnV0dG9uXG4gICAgICAgIHNlbGYubW9kZWwudHJpZ2dlcihcInRhc2s6dXBkYXRlOnN0YXRlXCIsICQoJ2lucHV0W25hbWU9b3Bwb3J0dW5pdHlTdGF0ZV06Y2hlY2tlZCcpLnZhbCgpKTtcbiAgICAgIH1cbiAgICB9KS5yZW5kZXIoKTtcbiAgfSxcblxuICBzdGF0ZVJlb3BlbjogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMubW9kZWwudHJpZ2dlcihcInRhc2s6dXBkYXRlOnN0YXRlXCIsICdvcGVuJyk7XG4gIH0sXG5cbiAgY2xlYW51cDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnRhc2tFZGl0Rm9ybVZpZXcpIHRoaXMudGFza0VkaXRGb3JtVmlldy5jbGVhbnVwKCk7XG4gICAgaWYgKHRoaXMudGFnVmlldykgeyB0aGlzLnRhZ1ZpZXcuY2xlYW51cCgpOyB9XG4gICAgaWYgKHRoaXMuYXR0YWNobWVudFZpZXcpIHsgdGhpcy5hdHRhY2htZW50Vmlldy5jbGVhbnVwKCk7IH1cbiAgICBpZiAodGhpcy5jb21tZW50TGlzdENvbnRyb2xsZXIpIHsgdGhpcy5jb21tZW50TGlzdENvbnRyb2xsZXIuY2xlYW51cCgpOyB9XG4gICAgaWYgKHRoaXMudGFza0l0ZW1WaWV3KSB7IHRoaXMudGFza0l0ZW1WaWV3LmNsZWFudXAoKTsgfVxuICAgIHJlbW92ZVZpZXcodGhpcyk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVGFza1Nob3dDb250cm9sbGVyO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcblxcdDxwPlBsZWFzZSBzZWxlY3QgdGhlIG5ldyBzdGF0ZSBmb3IgdGhlIG9wcG9ydHVuaXR5LiBUaGUgY3VycmVudCBzdGF0ZSBpcyBjaGVja2VkIGFuZCB0aGUgYXZhaWxhYmxlIHN0YXRlcyBhcmU6XFxuXFx0XFx0PHVsIHN0eWxlPSdsaXN0LXN0eWxlLXR5cGU6bm9uZSc+XFxuXFx0XFx0XFx0PCUgXy5lYWNoKHN0YXRlcywgZnVuY3Rpb24gKHQpIHsgJT5cXG5cXHRcXHRcXHRcXHQ8bGk+PGlucHV0IHR5cGU9J3JhZGlvJyBuYW1lPSdvcHBvcnR1bml0eVN0YXRlJyB2YWx1ZT0nPCUtIHQudmFsdWUgJT4nXFxuXFx0XFx0XFx0XFx0XFx0PCUgaWYgKCB0LnZhbHVlID09IG1vZGVsLmF0dHJpYnV0ZXMuc3RhdGUgKSB7JT5cXG5cXHRcXHRcXHRcXHRcXHRcXHQ8JS0gY2hlY2tlZD1cXFwiY2hlY2tlZFxcXCIgJT5cXG5cXHRcXHRcXHRcXHRcXHQ8JSB9ICU+XFxuXFx0XFx0XFx0XFx0XFx0XFx0PiA8JS0gdC5sYWJlbCAlPiA8L2xpPlxcblxcdFxcdFxcdFxcdFxcdDwlIH0pOyAlPlxcblxcdFxcdDwvdWw+XFxuXFx0PC9wPlxcbjwvZGl2PlxcblwiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjwhLS0gQUxFUlRTIC0tPlxcbjxkaXYgY2xhc3M9XFxcImFsZXJ0IGFsZXJ0LWRhbmdlclxcXCIgaWQ9XFxcImFsZXJ0LWNsb3NlZFxcXCIgc3R5bGU9XFxcIjwlIGlmIChtb2RlbC5zdGF0ZSAhPSAnY2xvc2VkJykgeyAlPmRpc3BsYXk6IG5vbmU7PCUgfSAlPlxcXCI+VGhpcyA8c3BhbiBkYXRhLWkxOG49XFxcInRhc2tcXFwiPm9wcG9ydHVuaXR5PC9zcGFuPiBpcyA8c3Ryb25nPmNsb3NlZDwvc3Ryb25nPi4gIEl0IGlzIG5vIGxvbmdlciBhY3RpdmUsIGFuZCBubyBtb3JlIG1vZGlmaWNhdGlvbnMgbWF5IGJlIG1hZGUuPC9kaXY+XFxuXFxuPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG5cXG4gIDxkaXYgY2xhc3M9XFxcImNvbC1tZC1wdXNoLTQgY29sLXNtLXB1c2gtNCBjb2wtc20tOCBjb2wtbWQtOCBtZC1ub3BhZGRpbmctcmlnaHRcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC05IHNtLW5vcGFkZGluZyBtZC1ub3BhZGRpbmdcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiYm94IGJveC1tYWluXFxcIj5cXG5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwibWFpbi1zZWN0aW9uXFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJlZGl0LXRhc2stc2VjdGlvblxcXCI+XFxuXFxuICAgICAgICAgICAgICA8aDE+PCUtIG1vZGVsLnRpdGxlICU+PC9oMT5cXG4gICAgICAgICAgICAgIDwlIGlmICghXy5pc1VuZGVmaW5lZChtb2RlbC5wcm9qZWN0KSAmJiB1aS5wcm9qZWN0LnNob3cpIHsgJT5cXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInRhc2stcHJvamVjdFxcXCI+XFxuICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIi9wcm9qZWN0cy88JS0gbW9kZWwucHJvamVjdElkICU+XFxcIiBjbGFzcz1cXFwibGluay1iYWNrYm9uZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWZvbGRlci1vXFxcIj48L2k+XFxuICAgICAgICAgICAgICAgICAgPCUtIG1vZGVsLnByb2plY3QudGl0bGUgJT5cXG4gICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICA8JSB9ICU+XFxuXFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0YXNrLXNob3ctZGVzY3JpcHRpb25cXFwiPlxcbiAgICAgICAgICAgICAgICA8JT0gbW9kZWwuZGVzY3JpcHRpb25IdG1sICU+XFxuICAgICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInRhc2stc2hvdy1jcmVhdGlvblxcXCI+XFxuICAgICAgICAgICAgICAgIDxzcGFuIGRhdGEtaTE4bj1cXFwiVGFza1xcXCI+T3Bwb3J0dW5pdHk8L3NwYW4+IGNyZWF0ZWQgPHRpbWUgY2xhc3M9XFxcInRpbWVhZ29cXFwiIGRhdGV0aW1lPVxcXCI8JS0gbW9kZWwuY3JlYXRlZEF0ICU+XFxcIj48JS0gbW9kZWwuY3JlYXRlZEF0ICU+PC90aW1lPlxcbiAgICAgICAgICAgICAgICA8JSBpZiAobW9kZWwuY3JlYXRlZEF0ICE9IG1vZGVsLnVwZGF0ZWRBdCkgeyAlPlxcbiAgICAgICAgICAgICAgICBhbmQgdXBkYXRlZCA8dGltZSBjbGFzcz1cXFwidGltZWFnb1xcXCIgZGF0ZXRpbWU9XFxcIjwlLSBtb2RlbC51cGRhdGVkQXQgJT5cXFwiPjwlLSBtb2RlbC51cGRhdGVkQXQgJT48L3RpbWU+XFxuICAgICAgICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0zIHBhZGRpbmctbGVmdC1ub25lIHNtLW5vcGFkZGluZyBtZC1ub3BhZGRpbmdcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiYm94IHBhZGRpbmctbm9uZVxcXCI+XFxuXFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm5hdmJhci1zaWRlIGxpa2Utcm93IGJvcmRlci1ib3R0b21cXFwiPlxcbiAgICAgICAgICAgIDwlIGlmICh1c2VyKSB7ICU+XFxuICAgICAgICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgaWQ9XFxcImxpa2UtYnV0dG9uXFxcIiBjbGFzcz1cXFwibGlrZS1idXR0b25cXFwiPlxcbiAgICAgICAgICAgIDwlIH0gZWxzZSB7ICU+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImxpa2UtYnV0dG9uXFxcIj5cXG4gICAgICAgICAgICA8JSB9ICU+XFxuICAgICAgICAgICAgICA8aSBpZD1cXFwibGlrZS1idXR0b24taWNvblxcXCIgY2xhc3M9XFxcImZhIGZhLXN0YXItbyBmYS1sZyBnb2xkXFxcIj48L2k+XFxuICAgICAgICAgICAgPCUgaWYgKHVzZXIpIHsgJT5cXG4gICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgPCUgfSBlbHNlIHsgJT5cXG4gICAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICAgICAgPCUgfSAlPlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJsaWtlLW51bWJlclxcXCIgaWQ9XFxcImxpa2UtbnVtYmVyXFxcIj48JS0gbW9kZWwubGlrZUNvdW50ICU+PC9zcGFuPlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJsaWtlLXBsdXJhbFxcXCIgaWQ9XFxcImxpa2UtdGV4dFxcXCIgZGF0YS1wbHVyYWw9XFxcImxpa2VzXFxcIiBkYXRhLXNpbmd1bGFyPVxcXCJsaWtlXFxcIj5saWtlczwvc3Bhbj5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm5hdmJhci1zaWRlIGJvcmRlci1ib3R0b21cXFwiPlxcbiAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwibmF2IG5hdi1waWxscyBuYXYtc3RhY2tlZFxcXCI+XFxuICAgICAgICAgICAgICA8bGk+XFxuICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGlkPVxcXCJlbWFpbFxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLWVudmVsb3BlLW9cXFwiPjwvaT4gPHNwYW4gY2xhc3M9XFxcImJveC1pY29uLXRleHRcXFwiPlNoYXJlPC9zcGFuPjwvYT5cXG4gICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgPC91bD5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDwlIGlmIChtb2RlbC5pc093bmVyIHx8ICh1c2VyICYmIHVzZXIuaXNBZG1pbikpIHsgJT5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwibmF2YmFyLXNpZGUgPCUgaWYgKHVzZXIpIHsgJT5ib3JkZXItYm90dG9tPCUgfSAlPlxcXCI+XFxuICAgICAgICAgICAgPGRpdiBpZD1cXFwibW9kYWwtY2xvc2VcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwibmF2IG5hdi1waWxscyBuYXYtc3RhY2tlZFxcXCI+XFxuICAgICAgICAgICAgICA8bGkgY2xhc3M9XFxcImxpLXRhc2stZWRpdFxcXCI+XFxuICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGlkPVxcXCJ0YXNrLWVkaXRcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1wZW5jaWxcXFwiPjwvaT4gPHNwYW4gY2xhc3M9XFxcImJveC1pY29uLXRleHRcXFwiPkVkaXQgPHNwYW4gZGF0YS1pMThuPVxcXCJUYXNrXFxcIj5PcHBvcnR1bml0eTwvc3Bhbj48L3NwYW4+PC9hPlxcbiAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICAgIDxsaSBjbGFzcz1cXFwibGktdGFzay12aWV3XFxcIiBzdHlsZT1cXFwiZGlzcGxheTogbm9uZTtcXFwiPlxcbiAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCIjXFxcIiBpZD1cXFwidGFzay12aWV3XFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtcGVuY2lsXFxcIj48L2k+IDxzcGFuIGNsYXNzPVxcXCJib3gtaWNvbi10ZXh0XFxcIj5WaWV3IDxzcGFuIGRhdGEtaTE4bj1cXFwiVGFza1xcXCI+T3Bwb3J0dW5pdHk8L3NwYW4+PC9zcGFuPjwvYT5cXG4gICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgICA8JSBpZiAoIWRyYWZ0QWRtaW5Pbmx5IHx8IG1vZGVsLnN0YXRlICE9PSAnZHJhZnQnIHx8ICh1c2VyICYmIHVzZXIuaXNBZG1pbikpIHsgJT5cXG4gICAgICAgICAgICAgIDxsaSBpZD1cXFwibGktdGFzay1jbG9zZVxcXCIgc3R5bGU9XFxcIjwlIGlmIChtb2RlbC5zdGF0ZSA9PSAnY2xvc2VkJykgeyAlPmRpc3BsYXk6IG5vbmU7PCUgfSAlPlxcXCI+XFxuICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGlkPVxcXCJ0YXNrLWNsb3NlXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtdGltZXMtY2lyY2xlXFxcIj48L2k+IDxzcGFuIGNsYXNzPVxcXCJib3gtaWNvbi10ZXh0XFxcIj5DaGFuZ2UgPHNwYW4gZGF0YS1pMThuPVxcXCJUYXNrXFxcIj5PcHBvcnR1bml0eTwvc3Bhbj4gU3RhdGU8L3NwYW4+PC9hPlxcbiAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICAgIDwlIH0gZWxzZSB7JT5cXG4gICAgICAgICAgICAgICAgPGxpPjxzcGFuIGNsYXNzPVxcXCJuby1saW5rXFxcIj5UaGlzIGRyYWZ0IDxzcGFuIGRhdGEtaTE4bj1cXFwidGFza1xcXCI+b3Bwb3J0dW5pdHk8L3NwYW4+IGlzIGF3YWl0aW5nIGFwcHJvdmFsIGZyb20gYW4gYWRtaW5pc3RyYXRvci48L3NwYW4+PC9saT5cXG4gICAgICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgICAgIDxsaSBpZD1cXFwibGktdGFzay1yZW9wZW5cXFwiIHN0eWxlPVxcXCI8JSBpZiAobW9kZWwuc3RhdGUgIT0gJ2Nsb3NlZCcpIHsgJT5kaXNwbGF5OiBub25lOzwlIH0gJT5cXFwiPlxcbiAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCIjXFxcIiBpZD1cXFwidGFzay1yZW9wZW5cXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1zaGFyZVxcXCI+PC9pPiA8c3BhbiBjbGFzcz1cXFwiYm94LWljb24tdGV4dFxcXCI+UmVvcGVuPC9zcGFuPjwvYT5cXG4gICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgICA8IS0tXFxuICAgICAgICAgICAgICA8bGk+XFxuICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGlkPVxcXCJ0YXNrLWRlbGV0ZVxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXRyYXNoLW9cXFwiPjwvaT4gPHNwYW4gY2xhc3M9XFxcImJveC1pY29uLXRleHRcXFwiPkRlbGV0ZSA8c3BhbiBkYXRhLWkxOG49XFxcIlRhc2tcXFwiPk9wcG9ydHVuaXR5PC9zcGFuPjwvc3Bhbj48L2E+XFxuICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgLS0+XFxuICAgICAgICAgICAgPC91bD5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwibmF2YmFyLXNpZGUgYm9yZGVyLWJvdHRvbVxcXCIgPCUgaWYgKCF2b2wpIHslPnN0eWxlPVxcXCJkaXNwbGF5OiBub25lO1xcXCI8JX0lPj5cXG4gICAgICAgICAgICA8ZGl2IGlkPVxcXCJtb2RhbC12b2x1bnRlZXJcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwibmF2IG5hdi1waWxscyBuYXYtc3RhY2tlZFxcXCI+XFxuICAgICAgICAgICAgICA8bGkgY2xhc3M9XFxcInZvbHVudGVlci10cnVlXFxcIiBzdHlsZT1cXFwiZGlzcGxheTogbm9uZTtcXFwiPlxcbiAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCIjXFxcIiBpZD1cXFwidm9sdW50ZWVyZWRcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWMxXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtdGh1bWJzLXVwXFxcIj48L2k+IDxzcGFuIGNsYXNzPVxcXCJib3gtaWNvbi10ZXh0XFxcIiBkYXRhLWkxOG49XFxcInRhc2tQYWdlLnZvbHVudGVlcmVkQnV0dG9uXFxcIj5Wb2x1bnRlZXJlZCE8L3NwYW4+PC9hPlxcblxcbiAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICAgIDxsaSBjbGFzcz1cXFwidm9sdW50ZWVyLWZhbHNlXFxcIj5cXG4gICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgaWQ9XFxcInZvbHVudGVlclxcXCIgY2xhc3M9XFxcImJ0biBidG4tYzJcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS10aHVtYnMtby11cFxcXCI+PC9pPiA8c3BhbiBjbGFzcz1cXFwiYm94LWljb24tdGV4dFxcXCIgZGF0YS1pMThuPVxcXCJ0YXNrUGFnZS52b2x1bnRlZXJCdXR0b25cXFwiPlZvbHVudGVlcjwvc3Bhbj48L2E+XFxuICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgIDwvdWw+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0xMiBzbS1ub3BhZGRpbmcgbWQtbm9wYWRkaW5nXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImJveCBib3gtbWFpbiB0YXNrLXZpZXdcXFwiPlxcbiAgICAgICAgICA8ZGl2IGlkPVxcXCJ0YXNrLXNob3ctbWFkbGliLWRlc2NyaXB0aW9uXFxcIiBjbGFzcz1cXFwidGFzay1zaG93LWRlc2NyaXB0aW9uXFxcIj5cXG4gICAgICAgICAgICBXZSBuZWVkXFxuICAgICAgICAgICAgICA8c3Ryb25nPlxcbiAgICAgICAgICAgICAgICA8JSBpZiAobWFkbGliVGFnc1sndGFzay1wZW9wbGUnXSkgeyAlPlxcbiAgICAgICAgICAgICAgICAgIDwlPSBtYWRsaWJUYWdzWyd0YXNrLXBlb3BsZSddWzBdLm5hbWUgJT5cXG4gICAgICAgICAgICAgICAgPCUgfSBlbHNlIHsgJT5cXG4gICAgICAgICAgICAgICAgICAnbm8gcGVvcGxlIHlldCBhc3NpZ25lZCdcXG4gICAgICAgICAgICAgICAgPCUgfSAlPlxcbiAgICAgICAgICAgICAgPC9zdHJvbmc+XFxuXFxuICAgICAgICAgICAgPCUgaWYgKG1hZGxpYlRhZ3MudG9waWMpIHsgJT5cXG4gICAgICAgICAgICB0byB3b3JrIG9uIGFuIDxzcGFuIGRhdGEtaTE4bj1cXFwidGFza1xcXCI+b3Bwb3J0dW5pdHk8L3NwYW4+IGFib3V0OlxcbiAgICAgICAgICAgICAgPHN0cm9uZz5cXG4gICAgICAgICAgICAgICAgICAgIDwlIF8uZWFjaChtYWRsaWJUYWdzLnRvcGljLCBmdW5jdGlvbiAodCwgaSkgeyAlPlxcbiAgICAgICAgICAgICAgICAgICAgPCUgaWYgKGkgPiAwKSB7ICU+XFxuICAgICAgICAgICAgICAgICAgICAsXFxuICAgICAgICAgICAgICAgICAgICA8JSB9ICU+XFxuICAgICAgICAgICAgICAgICAgICA8JT0gdC5uYW1lICU+XFxuICAgICAgICAgICAgICAgICAgICA8JSB9KSAlPlxcbiAgICAgICAgICAgICAgPC9zdHJvbmc+LlxcbiAgICAgICAgICAgIDwlIH0gJT5cXG5cXG4gICAgICAgICAgICA8YnIgLz5cXG5cXG4gICAgICAgICAgICBUaGUgZm9sbG93aW5nIHNraWxscyBhcmUgdXNlZnVsIGFuZFxcbiAgICAgICAgICAgICAgPHN0cm9uZz5cXG4gICAgICAgICAgICAgICAgPCUgaWYgKG1hZGxpYlRhZ3NbJ3Rhc2stc2tpbGxzLXJlcXVpcmVkJ10pIHsgJT5cXG4gICAgICAgICAgICAgICAgICA8JT0gbWFkbGliVGFnc1sndGFzay1za2lsbHMtcmVxdWlyZWQnXVswXS5uYW1lICU+XFxuICAgICAgICAgICAgICAgIDwlIH0gZWxzZSB7ICU+XFxuICAgICAgICAgICAgICAgICAgbm90IHJlcXVpcmVkXFxuICAgICAgICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgICAgIDwvc3Ryb25nPlxcblxcbiAgICAgICAgICAgIHRvIGNvbXBsZXRlIHRoaXMgPHNwYW4gZGF0YS1pMThuPVxcXCJ0YXNrXFxcIj5vcHBvcnR1bml0eTwvc3Bhbj46XFxuICAgICAgICAgICAgICA8c3Ryb25nPlxcbiAgICAgICAgICAgICAgICA8JSBpZiAobWFkbGliVGFncy5za2lsbCkgeyAlPlxcbiAgICAgICAgICAgICAgICAgIDwlIF8uZWFjaChtYWRsaWJUYWdzLnNraWxsLCBmdW5jdGlvbiAocywgaSkgeyAlPlxcbiAgICAgICAgICAgICAgICAgIDwlIGlmIChpID4gMCkgeyAlPlxcbiAgICAgICAgICAgICAgICAgICxcXG4gICAgICAgICAgICAgICAgICA8JSB9ICU+XFxuICAgICAgICAgICAgICAgICAgPCU9IHMubmFtZSAlPlxcbiAgICAgICAgICAgICAgICAgIDwlIH0pICU+XFxuICAgICAgICAgICAgICAgIDwlIH0gZWxzZSB7ICU+XFxuICAgICAgICAgICAgICAgICAgbm8gc3BlY2lhbCBza2lsbHMgcmVxdWlyZWRcXG4gICAgICAgICAgICAgICAgPCUgfSAlPlxcbiAgICAgICAgICAgICAgPC9zdHJvbmc+LlxcblxcblxcbiAgICAgICAgICAgIFRoZSA8c3BhbiBkYXRhLWkxOG49XFxcInRhc2tcXFwiPm9wcG9ydHVuaXR5PC9zcGFuPiB3aWxsIHJlcXVpcmVcXG4gICAgICAgICAgICAgIDxzdHJvbmc+XFxuICAgICAgICAgICAgICAgIDwlIGlmIChtYWRsaWJUYWdzWyd0YXNrLXRpbWUtZXN0aW1hdGUnXSkgeyAlPlxcbiAgICAgICAgICAgICAgICAgIDwlPSBtYWRsaWJUYWdzWyd0YXNrLXRpbWUtZXN0aW1hdGUnXVswXS5uYW1lICU+XFxuICAgICAgICAgICAgICAgIDwlIH0gZWxzZSB7ICU+XFxuICAgICAgICAgICAgICAgICAgYW4gdW5zcGVjaWZpZWQgYW1vdW50IG9mIHRpbWVcXG4gICAgICAgICAgICAgICAgPCUgfSAlPlxcbiAgICAgICAgICAgICAgPC9zdHJvbmc+XFxuXFxuICAgICAgICAgICAgb2ZcXG4gICAgICAgICAgICAgIDxzdHJvbmc+XFxuICAgICAgICAgICAgICAgIDwlIGlmIChtYWRsaWJUYWdzWyd0YXNrLXRpbWUtcmVxdWlyZWQnXSkgeyAlPlxcbiAgICAgICAgICAgICAgICAgIDwlPSBtYWRsaWJUYWdzWyd0YXNrLXRpbWUtcmVxdWlyZWQnXVswXS5uYW1lICU+XFxuICAgICAgICAgICAgICAgIDwlIH0gZWxzZSB7ICU+XFxuICAgICAgICAgICAgICAgICAgdW5zdHJ1Y3R1cmVkXFxuICAgICAgICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgICAgIDwvc3Ryb25nPlxcblxcbiAgICAgICAgICAgIHdvcmssIGFuZFxcbiAgICAgICAgICAgIDwlIGlmIChtYWRsaWJUYWdzWyd0YXNrLWxlbmd0aCddKSB7ICU+XFxuICAgICAgICAgICAgbXVzdCBiZSBjb21wbGV0ZWQgd2l0aGluXFxuICAgICAgICAgICAgICA8c3Ryb25nPlxcbiAgICAgICAgICAgICAgICA8JT0gbWFkbGliVGFnc1sndGFzay1sZW5ndGgnXVswXS5uYW1lICU+PC9zdHJvbmc+LlxcbiAgICAgICAgICAgIDwlIH0gZWxzZSB7ICU+XFxuICAgICAgICAgICAgICA8c3Ryb25nPlxcbiAgICAgICAgICAgICAgICBoYXMgbm8gZGVhZGxpbmUuXFxuICAgICAgICAgICAgICA8L3N0cm9uZz5cXG4gICAgICAgICAgICA8JSB9ICU+XFxuXFxuICAgICAgICAgICAgPCUgaWYgKG1hZGxpYlRhZ3MubG9jYXRpb24pIHsgJT5cXG4gICAgICAgICAgICBUaGUgcGFydGljaXBhbnQocykgbXVzdCBiZSBsb2NhdGVkIGF0XFxuICAgICAgICAgICAgPHN0cm9uZz5cXG4gICAgICAgICAgICAgIDwlIF8uZWFjaChtYWRsaWJUYWdzLmxvY2F0aW9uLCBmdW5jdGlvbiAocywgaSkgeyAlPlxcbiAgICAgICAgICAgICAgPCUgaWYgKGkgPiAwKSB7ICU+XFxuICAgICAgICAgICAgICAsXFxuICAgICAgICAgICAgICA8JSB9ICU+XFxuICAgICAgICAgICAgICA8JT0gcy5uYW1lICU+XFxuICAgICAgICAgICAgICA8JSB9KSAlPlxcbiAgICAgICAgICAgIDwvc3Ryb25nPlxcbiAgICAgICAgICAgIHRvIGNvbXBsZXRlIHRoaXMgPHNwYW4gZGF0YS1pMThuPVxcXCJ0YXNrXFxcIj5vcHBvcnR1bml0eTwvc3Bhbj4uXFxuICAgICAgICAgICAgPCUgfSBlbHNlIHsgJT5cXG4gICAgICAgICAgICBUaGUgcGFydGljaXBhbnQocykgY2FuIGJlIGxvY2F0ZWQgYW55d2hlcmUuXFxuICAgICAgICAgICAgPCUgfSAlPlxcbiAgICAgICAgICAgIDwvc3Ryb25nPlxcblxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMTIgc20tbm9wYWRkaW5nIG1kLW5vcGFkZGluZ1xcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJib3ggdGFzay1ib3RoXFxcIj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiYm94LXBhZC1sciBib3JkZXItYm90dG9tXFxcIj5cXG4gICAgICAgICAgICA8aDI+UmVxdWVzdG9yIGFuZCBQYXJ0aWNpcGFudHNcXG4gICAgICAgICAgICA8L2gyPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiYm94LW1haW5cXFwiIGlkPVxcXCJ0YXNrLXZvbHVudGVlcnNcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInByb2plY3QtcGVvcGxlLWRpdlxcXCIgZGF0YS11c2VyaWQ9XFxcIjwlPSBtb2RlbC51c2VySWQgJT5cXFwiPlxcbiAgICAgICAgICAgICAgPGltZyBzcmM9XFxcIi9hcGkvdXNlci9waG90by88JT0gbW9kZWwudXNlcklkICU+XFxcIiBjbGFzcz1cXFwicHJvamVjdC1wZW9wbGVcXFwiIGFsdD1cXFwiPCU9IG1vZGVsLm93bmVyLm5hbWUgJT5cXFwiLz5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwcm9qZWN0LXBlb3BsZS1zcGFjZVxcXCI+XFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJiYXJcXFwiPlxcbiAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPCUgXy5lYWNoKG1vZGVsLnZvbHVudGVlcnMsIGZ1bmN0aW9uICh2KSB7ICU+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicHJvamVjdC1wZW9wbGUtZGl2XFxcIiBkYXRhLXVzZXJpZD1cXFwiPCU9IHYudXNlcklkICU+XFxcIiBkYXRhLXZvbHVzZXJpZD1cXFwiPCU9IHYudXNlcklkICU+XFxcIj5cXG4gICAgICAgICAgICAgIDxpbWcgc3JjPVxcXCIvYXBpL3VzZXIvcGhvdG8vPCU9IHYudXNlcklkICU+XFxcIiBjbGFzcz1cXFwicHJvamVjdC1wZW9wbGVcXFwiIGFsdD1cXFwiPCU9IHYubmFtZSAlPlxcXCIvPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwlIH0pOyAlPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMTIgdGFzay12aWV3IHNtLW5vcGFkZGluZyBtZC1ub3BhZGRpbmdcXFwiPlxcblxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiYm94IGNvbW1lbnQtbGlzdC13cmFwcGVyXFxcIiBzdHlsZT1cXFwiY2xlYXI6IGJvdGg7XFxcIj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiYm94LXBhZC1sciBib3JkZXItYm90dG9tXFxcIj5cXG4gICAgICAgICAgICA8aDI+RGlzY3Vzc2lvblxcbiAgICAgICAgICAgIDwlIGlmICh1c2VyKSB7ICU+XFxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnRuIGJ0bi1jMCBidG4tc20gZmlsZS1hZGQgbmV3LXRvcGljXFxcIiBpZD1cXFwicHJvamVjdC10b3BpYy1uZXdcXFwiPk5ldyBUb3BpYzwvYnV0dG9uPlxcbiAgICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgICA8L2gyPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiXFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJib3gtcGFkLWxyIGJveC1wYWQtdCB0b3BpYy1mb3JtLXdyYXBwZXJcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgIDx1bCBpZD1cXFwiY29tbWVudC1saXN0LW51bGxcXFwiPlxcbiAgICAgICAgICAgIDwvdWw+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcblxcbiAgPC9kaXY+XFxuXFxuICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtcHVsbC04IGNvbC1zbS1wdWxsLTggY29sLXNtLTQgY29sLW1kLTQgcHJvamVjdC1zaWRlYmFyIG1kLW5vcGFkZGluZy1yaWdodFxcXCI+XFxuICAgIDwhLS0gTEVGVCBTSURFQkFSIC0tPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0xMiBib3ggc20tbm9wYWRkaW5nXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImJveC1tYWluIHRhZy13cmFwcGVyXFxcIj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMTIgYm94IHRhc2stdmlldyBzbS1ub3BhZGRpbmdcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiYXR0YWNobWVudC13cmFwcGVyXFxcIj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxwPkluIG9yZGVyIHRvIGludHJvZHVjZSB5b3UgYXMgcGFydCBvZiB0aGUgc2lnbiB1cCBwcm9jZXNzLCB3ZSB3b3VsZCBsaWtlIHRvIGZpbGwgaW4geW91ciBwcm9maWxlLiBQbGVhc2UgZW50ZXIgeW91ciBuYW1lOjwvcD5cXG48ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sIHZhbGlkYXRlXFxcIiBpZD1cXFwidXBkYXRlLW5hbWUtZmllbGRcXFwiIG5hbWU9XFxcInVwZGF0ZS1uYW1lLWZpZWxkXFxcIiBwbGFjZWhvbGRlcj1cXFwiRnVsbCBOYW1lXFxcIiBkYXRhLXZhbGlkYXRlPVxcXCJlbXB0eVxcXCI+XFxuICA8c3BhbiBjbGFzcz1cXFwiaGVscC1ibG9jayBlcnJvci1lbXB0eVxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPlBsZWFzZSBlbnRlciB5b3VyIGZ1bGwgbmFtZS48L3NwYW4+XFxuPC9kaXY+XFxuXCI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuXFx0PHA+VGhhbmsgeW91IGZvciB2b2x1bnRlZXJpbmcuIFBsZWFzZSBiZSBzdXJlIHlvdSBoYXZlIHRoZSBhdmFpbGFiaWxpdHkgYW5kIGV4cGVydGlzZSB0byBzdXBwb3J0IHRoaXMgb3Bwb3J0dW5pdHkgdG8gY29tcGxldGlvbi4gV2Ugd2lsbCBub3RpZnkgeW91ciBzdXBlcnZpc29yIG9mIHlvdXIgaW50ZXJlc3QgaW4gdGhpcyBwcm9qZWN0IHNvIHRoYXQgaGUgb3Igc2hlIGlzIGF3YXJlIHRoYXQgeW91IHBsYW4gdG8gaW5jbHVkZSB0aGlzIHdvcmsgZHVyaW5nIHlvdXIgcmVndWxhcmx5IHNjaGVkdWxlZCB3b3JrIHdlZWsgdG8gc3VwcG9ydCBEZXBhcnRtZW50IGNvbGxlYWd1ZXMgYW5kIHByb2plY3RzLiBLdWRvcyB0byB5b3UhPC9wPlxcblxcdDxwPlBsZWFzZSBlbnRlciAgdGhlIG5hbWUgYW5kIGVtYWlsIGFkZHJlc3Mgb2YgeW91ciBzdXBlcnZpc29yIGJlbG93LiBJZiB5b3XigJl2ZSBwcmV2aW91c2x5IHZvbHVudGVlcmVkLCB0aGUgbGFzdCBzdXBlcnZpc29yIGVtYWlsIHlvdSBwcm92aWRlZCBpcyBzaG93bi4gUGxlYXNlIHVwZGF0ZSBpdCBpZiBuZWNlc3NhcnkuPC9wPlxcblxcdDxzcGFuIGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG5cXHRcXHQ8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgaWQ9XFxcInVzZXJTdXBlclZpc29yTmFtZVxcXCIgcGxhY2Vob2xkZXI9XFxcIlN1cGVydmlzb3IgTmFtZVxcXCIgY2xhc3M9XFxcInZhbGlkYXRlXFxcIiBkYXRhLXZhbGlkYXRlPVxcXCJlbXB0eVxcXCIgdmFsdWU9XFxcIjwlPSBzdXBlcnZpc29yTmFtZSAlPlxcXCIvPlxcblxcdFxcdDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBpZD1cXFwidXNlclN1cGVyVmlzb3JFbWFpbFxcXCIgcGxhY2Vob2xkZXI9XFxcIlN1cGVydmlzb3IgZW1haWwgYWRkcmVzc1xcXCIgY2xhc3M9XFxcInZhbGlkYXRlXFxcIiBkYXRhLXZhbGlkYXRlPVxcXCJlbXB0eSxlbWFpbCxlbWFpbGRvbWFpblxcXCIgZGF0YS1lbWFpbGRvbWFpbj1cXFwic3RhdGUuZ292XFxcIiB2YWx1ZT1cXFwiPCU9IHN1cGVydmlzb3JFbWFpbCAlPlxcXCIvPlxcblxcdFxcdDxzcGFuIGNsYXNzPVxcXCJoZWxwLWJsb2NrIGVycm9yLWVtYWlsIGVycm9yLWVtcHR5IGVycm9yLWVtYWlsZG9tYWluXFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI+WW91IG11c3QgZW50ZXIgYSBuYW1lIGFuZCBhIHZhbGlkIFN0YXRlIERlcGFydG1lbnQgZW1haWwgYWRkcmVzcyB0byBwcm9jZWVkLjwvc3Bhbj5cXG5cXHQ8L3NwYW4+XFxuPC9kaXY+XFxuXCI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHAgZGF0YS1pMThuPVxcXCJ2b2x1bnRlZXJNb2RhbC5ub3RpZnlTdXBlcnZpc29yXFxcIj5JIHVuZGVyc3RhbmQgaXQgaXMgbXkgcmVzcG9uc2liaWxpdHkgdG8gY29uZmlybSBzdXBlcnZpc29yIGFwcHJvdmFsIHByaW9yIHRvIGNvbW1pdHRpbmcgdG8gYW4gb3Bwb3J0dW5pdHkuPC9wPlxcbjxwIGRhdGEtaTE4bj1cXFwidm9sdW50ZWVyTW9kYWwuY2FudENhbmNlbFxcXCI+T25jZSB5b3Ugdm9sdW50ZWVyIGZvciBhbiBvcHBvcnR1bml0eSwgeW91IHdpbGwgbm90IGJlIGFibGUgdG8gY2FuY2VsIHlvdXIgY29tbWl0bWVudCB0byB2b2x1bnRlZXIuPC9wPlxcblwiO1xuIiwidmFyIEJvb3RzdHJhcCA9IHJlcXVpcmUoJ2Jvb3RzdHJhcCcpO1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vbWl4aW5zL3V0aWxpdGllcycpO1xudmFyIFVJQ29uZmlnID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29uZmlnL3VpLmpzb24nKTtcbnZhciBhc3luYyA9IHJlcXVpcmUoJ2FzeW5jJyk7XG52YXIgbWFya2VkID0gcmVxdWlyZSgnbWFya2VkJyk7XG52YXIgVGltZUFnbyA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uLy4uL3ZlbmRvci9qcXVlcnkudGltZWFnbycpO1xudmFyIEJhc2VWaWV3ID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vYmFzZS9iYXNlX3ZpZXcnKTtcbnZhciBUYXNrU2hvd1RlbXBsYXRlID0gcmVxdWlyZSgnLi4vdGVtcGxhdGVzL3Rhc2tfc2hvd19pdGVtX3RlbXBsYXRlLmh0bWwnKTtcblxuXG52YXIgVGFza0l0ZW1WaWV3ID0gQmFzZVZpZXcuZXh0ZW5kKHtcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMubW9kZWwudHJpZ2dlcihcInRhc2s6bW9kZWw6ZmV0Y2hcIiwgb3B0aW9ucy5pZCk7XG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCBcInRhc2s6bW9kZWw6ZmV0Y2g6c3VjY2Vzc1wiLCBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgIHNlbGYubW9kZWwgPSBtb2RlbDtcbiAgICAgIHNlbGYuaW5pdGlhbGl6ZVRhZ3Moc2VsZik7XG4gICAgfSk7XG4gIH0sXG5cbiAgZ2V0VGFnRGF0YTogZnVuY3Rpb24gKHNlbGYsIGNiKSB7XG4gICAgJC5hamF4KHtcbiAgICAgIHVybDogJy9hcGkvdGFnL2ZpbmRBbGxCeVRhc2tJZC8nICsgc2VsZi5vcHRpb25zLmlkLFxuICAgICAgYXN5bmM6IGZhbHNlLFxuICAgICAgc3VjY2VzczogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgc2VsZi50YWdzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIHNlbGYudGFncy5wdXNoKGRhdGFbaV0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ1aWxkIG9iamVjdCBmb3IgcmVuZGVyXG4gICAgICAgIHNlbGYuZGF0YSA9IHtcbiAgICAgICAgICB1c2VyOiB3aW5kb3cuY2FjaGUuY3VycmVudFVzZXIsXG4gICAgICAgICAgbW9kZWw6IHNlbGYubW9kZWwudG9KU09OKCksXG4gICAgICAgICAgdGFnczogc2VsZi50YWdzXG4gICAgICAgIH07XG4gICAgICAgIHNlbGYuZGF0YVsnbWFkbGliVGFncyddID0gb3JnYW5pemVUYWdzKHNlbGYudGFncyk7XG4gICAgICAgIC8vIGNvbnZlcnQgZGVzY3JpcHRpb24gZnJvbSBtYXJrZG93biB0byBodG1sXG4gICAgICAgIHNlbGYuZGF0YS5tb2RlbC5kZXNjcmlwdGlvbkh0bWwgPSBtYXJrZWQoc2VsZi5kYXRhLm1vZGVsLmRlc2NyaXB0aW9uKTtcbiAgICAgICAgc2VsZi5tb2RlbC50cmlnZ2VyKCd0YXNrOnRhZzpkYXRhJywgc2VsZi50YWdzLCBzZWxmLmRhdGFbJ21hZGxpYlRhZ3MnXSk7XG4gICAgICAgIHJldHVybiBjYigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoc2VsZikge1xuICAgIHNlbGYuZ2V0VGFnRGF0YShzZWxmLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZCA9IHNlbGYuZGF0YSxcbiAgICAgICAgICB2b2wgPSAoKCFkLnVzZXIgfHwgZC51c2VyLmlkICE9PSBkLm1vZGVsLnVzZXJJZCkgJiYgZC5tb2RlbC5zdGF0ZSAhPT0gJ2RyYWZ0Jyk7XG4gICAgICBzZWxmLmRhdGEudWkgPSBVSUNvbmZpZztcbiAgICAgIHNlbGYuZGF0YS52b2wgPSB2b2w7XG4gICAgICB2YXIgY29tcGlsZWRUZW1wbGF0ZSA9IF8udGVtcGxhdGUoVGFza1Nob3dUZW1wbGF0ZSkoc2VsZi5kYXRhKTtcbiAgICAgIHNlbGYuJGVsLmh0bWwoY29tcGlsZWRUZW1wbGF0ZSk7XG4gICAgICBzZWxmLiRlbC5pMThuKCk7XG4gICAgICAkKFwidGltZS50aW1lYWdvXCIpLnRpbWVhZ28oKTtcbiAgICAgIHNlbGYudXBkYXRlVGFza0VtYWlsKCk7XG4gICAgICBzZWxmLm1vZGVsLnRyaWdnZXIoJ3Rhc2s6c2hvdzpyZW5kZXI6ZG9uZScpO1xuICAgIH0pO1xuICB9LFxuXG4gIHVwZGF0ZVRhc2tFbWFpbDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICQuYWpheCh7XG4gICAgICB1cmw6IGVuY29kZVVSSSgnL2FwaS9lbWFpbC9tYWtlVVJMP2VtYWlsPWNvbnRhY3RVc2VyQWJvdXRUYXNrJnN1YmplY3Q9Q2hlY2sgT3V0IFwiJysgc2VsZi5tb2RlbC5hdHRyaWJ1dGVzLnRpdGxlICsgJ1wiJyArXG4gICAgICAnJm9wcG9ydHVuaXR5VGl0bGU9JyArIHNlbGYubW9kZWwuYXR0cmlidXRlcy50aXRsZSArXG4gICAgICAnJm9wcG9ydHVuaXR5TGluaz0nICsgd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgd2luZG93LmxvY2F0aW9uLmhvc3QgKyBcIlwiICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICtcbiAgICAgICcmb3Bwb3J0dW5pdHlEZXNjcmlwdGlvbj0nICsgKHNlbGYubW9kZWwuYXR0cmlidXRlcy5kZXNjcmlwdGlvbiB8fCAnJykgK1xuICAgICAgJyZvcHBvcnR1bml0eU1hZGxpYnM9JyArICQoJzxkaXYgLz4nLCB7IGh0bWw6IHNlbGYuJCgnI3Rhc2stc2hvdy1tYWRsaWItZGVzY3JpcHRpb24nKS5odG1sKCkgfSkudGV4dCgpLnJlcGxhY2UoL1xccysvZywgXCIgXCIpKSxcbiAgICAgIHR5cGU6ICdHRVQnXG4gICAgfSkuZG9uZSggZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHNlbGYuJCgnI2VtYWlsJykuYXR0cignaHJlZicsIGRhdGEpO1xuICAgIH0pO1xuXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZVRhZ3M6IGZ1bmN0aW9uIChzZWxmKSB7XG4gICAgdmFyIHR5cGVzID0gW1widGFzay1za2lsbHMtcmVxdWlyZWRcIiwgXCJ0YXNrLXRpbWUtcmVxdWlyZWRcIiwgXCJ0YXNrLXBlb3BsZVwiLCBcInRhc2stbGVuZ3RoXCIsIFwidGFzay10aW1lLWVzdGltYXRlXCJdO1xuXG4gICAgc2VsZi50YWdTb3VyY2VzID0ge307XG5cbiAgICB2YXIgcmVxdWVzdEFsbFRhZ3NCeVR5cGUgPSBmdW5jdGlvbiAodHlwZSwgY2IpIHtcbiAgICAgICQuYWpheCh7XG4gICAgICAgIHVybDogJy9hcGkvYWMvdGFnP3R5cGU9JyArIHR5cGUgKyAnJmxpc3QnLFxuICAgICAgICB0eXBlOiAnR0VUJyxcbiAgICAgICAgYXN5bmM6IGZhbHNlLFxuICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIC8vIER5bmFtaWNhbGx5IGNyZWF0ZSBhbiBhc3NvY2lhdGl2ZVxuICAgICAgICAgIC8vIGFycmF5IGJhc2VkIG9uIHRoYXQgZm9yIHRoZSBwb2ludGVyIHRvIHRoZSBsaXN0IGl0c2VsZiB0byBiZSBpdGVyYXRlZCB0aHJvdWdoXG4gICAgICAgICAgLy8gb24gdGhlIGZyb250LWVuZC5cbiAgICAgICAgICBzZWxmLnRhZ1NvdXJjZXNbdHlwZV0gPSBkYXRhO1xuICAgICAgICAgIHJldHVybiBjYigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYy5lYWNoKHR5cGVzLCByZXF1ZXN0QWxsVGFnc0J5VHlwZSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgc2VsZi5tb2RlbC50cmlnZ2VyKCd0YXNrOnRhZzp0eXBlcycsIHNlbGYudGFnU291cmNlcyk7XG4gICAgICBzZWxmLnJlbmRlcihzZWxmKTtcbiAgICB9KTtcbiAgfSxcblxuICBjbGVhbnVwOiBmdW5jdGlvbigpIHtcbiAgICByZW1vdmVWaWV3KHRoaXMpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUYXNrSXRlbVZpZXc7XG4iLCJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcblxuXG5cdEJhc2VDb21wb25lbnQgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG5cblx0XHRpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7fVxuXG5cdH0pO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gQmFzZUNvbXBvbmVudDtcbiIsIi8vIEJhc2UgQ29udHJvbGxlclxuXG5cbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcblxuXG5cdEJhc2VDb250cm9sbGVyID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuXHRcdFxuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHt9LFxuXG5cdFx0Ly8gLS0tLS0tLS0tLS0tXG5cdFx0Ly89IENsYXNzIE1ldGhvZHMgYXZhaWxhYmxlIGZvciBvdGhlciB2aWV3cyBcblx0XHQvLyAtLS0tLS0tLS0tLS1cblxuXHRcdGluaXRpYWxpemVWaWV3U2FmZWx5OiBmdW5jdGlvbiAodmlld05hbWUpIHtcblx0XHRcdGlmICh0aGlzLnZpZXcpIHtcblx0XHRcdFx0dGhpcy52aWV3LmluaXRpYWxpemUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMudmlldyA9IG5ldyB2aWV3TmFtZSgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHQkKHRoaXMpLnJlbW92ZSgpO1xuXHRcdH1cblxuXHR9KTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IEJhc2VDb250cm9sbGVyO1xuXG4iLCIvLyBUaGlzIGNsYXNzIGltcGxlbWVudHMgYSBwYXJhZGlnbSB3aGVyZWluIGl0IHJlbmRlcnMgaXRzIG93biBjaGlsZCBjbGFzcy5cbi8vIERvaW5nIHRoaXMgYWxsb3dzIHVzIHRvIHBlcmZvcm0gbG9naWMgYWdhaW5zdCBpdC5cblxuLy8gTk9URVM6XG4vLyAndGhpcycgcmVmZXJzIHRvIHRoZSBwcm90b3R5cGUgY2xhc3MsIG5vdCB0aGUgY29uc3RydWN0b3IgKGxvZ2ljYWwgdGhpcykuXG4vLyBUaGlzIGlzIHZlcnkgdXNlZnVsIGZvciBzbWFsbGVyIGVsIHJlZ2lvbnMsIHN1Y2ggYXMgYSB0YXNrIGxpc3Rcbi8vIG9yIGFueXRoaW5nIHRoYXQgcmVxdWlyZXMgYSBzbWFsbCBzcGlubmVyLiAgQ3VycmVudGx5IHRvIGFkZCBhIGJpZ2dlciBzcGlubmVyXG4vLyBJJ2QgaGF2ZSB0byBleGNoYW5nZSB0aGUgZ2lmIGN1cnJlbnRseSBwcm92aWRlZCBieSBmb250LWF3ZXNvbWUuXG5cblxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIHV0aWxpdGllcyA9IHJlcXVpcmUoJy4uL21peGlucy91dGlsaXRpZXMnKTtcblxuXG52YXIgQmFzZVZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICB9LFxuXG4gIGNsZWFudXA6IGZ1bmN0aW9uICgpIHtcbiAgICByZW1vdmVWaWV3KHRoaXMpO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VWaWV3O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImFsZXJ0IDwlIGlmIChhbGVydC50eXBlKSB7ICU+PCU9IGFsZXJ0LnR5cGUgJT48JSB9IGVsc2UgeyAlPmFsZXJ0LWRhbmdlcjwlIH0gJT5cXFwiIGlkPVxcXCJhbGVydC1tYWluXFxcIj5cXG4gIDwlIGlmIChhbGVydC5kaXNtaXNzKSB7ICU+XFxuICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImNsb3NlXFxcIiBkYXRhLWRpc21pc3M9XFxcImFsZXJ0XFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+JnRpbWVzOzwvYnV0dG9uPlxcbiAgPCUgfSAlPlxcbiAgPCU9IGFsZXJ0Lm1lc3NhZ2UgJT5cXG48L2Rpdj5cXG5cIjtcbiIsIi8qKlxuICogVGhpcyBjb21wb25lbnQgaW1wbGVtZW50cyBhIE1hcmtkb3duIFRleHRFZGl0b3IgdGhhdCBjYW4gYmVcbiAqIGRyb3BwZWQgaW50byBhbnl3aGVyZSBvbiBhbiBleGlzdGluZyBmb3JtLlxuICogSW5pdGlhbGl6ZSB0aGUgTWFya2Rvd25FZGl0b3Igd2l0aCBhbiBlbGVtZW50IGBlbGAsXG4gKiBhbmQgdGhlIGBpZGAgb2YgdGhlIHRleHRhcmVhIChzbyB5b3UgY2FuIHJldHJlaXZlIGl0c1xuICogdmFsdWUgd2hlbiB0aGUgdXNlciBzdWJtaXRzIHRoZSBmb3JtLilcbiAqXG4gKiBPcHRpb25zOlxuICogICBlbDogSFRNTCBlbGVtZW50IHRvIGZpbGwgLSByZXF1aXJlZFxuICogICBpZDogSFRNTCBJRCBmb3IgdGhlIDx0ZXh0YXJlYT4gZWxlbWVudCAtIHJlcXVpcmVkXG4gKiAgIGRhdGE6IERlZmF1bHQgZGF0YSBmb3IgdGhlIHRleHRhcmVhIC0gcmVxdWlyZWRcbiAqICAgcGxhY2Vob2xkZXI6IFRleHRhcmVhIHBsYWNlaG9sZGVyIHZhbHVlIC0gb3B0aW9uYWxcbiAqICAgbWF4bGVuZ3RoOiBNYXhpbXVtIGNoYXJhY3RlcnMgZm9yIHRoZSB0ZXh0IGFyZWEgLSBvcHRpb25hbFxuICogICByb3dzOiBOdW1iZXIgb2Ygcm93cyBpbiB0aGUgdGV4dGFyZWEgLSBvcHRpb25hbFxuICogICB2YWxpZGF0ZTogTGlzdCBvZiBzdHJpbmdzIGZvciB0aGUgZGF0YS12YWxpZGF0ZSBhdHRyaWJ1dGUgLSBvcHRpb25hbFxuICogICAgIGV4YW1wbGU6IFsnZW1wdHknLCAnY291bnQ0MDAnXVxuICovXG5cbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL21peGlucy91dGlsaXRpZXMnKTtcbnZhciBtYXJrZWQgPSByZXF1aXJlKCdtYXJrZWQnKTtcbnZhciBCYXNlQ29tcG9uZW50ID0gcmVxdWlyZSgnLi4vYmFzZS9iYXNlX2NvbXBvbmVudCcpO1xudmFyIGpxU2VsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdmVuZG9yL2pxdWVyeS5zZWxlY3Rpb24nKTtcbnZhciBFZGl0b3JUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vbWFya2Rvd25fZWRpdG9yX3RlbXBsYXRlLmh0bWwnKTtcblxuXG5NYXJrZG93bkVkaXRvciA9IEJhc2VDb21wb25lbnQuZXh0ZW5kKHtcblxuICBldmVudHM6IHtcbiAgICBcImNsaWNrIC5idG5cIiAgICAgICAgICAgICAgICAgOiBcImNsaWNrQnV0dG9uXCJcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5hY3Rpb25zID0ge1xuICAgICAgJ2JvbGQnOiB7XG4gICAgICAgIGJlZm9yZTogJyoqJyxcbiAgICAgICAgdGV4dDogJ3RleHQnLFxuICAgICAgICBhZnRlcjogJyoqJ1xuICAgICAgfSxcbiAgICAgICdpdGFsaWMnOiB7XG4gICAgICAgIGJlZm9yZTogJ18nLFxuICAgICAgICB0ZXh0OiAndGV4dCcsXG4gICAgICAgIGFmdGVyOiAnXydcbiAgICAgIH0sXG4gICAgICAnc3RyaWtldGhyb3VnaCc6IHtcbiAgICAgICAgYmVmb3JlOiAnfn4nLFxuICAgICAgICB0ZXh0OiAndGV4dCcsXG4gICAgICAgIGFmdGVyOiAnfn4nXG4gICAgICB9LFxuICAgICAgJ2NvZGUnOiB7XG4gICAgICAgIGJlZm9yZTogJ2AnLFxuICAgICAgICB0ZXh0OiAnY29kZScsXG4gICAgICAgIGFmdGVyOiAnYCdcbiAgICAgIH0sXG4gICAgICAnbGluayc6IHtcbiAgICAgICAgYmVmb3JlOiAnW0xpbmsgVGl0bGVdKCcsXG4gICAgICAgIHRleHQ6ICdodHRwOi8vJyxcbiAgICAgICAgYWZ0ZXI6ICcpJ1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIGlkOiB0aGlzLm9wdGlvbnMuaWQsXG4gICAgICB2YWxpZGF0ZTogdGhpcy5vcHRpb25zLnZhbGlkYXRlLFxuICAgICAgcm93czogdGhpcy5vcHRpb25zLnJvd3MsXG4gICAgICBtYXhsZW5ndGg6IHRoaXMub3B0aW9ucy5tYXhsZW5ndGgsXG4gICAgICBwbGFjZWhvbGRlcjogdGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyLFxuICAgICAgdGl0bGU6IHRoaXMub3B0aW9ucy50aXRsZSxcbiAgICAgIGRhdGE6IHRoaXMub3B0aW9ucy5kYXRhXG4gICAgfTtcbiAgICB2YXIgdGVtcGxhdGUgPSBfLnRlbXBsYXRlKEVkaXRvclRlbXBsYXRlKShkYXRhKTtcbiAgICB0aGlzLiRlbC5odG1sKHRlbXBsYXRlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBjbGlja0J1dHRvbjogZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB2YXIgdCA9ICQoZS5jdXJyZW50VGFyZ2V0KTtcbiAgICB2YXIgc2VsVGV4dCA9IHRoaXMuJChcIiNcIiArIHRoaXMub3B0aW9ucy5pZCkuc2VsZWN0aW9uKCk7XG4gICAgdmFyIGVkaXREYXRhID0gdC5kYXRhKCdlZGl0Jyk7XG4gICAgaWYgKChlZGl0RGF0YSAhPSAncHJldmlldycpICYmXG4gICAgICAgIChlZGl0RGF0YSAhPSAnZWRpdCcpICYmXG4gICAgICAgIChlZGl0RGF0YSAhPSAnaGVscCcpKSB7XG4gICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgc2VsZWN0ZWQgcG9zaXRpb25zXG4gICAgICB2YXIgcG9zID0gdGhpcy4kKFwiI1wiICsgdGhpcy5vcHRpb25zLmlkKS5zZWxlY3Rpb24oJ2dldFBvcycpO1xuICAgICAgdmFyIHRleHQgPSB0aGlzLiQoXCIjXCIgKyB0aGlzLm9wdGlvbnMuaWQpLnZhbCgpO1xuICAgICAgLy8gY2hlY2sgaWYgdGhpcyBtb2RpZmllciBoYXMgYWxyZWFkeSBiZWVuIGluc2VydGVkXG4gICAgICB2YXIgb3JpZ0JlZm9yZSA9IHRleHQuc3Vic3RyaW5nKHBvcy5zdGFydC10aGlzLmFjdGlvbnNbZWRpdERhdGFdLmJlZm9yZS5sZW5ndGgscG9zLnN0YXJ0KTtcbiAgICAgIHZhciBvcmlnQWZ0ZXIgPSB0ZXh0LnN1YnN0cmluZyhwb3MuZW5kLHBvcy5lbmQrdGhpcy5hY3Rpb25zW2VkaXREYXRhXS5hZnRlci5sZW5ndGgpO1xuICAgICAgdmFyIGJlZm9yZSA9IHRoaXMuYWN0aW9uc1tlZGl0RGF0YV0uYmVmb3JlO1xuICAgICAgdmFyIGFmdGVyID0gdGhpcy5hY3Rpb25zW2VkaXREYXRhXS5hZnRlcjtcbiAgICAgIC8vIElmIHRoZSBzZWxlY3RlZCB0ZXh0IGFscmVhZHkgaGFzIHRoZSBtYXJrZG93biBzeW50YXggYmVmb3JlIGFuZCBhZnRlclxuICAgICAgLy8gZG9uJ3QgaW5zZXJ0IGl0IGFnYWluLiAgRWcsIGlmIHRleHQgaXMgc2VsZWN0ZWQgaW4gKip0ZXh0KiosIGRvbid0IGFkZCAqKiBhZ2FpblxuICAgICAgaWYgKChvcmlnQmVmb3JlID09IGJlZm9yZSkgJiYgKG9yaWdBZnRlciA9PSBhZnRlcikpIHtcbiAgICAgICAgYmVmb3JlID0gJyc7XG4gICAgICAgIGFmdGVyID0gJyc7XG4gICAgICB9XG4gICAgICAvLyBzZXQgcGxhY2Vob2xkZXIgdGV4dCBpZiBubyB0ZXh0IGlzIHNlbGVjdGVkIGJ5IHRoZSB1c2VyXG4gICAgICBpZiAoc2VsVGV4dCA9PSAnJykge1xuICAgICAgICBzZWxUZXh0ID0gdGhpcy5hY3Rpb25zW2VkaXREYXRhXS50ZXh0O1xuICAgICAgfVxuICAgICAgLy8gaW5zZXJ0IG1hcmtkb3duIHN5bnRheFxuICAgICAgdGhpcy4kKFwiI1wiICsgdGhpcy5vcHRpb25zLmlkKS5zZWxlY3Rpb24oJ2luc2VydCcsIHtcbiAgICAgICAgdGV4dDogYmVmb3JlLFxuICAgICAgICBtb2RlOiAnYmVmb3JlJ1xuICAgICAgfSlcbiAgICAgIC5zZWxlY3Rpb24oJ3JlcGxhY2UnLCB7XG4gICAgICAgIHRleHQ6IHNlbFRleHRcbiAgICAgIH0pXG4gICAgICAuc2VsZWN0aW9uKCdpbnNlcnQnLCB7XG4gICAgICAgIHRleHQ6IGFmdGVyLFxuICAgICAgICBtb2RlOiAnYWZ0ZXInXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGVkaXREYXRhID09ICdoZWxwJykge1xuICAgICAgLy8gc2hvdyBoZWxwIHRleHQgYW5kIGxpbmtzIHRvIG1hcmtkb3duIHN5bnRheFxuICAgICAgaWYgKHRoaXMuJCgnLmhlbHAnKS5pcygnOnZpc2libGUnKSkge1xuICAgICAgICB0aGlzLiQoJy5oZWxwJykuaGlkZSgpO1xuICAgICAgICB0LnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuJCgnLmhlbHAnKS5zaG93KCk7XG4gICAgICAgIHQuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy4kKCcucHJldmlldycpLmlzKCc6dmlzaWJsZScpKSB7XG4gICAgICAgIC8vIGlmIHdlJ3JlIGluIHByZXZpZXcgbW9kZSwgc3dpdGNoIGJhY2sgdG8gZWRpdCBtb2RlXG4gICAgICAgIHRoaXMuJCgnLmJ0bi1lZGl0JykuaGlkZSgpO1xuICAgICAgICB0aGlzLiQoJy5idG4tcHJldmlldycpLnNob3coKTtcbiAgICAgICAgdGhpcy4kKCcucHJldmlldycpLmhpZGUoKTtcbiAgICAgICAgdGhpcy4kKFwiI1wiICsgdGhpcy5vcHRpb25zLmlkKS5zaG93KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZW5kZXIgdGhlIHByZXZpZXcgdXNpbmcgbWFya2VkXG4gICAgICAgIHZhciBodG1sID0gbWFya2VkKHRoaXMuJChcIiNcIiArIHRoaXMub3B0aW9ucy5pZCkudmFsKCkpO1xuICAgICAgICB0aGlzLiQoJy5idG4tcHJldmlldycpLmhpZGUoKTtcbiAgICAgICAgdGhpcy4kKCcuYnRuLWVkaXQnKS5zaG93KCk7XG4gICAgICAgIHRoaXMuJCgnLnByZXZpZXcnKS5odG1sKGh0bWwpO1xuICAgICAgICB0aGlzLiQoXCIjXCIgKyB0aGlzLm9wdGlvbnMuaWQpLmhpZGUoKTtcbiAgICAgICAgdGhpcy4kKCcucHJldmlldycpLnNob3coKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgY2xlYW51cDogZnVuY3Rpb24gKCkge1xuICAgIHJlbW92ZVZpZXcodGhpcyk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFya2Rvd25FZGl0b3I7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwiYnRuLXRvb2xiYXJcXFwiIHJvbGU9XFxcInRvb2xiYXJcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiYnRuLWdyb3VwIGJ0bi1ncm91cC1zbVxcXCI+XFxuICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1jMFxcXCIgZGF0YS1lZGl0PVxcXCJib2xkXFxcIiB0aXRsZT1cXFwiQm9sZFxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLWJvbGRcXFwiIGFsdD1cXFwiQm9sZFxcXCI+PC9pPjwvYnV0dG9uPlxcbiAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tYzBcXFwiIGRhdGEtZWRpdD1cXFwiaXRhbGljXFxcIiB0aXRsZT1cXFwiSXRhbGljXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtaXRhbGljXFxcIiBhbHQ9XFxcIkl0YWxpY1xcXCI+PC9pPjwvYnV0dG9uPlxcbiAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tYzBcXFwiIGRhdGEtZWRpdD1cXFwic3RyaWtldGhyb3VnaFxcXCIgdGl0bGU9XFxcIlN0cmlrZXRocm91Z2hcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1zdHJpa2V0aHJvdWdoXFxcIiBhbHQ9XFxcIlN0cmlrZXRocm91Z2hcXFwiPjwvaT48L2J1dHRvbj5cXG4gICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWMwXFxcIiBkYXRhLWVkaXQ9XFxcImNvZGVcXFwiIHRpdGxlPVxcXCJDb2RlXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtY29kZVxcXCIgYWx0PVxcXCJDb2RlXFxcIj48L2k+PC9idXR0b24+XFxuICA8L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcImJ0bi1ncm91cCBidG4tZ3JvdXAtc21cXFwiPlxcbiAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tYzBcXFwiIGRhdGEtZWRpdD1cXFwibGlua1xcXCIgdGl0bGU9XFxcIkxpbmtcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1saW5rXFxcIiBhbHQ9XFxcIkxpbmtcXFwiPjwvaT48L2J1dHRvbj5cXG4gIDwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwiYnRuLWdyb3VwIGJ0bi1ncm91cC1zbVxcXCI+XFxuICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1jMFxcXCIgZGF0YS1lZGl0PVxcXCJoZWxwXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtcXVlc3Rpb24tY2lyY2xlXFxcIiBhbHQ9XFxcIkhlbHBcXFwiPjwvaT4gSGVscDwvYnV0dG9uPlxcbiAgPC9kaXY+XFxuXFxuICA8ZGl2IGNsYXNzPVxcXCJidG4tZ3JvdXAgYnRuLWdyb3VwLXNtXFxcIj5cXG4gICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWMxIGJ0bi1wcmV2aWV3XFxcIiBkYXRhLWVkaXQ9XFxcInByZXZpZXdcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1leWVcXFwiIGFsdD1cXFwiT3BlblxcXCI+PC9pPiBQcmV2aWV3PC9idXR0b24+XFxuICA8L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcImJ0bi1ncm91cCBidG4tZ3JvdXAtc21cXFwiPlxcbiAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tYzEgYnRuLWVkaXRcXFwiIGRhdGEtZWRpdD1cXFwiZWRpdFxcXCIgc3R5bGU9XFxcImRpc3BsYXk6IG5vbmU7XFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtcGVuY2lsXFxcIiBhbHQ9XFxcIkVkaXRcXFwiPjwvaT4gRWRpdDwvYnV0dG9uPlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwiaGVscFxcXCI+XFxuICBZb3UgY2FuIHVzZSBhbnkgPGEgaHJlZj1cXFwiaHR0cDovL2RhcmluZ2ZpcmViYWxsLm5ldC9wcm9qZWN0cy9tYXJrZG93bi9zeW50YXhcXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIj5NYXJrZG93bjwvYT4gb3IgPGEgaHJlZj1cXFwiaHR0cHM6Ly9oZWxwLmdpdGh1Yi5jb20vYXJ0aWNsZXMvZ2l0aHViLWZsYXZvcmVkLW1hcmtkb3duXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCI+R2l0SHViIEZsYXZvcmVkIE1hcmtkb3duPC9hPiBzeW50YXggaW4gdGhpcyB0ZXh0IGJveC5cXG48L2Rpdj5cXG48dGV4dGFyZWFcXG4gIDwlaWYgKCFfLmlzVW5kZWZpbmVkKG1heGxlbmd0aCkpIHsgJT5tYXhsZW5ndGg9XFxcIjwlPSBtYXhsZW5ndGggJT5cXFwiPCUgfSAlPlxcbiAgPCUgaWYgKCFfLmlzVW5kZWZpbmVkKHJvd3MpKSB7ICU+cm93cz1cXFwiPCU9IHJvd3MgJT5cXFwiPCUgfSAlPlxcbiAgY2xhc3M9XFxcImZvcm0tY29udHJvbCB2YWxpZGF0ZVxcXCJcXG4gIGlkPVxcXCI8JT0gaWQgJT5cXFwiXFxuICBkYXRhLXZhbGlkYXRlPVxcXCI8JSBpZiAoIV8uaXNVbmRlZmluZWQodmFsaWRhdGUpKSB7ICU+PCU9IHZhbGlkYXRlLmpvaW4oJywnKSAlPjwlIH0gJT5cXFwiXFxuICA8JSBpZiAoIV8uaXNVbmRlZmluZWQocGxhY2Vob2xkZXIpKSB7ICU+cGxhY2Vob2xkZXI9XFxcIjwlPSBwbGFjZWhvbGRlciAlPlxcXCI8JSB9ICU+XFxuICA8JSBpZiAoIV8uaXNVbmRlZmluZWQodGl0bGUpKSB7ICU+dGl0bGU9XFxcIjwlPSB0aXRsZSAlPlxcXCI8JSB9ICU+XFxuICA+PCU9IGRhdGEgJT48L3RleHRhcmVhPlxcbjxkaXYgY2xhc3M9XFxcInByZXZpZXdcXFwiIHN0eWxlPVxcXCJkaXNwbGF5OiBub25lO1xcXCI+PC9kaXY+XFxuXCI7XG4iLCIvKipcbiAqIFRoZSBNb2RhbCBjb21wb25lbnQgbmVlZHMgdG8gYmUgc2V0IHRvIHRoZSBlbDogb2YgdGhlIHBhcmVudCB2aWV3XG4gKiB5b3UgYXJlIHRyeWluZyB0byBpbml0IGl0IHdpdGhpbiwgdGhlbiB5b3Ugd2lsbCBiZSBhcHBlbmRpbmcgdGhlIG1vZGFsLXRlbXBsYXRlIHRvIHRoYXRcbiAqIHZpZXcgKHRoaXMpLiAgVGhlbiB0aGUgZm9ybSB2aWV3IGhhcyBhbiBlbCBvZiAkKFwiLm1vZGFsLWJvZHlcIikgc28gdGhhdCB0aGUgZm9ybSB3aWxsIHJlbmRlclxuICogd2l0aGluIHRoYXQgYm9keSBhcmVhLlxuICogVGhlbiBhbGwgeW91IGhhdmUgdG8gZG8gaXMgc2V0IHRoZSBJRCBvZiB0aGUgbW9kYWwgdG8gdGhlIElEIG9mIHRoZSBsaW5rIHlvdSBhcmUgdHJ5aW5nXG4gKiB0byB0cmlnZ2VyIGZyb20gYXMgcGVyIGJvb3RzdHJhcCBCUC5cbiAqL1xuXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgQmFzZUNvbXBvbmVudCA9IHJlcXVpcmUoJy4uL2Jhc2UvYmFzZV9jb21wb25lbnQnKTtcbnZhciBNb2RhbFRlbXBsYXRlID0gcmVxdWlyZSgnLi9tb2RhbF90ZW1wbGF0ZS5odG1sJyk7XG5cblxuTW9kYWwgPSBCYXNlQ29tcG9uZW50LmV4dGVuZCh7XG5cbiAgZXZlbnRzOiB7XG4gICAgXCJjbGljayAubGluay1iYWNrYm9uZVwiICA6IFwibGlua1wiXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhID0ge1xuICAgICAgaWQ6IHRoaXMub3B0aW9ucy5pZCxcbiAgICAgIG1vZGFsVGl0bGU6IHRoaXMub3B0aW9ucy5tb2RhbFRpdGxlLFxuICAgICAgZGlzYWJsZUNsb3NlOiB0aGlzLm9wdGlvbnMuZGlzYWJsZUNsb3NlXG4gICAgfTtcblxuICAgIHZhciBjb21waWxlZFRlbXBsYXRlID0gXy50ZW1wbGF0ZShNb2RhbFRlbXBsYXRlKShkYXRhKTtcbiAgICB0aGlzLiRlbC5hcHBlbmQoY29tcGlsZWRUZW1wbGF0ZSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBsaW5rOiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgLy8gaGlkZSB0aGUgbW9kYWwsIHdhaXQgZm9yIGl0IHRvIGNsb3NlLCB0aGVuIG5hdmlnYXRlXG4gICAgJCgnIycgKyB0aGlzLm9wdGlvbnMuaWQpLmJpbmQoJ2hpZGRlbi5icy5tb2RhbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgbGlua0JhY2tib25lKGUpO1xuICAgIH0pLm1vZGFsKCdoaWRlJyk7XG4gIH0sXG5cbiAgY2xlYW51cDogZnVuY3Rpb24gKCkge1xuICAgIHJlbW92ZVZpZXcodGhpcyk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTW9kYWw7XG4iLCJ2YXIgQm9vdHN0cmFwID0gcmVxdWlyZSgnYm9vdHN0cmFwJyk7XG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgTW9kYWxUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vbW9kYWxfYWxlcnRfdGVtcGxhdGUuaHRtbCcpO1xuXG5cbnZhciBNb2RhbEFsZXJ0ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuXG4gIGV2ZW50czoge1xuICAgIFwic3VibWl0ICNtb2RhbC1mb3JtXCIgICAgOiBcInBvc3RcIlxuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBfLnRlbXBsYXRlKE1vZGFsVGVtcGxhdGUpKHRoaXMub3B0aW9ucyk7XG4gICAgdGhpcy4kZWwuaHRtbCh0ZW1wbGF0ZSk7XG4gICAgdGhpcy4kZWwuaTE4bigpO1xuICAgICQodGhpcy5vcHRpb25zLm1vZGFsRGl2KS5tb2RhbCgnc2hvdycpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHBvc3Q6IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBoYXNFcnJvciA9IGZhbHNlO1xuXG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIC8vY2hlY2sgYW55IC52YWxpZGF0ZSBlbGVtZW50cyBhbmQgZG9uJ3Qgc3VibWl0IGlmIHRoZXkgZmFpbFxuICAgIGlmICggc2VsZi5vcHRpb25zLnZhbGlkYXRlQmVmb3JlU3VibWl0ICl7XG4gICAgICAkKFwiLnZhbGlkYXRlXCIpLmVhY2goZnVuY3Rpb24oaW5kZXgpe1xuICAgICAgICBoYXNFcnJvciA9IHZhbGlkYXRlKHtjdXJyZW50VGFyZ2V0OiB0aGlzfSk7XG4gICAgICAgIGlmICggaGFzRXJyb3IgKXsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoICFoYXNFcnJvciApIHtcbiAgICAgICQodGhpcy5vcHRpb25zLm1vZGFsRGl2KS5iaW5kKCdoaWRkZW4uYnMubW9kYWwnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5vcHRpb25zLmNhbGxiYWNrKGUpO1xuICAgICAgfSkubW9kYWwoJ2hpZGUnKTtcbiAgICB9XG4gIH0sXG5cbiAgY2xlYW51cDogZnVuY3Rpb24gKCkge1xuICAgIHJlbW92ZVZpZXcodGhpcyk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTW9kYWxBbGVydDtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8Zm9ybSByb2xlPVxcXCJmb3JtXFxcIiBhY3Rpb249XFxcIlxcXCIgaWQ9XFxcIm1vZGFsLWZvcm1cXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwibW9kYWwtYm9keVxcXCI+XFxuICAgIDwlPSBjb250ZW50ICU+XFxuICA8L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWZvb3RlclxcXCI+XFxuICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1jMFxcXCIgZGF0YS1kaXNtaXNzPVxcXCJtb2RhbFxcXCI+PCU9IGNhbmNlbCAlPjwvYnV0dG9uPlxcbiAgICA8aW5wdXQgdHlwZT1cXFwic3VibWl0XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1jMlxcXCIgaWQ9XFxcInN1Ym1pdFxcXCIgdmFsdWU9XFxcIjwlPSBzdWJtaXQgJT5cXFwiLz5cXG4gIDwvZGl2PlxcbjwvZm9ybT5cXG5cIjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJtb2RhbCBmYWRlXFxcIlxcbiAgaWQ9XFxcIjwlLSBpZCAlPlxcXCJcXG4gIHJvbGU9XFxcImRpYWxvZ1xcXCJcXG4gIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIlxcbiAgdGFiaW5kZXg9XFxcIi0xXFxcIlxcbiAgPCUgaWYgKGRpc2FibGVDbG9zZSA9PT0gdHJ1ZSkgeyAlPlxcbiAgZGF0YS1iYWNrZHJvcD1cXFwic3RhdGljXFxcIlxcbiAgZGF0YS1rZXlib2FyZD1cXFwiZmFsc2VcXFwiXFxuICA8JSB9ICU+XFxuICA+XFxuICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1kaWFsb2dcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1jb250ZW50XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1oZWFkZXJcXFwiPlxcbiAgICAgICAgPCUgaWYgKGRpc2FibGVDbG9zZSAhPT0gdHJ1ZSkgeyAlPlxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJjbG9zZVxcXCIgZGF0YS1kaXNtaXNzPVxcXCJtb2RhbFxcXCIgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPiZ0aW1lczs8L2J1dHRvbj5cXG4gICAgICAgIDwlIH0gJT5cXG4gICAgICAgIDxoNCBjbGFzcz1cXFwibW9kYWwtdGl0bGVcXFwiPjwlLSBtb2RhbFRpdGxlICU+PC9oND5cXG4gICAgICA8L2Rpdj5cXG5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC10ZW1wbGF0ZVxcXCI+XFxuXFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PjwhLS0gLy5tb2RhbC1jb250ZW50IC0tPlxcbiAgPC9kaXY+PCEtLSAvLm1vZGFsLWRpYWxvZyAtLT5cXG48L2Rpdj48IS0tIC8ubW9kYWwgLS0+XFxuXCI7XG4iLCIvLyBTaW1pbGFyIHRvIE1vZGFsIGNvbXBvbmVudCBpbiBldmVyeSB3YXkgaW4gYWxsIHdheXMgYnV0IHR3bzpcbi8vIDEpIFRoaXMgbW9kYWwgaGFzIGEgbmV4dCBidXR0b24gaW5zdGVhZCBvZiBzYXZlIGJ1dHRvbi5cbi8vIDIpIFRoaXMgbW9kYWwgaGFzIHNvbWUgZXhwZWN0YXRpb25zIGluc2lkZSB0aGUgbW9kYWwtYm9keSBmb3JtLlxuLy8gICAgXiBNb3JlIG9uIHRoaXMgYmVsb3dcbi8vXG4vLyBUaGlzIGlzIGFsbCB0aGUgY29tcG9uZW50IGV4cGVjdHMgZm9yIGl0IHRvIHdvcms6XG4vLyA8ZGl2IGNsYXNzPSdtb2RhbC1ib2R5Jz5cbi8vICA8c2VjdGlvbiBjbGFzcz1cImN1cnJlbnRcIj5GaXJzdCBjb250ZW50IHNlY3Rpb248L3NlY3Rpb24+XG4vLyAgPHNlY3Rpb24+U2Vjb25kIGNvbnRlbnQgc2VjdGlvbjwvc2VjdGlvbj5cbi8vICA8c2VjdGlvbj5UaGlyZCBjb250ZW50IHNlY3Rpb248L3NlY3Rpb24+XG4vLyAgPCEtLSBhbmQgc28gb24gLS0+XG4vLyA8L2Rpdj5cbi8vXG4vLyBSRU1FTUJFUjogVGhpcyBnb2VzIGluc2lkZSB5b3VyIGZvcm1UZW1wbGF0ZS4gIFRoaXNcbi8vIGlzIHRoZSBNb2RhbFdpemFyZENvbXBvbmVudCwgd2hpY2ggaXMgc2NvcGVkIHRvIGxpc3QgY29udHJvbGxlcixcbi8vIHRoZW4gdGhlIEZvcm0gaXRzZWxmIGZvciB0aGUgYWRkaXRpb24gdG8gdGhlIGxpc3QgaXMgc2NvcGVkIHRvIHRoZVxuLy8gbW9kYWwtYm9keSB3aXRoaW4gdGhpcyBtb2RhbC1jb21wb25lbnQgdGVtcGxhdGUuXG5cbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciB1dGlsaXRpZXMgPSByZXF1aXJlKCcuLi9taXhpbnMvdXRpbGl0aWVzJyk7XG52YXIgQmFzZVZpZXcgPSByZXF1aXJlKCcuLi9iYXNlL2Jhc2VfdmlldycpO1xudmFyIE1vZGFsV2l6YXJkVGVtcGxhdGUgPSByZXF1aXJlKCcuL21vZGFsX3dpemFyZF90ZW1wbGF0ZS5odG1sJyk7XG5cblxuTW9kYWxXaXphcmQgPSBCYXNlVmlldy5leHRlbmQoe1xuXG4gIGV2ZW50czoge1xuICAgIFwiY2xpY2sgLndpemFyZC1mb3J3YXJkXCIgOiBcIm1vdmVXaXphcmRGb3J3YXJkXCIsXG4gICAgXCJjbGljayAud2l6YXJkLWJhY2t3YXJkXCI6IFwibW92ZVdpemFyZEJhY2t3YXJkXCIsXG4gICAgXCJjbGljayAud2l6YXJkLXN1Ym1pdFwiICA6IFwic3VibWl0XCIsXG4gICAgXCJjbGljayAud2l6YXJkLWNhbmNlbFwiICA6IFwiY2FuY2VsXCJcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5pbml0aWFsaXplTGlzdGVuZXJzKCk7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZUxpc3RlbmVyczogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAodGhpcy5tb2RlbCkge1xuICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCB0aGlzLm9wdGlvbnMubW9kZWxOYW1lICsgJzptb2RhbDpoaWRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAkKCcubW9kYWwuaW4nKS5tb2RhbCgnaGlkZScpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhID0ge1xuICAgICAgaWQ6IHRoaXMub3B0aW9ucy5pZCxcbiAgICAgIG1vZGFsVGl0bGU6IHRoaXMub3B0aW9ucy5tb2RhbFRpdGxlLFxuICAgICAgZHJhZnQ6IHRoaXMub3B0aW9ucy5kcmFmdFxuICAgIH07XG4gICAgdmFyIGNvbXBpbGVkVGVtcGxhdGUgPSBfLnRlbXBsYXRlKE1vZGFsV2l6YXJkVGVtcGxhdGUpKGRhdGEpO1xuICAgIHRoaXMuJGVsLmh0bWwoY29tcGlsZWRUZW1wbGF0ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY2hpbGQgb2YgdGhpcyB2aWV3LCBzbyB3ZSBjYW4gcmVtb3ZlIGl0XG4gICAqIHdoZW4gdGhlIHZpZXcgaXMgZGVzdHJveWVkXG4gICAqIEByZXR1cm4gdGhpcyBmb3IgY2hhaW5pbmdcbiAgICovXG4gIHNldENoaWxkVmlldzogZnVuY3Rpb24gKHZpZXcpIHtcbiAgICB0aGlzLmNoaWxkVmlldyA9IHZpZXc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY2FsbGJhY2sgb24gdGhlIG5leHQgYnV0dG9uIG9mIHRoZSBtb2RhbC5cbiAgICogVXNlZnVsIGZvciBjYWxsYmFja3NcbiAgICogQHJldHVybiB0aGlzIGZvciBjaGFpbmluZ1xuICAgKi9cbiAgc2V0TmV4dDogZnVuY3Rpb24gKGZuKSB7XG4gICAgdGhpcy5jaGlsZE5leHQgPSBmbjtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogU2V0IHRoZSBjYWxsYmFjayBvbiB0aGUgc3VibWl0IGJ1dHRvbiBvZiB0aGUgbW9kYWwuXG4gICAqIFVzZWZ1bCBmb3IgY2FsbGJhY2tzXG4gICAqIEByZXR1cm4gdGhpcyBmb3IgY2hhaW5pbmdcbiAgICovXG4gIHNldFN1Ym1pdDogZnVuY3Rpb24gKGZuKSB7XG4gICAgdGhpcy5jaGlsZFN1Ym1pdCA9IGZuO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8vIEluIG9yZGVyIGZvciB0aGUgTW9kYWxXaXphcmQgdG8gd29yayBpdCBleHBlY3RzIGEgc2VjdGlvblxuICAvLyBieSBzZWN0aW9uIGxheW91dCBpbnNpZGUgdGhlIG1vZGFsLCB3aXRoIGEgJ2N1cnJlbnQnIGNsYXNzIG9uXG4gIC8vIHRoZSBmaXJzdCB5b3Ugd2FudCB0byBhbHdheXMgc3RhcnQgb24gKHJlKXJlbmRlci5cbiAgbW92ZVdpemFyZEZvcndhcmQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBTdG9yZSAkKFwiLmN1cnJlbnRcIikgaW4gY2FjaGUgdG8gcmVkdWNlIHF1ZXJ5IHRpbWVzIGZvciBET00gbG9va3VwXG4gICAgLy8gb24gZnV0dXJlIGNoaWxkcmVuIGFuZCBhZGphY2VudCBlbGVtZW50IHRvIHRoZSBjdXJyZW50IGVsLlxuICAgIHZhciBjdXJyZW50ICAgPSAkKFwiLmN1cnJlbnRcIiksXG4gICAgICAgIG5leHQgICAgICA9IGN1cnJlbnQubmV4dCgpLFxuICAgICAgICBuZXh0SHRtbCAgPSBuZXh0Lmh0bWwoKTtcblxuICAgIC8vIE5vdGlmeSB0aGUgc3ViLXZpZXcgdG8gc2VlIGlmIGl0IGlzIHNhZmUgdG8gcHJvY2VlZFxuICAgIC8vIGlmIG5vdCwgcmV0dXJuIGFuZCBzdG9wIHByb2Nlc3NpbmcuXG4gICAgdmFyIGFib3J0ID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuY2hpbGROZXh0KSB7XG4gICAgICBhYm9ydCA9IHRoaXMuY2hpbGROZXh0KGUsIGN1cnJlbnQpO1xuICAgIH1cbiAgICBpZiAoYWJvcnQgPT09IHRydWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dFdpemFyZFN0ZXAgPSB7XG4gICAgICBleGlzdHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICFfLmlzVW5kZWZpbmVkKG5leHQubmV4dCgpLmh0bWwoKSk7XG4gICAgICB9LFxuICAgICAgZG9lc05vdEV4aXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG5leHQubmV4dCgpLmh0bWwoKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGhpZGVDdXJyZW50QW5kSW5pdGlhbGl6ZU5leHRXaXphcmRTdGVwKCk7XG4gICAgaWYgKG5leHRXaXphcmRTdGVwLmRvZXNOb3RFeGlzdCgpKSB7XG4gICAgICAkKFwiYnV0dG9uLndpemFyZC1mb3J3YXJkXCIpLmhpZGUoKTtcbiAgICAgICQoXCJidXR0b24ud2l6YXJkLXN1Ym1pdFwiKS5zaG93KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGlkZUN1cnJlbnRBbmRJbml0aWFsaXplTmV4dFdpemFyZFN0ZXAgKCkge1xuICAgICAgY3VycmVudC5oaWRlKCk7XG4gICAgICBjdXJyZW50LnJlbW92ZUNsYXNzKFwiY3VycmVudFwiKTtcbiAgICAgIG5leHQuYWRkQ2xhc3MoXCJjdXJyZW50XCIpO1xuICAgICAgbmV4dC5zaG93KCk7XG4gICAgfTtcbiAgfSxcblxuICBtb3ZlV2l6YXJkQmFja3dhcmQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIHZhciBjdXJyZW50ICAgPSAkKFwiLmN1cnJlbnRcIiksXG4gICAgICAgIHByZXYgICAgICA9IGN1cnJlbnQucHJldigpLFxuICAgICAgICBwcmV2SHRtbCAgPSBwcmV2Lmh0bWwoKTtcblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwcmV2SHRtbCkpIHtcbiAgICAgIGN1cnJlbnQuaGlkZSgpO1xuICAgICAgY3VycmVudC5yZW1vdmVDbGFzcyhcImN1cnJlbnRcIik7XG4gICAgICBwcmV2LmFkZENsYXNzKFwiY3VycmVudFwiKTtcbiAgICAgIHByZXYuc2hvdygpO1xuICAgICAgJChcImJ1dHRvbi53aXphcmQtZm9yd2FyZFwiKS5zaG93KCk7XG4gICAgICAkKFwiYnV0dG9uLndpemFyZC1zdWJtaXRcIikuaGlkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9LFxuXG4gIC8vIER1bWIgc3VibWl0LiAgRXZlcnl0aGluZyBpcyBleHBlY3RlZCB2aWEgYSBwcm9taXNlIGZyb21cbiAgLy8gZnJvbSB0aGUgaW5zdGFudGlhdGlvbiBvZiB0aGlzIG1vZGFsIHdpemFyZC5cbiAgc3VibWl0OiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICB2YXIgZCA9IHRoaXMub3B0aW9ucy5kYXRhKHRoaXMpO1xuICAgIHZhciBhYm9ydCA9IGZhbHNlO1xuICAgIHZhciBzdGF0ZSA9ICQoZS5jdXJyZW50VGFyZ2V0KS5kYXRhKCdzdGF0ZScpO1xuXG4gICAgLy8gcGFzcyB0aGUgZGF0YSB0byB0aGUgdmlld1xuICAgIGlmICh0aGlzLmNoaWxkU3VibWl0KSB7XG4gICAgICAvLyBpZiBzdWJtaXQgcmV0dXJucyB0cnVlLCBhYm9ydCBtb2RhbCBwcm9jZXNzaW5nXG4gICAgICBhYm9ydCA9IHRoaXMuY2hpbGRTdWJtaXQoZSwgdGhpcy4kKFwiLmN1cnJlbnRcIikpO1xuICAgIH1cblxuICAgIGlmIChhYm9ydCA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgICQoJy5tb2RhbC5pbicpLm1vZGFsKCdoaWRlJyk7XG4gICAgaWYgKHN0YXRlKSBkLnN0YXRlID0gc3RhdGU7XG4gICAgdGhpcy5jb2xsZWN0aW9uLnRyaWdnZXIodGhpcy5vcHRpb25zLm1vZGVsTmFtZSArIFwiOnNhdmVcIiwgZCk7XG4gIH0sXG5cbiAgY2FuY2VsOiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgJCgnLm1vZGFsLmluJykubW9kYWwoJ2hpZGUnKTtcbiAgfSxcblxuICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuY2hpbGRWaWV3KSB7IHRoaXMuY2hpbGRWaWV3LmNsZWFudXAoKTsgfVxuICAgIHJlbW92ZVZpZXcodGhpcyk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vZGFsV2l6YXJkO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcIm1vZGFsIGZhZGVcXFwiIGlkPVxcXCI8JS0gaWQgJT5cXFwiIHJvbGU9XFxcImRpYWxvZ1xcXCIgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1kaWFsb2dcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1jb250ZW50XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1oZWFkZXJcXFwiPlxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJjbG9zZVxcXCIgZGF0YS1kaXNtaXNzPVxcXCJtb2RhbFxcXCIgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPiZ0aW1lczs8L2J1dHRvbj5cXG4gICAgICAgIDxoNCBjbGFzcz1cXFwibW9kYWwtdGl0bGVcXFwiPjwlLSBtb2RhbFRpdGxlICU+PC9oND5cXG4gICAgICA8L2Rpdj5cXG5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1ib2R5XFxcIj5cXG5cXG4gICAgICA8L2Rpdj5cXG5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1mb290ZXJcXFwiPlxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWMwIHdpemFyZC1jYW5jZWxcXFwiIGRhdGEtZGlzbWlzcz1cXFwibW9kYWxcXFwiPkNhbmNlbDwvYnV0dG9uPlxcbiAgICAgICAgPCUgaWYgKGRyYWZ0KSB7ICU+PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWMwIHdpemFyZC1zdWJtaXRcXFwiIGRhdGEtc3RhdGU9XFxcImRyYWZ0XFxcIj5TYXZlIERyYWZ0PC9idXR0b24+PCUgfSAlPlxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWMyIHdpemFyZC1iYWNrd2FyZFxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLWNoZXZyb24tbGVmdFxcXCI+PC9pPiBCYWNrPC9idXR0b24+XFxuICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tYzIgd2l6YXJkLWZvcndhcmRcXFwiPk5leHQgPGkgY2xhc3M9XFxcImZhIGZhLWNoZXZyb24tcmlnaHRcXFwiPjwvaT48L2J1dHRvbj5cXG4gICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1jMiB3aXphcmQtc3VibWl0XFxcIiBzdHlsZT1cXFwiZGlzcGxheTogbm9uZTtcXFwiPkNyZWF0ZTwvYnV0dG9uPlxcbiAgICAgIDwvZGl2PlxcblxcbiAgICA8L2Rpdj48IS0tIC8ubW9kYWwtY29udGVudCAtLT5cXG4gIDwvZGl2PjwhLS0gLy5tb2RhbC1kaWFsb2cgLS0+XFxuPC9kaXY+XFxuXCI7XG4iLCIvKipcbiAqIFRoaXMgY29tcG9uZW50IGltcGxlbWVudHMgYSB0YWcgd2lkZ2V0LCBhbGxvd2luZyBjcmVhdGlvbiBsb29rdXAgYW5kIGRlbGV0aW9uIG9mIHRhZ3MgZnJvbSBhIGNvbW1vbiB1aSBlbGVtZW50XG4gKlxuICogT3B0aW9uczpcbiAqXG4gKi9cblxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIGFzeW5jID0gcmVxdWlyZSgnYXN5bmMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL21peGlucy91dGlsaXRpZXMnKTtcbnZhciBtYXJrZWQgPSByZXF1aXJlKCdtYXJrZWQnKTtcbnZhciBCYXNlQ29tcG9uZW50ID0gcmVxdWlyZSgnLi4vYmFzZS9iYXNlX2NvbXBvbmVudCcpO1xudmFyIGpxU2VsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdmVuZG9yL2pxdWVyeS5zZWxlY3Rpb24nKTtcblxuXG5UYWdGYWN0b3J5ID0gQmFzZUNvbXBvbmVudC5leHRlbmQoe1xuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGFkZFRhZ0VudGl0aWVzOiBmdW5jdGlvbiAodGFnLCBjb250ZXh0LCBkb25lKSB7XG4gIFx0Ly9hc3N1bWVzXG4gIFx0Ly8gIHRhZyAtLSBhcnJheSBvZiB0YWcgb2JqZWN0cyB0byBhZGRcbiAgXHQvLyAgdGFnVHlwZSAtLSBzdHJpbmcgc3BlY2lmeWluZyB0eXBlIGZvciB0YWdFbnRpdHkgdGFibGVcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgXHQvL3RoaXMgaXMgY3VycmVudCBzb2x1dGlvbiB0byBtYXJrIGEgdGFnIG9iamVjdCBhcyBvbiB0aGUgZmx5IGFkZGVkXG4gICAgICBpZiAoICF0YWcgfHwgdHlwZW9mIHRhZy51bm1hdGNoZWQgPT0gJ3VuZGVmaW5lZCcgfHwgIXRhZy51bm1hdGNoZWQgKXtcbiAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICAgIH1cbiAgICAvL3JlbW92ZSB0aGUgZmxhZyB0aGF0IG1hcmtzIHRoZW0gYXMgbmV3XG4gICAgZGVsZXRlIHRhZy51bm1hdGNoZWQ7XG5cbiAgICAkLmFqYXgoe1xuICAgICAgdXJsOiAnL2FwaS90YWdFbnRpdHknLFxuICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgZGF0YToge1xuICAgICAgICB0eXBlOiB0YWcudGFnVHlwZSxcbiAgICAgICAgbmFtZTogdGFnLmlkLFxuICAgICAgICBkYXRhOiB0YWcuZGF0YVxuICAgICAgfSxcbiAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChkYXRhKXtcbiAgICAgICAgaWYgKGNvbnRleHQuZGF0YSkge1xuICAgICAgICAgIGNvbnRleHQuZGF0YS5uZXdUYWcgPSBkYXRhO1xuICAgICAgICAgIGNvbnRleHQuZGF0YS5uZXdJdGVtVGFncy5wdXNoKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb25lKG51bGwsIGRhdGEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIHJlbW92ZVRhZzogZnVuY3Rpb24gKGlkLCBkb25lKSB7XG4gICAgJC5hamF4KHtcbiAgICAgIHVybDogJy9hcGkvdGFnLycgKyBpZCxcbiAgICAgIHR5cGU6ICdERUxFVEUnLFxuICAgICAgc3VjY2VzczogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBhZGRUYWc6IGZ1bmN0aW9uICh0YWcsIG1vZGVsSWQsIG1vZGVsVHlwZSwgZG9uZSkge1xuICBcdC8vYXNzdW1lc1xuICBcdC8vICB0YWcgLS0gYXJyYXkgb2YgdGFnIG9iamVjdHMgdG8gYWRkXG4gIFx0Ly8gIC0tLSBOWUkgLS0tXG4gIFx0Ly8gIHByb2plY3Qgb3IgdGFzayBpZCAtIHN0cmluZ1xuICAgIC8vIFRPRE86IGFic3RyYWN0IHRoZSBiZWxvdyBpZi1lbHNlIHRvIGEgZGlmZmVyZW50IGZ1bmN0aW9uIHNvIHRoaXMgZnVuY2l0b24ganVzdCB0YWtlcyBhbiBhcnJheSB0YWcgaWRzXG5cbiAgICB2YXIgdGFnTWFwID0ge307XG4gICAgdGFnTWFwW21vZGVsVHlwZV0gPSBtb2RlbElkO1xuXG4gICAgaWYgKCBfLmlzRmluaXRlKHRhZykgKXtcbiAgICAgICAgLy8gLS0tIE5ZSSAtLS1cbiAgICAgICAgLy8gb3IgcHJvamVjdCBpZFxuXG4gICAgICAgIHRhZ01hcC50YWdJZCA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyAtLS0gTllJIC0tLVxuICAgICAgICAvLyBvciBwcm9qZWN0IGlkXG5cbiAgICAgICAgdGFnTWFwLnRhZ0lkID0gdGFnLmlkO1xuICAgIH1cblxuICAgICQuYWpheCh7XG4gICAgICB1cmw6ICcvYXBpL3RhZycsXG4gICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICBkYXRhOiB0YWdNYXAsXG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgfSxcbiAgICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBkb25lKGVycik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgfSxcblxuICBjcmVhdGVUYWdEcm9wRG93bjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBzZXR0aW5ncyA9IHtcbiAgICAgICAgICBwbGFjZWhvbGRlcjogXCJTdGFydCB0eXBpbmcgdG8gc2VsZWN0IGEgXCIrb3B0aW9ucy50eXBlLFxuICAgICAgICAgIG1pbmltdW1JbnB1dExlbmd0aDogMixcbiAgICAgICAgICBtdWx0aXBsZTogdHJ1ZSxcbiAgICAgICAgICB3aWR0aDogb3B0aW9ucy53aWR0aCB8fCBcIjUwMHB4XCIsXG4gICAgICAgICAgdG9rZW5TZXBhcmF0b3JzOiBvcHRpb25zLnRva2VuU2VwYXJhdG9ycyB8fCBbXSxcbiAgICAgICAgICBmb3JtYXRSZXN1bHQ6IGZ1bmN0aW9uIChvYmosIGNvbnRhaW5lciwgcXVlcnkpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmoubmFtZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZvcm1hdFNlbGVjdGlvbjogZnVuY3Rpb24gKG9iaiwgY29udGFpbmVyLCBxdWVyeSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iai5uYW1lO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY3JlYXRlU2VhcmNoQ2hvaWNlOiBmdW5jdGlvbiAodGVybSkge1xuICAgICAgICAgICAgLy91bm1hdGNoZWQgPSB0cnVlIGlzIHRoZSBmbGFnIGZvciBzYXZpbmcgdGhlc2UgXCJuZXdcIiB0YWdzIHRvIHRhZ0VudGl0eSB3aGVuIHRoZSBvcHAgaXMgc2F2ZWRcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHVubWF0Y2hlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdGFnVHlwZTogb3B0aW9ucy50eXBlLFxuICAgICAgICAgICAgICBpZDogdGVybSxcbiAgICAgICAgICAgICAgdmFsdWU6IHRlcm0sXG4gICAgICAgICAgICAgIHRlbXA6IHRydWUsXG4gICAgICAgICAgICAgIG5hbWU6IFwiPGI+XCIrdGVybStcIjwvYj4gPGk+XCIgKyAoKG9wdGlvbnMudHlwZSAhPT0gJ2xvY2F0aW9uJykgP1xuICAgICAgICAgICAgICAgIFwiY2xpY2sgdG8gY3JlYXRlIGEgbmV3IHRhZyB3aXRoIHRoaXMgdmFsdWVcIiA6XG4gICAgICAgICAgICAgICAgXCJzZWFyY2ggZm9yIHRoaXMgbG9jYXRpb25cIikgKyBcIjwvaT5cIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFqYXg6IHtcbiAgICAgICAgICAgIHVybDogJy9hcGkvYWMvdGFnJyxcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgICAgICBkYXRhOiBmdW5jdGlvbiAodGVybSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IG9wdGlvbnMudHlwZSxcbiAgICAgICAgICAgICAgICBxOiB0ZXJtXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzdWx0czogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0czogZGF0YSB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgJHNlbCA9IHNlbGYuJChvcHRpb25zLnNlbGVjdG9yKTtcbiAgICAkc2VsLnJlbW90ZSA9IHRydWU7XG4gICAgJHNlbC5zZWxlY3QyKHNldHRpbmdzKS5vbihcInNlbGVjdDItc2VsZWN0aW5nXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZS5jaG9pY2UudGFnVHlwZSA9PT0gJ2xvY2F0aW9uJykge1xuICAgICAgICB2YXIgJGVsID0gc2VsZi4kKGUuY3VycmVudFRhcmdldCk7XG4gICAgICAgIGlmIChlLmNob2ljZS50ZW1wKSB7XG4gICAgICAgICAgZS5jaG9pY2UubmFtZSA9ICc8ZW0+U2VhcmNoaW5nIGZvciA8c3Ryb25nPicgK1xuICAgICAgICAgICAgZS5jaG9pY2UudmFsdWUgKyAnPC9zdHJvbmc+PC9lbT4nO1xuICAgICAgICAgIHRoaXMudGVtcCA9IHRydWU7XG4gICAgICAgICAgJC5nZXQoJy9hcGkvbG9jYXRpb24vc3VnZ2VzdD9xPScgKyBlLmNob2ljZS52YWx1ZSwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgZCA9IF8oZCkubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpZDogaXRlbS5uYW1lLFxuICAgICAgICAgICAgICAgIG5hbWU6IGl0ZW0ubmFtZSxcbiAgICAgICAgICAgICAgICB1bm1hdGNoZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgdGFnVHlwZTogJ2xvY2F0aW9uJyxcbiAgICAgICAgICAgICAgICBkYXRhOiBfKGl0ZW0pLm9taXQoJ25hbWUnKVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSAkc2VsLnNlbGVjdDIoJ2RhdGEnKTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUgPSBfLnJlamVjdChpdGVtcywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICByZXR1cm4gKGl0ZW0ubmFtZS5pbmRleE9mKCc8ZW0+U2VhcmNoaW5nIGZvciA8c3Ryb25nPicpID49IDApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkc2VsLnNlbGVjdDIoe1xuICAgICAgICAgICAgICBtdWx0aXBsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgZGF0YTogeyByZXN1bHRzOiBkLCB0ZXh0OiAnbmFtZScgfVxuICAgICAgICAgICAgfSkuc2VsZWN0MignZGF0YScsIHRoaXMuY2FjaGUpLnNlbGVjdDIoJ29wZW4nKTtcbiAgICAgICAgICAgICRzZWwucmVtb3RlID0gZmFsc2U7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZWxvYWQgPSB0cnVlO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnRlbXA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICggZS5jaG9pY2UuaGFzT3duUHJvcGVydHkoXCJ1bm1hdGNoZWRcIikgJiYgZS5jaG9pY2UudW5tYXRjaGVkICl7XG4gICAgICAgICAgLy9yZW1vdmUgdGhlIGhpbnQgYmVmb3JlIGFkZGluZyBpdCB0byB0aGUgbGlzdFxuICAgICAgICAgIGUuY2hvaWNlLm5hbWUgPSBlLnZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLm9uKCdzZWxlY3QyLWJsdXInLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoIXRoaXMucmVsb2FkICYmIHRoaXMudGVtcCkge1xuICAgICAgICB0aGlzLnJlbG9hZCA9IHRydWU7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnRlbXA7XG4gICAgICB9XG4gICAgfSkub24oJ3NlbGVjdDItb3BlbicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBlbCA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5yZWxvYWQpIHtcbiAgICAgICAgdGhpcy5jYWNoZSA9ICRzZWwuc2VsZWN0MignZGF0YScpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgJHNlbC5zZWxlY3QyKHNldHRpbmdzKS5zZWxlY3QyKCdkYXRhJywgZWwuY2FjaGUpLnNlbGVjdDIoJ29wZW4nKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnJlbG9hZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBjcmVhdGVEaWZmOiBmdW5jdGlvbiAoIG9sZFRhZ3MsIGN1cnJlbnRUYWdzKXtcbiAgICAvL3NvcnQgdGFncyBpbnRvIHRoZWlyIG5lZWRlZCBhY3Rpb25zXG4gICAgLy9cblxuICAgIHZhciBvdXQgPSB7XG4gICAgICByZW1vdmU6IFtdLFxuICAgICAgYWRkOiBbXSxcbiAgICAgIG5vbmU6IFtdXG4gICAgfTtcblxuICAgIHZhciBub25lID0gbnVsbDtcblxuICAgIF8uZWFjaChvbGRUYWdzLCBmdW5jdGlvbiAob1RhZyxvaSl7XG5cbiAgICAgIG5vbmUgPSBudWxsO1xuXG4gICAgICBfLmVhY2goY3VycmVudFRhZ3MsIGZ1bmN0aW9uIChjVGFnLCBjaSl7XG4gICAgICAgICAgaWYgKGNUYWcgJiYgcGFyc2VJbnQoY1RhZy5pZCkgPT0gb1RhZy50YWdJZCApe1xuICAgICAgICAgICAgY3VycmVudFRhZ3Muc3BsaWNlKGNpLDEpO1xuICAgICAgICAgICAgbm9uZSA9IG9pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgIGlmKCBfLmlzRmluaXRlKG5vbmUpICl7XG4gICAgICAgIG91dC5ub25lLnB1c2gocGFyc2VJbnQob2xkVGFnc1tub25lXS50YWdJZCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0LnJlbW92ZS5wdXNoKHBhcnNlSW50KG9UYWcuaWQpKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIG91dC5hZGQgPSBjdXJyZW50VGFncztcblxuICAgIHJldHVybiBvdXQ7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVGFnRmFjdG9yeTtcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJyZXNHZXRQYXRoXCIgICAgICA6IFwiL2xvY2FsZXMvX19sbmdfXy9fX25zX18uanNvblwiLFxuXG4gIFwibG5nXCIgICAgICAgICAgICAgOiBcImVuLVVTXCIsXG5cbiAgXCJmYWxsYmFja0xuZ1wiICAgICA6IFwiZW5cIixcblxuICBcInVzZUxvY2FsU3RvcmFnZVwiIDogZmFsc2UsXG5cbiAgXCJzZW5kTWlzc2luZ1wiICAgICA6IGZhbHNlLFxuICBcInNlbmRNaXNzaW5nVG9cIiAgIDogXCJjdXJyZW50XCJcbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJzaWduaW5cIjogdHJ1ZSxcbiAgXCJvYXV0aFwiOiBbXG4gICAgXCJsaW5rZWRpblwiLFxuICAgIFwibXl1c2FcIlxuICBdLFxuICBcImNvbmZpZ1wiOiB7XG4gICAgXCJsaW5rZWRpblwiOiB7XG4gICAgICBcIm5hbWVcIjogXCJMaW5rZWRJblwiLFxuICAgICAgXCJpbWFnZVwiOiBcIi9pbWFnZXMvbG9naW4vbGlua2VkaW4ucG5nXCIsXG4gICAgICBcImVuZHBvaW50XCI6IFwiL2FwaS9hdXRoL29hdXRoL2xpbmtlZGluXCIsXG4gICAgICBcInBhcmFtc1wiOiB7XCJzY29wZVwiOiBbXCJyX2Jhc2ljcHJvZmlsZVwiLCBcInJfZnVsbHByb2ZpbGVcIiwgXCJyX2VtYWlsYWRkcmVzc1wiLCBcInJfbmV0d29ya1wiXX1cbiAgICB9LFxuICAgIFwibXl1c2FcIjoge1xuICAgICAgXCJuYW1lXCI6IFwiTXlVU0FcIixcbiAgICAgIFwiaW1hZ2VcIjogXCIvaW1hZ2VzL2xvZ2luL215dXNhLnBuZ1wiLFxuICAgICAgXCJlbmRwb2ludFwiOiBcIi9hcGkvYXV0aC9vYXV0aC9teXVzYVwiLFxuICAgICAgXCJwYXJhbXNcIjogeyBcInNjb3BlXCI6IFtcInByb2ZpbGUuZW1haWxcIiwgXCJwcm9maWxlLmZpcnN0X25hbWVcIiwgXCJwcm9maWxlLmxhc3RfbmFtZVwiXSB9XG4gICAgfVxuICB9LFxuICBcImxvY2FsXCI6IHtcbiAgICBcImVuYWJsZWRcIjogdHJ1ZSxcbiAgICBcImV4cGFuZFwiOiB0cnVlLFxuICAgIFwibG9nb3V0XCI6IHRydWVcbiAgfSxcbiAgXCJ0ZXJtc1wiOiB7XG4gICAgXCJlbmFibGVkXCI6IGZhbHNlLFxuICAgIFwibmFtZVwiOiBcIlRlcm1zIGFuZCBDb25kaXRpb25zXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly8xOGYuZ3NhLmdvdi9cIlxuICB9LFxuICBcInByb2ZpbGVcIjoge1xuICAgIFwiZWRpdFwiOiB0cnVlLFxuICAgIFwiZWRpdFVybFwiOiBudWxsXG4gIH1cbn1cbiIsIi8qKlxuICogVGhpcyBpcyBhIGNvbmZpZ3VyYXRpb24gZmlsZSB0aGF0IGRlZmluZXMgdGhlIHN0YW5kYXJkXG4gKiB0YWdzIGZvciB0aGlzIGluc3RhbGxhdGlvbi4gIFRoZSB0YWdzIHdpbGwgYmUgZGlzcGxheWVkXG4gKiBpbiB0aGUgb3JkZXIgb2YgdGhlIGFycmF5LlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gVGhpcyBkZWZpbmVzIGFsbCBvZiB0aGUgdGFnIGVsZW1lbnRzIGZvciB1c2UgaW4gdGhlIGFwcFxuICB0YWdzOiB7XG4gICAgJ3NraWxsJzoge1xuICAgICAgJ2ljb24nOiAnaWNvbi1hdG9tJyxcbiAgICAgICdjbGFzcyc6ICdza2lsbCcsXG4gICAgICAnaWQnOiAnc2tpbGwnLFxuICAgICAgJ3R5cGUnOiAnc2tpbGwnLFxuICAgICAgJ25hbWUnOiAnU2tpbGwnLFxuICAgICAgJ3BsdXJhbCc6ICdTa2lsbHMnXG4gICAgfSxcblxuICAgICd0b3BpYyc6IHtcbiAgICAgICdpY29uJzogJ2ZhIGZhLWJyaWVmY2FzZScsXG4gICAgICAnY2xhc3MnOiAndG9waWMnLFxuICAgICAgJ2lkJzogJ3RvcGljJyxcbiAgICAgICd0eXBlJzogJ3RvcGljJyxcbiAgICAgICduYW1lJzogJ1RvcGljJyxcbiAgICAgICdwbHVyYWwnOiAnVG9waWNzJ1xuICAgIH0sXG5cbiAgICAnYWdlbmN5Jzoge1xuICAgICAgJ2ljb24nOiAnaWNvbi1saWJyYXJ5JyxcbiAgICAgICdjbGFzcyc6ICdhZ2VuY3knLFxuICAgICAgJ2lkJzogJ2FnZW5jeScsXG4gICAgICAndHlwZSc6ICdhZ2VuY3knLFxuICAgICAgJ25hbWUnOiAnQWdlbmN5JyxcbiAgICAgICdwbHVyYWwnOiAnQWdlbmNpZXMnXG4gICAgfSxcblxuICAgICdsb2NhdGlvbic6IHtcbiAgICAgICdpY29uJzogJ2ZhIGZhLW1hcC1tYXJrZXInLFxuICAgICAgJ2NsYXNzJzogJ2xvY2F0aW9uJyxcbiAgICAgICdpZCc6ICdsb2NhdGlvbicsXG4gICAgICAndHlwZSc6ICdsb2NhdGlvbicsXG4gICAgICAnbmFtZSc6ICdXb3JrIExvY2F0aW9uJyxcbiAgICAgICdwbHVyYWwnOiAnV29yayBMb2NhdGlvbnMnXG4gICAgfSxcblxuICAgIC8vIC0tLVxuICAgIC8vIFRhc2stc3BlY2lmaWMgdGFnc1xuICAgIC8vIC0tLVxuICAgICd0YXNrLXNraWxscy1yZXF1aXJlZCc6IHtcbiAgICAgICdpY29uJzogJ2ZhIGZhLW1hcC1tYXJrZXInLFxuICAgICAgJ2NsYXNzJzogJ3Rhc2stc2tpbGxzLXJlcXVpcmVkJyxcbiAgICAgICdpZCc6ICd0YXNrLXNraWxscy1yZXF1aXJlZCcsXG4gICAgICAndHlwZSc6ICd0YXNrLXNraWxscy1yZXF1aXJlZCcsXG4gICAgICAnbmFtZSc6ICdTa2lsbCBSZXF1aXJlZCcsXG4gICAgICAncGx1cmFsJzogJ1NraWxscyBSZXF1aXJlZCdcbiAgICB9LFxuXG4gICAgJ3Rhc2stdGltZS1yZXF1aXJlZCc6IHtcbiAgICAgICdpY29uJzogJ2ZhIGZhLWNhbGVuZGFyLW8nLFxuICAgICAgJ2NsYXNzJzogJ3Rhc2stdGltZS1yZXF1aXJlZCcsXG4gICAgICAnaWQnOiAndGFzay10aW1lLXJlcXVpcmVkJyxcbiAgICAgICd0eXBlJzogJ3Rhc2stdGltZS1yZXF1aXJlZCcsXG4gICAgICAnbmFtZSc6ICdUaW1lIENvbW1pdG1lbnQnLFxuICAgICAgJ3BsdXJhbCc6ICdUaW1lIENvbW1pdG1lbnQnXG4gICAgfSxcblxuICAgICd0YXNrLXBlb3BsZSc6IHtcbiAgICAgICdpY29uJzogJ2ZhIGZhLWdyb3VwJyxcbiAgICAgICdjbGFzcyc6ICd0YXNrLXBlb3BsZScsXG4gICAgICAnaWQnOiAndGFzay1wZW9wbGUnLFxuICAgICAgJ3R5cGUnOiAndGFzay1wZW9wbGUnLFxuICAgICAgJ25hbWUnOiAnUGVyc29ubmVsIE5lZWRlZCcsXG4gICAgICAncGx1cmFsJzogJ1BlcnNvbm5lbCBOZWVkZWQnXG4gICAgfSxcblxuICAgICd0YXNrLWxlbmd0aCc6IHtcbiAgICAgICdpY29uJzogJ2ZhIGZhLWJ1bGxzZXllJyxcbiAgICAgICdjbGFzcyc6ICd0YXNrLWxlbmd0aCcsXG4gICAgICAnaWQnOiAndGFzay1sZW5ndGgnLFxuICAgICAgJ3R5cGUnOiAndGFzay1sZW5ndGgnLFxuICAgICAgJ25hbWUnOiAnRGVhZGxpbmUnLFxuICAgICAgJ3BsdXJhbCc6ICdEZWFkbGluZSdcbiAgICB9LFxuXG4gICAgJ3Rhc2stdGltZS1lc3RpbWF0ZSc6IHtcbiAgICAgICdpY29uJzogJ2ZhIGZhLWNvZ3MnLFxuICAgICAgJ2NsYXNzJzogJ3Rhc2stdGltZS1lc3RpbWF0ZScsXG4gICAgICAnaWQnOiAndGFzay10aW1lLWVzdGltYXRlJyxcbiAgICAgICd0eXBlJzogJ3Rhc2stdGltZS1lc3RpbWF0ZScsXG4gICAgICAnbmFtZSc6ICdFc3RpbWF0ZWQgVGltZSBSZXF1aXJlZCcsXG4gICAgICAncGx1cmFsJzogJ0VzdGltYXRlZCBUaW1lIFJlcXVpcmVkJ1xuICAgIH1cblxuICB9LFxuXG4gIC8vIFRoaXMgZGVmaW5lcyB0aGUgcGFydCBvZiB0aGUgYXBwIGFuZCB3aGljaCB0YWdzIGFwcGx5XG4gIC8vIHBsdXJhbCBuYW1lcyBhcmUgZm9yIHNlYXJjaGluZyB0aGUgY29sbGVjdGlvblxuICAvLyBzaW5ndWxhciBuYW1lcyBhcmUgZm9yIHRoZSBpbmRpdmlkdWFsIHNob3cgdmlld3MuXG4gIHByb2plY3QgICA6IFsnc2tpbGwnLCAndG9waWMnLCAnYWdlbmN5JywgJ2xvY2F0aW9uJ10sXG4gIHByb2plY3RzICA6IFsnc2tpbGwnLCAndG9waWMnLCAnYWdlbmN5JywgJ2xvY2F0aW9uJ10sXG5cbiAgcHJvZmlsZSAgIDogWydza2lsbCcsICd0b3BpYyddLFxuICBwcm9maWxlcyAgOiBbJ3NraWxsJywgJ3RvcGljJywgJ2FnZW5jeScsICdsb2NhdGlvbiddLFxuXG4gIHRhc2sgICAgICA6IFsnc2tpbGwnLCAndG9waWMnLCAnbG9jYXRpb24nLCAndGFzay1wZW9wbGUnLCAndGFzay10aW1lLWVzdGltYXRlJywgJ3Rhc2stdGltZS1yZXF1aXJlZCcsICd0YXNrLWxlbmd0aCddLFxuICB0YXNrcyAgICAgOiBbJ3NraWxsJywgJ3RvcGljJywgJ2FnZW5jeScsICdsb2NhdGlvbicsICd0YXNrLXNraWxscy1yZXF1aXJlZCcsICd0YXNrLXRpbWUtcmVxdWlyZWQnLCAndGFzay1wZW9wbGUnLCAndGFzay1sZW5ndGgnLCAndGFzay10aW1lLWVzdGltYXRlJ11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwicHJvamVjdFwiOiB7XG4gICAgXCJzaG93XCI6IHRydWVcbiAgfSxcbiAgXCJzdXBlcnZpc29yRW1haWxcIjoge1xuXHQgIFwidXNlU3VwZXJ2aXNvckVtYWlsXCI6IGZhbHNlXG4gIH0sXG4gIFwiaG9tZVwiOiB7XG4gICAgXCJsb2dnZWRfaW5fcGF0aFwiOiBcIi9wcm9qZWN0c1wiXG4gIH0sXG4gIFwiZmFxXCIgOiB7XG4gICAgXCJzaG93XCIgOiBmYWxzZSxcbiAgICBcInVybFwiICA6IFwiL2ZhcVwiXG4gIH0sXG4gIFwic3lzdGVtRW1haWxcIiA6IFwidGVzdEBtaWRhcy5jb21cIixcbiAgXCJicm93c2VcIjoge1xuICAgIFwicGFnZVNpemVcIiA6IDI3LFxuICAgIFwidXNlSW5maW5pdGVTY3JvbGxcIiA6IGZhbHNlXG4gIH0sXG4gIFwic3RhdGVzXCIgOiBbe1widmFsdWVcIjogXCJkcmFmdFwiLFwibGFiZWxcIjpcIkRyYWZ0XCJ9LHtcInZhbHVlXCI6IFwib3BlblwiLFwibGFiZWxcIjpcIk9wZW5cIn0se1widmFsdWVcIjpcImFzc2lnbmVkXCIsXCJsYWJlbFwiOlwiQXNzaWduZWRcIn0se1widmFsdWVcIjogXCJjb21wbGV0ZWRcIixcImxhYmVsXCI6XCJDb21wbGV0ZWRcIn0se1widmFsdWVcIjpcImFyY2hpdmVkXCIsXCJsYWJlbFwiOlwiQXJjaGl2ZWRcIn1dXG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgQ29tbWVudE1vZGVsID0gcmVxdWlyZSgnLi9jb21tZW50X21vZGVsJyk7XG52YXIgQ29tbWVudExpc3RDb250cm9sbGVyID0gcmVxdWlyZSgnLi4vLi4vYXBwcy9jb21tZW50cy9saXN0L2NvbnRyb2xsZXJzL2NvbW1lbnRfbGlzdF9jb250cm9sbGVyJyk7XG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENvbW1lbnRDb2xsZWN0aW9uID0gQmFja2JvbmUuQ29sbGVjdGlvbi5leHRlbmQoe1xuXG4gIHVybFJvb3Q6ICcvYXBpL2NvbW1lbnQnLFxuXG4gIG1vZGVsOiBDb21tZW50TW9kZWwsXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMubGlzdGVuVG8odGhpcywgXCJjb21tZW50OnNhdmVcIiwgZnVuY3Rpb24gKGRhdGEsIGN1cnJlbnRUYXJnZXQpIHtcbiAgICAgIHNlbGYuYWRkQW5kU2F2ZShkYXRhLCBjdXJyZW50VGFyZ2V0KTtcbiAgICB9KTtcblxuICB9LFxuXG4gIGFkZEFuZFNhdmU6IGZ1bmN0aW9uIChkYXRhLCBjdXJyZW50VGFyZ2V0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLCBjb21tZW50O1xuXG4gICAgY29tbWVudCA9IG5ldyBDb21tZW50TW9kZWwoe1xuICAgICAgcGFyZW50SWQgIDogZGF0YVsncGFyZW50SWQnXSxcbiAgICAgIHZhbHVlICAgICA6IGRhdGFbJ2NvbW1lbnQnXSxcbiAgICAgIHRhc2tJZCAgICA6IGRhdGFbJ3Rhc2tJZCddLFxuICAgICAgcHJvamVjdElkIDogZGF0YVsncHJvamVjdElkJ10sXG4gICAgICB0b3BpYyAgICAgOiBkYXRhWyd0b3BpYyddXG4gICAgfSlcblxuICAgIHNlbGYuYWRkKGNvbW1lbnQpO1xuXG4gICAgc2VsZi5tb2RlbHMuZm9yRWFjaChmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgIGlmIChtb2RlbC5hdHRyaWJ1dGVzLnZhbHVlID09PSBkYXRhWydjb21tZW50J10pIHtcbiAgICAgICAgbW9kZWwuc2F2ZShudWxsLCB7XG4gICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKG1vZGVsSW5zdGFuY2UsIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBzZWxmLnRyaWdnZXIoXCJjb21tZW50OnNhdmU6c3VjY2Vzc1wiLCBtb2RlbEluc3RhbmNlLCByZXNwb25zZSwgY3VycmVudFRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb21tZW50Q29sbGVjdGlvbjtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcblxuXG52YXIgQ29tbWVudE1vZGVsID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHtcblxuICB1cmxSb290OiAnL2FwaS9jb21tZW50JyxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zYXZlQ29tbWVudCgpO1xuICB9LFxuXG4gIHNhdmVDb21tZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLCAnY29tbWVudDpzYXZlJywgZnVuY3Rpb24gKHBhcmVudElkLCBjb21tZW50LCBwcm9qZWN0SWQpIHtcbiAgICAgIHNlbGYuc2F2ZSh7XG4gICAgICAgIHBhcmVudElkICA6IHBhcmVudElkLFxuICAgICAgICB2YWx1ZSAgICAgOiBjb21tZW50LFxuICAgICAgICBwcm9qZWN0SWQgOiBwcm9qZWN0SWRcbiAgICAgIH0sIHtcbiAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICBzZWxmLnRyaWdnZXIoXCJjb21tZW50OnNhdmU6c3VjY2Vzc1wiKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbW1lbnRNb2RlbDtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcblxuXG52YXIgRXZlbnRNb2RlbCA9IEJhY2tib25lLk1vZGVsLmV4dGVuZCh7XG5cbiAgdXJsUm9vdDogJy9hcGkvZXZlbnQnXG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50TW9kZWw7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgRXZlbnRNb2RlbCA9IHJlcXVpcmUoJy4vZXZlbnRfbW9kZWwnKTtcblxuXG52YXIgRXZlbnRDb2xsZWN0aW9uID0gQmFja2JvbmUuQ29sbGVjdGlvbi5leHRlbmQoe1xuICBcbiAgbW9kZWw6IEV2ZW50TW9kZWwsXG4gIFxuICBwYXJzZTogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZXZlbnRzO1xuICAgIH1cbiAgfSxcblxuICB1cmw6ICcvYXBpL2V2ZW50JyxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hZGRBbmRTYXZlKCk7XG4gIH0sXG5cbiAgYWRkQW5kU2F2ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMubGlzdGVuVG8odGhpcywgXCJldmVudDpzYXZlXCIsIGZ1bmN0aW9uIChkYXRhKSB7XG5cbiAgICAgIHNlbGYuZXYgPSBuZXcgRXZlbnRNb2RlbCh7XG4gICAgICAgIHRpdGxlICAgICAgIDogZGF0YVsndGl0bGUnXSwgXG4gICAgICAgIGRlc2NyaXB0aW9uIDogZGF0YVsnZGVzY3JpcHRpb24nXSwgXG4gICAgICAgIHN0YXJ0ICAgICAgIDogZGF0YVsnc3RhcnQnXSxcbiAgICAgICAgZW5kICAgICAgICAgOiBkYXRhWydlbmQnXSxcbiAgICAgICAgbG9jYXRpb24gICAgOiBkYXRhWydsb2NhdGlvbiddLFxuICAgICAgICBwcm9qZWN0SWQgICA6IGRhdGFbJ3Byb2plY3RJZCddIFxuICAgICAgfSk7XG5cbiAgICAgIHNlbGYuYWRkKHNlbGYuZXZlbnQpO1xuXG4gICAgICBzZWxmLmV2LnNhdmUoe30sIHtcbiAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKG1vZGVsSW5zdGFuY2UsIHJlc3BvbnNlKSB7XG4gICAgICAgICAgc2VsZi50cmlnZ2VyKFwiZXZlbnQ6c2F2ZTpzdWNjZXNzXCIsIG1vZGVsSW5zdGFuY2UsIHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRDb2xsZWN0aW9uO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xuXG5cblx0dmFyIFByb2ZpbGVNb2RlbCA9IEJhY2tib25lLk1vZGVsLmV4dGVuZCh7XG5cblx0XHR1cmxSb290OiAnL2FwaS91c2VyJyxcblxuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuaW5pdGlhbGl6ZVByb2ZpbGVTYXZlKCk7XG5cdFx0XHR0aGlzLmluaXRpYWxpemVQcm9maWxlR2V0KCk7XG5cdFx0fSxcblxuXHRcdHBhcnNlOiBmdW5jdGlvbihyZXMsIG9wdGlvbnMpIHtcblx0XHRcdC8vIFJlbW92ZSBmYWxzeSB2YWx1ZXMgKGRiIHJldHVybnMgbnVsbCBpbnN0ZWFkIG9mIHVuZGVmaW5lZClcblx0XHRcdF8ocmVzKS5lYWNoKGZ1bmN0aW9uKHYsIGssIG8pIHsgaWYgKCF2KSBkZWxldGUgb1trXTsgfSk7XG5cdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH0sXG5cblx0XHRpbml0aWFsaXplUHJvZmlsZUdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0XHR0aGlzLmxpc3RlblRvKHRoaXMsIFwicHJvZmlsZTpmZXRjaFwiLCBmdW5jdGlvbiAoaWQpIHtcblx0XHRcdFx0c2VsZi5yZW1vdGVHZXQoaWQpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuICByZW1vdGVHZXQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoaWQpIHtcblx0ICAgICAgdGhpcy5zZXQoeyBpZDogaWQgfSk7XG4gICAgfVxuICAgIHRoaXMuZmV0Y2goe1xuICAgICAgc3VjY2VzczogZnVuY3Rpb24gKG1vZGVsLCByZXNwb25zZSwgb3B0aW9ucykge1xuICAgICAgICBzZWxmLnRyaWdnZXIoXCJwcm9maWxlOmZldGNoOnN1Y2Nlc3NcIiwgbW9kZWwpO1xuICAgICAgfSxcbiAgICAgIGVycm9yOiBmdW5jdGlvbiAobW9kZWwsIHJlc3BvbnNlLCBvcHRpb25zKSB7XG4gICAgICAgIHNlbGYudHJpZ2dlcihcInByb2ZpbGU6ZmV0Y2g6ZXJyb3JcIiwgbW9kZWwsIHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuXHRcdGluaXRpYWxpemVQcm9maWxlU2F2ZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIF90aGlzID0gdGhpcztcblxuXHRcdFx0dGhpcy5saXN0ZW5Ubyh0aGlzLCBcInByb2ZpbGU6dXBkYXRlV2l0aFBob3RvSWRcIiwgZnVuY3Rpb24oZmlsZSkge1xuXHRcdFx0XHR2YXIgX3NlbGYgPSB0aGlzO1xuXHRcdFx0XHRfdGhpcy5zYXZlKHtcblx0XHRcdFx0XHRwaG90b0lkOiBmaWxlWydpZCddXG5cdFx0XHRcdH0sIHtcblx0XHRcdFx0c3VjY2VzczogZnVuY3Rpb24gKGRhdGEpIHtcblx0XHRcdFx0XHRfdGhpcy50cmlnZ2VyKFwicHJvZmlsZTp1cGRhdGVkUGhvdG9cIiwgZGF0YSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGVycm9yOiBmdW5jdGlvbiAoZGF0YSkge1xuXHRcdFx0XHRcdC8vIGFuIGVycm9yIG9jY3VycmVkXG5cdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5saXN0ZW5Ubyh0aGlzLCBcInByb2ZpbGU6c2F2ZVwiLCBmdW5jdGlvbiAoZm9ybSkge1xuXHRcdFx0XHRfdGhpcy5zYXZlKHtcblx0XHRcdFx0XHRuYW1lOiBmb3JtWyduYW1lJ10sXG5cdFx0XHRcdFx0dXNlcm5hbWU6IGZvcm1bJ3VzZXJuYW1lJ10sXG5cdFx0XHRcdFx0dGl0bGU6IGZvcm1bJ3RpdGxlJ10sXG5cdFx0XHRcdFx0YmlvOiBmb3JtWydiaW8nXVxuXHRcdFx0XHR9LCB7XG5cdFx0XHRcdHN1Y2Nlc3M6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdFx0XHRcdFx0X3RoaXMudHJpZ2dlcihcInByb2ZpbGU6c2F2ZTpzdWNjZXNzXCIsIGRhdGEpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRlcnJvcjogZnVuY3Rpb24gKGRhdGEpIHtcblx0XHRcdFx0XHRfdGhpcy50cmlnZ2VyKFwicHJvZmlsZTpzYXZlOmZhaWxcIiwgZGF0YSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5saXN0ZW5Ubyh0aGlzLCBcInByb2ZpbGU6cmVtb3ZlQXV0aFwiLCBmdW5jdGlvbihpZCkge1xuXHRcdFx0XHR2YXIgYXV0aHMgPSB0aGlzLmdldChcImF1dGhzXCIpO1xuXHRcdFx0XHRhdXRocy5zcGxpY2UoYXV0aHMuaW5kZXhPZihpZCksIDEpO1xuXHRcdFx0XHRfdGhpcy5zYXZlKHtcblx0XHRcdFx0XHRhdXRoczogYXV0aHNcblx0XHRcdFx0fSwge1xuXHRcdFx0XHRzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xuXHRcdFx0XHRcdF90aGlzLnRyaWdnZXIoXCJwcm9maWxlOnJlbW92ZUF1dGg6c3VjY2Vzc1wiLCBkYXRhLCBpZCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGVycm9yOiBmdW5jdGlvbiAoZGF0YSkge1xuXHRcdFx0XHRcdF90aGlzLnRyaWdnZXIoXCJwcm9maWxlOnJlbW92ZUF1dGg6ZmFpbFwiLCBkYXRhLCBpZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblxuXHRcdH1cblxuXHR9KTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IFByb2ZpbGVNb2RlbDtcblxuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xuXG5cbnZhciBQcm9qZWN0TW9kZWwgPSBCYWNrYm9uZS5Nb2RlbC5leHRlbmQoe1xuXG4gIGRlZmF1bHRzOiB7XG4gICAgdGl0bGUgICAgICAgOiBudWxsLFxuICAgIGRlc2NyaXB0aW9uIDogbnVsbCxcbiAgICBhcmNoaXZlZCAgICA6IGZhbHNlXG4gIH0sXG5cbiAgLy8gSW5pdGlhbGl6ZSBjb250YWlucyBvbmx5IGV2ZW50IGJpbmRpbmdzIGFuZCBpZi90aGVuIHJlc3BvbnNlXG4gIC8vIGZ1bmN0aW9ucyAoY2xhc3MgbWV0aG9kcykuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLmxpc3RlblRvKHRoaXMsIFwicHJvamVjdDptb2RlbDpmZXRjaFwiLCBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHNlbGYucmVtb3RlR2V0KGlkKTtcbiAgICB9KTtcblxuICAgIHRoaXMubGlzdGVuVG8odGhpcywgXCJwcm9qZWN0Om1vZGVsOnVwZGF0ZVwiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgc2VsZi51cGRhdGUoZGF0YSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmxpc3RlblRvKHRoaXMsIFwicHJvamVjdDp1cGRhdGU6cGhvdG9JZFwiLCBmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgc2VsZi51cGRhdGVQaG90byhmaWxlKTtcbiAgICB9KTtcblxuICAgIHRoaXMubGlzdGVuVG8odGhpcywgXCJwcm9qZWN0OnVwZGF0ZTpzdGF0ZVwiLCBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIHNlbGYudXBkYXRlU3RhdGUoc3RhdGUpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLCBcInByb2plY3Rvd25lcjpzaG93OmNoYW5nZWRcIiwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHNlbGYudXBkYXRlT3duZXJzKGRhdGEpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLCBcInByb2plY3Q6dXBkYXRlOnRhc2tzOm9ycGhhblwiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgc2VsZi5vcnBoYW4oZGF0YSk7XG4gICAgfSk7XG5cbiAgfSxcblxuICB1cmxSb290OiAnL2FwaS9wcm9qZWN0JyxcblxuICByZW1vdGVHZXQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLnNldCh7IGlkOiBpZCB9KTtcbiAgICB0aGlzLmZldGNoKHtcbiAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHNlbGYudHJpZ2dlcihcInByb2plY3Q6bW9kZWw6ZmV0Y2g6c3VjY2Vzc1wiLCBkYXRhKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5zYXZlKHtcbiAgICAgIHRpdGxlOiBkYXRhWyd0aXRsZSddLFxuICAgICAgZGVzY3JpcHRpb246IGRhdGFbJ2Rlc2NyaXB0aW9uJ11cbiAgICB9LCB7IHN1Y2Nlc3M6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHNlbGYudHJpZ2dlcihcInByb2plY3Q6c2F2ZTpzdWNjZXNzXCIsIGRhdGEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8vIFRPRE86IFVwZGF0ZSB0aGlzIG1ldGhvZCBhbmQgbW92ZSBpdCBpbnRvIHRoZSBnbG9iYWwgdXBkYXRlIG1ldGhvZC5cbiAgdXBkYXRlUGhvdG86IGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5zYXZlKHtcbiAgICAgIGNvdmVySWQ6IGZpbGVbJ2lkJ11cbiAgICB9LCB7XG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBzZWxmLnRyaWdnZXIoXCJwcm9qZWN0OnVwZGF0ZWQ6cGhvdG86c3VjY2Vzc1wiLCBkYXRhKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICB1cGRhdGVTdGF0ZTogZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5zYXZlKHtcbiAgICAgIHN0YXRlOiBzdGF0ZVxuICAgIH0sIHtcbiAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgc2VsZi50cmlnZ2VyKFwicHJvamVjdDp1cGRhdGU6c3RhdGU6c3VjY2Vzc1wiLCBkYXRhKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICB1cGRhdGVPd25lcnM6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIC8vIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgIHRoaXMuc2F2ZSh7XG4gICAgICBvd25lcnM6IGRhdGFcbiAgICB9LCB7XG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHNlbGYudHJpZ2dlcihcInByb2plY3Q6dXBkYXRlOm93bmVyczpzdWNjZXNzXCIsIGRhdGEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIGhhc09wZW5UYXNrczogZnVuY3Rpb24odGFza3Mpe1xuICAgIC8vdGFrZXMgYSB0YXNrIGNvbGxlY3Rpb24gb2JqZWN0XG4gICAgdmFyIGhhc09wZW5UYXNrcyA9IGZhbHNlO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY291bnQgPSAwO1xuXG4gICAgXy5lYWNoKHRhc2tzLm1vZGVscyxmdW5jdGlvbih0YXNrKXtcbiAgICAgIGlmICggXy5pbmRleE9mKFsnb3BlbicsJ2Fzc2lnbmVkJ10sdGFzay5hdHRyaWJ1dGVzLnN0YXRlKSAhPSAtMSApe1xuICAgICAgICBoYXNPcGVuVGFza3MgPSB0cnVlO1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtoYXNPcGVuVGFza3M6aGFzT3BlblRhc2tzLGNvdW50OmNvdW50fTtcbiAgfSxcblxuICBvcnBoYW46IGZ1bmN0aW9uKHRhc2tzKSB7XG4gICAgLy9vcnBoYW5zIGFzc29jaWF0ZWQgdGFza3MgZm9yIGEgc3RhdGUgY2hhbmdlXG4gICAgdGFza3MuZWFjaChmdW5jdGlvbihtb2RlbCl7XG4gICAgICBtb2RlbC50cmlnZ2VyKFwidGFzazp1cGRhdGU6b3JwaGFuXCIse30pO1xuICAgIH0pO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb2plY3RNb2RlbDtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciBQcm9qZWN0TW9kZWwgPSByZXF1aXJlKCcuL3Byb2plY3RfbW9kZWwnKTtcblxuXG52YXIgUHJvamVjdHNDb2xsZWN0aW9uID0gQmFja2JvbmUuQ29sbGVjdGlvbi5leHRlbmQoe1xuXG4gIG1vZGVsOiBQcm9qZWN0TW9kZWwsXG5cbiAgdXJsOiAnL2FwaS9wcm9qZWN0L2ZpbmRBbGwnLFxuXG4gIHBhcnNlOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gcmVzcG9uc2UucHJvamVjdHM7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMubGlzdGVuVG8odGhpcywgXCJwcm9qZWN0OnNhdmVcIiwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHNlbGYuYWRkQW5kU2F2ZShkYXRhKTtcbiAgICB9KTtcbiAgfSxcblxuICBhZGRBbmRTYXZlOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBwcm9qZWN0LCBzZWxmID0gdGhpcztcblxuICAgIHByb2plY3QgPSBuZXcgUHJvamVjdE1vZGVsKHtcbiAgICAgIHRpdGxlOiBkYXRhWyd0aXRsZSddLFxuICAgICAgZGVzY3JpcHRpb246IGRhdGFbJ2Rlc2NyaXB0aW9uJ11cbiAgICB9KTtcblxuICAgIHByb2plY3Quc2F2ZSh7fSwge1xuICAgICAgc3VjY2VzczogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgc2VsZi5hZGQocHJvamVjdCk7XG4gICAgICAgIHNlbGYudHJpZ2dlcihcInByb2plY3Q6c2F2ZTpzdWNjZXNzXCIsIGRhdGEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb2plY3RzQ29sbGVjdGlvbjtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVGFza01vZGVsID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHtcblxuICBkZWZhdWx0czoge1xuICAgIG5hbWUgICAgICAgIDogbnVsbCxcbiAgICBkZXNjcmlwdGlvbiA6IG51bGxcbiAgfSxcblxuICB1cmxSb290OiAnL2FwaS90YXNrJyxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLCBcInRhc2s6c2F2ZVwiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgdGhpcy5zYXZlKGRhdGEpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLCBcInRhc2s6bW9kZWw6ZmV0Y2hcIiwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHRoaXMucmVtb3RlR2V0KGRhdGEpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLCBcInRhc2s6dXBkYXRlXCIsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICB0aGlzLnVwZGF0ZShkYXRhKTtcbiAgICB9KTtcblxuICAgIHRoaXMubGlzdGVuVG8odGhpcywgXCJ0YXNrOnVwZGF0ZTpzdGF0ZVwiLCBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIHRoaXMudXBkYXRlU3RhdGUoc3RhdGUpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLCBcInRhc2s6dXBkYXRlOm9ycGhhblwiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgdGhpcy5vcnBoYW4oZGF0YSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuc2F2ZShkYXRhLCB7XG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBzZWxmLnRyaWdnZXIoXCJ0YXNrOnVwZGF0ZTpzdWNjZXNzXCIsIGRhdGEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIHVwZGF0ZVN0YXRlOiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLnNhdmUoe1xuICAgICAgc3RhdGU6IHN0YXRlXG4gICAgfSwge1xuICAgICAgc3VjY2VzczogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBzZWxmLnRyaWdnZXIoXCJ0YXNrOnVwZGF0ZTpzdGF0ZTpzdWNjZXNzXCIsIGRhdGEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIG9ycGhhbjogZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuc2F2ZSh7XG4gICAgICBwcm9qZWN0SWQ6IG51bGxcbiAgICB9LCB7XG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHNlbGYudHJpZ2dlcihcInRhc2s6dXBkYXRlOm9ycGhhbjpzdWNjZXNzXCIsIGRhdGEpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gIH0sXG5cbiAgcmVtb3RlR2V0OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5zZXQoeyBpZDogaWQgfSk7XG4gICAgdGhpcy5mZXRjaCh7XG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBzZWxmLnRyaWdnZXIoXCJ0YXNrOm1vZGVsOmZldGNoOnN1Y2Nlc3NcIiwgZGF0YSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbn0pO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gVGFza01vZGVsO1xuXG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgVGFza01vZGVsID0gcmVxdWlyZSgnLi90YXNrX21vZGVsJyk7XG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFRhc2tzQ29sbGVjdGlvbiA9IEJhY2tib25lLkNvbGxlY3Rpb24uZXh0ZW5kKHtcblxuICBtb2RlbDogVGFza01vZGVsLFxuXG4gIHBhcnNlOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgIGlmIChyZXNwb25zZS50YXNrcykge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UudGFza3M7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfSxcblxuICB1cmw6ICcvYXBpL3Rhc2snLFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLmxpc3RlblRvKHRoaXMsIFwidGFzazpzYXZlXCIsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBzZWxmLmFkZEFuZFNhdmUoZGF0YSk7XG4gICAgfSlcbiAgfSxcblxuICBhZGRBbmRTYXZlOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHNlbGYudGFzayA9IG5ldyBUYXNrTW9kZWwoZGF0YSk7XG5cbiAgICBzZWxmLnRhc2suc2F2ZShudWxsLHtcbiAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICBzZWxmLnRyaWdnZXIoXCJ0YXNrOnNhdmU6c3VjY2Vzc1wiLCBzZWxmLnRhc2suaWQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRhc2tzQ29sbGVjdGlvbjtcblxuIiwiXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgQmFzZUNvbXBvbmVudCA9IHJlcXVpcmUoJy4uL2Jhc2UvYmFzZV9jb21wb25lbnQnKTtcbnZhciBCb290c3RyYXAgPSByZXF1aXJlKCdib290c3RyYXAnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbGl0aWVzJyk7XG52YXIgUG9wb3ZlclByb2ZpbGUgPSByZXF1aXJlKCcuL3RlbXBsYXRlcy9wb3BvdmVyX3Byb2ZpbGUuaHRtbCcpO1xuXG5cblBvcG92ZXJzID0gQmFzZUNvbXBvbmVudC5leHRlbmQoe1xuXG4gIHBvcG92ZXJQZW9wbGVJbml0OiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgJCh0YXJnZXQpLnBvcG92ZXIoXG4gICAgICB7XG4gICAgICAgIHBsYWNlbWVudDogJ2F1dG8gdG9wJyxcbiAgICAgICAgdHJpZ2dlcjogJ21hbnVhbCcsXG4gICAgICAgIGh0bWw6ICd0cnVlJyxcbiAgICAgICAgdGl0bGU6ICdsb2FkJyxcbiAgICAgICAgY29udGFpbmVyOiAnYm9keScsXG4gICAgICAgIGNvbnRlbnQ6ICc8ZGl2IGNsYXNzPVwicG9wb3Zlci1zcGlubmVyXCI+PGRpdiBjbGFzcz1cImxvYWRpbmdcIj5GZXRjaGluZyBJbmZvcm1hdGlvbjwvZGl2PjxpIGNsYXNzPVwiZmEgZmEtc3Bpbm5lciBmYS1zcGluXCI+PC9pPjwvZGl2PicsXG4gICAgICAgIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cInBvcG92ZXJcIj48ZGl2IGNsYXNzPVwiYXJyb3dcIj48L2Rpdj48aDMgY2xhc3M9XCJwb3BvdmVyLXRpdGxlXCIgc3R5bGU9XCJkaXNwbGF5Om5vbmU7IHZpc2liaWxpdHk6aGlkZGVuXCI+PC9oMz48ZGl2IGNsYXNzPVwicG9wb3Zlci1jb250ZW50XCI+PC9kaXY+PC9kaXY+J1xuICAgICAgfSkub24oXCJtb3VzZWxlYXZlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHRpbWVvdXRGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoISQoXCIucG9wb3Zlcjpob3ZlclwiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICQoX3RoaXMpLnBvcG92ZXIoXCJoaWRlXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRpbWVvdXRGbiwgMTAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHNldFRpbWVvdXQodGltZW91dEZuLCAxMDApO1xuICAgICAgfSk7XG4gIH0sXG5cbiAgcG9wb3ZlclBlb3BsZU9uOiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIHRhcmdldCA9ICQoZS5jdXJyZW50VGFyZ2V0KTtcbiAgICB2YXIgcG9wb3ZlciA9IHRhcmdldC5kYXRhKCdicy5wb3BvdmVyJyk7XG4gICAgLy8gaWYgdGhlIGRhdGEgZWxlbWVudCBpc24ndCBzZXQgb3IgcG9wb3ZlcnMgbm90IGluaXQnZCwgYWJvcnRcbiAgICBpZiAoKF8uaXNVbmRlZmluZWQodGFyZ2V0LmRhdGEoJ3VzZXJpZCcpKSkgfHwgKF8uaXNVbmRlZmluZWQocG9wb3ZlcikpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRhcmdldC5wb3BvdmVyKCdzaG93Jyk7XG4gICAgLy8gT25seSBsb2FkIGRhdGEgaWYgdGhlIHBvcG92ZXIgaGFzbid0IHByZXZpb3VzbHkgYmVlbiBsb2FkZWRcbiAgICBpZiAocG9wb3Zlci5vcHRpb25zLnRpdGxlID09ICdsb2FkJykge1xuICAgICAgJC5hamF4KHsgdXJsOiAnL2FwaS91c2VyL2luZm8vJyArIHRhcmdldC5kYXRhKCd1c2VyaWQnKSB9KS5kb25lKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZShQb3BvdmVyUHJvZmlsZSkoe2RhdGE6IGRhdGF9KTtcbiAgICAgICAgcG9wb3Zlci5vcHRpb25zLnRpdGxlID0gJ2RvbmUnO1xuICAgICAgICBwb3BvdmVyLm9wdGlvbnMuY29udGVudCA9IHRlbXBsYXRlO1xuICAgICAgICBwb3BvdmVyLnNldENvbnRlbnQoKTtcbiAgICAgICAgcG9wb3Zlci4kdGlwLmFkZENsYXNzKHBvcG92ZXIub3B0aW9ucy5wbGFjZW1lbnQpO1xuICAgICAgICAvLyBoYW5kbGUgbGlua3MgaW4gdGhlIHBvcG92ZXJzXG4gICAgICAgICQoXCIucG9wb3ZlclwiKS5vbignY2xpY2snLCBcIi5saW5rLWJhY2tib25lXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdGFyZ2V0LnBvcG92ZXIoJ2hpZGUnKTtcbiAgICAgICAgICBsaW5rQmFja2JvbmUoZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIHBvcG92ZXJDbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHZhciBpZCA9ICQoZS5jdXJyZW50VGFyZ2V0KS5kYXRhKCd1c2VyaWQnKTtcbiAgICAkKGUuY3VycmVudFRhcmdldCkucG9wb3ZlcignaGlkZScpO1xuICAgIEJhY2tib25lLmhpc3RvcnkubmF2aWdhdGUoJ3Byb2ZpbGUvJyArIGlkLCB7IHRyaWdnZXI6IHRydWUgfSk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvcG92ZXJzO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcInBvcG92ZXItdGFibGVcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwicG9wb3Zlci1yb3dcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJwb3BvdmVyLWNlbGwtbGVmdFxcXCI+XFxuICAgICAgPGltZyBhbGlnbj1cXFwibGVmdFxcXCIgc3JjPVxcXCIvYXBpL3VzZXIvcGhvdG8vPCUtIGRhdGEuaWQgJT5cXFwiIGNsYXNzPVxcXCJwb3BvdmVyLWltYWdlXFxcIi8+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJwb3BvdmVyLWNlbGwtcmlnaHQgcG9wb3Zlci1wZXJzb25cXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInRpdGxlXFxcIj48YSBjbGFzcz1cXFwibGluay1iYWNrYm9uZVxcXCIgaHJlZj1cXFwiL3Byb2ZpbGUvPCUtIGRhdGEuaWQgJT5cXFwiPjwlLSBkYXRhLm5hbWUgJT48L2E+PC9kaXY+XFxuICAgICAgPCUgaWYgKGRhdGEudGl0bGUpIHsgJT48ZGl2IGNsYXNzPVxcXCJ0ZXh0LWxpbmVcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1icmllZmNhc2VcXFwiPjwvaT4gPCUtIGRhdGEudGl0bGUgJT48L2Rpdj48JSB9ICU+XFxuICAgICAgPCUgaWYgKGRhdGEuYWdlbmN5KSB7ICU+PGRpdiBjbGFzcz1cXFwidGV4dC1saW5lXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtbGlicmFyeVxcXCI+PC9pPiA8JS0gZGF0YS5hZ2VuY3kudGFnLm5hbWUgJT48L2Rpdj48JSB9ICU+XFxuICAgICAgPCUgaWYgKGRhdGEubG9jYXRpb24pIHsgJT48ZGl2IGNsYXNzPVxcXCJ0ZXh0LWxpbmVcXFwiPjxzcGFuIGNsYXNzPVxcXCJmYSBmYS1tYXAtbWFya2VyXFxcIj48L3NwYW4+IDwlLSBkYXRhLmxvY2F0aW9uLnRhZy5uYW1lICU+PC9kaXY+PCUgfSAlPlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZGl2PlwiO1xuIiwiLy8gSW5wdXQ6XG4vLyBAY29sbGVjdGlvbiBbQVJSQVldIEJhY2tib25lIGNvbGxlY3Rpb24uXG4vLyBAbW9kZWxJZCBbSU5URUdFUl0gQmFja2JvbmUgTW9kZWwuY2lkXG5cbi8vIFJldHVybjogW09CSkVDVF0gTW9kZWwgaW5zdGFuY2UgbG9va2VkIHVwIGZyb20gbW9kZWxJZCB3aXRoaW4gY29sbGVjdGlvbi5cbmdsb2JhbC5nZXRDdXJyZW50TW9kZWxGcm9tSWQgPSBmdW5jdGlvbiAoY29sbGVjdGlvbiwgbW9kZWxJZCkge1xuXHR2YXIgaSA9IDA7XG5cdFx0XHRpZCA9IHBhcnNlSW50KG1vZGVsSWQpXG5cdFx0XHRtb2RlbHMgPSBjb2xsZWN0aW9uLm1vZGVscztcblxuXHRmb3IgKCA7IGkgPCBtb2RlbHMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRpZiAobW9kZWxzW2ldLmlkID09PSBpZCkge1xuXHRcdFx0cmV0dXJuIG1vZGVsc1tpXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXHR9XG59XG5cbi8vIElucHV0OlxuLy8gQGNvbGxlY3Rpb24gW0FSUkFZXSBCYWNrYm9uZSBjb2xsZWN0aW9uLlxuLy8gQGF0dHIgW1NUUklOR10gVmFsdWUsIHRvIGJlIGZvdW5kLlxuXG4vLyBSZXR1cm46IFtPQkpFQ1RdIE1vZGVsIGluc3RhbmNlIHRoYXQgaXMgY29yb2xsYXJ5IHRvIHRoZSBmb3VuZCBAYXR0ciB2YWx1ZS5cbmdsb2JhbC5nZXRDdXJyZW50TW9kZWxGcm9tRm9ybUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoY29sbGVjdGlvbiwgYXR0cikge1xuXHR2YXJcdGosXG5cdFx0XHRpID0gMCxcblx0XHRcdGF0dHIgPSAkLnRyaW0oYXR0ciksXG5cdFx0XHRtb2RlbHMgPSBjb2xsZWN0aW9uLm1vZGVscztcblxuXHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBtb2RlbHNcblx0Zm9yICggOyBpIDwgbW9kZWxzLmxlbmd0aDsgaSArPSAxKSB7XG5cblx0XHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBhdHRyaWJ1dGVzIHdpdGhpbiB0aGUgbW9kZWxcblx0XHRmb3IgKGogaW4gbW9kZWxzW2ldLmF0dHJpYnV0ZXMpIHtcblxuXHRcdFx0Ly8gSWYgd2UgZmluZCB0aGUgbW9kZWwuYXR0clt2YWx1ZV0gb24gdGhlIGN1cnJlbnQgbW9kZWxzXG5cdFx0XHQvLyBhdHRyaWJ1dGUgdGhhdCB3ZSBhcmUgbG9vcGluZyBvdmVyLCB0aGVuIHN0b3AgYW5kIHJldHVybiB0aGF0XG5cdFx0XHQvLyBtb2RlbCBiYWNrIG91dCB0byB0aGUgZnJvbnQtZW5kLlxuXHRcdFx0aWYgKG1vZGVsc1tpXS5hdHRyaWJ1dGVzW2pdID09PSBhdHRyKSB7XG5cdFx0XHRcdHJldHVybiBtb2RlbHNbaV1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIE90aGVyd2lzZSBjb250aW51ZSBvbi5cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQ29tcGxldGVseSByZW1vdmUgYSBiYWNrYm9uZSB2aWV3IGFuZCBhbGwgb2YgaXRzXG4gKiByZWZlcmVuY2VzLiAgVGhpcyBpcyBuZWVkZWQgdG8gZGVzdHJveSB0aGUgdmlld1xuICogYW5kIGFsbCBvZiBpdHMgbGlzdGVuZXJzLCBpbiBvcmRlciB0byBzdGFydFxuICogZnJlc2ggYWdhaW4gYW5kIHJlbmRlciBhIG5ldyB2aWV3IHdpdGggYSBuZXdcbiAqIG1vZGVsLlxuICpcbiAqIElucHV0OlxuICogQHZpZXcgdGhlIHZpZXcgdG8gYmUgcmVtb3ZlZCwgdHlwaWNhbGx5IGNhbGxlZCB3aXRoIHJlbW92ZVZpZXcodGhpcyk7XG4gKlxuICogUmV0dXJuOlxuICogbm90aGluZ1xuICovXG5nbG9iYWwucmVtb3ZlVmlldyA9IGZ1bmN0aW9uICh2aWV3KSB7XG4gIHZpZXcudW5kZWxlZ2F0ZUV2ZW50cygpO1xuICB2aWV3LiRlbC5odG1sKFwiXCIpO1xufVxuXG4vKipcbiAqIENsZWFyIG91dCBhbnkgZWwuXG4gKiBAcGFyYW1zIHtbVGhlIG5vbi1qcXVlcnkgbWFwcGVkIGVsIGZvciB0aGUgdmlldyBpbnN0YW5jZV19XG4gKiBSZXR1cm46IE5vdGhpbmcuXG4gKi9cbmdsb2JhbC5jbGVhckVsID0gZnVuY3Rpb24gKGVsKSB7XG4gICQoZWwpLmNoaWxkcmVuKCkucmVtb3ZlKCk7XG59XG5cbi8qKlxuICogQ2xlYXIgb3V0IG91ciBnbG9iYWwgY29udGFpbmVyIGZvciBmdWxsIHBhZ2UgdHJhbnNpdGlvbnMuXG4gKiBAcGFyYW1zIE5vbmVcbiAqIEByZXR1cm4gTm90aGluZ1xuICovXG5nbG9iYWwuY2xlYXJDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gICQoXCIjY29udGFpbmVyXCIpLmNoaWxkcmVuKCkucmVtb3ZlKCk7XG59XG5cbi8qKlxuICogVGhpcyBoZWxwcyBhbGxldmlhdGUgYSBjb21tb24gYnVnIHdpdGggYWpheCBiYXNlZFxuICogcGFnZSB0cmFuc2l0aW9ucy4gVGhhdCBpcyBzb21ldGltZXMgd2hlbiB0aGUgcGFnZSBwdXNoZXMgaXRzZWxmIG9mZiB0aGUgc2NyZWVuXG4gKiBhbmQgYWxsb3dzIGEgYnJvd3NlciBkZWZhdWx0IGJhY2tncm91bmQgdG8gc2hvdywgYWZ0ZXIgd2hpY2ggc2Nyb2xsaW5nXG4gKiB1cCBpcyByZXF1aXJlZC4gIEl0IGlzIGEgc29tZXdoYXQgcmFyZSBidWcsIGJ1dCB1c2VmdWwgdG8gaGF2ZSB0aGlzIGZ1bmN0aW9uXG4gKiBpZiB5b3UgbmVlZCBpdC5cbiAqXG4gKiBSZXR1cm46XG4gKiBub3RoaW5nXG4gKi9cbmdsb2JhbC5zY3JvbGxUb3AgPSBmdW5jdGlvbiAoKSB7XG4gICQod2luZG93KS5zY3JvbGxUb3AoJCh3aW5kb3cpLnNjcm9sbFRvcCgpKTtcbn1cblxuLyoqXG4gKiBPcmdhbml6ZSB0aGUgdGFncyBvdXRwdXQgaW50byBhbiBhc3NvY2lhdGl2ZSBhcnJheSBrZXknZCBieSB0aGVpciB0eXBlLlxuICogSWYgdGhlIHRhZyBoYXMgbW9yZSB0aGFuIG9uZSB2YWx1ZSBmb3Igc2FpZCBrZXksIG1ha2UgaXQgYW4gYXJyYXkgb3RoZXJ3aXNlXG4gKiBrZWVwIGl0IGFzIGEgdG9wIGxldmVsIG9iamVjdC5cbiAqIEBwYXJhbSAge1thcnJheV19IHRhZ3MgICAgICAgICAgIFthcnJheSBvZiB0YWdzXVxuICogQHJldHVybiB7W29iamVjdF19ICAgICAgICAgICAgICAgW2JpbmRpbmdPYmplY3QgcmV0dXJuZWQgb3V0XVxuICovXG5nbG9iYWwub3JnYW5pemVUYWdzID0gZnVuY3Rpb24gKHRhZ3MpIHtcbiAgdmFyIG91dFRhZ3MgPSB7fTtcbiAgZm9yICh0IGluIHRhZ3MpIHtcbiAgICBpZiAoIShfLmhhcyhvdXRUYWdzLCB0YWdzW3RdLnRhZy50eXBlKSkpIHtcbiAgICAgIG91dFRhZ3NbdGFnc1t0XS50YWcudHlwZV0gPSBbXTtcbiAgICB9XG4gICAgb3V0VGFnc1t0YWdzW3RdLnRhZy50eXBlXS5wdXNoKHRhZ3NbdF0udGFnKTtcbiAgfVxuICByZXR1cm4gb3V0VGFncztcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBhbiBpbnB1dCBmaWVsZC4gIEFzc3VtZXMgdGhhdCB0aGVyZSBpcyBhIGRhdGFcbiAqIHZhcmlhYmxlIGluIHRoZSBIVE1MIHRhZyBjYWxsZWQgYGRhdGEtdmFsaWRhdGVgIHdpdGggdGhlXG4gKiB2YWxpZGF0aW9uIG9wdGlvbnMgdGhhdCB5b3Ugd2FudCB0byBlbmZvcmNlLlxuICpcbiAqIGVtYWlsIGlzIG9ubHkgbWVhbnQgdG8gYWxsb3cgdGhlIHZhbHVlIGlzIGdlbmVyYWxseSBlbWFpbCBzaGFwZWRcbiAqICAgIGl0IGlzIG5vdCBidWxsZXQgcHJvb2ZcbiAqXG4gKiBlbWFpbGRvbWFpbiByZXF1aXJlcyBhIGRhdGEtZW1haWxkb21haW4gdmFyaWFibGUgaW4gdGhlIEhUTUwgdGFnXG4gKiAgICBpdCB3aWxsIHZhbGlkYXRlIGFnYWluc3QgdGhlIHZhbHVlIHRoZXJlXG4gKlxuICogVGhlIGlucHV0IHNob3VsZCBiZSBpbiBhIGBmb3JtLWdyb3VwYCBjb21wb25lbnQsXG4gKiBhbmQgdGhlIGNvbXBvbmVudCBzaG91bGQgaGF2ZSBhIC5oZWxwLXRleHQgZWxlbWVudFxuICogd2l0aCBhIGNsYXNzIGAuZXJyb3ItW2NvZGVdYCB3aGVyZSBbY29kZV0gaXMgdGhlXG4gKiB2YWxpZGF0aW9uIHJ1bGUgKGVnLCBgZW1wdHlgKTtcbiAqXG4gKiBFeHBlY3RzIGFuIG9iamVjdCB3aXRoIGN1cnJlbnRUYXJnZXQsIGVnIHsgY3VycmVudFRhcmdldDogJyNmb28nIH1cbiAqL1xuZ2xvYmFsLnZhbGlkYXRlID0gZnVuY3Rpb24gKGUpIHtcbiAgdmFyIG9wdHMgPSBTdHJpbmcoJChlLmN1cnJlbnRUYXJnZXQpLmRhdGEoJ3ZhbGlkYXRlJykpLnNwbGl0KCcsJyk7XG4gIHZhciB2YWwgPSAkKGUuY3VycmVudFRhcmdldCkudmFsKCk7XG4gIHZhciBwYXJlbnQgPSAkKGUuY3VycmVudFRhcmdldCkucGFyZW50cygnLmZvcm0tZ3JvdXAsIC5jaGVja2JveCcpWzBdO1xuICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gIF8uZWFjaChvcHRzLCBmdW5jdGlvbiAobykge1xuICAgIGlmIChvID09ICdlbXB0eScpIHtcbiAgICAgIGlmICghdmFsKSB7XG4gICAgICAgICQocGFyZW50KS5maW5kKCcuZXJyb3ItZW1wdHknKS5zaG93KCk7XG4gICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkKHBhcmVudCkuZmluZCgnLmVycm9yLWVtcHR5JykuaGlkZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobyA9PSAnY2hlY2tlZCcpIHtcbiAgICAgIGlmICgkKGUuY3VycmVudFRhcmdldCkucHJvcCgnY2hlY2tlZCcpICE9PSB0cnVlKSB7XG4gICAgICAgICQocGFyZW50KS5maW5kKCcuZXJyb3ItY2hlY2tlZCcpLnNob3coKTtcbiAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICQocGFyZW50KS5maW5kKCcuZXJyb3ItY2hlY2tlZCcpLmhpZGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG8uc3Vic3RyaW5nKDAsNSkgPT0gJ2NvdW50Jykge1xuICAgICAgdmFyIGxlbiA9IHBhcnNlSW50KG8uc3Vic3RyaW5nKDUpKTtcbiAgICAgIGlmICh2YWwubGVuZ3RoID4gbGVuKSB7XG4gICAgICAgICQocGFyZW50KS5maW5kKCcuZXJyb3ItJyArIG8pLnNob3coKTtcbiAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICQocGFyZW50KS5maW5kKCcuZXJyb3ItJyArIG8pLmhpZGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG8gPT0gJ2NvbmZpcm0nKSB7XG4gICAgICB2YXIgaWQgPSAkKGUuY3VycmVudFRhcmdldCkuYXR0cignaWQnKTtcbiAgICAgIHZhciBuZXdWYWwgPSAkKCcjJyArIGlkICsgJy1jb25maXJtJykudmFsKCk7XG4gICAgICBpZiAodmFsICE9IG5ld1ZhbCkge1xuICAgICAgICAkKHBhcmVudCkuZmluZCgnLmVycm9yLScgKyBvKS5zaG93KCk7XG4gICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkKHBhcmVudCkuZmluZCgnLmVycm9yLScgKyBvKS5oaWRlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvID09ICdidXR0b24nKSB7XG4gICAgICBpZiAoISgkKCQocGFyZW50KS5maW5kKFwiI1wiICsgJChlLmN1cnJlbnRUYXJnZXQpLmF0dHIoJ2lkJykgKyBcIi1idXR0b25cIilbMF0pLmhhc0NsYXNzKCdidG4tc3VjY2VzcycpKSkge1xuICAgICAgICAkKHBhcmVudCkuZmluZCgnLmVycm9yLScgKyBvKS5zaG93KCk7XG4gICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkKHBhcmVudCkuZmluZCgnLmVycm9yLScgKyBvKS5oaWRlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvID09ICdlbWFpbCcpe1xuICAgICAgdmFyIGNvcnJlY3RMZW5ndGggPSBmYWxzZTtcbiAgICAgIGlmICggdmFsICE9IFwiXCIgJiYgdmFsLmluZGV4T2YoXCJAXCIpID49IDIgKXtcbiAgICAgICAgdmFyIGJpdHMgPSB2YWwuc3BsaXQoXCJAXCIpO1xuICAgICAgICB2YXIgYWRkckJpdHMgPSBiaXRzWzFdLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgaWYgKCBhZGRyQml0cy5sZW5ndGggPj0yICkge1xuICAgICAgICAgIGZvciAoaT0wOyBpPGFkZHJCaXRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICBpZiAoIGFkZHJCaXRzW2ldLmxlbmd0aCA8IDIgKXtcbiAgICAgICAgICAgICAgY29ycmVjdExlbmd0aCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvcnJlY3RMZW5ndGggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCAhY29ycmVjdExlbmd0aCB8fCBiaXRzWzBdLmxlbmd0aCA8IDIgKSB7XG4gICAgICAgICQocGFyZW50KS5maW5kKCcuZXJyb3ItZW1haWwnKS5zaG93KCk7XG4gICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkKHBhcmVudCkuZmluZCgnLmVycm9yLWVtYWlsJykuaGlkZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIG89PSAnZW1haWxkb21haW4nKXtcbiAgICAgIHZhciBkb21haW4gPSAkKGUuY3VycmVudFRhcmdldCkuZGF0YSgnZW1haWxkb21haW4nKTtcbiAgICAgIGlmICggdmFsICE9IFwiXCIgJiYgdmFsLmluZGV4T2YoXCJAXCIpID49IDIgKXtcbiAgICAgICAgdmFyIGJpdHMgPSB2YWwuc3BsaXQoXCJAXCIpO1xuICAgICAgICBpZiAoIGJpdHNbMV0gIT0gZG9tYWluICl7XG4gICAgICAgICAgJChwYXJlbnQpLmZpbmQoJy5lcnJvci1lbWFpbGRvbWFpbicpLnNob3coKTtcbiAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICQocGFyZW50KS5maW5kKCcuZXJyb3ItZW1haWxkb21haW4nKS5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0pO1xuICBpZiAocmVzdWx0ID09PSB0cnVlKSB7XG4gICAgJChwYXJlbnQpLmFkZENsYXNzKCdoYXMtZXJyb3InKTtcbiAgfSBlbHNlIHtcbiAgICAkKHBhcmVudCkucmVtb3ZlQ2xhc3MoJ2hhcy1lcnJvcicpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5nbG9iYWwudmFsaWRhdGVQYXNzd29yZCA9IGZ1bmN0aW9uICh1c2VybmFtZSwgcGFzc3dvcmQpIHtcbiAgdmFyIHJ1bGVzID0ge1xuICAgIHVzZXJuYW1lOiBmYWxzZSxcbiAgICBsZW5ndGg6IGZhbHNlLFxuICAgIHVwcGVyOiBmYWxzZSxcbiAgICBsb3dlcjogZmFsc2UsXG4gICAgbnVtYmVyOiBmYWxzZSxcbiAgICBzeW1ib2w6IGZhbHNlXG4gIH07XG4gIHZhciBfdXNlcm5hbWUgPSB1c2VybmFtZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgdmFyIF9wYXNzd29yZCA9IHBhc3N3b3JkLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAvLyBjaGVjayB1c2VybmFtZSBpcyBub3QgdGhlIHNhbWUgYXMgdGhlIHBhc3N3b3JkLCBpbiBhbnkgY2FzZVxuICBpZiAoX3VzZXJuYW1lICE9IF9wYXNzd29yZCAmJiBfdXNlcm5hbWUuc3BsaXQoJ0AnLDEpWzBdICE9IF9wYXNzd29yZCkge1xuICAgIHJ1bGVzWyd1c2VybmFtZSddID0gdHJ1ZTtcbiAgfVxuICAvLyBsZW5ndGggPiA4IGNoYXJhY3RlcnNcbiAgaWYgKHBhc3N3b3JkICYmIHBhc3N3b3JkLmxlbmd0aCA+PSA4KSB7XG4gICAgcnVsZXNbJ2xlbmd0aCddID0gdHJ1ZTtcbiAgfVxuICAvLyBVcHBlcmNhc2UsIExvd2VyY2FzZSwgYW5kIE51bWJlcnNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXNzd29yZC5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0ZXN0ID0gcGFzc3dvcmQuY2hhckF0KGkpO1xuICAgIC8vIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zODE2OTA1L2NoZWNraW5nLWlmLWEtc3RyaW5nLXN0YXJ0cy13aXRoLWEtbG93ZXJjYXNlLWxldHRlclxuICAgIGlmICh0ZXN0ID09PSB0ZXN0LnRvTG93ZXJDYXNlKCkgJiYgdGVzdCAhPT0gdGVzdC50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAvLyBsb3dlcmNhc2UgZm91bmRcbiAgICAgIHJ1bGVzWydsb3dlciddID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGVzdCA9PT0gdGVzdC50b1VwcGVyQ2FzZSgpICYmIHRlc3QgIT09IHRlc3QudG9Mb3dlckNhc2UoKSkge1xuICAgICAgcnVsZXNbJ3VwcGVyJ10gPSB0cnVlO1xuICAgIH1cbiAgICAvLyBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTgwODIvdmFsaWRhdGUtbnVtYmVycy1pbi1qYXZhc2NyaXB0LWlzbnVtZXJpY1xuICAgIGVsc2UgaWYgKCFpc05hTihwYXJzZUZsb2F0KHRlc3QpKSAmJiBpc0Zpbml0ZSh0ZXN0KSkge1xuICAgICAgcnVsZXNbJ251bWJlciddID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLy8gY2hlY2sgZm9yIHN5bWJvbHNcbiAgaWYgKC8uKlteXFx3XFxzXS4qLy50ZXN0KHBhc3N3b3JkKSkge1xuICAgIHJ1bGVzWydzeW1ib2wnXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHJ1bGVzO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gbmF2aWdhdGUgbGlua3Mgd2l0aGluIGJhY2tib25lXG4gKiBpbnN0ZWFkIG9mIHJlbG9hZGluZyB0aGUgd2hvbGUgcGFnZSB0aHJvdWdoIGEgaGFyZCBsaW5rLlxuICogVHlwaWNhbGx5IHVzZWQgd2l0aCB0aGUgYGV2ZW50czoge31gIGhhbmRsZXIgb2YgYmFja2JvbmVcbiAqIHN1Y2ggYXMgJ2NsaWNrIC5saW5rLWJhY2tib25lJyA6IGxpbmtCYWNrYm9uZVxuICogQHBhcmFtIGUgdGhlIGV2ZW50IGZpcmVkIGJ5IGpxdWVyeS9iYWNrYm9uZVxuICovXG5nbG9iYWwubGlua0JhY2tib25lID0gZnVuY3Rpb24gKGUpIHtcbiAgLy8gaWYgbWV0YSBvciBjb250cm9sIGlzIGhlbGQsIG9yIGlmIHRoZSBtaWRkbGUgbW91c2UgYnV0dG9uIGlzIHByZXNzZWQsXG4gIC8vIGxldCB0aGUgbGluayBwcm9jZXNzIG5vcm1hbGx5LlxuICAvLyBlZzogb3BlbiBhIG5ldyB0YWIgb3Igd2luZG93IGJhc2VkIG9uIHRoZSBicm93c2VyIHByZWZzXG4gIGlmICgoZS5tZXRhS2V5ID09PSB0cnVlKSB8fCAoZS5jdHJsS2V5ID09PSB0cnVlKSB8fCAoZS53aGljaCA9PSAyKSkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBvdGhlcndpc2UgY29udGFpbiB0aGUgbGluayB3aXRoaW4gYmFja2JvbmVcbiAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgdmFyIGhyZWYgPSAkKGUuY3VycmVudFRhcmdldCkuYXR0cignaHJlZicpO1xuICBCYWNrYm9uZS5oaXN0b3J5Lm5hdmlnYXRlKGhyZWYsIHsgdHJpZ2dlcjogdHJ1ZSB9KTtcbn07XG4iLCIvKiFcbiAqIGpRdWVyeS5zZWxlY3Rpb24gLSBqUXVlcnkgUGx1Z2luXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTQgSVdBU0FLSSBLb2ppIChAbWFkYXBhamEpLlxuICogaHR0cDovL2Jsb2cubWFkYXBhamEubmV0L1xuICogVW5kZXIgVGhlIE1JVCBMaWNlbnNlXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXG4gKiBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbiAqIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuICogZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4gKiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbiAqIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICogTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkVcbiAqIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT05cbiAqIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuICogV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cbihmdW5jdGlvbigkLCB3aW4sIGRvYykge1xuICAgIC8qKlxuICAgICAqIGdldCBjYXJldCBzdGF0dXMgb2YgdGhlIHNlbGVjdGlvbiBvZiB0aGUgZWxlbWVudFxuICAgICAqXG4gICAgICogQHBhcmFtICAge0VsZW1lbnR9ICAgZWxlbWVudCAgICAgICAgIHRhcmdldCBET00gZWxlbWVudFxuICAgICAqIEByZXR1cm4gIHtPYmplY3R9ICAgIHJldHVyblxuICAgICAqIEByZXR1cm4gIHtTdHJpbmd9ICAgIHJldHVybi50ZXh0ICAgICBzZWxlY3RlZCB0ZXh0XG4gICAgICogQHJldHVybiAge051bWJlcn0gICAgcmV0dXJuLnN0YXJ0ICAgIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBzZWxlY3Rpb25cbiAgICAgKiBAcmV0dXJuICB7TnVtYmVyfSAgICByZXR1cm4uZW5kICAgICAgZW5kIHBvc2l0aW9uIG9mIHRoZSBzZWxlY3Rpb25cbiAgICAgKi9cbiAgICB2YXIgX2dldENhcmV0SW5mbyA9IGZ1bmN0aW9uKGVsZW1lbnQpe1xuICAgICAgICB2YXIgcmVzID0ge1xuICAgICAgICAgICAgdGV4dDogJycsXG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGVuZDogMFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghZWxlbWVudC52YWx1ZSkge1xuICAgICAgICAgICAgLyogbm8gdmFsdWUgb3IgZW1wdHkgc3RyaW5nICovXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh3aW4uZ2V0U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgLyogZXhjZXB0IElFICovXG4gICAgICAgICAgICAgICAgcmVzLnN0YXJ0ID0gZWxlbWVudC5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgICAgICAgICByZXMuZW5kID0gZWxlbWVudC5zZWxlY3Rpb25FbmQ7XG4gICAgICAgICAgICAgICAgcmVzLnRleHQgPSBlbGVtZW50LnZhbHVlLnNsaWNlKHJlcy5zdGFydCwgcmVzLmVuZCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRvYy5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAvKiBmb3IgSUUgKi9cbiAgICAgICAgICAgICAgICBlbGVtZW50LmZvY3VzKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBkb2Muc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCksXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlMiA9IGRvYy5ib2R5LmNyZWF0ZVRleHRSYW5nZSgpLFxuICAgICAgICAgICAgICAgICAgICB0bXBMZW5ndGg7XG5cbiAgICAgICAgICAgICAgICByZXMudGV4dCA9IHJhbmdlLnRleHQ7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByYW5nZTIubW92ZVRvRWxlbWVudFRleHQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlMi5zZXRFbmRQb2ludCgnU3RhcnRUb1N0YXJ0JywgcmFuZ2UpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UyID0gZWxlbWVudC5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UyLnNldEVuZFBvaW50KCdTdGFydFRvU3RhcnQnLCByYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzLnN0YXJ0ID0gZWxlbWVudC52YWx1ZS5sZW5ndGggLSByYW5nZTIudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCA9IHJlcy5zdGFydCArIHJhbmdlLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvKiBnaXZlIHVwICovXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjYXJldCBvcGVyYXRpb24gZm9yIHRoZSBlbGVtZW50XG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB2YXIgX0NhcmV0T3BlcmF0aW9uID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IGNhcmV0IHBvc2l0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAgIHtFbGVtZW50fSAgIGVsZW1lbnQgICAgICAgICB0YXJnZXQgZWxlbWVudFxuICAgICAgICAgKiBAcmV0dXJuICB7T2JqZWN0fSAgICByZXR1cm5cbiAgICAgICAgICogQHJldHVybiAge051bWJlcn0gICAgcmV0dXJuLnN0YXJ0ICAgIHN0YXJ0IHBvc2l0aW9uIGZvciB0aGUgc2VsZWN0aW9uXG4gICAgICAgICAqIEByZXR1cm4gIHtOdW1iZXJ9ICAgIHJldHVybi5lbmQgICAgICBlbmQgcG9zaXRpb24gZm9yIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIGdldFBvczogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHRtcCA9IF9nZXRDYXJldEluZm8oZWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4ge3N0YXJ0OiB0bXAuc3RhcnQsIGVuZDogdG1wLmVuZH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNldCBjYXJldCBwb3NpdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gICB7RWxlbWVudH0gICBlbGVtZW50ICAgICAgICAgdGFyZ2V0IGVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtICAge09iamVjdH0gICAgdG9SYW5nZSAgICAgICAgIGNhcmV0IHBvc2l0aW9uXG4gICAgICAgICAqIEBwYXJhbSAgIHtOdW1iZXJ9ICAgIHRvUmFuZ2Uuc3RhcnQgICBzdGFydCBwb3NpdGlvbiBmb3IgdGhlIHNlbGVjdGlvblxuICAgICAgICAgKiBAcGFyYW0gICB7TnVtYmVyfSAgICB0b1JhbmdlLmVuZCAgICAgZW5kIHBvc2l0aW9uIGZvciB0aGUgc2VsZWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgIGNhcmV0ICAgICAgICAgICBjYXJldCBtb2RlOiBhbnkgb2YgdGhlIGZvbGxvd2luZzogXCJrZWVwXCIgfCBcInN0YXJ0XCIgfCBcImVuZFwiXG4gICAgICAgICAqL1xuICAgICAgICBzZXRQb3M6IGZ1bmN0aW9uKGVsZW1lbnQsIHRvUmFuZ2UsIGNhcmV0KSB7XG4gICAgICAgICAgICBjYXJldCA9IHRoaXMuX2NhcmV0TW9kZShjYXJldCk7XG5cbiAgICAgICAgICAgIGlmIChjYXJldCA9PSAnc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgdG9SYW5nZS5lbmQgPSB0b1JhbmdlLnN0YXJ0O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjYXJldCA9PSAnZW5kJykge1xuICAgICAgICAgICAgICAgIHRvUmFuZ2Uuc3RhcnQgPSB0b1JhbmdlLmVuZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5jcmVhdGVUZXh0UmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gZWxlbWVudC5jcmVhdGVUZXh0UmFuZ2UoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAod2luLm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwibXNpZVwiKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1JhbmdlLnN0YXJ0ID0gZWxlbWVudC52YWx1ZS5zdWJzdHIoMCwgdG9SYW5nZS5zdGFydCkucmVwbGFjZSgvXFxyL2csICcnKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1JhbmdlLmVuZCA9IGVsZW1lbnQudmFsdWUuc3Vic3RyKDAsIHRvUmFuZ2UuZW5kKS5yZXBsYWNlKC9cXHIvZywgJycpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIHRvUmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCB0b1JhbmdlLmVuZCAtIHRvUmFuZ2Uuc3RhcnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNlbGVjdCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5zZXRTZWxlY3Rpb25SYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnNldFNlbGVjdGlvblJhbmdlKHRvUmFuZ2Uuc3RhcnQsIHRvUmFuZ2UuZW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLyogZ2l2ZSB1cCAqL1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgc2VsZWN0ZWQgdGV4dFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gICB7RWxlbWVudH0gICBlbGVtZW50ICAgICAgICAgdGFyZ2V0IGVsZW1lbnRcbiAgICAgICAgICogQHJldHVybiAge1N0cmluZ30gICAgcmV0dXJuICAgICAgICAgIHNlbGVjdGVkIHRleHRcbiAgICAgICAgICovXG4gICAgICAgIGdldFRleHQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBfZ2V0Q2FyZXRJbmZvKGVsZW1lbnQpLnRleHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCBjYXJldCBtb2RlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgIGNhcmV0ICAgICAgICAgICBjYXJldCBtb2RlXG4gICAgICAgICAqIEByZXR1cm4gIHtTdHJpbmd9ICAgIHJldHVybiAgICAgICAgICBhbnkgb2YgdGhlIGZvbGxvd2luZzogXCJrZWVwXCIgfCBcInN0YXJ0XCIgfCBcImVuZFwiXG4gICAgICAgICAqL1xuICAgICAgICBfY2FyZXRNb2RlOiBmdW5jdGlvbihjYXJldCkge1xuICAgICAgICAgICAgY2FyZXQgPSBjYXJldCB8fCBcImtlZXBcIjtcbiAgICAgICAgICAgIGlmIChjYXJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjYXJldCA9ICdlbmQnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKGNhcmV0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAna2VlcCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RhcnQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgY2FyZXQgPSAna2VlcCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjYXJldDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogcmVwbGFjZSBzZWxlY3RlZCB0ZXh0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAgIHtFbGVtZW50fSAgIGVsZW1lbnQgICAgICAgICB0YXJnZXQgZWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0gICB7U3RyaW5nfSAgICB0ZXh0ICAgICAgICAgICAgcmVwbGFjZW1lbnQgdGV4dFxuICAgICAgICAgKiBAcGFyYW0gICB7U3RyaW5nfSAgICBjYXJldCAgICAgICAgICAgY2FyZXQgbW9kZTogYW55IG9mIHRoZSBmb2xsb3dpbmc6IFwia2VlcFwiIHwgXCJzdGFydFwiIHwgXCJlbmRcIlxuICAgICAgICAgKi9cbiAgICAgICAgcmVwbGFjZTogZnVuY3Rpb24oZWxlbWVudCwgdGV4dCwgY2FyZXQpIHtcbiAgICAgICAgICAgIHZhciB0bXAgPSBfZ2V0Q2FyZXRJbmZvKGVsZW1lbnQpLFxuICAgICAgICAgICAgICAgIG9yaWcgPSBlbGVtZW50LnZhbHVlLFxuICAgICAgICAgICAgICAgIHBvcyA9ICQoZWxlbWVudCkuc2Nyb2xsVG9wKCksXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSB7c3RhcnQ6IHRtcC5zdGFydCwgZW5kOiB0bXAuc3RhcnQgKyB0ZXh0Lmxlbmd0aH07XG5cbiAgICAgICAgICAgIGVsZW1lbnQudmFsdWUgPSBvcmlnLnN1YnN0cigwLCB0bXAuc3RhcnQpICsgdGV4dCArIG9yaWcuc3Vic3RyKHRtcC5lbmQpO1xuXG4gICAgICAgICAgICAkKGVsZW1lbnQpLnNjcm9sbFRvcChwb3MpO1xuICAgICAgICAgICAgdGhpcy5zZXRQb3MoZWxlbWVudCwgcmFuZ2UsIGNhcmV0KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogaW5zZXJ0IGJlZm9yZSB0aGUgc2VsZWN0ZWQgdGV4dFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gICB7RWxlbWVudH0gICBlbGVtZW50ICAgICAgICAgdGFyZ2V0IGVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtICAge1N0cmluZ30gICAgdGV4dCAgICAgICAgICAgIGluc2VydGlvbiB0ZXh0XG4gICAgICAgICAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgIGNhcmV0ICAgICAgICAgICBjYXJldCBtb2RlOiBhbnkgb2YgdGhlIGZvbGxvd2luZzogXCJrZWVwXCIgfCBcInN0YXJ0XCIgfCBcImVuZFwiXG4gICAgICAgICAqL1xuICAgICAgICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uKGVsZW1lbnQsIHRleHQsIGNhcmV0KSB7XG4gICAgICAgICAgICB2YXIgdG1wID0gX2dldENhcmV0SW5mbyhlbGVtZW50KSxcbiAgICAgICAgICAgICAgICBvcmlnID0gZWxlbWVudC52YWx1ZSxcbiAgICAgICAgICAgICAgICBwb3MgPSAkKGVsZW1lbnQpLnNjcm9sbFRvcCgpLFxuICAgICAgICAgICAgICAgIHJhbmdlID0ge3N0YXJ0OiB0bXAuc3RhcnQgKyB0ZXh0Lmxlbmd0aCwgZW5kOiB0bXAuZW5kICsgdGV4dC5sZW5ndGh9O1xuXG4gICAgICAgICAgICBlbGVtZW50LnZhbHVlID0gb3JpZy5zdWJzdHIoMCwgdG1wLnN0YXJ0KSArIHRleHQgKyBvcmlnLnN1YnN0cih0bXAuc3RhcnQpO1xuXG4gICAgICAgICAgICAkKGVsZW1lbnQpLnNjcm9sbFRvcChwb3MpO1xuICAgICAgICAgICAgdGhpcy5zZXRQb3MoZWxlbWVudCwgcmFuZ2UsIGNhcmV0KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogaW5zZXJ0IGFmdGVyIHRoZSBzZWxlY3RlZCB0ZXh0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAgIHtFbGVtZW50fSAgIGVsZW1lbnQgICAgICAgICB0YXJnZXQgZWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0gICB7U3RyaW5nfSAgICB0ZXh0ICAgICAgICAgICAgaW5zZXJ0aW9uIHRleHRcbiAgICAgICAgICogQHBhcmFtICAge1N0cmluZ30gICAgY2FyZXQgICAgICAgICAgIGNhcmV0IG1vZGU6IGFueSBvZiB0aGUgZm9sbG93aW5nOiBcImtlZXBcIiB8IFwic3RhcnRcIiB8IFwiZW5kXCJcbiAgICAgICAgICovXG4gICAgICAgIGluc2VydEFmdGVyOiBmdW5jdGlvbihlbGVtZW50LCB0ZXh0LCBjYXJldCkge1xuICAgICAgICAgICAgdmFyIHRtcCA9IF9nZXRDYXJldEluZm8oZWxlbWVudCksXG4gICAgICAgICAgICAgICAgb3JpZyA9IGVsZW1lbnQudmFsdWUsXG4gICAgICAgICAgICAgICAgcG9zID0gJChlbGVtZW50KS5zY3JvbGxUb3AoKSxcbiAgICAgICAgICAgICAgICByYW5nZSA9IHtzdGFydDogdG1wLnN0YXJ0LCBlbmQ6IHRtcC5lbmR9O1xuXG4gICAgICAgICAgICBlbGVtZW50LnZhbHVlID0gb3JpZy5zdWJzdHIoMCwgdG1wLmVuZCkgKyB0ZXh0ICsgb3JpZy5zdWJzdHIodG1wLmVuZCk7XG5cbiAgICAgICAgICAgICQoZWxlbWVudCkuc2Nyb2xsVG9wKHBvcyk7XG4gICAgICAgICAgICB0aGlzLnNldFBvcyhlbGVtZW50LCByYW5nZSwgY2FyZXQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qIGFkZCBqUXVlcnkuc2VsZWN0aW9uICovXG4gICAgJC5leHRlbmQoe1xuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IHNlbGVjdGVkIHRleHQgb24gdGhlIHdpbmRvd1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gICB7U3RyaW5nfSAgICBtb2RlICAgICAgICAgICAgc2VsZWN0aW9uIG1vZGU6IGFueSBvZiB0aGUgZm9sbG93aW5nOiBcInRleHRcIiB8IFwiaHRtbFwiXG4gICAgICAgICAqIEByZXR1cm4gIHtTdHJpbmd9ICAgIHJldHVyblxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0aW9uOiBmdW5jdGlvbihtb2RlKSB7XG4gICAgICAgICAgICB2YXIgZ2V0VGV4dCA9ICgobW9kZSB8fCAndGV4dCcpLnRvTG93ZXJDYXNlKCkgPT0gJ3RleHQnKTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAod2luLmdldFNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0VGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW4uZ2V0U2VsZWN0aW9uKCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldCBodG1sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VsID0gd2luLmdldFNlbGVjdGlvbigpLCByYW5nZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbC5nZXRSYW5nZUF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBzZWwuZ2V0UmFuZ2VBdCgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBkb2MuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydChzZWwuYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkKCc8ZGl2PjwvZGl2PicpLmFwcGVuZChyYW5nZS5jbG9uZUNvbnRlbnRzKCkpLmh0bWwoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZG9jLnNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0VGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2Muc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCkudGV4dDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldCBodG1sXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9jLnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpLmh0bWxUZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8qIGdpdmUgdXAgKi9cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKiBhZGQgc2VsZWN0aW9uICovXG4gICAgJC5mbi5leHRlbmQoe1xuICAgICAgICBzZWxlY3Rpb246IGZ1bmN0aW9uKG1vZGUsIG9wdHMpIHtcbiAgICAgICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBzZWxlY3Rpb24oJ2dldFBvcycpXG4gICAgICAgICAgICAgICAgICogZ2V0IGNhcmV0IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuICB7T2JqZWN0fSAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuICB7TnVtYmVyfSAgICByZXR1cm4uc3RhcnQgICAgc3RhcnQgcG9zaXRpb24gZm9yIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuICB7TnVtYmVyfSAgICByZXR1cm4uZW5kICAgICAgZW5kIHBvc2l0aW9uIGZvciB0aGUgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY2FzZSAnZ2V0UG9zJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9DYXJldE9wZXJhdGlvbi5nZXRQb3ModGhpc1swXSk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBzZWxlY3Rpb24oJ3NldFBvcycsIG9wdHMpXG4gICAgICAgICAgICAgICAgICogc2V0IGNhcmV0IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gICB7TnVtYmVyfSAgICBvcHRzLnN0YXJ0ICAgICAgc3RhcnQgcG9zaXRpb24gZm9yIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gICB7TnVtYmVyfSAgICBvcHRzLmVuZCAgICAgICAgZW5kIHBvc2l0aW9uIGZvciB0aGUgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY2FzZSAnc2V0UG9zJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9DYXJldE9wZXJhdGlvbi5zZXRQb3ModGhpcywgb3B0cyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogc2VsZWN0aW9uKCdyZXBsYWNlJywgb3B0cylcbiAgICAgICAgICAgICAgICAgKiByZXBsYWNlIHRoZSBzZWxlY3RlZCB0ZXh0XG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gICB7U3RyaW5nfSAgICBvcHRzLnRleHQgICAgICAgICAgICByZXBsYWNlbWVudCB0ZXh0XG4gICAgICAgICAgICAgICAgICogQHBhcmFtICAge1N0cmluZ30gICAgb3B0cy5jYXJldCAgICAgICAgICAgY2FyZXQgbW9kZTogYW55IG9mIHRoZSBmb2xsb3dpbmc6IFwia2VlcFwiIHwgXCJzdGFydFwiIHwgXCJlbmRcIlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JlcGxhY2UnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX0NhcmV0T3BlcmF0aW9uLnJlcGxhY2UodGhpcywgb3B0cy50ZXh0LCBvcHRzLmNhcmV0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBzZWxlY3Rpb24oJ2luc2VydCcsIG9wdHMpXG4gICAgICAgICAgICAgICAgICogaW5zZXJ0IGJlZm9yZS9hZnRlciB0aGUgc2VsZWN0ZWQgdGV4dFxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHBhcmFtICAge1N0cmluZ30gICAgb3B0cy50ZXh0ICAgICAgICAgICAgaW5zZXJ0aW9uIHRleHRcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gICB7U3RyaW5nfSAgICBvcHRzLmNhcmV0ICAgICAgICAgICBjYXJldCBtb2RlOiBhbnkgb2YgdGhlIGZvbGxvd2luZzogXCJrZWVwXCIgfCBcInN0YXJ0XCIgfCBcImVuZFwiXG4gICAgICAgICAgICAgICAgICogQHBhcmFtICAge1N0cmluZ30gICAgb3B0cy5tb2RlICAgICAgICAgICAgaW5zZXJ0aW9uIG1vZGU6IGFueSBvZiB0aGUgZm9sbG93aW5nOiBcImJlZm9yZVwiIHwgXCJhZnRlclwiXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY2FzZSAnaW5zZXJ0JzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLm1vZGUgPT0gJ2JlZm9yZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfQ2FyZXRPcGVyYXRpb24uaW5zZXJ0QmVmb3JlKHRoaXMsIG9wdHMudGV4dCwgb3B0cy5jYXJldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9DYXJldE9wZXJhdGlvbi5pbnNlcnRBZnRlcih0aGlzLCBvcHRzLnRleHQsIG9wdHMuY2FyZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIHNlbGVjdGlvbignZ2V0JylcbiAgICAgICAgICAgICAgICAgKiBnZXQgc2VsZWN0ZWQgdGV4dFxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHJldHVybiAge1N0cmluZ30gICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY2FzZSAnZ2V0JzpcbiAgICAgICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfQ2FyZXRPcGVyYXRpb24uZ2V0VGV4dCh0aGlzWzBdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9KTtcbn0pKGpRdWVyeSwgd2luZG93LCB3aW5kb3cuZG9jdW1lbnQpO1xuIiwiLyoqXG4gKiBUaW1lYWdvIGlzIGEgalF1ZXJ5IHBsdWdpbiB0aGF0IG1ha2VzIGl0IGVhc3kgdG8gc3VwcG9ydCBhdXRvbWF0aWNhbGx5XG4gKiB1cGRhdGluZyBmdXp6eSB0aW1lc3RhbXBzIChlLmcuIFwiNCBtaW51dGVzIGFnb1wiIG9yIFwiYWJvdXQgMSBkYXkgYWdvXCIpLlxuICpcbiAqIEBuYW1lIHRpbWVhZ29cbiAqIEB2ZXJzaW9uIDEuMy4wXG4gKiBAcmVxdWlyZXMgalF1ZXJ5IHYxLjIuMytcbiAqIEBhdXRob3IgUnlhbiBNY0dlYXJ5XG4gKiBAbGljZW5zZSBNSVQgTGljZW5zZSAtIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gKlxuICogRm9yIHVzYWdlIGFuZCBleGFtcGxlcywgdmlzaXQ6XG4gKiBodHRwOi8vdGltZWFnby55YXJwLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDgtMjAxMywgUnlhbiBNY0dlYXJ5IChyeWFuIC1bYXRdLSBtY2dlYXJ5IFsqZG90Kl0gb3JnKVxuICovXG5cbihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgIGRlZmluZShbJ2pxdWVyeSddLCBmYWN0b3J5KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBCcm93c2VyIGdsb2JhbHNcbiAgICBmYWN0b3J5KGpRdWVyeSk7XG4gIH1cbn0oZnVuY3Rpb24gKCQpIHtcbiAgJC50aW1lYWdvID0gZnVuY3Rpb24odGltZXN0YW1wKSB7XG4gICAgaWYgKHRpbWVzdGFtcCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiBpbldvcmRzKHRpbWVzdGFtcCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGltZXN0YW1wID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gaW5Xb3JkcygkLnRpbWVhZ28ucGFyc2UodGltZXN0YW1wKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGltZXN0YW1wID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gaW5Xb3JkcyhuZXcgRGF0ZSh0aW1lc3RhbXApKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGluV29yZHMoJC50aW1lYWdvLmRhdGV0aW1lKHRpbWVzdGFtcCkpO1xuICAgIH1cbiAgfTtcbiAgdmFyICR0ID0gJC50aW1lYWdvO1xuXG4gICQuZXh0ZW5kKCQudGltZWFnbywge1xuICAgIHNldHRpbmdzOiB7XG4gICAgICByZWZyZXNoTWlsbGlzOiA2MDAwMCxcbiAgICAgIGFsbG93RnV0dXJlOiBmYWxzZSxcbiAgICAgIGxvY2FsZVRpdGxlOiBmYWxzZSxcbiAgICAgIGN1dG9mZjogMCxcbiAgICAgIHN0cmluZ3M6IHtcbiAgICAgICAgcHJlZml4QWdvOiBudWxsLFxuICAgICAgICBwcmVmaXhGcm9tTm93OiBudWxsLFxuICAgICAgICBzdWZmaXhBZ286IFwiYWdvXCIsXG4gICAgICAgIHN1ZmZpeEZyb21Ob3c6IFwiZnJvbSBub3dcIixcbiAgICAgICAgc2Vjb25kczogXCJsZXNzIHRoYW4gYSBtaW51dGVcIixcbiAgICAgICAgbWludXRlOiBcImFib3V0IGEgbWludXRlXCIsXG4gICAgICAgIG1pbnV0ZXM6IFwiJWQgbWludXRlc1wiLFxuICAgICAgICBob3VyOiBcImFib3V0IGFuIGhvdXJcIixcbiAgICAgICAgaG91cnM6IFwiYWJvdXQgJWQgaG91cnNcIixcbiAgICAgICAgZGF5OiBcImEgZGF5XCIsXG4gICAgICAgIGRheXM6IFwiJWQgZGF5c1wiLFxuICAgICAgICBtb250aDogXCJhYm91dCBhIG1vbnRoXCIsXG4gICAgICAgIG1vbnRoczogXCIlZCBtb250aHNcIixcbiAgICAgICAgeWVhcjogXCJhYm91dCBhIHllYXJcIixcbiAgICAgICAgeWVhcnM6IFwiJWQgeWVhcnNcIixcbiAgICAgICAgd29yZFNlcGFyYXRvcjogXCIgXCIsXG4gICAgICAgIG51bWJlcnM6IFtdXG4gICAgICB9XG4gICAgfSxcbiAgICBpbldvcmRzOiBmdW5jdGlvbihkaXN0YW5jZU1pbGxpcykge1xuICAgICAgdmFyICRsID0gdGhpcy5zZXR0aW5ncy5zdHJpbmdzO1xuICAgICAgdmFyIHByZWZpeCA9ICRsLnByZWZpeEFnbztcbiAgICAgIHZhciBzdWZmaXggPSAkbC5zdWZmaXhBZ287XG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5hbGxvd0Z1dHVyZSkge1xuICAgICAgICBpZiAoZGlzdGFuY2VNaWxsaXMgPCAwKSB7XG4gICAgICAgICAgcHJlZml4ID0gJGwucHJlZml4RnJvbU5vdztcbiAgICAgICAgICBzdWZmaXggPSAkbC5zdWZmaXhGcm9tTm93O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWNvbmRzID0gTWF0aC5hYnMoZGlzdGFuY2VNaWxsaXMpIC8gMTAwMDtcbiAgICAgIHZhciBtaW51dGVzID0gc2Vjb25kcyAvIDYwO1xuICAgICAgdmFyIGhvdXJzID0gbWludXRlcyAvIDYwO1xuICAgICAgdmFyIGRheXMgPSBob3VycyAvIDI0O1xuICAgICAgdmFyIHllYXJzID0gZGF5cyAvIDM2NTtcblxuICAgICAgZnVuY3Rpb24gc3Vic3RpdHV0ZShzdHJpbmdPckZ1bmN0aW9uLCBudW1iZXIpIHtcbiAgICAgICAgdmFyIHN0cmluZyA9ICQuaXNGdW5jdGlvbihzdHJpbmdPckZ1bmN0aW9uKSA/IHN0cmluZ09yRnVuY3Rpb24obnVtYmVyLCBkaXN0YW5jZU1pbGxpcykgOiBzdHJpbmdPckZ1bmN0aW9uO1xuICAgICAgICB2YXIgdmFsdWUgPSAoJGwubnVtYmVycyAmJiAkbC5udW1iZXJzW251bWJlcl0pIHx8IG51bWJlcjtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8lZC9pLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB3b3JkcyA9IHNlY29uZHMgPCA0NSAmJiBzdWJzdGl0dXRlKCRsLnNlY29uZHMsIE1hdGgucm91bmQoc2Vjb25kcykpIHx8XG4gICAgICAgIHNlY29uZHMgPCA5MCAmJiBzdWJzdGl0dXRlKCRsLm1pbnV0ZSwgMSkgfHxcbiAgICAgICAgbWludXRlcyA8IDQ1ICYmIHN1YnN0aXR1dGUoJGwubWludXRlcywgTWF0aC5yb3VuZChtaW51dGVzKSkgfHxcbiAgICAgICAgbWludXRlcyA8IDkwICYmIHN1YnN0aXR1dGUoJGwuaG91ciwgMSkgfHxcbiAgICAgICAgaG91cnMgPCAyNCAmJiBzdWJzdGl0dXRlKCRsLmhvdXJzLCBNYXRoLnJvdW5kKGhvdXJzKSkgfHxcbiAgICAgICAgaG91cnMgPCA0MiAmJiBzdWJzdGl0dXRlKCRsLmRheSwgMSkgfHxcbiAgICAgICAgZGF5cyA8IDMwICYmIHN1YnN0aXR1dGUoJGwuZGF5cywgTWF0aC5yb3VuZChkYXlzKSkgfHxcbiAgICAgICAgZGF5cyA8IDQ1ICYmIHN1YnN0aXR1dGUoJGwubW9udGgsIDEpIHx8XG4gICAgICAgIGRheXMgPCAzNjUgJiYgc3Vic3RpdHV0ZSgkbC5tb250aHMsIE1hdGgucm91bmQoZGF5cyAvIDMwKSkgfHxcbiAgICAgICAgeWVhcnMgPCAxLjUgJiYgc3Vic3RpdHV0ZSgkbC55ZWFyLCAxKSB8fFxuICAgICAgICBzdWJzdGl0dXRlKCRsLnllYXJzLCBNYXRoLnJvdW5kKHllYXJzKSk7XG5cbiAgICAgIHZhciBzZXBhcmF0b3IgPSAkbC53b3JkU2VwYXJhdG9yIHx8IFwiXCI7XG4gICAgICBpZiAoJGwud29yZFNlcGFyYXRvciA9PT0gdW5kZWZpbmVkKSB7IHNlcGFyYXRvciA9IFwiIFwiOyB9XG4gICAgICByZXR1cm4gJC50cmltKFtwcmVmaXgsIHdvcmRzLCBzdWZmaXhdLmpvaW4oc2VwYXJhdG9yKSk7XG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24oaXNvODYwMSkge1xuICAgICAgdmFyIHMgPSAkLnRyaW0oaXNvODYwMSk7XG4gICAgICBzID0gcy5yZXBsYWNlKC9cXC5cXGQrLyxcIlwiKTsgLy8gcmVtb3ZlIG1pbGxpc2Vjb25kc1xuICAgICAgcyA9IHMucmVwbGFjZSgvLS8sXCIvXCIpLnJlcGxhY2UoLy0vLFwiL1wiKTtcbiAgICAgIHMgPSBzLnJlcGxhY2UoL1QvLFwiIFwiKS5yZXBsYWNlKC9aLyxcIiBVVENcIik7XG4gICAgICBzID0gcy5yZXBsYWNlKC8oW1xcK1xcLV1cXGRcXGQpXFw6PyhcXGRcXGQpLyxcIiAkMSQyXCIpOyAvLyAtMDQ6MDAgLT4gLTA0MDBcbiAgICAgIHJldHVybiBuZXcgRGF0ZShzKTtcbiAgICB9LFxuICAgIGRhdGV0aW1lOiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICB2YXIgaXNvODYwMSA9ICR0LmlzVGltZShlbGVtKSA/ICQoZWxlbSkuYXR0cihcImRhdGV0aW1lXCIpIDogJChlbGVtKS5hdHRyKFwidGl0bGVcIik7XG4gICAgICByZXR1cm4gJHQucGFyc2UoaXNvODYwMSk7XG4gICAgfSxcbiAgICBpc1RpbWU6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgIC8vIGpRdWVyeSdzIGBpcygpYCBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoIEhUTUw1IGluIElFXG4gICAgICByZXR1cm4gJChlbGVtKS5nZXQoMCkudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInRpbWVcIjsgLy8gJChlbGVtKS5pcyhcInRpbWVcIik7XG4gICAgfVxuICB9KTtcblxuICAvLyBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgY2FsbGVkIHZpYSAkKGVsKS50aW1lYWdvKCdhY3Rpb24nKVxuICAvLyBpbml0IGlzIGRlZmF1bHQgd2hlbiBubyBhY3Rpb24gaXMgZ2l2ZW5cbiAgLy8gZnVuY3Rpb25zIGFyZSBjYWxsZWQgd2l0aCBjb250ZXh0IG9mIGEgc2luZ2xlIGVsZW1lbnRcbiAgdmFyIGZ1bmN0aW9ucyA9IHtcbiAgICBpbml0OiBmdW5jdGlvbigpe1xuICAgICAgdmFyIHJlZnJlc2hfZWwgPSAkLnByb3h5KHJlZnJlc2gsIHRoaXMpO1xuICAgICAgcmVmcmVzaF9lbCgpO1xuICAgICAgdmFyICRzID0gJHQuc2V0dGluZ3M7XG4gICAgICBpZiAoJHMucmVmcmVzaE1pbGxpcyA+IDApIHtcbiAgICAgICAgc2V0SW50ZXJ2YWwocmVmcmVzaF9lbCwgJHMucmVmcmVzaE1pbGxpcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uKHRpbWUpe1xuICAgICAgJCh0aGlzKS5kYXRhKCd0aW1lYWdvJywgeyBkYXRldGltZTogJHQucGFyc2UodGltZSkgfSk7XG4gICAgICByZWZyZXNoLmFwcGx5KHRoaXMpO1xuICAgIH0sXG4gICAgdXBkYXRlRnJvbURPTTogZnVuY3Rpb24oKXtcbiAgICAgICQodGhpcykuZGF0YSgndGltZWFnbycsIHsgZGF0ZXRpbWU6ICR0LnBhcnNlKCAkdC5pc1RpbWUodGhpcykgPyAkKHRoaXMpLmF0dHIoXCJkYXRldGltZVwiKSA6ICQodGhpcykuYXR0cihcInRpdGxlXCIpICkgfSk7XG4gICAgICByZWZyZXNoLmFwcGx5KHRoaXMpO1xuICAgIH1cbiAgfTtcblxuICAkLmZuLnRpbWVhZ28gPSBmdW5jdGlvbihhY3Rpb24sIG9wdGlvbnMpIHtcbiAgICB2YXIgZm4gPSBhY3Rpb24gPyBmdW5jdGlvbnNbYWN0aW9uXSA6IGZ1bmN0aW9ucy5pbml0O1xuICAgIGlmKCFmbil7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGZ1bmN0aW9uIG5hbWUgJ1wiKyBhY3Rpb24gK1wiJyBmb3IgdGltZWFnb1wiKTtcbiAgICB9XG4gICAgLy8gZWFjaCBvdmVyIG9iamVjdHMgaGVyZSBhbmQgY2FsbCB0aGUgcmVxdWVzdGVkIGZ1bmN0aW9uXG4gICAgdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICBmbi5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgdmFyIGRhdGEgPSBwcmVwYXJlRGF0YSh0aGlzKTtcbiAgICB2YXIgJHMgPSAkdC5zZXR0aW5ncztcblxuICAgIGlmICghaXNOYU4oZGF0YS5kYXRldGltZSkpIHtcbiAgICAgIGlmICggJHMuY3V0b2ZmID09IDAgfHwgZGlzdGFuY2UoZGF0YS5kYXRldGltZSkgPCAkcy5jdXRvZmYpIHtcbiAgICAgICAgJCh0aGlzKS50ZXh0KGluV29yZHMoZGF0YS5kYXRldGltZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmVEYXRhKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50ID0gJChlbGVtZW50KTtcbiAgICBpZiAoIWVsZW1lbnQuZGF0YShcInRpbWVhZ29cIikpIHtcbiAgICAgIGVsZW1lbnQuZGF0YShcInRpbWVhZ29cIiwgeyBkYXRldGltZTogJHQuZGF0ZXRpbWUoZWxlbWVudCkgfSk7XG4gICAgICB2YXIgdGV4dCA9ICQudHJpbShlbGVtZW50LnRleHQoKSk7XG4gICAgICBpZiAoJHQuc2V0dGluZ3MubG9jYWxlVGl0bGUpIHtcbiAgICAgICAgZWxlbWVudC5hdHRyKFwidGl0bGVcIiwgZWxlbWVudC5kYXRhKCd0aW1lYWdvJykuZGF0ZXRpbWUudG9Mb2NhbGVTdHJpbmcoKSk7XG4gICAgICB9IGVsc2UgaWYgKHRleHQubGVuZ3RoID4gMCAmJiAhKCR0LmlzVGltZShlbGVtZW50KSAmJiBlbGVtZW50LmF0dHIoXCJ0aXRsZVwiKSkpIHtcbiAgICAgICAgZWxlbWVudC5hdHRyKFwidGl0bGVcIiwgdGV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50LmRhdGEoXCJ0aW1lYWdvXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5Xb3JkcyhkYXRlKSB7XG4gICAgcmV0dXJuICR0LmluV29yZHMoZGlzdGFuY2UoZGF0ZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGlzdGFuY2UoZGF0ZSkge1xuICAgIHJldHVybiAobmV3IERhdGUoKS5nZXRUaW1lKCkgLSBkYXRlLmdldFRpbWUoKSk7XG4gIH1cblxuICAvLyBmaXggZm9yIElFNiBzdWNrYWdlXG4gIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhYmJyXCIpO1xuICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGltZVwiKTtcbn0pKTtcbiIsIi8qZ2xvYmFsIHNldEltbWVkaWF0ZTogZmFsc2UsIHNldFRpbWVvdXQ6IGZhbHNlLCBjb25zb2xlOiBmYWxzZSAqL1xuKGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBhc3luYyA9IHt9O1xuXG4gICAgLy8gZ2xvYmFsIG9uIHRoZSBzZXJ2ZXIsIHdpbmRvdyBpbiB0aGUgYnJvd3NlclxuICAgIHZhciByb290LCBwcmV2aW91c19hc3luYztcblxuICAgIHJvb3QgPSB0aGlzO1xuICAgIGlmIChyb290ICE9IG51bGwpIHtcbiAgICAgIHByZXZpb3VzX2FzeW5jID0gcm9vdC5hc3luYztcbiAgICB9XG5cbiAgICBhc3luYy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByb290LmFzeW5jID0gcHJldmlvdXNfYXN5bmM7XG4gICAgICAgIHJldHVybiBhc3luYztcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gb25seV9vbmNlKGZuKSB7XG4gICAgICAgIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGNhbGxlZCkgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbGJhY2sgd2FzIGFscmVhZHkgY2FsbGVkLlwiKTtcbiAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICBmbi5hcHBseShyb290LCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8vLyBjcm9zcy1icm93c2VyIGNvbXBhdGlibGl0eSBmdW5jdGlvbnMgLy8vL1xuXG4gICAgdmFyIF9lYWNoID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IpIHtcbiAgICAgICAgaWYgKGFyci5mb3JFYWNoKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyLmZvckVhY2goaXRlcmF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihhcnJbaV0sIGksIGFycik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIF9tYXAgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvcikge1xuICAgICAgICBpZiAoYXJyLm1hcCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyci5tYXAoaXRlcmF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIF9lYWNoKGFyciwgZnVuY3Rpb24gKHgsIGksIGEpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChpdGVyYXRvcih4LCBpLCBhKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuXG4gICAgdmFyIF9yZWR1Y2UgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgbWVtbykge1xuICAgICAgICBpZiAoYXJyLnJlZHVjZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFyci5yZWR1Y2UoaXRlcmF0b3IsIG1lbW8pO1xuICAgICAgICB9XG4gICAgICAgIF9lYWNoKGFyciwgZnVuY3Rpb24gKHgsIGksIGEpIHtcbiAgICAgICAgICAgIG1lbW8gPSBpdGVyYXRvcihtZW1vLCB4LCBpLCBhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtZW1vO1xuICAgIH07XG5cbiAgICB2YXIgX2tleXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cykge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfTtcblxuICAgIC8vLy8gZXhwb3J0ZWQgYXN5bmMgbW9kdWxlIGZ1bmN0aW9ucyAvLy8vXG5cbiAgICAvLy8vIG5leHRUaWNrIGltcGxlbWVudGF0aW9uIHdpdGggYnJvd3Nlci1jb21wYXRpYmxlIGZhbGxiYWNrIC8vLy9cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8ICEocHJvY2Vzcy5uZXh0VGljaykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGFzeW5jLm5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgLy8gbm90IGEgZGlyZWN0IGFsaWFzIGZvciBJRTEwIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoZm4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZSA9IGFzeW5jLm5leHRUaWNrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXN5bmMubmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUgPSBhc3luYy5uZXh0VGljaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXN5bmMubmV4dFRpY2sgPSBwcm9jZXNzLm5leHRUaWNrO1xuICAgICAgICBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAvLyBub3QgYSBkaXJlY3QgYWxpYXMgZm9yIElFMTAgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoZm4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZSA9IGFzeW5jLm5leHRUaWNrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMuZWFjaCA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICBpZiAoIWFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb21wbGV0ZWQgPSAwO1xuICAgICAgICBfZWFjaChhcnIsIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LCBvbmx5X29uY2UoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkID49IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGFzeW5jLmZvckVhY2ggPSBhc3luYy5lYWNoO1xuXG4gICAgYXN5bmMuZWFjaFNlcmllcyA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICBpZiAoIWFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb21wbGV0ZWQgPSAwO1xuICAgICAgICB2YXIgaXRlcmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKGFycltjb21wbGV0ZWRdLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPj0gYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaXRlcmF0ZSgpO1xuICAgIH07XG4gICAgYXN5bmMuZm9yRWFjaFNlcmllcyA9IGFzeW5jLmVhY2hTZXJpZXM7XG5cbiAgICBhc3luYy5lYWNoTGltaXQgPSBmdW5jdGlvbiAoYXJyLCBsaW1pdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBmbiA9IF9lYWNoTGltaXQobGltaXQpO1xuICAgICAgICBmbi5hcHBseShudWxsLCBbYXJyLCBpdGVyYXRvciwgY2FsbGJhY2tdKTtcbiAgICB9O1xuICAgIGFzeW5jLmZvckVhY2hMaW1pdCA9IGFzeW5jLmVhY2hMaW1pdDtcblxuICAgIHZhciBfZWFjaExpbWl0ID0gZnVuY3Rpb24gKGxpbWl0KSB7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgIGlmICghYXJyLmxlbmd0aCB8fCBsaW1pdCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY29tcGxldGVkID0gMDtcbiAgICAgICAgICAgIHZhciBzdGFydGVkID0gMDtcbiAgICAgICAgICAgIHZhciBydW5uaW5nID0gMDtcblxuICAgICAgICAgICAgKGZ1bmN0aW9uIHJlcGxlbmlzaCAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHdoaWxlIChydW5uaW5nIDwgbGltaXQgJiYgc3RhcnRlZCA8IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRlZCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBydW5uaW5nICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yKGFycltzdGFydGVkIC0gMV0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW5uaW5nIC09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsZW5pc2goKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH07XG4gICAgfTtcblxuXG4gICAgdmFyIGRvUGFyYWxsZWwgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBbYXN5bmMuZWFjaF0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBkb1BhcmFsbGVsTGltaXQgPSBmdW5jdGlvbihsaW1pdCwgZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBbX2VhY2hMaW1pdChsaW1pdCldLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgZG9TZXJpZXMgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBbYXN5bmMuZWFjaFNlcmllc10uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG5cbiAgICB2YXIgX2FzeW5jTWFwID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgYXJyID0gX21hcChhcnIsIGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgICAgICAgICByZXR1cm4ge2luZGV4OiBpLCB2YWx1ZTogeH07XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgudmFsdWUsIGZ1bmN0aW9uIChlcnIsIHYpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzW3guaW5kZXhdID0gdjtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYXN5bmMubWFwID0gZG9QYXJhbGxlbChfYXN5bmNNYXApO1xuICAgIGFzeW5jLm1hcFNlcmllcyA9IGRvU2VyaWVzKF9hc3luY01hcCk7XG4gICAgYXN5bmMubWFwTGltaXQgPSBmdW5jdGlvbiAoYXJyLCBsaW1pdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBfbWFwTGltaXQobGltaXQpKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgdmFyIF9tYXBMaW1pdCA9IGZ1bmN0aW9uKGxpbWl0KSB7XG4gICAgICAgIHJldHVybiBkb1BhcmFsbGVsTGltaXQobGltaXQsIF9hc3luY01hcCk7XG4gICAgfTtcblxuICAgIC8vIHJlZHVjZSBvbmx5IGhhcyBhIHNlcmllcyB2ZXJzaW9uLCBhcyBkb2luZyByZWR1Y2UgaW4gcGFyYWxsZWwgd29uJ3RcbiAgICAvLyB3b3JrIGluIG1hbnkgc2l0dWF0aW9ucy5cbiAgICBhc3luYy5yZWR1Y2UgPSBmdW5jdGlvbiAoYXJyLCBtZW1vLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgYXN5bmMuZWFjaFNlcmllcyhhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IobWVtbywgeCwgZnVuY3Rpb24gKGVyciwgdikge1xuICAgICAgICAgICAgICAgIG1lbW8gPSB2O1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBtZW1vKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBpbmplY3QgYWxpYXNcbiAgICBhc3luYy5pbmplY3QgPSBhc3luYy5yZWR1Y2U7XG4gICAgLy8gZm9sZGwgYWxpYXNcbiAgICBhc3luYy5mb2xkbCA9IGFzeW5jLnJlZHVjZTtcblxuICAgIGFzeW5jLnJlZHVjZVJpZ2h0ID0gZnVuY3Rpb24gKGFyciwgbWVtbywgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXZlcnNlZCA9IF9tYXAoYXJyLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH0pLnJldmVyc2UoKTtcbiAgICAgICAgYXN5bmMucmVkdWNlKHJldmVyc2VkLCBtZW1vLCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgLy8gZm9sZHIgYWxpYXNcbiAgICBhc3luYy5mb2xkciA9IGFzeW5jLnJlZHVjZVJpZ2h0O1xuXG4gICAgdmFyIF9maWx0ZXIgPSBmdW5jdGlvbiAoZWFjaGZuLCBhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBhcnIgPSBfbWFwKGFyciwgZnVuY3Rpb24gKHgsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB7aW5kZXg6IGksIHZhbHVlOiB4fTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeC52YWx1ZSwgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soX21hcChyZXN1bHRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXg7XG4gICAgICAgICAgICB9KSwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geC52YWx1ZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBhc3luYy5maWx0ZXIgPSBkb1BhcmFsbGVsKF9maWx0ZXIpO1xuICAgIGFzeW5jLmZpbHRlclNlcmllcyA9IGRvU2VyaWVzKF9maWx0ZXIpO1xuICAgIC8vIHNlbGVjdCBhbGlhc1xuICAgIGFzeW5jLnNlbGVjdCA9IGFzeW5jLmZpbHRlcjtcbiAgICBhc3luYy5zZWxlY3RTZXJpZXMgPSBhc3luYy5maWx0ZXJTZXJpZXM7XG5cbiAgICB2YXIgX3JlamVjdCA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGFyciA9IF9tYXAoYXJyLCBmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHtpbmRleDogaSwgdmFsdWU6IHh9O1xuICAgICAgICB9KTtcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LnZhbHVlLCBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIGlmICghdikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soX21hcChyZXN1bHRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXg7XG4gICAgICAgICAgICB9KSwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geC52YWx1ZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBhc3luYy5yZWplY3QgPSBkb1BhcmFsbGVsKF9yZWplY3QpO1xuICAgIGFzeW5jLnJlamVjdFNlcmllcyA9IGRvU2VyaWVzKF9yZWplY3QpO1xuXG4gICAgdmFyIF9kZXRlY3QgPSBmdW5jdGlvbiAoZWFjaGZuLCBhcnIsIGl0ZXJhdG9yLCBtYWluX2NhbGxiYWNrKSB7XG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeCwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayh4KTtcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgbWFpbl9jYWxsYmFjaygpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGFzeW5jLmRldGVjdCA9IGRvUGFyYWxsZWwoX2RldGVjdCk7XG4gICAgYXN5bmMuZGV0ZWN0U2VyaWVzID0gZG9TZXJpZXMoX2RldGVjdCk7XG5cbiAgICBhc3luYy5zb21lID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIG1haW5fY2FsbGJhY2spIHtcbiAgICAgICAgYXN5bmMuZWFjaChhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeCwgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgbWFpbl9jYWxsYmFjayhmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gYW55IGFsaWFzXG4gICAgYXN5bmMuYW55ID0gYXN5bmMuc29tZTtcblxuICAgIGFzeW5jLmV2ZXJ5ID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIG1haW5fY2FsbGJhY2spIHtcbiAgICAgICAgYXN5bmMuZWFjaChhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeCwgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXYpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBtYWluX2NhbGxiYWNrKHRydWUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIGFsbCBhbGlhc1xuICAgIGFzeW5jLmFsbCA9IGFzeW5jLmV2ZXJ5O1xuXG4gICAgYXN5bmMuc29ydEJ5ID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGFzeW5jLm1hcChhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeCwgZnVuY3Rpb24gKGVyciwgY3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7dmFsdWU6IHgsIGNyaXRlcmlhOiBjcml0ZXJpYX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCByZXN1bHRzKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBsZWZ0LmNyaXRlcmlhLCBiID0gcmlnaHQuY3JpdGVyaWE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIF9tYXAocmVzdWx0cy5zb3J0KGZuKSwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgudmFsdWU7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgYXN5bmMuYXV0byA9IGZ1bmN0aW9uICh0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgdmFyIGtleXMgPSBfa2V5cyh0YXNrcyk7XG4gICAgICAgIGlmICgha2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHRzID0ge307XG5cbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IFtdO1xuICAgICAgICB2YXIgYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIGxpc3RlbmVycy51bnNoaWZ0KGZuKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0gPT09IGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0YXNrQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfZWFjaChsaXN0ZW5lcnMuc2xpY2UoMCksIGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBhZGRMaXN0ZW5lcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX2tleXMocmVzdWx0cykubGVuZ3RoID09PSBrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdHMpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF9lYWNoKGtleXMsIGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9ICh0YXNrc1trXSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSA/IFt0YXNrc1trXV06IHRhc2tzW2tdO1xuICAgICAgICAgICAgdmFyIHRhc2tDYWxsYmFjayA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNhZmVSZXN1bHRzID0ge307XG4gICAgICAgICAgICAgICAgICAgIF9lYWNoKF9rZXlzKHJlc3VsdHMpLCBmdW5jdGlvbihya2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYWZlUmVzdWx0c1tya2V5XSA9IHJlc3VsdHNbcmtleV07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzYWZlUmVzdWx0c1trXSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgc2FmZVJlc3VsdHMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBzdG9wIHN1YnNlcXVlbnQgZXJyb3JzIGhpdHRpbmcgY2FsbGJhY2sgbXVsdGlwbGUgdGltZXNcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNba10gPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUodGFza0NvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHJlcXVpcmVzID0gdGFzay5zbGljZSgwLCBNYXRoLmFicyh0YXNrLmxlbmd0aCAtIDEpKSB8fCBbXTtcbiAgICAgICAgICAgIHZhciByZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3JlZHVjZShyZXF1aXJlcywgZnVuY3Rpb24gKGEsIHgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChhICYmIHJlc3VsdHMuaGFzT3duUHJvcGVydHkoeCkpO1xuICAgICAgICAgICAgICAgIH0sIHRydWUpICYmICFyZXN1bHRzLmhhc093blByb3BlcnR5KGspO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChyZWFkeSgpKSB7XG4gICAgICAgICAgICAgICAgdGFza1t0YXNrLmxlbmd0aCAtIDFdKHRhc2tDYWxsYmFjaywgcmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWFkeSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrW3Rhc2subGVuZ3RoIC0gMV0odGFza0NhbGxiYWNrLCByZXN1bHRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYWRkTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgYXN5bmMud2F0ZXJmYWxsID0gZnVuY3Rpb24gKHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICBpZiAodGFza3MuY29uc3RydWN0b3IgIT09IEFycmF5KSB7XG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgdG8gd2F0ZXJmYWxsIG11c3QgYmUgYW4gYXJyYXkgb2YgZnVuY3Rpb25zJyk7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0YXNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3cmFwSXRlcmF0b3IgPSBmdW5jdGlvbiAoaXRlcmF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaCh3cmFwSXRlcmF0b3IobmV4dCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHdyYXBJdGVyYXRvcihhc3luYy5pdGVyYXRvcih0YXNrcykpKCk7XG4gICAgfTtcblxuICAgIHZhciBfcGFyYWxsZWwgPSBmdW5jdGlvbihlYWNoZm4sIHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICBpZiAodGFza3MuY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4gICAgICAgICAgICBlYWNoZm4ubWFwKHRhc2tzLCBmdW5jdGlvbiAoZm4sIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKG51bGwsIGVyciwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0ge307XG4gICAgICAgICAgICBlYWNoZm4uZWFjaChfa2V5cyh0YXNrcyksIGZ1bmN0aW9uIChrLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRhc2tzW2tdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1trXSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGFzeW5jLnBhcmFsbGVsID0gZnVuY3Rpb24gKHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICBfcGFyYWxsZWwoeyBtYXA6IGFzeW5jLm1hcCwgZWFjaDogYXN5bmMuZWFjaCB9LCB0YXNrcywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy5wYXJhbGxlbExpbWl0ID0gZnVuY3Rpb24odGFza3MsIGxpbWl0LCBjYWxsYmFjaykge1xuICAgICAgICBfcGFyYWxsZWwoeyBtYXA6IF9tYXBMaW1pdChsaW1pdCksIGVhY2g6IF9lYWNoTGltaXQobGltaXQpIH0sIHRhc2tzLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLnNlcmllcyA9IGZ1bmN0aW9uICh0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgaWYgKHRhc2tzLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICAgICAgYXN5bmMubWFwU2VyaWVzKHRhc2tzLCBmdW5jdGlvbiAoZm4sIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKG51bGwsIGVyciwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0ge307XG4gICAgICAgICAgICBhc3luYy5lYWNoU2VyaWVzKF9rZXlzKHRhc2tzKSwgZnVuY3Rpb24gKGssIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGFza3Nba10oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2tdID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYXN5bmMuaXRlcmF0b3IgPSBmdW5jdGlvbiAodGFza3MpIHtcbiAgICAgICAgdmFyIG1ha2VDYWxsYmFjayA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0YXNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFza3NbaW5kZXhdLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmbi5uZXh0KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm4ubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGluZGV4IDwgdGFza3MubGVuZ3RoIC0gMSkgPyBtYWtlQ2FsbGJhY2soaW5kZXggKyAxKTogbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZm47XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBtYWtlQ2FsbGJhY2soMCk7XG4gICAgfTtcblxuICAgIGFzeW5jLmFwcGx5ID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShcbiAgICAgICAgICAgICAgICBudWxsLCBhcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIF9jb25jYXQgPSBmdW5jdGlvbiAoZWFjaGZuLCBhcnIsIGZuLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgciA9IFtdO1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2IpIHtcbiAgICAgICAgICAgIGZuKHgsIGZ1bmN0aW9uIChlcnIsIHkpIHtcbiAgICAgICAgICAgICAgICByID0gci5jb25jYXQoeSB8fCBbXSk7XG4gICAgICAgICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIHIpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGFzeW5jLmNvbmNhdCA9IGRvUGFyYWxsZWwoX2NvbmNhdCk7XG4gICAgYXN5bmMuY29uY2F0U2VyaWVzID0gZG9TZXJpZXMoX2NvbmNhdCk7XG5cbiAgICBhc3luYy53aGlsc3QgPSBmdW5jdGlvbiAodGVzdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0ZXN0KCkpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhc3luYy53aGlsc3QodGVzdCwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBhc3luYy5kb1doaWxzdCA9IGZ1bmN0aW9uIChpdGVyYXRvciwgdGVzdCwgY2FsbGJhY2spIHtcbiAgICAgICAgaXRlcmF0b3IoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRlc3QoKSkge1xuICAgICAgICAgICAgICAgIGFzeW5jLmRvV2hpbHN0KGl0ZXJhdG9yLCB0ZXN0LCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgYXN5bmMudW50aWwgPSBmdW5jdGlvbiAodGVzdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghdGVzdCgpKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXN5bmMudW50aWwodGVzdCwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBhc3luYy5kb1VudGlsID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCB0ZXN0LCBjYWxsYmFjaykge1xuICAgICAgICBpdGVyYXRvcihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRlc3QoKSkge1xuICAgICAgICAgICAgICAgIGFzeW5jLmRvVW50aWwoaXRlcmF0b3IsIHRlc3QsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBhc3luYy5xdWV1ZSA9IGZ1bmN0aW9uICh3b3JrZXIsIGNvbmN1cnJlbmN5KSB7XG4gICAgICAgIGlmIChjb25jdXJyZW5jeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25jdXJyZW5jeSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gX2luc2VydChxLCBkYXRhLCBwb3MsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgaWYoZGF0YS5jb25zdHJ1Y3RvciAhPT0gQXJyYXkpIHtcbiAgICAgICAgICAgICAgZGF0YSA9IFtkYXRhXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX2VhY2goZGF0YSwgZnVuY3Rpb24odGFzaykge1xuICAgICAgICAgICAgICB2YXIgaXRlbSA9IHtcbiAgICAgICAgICAgICAgICAgIGRhdGE6IHRhc2ssXG4gICAgICAgICAgICAgICAgICBjYWxsYmFjazogdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gY2FsbGJhY2sgOiBudWxsXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgICAgICAgIHEudGFza3MudW5zaGlmdChpdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBxLnRhc2tzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAocS5zYXR1cmF0ZWQgJiYgcS50YXNrcy5sZW5ndGggPT09IGNvbmN1cnJlbmN5KSB7XG4gICAgICAgICAgICAgICAgICBxLnNhdHVyYXRlZCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZShxLnByb2Nlc3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHdvcmtlcnMgPSAwO1xuICAgICAgICB2YXIgcSA9IHtcbiAgICAgICAgICAgIHRhc2tzOiBbXSxcbiAgICAgICAgICAgIGNvbmN1cnJlbmN5OiBjb25jdXJyZW5jeSxcbiAgICAgICAgICAgIHNhdHVyYXRlZDogbnVsbCxcbiAgICAgICAgICAgIGVtcHR5OiBudWxsLFxuICAgICAgICAgICAgZHJhaW46IG51bGwsXG4gICAgICAgICAgICBwdXNoOiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgX2luc2VydChxLCBkYXRhLCBmYWxzZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVuc2hpZnQ6IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICBfaW5zZXJ0KHEsIGRhdGEsIHRydWUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm9jZXNzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdvcmtlcnMgPCBxLmNvbmN1cnJlbmN5ICYmIHEudGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXNrID0gcS50YXNrcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocS5lbXB0eSAmJiBxLnRhc2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcS5lbXB0eSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdvcmtlcnMgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrZXJzIC09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFzay5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2suY2FsbGJhY2suYXBwbHkodGFzaywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxLmRyYWluICYmIHEudGFza3MubGVuZ3RoICsgd29ya2VycyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEuZHJhaW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHEucHJvY2VzcygpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2IgPSBvbmx5X29uY2UobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtlcih0YXNrLmRhdGEsIGNiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHEudGFza3MubGVuZ3RoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJ1bm5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd29ya2VycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHE7XG4gICAgfTtcblxuICAgIGFzeW5jLmNhcmdvID0gZnVuY3Rpb24gKHdvcmtlciwgcGF5bG9hZCkge1xuICAgICAgICB2YXIgd29ya2luZyAgICAgPSBmYWxzZSxcbiAgICAgICAgICAgIHRhc2tzICAgICAgID0gW107XG5cbiAgICAgICAgdmFyIGNhcmdvID0ge1xuICAgICAgICAgICAgdGFza3M6IHRhc2tzLFxuICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgICAgIHNhdHVyYXRlZDogbnVsbCxcbiAgICAgICAgICAgIGVtcHR5OiBudWxsLFxuICAgICAgICAgICAgZHJhaW46IG51bGwsXG4gICAgICAgICAgICBwdXNoOiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZihkYXRhLmNvbnN0cnVjdG9yICE9PSBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gW2RhdGFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfZWFjaChkYXRhLCBmdW5jdGlvbih0YXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2tzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdGFzayxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBjYWxsYmFjayA6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYXJnby5zYXR1cmF0ZWQgJiYgdGFza3MubGVuZ3RoID09PSBwYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJnby5zYXR1cmF0ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZShjYXJnby5wcm9jZXNzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm9jZXNzOiBmdW5jdGlvbiBwcm9jZXNzKCkge1xuICAgICAgICAgICAgICAgIGlmICh3b3JraW5nKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKHRhc2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZihjYXJnby5kcmFpbikgY2FyZ28uZHJhaW4oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB0cyA9IHR5cGVvZiBwYXlsb2FkID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGFza3Muc3BsaWNlKDAsIHBheWxvYWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0YXNrcy5zcGxpY2UoMCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZHMgPSBfbWFwKHRzLCBmdW5jdGlvbiAodGFzaykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFzay5kYXRhO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYoY2FyZ28uZW1wdHkpIGNhcmdvLmVtcHR5KCk7XG4gICAgICAgICAgICAgICAgd29ya2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgd29ya2VyKGRzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICAgICAgX2VhY2godHMsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY2FsbGJhY2suYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsZW5ndGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFza3MubGVuZ3RoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJ1bm5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd29ya2luZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNhcmdvO1xuICAgIH07XG5cbiAgICB2YXIgX2NvbnNvbGVfZm4gPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzLmNvbmNhdChbZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbnNvbGVbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lYWNoKGFyZ3MsIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZVtuYW1lXSh4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGFzeW5jLmxvZyA9IF9jb25zb2xlX2ZuKCdsb2cnKTtcbiAgICBhc3luYy5kaXIgPSBfY29uc29sZV9mbignZGlyJyk7XG4gICAgLyphc3luYy5pbmZvID0gX2NvbnNvbGVfZm4oJ2luZm8nKTtcbiAgICBhc3luYy53YXJuID0gX2NvbnNvbGVfZm4oJ3dhcm4nKTtcbiAgICBhc3luYy5lcnJvciA9IF9jb25zb2xlX2ZuKCdlcnJvcicpOyovXG5cbiAgICBhc3luYy5tZW1vaXplID0gZnVuY3Rpb24gKGZuLCBoYXNoZXIpIHtcbiAgICAgICAgdmFyIG1lbW8gPSB7fTtcbiAgICAgICAgdmFyIHF1ZXVlcyA9IHt9O1xuICAgICAgICBoYXNoZXIgPSBoYXNoZXIgfHwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgdmFyIGtleSA9IGhhc2hlci5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgIGlmIChrZXkgaW4gbWVtbykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIG1lbW9ba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgaW4gcXVldWVzKSB7XG4gICAgICAgICAgICAgICAgcXVldWVzW2tleV0ucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBxdWV1ZXNba2V5XSA9IFtjYWxsYmFja107XG4gICAgICAgICAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncy5jb25jYXQoW2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVtb1trZXldID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcSA9IHF1ZXVlc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcXVldWVzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBxW2ldLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBtZW1vaXplZC5tZW1vID0gbWVtbztcbiAgICAgICAgbWVtb2l6ZWQudW5tZW1vaXplZCA9IGZuO1xuICAgICAgICByZXR1cm4gbWVtb2l6ZWQ7XG4gICAgfTtcblxuICAgIGFzeW5jLnVubWVtb2l6ZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChmbi51bm1lbW9pemVkIHx8IGZuKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgYXN5bmMudGltZXMgPSBmdW5jdGlvbiAoY291bnQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgY291bnRlciA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvdW50ZXIucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN5bmMubWFwKGNvdW50ZXIsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLnRpbWVzU2VyaWVzID0gZnVuY3Rpb24gKGNvdW50LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGNvdW50ZXIgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb3VudGVyLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzeW5jLm1hcFNlcmllcyhjb3VudGVyLCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy5jb21wb3NlID0gZnVuY3Rpb24gKC8qIGZ1bmN0aW9ucy4uLiAqLykge1xuICAgICAgICB2YXIgZm5zID0gQXJyYXkucHJvdG90eXBlLnJldmVyc2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgICAgIGFzeW5jLnJlZHVjZShmbnMsIGFyZ3MsIGZ1bmN0aW9uIChuZXdhcmdzLCBmbiwgY2IpIHtcbiAgICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBuZXdhcmdzLmNvbmNhdChbZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgICAgICBjYihlcnIsIG5leHRhcmdzKTtcbiAgICAgICAgICAgICAgICB9XSkpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoYXQsIFtlcnJdLmNvbmNhdChyZXN1bHRzKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIF9hcHBseUVhY2ggPSBmdW5jdGlvbiAoZWFjaGZuLCBmbnMgLyphcmdzLi4uKi8pIHtcbiAgICAgICAgdmFyIGdvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiBlYWNoZm4oZm5zLCBmdW5jdGlvbiAoZm4sIGNiKSB7XG4gICAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJncy5jb25jYXQoW2NiXSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICAgICAgICByZXR1cm4gZ28uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ287XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGFzeW5jLmFwcGx5RWFjaCA9IGRvUGFyYWxsZWwoX2FwcGx5RWFjaCk7XG4gICAgYXN5bmMuYXBwbHlFYWNoU2VyaWVzID0gZG9TZXJpZXMoX2FwcGx5RWFjaCk7XG5cbiAgICBhc3luYy5mb3JldmVyID0gZnVuY3Rpb24gKGZuLCBjYWxsYmFjaykge1xuICAgICAgICBmdW5jdGlvbiBuZXh0KGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm4obmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCgpO1xuICAgIH07XG5cbiAgICAvLyBBTUQgLyBSZXF1aXJlSlNcbiAgICBpZiAodHlwZW9mIGRlZmluZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoW10sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3luYztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIE5vZGUuanNcbiAgICBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGFzeW5jO1xuICAgIH1cbiAgICAvLyBpbmNsdWRlZCBkaXJlY3RseSB2aWEgPHNjcmlwdD4gdGFnXG4gICAgZWxzZSB7XG4gICAgICAgIHJvb3QuYXN5bmMgPSBhc3luYztcbiAgICB9XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcclxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXHJcbiAgICBkZWZpbmUoW10sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIChyb290LnJldHVybkV4cG9ydHNHbG9iYWwgPSBmYWN0b3J5KCkpO1xyXG4gICAgfSk7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcclxuICAgIC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxyXG4gICAgLy8gb25seSBDb21tb25KUy1saWtlIGVudmlyb21lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cyxcclxuICAgIC8vIGxpa2UgTm9kZS5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByb290WydBdXRvbGlua2VyJ10gPSBmYWN0b3J5KCk7XHJcbiAgfVxyXG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0LyohXHJcblx0ICogQXV0b2xpbmtlci5qc1xyXG5cdCAqIDAuMTUuMlxyXG5cdCAqXHJcblx0ICogQ29weXJpZ2h0KGMpIDIwMTUgR3JlZ29yeSBKYWNvYnMgPGdyZWdAZ3JlZy1qYWNvYnMuY29tPlxyXG5cdCAqIE1JVCBMaWNlbnNlZC4gaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHQgKlxyXG5cdCAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmVnamFjb2JzL0F1dG9saW5rZXIuanNcclxuXHQgKi9cclxuXHQvKipcclxuXHQgKiBAY2xhc3MgQXV0b2xpbmtlclxyXG5cdCAqIEBleHRlbmRzIE9iamVjdFxyXG5cdCAqIFxyXG5cdCAqIFV0aWxpdHkgY2xhc3MgdXNlZCB0byBwcm9jZXNzIGEgZ2l2ZW4gc3RyaW5nIG9mIHRleHQsIGFuZCB3cmFwIHRoZSBVUkxzLCBlbWFpbCBhZGRyZXNzZXMsIGFuZCBUd2l0dGVyIGhhbmRsZXMgaW4gXHJcblx0ICogdGhlIGFwcHJvcHJpYXRlIGFuY2hvciAoJmx0O2EmZ3Q7KSB0YWdzIHRvIHR1cm4gdGhlbSBpbnRvIGxpbmtzLlxyXG5cdCAqIFxyXG5cdCAqIEFueSBvZiB0aGUgY29uZmlndXJhdGlvbiBvcHRpb25zIG1heSBiZSBwcm92aWRlZCBpbiBhbiBPYmplY3QgKG1hcCkgcHJvdmlkZWQgdG8gdGhlIEF1dG9saW5rZXIgY29uc3RydWN0b3IsIHdoaWNoXHJcblx0ICogd2lsbCBjb25maWd1cmUgaG93IHRoZSB7QGxpbmsgI2xpbmsgbGluaygpfSBtZXRob2Qgd2lsbCBwcm9jZXNzIHRoZSBsaW5rcy5cclxuXHQgKiBcclxuXHQgKiBGb3IgZXhhbXBsZTpcclxuXHQgKiBcclxuXHQgKiAgICAgdmFyIGF1dG9saW5rZXIgPSBuZXcgQXV0b2xpbmtlcigge1xyXG5cdCAqICAgICAgICAgbmV3V2luZG93IDogZmFsc2UsXHJcblx0ICogICAgICAgICB0cnVuY2F0ZSAgOiAzMFxyXG5cdCAqICAgICB9ICk7XHJcblx0ICogICAgIFxyXG5cdCAqICAgICB2YXIgaHRtbCA9IGF1dG9saW5rZXIubGluayggXCJKb2Ugd2VudCB0byB3d3cueWFob28uY29tXCIgKTtcclxuXHQgKiAgICAgLy8gcHJvZHVjZXM6ICdKb2Ugd2VudCB0byA8YSBocmVmPVwiaHR0cDovL3d3dy55YWhvby5jb21cIj55YWhvby5jb208L2E+J1xyXG5cdCAqIFxyXG5cdCAqIFxyXG5cdCAqIFRoZSB7QGxpbmsgI3N0YXRpYy1saW5rIHN0YXRpYyBsaW5rKCl9IG1ldGhvZCBtYXkgYWxzbyBiZSB1c2VkIHRvIGlubGluZSBvcHRpb25zIGludG8gYSBzaW5nbGUgY2FsbCwgd2hpY2ggbWF5XHJcblx0ICogYmUgbW9yZSBjb252ZW5pZW50IGZvciBvbmUtb2ZmIHVzZXMuIEZvciBleGFtcGxlOlxyXG5cdCAqIFxyXG5cdCAqICAgICB2YXIgaHRtbCA9IEF1dG9saW5rZXIubGluayggXCJKb2Ugd2VudCB0byB3d3cueWFob28uY29tXCIsIHtcclxuXHQgKiAgICAgICAgIG5ld1dpbmRvdyA6IGZhbHNlLFxyXG5cdCAqICAgICAgICAgdHJ1bmNhdGUgIDogMzBcclxuXHQgKiAgICAgfSApO1xyXG5cdCAqICAgICAvLyBwcm9kdWNlczogJ0pvZSB3ZW50IHRvIDxhIGhyZWY9XCJodHRwOi8vd3d3LnlhaG9vLmNvbVwiPnlhaG9vLmNvbTwvYT4nXHJcblx0ICogXHJcblx0ICogXHJcblx0ICogIyMgQ3VzdG9tIFJlcGxhY2VtZW50cyBvZiBMaW5rc1xyXG5cdCAqIFxyXG5cdCAqIElmIHRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZG8gbm90IHByb3ZpZGUgZW5vdWdoIGZsZXhpYmlsaXR5LCBhIHtAbGluayAjcmVwbGFjZUZufSBtYXkgYmUgcHJvdmlkZWQgdG8gZnVsbHkgY3VzdG9taXplXHJcblx0ICogdGhlIG91dHB1dCBvZiBBdXRvbGlua2VyLiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmNlIGZvciBlYWNoIFVSTC9FbWFpbC9Ud2l0dGVyIGhhbmRsZSBtYXRjaCB0aGF0IGlzIGVuY291bnRlcmVkLlxyXG5cdCAqIFxyXG5cdCAqIEZvciBleGFtcGxlOlxyXG5cdCAqIFxyXG5cdCAqICAgICB2YXIgaW5wdXQgPSBcIi4uLlwiOyAgLy8gc3RyaW5nIHdpdGggVVJMcywgRW1haWwgQWRkcmVzc2VzLCBhbmQgVHdpdHRlciBIYW5kbGVzXHJcblx0ICogICAgIFxyXG5cdCAqICAgICB2YXIgbGlua2VkVGV4dCA9IEF1dG9saW5rZXIubGluayggaW5wdXQsIHtcclxuXHQgKiAgICAgICAgIHJlcGxhY2VGbiA6IGZ1bmN0aW9uKCBhdXRvbGlua2VyLCBtYXRjaCApIHtcclxuXHQgKiAgICAgICAgICAgICBjb25zb2xlLmxvZyggXCJocmVmID0gXCIsIG1hdGNoLmdldEFuY2hvckhyZWYoKSApO1xyXG5cdCAqICAgICAgICAgICAgIGNvbnNvbGUubG9nKCBcInRleHQgPSBcIiwgbWF0Y2guZ2V0QW5jaG9yVGV4dCgpICk7XHJcblx0ICogICAgICAgICBcclxuXHQgKiAgICAgICAgICAgICBzd2l0Y2goIG1hdGNoLmdldFR5cGUoKSApIHtcclxuXHQgKiAgICAgICAgICAgICAgICAgY2FzZSAndXJsJyA6IFxyXG5cdCAqICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coIFwidXJsOiBcIiwgbWF0Y2guZ2V0VXJsKCkgKTtcclxuXHQgKiAgICAgICAgICAgICAgICAgICAgIFxyXG5cdCAqICAgICAgICAgICAgICAgICAgICAgaWYoIG1hdGNoLmdldFVybCgpLmluZGV4T2YoICdteXNpdGUuY29tJyApID09PSAtMSApIHtcclxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gYXV0b2xpbmtlci5nZXRUYWdCdWlsZGVyKCkuYnVpbGQoIG1hdGNoICk7ICAvLyByZXR1cm5zIGFuIGBBdXRvbGlua2VyLkh0bWxUYWdgIGluc3RhbmNlLCB3aGljaCBwcm92aWRlcyBtdXRhdG9yIG1ldGhvZHMgZm9yIGVhc3kgY2hhbmdlc1xyXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgIHRhZy5zZXRBdHRyKCAncmVsJywgJ25vZm9sbG93JyApO1xyXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgIHRhZy5hZGRDbGFzcyggJ2V4dGVybmFsLWxpbmsnICk7XHJcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgXHJcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhZztcclxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICBcclxuXHQgKiAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7ICAvLyBsZXQgQXV0b2xpbmtlciBwZXJmb3JtIGl0cyBub3JtYWwgYW5jaG9yIHRhZyByZXBsYWNlbWVudFxyXG5cdCAqICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAqICAgICAgICAgICAgICAgICAgICAgXHJcblx0ICogICAgICAgICAgICAgICAgIGNhc2UgJ2VtYWlsJyA6XHJcblx0ICogICAgICAgICAgICAgICAgICAgICB2YXIgZW1haWwgPSBtYXRjaC5nZXRFbWFpbCgpO1xyXG5cdCAqICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coIFwiZW1haWw6IFwiLCBlbWFpbCApO1xyXG5cdCAqICAgICAgICAgICAgICAgICAgICAgXHJcblx0ICogICAgICAgICAgICAgICAgICAgICBpZiggZW1haWwgPT09IFwibXlAb3duLmFkZHJlc3NcIiApIHtcclxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7ICAvLyBkb24ndCBhdXRvLWxpbmsgdGhpcyBwYXJ0aWN1bGFyIGVtYWlsIGFkZHJlc3M7IGxlYXZlIGFzLWlzXHJcblx0ICogICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgIC8vIG5vIHJldHVybiB2YWx1ZSB3aWxsIGhhdmUgQXV0b2xpbmtlciBwZXJmb3JtIGl0cyBub3JtYWwgYW5jaG9yIHRhZyByZXBsYWNlbWVudCAoc2FtZSBhcyByZXR1cm5pbmcgYHRydWVgKVxyXG5cdCAqICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAqICAgICAgICAgICAgICAgICBcclxuXHQgKiAgICAgICAgICAgICAgICAgY2FzZSAndHdpdHRlcicgOlxyXG5cdCAqICAgICAgICAgICAgICAgICAgICAgdmFyIHR3aXR0ZXJIYW5kbGUgPSBtYXRjaC5nZXRUd2l0dGVySGFuZGxlKCk7XHJcblx0ICogICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyggdHdpdHRlckhhbmRsZSApO1xyXG5cdCAqICAgICAgICAgICAgICAgICAgICAgXHJcblx0ICogICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzxhIGhyZWY9XCJodHRwOi8vbmV3cGxhY2UudG8ubGluay50d2l0dGVyLmhhbmRsZXMudG8vXCI+JyArIHR3aXR0ZXJIYW5kbGUgKyAnPC9hPic7XHJcblx0ICogICAgICAgICAgICAgfVxyXG5cdCAqICAgICAgICAgfVxyXG5cdCAqICAgICB9ICk7XHJcblx0ICogXHJcblx0ICogXHJcblx0ICogVGhlIGZ1bmN0aW9uIG1heSByZXR1cm4gdGhlIGZvbGxvd2luZyB2YWx1ZXM6XHJcblx0ICogXHJcblx0ICogLSBgdHJ1ZWAgKEJvb2xlYW4pOiBBbGxvdyBBdXRvbGlua2VyIHRvIHJlcGxhY2UgdGhlIG1hdGNoIGFzIGl0IG5vcm1hbGx5IHdvdWxkLlxyXG5cdCAqIC0gYGZhbHNlYCAoQm9vbGVhbik6IERvIG5vdCByZXBsYWNlIHRoZSBjdXJyZW50IG1hdGNoIGF0IGFsbCAtIGxlYXZlIGFzLWlzLlxyXG5cdCAqIC0gQW55IFN0cmluZzogSWYgYSBzdHJpbmcgaXMgcmV0dXJuZWQgZnJvbSB0aGUgZnVuY3Rpb24sIHRoZSBzdHJpbmcgd2lsbCBiZSB1c2VkIGRpcmVjdGx5IGFzIHRoZSByZXBsYWNlbWVudCBIVE1MIGZvclxyXG5cdCAqICAgdGhlIG1hdGNoLlxyXG5cdCAqIC0gQW4ge0BsaW5rIEF1dG9saW5rZXIuSHRtbFRhZ30gaW5zdGFuY2UsIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGJ1aWxkL21vZGlmeSBhbiBIVE1MIHRhZyBiZWZvcmUgd3JpdGluZyBvdXQgaXRzIEhUTUwgdGV4dC5cclxuXHQgKiBcclxuXHQgKiBAY29uc3RydWN0b3JcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIEF1dG9saW5rZXIgaW5zdGFuY2UsIHNwZWNpZmllZCBpbiBhbiBPYmplY3QgKG1hcCkuXHJcblx0ICovXHJcblx0dmFyIEF1dG9saW5rZXIgPSBmdW5jdGlvbiggY2ZnICkge1xyXG5cdFx0QXV0b2xpbmtlci5VdGlsLmFzc2lnbiggdGhpcywgY2ZnICk7ICAvLyBhc3NpZ24gdGhlIHByb3BlcnRpZXMgb2YgYGNmZ2Agb250byB0aGUgQXV0b2xpbmtlciBpbnN0YW5jZS4gUHJvdG90eXBlIHByb3BlcnRpZXMgd2lsbCBiZSB1c2VkIGZvciBtaXNzaW5nIGNvbmZpZ3MuXHJcblxyXG5cdFx0dGhpcy5tYXRjaFZhbGlkYXRvciA9IG5ldyBBdXRvbGlua2VyLk1hdGNoVmFsaWRhdG9yKCk7XHJcblx0fTtcclxuXHJcblxyXG5cdEF1dG9saW5rZXIucHJvdG90eXBlID0ge1xyXG5cdFx0Y29uc3RydWN0b3IgOiBBdXRvbGlua2VyLCAgLy8gZml4IGNvbnN0cnVjdG9yIHByb3BlcnR5XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBAY2ZnIHtCb29sZWFufSB1cmxzXHJcblx0XHQgKiBcclxuXHRcdCAqIGB0cnVlYCBpZiBtaXNjZWxsYW5lb3VzIFVSTHMgc2hvdWxkIGJlIGF1dG9tYXRpY2FsbHkgbGlua2VkLCBgZmFsc2VgIGlmIHRoZXkgc2hvdWxkIG5vdCBiZS5cclxuXHRcdCAqL1xyXG5cdFx0dXJscyA6IHRydWUsXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBAY2ZnIHtCb29sZWFufSBlbWFpbFxyXG5cdFx0ICogXHJcblx0XHQgKiBgdHJ1ZWAgaWYgZW1haWwgYWRkcmVzc2VzIHNob3VsZCBiZSBhdXRvbWF0aWNhbGx5IGxpbmtlZCwgYGZhbHNlYCBpZiB0aGV5IHNob3VsZCBub3QgYmUuXHJcblx0XHQgKi9cclxuXHRcdGVtYWlsIDogdHJ1ZSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEBjZmcge0Jvb2xlYW59IHR3aXR0ZXJcclxuXHRcdCAqIFxyXG5cdFx0ICogYHRydWVgIGlmIFR3aXR0ZXIgaGFuZGxlcyAoXCJAZXhhbXBsZVwiKSBzaG91bGQgYmUgYXV0b21hdGljYWxseSBsaW5rZWQsIGBmYWxzZWAgaWYgdGhleSBzaG91bGQgbm90IGJlLlxyXG5cdFx0ICovXHJcblx0XHR0d2l0dGVyIDogdHJ1ZSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEBjZmcge0Jvb2xlYW59IG5ld1dpbmRvd1xyXG5cdFx0ICogXHJcblx0XHQgKiBgdHJ1ZWAgaWYgdGhlIGxpbmtzIHNob3VsZCBvcGVuIGluIGEgbmV3IHdpbmRvdywgYGZhbHNlYCBvdGhlcndpc2UuXHJcblx0XHQgKi9cclxuXHRcdG5ld1dpbmRvdyA6IHRydWUsXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBAY2ZnIHtCb29sZWFufSBzdHJpcFByZWZpeFxyXG5cdFx0ICogXHJcblx0XHQgKiBgdHJ1ZWAgaWYgJ2h0dHA6Ly8nIG9yICdodHRwczovLycgYW5kL29yIHRoZSAnd3d3Licgc2hvdWxkIGJlIHN0cmlwcGVkIGZyb20gdGhlIGJlZ2lubmluZyBvZiBVUkwgbGlua3MnIHRleHQsIFxyXG5cdFx0ICogYGZhbHNlYCBvdGhlcndpc2UuXHJcblx0XHQgKi9cclxuXHRcdHN0cmlwUHJlZml4IDogdHJ1ZSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEBjZmcge051bWJlcn0gdHJ1bmNhdGVcclxuXHRcdCAqIFxyXG5cdFx0ICogQSBudW1iZXIgZm9yIGhvdyBtYW55IGNoYXJhY3RlcnMgbG9uZyBVUkxzL2VtYWlscy90d2l0dGVyIGhhbmRsZXMgc2hvdWxkIGJlIHRydW5jYXRlZCB0byBpbnNpZGUgdGhlIHRleHQgb2YgXHJcblx0XHQgKiBhIGxpbmsuIElmIHRoZSBVUkwvZW1haWwvdHdpdHRlciBpcyBvdmVyIHRoaXMgbnVtYmVyIG9mIGNoYXJhY3RlcnMsIGl0IHdpbGwgYmUgdHJ1bmNhdGVkIHRvIHRoaXMgbGVuZ3RoIGJ5IFxyXG5cdFx0ICogYWRkaW5nIGEgdHdvIHBlcmlvZCBlbGxpcHNpcyAoJy4uJykgdG8gdGhlIGVuZCBvZiB0aGUgc3RyaW5nLlxyXG5cdFx0ICogXHJcblx0XHQgKiBGb3IgZXhhbXBsZTogQSB1cmwgbGlrZSAnaHR0cDovL3d3dy55YWhvby5jb20vc29tZS9sb25nL3BhdGgvdG8vYS9maWxlJyB0cnVuY2F0ZWQgdG8gMjUgY2hhcmFjdGVycyBtaWdodCBsb29rXHJcblx0XHQgKiBzb21ldGhpbmcgbGlrZSB0aGlzOiAneWFob28uY29tL3NvbWUvbG9uZy9wYXQuLidcclxuXHRcdCAqL1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQGNmZyB7U3RyaW5nfSBjbGFzc05hbWVcclxuXHRcdCAqIFxyXG5cdFx0ICogQSBDU1MgY2xhc3MgbmFtZSB0byBhZGQgdG8gdGhlIGdlbmVyYXRlZCBsaW5rcy4gVGhpcyBjbGFzcyB3aWxsIGJlIGFkZGVkIHRvIGFsbCBsaW5rcywgYXMgd2VsbCBhcyB0aGlzIGNsYXNzXHJcblx0XHQgKiBwbHVzIHVybC9lbWFpbC90d2l0dGVyIHN1ZmZpeGVzIGZvciBzdHlsaW5nIHVybC9lbWFpbC90d2l0dGVyIGxpbmtzIGRpZmZlcmVudGx5LlxyXG5cdFx0ICogXHJcblx0XHQgKiBGb3IgZXhhbXBsZSwgaWYgdGhpcyBjb25maWcgaXMgcHJvdmlkZWQgYXMgXCJteUxpbmtcIiwgdGhlbjpcclxuXHRcdCAqIFxyXG5cdFx0ICogLSBVUkwgbGlua3Mgd2lsbCBoYXZlIHRoZSBDU1MgY2xhc3NlczogXCJteUxpbmsgbXlMaW5rLXVybFwiXHJcblx0XHQgKiAtIEVtYWlsIGxpbmtzIHdpbGwgaGF2ZSB0aGUgQ1NTIGNsYXNzZXM6IFwibXlMaW5rIG15TGluay1lbWFpbFwiLCBhbmRcclxuXHRcdCAqIC0gVHdpdHRlciBsaW5rcyB3aWxsIGhhdmUgdGhlIENTUyBjbGFzc2VzOiBcIm15TGluayBteUxpbmstdHdpdHRlclwiXHJcblx0XHQgKi9cclxuXHRcdGNsYXNzTmFtZSA6IFwiXCIsXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBAY2ZnIHtGdW5jdGlvbn0gcmVwbGFjZUZuXHJcblx0XHQgKiBcclxuXHRcdCAqIEEgZnVuY3Rpb24gdG8gaW5kaXZpZHVhbGx5IHByb2Nlc3MgZWFjaCBVUkwvRW1haWwvVHdpdHRlciBtYXRjaCBmb3VuZCBpbiB0aGUgaW5wdXQgc3RyaW5nLlxyXG5cdFx0ICogXHJcblx0XHQgKiBTZWUgdGhlIGNsYXNzJ3MgZGVzY3JpcHRpb24gZm9yIHVzYWdlLlxyXG5cdFx0ICogXHJcblx0XHQgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcclxuXHRcdCAqIFxyXG5cdFx0ICogQGNmZyB7QXV0b2xpbmtlcn0gcmVwbGFjZUZuLmF1dG9saW5rZXIgVGhlIEF1dG9saW5rZXIgaW5zdGFuY2UsIHdoaWNoIG1heSBiZSB1c2VkIHRvIHJldHJpZXZlIGNoaWxkIG9iamVjdHMgZnJvbSAoc3VjaFxyXG5cdFx0ICogICBhcyB0aGUgaW5zdGFuY2UncyB7QGxpbmsgI2dldFRhZ0J1aWxkZXIgdGFnIGJ1aWxkZXJ9KS5cclxuXHRcdCAqIEBjZmcge0F1dG9saW5rZXIubWF0Y2guTWF0Y2h9IHJlcGxhY2VGbi5tYXRjaCBUaGUgTWF0Y2ggaW5zdGFuY2Ugd2hpY2ggY2FuIGJlIHVzZWQgdG8gcmV0cmlldmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlXHJcblx0XHQgKiAgIHtAbGluayBBdXRvbGlua2VyLm1hdGNoLlVybCBVUkx9L3tAbGluayBBdXRvbGlua2VyLm1hdGNoLkVtYWlsIGVtYWlsfS97QGxpbmsgQXV0b2xpbmtlci5tYXRjaC5Ud2l0dGVyIFR3aXR0ZXJ9XHJcblx0XHQgKiAgIG1hdGNoIHRoYXQgdGhlIGByZXBsYWNlRm5gIGlzIGN1cnJlbnRseSBwcm9jZXNzaW5nLlxyXG5cdFx0ICovXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEBwcm9wZXJ0eSB7UmVnRXhwfSBodG1sQ2hhcmFjdGVyRW50aXRpZXNSZWdleFxyXG5cdFx0ICpcclxuXHRcdCAqIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIGNvbW1vbiBIVE1MIGNoYXJhY3RlciBlbnRpdGllcy5cclxuXHRcdCAqIFxyXG5cdFx0ICogSWdub3JpbmcgJmFtcDsgYXMgaXQgY291bGQgYmUgcGFydCBvZiBhIHF1ZXJ5IHN0cmluZyAtLSBoYW5kbGluZyBpdCBzZXBhcmF0ZWx5LlxyXG5cdFx0ICovXHJcblx0XHRodG1sQ2hhcmFjdGVyRW50aXRpZXNSZWdleDogLygmbmJzcDt8JiMxNjA7fCZsdDt8JiM2MDt8Jmd0O3wmIzYyO3wmcXVvdDt8JiMzNDt8JiMzOTspL2dpLFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEBwcm9wZXJ0eSB7UmVnRXhwfSBtYXRjaGVyUmVnZXhcclxuXHRcdCAqIFxyXG5cdFx0ICogVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IG1hdGNoZXMgVVJMcywgZW1haWwgYWRkcmVzc2VzLCBhbmQgVHdpdHRlciBoYW5kbGVzLlxyXG5cdFx0ICogXHJcblx0XHQgKiBUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBoYXMgdGhlIGZvbGxvd2luZyBjYXB0dXJpbmcgZ3JvdXBzOlxyXG5cdFx0ICogXHJcblx0XHQgKiAxLiBHcm91cCB0aGF0IGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZXJlIGlzIGEgVHdpdHRlciBoYW5kbGUgbWF0Y2ggKGkuZS4gXFxAc29tZVR3aXR0ZXJVc2VyKS4gU2ltcGx5IGNoZWNrIGZvciBpdHMgXHJcblx0XHQgKiAgICBleGlzdGVuY2UgdG8gZGV0ZXJtaW5lIGlmIHRoZXJlIGlzIGEgVHdpdHRlciBoYW5kbGUgbWF0Y2guIFRoZSBuZXh0IGNvdXBsZSBvZiBjYXB0dXJpbmcgZ3JvdXBzIGdpdmUgaW5mb3JtYXRpb24gXHJcblx0XHQgKiAgICBhYm91dCB0aGUgVHdpdHRlciBoYW5kbGUgbWF0Y2guXHJcblx0XHQgKiAyLiBUaGUgd2hpdGVzcGFjZSBjaGFyYWN0ZXIgYmVmb3JlIHRoZSBcXEBzaWduIGluIGEgVHdpdHRlciBoYW5kbGUuIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2UgdGhlcmUgYXJlIG5vIGxvb2tiZWhpbmRzIGluXHJcblx0XHQgKiAgICBKUyByZWd1bGFyIGV4cHJlc3Npb25zLCBhbmQgY2FuIGJlIHVzZWQgdG8gcmVjb25zdHJ1Y3QgdGhlIG9yaWdpbmFsIHN0cmluZyBpbiBhIHJlcGxhY2UoKS5cclxuXHRcdCAqIDMuIFRoZSBUd2l0dGVyIGhhbmRsZSBpdHNlbGYgaW4gYSBUd2l0dGVyIG1hdGNoLiBJZiB0aGUgbWF0Y2ggaXMgJ0Bzb21lVHdpdHRlclVzZXInLCB0aGUgaGFuZGxlIGlzICdzb21lVHdpdHRlclVzZXInLlxyXG5cdFx0ICogNC4gR3JvdXAgdGhhdCBtYXRjaGVzIGFuIGVtYWlsIGFkZHJlc3MuIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBtYXRjaCBpcyBhbiBlbWFpbCBhZGRyZXNzLCBhcyB3ZWxsIGFzIGhvbGRpbmcgdGhlIGZ1bGwgXHJcblx0XHQgKiAgICBhZGRyZXNzLiBFeDogJ21lQG15LmNvbSdcclxuXHRcdCAqIDUuIEdyb3VwIHRoYXQgbWF0Y2hlcyBhIFVSTCBpbiB0aGUgaW5wdXQgdGV4dC4gRXg6ICdodHRwOi8vZ29vZ2xlLmNvbScsICd3d3cuZ29vZ2xlLmNvbScsIG9yIGp1c3QgJ2dvb2dsZS5jb20nLlxyXG5cdFx0ICogICAgVGhpcyBhbHNvIGluY2x1ZGVzIGEgcGF0aCwgdXJsIHBhcmFtZXRlcnMsIG9yIGhhc2ggYW5jaG9ycy4gRXg6IGdvb2dsZS5jb20vcGF0aC90by9maWxlP3ExPTEmcTI9MiNteUFuY2hvclxyXG5cdFx0ICogNi4gR3JvdXAgdGhhdCBtYXRjaGVzIGEgcHJvdG9jb2wgVVJMIChpLmUuICdodHRwOi8vZ29vZ2xlLmNvbScpLiBUaGlzIGlzIHVzZWQgdG8gbWF0Y2ggcHJvdG9jb2wgVVJMcyB3aXRoIGp1c3QgYSBzaW5nbGVcclxuXHRcdCAqICAgIHdvcmQsIGxpa2UgJ2h0dHA6Ly9sb2NhbGhvc3QnLCB3aGVyZSB3ZSB3b24ndCBkb3VibGUgY2hlY2sgdGhhdCB0aGUgZG9tYWluIG5hbWUgaGFzIGF0IGxlYXN0IG9uZSAnLicgaW4gaXQuXHJcblx0XHQgKiA3LiBBIHByb3RvY29sLXJlbGF0aXZlICgnLy8nKSBtYXRjaCBmb3IgdGhlIGNhc2Ugb2YgYSAnd3d3LicgcHJlZml4ZWQgVVJMLiBXaWxsIGJlIGFuIGVtcHR5IHN0cmluZyBpZiBpdCBpcyBub3QgYSBcclxuXHRcdCAqICAgIHByb3RvY29sLXJlbGF0aXZlIG1hdGNoLiBXZSBuZWVkIHRvIGtub3cgdGhlIGNoYXJhY3RlciBiZWZvcmUgdGhlICcvLycgaW4gb3JkZXIgdG8gZGV0ZXJtaW5lIGlmIGl0IGlzIGEgdmFsaWQgbWF0Y2hcclxuXHRcdCAqICAgIG9yIHRoZSAvLyB3YXMgaW4gYSBzdHJpbmcgd2UgZG9uJ3Qgd2FudCB0byBhdXRvLWxpbmsuXHJcblx0XHQgKiA4LiBBIHByb3RvY29sLXJlbGF0aXZlICgnLy8nKSBtYXRjaCBmb3IgdGhlIGNhc2Ugb2YgYSBrbm93biBUTEQgcHJlZml4ZWQgVVJMLiBXaWxsIGJlIGFuIGVtcHR5IHN0cmluZyBpZiBpdCBpcyBub3QgYSBcclxuXHRcdCAqICAgIHByb3RvY29sLXJlbGF0aXZlIG1hdGNoLiBTZWUgIzYgZm9yIG1vcmUgaW5mby4gXHJcblx0XHQgKi9cclxuXHRcdG1hdGNoZXJSZWdleCA6IChmdW5jdGlvbigpIHtcclxuXHRcdFx0dmFyIHR3aXR0ZXJSZWdleCA9IC8oXnxbXlxcd10pQChcXHd7MSwxNX0pLywgICAgICAgICAgICAgIC8vIEZvciBtYXRjaGluZyBhIHR3aXR0ZXIgaGFuZGxlLiBFeDogQGdyZWdvcnlfamFjb2JzXHJcblxyXG5cdFx0XHQgICAgZW1haWxSZWdleCA9IC8oPzpbXFwtOzomPVxcK1xcJCxcXHdcXC5dK0ApLywgICAgICAgICAgICAgLy8gc29tZXRoaW5nQCBmb3IgZW1haWwgYWRkcmVzc2VzIChhLmsuYS4gbG9jYWwtcGFydClcclxuXHJcblx0XHRcdCAgICBwcm90b2NvbFJlZ2V4ID0gLyg/OltBLVphLXpdWy0uK0EtWmEtejAtOV0rOig/IVtBLVphLXpdWy0uK0EtWmEtejAtOV0rOlxcL1xcLykoPyFcXGQrXFwvPykoPzpcXC9cXC8pPykvLCAgLy8gbWF0Y2ggcHJvdG9jb2wsIGFsbG93IGluIGZvcm1hdCBcImh0dHA6Ly9cIiBvciBcIm1haWx0bzpcIi4gSG93ZXZlciwgZG8gbm90IG1hdGNoIHRoZSBmaXJzdCBwYXJ0IG9mIHNvbWV0aGluZyBsaWtlICdsaW5rOmh0dHA6Ly93d3cuZ29vZ2xlLmNvbScgKGkuZS4gZG9uJ3QgbWF0Y2ggXCJsaW5rOlwiKS4gQWxzbywgbWFrZSBzdXJlIHdlIGRvbid0IGludGVycHJldCAnZ29vZ2xlLmNvbTo4MDAwJyBhcyBpZiAnZ29vZ2xlLmNvbScgd2FzIGEgcHJvdG9jb2wgaGVyZSAoaS5lLiBpZ25vcmUgYSB0cmFpbGluZyBwb3J0IG51bWJlciBpbiB0aGlzIHJlZ2V4KVxyXG5cdFx0XHQgICAgd3d3UmVnZXggPSAvKD86d3d3XFwuKS8sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFydGluZyB3aXRoICd3d3cuJ1xyXG5cdFx0XHQgICAgZG9tYWluTmFtZVJlZ2V4ID0gL1tBLVphLXowLTlcXC5cXC1dKltBLVphLXowLTlcXC1dLywgIC8vIGFueXRoaW5nIGxvb2tpbmcgYXQgYWxsIGxpa2UgYSBkb21haW4sIG5vbi11bmljb2RlIGRvbWFpbnMsIG5vdCBlbmRpbmcgaW4gYSBwZXJpb2RcclxuXHRcdFx0ICAgIHRsZFJlZ2V4ID0gL1xcLig/OmludGVybmF0aW9uYWx8Y29uc3RydWN0aW9ufGNvbnRyYWN0b3JzfGVudGVycHJpc2VzfHBob3RvZ3JhcGh5fHByb2R1Y3Rpb25zfGZvdW5kYXRpb258aW1tb2JpbGllbnxpbmR1c3RyaWVzfG1hbmFnZW1lbnR8cHJvcGVydGllc3x0ZWNobm9sb2d5fGNocmlzdG1hc3xjb21tdW5pdHl8ZGlyZWN0b3J5fGVkdWNhdGlvbnxlcXVpcG1lbnR8aW5zdGl0dXRlfG1hcmtldGluZ3xzb2x1dGlvbnN8dmFjYXRpb25zfGJhcmdhaW5zfGJvdXRpcXVlfGJ1aWxkZXJzfGNhdGVyaW5nfGNsZWFuaW5nfGNsb3RoaW5nfGNvbXB1dGVyfGRlbW9jcmF0fGRpYW1vbmRzfGdyYXBoaWNzfGhvbGRpbmdzfGxpZ2h0aW5nfHBhcnRuZXJzfHBsdW1iaW5nfHN1cHBsaWVzfHRyYWluaW5nfHZlbnR1cmVzfGFjYWRlbXl8Y2FyZWVyc3xjb21wYW55fGNydWlzZXN8ZG9tYWluc3xleHBvc2VkfGZsaWdodHN8ZmxvcmlzdHxnYWxsZXJ5fGd1aXRhcnN8aG9saWRheXxraXRjaGVufG5ldXN0YXJ8b2tpbmF3YXxyZWNpcGVzfHJlbnRhbHN8cmV2aWV3c3xzaGlrc2hhfHNpbmdsZXN8c3VwcG9ydHxzeXN0ZW1zfGFnZW5jeXxiZXJsaW58Y2FtZXJhfGNlbnRlcnxjb2ZmZWV8Y29uZG9zfGRhdGluZ3xlc3RhdGV8ZXZlbnRzfGV4cGVydHxmdXRib2x8a2F1ZmVufGx1eHVyeXxtYWlzb258bW9uYXNofG11c2V1bXxuYWdveWF8cGhvdG9zfHJlcGFpcnxyZXBvcnR8c29jaWFsfHN1cHBseXx0YXR0b298dGllbmRhfHRyYXZlbHx2aWFqZXN8dmlsbGFzfHZpc2lvbnx2b3Rpbmd8dm95YWdlfGFjdG9yfGJ1aWxkfGNhcmRzfGNoZWFwfGNvZGVzfGRhbmNlfGVtYWlsfGdsYXNzfGhvdXNlfG1hbmdvfG5pbmphfHBhcnRzfHBob3RvfHNob2VzfHNvbGFyfHRvZGF5fHRva3lvfHRvb2xzfHdhdGNofHdvcmtzfGFlcm98YXJwYXxhc2lhfGJlc3R8YmlrZXxibHVlfGJ1enp8Y2FtcHxjbHVifGNvb2x8Y29vcHxmYXJtfGZpc2h8Z2lmdHxndXJ1fGluZm98am9ic3xraXdpfGtyZWR8bGFuZHxsaW1vfGxpbmt8bWVudXxtb2JpfG1vZGF8bmFtZXxwaWNzfHBpbmt8cG9zdHxxcG9ufHJpY2h8cnVocnxzZXh5fHRpcHN8dm90ZXx2b3RvfHdhbmd8d2llbnx3aWtpfHpvbmV8YmFyfGJpZHxiaXp8Y2FifGNhdHxjZW98Y29tfGVkdXxnb3Z8aW50fGtpbXxtaWx8bmV0fG9ubHxvcmd8cHJvfHB1YnxyZWR8dGVsfHVub3x3ZWR8eHh4fHh5enxhY3xhZHxhZXxhZnxhZ3xhaXxhbHxhbXxhbnxhb3xhcXxhcnxhc3xhdHxhdXxhd3xheHxhenxiYXxiYnxiZHxiZXxiZnxiZ3xiaHxiaXxianxibXxibnxib3xicnxic3xidHxidnxid3xieXxienxjYXxjY3xjZHxjZnxjZ3xjaHxjaXxja3xjbHxjbXxjbnxjb3xjcnxjdXxjdnxjd3xjeHxjeXxjenxkZXxkanxka3xkbXxkb3xkenxlY3xlZXxlZ3xlcnxlc3xldHxldXxmaXxmanxma3xmbXxmb3xmcnxnYXxnYnxnZHxnZXxnZnxnZ3xnaHxnaXxnbHxnbXxnbnxncHxncXxncnxnc3xndHxndXxnd3xneXxoa3xobXxobnxocnxodHxodXxpZHxpZXxpbHxpbXxpbnxpb3xpcXxpcnxpc3xpdHxqZXxqbXxqb3xqcHxrZXxrZ3xraHxraXxrbXxrbnxrcHxrcnxrd3xreXxrenxsYXxsYnxsY3xsaXxsa3xscnxsc3xsdHxsdXxsdnxseXxtYXxtY3xtZHxtZXxtZ3xtaHxta3xtbHxtbXxtbnxtb3xtcHxtcXxtcnxtc3xtdHxtdXxtdnxtd3xteHxteXxtenxuYXxuY3xuZXxuZnxuZ3xuaXxubHxub3xucHxucnxudXxuenxvbXxwYXxwZXxwZnxwZ3xwaHxwa3xwbHxwbXxwbnxwcnxwc3xwdHxwd3xweXxxYXxyZXxyb3xyc3xydXxyd3xzYXxzYnxzY3xzZHxzZXxzZ3xzaHxzaXxzanxza3xzbHxzbXxzbnxzb3xzcnxzdHxzdXxzdnxzeHxzeXxzenx0Y3x0ZHx0Znx0Z3x0aHx0anx0a3x0bHx0bXx0bnx0b3x0cHx0cnx0dHx0dnx0d3x0enx1YXx1Z3x1a3x1c3x1eXx1enx2YXx2Y3x2ZXx2Z3x2aXx2bnx2dXx3Znx3c3x5ZXx5dHx6YXx6bXx6dylcXGIvLCAgIC8vIG1hdGNoIG91ciBrbm93biB0b3AgbGV2ZWwgZG9tYWlucyAoVExEcylcclxuXHJcblx0XHRcdCAgICAvLyBBbGxvdyBvcHRpb25hbCBwYXRoLCBxdWVyeSBzdHJpbmcsIGFuZCBoYXNoIGFuY2hvciwgbm90IGVuZGluZyBpbiB0aGUgZm9sbG93aW5nIGNoYXJhY3RlcnM6IFwiPyE6LC47XCJcclxuXHRcdFx0ICAgIC8vIGh0dHA6Ly9ibG9nLmNvZGluZ2hvcnJvci5jb20vdGhlLXByb2JsZW0td2l0aC11cmxzL1xyXG5cdFx0XHQgICAgdXJsU3VmZml4UmVnZXggPSAvW1xcLUEtWmEtejAtOSsmQCNcXC8lPX5fKCl8JyQqXFxbXFxdPyE6LC47XSpbXFwtQS1aYS16MC05KyZAI1xcLyU9fl8oKXwnJCpcXFtcXF1dLztcclxuXHJcblx0XHRcdHJldHVybiBuZXcgUmVnRXhwKCBbXHJcblx0XHRcdFx0JygnLCAgLy8gKioqIENhcHR1cmluZyBncm91cCAkMSwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gY2hlY2sgZm9yIGEgdHdpdHRlciBoYW5kbGUgbWF0Y2guIFVzZSBncm91cCAkMyBmb3IgdGhlIGFjdHVhbCB0d2l0dGVyIGhhbmRsZSB0aG91Z2guICQyIG1heSBiZSB1c2VkIHRvIHJlY29uc3RydWN0IHRoZSBvcmlnaW5hbCBzdHJpbmcgaW4gYSByZXBsYWNlKCkgXHJcblx0XHRcdFx0XHQvLyAqKiogQ2FwdHVyaW5nIGdyb3VwICQyLCB3aGljaCBtYXRjaGVzIHRoZSB3aGl0ZXNwYWNlIGNoYXJhY3RlciBiZWZvcmUgdGhlICdAJyBzaWduIChuZWVkZWQgYmVjYXVzZSBvZiBubyBsb29rYmVoaW5kcyksIGFuZCBcclxuXHRcdFx0XHRcdC8vICoqKiBDYXB0dXJpbmcgZ3JvdXAgJDMsIHdoaWNoIG1hdGNoZXMgdGhlIGFjdHVhbCB0d2l0dGVyIGhhbmRsZVxyXG5cdFx0XHRcdFx0dHdpdHRlclJlZ2V4LnNvdXJjZSxcclxuXHRcdFx0XHQnKScsXHJcblxyXG5cdFx0XHRcdCd8JyxcclxuXHJcblx0XHRcdFx0JygnLCAgLy8gKioqIENhcHR1cmluZyBncm91cCAkNCwgd2hpY2ggaXMgdXNlZCB0byBkZXRlcm1pbmUgYW4gZW1haWwgbWF0Y2hcclxuXHRcdFx0XHRcdGVtYWlsUmVnZXguc291cmNlLFxyXG5cdFx0XHRcdFx0ZG9tYWluTmFtZVJlZ2V4LnNvdXJjZSxcclxuXHRcdFx0XHRcdHRsZFJlZ2V4LnNvdXJjZSxcclxuXHRcdFx0XHQnKScsXHJcblxyXG5cdFx0XHRcdCd8JyxcclxuXHJcblx0XHRcdFx0JygnLCAgLy8gKioqIENhcHR1cmluZyBncm91cCAkNSwgd2hpY2ggaXMgdXNlZCB0byBtYXRjaCBhIFVSTFxyXG5cdFx0XHRcdFx0Jyg/OicsIC8vIHBhcmVucyB0byBjb3ZlciBtYXRjaCBmb3IgcHJvdG9jb2wgKG9wdGlvbmFsKSwgYW5kIGRvbWFpblxyXG5cdFx0XHRcdFx0XHQnKCcsICAvLyAqKiogQ2FwdHVyaW5nIGdyb3VwICQ2LCBmb3IgYSBwcm90b2NvbC1wcmVmaXhlZCB1cmwgKGV4OiBodHRwOi8vZ29vZ2xlLmNvbSlcclxuXHRcdFx0XHRcdFx0XHRwcm90b2NvbFJlZ2V4LnNvdXJjZSxcclxuXHRcdFx0XHRcdFx0XHRkb21haW5OYW1lUmVnZXguc291cmNlLFxyXG5cdFx0XHRcdFx0XHQnKScsXHJcblxyXG5cdFx0XHRcdFx0XHQnfCcsXHJcblxyXG5cdFx0XHRcdFx0XHQnKD86JywgIC8vIG5vbi1jYXB0dXJpbmcgcGFyZW4gZm9yIGEgJ3d3dy4nIHByZWZpeGVkIHVybCAoZXg6IHd3dy5nb29nbGUuY29tKVxyXG5cdFx0XHRcdFx0XHRcdCcoLj8vLyk/JywgIC8vICoqKiBDYXB0dXJpbmcgZ3JvdXAgJDcgZm9yIGFuIG9wdGlvbmFsIHByb3RvY29sLXJlbGF0aXZlIFVSTC4gTXVzdCBiZSBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzdHJpbmcgb3Igc3RhcnQgd2l0aCBhIG5vbi13b3JkIGNoYXJhY3RlclxyXG5cdFx0XHRcdFx0XHRcdHd3d1JlZ2V4LnNvdXJjZSxcclxuXHRcdFx0XHRcdFx0XHRkb21haW5OYW1lUmVnZXguc291cmNlLFxyXG5cdFx0XHRcdFx0XHQnKScsXHJcblxyXG5cdFx0XHRcdFx0XHQnfCcsXHJcblxyXG5cdFx0XHRcdFx0XHQnKD86JywgIC8vIG5vbi1jYXB0dXJpbmcgcGFyZW4gZm9yIGtub3duIGEgVExEIHVybCAoZXg6IGdvb2dsZS5jb20pXHJcblx0XHRcdFx0XHRcdFx0JyguPy8vKT8nLCAgLy8gKioqIENhcHR1cmluZyBncm91cCAkOCBmb3IgYW4gb3B0aW9uYWwgcHJvdG9jb2wtcmVsYXRpdmUgVVJMLiBNdXN0IGJlIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHN0cmluZyBvciBzdGFydCB3aXRoIGEgbm9uLXdvcmQgY2hhcmFjdGVyXHJcblx0XHRcdFx0XHRcdFx0ZG9tYWluTmFtZVJlZ2V4LnNvdXJjZSxcclxuXHRcdFx0XHRcdFx0XHR0bGRSZWdleC5zb3VyY2UsXHJcblx0XHRcdFx0XHRcdCcpJyxcclxuXHRcdFx0XHRcdCcpJyxcclxuXHJcblx0XHRcdFx0XHQnKD86JyArIHVybFN1ZmZpeFJlZ2V4LnNvdXJjZSArICcpPycsICAvLyBtYXRjaCBmb3IgcGF0aCwgcXVlcnkgc3RyaW5nLCBhbmQvb3IgaGFzaCBhbmNob3IgLSBvcHRpb25hbFxyXG5cdFx0XHRcdCcpJ1xyXG5cdFx0XHRdLmpvaW4oIFwiXCIgKSwgJ2dpJyApO1xyXG5cdFx0fSApKCksXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHByb3BlcnR5IHtSZWdFeHB9IGNoYXJCZWZvcmVQcm90b2NvbFJlbE1hdGNoUmVnZXhcclxuXHRcdCAqIFxyXG5cdFx0ICogVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHJldHJpZXZlIHRoZSBjaGFyYWN0ZXIgYmVmb3JlIGEgcHJvdG9jb2wtcmVsYXRpdmUgVVJMIG1hdGNoLlxyXG5cdFx0ICogXHJcblx0XHQgKiBUaGlzIGlzIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUge0BsaW5rICNtYXRjaGVyUmVnZXh9LCB3aGljaCBuZWVkcyB0byBncmFiIHRoZSBjaGFyYWN0ZXIgYmVmb3JlIGEgcHJvdG9jb2wtcmVsYXRpdmVcclxuXHRcdCAqICcvLycgZHVlIHRvIHRoZSBsYWNrIG9mIGEgbmVnYXRpdmUgbG9vay1iZWhpbmQgaW4gSmF2YVNjcmlwdCByZWd1bGFyIGV4cHJlc3Npb25zLiBUaGUgY2hhcmFjdGVyIGJlZm9yZSB0aGUgbWF0Y2ggaXMgc3RyaXBwZWRcclxuXHRcdCAqIGZyb20gdGhlIFVSTC5cclxuXHRcdCAqL1xyXG5cdFx0Y2hhckJlZm9yZVByb3RvY29sUmVsTWF0Y2hSZWdleCA6IC9eKC4pP1xcL1xcLy8sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHByb3BlcnR5IHtBdXRvbGlua2VyLk1hdGNoVmFsaWRhdG9yfSBtYXRjaFZhbGlkYXRvclxyXG5cdFx0ICogXHJcblx0XHQgKiBUaGUgTWF0Y2hWYWxpZGF0b3Igb2JqZWN0LCB1c2VkIHRvIGZpbHRlciBvdXQgYW55IGZhbHNlIHBvc2l0aXZlcyBmcm9tIHRoZSB7QGxpbmsgI21hdGNoZXJSZWdleH0uIFNlZVxyXG5cdFx0ICoge0BsaW5rIEF1dG9saW5rZXIuTWF0Y2hWYWxpZGF0b3J9IGZvciBkZXRhaWxzLlxyXG5cdFx0ICovXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHByb3BlcnR5IHtBdXRvbGlua2VyLkh0bWxQYXJzZXJ9IGh0bWxQYXJzZXJcclxuXHRcdCAqIFxyXG5cdFx0ICogVGhlIEh0bWxQYXJzZXIgaW5zdGFuY2UgdXNlZCB0byBza2lwIG92ZXIgSFRNTCB0YWdzLCB3aGlsZSBmaW5kaW5nIHRleHQgbm9kZXMgdG8gcHJvY2Vzcy4gVGhpcyBpcyBsYXppbHkgaW5zdGFudGlhdGVkXHJcblx0XHQgKiBpbiB0aGUge0BsaW5rICNnZXRIdG1sUGFyc2VyfSBtZXRob2QuXHJcblx0XHQgKi9cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAcHJvcGVydHkge0F1dG9saW5rZXIuQW5jaG9yVGFnQnVpbGRlcn0gdGFnQnVpbGRlclxyXG5cdFx0ICogXHJcblx0XHQgKiBUaGUgQW5jaG9yVGFnQnVpbGRlciBpbnN0YW5jZSB1c2VkIHRvIGJ1aWxkIHRoZSBVUkwvZW1haWwvVHdpdHRlciByZXBsYWNlbWVudCBhbmNob3IgdGFncy4gVGhpcyBpcyBsYXppbHkgaW5zdGFudGlhdGVkXHJcblx0XHQgKiBpbiB0aGUge0BsaW5rICNnZXRUYWdCdWlsZGVyfSBtZXRob2QuXHJcblx0XHQgKi9cclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBdXRvbWF0aWNhbGx5IGxpbmtzIFVSTHMsIGVtYWlsIGFkZHJlc3NlcywgYW5kIFR3aXR0ZXIgaGFuZGxlcyBmb3VuZCBpbiB0aGUgZ2l2ZW4gY2h1bmsgb2YgSFRNTC4gXHJcblx0XHQgKiBEb2VzIG5vdCBsaW5rIFVSTHMgZm91bmQgd2l0aGluIEhUTUwgdGFncy5cclxuXHRcdCAqIFxyXG5cdFx0ICogRm9yIGluc3RhbmNlLCBpZiBnaXZlbiB0aGUgdGV4dDogYFlvdSBzaG91bGQgZ28gdG8gaHR0cDovL3d3dy55YWhvby5jb21gLCB0aGVuIHRoZSByZXN1bHRcclxuXHRcdCAqIHdpbGwgYmUgYFlvdSBzaG91bGQgZ28gdG8gJmx0O2EgaHJlZj1cImh0dHA6Ly93d3cueWFob28uY29tXCImZ3Q7aHR0cDovL3d3dy55YWhvby5jb20mbHQ7L2EmZ3Q7YFxyXG5cdFx0ICogXHJcblx0XHQgKiBUaGlzIG1ldGhvZCBmaW5kcyB0aGUgdGV4dCBhcm91bmQgYW55IEhUTUwgZWxlbWVudHMgaW4gdGhlIGlucHV0IGB0ZXh0T3JIdG1sYCwgd2hpY2ggd2lsbCBiZSB0aGUgdGV4dCB0aGF0IGlzIHByb2Nlc3NlZC5cclxuXHRcdCAqIEFueSBvcmlnaW5hbCBIVE1MIGVsZW1lbnRzIHdpbGwgYmUgbGVmdCBhcy1pcywgYXMgd2VsbCBhcyB0aGUgdGV4dCB0aGF0IGlzIGFscmVhZHkgd3JhcHBlZCBpbiBhbmNob3IgKCZsdDthJmd0OykgdGFncy5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHRPckh0bWwgVGhlIEhUTUwgb3IgdGV4dCB0byBsaW5rIFVSTHMsIGVtYWlsIGFkZHJlc3NlcywgYW5kIFR3aXR0ZXIgaGFuZGxlcyB3aXRoaW4gKGRlcGVuZGluZyBvbiBpZlxyXG5cdFx0ICogICB0aGUge0BsaW5rICN1cmxzfSwge0BsaW5rICNlbWFpbH0sIGFuZCB7QGxpbmsgI3R3aXR0ZXJ9IG9wdGlvbnMgYXJlIGVuYWJsZWQpLlxyXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgSFRNTCwgd2l0aCBVUkxzL2VtYWlscy9Ud2l0dGVyIGhhbmRsZXMgYXV0b21hdGljYWxseSBsaW5rZWQuXHJcblx0XHQgKi9cclxuXHRcdGxpbmsgOiBmdW5jdGlvbiggdGV4dE9ySHRtbCApIHtcclxuXHRcdFx0dmFyIG1lID0gdGhpcywgIC8vIGZvciBjbG9zdXJlXHJcblx0XHRcdCAgICBodG1sUGFyc2VyID0gdGhpcy5nZXRIdG1sUGFyc2VyKCksXHJcblx0XHRcdCAgICBodG1sQ2hhcmFjdGVyRW50aXRpZXNSZWdleCA9IHRoaXMuaHRtbENoYXJhY3RlckVudGl0aWVzUmVnZXgsXHJcblx0XHRcdCAgICBhbmNob3JUYWdTdGFja0NvdW50ID0gMCwgIC8vIHVzZWQgdG8gb25seSBwcm9jZXNzIHRleHQgYXJvdW5kIGFuY2hvciB0YWdzLCBhbmQgYW55IGlubmVyIHRleHQvaHRtbCB0aGV5IG1heSBoYXZlXHJcblx0XHRcdCAgICByZXN1bHRIdG1sID0gW107XHJcblxyXG5cdFx0XHRodG1sUGFyc2VyLnBhcnNlKCB0ZXh0T3JIdG1sLCB7XHJcblx0XHRcdFx0Ly8gUHJvY2VzcyBIVE1MIG5vZGVzIGluIHRoZSBpbnB1dCBgdGV4dE9ySHRtbGBcclxuXHRcdFx0XHRwcm9jZXNzSHRtbE5vZGUgOiBmdW5jdGlvbiggdGFnVGV4dCwgdGFnTmFtZSwgaXNDbG9zaW5nVGFnICkge1xyXG5cdFx0XHRcdFx0aWYoIHRhZ05hbWUgPT09ICdhJyApIHtcclxuXHRcdFx0XHRcdFx0aWYoICFpc0Nsb3NpbmdUYWcgKSB7ICAvLyBpdCdzIHRoZSBzdGFydCA8YT4gdGFnXHJcblx0XHRcdFx0XHRcdFx0YW5jaG9yVGFnU3RhY2tDb3VudCsrO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2UgeyAgIC8vIGl0J3MgdGhlIGVuZCA8L2E+IHRhZ1xyXG5cdFx0XHRcdFx0XHRcdGFuY2hvclRhZ1N0YWNrQ291bnQgPSBNYXRoLm1heCggYW5jaG9yVGFnU3RhY2tDb3VudCAtIDEsIDAgKTsgIC8vIGF0dGVtcHQgdG8gaGFuZGxlIGV4dHJhbmVvdXMgPC9hPiB0YWdzIGJ5IG1ha2luZyBzdXJlIHRoZSBzdGFjayBjb3VudCBuZXZlciBnb2VzIGJlbG93IDBcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cmVzdWx0SHRtbC5wdXNoKCB0YWdUZXh0ICk7ICAvLyBub3cgYWRkIHRoZSB0ZXh0IG9mIHRoZSB0YWcgaXRzZWxmIHZlcmJhdGltXHJcblx0XHRcdFx0fSxcclxuXHJcblx0XHRcdFx0Ly8gUHJvY2VzcyB0ZXh0IG5vZGVzIGluIHRoZSBpbnB1dCBgdGV4dE9ySHRtbGBcclxuXHRcdFx0XHRwcm9jZXNzVGV4dE5vZGUgOiBmdW5jdGlvbiggdGV4dCApIHtcclxuXHRcdFx0XHRcdGlmKCBhbmNob3JUYWdTdGFja0NvdW50ID09PSAwICkge1xyXG5cdFx0XHRcdFx0XHQvLyBJZiB3ZSdyZSBub3Qgd2l0aGluIGFuIDxhPiB0YWcsIHByb2Nlc3MgdGhlIHRleHQgbm9kZVxyXG5cdFx0XHRcdFx0XHR2YXIgdW5lc2NhcGVkVGV4dCA9IEF1dG9saW5rZXIuVXRpbC5zcGxpdEFuZENhcHR1cmUoIHRleHQsIGh0bWxDaGFyYWN0ZXJFbnRpdGllc1JlZ2V4ICk7ICAvLyBzcGxpdCBhdCBIVE1MIGVudGl0aWVzLCBidXQgaW5jbHVkZSB0aGUgSFRNTCBlbnRpdGllcyBpbiB0aGUgcmVzdWx0cyBhcnJheVxyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsZW4gPSB1bmVzY2FwZWRUZXh0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xyXG5cdFx0XHRcdFx0XHRcdHZhciB0ZXh0VG9Qcm9jZXNzID0gdW5lc2NhcGVkVGV4dFsgaSBdLFxyXG5cdFx0XHRcdFx0XHRcdCAgICBwcm9jZXNzZWRUZXh0Tm9kZSA9IG1lLnByb2Nlc3NUZXh0Tm9kZSggdGV4dFRvUHJvY2VzcyApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRyZXN1bHRIdG1sLnB1c2goIHByb2Nlc3NlZFRleHROb2RlICk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHQvLyBgdGV4dGAgaXMgd2l0aGluIGFuIDxhPiB0YWcsIHNpbXBseSBhcHBlbmQgdGhlIHRleHQgLSB3ZSBkbyBub3Qgd2FudCB0byBhdXRvbGluayBhbnl0aGluZyBcclxuXHRcdFx0XHRcdFx0Ly8gYWxyZWFkeSB3aXRoaW4gYW4gPGE+Li4uPC9hPiB0YWdcclxuXHRcdFx0XHRcdFx0cmVzdWx0SHRtbC5wdXNoKCB0ZXh0ICk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9ICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0SHRtbC5qb2luKCBcIlwiICk7XHJcblx0XHR9LFxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIExhemlseSBpbnN0YW50aWF0ZXMgYW5kIHJldHVybnMgdGhlIHtAbGluayAjaHRtbFBhcnNlcn0gaW5zdGFuY2UgZm9yIHRoaXMgQXV0b2xpbmtlciBpbnN0YW5jZS5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHByb3RlY3RlZFxyXG5cdFx0ICogQHJldHVybiB7QXV0b2xpbmtlci5IdG1sUGFyc2VyfVxyXG5cdFx0ICovXHJcblx0XHRnZXRIdG1sUGFyc2VyIDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHZhciBodG1sUGFyc2VyID0gdGhpcy5odG1sUGFyc2VyO1xyXG5cclxuXHRcdFx0aWYoICFodG1sUGFyc2VyICkge1xyXG5cdFx0XHRcdGh0bWxQYXJzZXIgPSB0aGlzLmh0bWxQYXJzZXIgPSBuZXcgQXV0b2xpbmtlci5IdG1sUGFyc2VyKCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBodG1sUGFyc2VyO1xyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBSZXR1cm5zIHRoZSB7QGxpbmsgI3RhZ0J1aWxkZXJ9IGluc3RhbmNlIGZvciB0aGlzIEF1dG9saW5rZXIgaW5zdGFuY2UsIGxhemlseSBpbnN0YW50aWF0aW5nIGl0XHJcblx0XHQgKiBpZiBpdCBkb2VzIG5vdCB5ZXQgZXhpc3QuXHJcblx0XHQgKiBcclxuXHRcdCAqIFRoaXMgbWV0aG9kIG1heSBiZSB1c2VkIGluIGEge0BsaW5rICNyZXBsYWNlRm59IHRvIGdlbmVyYXRlIHRoZSB7QGxpbmsgQXV0b2xpbmtlci5IdG1sVGFnIEh0bWxUYWd9IGluc3RhbmNlIHRoYXQgXHJcblx0XHQgKiBBdXRvbGlua2VyIHdvdWxkIG5vcm1hbGx5IGdlbmVyYXRlLCBhbmQgdGhlbiBhbGxvdyBmb3IgbW9kaWZpY2F0aW9ucyBiZWZvcmUgcmV0dXJuaW5nIGl0LiBGb3IgZXhhbXBsZTpcclxuXHRcdCAqIFxyXG5cdFx0ICogICAgIHZhciBodG1sID0gQXV0b2xpbmtlci5saW5rKCBcIlRlc3QgZ29vZ2xlLmNvbVwiLCB7XHJcblx0XHQgKiAgICAgICAgIHJlcGxhY2VGbiA6IGZ1bmN0aW9uKCBhdXRvbGlua2VyLCBtYXRjaCApIHtcclxuXHRcdCAqICAgICAgICAgICAgIHZhciB0YWcgPSBhdXRvbGlua2VyLmdldFRhZ0J1aWxkZXIoKS5idWlsZCggbWF0Y2ggKTsgIC8vIHJldHVybnMgYW4ge0BsaW5rIEF1dG9saW5rZXIuSHRtbFRhZ30gaW5zdGFuY2VcclxuXHRcdCAqICAgICAgICAgICAgIHRhZy5zZXRBdHRyKCAncmVsJywgJ25vZm9sbG93JyApO1xyXG5cdFx0ICogICAgICAgICAgICAgXHJcblx0XHQgKiAgICAgICAgICAgICByZXR1cm4gdGFnO1xyXG5cdFx0ICogICAgICAgICB9XHJcblx0XHQgKiAgICAgfSApO1xyXG5cdFx0ICogICAgIFxyXG5cdFx0ICogICAgIC8vIGdlbmVyYXRlZCBodG1sOlxyXG5cdFx0ICogICAgIC8vICAgVGVzdCA8YSBocmVmPVwiaHR0cDovL2dvb2dsZS5jb21cIiB0YXJnZXQ9XCJfYmxhbmtcIiByZWw9XCJub2ZvbGxvd1wiPmdvb2dsZS5jb208L2E+XHJcblx0XHQgKiBcclxuXHRcdCAqIEByZXR1cm4ge0F1dG9saW5rZXIuQW5jaG9yVGFnQnVpbGRlcn1cclxuXHRcdCAqL1xyXG5cdFx0Z2V0VGFnQnVpbGRlciA6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR2YXIgdGFnQnVpbGRlciA9IHRoaXMudGFnQnVpbGRlcjtcclxuXHJcblx0XHRcdGlmKCAhdGFnQnVpbGRlciApIHtcclxuXHRcdFx0XHR0YWdCdWlsZGVyID0gdGhpcy50YWdCdWlsZGVyID0gbmV3IEF1dG9saW5rZXIuQW5jaG9yVGFnQnVpbGRlcigge1xyXG5cdFx0XHRcdFx0bmV3V2luZG93ICAgOiB0aGlzLm5ld1dpbmRvdyxcclxuXHRcdFx0XHRcdHRydW5jYXRlICAgIDogdGhpcy50cnVuY2F0ZSxcclxuXHRcdFx0XHRcdGNsYXNzTmFtZSAgIDogdGhpcy5jbGFzc05hbWVcclxuXHRcdFx0XHR9ICk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0YWdCdWlsZGVyO1xyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBQcm9jZXNzIHRoZSB0ZXh0IHRoYXQgbGllcyBpbmJldHdlZW4gSFRNTCB0YWdzLiBUaGlzIG1ldGhvZCBkb2VzIHRoZSBhY3R1YWwgd3JhcHBpbmcgb2YgVVJMcyB3aXRoXHJcblx0XHQgKiBhbmNob3IgdGFncy5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIGF1dG8tbGluay5cclxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHRleHQgd2l0aCBhbmNob3IgdGFncyBhdXRvLWZpbGxlZC5cclxuXHRcdCAqL1xyXG5cdFx0cHJvY2Vzc1RleHROb2RlIDogZnVuY3Rpb24oIHRleHQgKSB7XHJcblx0XHRcdHZhciBtZSA9IHRoaXM7ICAvLyBmb3IgY2xvc3VyZVxyXG5cclxuXHRcdFx0cmV0dXJuIHRleHQucmVwbGFjZSggdGhpcy5tYXRjaGVyUmVnZXgsIGZ1bmN0aW9uKCBtYXRjaFN0ciwgJDEsICQyLCAkMywgJDQsICQ1LCAkNiwgJDcsICQ4ICkge1xyXG5cdFx0XHRcdHZhciBtYXRjaERlc2NPYmogPSBtZS5wcm9jZXNzQ2FuZGlkYXRlTWF0Y2goIG1hdGNoU3RyLCAkMSwgJDIsICQzLCAkNCwgJDUsICQ2LCAkNywgJDggKTsgIC8vIG1hdGNoIGRlc2NyaXB0aW9uIG9iamVjdFxyXG5cclxuXHRcdFx0XHQvLyBSZXR1cm4gb3V0IHdpdGggbm8gY2hhbmdlcyBmb3IgbWF0Y2ggdHlwZXMgdGhhdCBhcmUgZGlzYWJsZWQgKHVybCwgZW1haWwsIHR3aXR0ZXIpLCBvciBmb3IgbWF0Y2hlcyB0aGF0IGFyZSBcclxuXHRcdFx0XHQvLyBpbnZhbGlkIChmYWxzZSBwb3NpdGl2ZXMgZnJvbSB0aGUgbWF0Y2hlclJlZ2V4LCB3aGljaCBjYW4ndCB1c2UgbG9vay1iZWhpbmRzIHNpbmNlIHRoZXkgYXJlIHVuYXZhaWxhYmxlIGluIEpTKS5cclxuXHRcdFx0XHRpZiggIW1hdGNoRGVzY09iaiApIHtcclxuXHRcdFx0XHRcdHJldHVybiBtYXRjaFN0cjtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdC8vIEdlbmVyYXRlIHRoZSByZXBsYWNlbWVudCB0ZXh0IGZvciB0aGUgbWF0Y2hcclxuXHRcdFx0XHRcdHZhciBtYXRjaFJldHVyblZhbCA9IG1lLmNyZWF0ZU1hdGNoUmV0dXJuVmFsKCBtYXRjaERlc2NPYmoubWF0Y2gsIG1hdGNoRGVzY09iai5tYXRjaFN0ciApO1xyXG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoRGVzY09iai5wcmVmaXhTdHIgKyBtYXRjaFJldHVyblZhbCArIG1hdGNoRGVzY09iai5zdWZmaXhTdHI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9ICk7XHJcblx0XHR9LFxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFByb2Nlc3NlcyBhIGNhbmRpZGF0ZSBtYXRjaCBmcm9tIHRoZSB7QGxpbmsgI21hdGNoZXJSZWdleH0uIFxyXG5cdFx0ICogXHJcblx0XHQgKiBOb3QgYWxsIG1hdGNoZXMgZm91bmQgYnkgdGhlIHJlZ2V4IGFyZSBhY3R1YWwgVVJML2VtYWlsL1R3aXR0ZXIgbWF0Y2hlcywgYXMgZGV0ZXJtaW5lZCBieSB0aGUge0BsaW5rICNtYXRjaFZhbGlkYXRvcn0uIEluXHJcblx0XHQgKiB0aGlzIGNhc2UsIHRoZSBtZXRob2QgcmV0dXJucyBgbnVsbGAuIE90aGVyd2lzZSwgYSB2YWxpZCBPYmplY3Qgd2l0aCBgcHJlZml4U3RyYCwgYG1hdGNoYCwgYW5kIGBzdWZmaXhTdHJgIGlzIHJldHVybmVkLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG1hdGNoU3RyIFRoZSBmdWxsIG1hdGNoIHRoYXQgd2FzIGZvdW5kIGJ5IHRoZSB7QGxpbmsgI21hdGNoZXJSZWdleH0uXHJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdHdpdHRlck1hdGNoIFRoZSBtYXRjaGVkIHRleHQgb2YgYSBUd2l0dGVyIGhhbmRsZSwgaWYgdGhlIG1hdGNoIGlzIGEgVHdpdHRlciBtYXRjaC5cclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB0d2l0dGVySGFuZGxlUHJlZml4V2hpdGVzcGFjZUNoYXIgVGhlIHdoaXRlc3BhY2UgY2hhciBiZWZvcmUgdGhlIEAgc2lnbiBpbiBhIFR3aXR0ZXIgaGFuZGxlIG1hdGNoLiBUaGlzIFxyXG5cdFx0ICogICBpcyBuZWVkZWQgYmVjYXVzZSBvZiBubyBsb29rYmVoaW5kcyBpbiBKUyByZWdleGVzLCBhbmQgaXMgbmVlZCB0byByZS1pbmNsdWRlIHRoZSBjaGFyYWN0ZXIgZm9yIHRoZSBhbmNob3IgdGFnIHJlcGxhY2VtZW50LlxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHR3aXR0ZXJIYW5kbGUgVGhlIGFjdHVhbCBUd2l0dGVyIHVzZXIgKGkuZSB0aGUgd29yZCBhZnRlciB0aGUgQCBzaWduIGluIGEgVHdpdHRlciBtYXRjaCkuXHJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gZW1haWxBZGRyZXNzTWF0Y2ggVGhlIG1hdGNoZWQgZW1haWwgYWRkcmVzcyBmb3IgYW4gZW1haWwgYWRkcmVzcyBtYXRjaC5cclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB1cmxNYXRjaCBUaGUgbWF0Y2hlZCBVUkwgc3RyaW5nIGZvciBhIFVSTCBtYXRjaC5cclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBwcm90b2NvbFVybE1hdGNoIFRoZSBtYXRjaCBVUkwgc3RyaW5nIGZvciBhIHByb3RvY29sIG1hdGNoLiBFeDogJ2h0dHA6Ly95YWhvby5jb20nLiBUaGlzIGlzIHVzZWQgdG8gbWF0Y2hcclxuXHRcdCAqICAgc29tZXRoaW5nIGxpa2UgJ2h0dHA6Ly9sb2NhbGhvc3QnLCB3aGVyZSB3ZSB3b24ndCBkb3VibGUgY2hlY2sgdGhhdCB0aGUgZG9tYWluIG5hbWUgaGFzIGF0IGxlYXN0IG9uZSAnLicgaW4gaXQuXHJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gd3d3UHJvdG9jb2xSZWxhdGl2ZU1hdGNoIFRoZSAnLy8nIGZvciBhIHByb3RvY29sLXJlbGF0aXZlIG1hdGNoIGZyb20gYSAnd3d3JyB1cmwsIHdpdGggdGhlIGNoYXJhY3RlciB0aGF0IFxyXG5cdFx0ICogICBjb21lcyBiZWZvcmUgdGhlICcvLycuXHJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdGxkUHJvdG9jb2xSZWxhdGl2ZU1hdGNoIFRoZSAnLy8nIGZvciBhIHByb3RvY29sLXJlbGF0aXZlIG1hdGNoIGZyb20gYSBUTEQgKHRvcCBsZXZlbCBkb21haW4pIG1hdGNoLCB3aXRoIFxyXG5cdFx0ICogICB0aGUgY2hhcmFjdGVyIHRoYXQgY29tZXMgYmVmb3JlIHRoZSAnLy8nLlxyXG5cdFx0ICogICBcclxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gQSBcIm1hdGNoIGRlc2NyaXB0aW9uIG9iamVjdFwiLiBUaGlzIHdpbGwgYmUgYG51bGxgIGlmIHRoZSBtYXRjaCB3YXMgaW52YWxpZCwgb3IgaWYgYSBtYXRjaCB0eXBlIGlzIGRpc2FibGVkLlxyXG5cdFx0ICogICBPdGhlcndpc2UsIHRoaXMgd2lsbCBiZSBhbiBPYmplY3QgKG1hcCkgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybi5wcmVmaXhTdHIgVGhlIGNoYXIocykgdGhhdCBzaG91bGQgYmUgcHJlcGVuZGVkIHRvIHRoZSByZXBsYWNlbWVudCBzdHJpbmcuIFRoZXNlIGFyZSBjaGFyKHMpIHRoYXRcclxuXHRcdCAqICAgd2VyZSBuZWVkZWQgdG8gYmUgaW5jbHVkZWQgZnJvbSB0aGUgcmVnZXggbWF0Y2ggdGhhdCB3ZXJlIGlnbm9yZWQgYnkgcHJvY2Vzc2luZyBjb2RlLCBhbmQgc2hvdWxkIGJlIHJlLWluc2VydGVkIGludG8gXHJcblx0XHQgKiAgIHRoZSByZXBsYWNlbWVudCBzdHJlYW0uXHJcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybi5zdWZmaXhTdHIgVGhlIGNoYXIocykgdGhhdCBzaG91bGQgYmUgYXBwZW5kZWQgdG8gdGhlIHJlcGxhY2VtZW50IHN0cmluZy4gVGhlc2UgYXJlIGNoYXIocykgdGhhdFxyXG5cdFx0ICogICB3ZXJlIG5lZWRlZCB0byBiZSBpbmNsdWRlZCBmcm9tIHRoZSByZWdleCBtYXRjaCB0aGF0IHdlcmUgaWdub3JlZCBieSBwcm9jZXNzaW5nIGNvZGUsIGFuZCBzaG91bGQgYmUgcmUtaW5zZXJ0ZWQgaW50byBcclxuXHRcdCAqICAgdGhlIHJlcGxhY2VtZW50IHN0cmVhbS5cclxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJuLm1hdGNoU3RyIFRoZSBgbWF0Y2hTdHJgLCBmaXhlZCB1cCB0byByZW1vdmUgY2hhcmFjdGVycyB0aGF0IGFyZSBubyBsb25nZXIgbmVlZGVkICh3aGljaCBoYXZlIGJlZW5cclxuXHRcdCAqICAgYWRkZWQgdG8gYHByZWZpeFN0cmAgYW5kIGBzdWZmaXhTdHJgKS5cclxuXHRcdCAqIEByZXR1cm4ge0F1dG9saW5rZXIubWF0Y2guTWF0Y2h9IHJldHVybi5tYXRjaCBUaGUgTWF0Y2ggb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgbWF0Y2ggdGhhdCB3YXMgZm91bmQuXHJcblx0XHQgKi9cclxuXHRcdHByb2Nlc3NDYW5kaWRhdGVNYXRjaCA6IGZ1bmN0aW9uKCBcclxuXHRcdFx0bWF0Y2hTdHIsIHR3aXR0ZXJNYXRjaCwgdHdpdHRlckhhbmRsZVByZWZpeFdoaXRlc3BhY2VDaGFyLCB0d2l0dGVySGFuZGxlLCBcclxuXHRcdFx0ZW1haWxBZGRyZXNzTWF0Y2gsIHVybE1hdGNoLCBwcm90b2NvbFVybE1hdGNoLCB3d3dQcm90b2NvbFJlbGF0aXZlTWF0Y2gsIHRsZFByb3RvY29sUmVsYXRpdmVNYXRjaFxyXG5cdFx0KSB7XHJcblx0XHRcdHZhciBwcm90b2NvbFJlbGF0aXZlTWF0Y2ggPSB3d3dQcm90b2NvbFJlbGF0aXZlTWF0Y2ggfHwgdGxkUHJvdG9jb2xSZWxhdGl2ZU1hdGNoLFxyXG5cdFx0XHQgICAgbWF0Y2gsICAvLyBXaWxsIGJlIGFuIEF1dG9saW5rZXIubWF0Y2guTWF0Y2ggb2JqZWN0XHJcblxyXG5cdFx0XHQgICAgcHJlZml4U3RyID0gXCJcIiwgICAgICAgLy8gQSBzdHJpbmcgdG8gdXNlIHRvIHByZWZpeCB0aGUgYW5jaG9yIHRhZyB0aGF0IGlzIGNyZWF0ZWQuIFRoaXMgaXMgbmVlZGVkIGZvciB0aGUgVHdpdHRlciBoYW5kbGUgbWF0Y2hcclxuXHRcdFx0ICAgIHN1ZmZpeFN0ciA9IFwiXCI7ICAgICAgIC8vIEEgc3RyaW5nIHRvIHN1ZmZpeCB0aGUgYW5jaG9yIHRhZyB0aGF0IGlzIGNyZWF0ZWQuIFRoaXMgaXMgdXNlZCBpZiB0aGVyZSBpcyBhIHRyYWlsaW5nIHBhcmVudGhlc2lzIHRoYXQgc2hvdWxkIG5vdCBiZSBhdXRvLWxpbmtlZC5cclxuXHJcblxyXG5cdFx0XHQvLyBSZXR1cm4gb3V0IHdpdGggYG51bGxgIGZvciBtYXRjaCB0eXBlcyB0aGF0IGFyZSBkaXNhYmxlZCAodXJsLCBlbWFpbCwgdHdpdHRlciksIG9yIGZvciBtYXRjaGVzIHRoYXQgYXJlIFxyXG5cdFx0XHQvLyBpbnZhbGlkIChmYWxzZSBwb3NpdGl2ZXMgZnJvbSB0aGUgbWF0Y2hlclJlZ2V4LCB3aGljaCBjYW4ndCB1c2UgbG9vay1iZWhpbmRzIHNpbmNlIHRoZXkgYXJlIHVuYXZhaWxhYmxlIGluIEpTKS5cclxuXHRcdFx0aWYoXHJcblx0XHRcdFx0KCB0d2l0dGVyTWF0Y2ggJiYgIXRoaXMudHdpdHRlciApIHx8ICggZW1haWxBZGRyZXNzTWF0Y2ggJiYgIXRoaXMuZW1haWwgKSB8fCAoIHVybE1hdGNoICYmICF0aGlzLnVybHMgKSB8fFxyXG5cdFx0XHRcdCF0aGlzLm1hdGNoVmFsaWRhdG9yLmlzVmFsaWRNYXRjaCggdXJsTWF0Y2gsIHByb3RvY29sVXJsTWF0Y2gsIHByb3RvY29sUmVsYXRpdmVNYXRjaCApIFxyXG5cdFx0XHQpIHtcclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gSGFuZGxlIGEgY2xvc2luZyBwYXJlbnRoZXNpcyBhdCB0aGUgZW5kIG9mIHRoZSBtYXRjaCwgYW5kIGV4Y2x1ZGUgaXQgaWYgdGhlcmUgaXMgbm90IGEgbWF0Y2hpbmcgb3BlbiBwYXJlbnRoZXNpc1xyXG5cdFx0XHQvLyBpbiB0aGUgbWF0Y2ggaXRzZWxmLiBcclxuXHRcdFx0aWYoIHRoaXMubWF0Y2hIYXNVbmJhbGFuY2VkQ2xvc2luZ1BhcmVuKCBtYXRjaFN0ciApICkge1xyXG5cdFx0XHRcdG1hdGNoU3RyID0gbWF0Y2hTdHIuc3Vic3RyKCAwLCBtYXRjaFN0ci5sZW5ndGggLSAxICk7ICAvLyByZW1vdmUgdGhlIHRyYWlsaW5nIFwiKVwiXHJcblx0XHRcdFx0c3VmZml4U3RyID0gXCIpXCI7ICAvLyB0aGlzIHdpbGwgYmUgYWRkZWQgYWZ0ZXIgdGhlIGdlbmVyYXRlZCA8YT4gdGFnXHJcblx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHRpZiggZW1haWxBZGRyZXNzTWF0Y2ggKSB7XHJcblx0XHRcdFx0bWF0Y2ggPSBuZXcgQXV0b2xpbmtlci5tYXRjaC5FbWFpbCggeyBtYXRjaGVkVGV4dDogbWF0Y2hTdHIsIGVtYWlsOiBlbWFpbEFkZHJlc3NNYXRjaCB9ICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYoIHR3aXR0ZXJNYXRjaCApIHtcclxuXHRcdFx0XHQvLyBmaXggdXAgdGhlIGBtYXRjaFN0cmAgaWYgdGhlcmUgd2FzIGEgcHJlY2VkaW5nIHdoaXRlc3BhY2UgY2hhciwgd2hpY2ggd2FzIG5lZWRlZCB0byBkZXRlcm1pbmUgdGhlIG1hdGNoIFxyXG5cdFx0XHRcdC8vIGl0c2VsZiAoc2luY2UgdGhlcmUgYXJlIG5vIGxvb2stYmVoaW5kcyBpbiBKUyByZWdleGVzKVxyXG5cdFx0XHRcdGlmKCB0d2l0dGVySGFuZGxlUHJlZml4V2hpdGVzcGFjZUNoYXIgKSB7XHJcblx0XHRcdFx0XHRwcmVmaXhTdHIgPSB0d2l0dGVySGFuZGxlUHJlZml4V2hpdGVzcGFjZUNoYXI7XHJcblx0XHRcdFx0XHRtYXRjaFN0ciA9IG1hdGNoU3RyLnNsaWNlKCAxICk7ICAvLyByZW1vdmUgdGhlIHByZWZpeGVkIHdoaXRlc3BhY2UgY2hhciBmcm9tIHRoZSBtYXRjaFxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRtYXRjaCA9IG5ldyBBdXRvbGlua2VyLm1hdGNoLlR3aXR0ZXIoIHsgbWF0Y2hlZFRleHQ6IG1hdGNoU3RyLCB0d2l0dGVySGFuZGxlOiB0d2l0dGVySGFuZGxlIH0gKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7ICAvLyB1cmwgbWF0Y2hcclxuXHRcdFx0XHQvLyBJZiBpdCdzIGEgcHJvdG9jb2wtcmVsYXRpdmUgJy8vJyBtYXRjaCwgcmVtb3ZlIHRoZSBjaGFyYWN0ZXIgYmVmb3JlIHRoZSAnLy8nICh3aGljaCB0aGUgbWF0Y2hlclJlZ2V4IG5lZWRlZFxyXG5cdFx0XHRcdC8vIHRvIG1hdGNoIGR1ZSB0byB0aGUgbGFjayBvZiBhIG5lZ2F0aXZlIGxvb2stYmVoaW5kIGluIEphdmFTY3JpcHQgcmVndWxhciBleHByZXNzaW9ucylcclxuXHRcdFx0XHRpZiggcHJvdG9jb2xSZWxhdGl2ZU1hdGNoICkge1xyXG5cdFx0XHRcdFx0dmFyIGNoYXJCZWZvcmVNYXRjaCA9IHByb3RvY29sUmVsYXRpdmVNYXRjaC5tYXRjaCggdGhpcy5jaGFyQmVmb3JlUHJvdG9jb2xSZWxNYXRjaFJlZ2V4IClbIDEgXSB8fCBcIlwiO1xyXG5cclxuXHRcdFx0XHRcdGlmKCBjaGFyQmVmb3JlTWF0Y2ggKSB7ICAvLyBmaXggdXAgdGhlIGBtYXRjaFN0cmAgaWYgdGhlcmUgd2FzIGEgcHJlY2VkaW5nIGNoYXIgYmVmb3JlIGEgcHJvdG9jb2wtcmVsYXRpdmUgbWF0Y2gsIHdoaWNoIHdhcyBuZWVkZWQgdG8gZGV0ZXJtaW5lIHRoZSBtYXRjaCBpdHNlbGYgKHNpbmNlIHRoZXJlIGFyZSBubyBsb29rLWJlaGluZHMgaW4gSlMgcmVnZXhlcylcclxuXHRcdFx0XHRcdFx0cHJlZml4U3RyID0gY2hhckJlZm9yZU1hdGNoO1xyXG5cdFx0XHRcdFx0XHRtYXRjaFN0ciA9IG1hdGNoU3RyLnNsaWNlKCAxICk7ICAvLyByZW1vdmUgdGhlIHByZWZpeGVkIGNoYXIgZnJvbSB0aGUgbWF0Y2hcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdG1hdGNoID0gbmV3IEF1dG9saW5rZXIubWF0Y2guVXJsKCB7XHJcblx0XHRcdFx0XHRtYXRjaGVkVGV4dCA6IG1hdGNoU3RyLFxyXG5cdFx0XHRcdFx0dXJsIDogbWF0Y2hTdHIsXHJcblx0XHRcdFx0XHRwcm90b2NvbFVybE1hdGNoIDogISFwcm90b2NvbFVybE1hdGNoLFxyXG5cdFx0XHRcdFx0cHJvdG9jb2xSZWxhdGl2ZU1hdGNoIDogISFwcm90b2NvbFJlbGF0aXZlTWF0Y2gsXHJcblx0XHRcdFx0XHRzdHJpcFByZWZpeCA6IHRoaXMuc3RyaXBQcmVmaXhcclxuXHRcdFx0XHR9ICk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0cHJlZml4U3RyIDogcHJlZml4U3RyLFxyXG5cdFx0XHRcdHN1ZmZpeFN0ciA6IHN1ZmZpeFN0cixcclxuXHRcdFx0XHRtYXRjaFN0ciAgOiBtYXRjaFN0cixcclxuXHRcdFx0XHRtYXRjaCAgICAgOiBtYXRjaFxyXG5cdFx0XHR9O1xyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBEZXRlcm1pbmVzIGlmIGEgbWF0Y2ggZm91bmQgaGFzIGFuIHVubWF0Y2hlZCBjbG9zaW5nIHBhcmVudGhlc2lzLiBJZiBzbywgdGhpcyBwYXJlbnRoZXNpcyB3aWxsIGJlIHJlbW92ZWRcclxuXHRcdCAqIGZyb20gdGhlIG1hdGNoIGl0c2VsZiwgYW5kIGFwcGVuZGVkIGFmdGVyIHRoZSBnZW5lcmF0ZWQgYW5jaG9yIHRhZyBpbiB7QGxpbmsgI3Byb2Nlc3NUZXh0Tm9kZX0uXHJcblx0XHQgKiBcclxuXHRcdCAqIEEgbWF0Y2ggbWF5IGhhdmUgYW4gZXh0cmEgY2xvc2luZyBwYXJlbnRoZXNpcyBhdCB0aGUgZW5kIG9mIHRoZSBtYXRjaCBiZWNhdXNlIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gbXVzdCBpbmNsdWRlIHBhcmVudGhlc2lzXHJcblx0XHQgKiBmb3IgVVJMcyBzdWNoIGFzIFwid2lraXBlZGlhLmNvbS9zb21ldGhpbmdfKGRpc2FtYmlndWF0aW9uKVwiLCB3aGljaCBzaG91bGQgYmUgYXV0by1saW5rZWQuIFxyXG5cdFx0ICogXHJcblx0XHQgKiBIb3dldmVyLCBhbiBleHRyYSBwYXJlbnRoZXNpcyAqd2lsbCogYmUgaW5jbHVkZWQgd2hlbiB0aGUgVVJMIGl0c2VsZiBpcyB3cmFwcGVkIGluIHBhcmVudGhlc2lzLCBzdWNoIGFzIGluIHRoZSBjYXNlIG9mXHJcblx0XHQgKiBcIih3aWtpcGVkaWEuY29tL3NvbWV0aGluZ18oZGlzYW1iaWd1YXRpb24pKVwiLiBJbiB0aGlzIGNhc2UsIHRoZSBsYXN0IGNsb3NpbmcgcGFyZW50aGVzaXMgc2hvdWxkICpub3QqIGJlIHBhcnQgb2YgdGhlIFVSTCBcclxuXHRcdCAqIGl0c2VsZiwgYW5kIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGB0cnVlYC5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBtYXRjaFN0ciBUaGUgZnVsbCBtYXRjaCBzdHJpbmcgZnJvbSB0aGUge0BsaW5rICNtYXRjaGVyUmVnZXh9LlxyXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZXJlIGlzIGFuIHVuYmFsYW5jZWQgY2xvc2luZyBwYXJlbnRoZXNpcyBhdCB0aGUgZW5kIG9mIHRoZSBgbWF0Y2hTdHJgLCBgZmFsc2VgIG90aGVyd2lzZS5cclxuXHRcdCAqL1xyXG5cdFx0bWF0Y2hIYXNVbmJhbGFuY2VkQ2xvc2luZ1BhcmVuIDogZnVuY3Rpb24oIG1hdGNoU3RyICkge1xyXG5cdFx0XHR2YXIgbGFzdENoYXIgPSBtYXRjaFN0ci5jaGFyQXQoIG1hdGNoU3RyLmxlbmd0aCAtIDEgKTtcclxuXHJcblx0XHRcdGlmKCBsYXN0Q2hhciA9PT0gJyknICkge1xyXG5cdFx0XHRcdHZhciBvcGVuUGFyZW5zTWF0Y2ggPSBtYXRjaFN0ci5tYXRjaCggL1xcKC9nICksXHJcblx0XHRcdFx0ICAgIGNsb3NlUGFyZW5zTWF0Y2ggPSBtYXRjaFN0ci5tYXRjaCggL1xcKS9nICksXHJcblx0XHRcdFx0ICAgIG51bU9wZW5QYXJlbnMgPSAoIG9wZW5QYXJlbnNNYXRjaCAmJiBvcGVuUGFyZW5zTWF0Y2gubGVuZ3RoICkgfHwgMCxcclxuXHRcdFx0XHQgICAgbnVtQ2xvc2VQYXJlbnMgPSAoIGNsb3NlUGFyZW5zTWF0Y2ggJiYgY2xvc2VQYXJlbnNNYXRjaC5sZW5ndGggKSB8fCAwO1xyXG5cclxuXHRcdFx0XHRpZiggbnVtT3BlblBhcmVucyA8IG51bUNsb3NlUGFyZW5zICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9LFxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIENyZWF0ZXMgdGhlIHJldHVybiBzdHJpbmcgdmFsdWUgZm9yIGEgZ2l2ZW4gbWF0Y2ggaW4gdGhlIGlucHV0IHN0cmluZywgZm9yIHRoZSB7QGxpbmsgI3Byb2Nlc3NUZXh0Tm9kZX0gbWV0aG9kLlxyXG5cdFx0ICogXHJcblx0XHQgKiBUaGlzIG1ldGhvZCBoYW5kbGVzIHRoZSB7QGxpbmsgI3JlcGxhY2VGbn0sIGlmIG9uZSB3YXMgcHJvdmlkZWQuXHJcblx0XHQgKiBcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAcGFyYW0ge0F1dG9saW5rZXIubWF0Y2guTWF0Y2h9IG1hdGNoIFRoZSBNYXRjaCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBtYXRjaC5cclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBtYXRjaFN0ciBUaGUgb3JpZ2luYWwgbWF0Y2ggc3RyaW5nLCBhZnRlciBoYXZpbmcgYmVlbiBwcmVwcm9jZXNzZWQgdG8gZml4IG1hdGNoIGVkZ2UgY2FzZXMgKHNlZVxyXG5cdFx0ICogICB0aGUgYHByZWZpeFN0cmAgYW5kIGBzdWZmaXhTdHJgIHZhcnMgaW4ge0BsaW5rICNwcm9jZXNzVGV4dE5vZGV9LlxyXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgc3RyaW5nIHRoYXQgdGhlIGBtYXRjaGAgc2hvdWxkIGJlIHJlcGxhY2VkIHdpdGguIFRoaXMgaXMgdXN1YWxseSB0aGUgYW5jaG9yIHRhZyBzdHJpbmcsIGJ1dFxyXG5cdFx0ICogICBtYXkgYmUgdGhlIGBtYXRjaFN0cmAgaXRzZWxmIGlmIHRoZSBtYXRjaCBpcyBub3QgdG8gYmUgcmVwbGFjZWQuXHJcblx0XHQgKi9cclxuXHRcdGNyZWF0ZU1hdGNoUmV0dXJuVmFsIDogZnVuY3Rpb24oIG1hdGNoLCBtYXRjaFN0ciApIHtcclxuXHRcdFx0Ly8gSGFuZGxlIGEgY3VzdG9tIGByZXBsYWNlRm5gIGJlaW5nIHByb3ZpZGVkXHJcblx0XHRcdHZhciByZXBsYWNlRm5SZXN1bHQ7XHJcblx0XHRcdGlmKCB0aGlzLnJlcGxhY2VGbiApIHtcclxuXHRcdFx0XHRyZXBsYWNlRm5SZXN1bHQgPSB0aGlzLnJlcGxhY2VGbi5jYWxsKCB0aGlzLCB0aGlzLCBtYXRjaCApOyAgLy8gQXV0b2xpbmtlciBpbnN0YW5jZSBpcyB0aGUgY29udGV4dCwgYW5kIHRoZSBmaXJzdCBhcmdcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYoIHR5cGVvZiByZXBsYWNlRm5SZXN1bHQgPT09ICdzdHJpbmcnICkge1xyXG5cdFx0XHRcdHJldHVybiByZXBsYWNlRm5SZXN1bHQ7ICAvLyBgcmVwbGFjZUZuYCByZXR1cm5lZCBhIHN0cmluZywgdXNlIHRoYXRcclxuXHJcblx0XHRcdH0gZWxzZSBpZiggcmVwbGFjZUZuUmVzdWx0ID09PSBmYWxzZSApIHtcclxuXHRcdFx0XHRyZXR1cm4gbWF0Y2hTdHI7ICAvLyBubyByZXBsYWNlbWVudCBmb3IgdGhlIG1hdGNoXHJcblxyXG5cdFx0XHR9IGVsc2UgaWYoIHJlcGxhY2VGblJlc3VsdCBpbnN0YW5jZW9mIEF1dG9saW5rZXIuSHRtbFRhZyApIHtcclxuXHRcdFx0XHRyZXR1cm4gcmVwbGFjZUZuUmVzdWx0LnRvU3RyaW5nKCk7XHJcblxyXG5cdFx0XHR9IGVsc2UgeyAgLy8gcmVwbGFjZUZuUmVzdWx0ID09PSB0cnVlLCBvciBuby91bmtub3duIHJldHVybiB2YWx1ZSBmcm9tIGZ1bmN0aW9uXHJcblx0XHRcdFx0Ly8gUGVyZm9ybSBBdXRvbGlua2VyJ3MgZGVmYXVsdCBhbmNob3IgdGFnIGdlbmVyYXRpb25cclxuXHRcdFx0XHR2YXIgdGFnQnVpbGRlciA9IHRoaXMuZ2V0VGFnQnVpbGRlcigpLFxyXG5cdFx0XHRcdCAgICBhbmNob3JUYWcgPSB0YWdCdWlsZGVyLmJ1aWxkKCBtYXRjaCApOyAgLy8gcmV0dXJucyBhbiBBdXRvbGlua2VyLkh0bWxUYWcgaW5zdGFuY2VcclxuXHJcblx0XHRcdFx0cmV0dXJuIGFuY2hvclRhZy50b1N0cmluZygpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBBdXRvbWF0aWNhbGx5IGxpbmtzIFVSTHMsIGVtYWlsIGFkZHJlc3NlcywgYW5kIFR3aXR0ZXIgaGFuZGxlcyBmb3VuZCBpbiB0aGUgZ2l2ZW4gY2h1bmsgb2YgSFRNTC4gXHJcblx0ICogRG9lcyBub3QgbGluayBVUkxzIGZvdW5kIHdpdGhpbiBIVE1MIHRhZ3MuXHJcblx0ICogXHJcblx0ICogRm9yIGluc3RhbmNlLCBpZiBnaXZlbiB0aGUgdGV4dDogYFlvdSBzaG91bGQgZ28gdG8gaHR0cDovL3d3dy55YWhvby5jb21gLCB0aGVuIHRoZSByZXN1bHRcclxuXHQgKiB3aWxsIGJlIGBZb3Ugc2hvdWxkIGdvIHRvICZsdDthIGhyZWY9XCJodHRwOi8vd3d3LnlhaG9vLmNvbVwiJmd0O2h0dHA6Ly93d3cueWFob28uY29tJmx0Oy9hJmd0O2BcclxuXHQgKiBcclxuXHQgKiBFeGFtcGxlOlxyXG5cdCAqIFxyXG5cdCAqICAgICB2YXIgbGlua2VkVGV4dCA9IEF1dG9saW5rZXIubGluayggXCJHbyB0byBnb29nbGUuY29tXCIsIHsgbmV3V2luZG93OiBmYWxzZSB9ICk7XHJcblx0ICogICAgIC8vIFByb2R1Y2VzOiBcIkdvIHRvIDxhIGhyZWY9XCJodHRwOi8vZ29vZ2xlLmNvbVwiPmdvb2dsZS5jb208L2E+XCJcclxuXHQgKiBcclxuXHQgKiBAc3RhdGljXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHRPckh0bWwgVGhlIEhUTUwgb3IgdGV4dCB0byBmaW5kIFVSTHMsIGVtYWlsIGFkZHJlc3NlcywgYW5kIFR3aXR0ZXIgaGFuZGxlcyB3aXRoaW4gKGRlcGVuZGluZyBvbiBpZlxyXG5cdCAqICAgdGhlIHtAbGluayAjdXJsc30sIHtAbGluayAjZW1haWx9LCBhbmQge0BsaW5rICN0d2l0dGVyfSBvcHRpb25zIGFyZSBlbmFibGVkKS5cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFueSBvZiB0aGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgQXV0b2xpbmtlciBjbGFzcywgc3BlY2lmaWVkIGluIGFuIE9iamVjdCAobWFwKS5cclxuXHQgKiAgIFNlZSB0aGUgY2xhc3MgZGVzY3JpcHRpb24gZm9yIGFuIGV4YW1wbGUgY2FsbC5cclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBIVE1MIHRleHQsIHdpdGggVVJMcyBhdXRvbWF0aWNhbGx5IGxpbmtlZFxyXG5cdCAqL1xyXG5cdEF1dG9saW5rZXIubGluayA9IGZ1bmN0aW9uKCB0ZXh0T3JIdG1sLCBvcHRpb25zICkge1xyXG5cdFx0dmFyIGF1dG9saW5rZXIgPSBuZXcgQXV0b2xpbmtlciggb3B0aW9ucyApO1xyXG5cdFx0cmV0dXJuIGF1dG9saW5rZXIubGluayggdGV4dE9ySHRtbCApO1xyXG5cdH07XHJcblxyXG5cclxuXHQvLyBOYW1lc3BhY2UgZm9yIGBtYXRjaGAgY2xhc3Nlc1xyXG5cdEF1dG9saW5rZXIubWF0Y2ggPSB7fTtcclxuXHQvKmdsb2JhbCBBdXRvbGlua2VyICovXHJcblx0Lypqc2hpbnQgZXFudWxsOnRydWUsIGJvc3M6dHJ1ZSAqL1xyXG5cdC8qKlxyXG5cdCAqIEBjbGFzcyBBdXRvbGlua2VyLlV0aWxcclxuXHQgKiBAc2luZ2xldG9uXHJcblx0ICogXHJcblx0ICogQSBmZXcgdXRpbGl0eSBtZXRob2RzIGZvciBBdXRvbGlua2VyLlxyXG5cdCAqL1xyXG5cdEF1dG9saW5rZXIuVXRpbCA9IHtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGFic3RyYWN0TWV0aG9kXHJcblx0XHQgKiBcclxuXHRcdCAqIEEgZnVuY3Rpb24gb2JqZWN0IHdoaWNoIHJlcHJlc2VudHMgYW4gYWJzdHJhY3QgbWV0aG9kLlxyXG5cdFx0ICovXHJcblx0XHRhYnN0cmFjdE1ldGhvZCA6IGZ1bmN0aW9uKCkgeyB0aHJvdyBcImFic3RyYWN0XCI7IH0sXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQXNzaWducyAoc2hhbGxvdyBjb3BpZXMpIHRoZSBwcm9wZXJ0aWVzIG9mIGBzcmNgIG9udG8gYGRlc3RgLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZGVzdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxyXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHNyYyBUaGUgc291cmNlIG9iamVjdC5cclxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlc3RpbmF0aW9uIG9iamVjdCAoYGRlc3RgKVxyXG5cdFx0ICovXHJcblx0XHRhc3NpZ24gOiBmdW5jdGlvbiggZGVzdCwgc3JjICkge1xyXG5cdFx0XHRmb3IoIHZhciBwcm9wIGluIHNyYyApIHtcclxuXHRcdFx0XHRpZiggc3JjLmhhc093blByb3BlcnR5KCBwcm9wICkgKSB7XHJcblx0XHRcdFx0XHRkZXN0WyBwcm9wIF0gPSBzcmNbIHByb3AgXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBkZXN0O1xyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBFeHRlbmRzIGBzdXBlcmNsYXNzYCB0byBjcmVhdGUgYSBuZXcgc3ViY2xhc3MsIGFkZGluZyB0aGUgYHByb3RvUHJvcHNgIHRvIHRoZSBuZXcgc3ViY2xhc3MncyBwcm90b3R5cGUuXHJcblx0XHQgKiBcclxuXHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IHN1cGVyY2xhc3MgVGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciB0aGUgc3VwZXJjbGFzcy5cclxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b1Byb3BzIFRoZSBtZXRob2RzL3Byb3BlcnRpZXMgdG8gYWRkIHRvIHRoZSBzdWJjbGFzcydzIHByb3RvdHlwZS4gVGhpcyBtYXkgY29udGFpbiB0aGVcclxuXHRcdCAqICAgc3BlY2lhbCBwcm9wZXJ0eSBgY29uc3RydWN0b3JgLCB3aGljaCB3aWxsIGJlIHVzZWQgYXMgdGhlIG5ldyBzdWJjbGFzcydzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxyXG5cdFx0ICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBuZXcgc3ViY2xhc3MgZnVuY3Rpb24uXHJcblx0XHQgKi9cclxuXHRcdGV4dGVuZCA6IGZ1bmN0aW9uKCBzdXBlcmNsYXNzLCBwcm90b1Byb3BzICkge1xyXG5cdFx0XHR2YXIgc3VwZXJjbGFzc1Byb3RvID0gc3VwZXJjbGFzcy5wcm90b3R5cGU7XHJcblxyXG5cdFx0XHR2YXIgRiA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRcdEYucHJvdG90eXBlID0gc3VwZXJjbGFzc1Byb3RvO1xyXG5cclxuXHRcdFx0dmFyIHN1YmNsYXNzO1xyXG5cdFx0XHRpZiggcHJvdG9Qcm9wcy5oYXNPd25Qcm9wZXJ0eSggJ2NvbnN0cnVjdG9yJyApICkge1xyXG5cdFx0XHRcdHN1YmNsYXNzID0gcHJvdG9Qcm9wcy5jb25zdHJ1Y3RvcjtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRzdWJjbGFzcyA9IGZ1bmN0aW9uKCkgeyBzdXBlcmNsYXNzUHJvdG8uY29uc3RydWN0b3IuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApOyB9O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgc3ViY2xhc3NQcm90byA9IHN1YmNsYXNzLnByb3RvdHlwZSA9IG5ldyBGKCk7ICAvLyBzZXQgdXAgcHJvdG90eXBlIGNoYWluXHJcblx0XHRcdHN1YmNsYXNzUHJvdG8uY29uc3RydWN0b3IgPSBzdWJjbGFzczsgIC8vIGZpeCBjb25zdHJ1Y3RvciBwcm9wZXJ0eVxyXG5cdFx0XHRzdWJjbGFzc1Byb3RvLnN1cGVyY2xhc3MgPSBzdXBlcmNsYXNzUHJvdG87XHJcblxyXG5cdFx0XHRkZWxldGUgcHJvdG9Qcm9wcy5jb25zdHJ1Y3RvcjsgIC8vIGRvbid0IHJlLWFzc2lnbiBjb25zdHJ1Y3RvciBwcm9wZXJ0eSB0byB0aGUgcHJvdG90eXBlLCBzaW5jZSBhIG5ldyBmdW5jdGlvbiBtYXkgaGF2ZSBiZWVuIGNyZWF0ZWQgKGBzdWJjbGFzc2ApLCB3aGljaCBpcyBub3cgYWxyZWFkeSB0aGVyZVxyXG5cdFx0XHRBdXRvbGlua2VyLlV0aWwuYXNzaWduKCBzdWJjbGFzc1Byb3RvLCBwcm90b1Byb3BzICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gc3ViY2xhc3M7XHJcblx0XHR9LFxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRydW5jYXRlcyB0aGUgYHN0cmAgYXQgYGxlbiAtIGVsbGlwc2lzQ2hhcnMubGVuZ3RoYCwgYW5kIGFkZHMgdGhlIGBlbGxpcHNpc0NoYXJzYCB0byB0aGVcclxuXHRcdCAqIGVuZCBvZiB0aGUgc3RyaW5nIChieSBkZWZhdWx0LCB0d28gcGVyaW9kczogJy4uJykuIElmIHRoZSBgc3RyYCBsZW5ndGggZG9lcyBub3QgZXhjZWVkIFxyXG5cdFx0ICogYGxlbmAsIHRoZSBzdHJpbmcgd2lsbCBiZSByZXR1cm5lZCB1bmNoYW5nZWQuXHJcblx0XHQgKiBcclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byB0cnVuY2F0ZSBhbmQgYWRkIGFuIGVsbGlwc2lzIHRvLlxyXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHRydW5jYXRlTGVuIFRoZSBsZW5ndGggdG8gdHJ1bmNhdGUgdGhlIHN0cmluZyBhdC5cclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBbZWxsaXBzaXNDaGFycz0uLl0gVGhlIGVsbGlwc2lzIGNoYXJhY3RlcihzKSB0byBhZGQgdG8gdGhlIGVuZCBvZiBgc3RyYFxyXG5cdFx0ICogICB3aGVuIHRydW5jYXRlZC4gRGVmYXVsdHMgdG8gJy4uJ1xyXG5cdFx0ICovXHJcblx0XHRlbGxpcHNpcyA6IGZ1bmN0aW9uKCBzdHIsIHRydW5jYXRlTGVuLCBlbGxpcHNpc0NoYXJzICkge1xyXG5cdFx0XHRpZiggc3RyLmxlbmd0aCA+IHRydW5jYXRlTGVuICkge1xyXG5cdFx0XHRcdGVsbGlwc2lzQ2hhcnMgPSAoIGVsbGlwc2lzQ2hhcnMgPT0gbnVsbCApID8gJy4uJyA6IGVsbGlwc2lzQ2hhcnM7XHJcblx0XHRcdFx0c3RyID0gc3RyLnN1YnN0cmluZyggMCwgdHJ1bmNhdGVMZW4gLSBlbGxpcHNpc0NoYXJzLmxlbmd0aCApICsgZWxsaXBzaXNDaGFycztcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gc3RyO1xyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBTdXBwb3J0cyBgQXJyYXkucHJvdG90eXBlLmluZGV4T2YoKWAgZnVuY3Rpb25hbGl0eSBmb3Igb2xkIElFIChJRTggYW5kIGJlbG93KS5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gYXJyIFRoZSBhcnJheSB0byBmaW5kIGFuIGVsZW1lbnQgb2YuXHJcblx0XHQgKiBAcGFyYW0geyp9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gZmluZCBpbiB0aGUgYXJyYXksIGFuZCByZXR1cm4gdGhlIGluZGV4IG9mLlxyXG5cdFx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgaW5kZXggb2YgdGhlIGBlbGVtZW50YCwgb3IgLTEgaWYgaXQgd2FzIG5vdCBmb3VuZC5cclxuXHRcdCAqL1xyXG5cdFx0aW5kZXhPZiA6IGZ1bmN0aW9uKCBhcnIsIGVsZW1lbnQgKSB7XHJcblx0XHRcdGlmKCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiApIHtcclxuXHRcdFx0XHRyZXR1cm4gYXJyLmluZGV4T2YoIGVsZW1lbnQgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Zm9yKCB2YXIgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcclxuXHRcdFx0XHRcdGlmKCBhcnJbIGkgXSA9PT0gZWxlbWVudCApIHJldHVybiBpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gLTE7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFBlcmZvcm1zIHRoZSBmdW5jdGlvbmFsaXR5IG9mIHdoYXQgbW9kZXJuIGJyb3dzZXJzIGRvIHdoZW4gYFN0cmluZy5wcm90b3R5cGUuc3BsaXQoKWAgaXMgY2FsbGVkXHJcblx0XHQgKiB3aXRoIGEgcmVndWxhciBleHByZXNzaW9uIHRoYXQgY29udGFpbnMgY2FwdHVyaW5nIHBhcmVudGhlc2lzLlxyXG5cdFx0ICogXHJcblx0XHQgKiBGb3IgZXhhbXBsZTpcclxuXHRcdCAqIFxyXG5cdFx0ICogICAgIC8vIE1vZGVybiBicm93c2VyczogXHJcblx0XHQgKiAgICAgXCJhLGIsY1wiLnNwbGl0KCAvKCwpLyApOyAgLy8gLS0+IFsgJ2EnLCAnLCcsICdiJywgJywnLCAnYycgXVxyXG5cdFx0ICogICAgIFxyXG5cdFx0ICogICAgIC8vIE9sZCBJRSAoaW5jbHVkaW5nIElFOCk6XHJcblx0XHQgKiAgICAgXCJhLGIsY1wiLnNwbGl0KCAvKCwpLyApOyAgLy8gLS0+IFsgJ2EnLCAnYicsICdjJyBdXHJcblx0XHQgKiAgICAgXHJcblx0XHQgKiBUaGlzIG1ldGhvZCBlbXVsYXRlcyB0aGUgZnVuY3Rpb25hbGl0eSBvZiBtb2Rlcm4gYnJvd3NlcnMgZm9yIHRoZSBvbGQgSUUgY2FzZS5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIHNwbGl0LlxyXG5cdFx0ICogQHBhcmFtIHtSZWdFeHB9IHNwbGl0UmVnZXggVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBzcGxpdCB0aGUgaW5wdXQgYHN0cmAgb24uIFRoZSBzcGxpdHRpbmdcclxuXHRcdCAqICAgY2hhcmFjdGVyKHMpIHdpbGwgYmUgc3BsaWNlZCBpbnRvIHRoZSBhcnJheSwgYXMgaW4gdGhlIFwibW9kZXJuIGJyb3dzZXJzXCIgZXhhbXBsZSBpbiB0aGUgXHJcblx0XHQgKiAgIGRlc2NyaXB0aW9uIG9mIHRoaXMgbWV0aG9kLiBcclxuXHRcdCAqICAgTm90ZSAjMTogdGhlIHN1cHBsaWVkIHJlZ3VsYXIgZXhwcmVzc2lvbiAqKm11c3QqKiBoYXZlIHRoZSAnZycgZmxhZyBzcGVjaWZpZWQuXHJcblx0XHQgKiAgIE5vdGUgIzI6IGZvciBzaW1wbGljaXR5J3Mgc2FrZSwgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBkb2VzIG5vdCBuZWVkIFxyXG5cdFx0ICogICB0byBjb250YWluIGNhcHR1cmluZyBwYXJlbnRoZXNpcyAtIGl0IHdpbGwgYmUgYXNzdW1lZCB0aGF0IGFueSBtYXRjaCBoYXMgdGhlbS5cclxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ1tdfSBUaGUgc3BsaXQgYXJyYXkgb2Ygc3RyaW5ncywgd2l0aCB0aGUgc3BsaXR0aW5nIGNoYXJhY3RlcihzKSBpbmNsdWRlZC5cclxuXHRcdCAqL1xyXG5cdFx0c3BsaXRBbmRDYXB0dXJlIDogZnVuY3Rpb24oIHN0ciwgc3BsaXRSZWdleCApIHtcclxuXHRcdFx0aWYoICFzcGxpdFJlZ2V4Lmdsb2JhbCApIHRocm93IG5ldyBFcnJvciggXCJgc3BsaXRSZWdleGAgbXVzdCBoYXZlIHRoZSAnZycgZmxhZyBzZXRcIiApO1xyXG5cclxuXHRcdFx0dmFyIHJlc3VsdCA9IFtdLFxyXG5cdFx0XHQgICAgbGFzdElkeCA9IDAsXHJcblx0XHRcdCAgICBtYXRjaDtcclxuXHJcblx0XHRcdHdoaWxlKCBtYXRjaCA9IHNwbGl0UmVnZXguZXhlYyggc3RyICkgKSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goIHN0ci5zdWJzdHJpbmcoIGxhc3RJZHgsIG1hdGNoLmluZGV4ICkgKTtcclxuXHRcdFx0XHRyZXN1bHQucHVzaCggbWF0Y2hbIDAgXSApOyAgLy8gcHVzaCB0aGUgc3BsaXR0aW5nIGNoYXIocylcclxuXHJcblx0XHRcdFx0bGFzdElkeCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbIDAgXS5sZW5ndGg7XHJcblx0XHRcdH1cclxuXHRcdFx0cmVzdWx0LnB1c2goIHN0ci5zdWJzdHJpbmcoIGxhc3RJZHggKSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHQvKmdsb2JhbCBBdXRvbGlua2VyICovXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAY2xhc3MgQXV0b2xpbmtlci5IdG1sUGFyc2VyXHJcblx0ICogQGV4dGVuZHMgT2JqZWN0XHJcblx0ICogXHJcblx0ICogQW4gSFRNTCBwYXJzZXIgaW1wbGVtZW50YXRpb24gd2hpY2ggc2ltcGx5IHdhbGtzIGFuIEhUTUwgc3RyaW5nIGFuZCBjYWxscyB0aGUgcHJvdmlkZWQgdmlzaXRvciBmdW5jdGlvbnMgdG8gcHJvY2VzcyBcclxuXHQgKiBIVE1MIGFuZCB0ZXh0IG5vZGVzLlxyXG5cdCAqIFxyXG5cdCAqIEF1dG9saW5rZXIgdXNlcyB0aGlzIHRvIG9ubHkgbGluayBVUkxzL2VtYWlscy9Ud2l0dGVyIGhhbmRsZXMgd2l0aGluIHRleHQgbm9kZXMsIGJhc2ljYWxseSBpZ25vcmluZyBIVE1MIHRhZ3MuXHJcblx0ICovXHJcblx0QXV0b2xpbmtlci5IdG1sUGFyc2VyID0gQXV0b2xpbmtlci5VdGlsLmV4dGVuZCggT2JqZWN0LCB7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHByb3BlcnR5IHtSZWdFeHB9IGh0bWxSZWdleFxyXG5cdFx0ICogXHJcblx0XHQgKiBUaGUgcmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gcHVsbCBvdXQgSFRNTCB0YWdzIGZyb20gYSBzdHJpbmcuIEhhbmRsZXMgbmFtZXNwYWNlZCBIVE1MIHRhZ3MgYW5kXHJcblx0XHQgKiBhdHRyaWJ1dGUgbmFtZXMsIGFzIHNwZWNpZmllZCBieSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sLW1hcmt1cC9zeW50YXguaHRtbC5cclxuXHRcdCAqIFxyXG5cdFx0ICogQ2FwdHVyaW5nIGdyb3VwczpcclxuXHRcdCAqIFxyXG5cdFx0ICogMS4gVGhlIFwiIURPQ1RZUEVcIiB0YWcgbmFtZSwgaWYgYSB0YWcgaXMgYSAmbHQ7IURPQ1RZUEUmZ3Q7IHRhZy5cclxuXHRcdCAqIDIuIElmIGl0IGlzIGFuIGVuZCB0YWcsIHRoaXMgZ3JvdXAgd2lsbCBoYXZlIHRoZSAnLycuXHJcblx0XHQgKiAzLiBUaGUgdGFnIG5hbWUgZm9yIGFsbCB0YWdzIChvdGhlciB0aGFuIHRoZSAmbHQ7IURPQ1RZUEUmZ3Q7IHRhZylcclxuXHRcdCAqL1xyXG5cdFx0aHRtbFJlZ2V4IDogKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR2YXIgdGFnTmFtZVJlZ2V4ID0gL1swLTlhLXpBLVpdWzAtOWEtekEtWjpdKi8sXHJcblx0XHRcdCAgICBhdHRyTmFtZVJlZ2V4ID0gL1teXFxzXFwwXCInPlxcLz1cXHgwMS1cXHgxRlxceDdGXSsvLCAgIC8vIHRoZSB1bmljb2RlIHJhbmdlIGFjY291bnRzIGZvciBleGNsdWRpbmcgY29udHJvbCBjaGFycywgYW5kIHRoZSBkZWxldGUgY2hhclxyXG5cdFx0XHQgICAgYXR0clZhbHVlUmVnZXggPSAvKD86XCJbXlwiXSo/XCJ8J1teJ10qPyd8W14nXCI9PD5gXFxzXSspLywgLy8gZG91YmxlIHF1b3RlZCwgc2luZ2xlIHF1b3RlZCwgb3IgdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlc1xyXG5cdFx0XHQgICAgbmFtZUVxdWFsc1ZhbHVlUmVnZXggPSBhdHRyTmFtZVJlZ2V4LnNvdXJjZSArICcoPzpcXFxccyo9XFxcXHMqJyArIGF0dHJWYWx1ZVJlZ2V4LnNvdXJjZSArICcpPyc7ICAvLyBvcHRpb25hbCAnPVt2YWx1ZV0nXHJcblxyXG5cdFx0XHRyZXR1cm4gbmV3IFJlZ0V4cCggW1xyXG5cdFx0XHRcdC8vIGZvciA8IURPQ1RZUEU+IHRhZy4gRXg6IDwhRE9DVFlQRSBodG1sIFBVQkxJQyBcIi0vL1czQy8vRFREIFhIVE1MIDEuMCBTdHJpY3QvL0VOXCIgXCJodHRwOi8vd3d3LnczLm9yZy9UUi94aHRtbDEvRFREL3hodG1sMS1zdHJpY3QuZHRkXCI+KSBcclxuXHRcdFx0XHQnKD86JyxcclxuXHRcdFx0XHRcdCc8KCFET0NUWVBFKScsICAvLyAqKiogQ2FwdHVyaW5nIEdyb3VwIDEgLSBJZiBpdCdzIGEgZG9jdHlwZSB0YWdcclxuXHJcblx0XHRcdFx0XHRcdC8vIFplcm8gb3IgbW9yZSBhdHRyaWJ1dGVzIGZvbGxvd2luZyB0aGUgdGFnIG5hbWVcclxuXHRcdFx0XHRcdFx0Jyg/OicsXHJcblx0XHRcdFx0XHRcdFx0J1xcXFxzKycsICAvLyBvbmUgb3IgbW9yZSB3aGl0ZXNwYWNlIGNoYXJzIGJlZm9yZSBhbiBhdHRyaWJ1dGVcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gRWl0aGVyOlxyXG5cdFx0XHRcdFx0XHRcdC8vIEEuIGF0dHI9XCJ2YWx1ZVwiLCBvciBcclxuXHRcdFx0XHRcdFx0XHQvLyBCLiBcInZhbHVlXCIgYWxvbmUgKFRvIGNvdmVyIGV4YW1wbGUgZG9jdHlwZSB0YWc6IDwhRE9DVFlQRSBodG1sIFBVQkxJQyBcIi0vL1czQy8vRFREIFhIVE1MIDEuMCBTdHJpY3QvL0VOXCIgXCJodHRwOi8vd3d3LnczLm9yZy9UUi94aHRtbDEvRFREL3hodG1sMS1zdHJpY3QuZHRkXCI+KSBcclxuXHRcdFx0XHRcdFx0XHQnKD86JywgbmFtZUVxdWFsc1ZhbHVlUmVnZXgsICd8JywgYXR0clZhbHVlUmVnZXguc291cmNlICsgJyknLFxyXG5cdFx0XHRcdFx0XHQnKSonLFxyXG5cdFx0XHRcdFx0Jz4nLFxyXG5cdFx0XHRcdCcpJyxcclxuXHJcblx0XHRcdFx0J3wnLFxyXG5cclxuXHRcdFx0XHQvLyBBbGwgb3RoZXIgSFRNTCB0YWdzIChpLmUuIHRhZ3MgdGhhdCBhcmUgbm90IDwhRE9DVFlQRT4pXHJcblx0XHRcdFx0Jyg/OicsXHJcblx0XHRcdFx0XHQnPCgvKT8nLCAgLy8gQmVnaW5uaW5nIG9mIGEgdGFnLiBFaXRoZXIgJzwnIGZvciBhIHN0YXJ0IHRhZywgb3IgJzwvJyBmb3IgYW4gZW5kIHRhZy4gXHJcblx0XHRcdFx0XHQgICAgICAgICAgLy8gKioqIENhcHR1cmluZyBHcm91cCAyOiBUaGUgc2xhc2ggb3IgYW4gZW1wdHkgc3RyaW5nLiBTbGFzaCAoJy8nKSBmb3IgZW5kIHRhZywgZW1wdHkgc3RyaW5nIGZvciBzdGFydCBvciBzZWxmLWNsb3NpbmcgdGFnLlxyXG5cclxuXHRcdFx0XHRcdFx0Ly8gKioqIENhcHR1cmluZyBHcm91cCAzIC0gVGhlIHRhZyBuYW1lXHJcblx0XHRcdFx0XHRcdCcoJyArIHRhZ05hbWVSZWdleC5zb3VyY2UgKyAnKScsXHJcblxyXG5cdFx0XHRcdFx0XHQvLyBaZXJvIG9yIG1vcmUgYXR0cmlidXRlcyBmb2xsb3dpbmcgdGhlIHRhZyBuYW1lXHJcblx0XHRcdFx0XHRcdCcoPzonLFxyXG5cdFx0XHRcdFx0XHRcdCdcXFxccysnLCAgICAgICAgICAgICAgICAvLyBvbmUgb3IgbW9yZSB3aGl0ZXNwYWNlIGNoYXJzIGJlZm9yZSBhbiBhdHRyaWJ1dGVcclxuXHRcdFx0XHRcdFx0XHRuYW1lRXF1YWxzVmFsdWVSZWdleCwgIC8vIGF0dHI9XCJ2YWx1ZVwiICh3aXRoIG9wdGlvbmFsID1cInZhbHVlXCIgcGFydClcclxuXHRcdFx0XHRcdFx0JykqJyxcclxuXHJcblx0XHRcdFx0XHRcdCdcXFxccyovPycsICAvLyBhbnkgdHJhaWxpbmcgc3BhY2VzIGFuZCBvcHRpb25hbCAnLycgYmVmb3JlIHRoZSBjbG9zaW5nICc+J1xyXG5cdFx0XHRcdFx0Jz4nLFxyXG5cdFx0XHRcdCcpJ1xyXG5cdFx0XHRdLmpvaW4oIFwiXCIgKSwgJ2dpJyApO1xyXG5cdFx0fSApKCksXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogV2Fsa3MgYW4gSFRNTCBzdHJpbmcsIGNhbGxpbmcgdGhlIGBvcHRpb25zLnByb2Nlc3NIdG1sTm9kZWAgZnVuY3Rpb24gZm9yIGVhY2ggSFRNTCB0YWcgdGhhdCBpcyBlbmNvdW50ZXJlZCwgYW5kIGNhbGxpbmdcclxuXHRcdCAqIHRoZSBgb3B0aW9ucy5wcm9jZXNzVGV4dE5vZGVgIGZ1bmN0aW9uIHdoZW4gZWFjaCB0ZXh0IGFyb3VuZCBIVE1MIHRhZ3MgaXMgZW5jb3VudGVyZWQuXHJcblx0XHQgKiBcclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBodG1sIFRoZSBIVE1MIHRvIHBhcnNlLlxyXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbiBPYmplY3QgKG1hcCkgd2hpY2ggbWF5IGNvbnRhaW4gdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5wcm9jZXNzSHRtbE5vZGVdIEEgdmlzaXRvciBmdW5jdGlvbiB3aGljaCBhbGxvd3MgcHJvY2Vzc2luZyBvZiBhbiBlbmNvdW50ZXJlZCBIVE1MIG5vZGUuXHJcblx0XHQgKiAgIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggdGhlIGZvbGxvd2luZyBhcmd1bWVudHM6XHJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucHJvY2Vzc0h0bWxOb2RlLnRhZ1RleHRdIFRoZSBIVE1MIHRhZyB0ZXh0IHRoYXQgd2FzIGZvdW5kLlxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnByb2Nlc3NIdG1sTm9kZS50YWdOYW1lXSBUaGUgdGFnIG5hbWUgZm9yIHRoZSBIVE1MIHRhZyB0aGF0IHdhcyBmb3VuZC4gRXg6ICdhJyBmb3IgYW4gYW5jaG9yIHRhZy5cclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wcm9jZXNzSHRtbE5vZGUuaXNDbG9zaW5nVGFnXSBgdHJ1ZWAgaWYgdGhlIHRhZyBpcyBhIGNsb3NpbmcgdGFnIChleDogJmx0Oy9hJmd0OyksIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG5cdFx0ICogIFxyXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMucHJvY2Vzc1RleHROb2RlXSBBIHZpc2l0b3IgZnVuY3Rpb24gd2hpY2ggYWxsb3dzIHByb2Nlc3Npbmcgb2YgYW4gZW5jb3VudGVyZWQgdGV4dCBub2RlLlxyXG5cdFx0ICogICBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIHRoZSBmb2xsb3dpbmcgYXJndW1lbnRzOlxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnByb2Nlc3NUZXh0Tm9kZS50ZXh0XSBUaGUgdGV4dCBub2RlIHRoYXQgd2FzIG1hdGNoZWQuXHJcblx0XHQgKi9cclxuXHRcdHBhcnNlIDogZnVuY3Rpb24oIGh0bWwsIG9wdGlvbnMgKSB7XHJcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuXHRcdFx0dmFyIHByb2Nlc3NIdG1sTm9kZVZpc2l0b3IgPSBvcHRpb25zLnByb2Nlc3NIdG1sTm9kZSB8fCBmdW5jdGlvbigpIHt9LFxyXG5cdFx0XHQgICAgcHJvY2Vzc1RleHROb2RlVmlzaXRvciA9IG9wdGlvbnMucHJvY2Vzc1RleHROb2RlIHx8IGZ1bmN0aW9uKCkge30sXHJcblx0XHRcdCAgICBodG1sUmVnZXggPSB0aGlzLmh0bWxSZWdleCxcclxuXHRcdFx0ICAgIGN1cnJlbnRSZXN1bHQsXHJcblx0XHRcdCAgICBsYXN0SW5kZXggPSAwO1xyXG5cclxuXHRcdFx0Ly8gTG9vcCBvdmVyIHRoZSBIVE1MIHN0cmluZywgaWdub3JpbmcgSFRNTCB0YWdzLCBhbmQgcHJvY2Vzc2luZyB0aGUgdGV4dCB0aGF0IGxpZXMgYmV0d2VlbiB0aGVtLFxyXG5cdFx0XHQvLyB3cmFwcGluZyB0aGUgVVJMcyBpbiBhbmNob3IgdGFnc1xyXG5cdFx0XHR3aGlsZSggKCBjdXJyZW50UmVzdWx0ID0gaHRtbFJlZ2V4LmV4ZWMoIGh0bWwgKSApICE9PSBudWxsICkge1xyXG5cdFx0XHRcdHZhciB0YWdUZXh0ID0gY3VycmVudFJlc3VsdFsgMCBdLFxyXG5cdFx0XHRcdCAgICB0YWdOYW1lID0gY3VycmVudFJlc3VsdFsgMSBdIHx8IGN1cnJlbnRSZXN1bHRbIDMgXSwgIC8vIFRoZSA8IURPQ1RZUEU+IHRhZyAoZXg6IFwiIURPQ1RZUEVcIiksIG9yIGFub3RoZXIgdGFnIChleDogXCJhXCIpIFxyXG5cdFx0XHRcdCAgICBpc0Nsb3NpbmdUYWcgPSAhIWN1cnJlbnRSZXN1bHRbIDIgXSxcclxuXHRcdFx0XHQgICAgaW5CZXR3ZWVuVGFnc1RleHQgPSBodG1sLnN1YnN0cmluZyggbGFzdEluZGV4LCBjdXJyZW50UmVzdWx0LmluZGV4ICk7XHJcblxyXG5cdFx0XHRcdGlmKCBpbkJldHdlZW5UYWdzVGV4dCApIHtcclxuXHRcdFx0XHRcdHByb2Nlc3NUZXh0Tm9kZVZpc2l0b3IoIGluQmV0d2VlblRhZ3NUZXh0ICk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRwcm9jZXNzSHRtbE5vZGVWaXNpdG9yKCB0YWdUZXh0LCB0YWdOYW1lLnRvTG93ZXJDYXNlKCksIGlzQ2xvc2luZ1RhZyApO1xyXG5cclxuXHRcdFx0XHRsYXN0SW5kZXggPSBjdXJyZW50UmVzdWx0LmluZGV4ICsgdGFnVGV4dC5sZW5ndGg7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFByb2Nlc3MgYW55IHJlbWFpbmluZyB0ZXh0IGFmdGVyIHRoZSBsYXN0IEhUTUwgZWxlbWVudC4gV2lsbCBwcm9jZXNzIGFsbCBvZiB0aGUgdGV4dCBpZiB0aGVyZSB3ZXJlIG5vIEhUTUwgZWxlbWVudHMuXHJcblx0XHRcdGlmKCBsYXN0SW5kZXggPCBodG1sLmxlbmd0aCApIHtcclxuXHRcdFx0XHR2YXIgdGV4dCA9IGh0bWwuc3Vic3RyaW5nKCBsYXN0SW5kZXggKTtcclxuXHJcblx0XHRcdFx0aWYoIHRleHQgKSB7XHJcblx0XHRcdFx0XHRwcm9jZXNzVGV4dE5vZGVWaXNpdG9yKCB0ZXh0ICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHQvKmdsb2JhbCBBdXRvbGlua2VyICovXHJcblx0Lypqc2hpbnQgYm9zczp0cnVlICovXHJcblx0LyoqXHJcblx0ICogQGNsYXNzIEF1dG9saW5rZXIuSHRtbFRhZ1xyXG5cdCAqIEBleHRlbmRzIE9iamVjdFxyXG5cdCAqIFxyXG5cdCAqIFJlcHJlc2VudHMgYW4gSFRNTCB0YWcsIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGVhc2lseSBidWlsZC9tb2RpZnkgSFRNTCB0YWdzIHByb2dyYW1tYXRpY2FsbHkuXHJcblx0ICogXHJcblx0ICogQXV0b2xpbmtlciB1c2VzIHRoaXMgYWJzdHJhY3Rpb24gdG8gY3JlYXRlIEhUTUwgdGFncywgYW5kIHRoZW4gd3JpdGUgdGhlbSBvdXQgYXMgc3RyaW5ncy4gWW91IG1heSBhbHNvIHVzZVxyXG5cdCAqIHRoaXMgY2xhc3MgaW4geW91ciBjb2RlLCBlc3BlY2lhbGx5IHdpdGhpbiBhIHtAbGluayBBdXRvbGlua2VyI3JlcGxhY2VGbiByZXBsYWNlRm59LlxyXG5cdCAqIFxyXG5cdCAqICMjIEV4YW1wbGVzXHJcblx0ICogXHJcblx0ICogRXhhbXBsZSBpbnN0YW50aWF0aW9uOlxyXG5cdCAqIFxyXG5cdCAqICAgICB2YXIgdGFnID0gbmV3IEF1dG9saW5rZXIuSHRtbFRhZygge1xyXG5cdCAqICAgICAgICAgdGFnTmFtZSA6ICdhJyxcclxuXHQgKiAgICAgICAgIGF0dHJzICAgOiB7ICdocmVmJzogJ2h0dHA6Ly9nb29nbGUuY29tJywgJ2NsYXNzJzogJ2V4dGVybmFsLWxpbmsnIH0sXHJcblx0ICogICAgICAgICBpbm5lckh0bWwgOiAnR29vZ2xlJ1xyXG5cdCAqICAgICB9ICk7XHJcblx0ICogICAgIFxyXG5cdCAqICAgICB0YWcudG9TdHJpbmcoKTsgIC8vIDxhIGhyZWY9XCJodHRwOi8vZ29vZ2xlLmNvbVwiIGNsYXNzPVwiZXh0ZXJuYWwtbGlua1wiPkdvb2dsZTwvYT5cclxuXHQgKiAgICAgXHJcblx0ICogICAgIC8vIEluZGl2aWR1YWwgYWNjZXNzb3IgbWV0aG9kc1xyXG5cdCAqICAgICB0YWcuZ2V0VGFnTmFtZSgpOyAgICAgICAgICAgICAgICAgLy8gJ2EnXHJcblx0ICogICAgIHRhZy5nZXRBdHRyKCAnaHJlZicgKTsgICAgICAgICAgICAvLyAnaHR0cDovL2dvb2dsZS5jb20nXHJcblx0ICogICAgIHRhZy5oYXNDbGFzcyggJ2V4dGVybmFsLWxpbmsnICk7ICAvLyB0cnVlXHJcblx0ICogXHJcblx0ICogXHJcblx0ICogVXNpbmcgbXV0YXRvciBtZXRob2RzICh3aGljaCBtYXkgYmUgdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIGluc3RhbnRpYXRpb24gY29uZmlnIHByb3BlcnRpZXMpOlxyXG5cdCAqIFxyXG5cdCAqICAgICB2YXIgdGFnID0gbmV3IEF1dG9saW5rZXIuSHRtbFRhZygpO1xyXG5cdCAqICAgICB0YWcuc2V0VGFnTmFtZSggJ2EnICk7XHJcblx0ICogICAgIHRhZy5zZXRBdHRyKCAnaHJlZicsICdodHRwOi8vZ29vZ2xlLmNvbScgKTtcclxuXHQgKiAgICAgdGFnLmFkZENsYXNzKCAnZXh0ZXJuYWwtbGluaycgKTtcclxuXHQgKiAgICAgdGFnLnNldElubmVySHRtbCggJ0dvb2dsZScgKTtcclxuXHQgKiAgICAgXHJcblx0ICogICAgIHRhZy5nZXRUYWdOYW1lKCk7ICAgICAgICAgICAgICAgICAvLyAnYSdcclxuXHQgKiAgICAgdGFnLmdldEF0dHIoICdocmVmJyApOyAgICAgICAgICAgIC8vICdodHRwOi8vZ29vZ2xlLmNvbSdcclxuXHQgKiAgICAgdGFnLmhhc0NsYXNzKCAnZXh0ZXJuYWwtbGluaycgKTsgIC8vIHRydWVcclxuXHQgKiAgICAgXHJcblx0ICogICAgIHRhZy50b1N0cmluZygpOyAgLy8gPGEgaHJlZj1cImh0dHA6Ly9nb29nbGUuY29tXCIgY2xhc3M9XCJleHRlcm5hbC1saW5rXCI+R29vZ2xlPC9hPlxyXG5cdCAqICAgICBcclxuXHQgKiBcclxuXHQgKiAjIyBFeGFtcGxlIHVzZSB3aXRoaW4gYSB7QGxpbmsgQXV0b2xpbmtlciNyZXBsYWNlRm4gcmVwbGFjZUZufVxyXG5cdCAqIFxyXG5cdCAqICAgICB2YXIgaHRtbCA9IEF1dG9saW5rZXIubGluayggXCJUZXN0IGdvb2dsZS5jb21cIiwge1xyXG5cdCAqICAgICAgICAgcmVwbGFjZUZuIDogZnVuY3Rpb24oIGF1dG9saW5rZXIsIG1hdGNoICkge1xyXG5cdCAqICAgICAgICAgICAgIHZhciB0YWcgPSBhdXRvbGlua2VyLmdldFRhZ0J1aWxkZXIoKS5idWlsZCggbWF0Y2ggKTsgIC8vIHJldHVybnMgYW4ge0BsaW5rIEF1dG9saW5rZXIuSHRtbFRhZ30gaW5zdGFuY2UsIGNvbmZpZ3VyZWQgd2l0aCB0aGUgTWF0Y2gncyBocmVmIGFuZCBhbmNob3IgdGV4dFxyXG5cdCAqICAgICAgICAgICAgIHRhZy5zZXRBdHRyKCAncmVsJywgJ25vZm9sbG93JyApO1xyXG5cdCAqICAgICAgICAgICAgIFxyXG5cdCAqICAgICAgICAgICAgIHJldHVybiB0YWc7XHJcblx0ICogICAgICAgICB9XHJcblx0ICogICAgIH0gKTtcclxuXHQgKiAgICAgXHJcblx0ICogICAgIC8vIGdlbmVyYXRlZCBodG1sOlxyXG5cdCAqICAgICAvLyAgIFRlc3QgPGEgaHJlZj1cImh0dHA6Ly9nb29nbGUuY29tXCIgdGFyZ2V0PVwiX2JsYW5rXCIgcmVsPVwibm9mb2xsb3dcIj5nb29nbGUuY29tPC9hPlxyXG5cdCAqICAgICBcclxuXHQgKiAgICAgXHJcblx0ICogIyMgRXhhbXBsZSB1c2Ugd2l0aCBhIG5ldyB0YWcgZm9yIHRoZSByZXBsYWNlbWVudFxyXG5cdCAqIFxyXG5cdCAqICAgICB2YXIgaHRtbCA9IEF1dG9saW5rZXIubGluayggXCJUZXN0IGdvb2dsZS5jb21cIiwge1xyXG5cdCAqICAgICAgICAgcmVwbGFjZUZuIDogZnVuY3Rpb24oIGF1dG9saW5rZXIsIG1hdGNoICkge1xyXG5cdCAqICAgICAgICAgICAgIHZhciB0YWcgPSBuZXcgQXV0b2xpbmtlci5IdG1sVGFnKCB7XHJcblx0ICogICAgICAgICAgICAgICAgIHRhZ05hbWUgOiAnYnV0dG9uJyxcclxuXHQgKiAgICAgICAgICAgICAgICAgYXR0cnMgICA6IHsgJ3RpdGxlJzogJ0xvYWQgVVJMOiAnICsgbWF0Y2guZ2V0QW5jaG9ySHJlZigpIH0sXHJcblx0ICogICAgICAgICAgICAgICAgIGlubmVySHRtbCA6ICdMb2FkIFVSTDogJyArIG1hdGNoLmdldEFuY2hvclRleHQoKVxyXG5cdCAqICAgICAgICAgICAgIH0gKTtcclxuXHQgKiAgICAgICAgICAgICBcclxuXHQgKiAgICAgICAgICAgICByZXR1cm4gdGFnO1xyXG5cdCAqICAgICAgICAgfVxyXG5cdCAqICAgICB9ICk7XHJcblx0ICogICAgIFxyXG5cdCAqICAgICAvLyBnZW5lcmF0ZWQgaHRtbDpcclxuXHQgKiAgICAgLy8gICBUZXN0IDxidXR0b24gdGl0bGU9XCJMb2FkIFVSTDogaHR0cDovL2dvb2dsZS5jb21cIj5Mb2FkIFVSTDogZ29vZ2xlLmNvbTwvYnV0dG9uPlxyXG5cdCAqL1xyXG5cdEF1dG9saW5rZXIuSHRtbFRhZyA9IEF1dG9saW5rZXIuVXRpbC5leHRlbmQoIE9iamVjdCwge1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQGNmZyB7U3RyaW5nfSB0YWdOYW1lXHJcblx0XHQgKiBcclxuXHRcdCAqIFRoZSB0YWcgbmFtZS4gRXg6ICdhJywgJ2J1dHRvbicsIGV0Yy5cclxuXHRcdCAqIFxyXG5cdFx0ICogTm90IHJlcXVpcmVkIGF0IGluc3RhbnRpYXRpb24gdGltZSwgYnV0IHNob3VsZCBiZSBzZXQgdXNpbmcge0BsaW5rICNzZXRUYWdOYW1lfSBiZWZvcmUge0BsaW5rICN0b1N0cmluZ31cclxuXHRcdCAqIGlzIGV4ZWN1dGVkLlxyXG5cdFx0ICovXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBAY2ZnIHtPYmplY3QuPFN0cmluZywgU3RyaW5nPn0gYXR0cnNcclxuXHRcdCAqIFxyXG5cdFx0ICogQW4ga2V5L3ZhbHVlIE9iamVjdCAobWFwKSBvZiBhdHRyaWJ1dGVzIHRvIGNyZWF0ZSB0aGUgdGFnIHdpdGguIFRoZSBrZXlzIGFyZSB0aGUgYXR0cmlidXRlIG5hbWVzLCBhbmQgdGhlXHJcblx0XHQgKiB2YWx1ZXMgYXJlIHRoZSBhdHRyaWJ1dGUgdmFsdWVzLlxyXG5cdFx0ICovXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBAY2ZnIHtTdHJpbmd9IGlubmVySHRtbFxyXG5cdFx0ICogXHJcblx0XHQgKiBUaGUgaW5uZXIgSFRNTCBmb3IgdGhlIHRhZy4gXHJcblx0XHQgKiBcclxuXHRcdCAqIE5vdGUgdGhlIGNhbWVsIGNhc2UgbmFtZSBvbiBgaW5uZXJIdG1sYC4gQWNyb255bXMgYXJlIGNhbWVsQ2FzZWQgaW4gdGhpcyB1dGlsaXR5IChzdWNoIGFzIG5vdCB0byBydW4gaW50byB0aGUgYWNyb255bSBcclxuXHRcdCAqIG5hbWluZyBpbmNvbnNpc3RlbmN5IHRoYXQgdGhlIERPTSBkZXZlbG9wZXJzIGNyZWF0ZWQgd2l0aCBgWE1MSHR0cFJlcXVlc3RgKS4gWW91IG1heSBhbHRlcm5hdGl2ZWx5IHVzZSB7QGxpbmsgI2lubmVySFRNTH1cclxuXHRcdCAqIGlmIHlvdSBwcmVmZXIsIGJ1dCB0aGlzIG9uZSBpcyByZWNvbW1lbmRlZC5cclxuXHRcdCAqL1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQGNmZyB7U3RyaW5nfSBpbm5lckhUTUxcclxuXHRcdCAqIFxyXG5cdFx0ICogQWxpYXMgb2Yge0BsaW5rICNpbm5lckh0bWx9LCBhY2NlcHRlZCBmb3IgY29uc2lzdGVuY3kgd2l0aCB0aGUgYnJvd3NlciBET00gYXBpLCBidXQgcHJlZmVyIHRoZSBjYW1lbENhc2VkIHZlcnNpb25cclxuXHRcdCAqIGZvciBhY3JvbnltIG5hbWVzLlxyXG5cdFx0ICovXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQHByb3RlY3RlZFxyXG5cdFx0ICogQHByb3BlcnR5IHtSZWdFeHB9IHdoaXRlc3BhY2VSZWdleFxyXG5cdFx0ICogXHJcblx0XHQgKiBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byBtYXRjaCB3aGl0ZXNwYWNlIGluIGEgc3RyaW5nIG9mIENTUyBjbGFzc2VzLlxyXG5cdFx0ICovXHJcblx0XHR3aGl0ZXNwYWNlUmVnZXggOiAvXFxzKy8sXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQGNvbnN0cnVjdG9yXHJcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gW2NmZ10gVGhlIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcyBmb3IgdGhpcyBjbGFzcywgaW4gYW4gT2JqZWN0IChtYXApXHJcblx0XHQgKi9cclxuXHRcdGNvbnN0cnVjdG9yIDogZnVuY3Rpb24oIGNmZyApIHtcclxuXHRcdFx0QXV0b2xpbmtlci5VdGlsLmFzc2lnbiggdGhpcywgY2ZnICk7XHJcblxyXG5cdFx0XHR0aGlzLmlubmVySHRtbCA9IHRoaXMuaW5uZXJIdG1sIHx8IHRoaXMuaW5uZXJIVE1MOyAgLy8gYWNjZXB0IGVpdGhlciB0aGUgY2FtZWxDYXNlZCBmb3JtIG9yIHRoZSBmdWxseSBjYXBpdGFsaXplZCBhY3JvbnltXHJcblx0XHR9LFxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFNldHMgdGhlIHRhZyBuYW1lIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGdlbmVyYXRlIHRoZSB0YWcgd2l0aC5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHRhZ05hbWVcclxuXHRcdCAqIEByZXR1cm4ge0F1dG9saW5rZXIuSHRtbFRhZ30gVGhpcyBIdG1sVGFnIGluc3RhbmNlLCBzbyB0aGF0IG1ldGhvZCBjYWxscyBtYXkgYmUgY2hhaW5lZC5cclxuXHRcdCAqL1xyXG5cdFx0c2V0VGFnTmFtZSA6IGZ1bmN0aW9uKCB0YWdOYW1lICkge1xyXG5cdFx0XHR0aGlzLnRhZ05hbWUgPSB0YWdOYW1lO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH0sXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogUmV0cmlldmVzIHRoZSB0YWcgbmFtZS5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfVxyXG5cdFx0ICovXHJcblx0XHRnZXRUYWdOYW1lIDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnRhZ05hbWUgfHwgXCJcIjtcclxuXHRcdH0sXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogU2V0cyBhbiBhdHRyaWJ1dGUgb24gdGhlIEh0bWxUYWcuXHJcblx0XHQgKiBcclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyTmFtZSBUaGUgYXR0cmlidXRlIG5hbWUgdG8gc2V0LlxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGF0dHJWYWx1ZSBUaGUgYXR0cmlidXRlIHZhbHVlIHRvIHNldC5cclxuXHRcdCAqIEByZXR1cm4ge0F1dG9saW5rZXIuSHRtbFRhZ30gVGhpcyBIdG1sVGFnIGluc3RhbmNlLCBzbyB0aGF0IG1ldGhvZCBjYWxscyBtYXkgYmUgY2hhaW5lZC5cclxuXHRcdCAqL1xyXG5cdFx0c2V0QXR0ciA6IGZ1bmN0aW9uKCBhdHRyTmFtZSwgYXR0clZhbHVlICkge1xyXG5cdFx0XHR2YXIgdGFnQXR0cnMgPSB0aGlzLmdldEF0dHJzKCk7XHJcblx0XHRcdHRhZ0F0dHJzWyBhdHRyTmFtZSBdID0gYXR0clZhbHVlO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9LFxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFJldHJpZXZlcyBhbiBhdHRyaWJ1dGUgZnJvbSB0aGUgSHRtbFRhZy4gSWYgdGhlIGF0dHJpYnV0ZSBkb2VzIG5vdCBleGlzdCwgcmV0dXJucyBgdW5kZWZpbmVkYC5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGF0dHJpYnV0ZSBuYW1lIHRvIHJldHJpZXZlLlxyXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgYXR0cmlidXRlJ3MgdmFsdWUsIG9yIGB1bmRlZmluZWRgIGlmIGl0IGRvZXMgbm90IGV4aXN0IG9uIHRoZSBIdG1sVGFnLlxyXG5cdFx0ICovXHJcblx0XHRnZXRBdHRyIDogZnVuY3Rpb24oIGF0dHJOYW1lICkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRBdHRycygpWyBhdHRyTmFtZSBdO1xyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBTZXRzIG9uZSBvciBtb3JlIGF0dHJpYnV0ZXMgb24gdGhlIEh0bWxUYWcuXHJcblx0XHQgKiBcclxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0LjxTdHJpbmcsIFN0cmluZz59IGF0dHJzIEEga2V5L3ZhbHVlIE9iamVjdCAobWFwKSBvZiB0aGUgYXR0cmlidXRlcyB0byBzZXQuXHJcblx0XHQgKiBAcmV0dXJuIHtBdXRvbGlua2VyLkh0bWxUYWd9IFRoaXMgSHRtbFRhZyBpbnN0YW5jZSwgc28gdGhhdCBtZXRob2QgY2FsbHMgbWF5IGJlIGNoYWluZWQuXHJcblx0XHQgKi9cclxuXHRcdHNldEF0dHJzIDogZnVuY3Rpb24oIGF0dHJzICkge1xyXG5cdFx0XHR2YXIgdGFnQXR0cnMgPSB0aGlzLmdldEF0dHJzKCk7XHJcblx0XHRcdEF1dG9saW5rZXIuVXRpbC5hc3NpZ24oIHRhZ0F0dHJzLCBhdHRycyApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9LFxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFJldHJpZXZlcyB0aGUgYXR0cmlidXRlcyBPYmplY3QgKG1hcCkgZm9yIHRoZSBIdG1sVGFnLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcmV0dXJuIHtPYmplY3QuPFN0cmluZywgU3RyaW5nPn0gQSBrZXkvdmFsdWUgb2JqZWN0IG9mIHRoZSBhdHRyaWJ1dGVzIGZvciB0aGUgSHRtbFRhZy5cclxuXHRcdCAqL1xyXG5cdFx0Z2V0QXR0cnMgOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuYXR0cnMgfHwgKCB0aGlzLmF0dHJzID0ge30gKTtcclxuXHRcdH0sXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogU2V0cyB0aGUgcHJvdmlkZWQgYGNzc0NsYXNzYCwgb3ZlcndyaXRpbmcgYW55IGN1cnJlbnQgQ1NTIGNsYXNzZXMgb24gdGhlIEh0bWxUYWcuXHJcblx0XHQgKiBcclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBjc3NDbGFzcyBPbmUgb3IgbW9yZSBzcGFjZS1zZXBhcmF0ZWQgQ1NTIGNsYXNzZXMgdG8gc2V0IChvdmVyd3JpdGUpLlxyXG5cdFx0ICogQHJldHVybiB7QXV0b2xpbmtlci5IdG1sVGFnfSBUaGlzIEh0bWxUYWcgaW5zdGFuY2UsIHNvIHRoYXQgbWV0aG9kIGNhbGxzIG1heSBiZSBjaGFpbmVkLlxyXG5cdFx0ICovXHJcblx0XHRzZXRDbGFzcyA6IGZ1bmN0aW9uKCBjc3NDbGFzcyApIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuc2V0QXR0ciggJ2NsYXNzJywgY3NzQ2xhc3MgKTtcclxuXHRcdH0sXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIGFkZCBvbmUgb3IgbW9yZSBDU1MgY2xhc3NlcyB0byB0aGUgSHRtbFRhZy4gV2lsbCBub3QgYWRkIGR1cGxpY2F0ZSBDU1MgY2xhc3Nlcy5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGNzc0NsYXNzIE9uZSBvciBtb3JlIHNwYWNlLXNlcGFyYXRlZCBDU1MgY2xhc3NlcyB0byBhZGQuXHJcblx0XHQgKiBAcmV0dXJuIHtBdXRvbGlua2VyLkh0bWxUYWd9IFRoaXMgSHRtbFRhZyBpbnN0YW5jZSwgc28gdGhhdCBtZXRob2QgY2FsbHMgbWF5IGJlIGNoYWluZWQuXHJcblx0XHQgKi9cclxuXHRcdGFkZENsYXNzIDogZnVuY3Rpb24oIGNzc0NsYXNzICkge1xyXG5cdFx0XHR2YXIgY2xhc3NBdHRyID0gdGhpcy5nZXRDbGFzcygpLFxyXG5cdFx0XHQgICAgd2hpdGVzcGFjZVJlZ2V4ID0gdGhpcy53aGl0ZXNwYWNlUmVnZXgsXHJcblx0XHRcdCAgICBpbmRleE9mID0gQXV0b2xpbmtlci5VdGlsLmluZGV4T2YsICAvLyB0byBzdXBwb3J0IElFOCBhbmQgYmVsb3dcclxuXHRcdFx0ICAgIGNsYXNzZXMgPSAoICFjbGFzc0F0dHIgKSA/IFtdIDogY2xhc3NBdHRyLnNwbGl0KCB3aGl0ZXNwYWNlUmVnZXggKSxcclxuXHRcdFx0ICAgIG5ld0NsYXNzZXMgPSBjc3NDbGFzcy5zcGxpdCggd2hpdGVzcGFjZVJlZ2V4ICksXHJcblx0XHRcdCAgICBuZXdDbGFzcztcclxuXHJcblx0XHRcdHdoaWxlKCBuZXdDbGFzcyA9IG5ld0NsYXNzZXMuc2hpZnQoKSApIHtcclxuXHRcdFx0XHRpZiggaW5kZXhPZiggY2xhc3NlcywgbmV3Q2xhc3MgKSA9PT0gLTEgKSB7XHJcblx0XHRcdFx0XHRjbGFzc2VzLnB1c2goIG5ld0NsYXNzICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmdldEF0dHJzKClbICdjbGFzcycgXSA9IGNsYXNzZXMuam9pbiggXCIgXCIgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9LFxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIENvbnZlbmllbmNlIG1ldGhvZCB0byByZW1vdmUgb25lIG9yIG1vcmUgQ1NTIGNsYXNzZXMgZnJvbSB0aGUgSHRtbFRhZy5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGNzc0NsYXNzIE9uZSBvciBtb3JlIHNwYWNlLXNlcGFyYXRlZCBDU1MgY2xhc3NlcyB0byByZW1vdmUuXHJcblx0XHQgKiBAcmV0dXJuIHtBdXRvbGlua2VyLkh0bWxUYWd9IFRoaXMgSHRtbFRhZyBpbnN0YW5jZSwgc28gdGhhdCBtZXRob2QgY2FsbHMgbWF5IGJlIGNoYWluZWQuXHJcblx0XHQgKi9cclxuXHRcdHJlbW92ZUNsYXNzIDogZnVuY3Rpb24oIGNzc0NsYXNzICkge1xyXG5cdFx0XHR2YXIgY2xhc3NBdHRyID0gdGhpcy5nZXRDbGFzcygpLFxyXG5cdFx0XHQgICAgd2hpdGVzcGFjZVJlZ2V4ID0gdGhpcy53aGl0ZXNwYWNlUmVnZXgsXHJcblx0XHRcdCAgICBpbmRleE9mID0gQXV0b2xpbmtlci5VdGlsLmluZGV4T2YsICAvLyB0byBzdXBwb3J0IElFOCBhbmQgYmVsb3dcclxuXHRcdFx0ICAgIGNsYXNzZXMgPSAoICFjbGFzc0F0dHIgKSA/IFtdIDogY2xhc3NBdHRyLnNwbGl0KCB3aGl0ZXNwYWNlUmVnZXggKSxcclxuXHRcdFx0ICAgIHJlbW92ZUNsYXNzZXMgPSBjc3NDbGFzcy5zcGxpdCggd2hpdGVzcGFjZVJlZ2V4ICksXHJcblx0XHRcdCAgICByZW1vdmVDbGFzcztcclxuXHJcblx0XHRcdHdoaWxlKCBjbGFzc2VzLmxlbmd0aCAmJiAoIHJlbW92ZUNsYXNzID0gcmVtb3ZlQ2xhc3Nlcy5zaGlmdCgpICkgKSB7XHJcblx0XHRcdFx0dmFyIGlkeCA9IGluZGV4T2YoIGNsYXNzZXMsIHJlbW92ZUNsYXNzICk7XHJcblx0XHRcdFx0aWYoIGlkeCAhPT0gLTEgKSB7XHJcblx0XHRcdFx0XHRjbGFzc2VzLnNwbGljZSggaWR4LCAxICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmdldEF0dHJzKClbICdjbGFzcycgXSA9IGNsYXNzZXMuam9pbiggXCIgXCIgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9LFxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIENvbnZlbmllbmNlIG1ldGhvZCB0byByZXRyaWV2ZSB0aGUgQ1NTIGNsYXNzKGVzKSBmb3IgdGhlIEh0bWxUYWcsIHdoaWNoIHdpbGwgZWFjaCBiZSBzZXBhcmF0ZWQgYnkgc3BhY2VzIHdoZW5cclxuXHRcdCAqIHRoZXJlIGFyZSBtdWx0aXBsZS5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfVxyXG5cdFx0ICovXHJcblx0XHRnZXRDbGFzcyA6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRBdHRycygpWyAnY2xhc3MnIF0gfHwgXCJcIjtcclxuXHRcdH0sXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIGNoZWNrIGlmIHRoZSB0YWcgaGFzIGEgQ1NTIGNsYXNzIG9yIG5vdC5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGNzc0NsYXNzIFRoZSBDU1MgY2xhc3MgdG8gY2hlY2sgZm9yLlxyXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBIdG1sVGFnIGhhcyB0aGUgQ1NTIGNsYXNzLCBgZmFsc2VgIG90aGVyd2lzZS5cclxuXHRcdCAqL1xyXG5cdFx0aGFzQ2xhc3MgOiBmdW5jdGlvbiggY3NzQ2xhc3MgKSB7XHJcblx0XHRcdHJldHVybiAoICcgJyArIHRoaXMuZ2V0Q2xhc3MoKSArICcgJyApLmluZGV4T2YoICcgJyArIGNzc0NsYXNzICsgJyAnICkgIT09IC0xO1xyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBTZXRzIHRoZSBpbm5lciBIVE1MIGZvciB0aGUgdGFnLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gaHRtbCBUaGUgaW5uZXIgSFRNTCB0byBzZXQuXHJcblx0XHQgKiBAcmV0dXJuIHtBdXRvbGlua2VyLkh0bWxUYWd9IFRoaXMgSHRtbFRhZyBpbnN0YW5jZSwgc28gdGhhdCBtZXRob2QgY2FsbHMgbWF5IGJlIGNoYWluZWQuXHJcblx0XHQgKi9cclxuXHRcdHNldElubmVySHRtbCA6IGZ1bmN0aW9uKCBodG1sICkge1xyXG5cdFx0XHR0aGlzLmlubmVySHRtbCA9IGh0bWw7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH0sXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogUmV0cmlldmVzIHRoZSBpbm5lciBIVE1MIGZvciB0aGUgdGFnLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XHJcblx0XHQgKi9cclxuXHRcdGdldElubmVySHRtbCA6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5pbm5lckh0bWwgfHwgXCJcIjtcclxuXHRcdH0sXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogT3ZlcnJpZGUgb2Ygc3VwZXJjbGFzcyBtZXRob2QgdXNlZCB0byBnZW5lcmF0ZSB0aGUgSFRNTCBzdHJpbmcgZm9yIHRoZSB0YWcuXHJcblx0XHQgKiBcclxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cclxuXHRcdCAqL1xyXG5cdFx0dG9TdHJpbmcgOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0dmFyIHRhZ05hbWUgPSB0aGlzLmdldFRhZ05hbWUoKSxcclxuXHRcdFx0ICAgIGF0dHJzU3RyID0gdGhpcy5idWlsZEF0dHJzU3RyKCk7XHJcblxyXG5cdFx0XHRhdHRyc1N0ciA9ICggYXR0cnNTdHIgKSA/ICcgJyArIGF0dHJzU3RyIDogJyc7ICAvLyBwcmVwZW5kIGEgc3BhY2UgaWYgdGhlcmUgYXJlIGFjdHVhbGx5IGF0dHJpYnV0ZXNcclxuXHJcblx0XHRcdHJldHVybiBbICc8JywgdGFnTmFtZSwgYXR0cnNTdHIsICc+JywgdGhpcy5nZXRJbm5lckh0bWwoKSwgJzwvJywgdGFnTmFtZSwgJz4nIF0uam9pbiggXCJcIiApO1xyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBTdXBwb3J0IG1ldGhvZCBmb3Ige0BsaW5rICN0b1N0cmluZ30sIHJldHVybnMgdGhlIHN0cmluZyBzcGFjZS1zZXBhcmF0ZWQga2V5PVwidmFsdWVcIiBwYWlycywgdXNlZCB0byBwb3B1bGF0ZSBcclxuXHRcdCAqIHRoZSBzdHJpbmdpZmllZCBIdG1sVGFnLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcHJvdGVjdGVkXHJcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9IEV4YW1wbGUgcmV0dXJuOiBgYXR0cjE9XCJ2YWx1ZTFcIiBhdHRyMj1cInZhbHVlMlwiYFxyXG5cdFx0ICovXHJcblx0XHRidWlsZEF0dHJzU3RyIDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdGlmKCAhdGhpcy5hdHRycyApIHJldHVybiBcIlwiOyAgLy8gbm8gYGF0dHJzYCBPYmplY3QgKG1hcCkgaGFzIGJlZW4gc2V0LCByZXR1cm4gZW1wdHkgc3RyaW5nXHJcblxyXG5cdFx0XHR2YXIgYXR0cnMgPSB0aGlzLmdldEF0dHJzKCksXHJcblx0XHRcdCAgICBhdHRyc0FyciA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yKCB2YXIgcHJvcCBpbiBhdHRycyApIHtcclxuXHRcdFx0XHRpZiggYXR0cnMuaGFzT3duUHJvcGVydHkoIHByb3AgKSApIHtcclxuXHRcdFx0XHRcdGF0dHJzQXJyLnB1c2goIHByb3AgKyAnPVwiJyArIGF0dHJzWyBwcm9wIF0gKyAnXCInICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBhdHRyc0Fyci5qb2luKCBcIiBcIiApO1xyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblx0LypnbG9iYWwgQXV0b2xpbmtlciAqL1xyXG5cdC8qanNoaW50IHNjcmlwdHVybDp0cnVlICovXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAY2xhc3MgQXV0b2xpbmtlci5NYXRjaFZhbGlkYXRvclxyXG5cdCAqIEBleHRlbmRzIE9iamVjdFxyXG5cdCAqIFxyXG5cdCAqIFVzZWQgYnkgQXV0b2xpbmtlciB0byBmaWx0ZXIgb3V0IGZhbHNlIHBvc2l0aXZlcyBmcm9tIHRoZSB7QGxpbmsgQXV0b2xpbmtlciNtYXRjaGVyUmVnZXh9LlxyXG5cdCAqIFxyXG5cdCAqIER1ZSB0byB0aGUgbGltaXRhdGlvbnMgb2YgcmVndWxhciBleHByZXNzaW9ucyAoaW5jbHVkaW5nIHRoZSBtaXNzaW5nIGZlYXR1cmUgb2YgbG9vay1iZWhpbmRzIGluIEpTIHJlZ3VsYXIgZXhwcmVzc2lvbnMpLFxyXG5cdCAqIHdlIGNhbm5vdCBhbHdheXMgZGV0ZXJtaW5lIHRoZSB2YWxpZGl0eSBvZiBhIGdpdmVuIG1hdGNoLiBUaGlzIGNsYXNzIGFwcGxpZXMgYSBiaXQgb2YgYWRkaXRpb25hbCBsb2dpYyB0byBmaWx0ZXIgb3V0IGFueVxyXG5cdCAqIGZhbHNlIHBvc2l0aXZlcyB0aGF0IGhhdmUgYmVlbiBtYXRjaGVkIGJ5IHRoZSB7QGxpbmsgQXV0b2xpbmtlciNtYXRjaGVyUmVnZXh9LlxyXG5cdCAqL1xyXG5cdEF1dG9saW5rZXIuTWF0Y2hWYWxpZGF0b3IgPSBBdXRvbGlua2VyLlV0aWwuZXh0ZW5kKCBPYmplY3QsIHtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAcHJvcGVydHkge1JlZ0V4cH0gaW52YWxpZFByb3RvY29sUmVsTWF0Y2hSZWdleFxyXG5cdFx0ICogXHJcblx0XHQgKiBUaGUgcmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gY2hlY2sgYSBwb3RlbnRpYWwgcHJvdG9jb2wtcmVsYXRpdmUgVVJMIG1hdGNoLCBjb21pbmcgZnJvbSB0aGUgXHJcblx0XHQgKiB7QGxpbmsgQXV0b2xpbmtlciNtYXRjaGVyUmVnZXh9LiBBIHByb3RvY29sLXJlbGF0aXZlIFVSTCBpcywgZm9yIGV4YW1wbGUsIFwiLy95YWhvby5jb21cIlxyXG5cdFx0ICogXHJcblx0XHQgKiBUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBjaGVja3MgdG8gc2VlIGlmIHRoZXJlIGlzIGEgd29yZCBjaGFyYWN0ZXIgYmVmb3JlIHRoZSAnLy8nIG1hdGNoIGluIG9yZGVyIHRvIGRldGVybWluZSBpZiBcclxuXHRcdCAqIHdlIHNob3VsZCBhY3R1YWxseSBhdXRvbGluayBhIHByb3RvY29sLXJlbGF0aXZlIFVSTC4gVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSB0aGVyZSBpcyBubyBuZWdhdGl2ZSBsb29rLWJlaGluZCBpbiBcclxuXHRcdCAqIEphdmFTY3JpcHQgcmVndWxhciBleHByZXNzaW9ucy4gXHJcblx0XHQgKiBcclxuXHRcdCAqIEZvciBpbnN0YW5jZSwgd2Ugd2FudCB0byBhdXRvbGluayBzb21ldGhpbmcgbGlrZSBcIkdvIHRvOiAvL2dvb2dsZS5jb21cIiwgYnV0IHdlIGRvbid0IHdhbnQgdG8gYXV0b2xpbmsgc29tZXRoaW5nIFxyXG5cdFx0ICogbGlrZSBcImFiYy8vZ29vZ2xlLmNvbVwiXHJcblx0XHQgKi9cclxuXHRcdGludmFsaWRQcm90b2NvbFJlbE1hdGNoUmVnZXggOiAvXltcXHddXFwvXFwvLyxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFJlZ2V4IHRvIHRlc3QgZm9yIGEgZnVsbCBwcm90b2NvbCwgd2l0aCB0aGUgdHdvIHRyYWlsaW5nIHNsYXNoZXMuIEV4OiAnaHR0cDovLydcclxuXHRcdCAqIFxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEBwcm9wZXJ0eSB7UmVnRXhwfSBoYXNGdWxsUHJvdG9jb2xSZWdleFxyXG5cdFx0ICovXHJcblx0XHRoYXNGdWxsUHJvdG9jb2xSZWdleCA6IC9eW0EtWmEtel1bLS4rQS1aYS16MC05XSs6XFwvXFwvLyxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFJlZ2V4IHRvIGZpbmQgdGhlIFVSSSBzY2hlbWUsIHN1Y2ggYXMgJ21haWx0bzonLlxyXG5cdFx0ICogXHJcblx0XHQgKiBUaGlzIGlzIHVzZWQgdG8gZmlsdGVyIG91dCAnamF2YXNjcmlwdDonIGFuZCAndmJzY3JpcHQ6JyBzY2hlbWVzLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHByb3BlcnR5IHtSZWdFeHB9IHVyaVNjaGVtZVJlZ2V4XHJcblx0XHQgKi9cclxuXHRcdHVyaVNjaGVtZVJlZ2V4IDogL15bQS1aYS16XVstLitBLVphLXowLTldKzovLFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogUmVnZXggdG8gZGV0ZXJtaW5lIGlmIGF0IGxlYXN0IG9uZSB3b3JkIGNoYXIgZXhpc3RzIGFmdGVyIHRoZSBwcm90b2NvbCAoaS5lLiBhZnRlciB0aGUgJzonKVxyXG5cdFx0ICogXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHByb3BlcnR5IHtSZWdFeHB9IGhhc1dvcmRDaGFyQWZ0ZXJQcm90b2NvbFJlZ2V4XHJcblx0XHQgKi9cclxuXHRcdGhhc1dvcmRDaGFyQWZ0ZXJQcm90b2NvbFJlZ2V4IDogLzpbXlxcc10qP1tBLVphLXpdLyxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gbWF0Y2ggZm91bmQgYnkge0BsaW5rIEF1dG9saW5rZXIjcHJvY2Vzc1RleHROb2RlfSBpcyB2YWxpZC4gV2lsbCByZXR1cm4gYGZhbHNlYCBmb3I6XHJcblx0XHQgKiBcclxuXHRcdCAqIDEpIFVSTCBtYXRjaGVzIHdoaWNoIGRvIG5vdCBoYXZlIGF0IGxlYXN0IGhhdmUgb25lIHBlcmlvZCAoJy4nKSBpbiB0aGUgZG9tYWluIG5hbWUgKGVmZmVjdGl2ZWx5IHNraXBwaW5nIG92ZXIgXHJcblx0XHQgKiAgICBtYXRjaGVzIGxpa2UgXCJhYmM6ZGVmXCIpLiBIb3dldmVyLCBVUkwgbWF0Y2hlcyB3aXRoIGEgcHJvdG9jb2wgd2lsbCBiZSBhbGxvd2VkIChleDogJ2h0dHA6Ly9sb2NhbGhvc3QnKVxyXG5cdFx0ICogMikgVVJMIG1hdGNoZXMgd2hpY2ggZG8gbm90IGhhdmUgYXQgbGVhc3Qgb25lIHdvcmQgY2hhcmFjdGVyIGluIHRoZSBkb21haW4gbmFtZSAoZWZmZWN0aXZlbHkgc2tpcHBpbmcgb3ZlclxyXG5cdFx0ICogICAgbWF0Y2hlcyBsaWtlIFwiZ2l0OjEuMFwiKS5cclxuXHRcdCAqIDMpIEEgcHJvdG9jb2wtcmVsYXRpdmUgdXJsIG1hdGNoIChhIFVSTCBiZWdpbm5pbmcgd2l0aCAnLy8nKSB3aG9zZSBwcmV2aW91cyBjaGFyYWN0ZXIgaXMgYSB3b3JkIGNoYXJhY3RlciBcclxuXHRcdCAqICAgIChlZmZlY3RpdmVseSBza2lwcGluZyBvdmVyIHN0cmluZ3MgbGlrZSBcImFiYy8vZ29vZ2xlLmNvbVwiKVxyXG5cdFx0ICogXHJcblx0XHQgKiBPdGhlcndpc2UsIHJldHVybnMgYHRydWVgLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdXJsTWF0Y2ggVGhlIG1hdGNoZWQgVVJMLCBpZiB0aGVyZSB3YXMgb25lLiBXaWxsIGJlIGFuIGVtcHR5IHN0cmluZyBpZiB0aGUgbWF0Y2ggaXMgbm90IGEgVVJMIG1hdGNoLlxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sVXJsTWF0Y2ggVGhlIG1hdGNoIFVSTCBzdHJpbmcgZm9yIGEgcHJvdG9jb2wgbWF0Y2guIEV4OiAnaHR0cDovL3lhaG9vLmNvbScuIFRoaXMgaXMgdXNlZCB0byBtYXRjaFxyXG5cdFx0ICogICBzb21ldGhpbmcgbGlrZSAnaHR0cDovL2xvY2FsaG9zdCcsIHdoZXJlIHdlIHdvbid0IGRvdWJsZSBjaGVjayB0aGF0IHRoZSBkb21haW4gbmFtZSBoYXMgYXQgbGVhc3Qgb25lICcuJyBpbiBpdC5cclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBwcm90b2NvbFJlbGF0aXZlTWF0Y2ggVGhlIHByb3RvY29sLXJlbGF0aXZlIHN0cmluZyBmb3IgYSBVUkwgbWF0Y2ggKGkuZS4gJy8vJyksIHBvc3NpYmx5IHdpdGggYSBwcmVjZWRpbmdcclxuXHRcdCAqICAgY2hhcmFjdGVyIChleCwgYSBzcGFjZSwgc3VjaCBhczogJyAvLycsIG9yIGEgbGV0dGVyLCBzdWNoIGFzOiAnYS8vJykuIFRoZSBtYXRjaCBpcyBpbnZhbGlkIGlmIHRoZXJlIGlzIGEgd29yZCBjaGFyYWN0ZXJcclxuXHRcdCAqICAgcHJlY2VkaW5nIHRoZSAnLy8nLlxyXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBtYXRjaCBnaXZlbiBpcyB2YWxpZCBhbmQgc2hvdWxkIGJlIHByb2Nlc3NlZCwgb3IgYGZhbHNlYCBpZiB0aGUgbWF0Y2ggaXMgaW52YWxpZCBhbmQvb3IgXHJcblx0XHQgKiAgIHNob3VsZCBqdXN0IG5vdCBiZSBwcm9jZXNzZWQuXHJcblx0XHQgKi9cclxuXHRcdGlzVmFsaWRNYXRjaCA6IGZ1bmN0aW9uKCB1cmxNYXRjaCwgcHJvdG9jb2xVcmxNYXRjaCwgcHJvdG9jb2xSZWxhdGl2ZU1hdGNoICkge1xyXG5cdFx0XHRpZihcclxuXHRcdFx0XHQoIHByb3RvY29sVXJsTWF0Y2ggJiYgIXRoaXMuaXNWYWxpZFVyaVNjaGVtZSggcHJvdG9jb2xVcmxNYXRjaCApICkgfHxcclxuXHRcdFx0XHR0aGlzLnVybE1hdGNoRG9lc05vdEhhdmVQcm90b2NvbE9yRG90KCB1cmxNYXRjaCwgcHJvdG9jb2xVcmxNYXRjaCApIHx8ICAgICAgIC8vIEF0IGxlYXN0IG9uZSBwZXJpb2QgKCcuJykgbXVzdCBleGlzdCBpbiB0aGUgVVJMIG1hdGNoIGZvciB1cyB0byBjb25zaWRlciBpdCBhbiBhY3R1YWwgVVJMLCAqdW5sZXNzKiBpdCB3YXMgYSBmdWxsIHByb3RvY29sIG1hdGNoIChsaWtlICdodHRwOi8vbG9jYWxob3N0JylcclxuXHRcdFx0XHR0aGlzLnVybE1hdGNoRG9lc05vdEhhdmVBdExlYXN0T25lV29yZENoYXIoIHVybE1hdGNoLCBwcm90b2NvbFVybE1hdGNoICkgfHwgIC8vIEF0IGxlYXN0IG9uZSBsZXR0ZXIgY2hhcmFjdGVyIG11c3QgZXhpc3QgaW4gdGhlIGRvbWFpbiBuYW1lIGFmdGVyIGEgcHJvdG9jb2wgbWF0Y2guIEV4OiBza2lwIG92ZXIgc29tZXRoaW5nIGxpa2UgXCJnaXQ6MS4wXCJcclxuXHRcdFx0XHR0aGlzLmlzSW52YWxpZFByb3RvY29sUmVsYXRpdmVNYXRjaCggcHJvdG9jb2xSZWxhdGl2ZU1hdGNoICkgICAgICAgICAgICAgICAgIC8vIEEgcHJvdG9jb2wtcmVsYXRpdmUgbWF0Y2ggd2hpY2ggaGFzIGEgd29yZCBjaGFyYWN0ZXIgaW4gZnJvbnQgb2YgaXQgKHNvIHdlIGNhbiBza2lwIHNvbWV0aGluZyBsaWtlIFwiYWJjLy9nb29nbGUuY29tXCIpXHJcblx0XHRcdCkge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9LFxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIERldGVybWluZXMgaWYgdGhlIFVSSSBzY2hlbWUgaXMgYSB2YWxpZCBzY2hlbWUgdG8gYmUgYXV0b2xpbmtlZC4gUmV0dXJucyBgZmFsc2VgIGlmIHRoZSBzY2hlbWUgaXMgXHJcblx0XHQgKiAnamF2YXNjcmlwdDonIG9yICd2YnNjcmlwdDonXHJcblx0XHQgKiBcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdXJpU2NoZW1lTWF0Y2ggVGhlIG1hdGNoIFVSTCBzdHJpbmcgZm9yIGEgZnVsbCBVUkkgc2NoZW1lIG1hdGNoLiBFeDogJ2h0dHA6Ly95YWhvby5jb20nIFxyXG5cdFx0ICogICBvciAnbWFpbHRvOmFAYS5jb20nLlxyXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBzY2hlbWUgaXMgYSB2YWxpZCBvbmUsIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG5cdFx0ICovXHJcblx0XHRpc1ZhbGlkVXJpU2NoZW1lIDogZnVuY3Rpb24oIHVyaVNjaGVtZU1hdGNoICkge1xyXG5cdFx0XHR2YXIgdXJpU2NoZW1lID0gdXJpU2NoZW1lTWF0Y2gubWF0Y2goIHRoaXMudXJpU2NoZW1lUmVnZXggKVsgMCBdO1xyXG5cclxuXHRcdFx0cmV0dXJuICggdXJpU2NoZW1lICE9PSAnamF2YXNjcmlwdDonICYmIHVyaVNjaGVtZSAhPT0gJ3Zic2NyaXB0OicgKTtcclxuXHRcdH0sXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogRGV0ZXJtaW5lcyBpZiBhIFVSTCBtYXRjaCBkb2VzIG5vdCBoYXZlIGVpdGhlcjpcclxuXHRcdCAqIFxyXG5cdFx0ICogYSkgYSBmdWxsIHByb3RvY29sIChpLmUuICdodHRwOi8vJyksIG9yXHJcblx0XHQgKiBiKSBhdCBsZWFzdCBvbmUgZG90ICgnLicpIGluIHRoZSBkb21haW4gbmFtZSAoZm9yIGEgbm9uLWZ1bGwtcHJvdG9jb2wgbWF0Y2gpLlxyXG5cdFx0ICogXHJcblx0XHQgKiBFaXRoZXIgc2l0dWF0aW9uIGlzIGNvbnNpZGVyZWQgYW4gaW52YWxpZCBVUkwgKGV4OiAnZ2l0OmQnIGRvZXMgbm90IGhhdmUgZWl0aGVyIHRoZSAnOi8vJyBwYXJ0LCBvciBhdCBsZWFzdCBvbmUgZG90XHJcblx0XHQgKiBpbiB0aGUgZG9tYWluIG5hbWUuIElmIHRoZSBtYXRjaCB3YXMgJ2dpdDphYmMuY29tJywgd2Ugd291bGQgY29uc2lkZXIgdGhpcyB2YWxpZC4pXHJcblx0XHQgKiBcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdXJsTWF0Y2ggVGhlIG1hdGNoZWQgVVJMLCBpZiB0aGVyZSB3YXMgb25lLiBXaWxsIGJlIGFuIGVtcHR5IHN0cmluZyBpZiB0aGUgbWF0Y2ggaXMgbm90IGEgVVJMIG1hdGNoLlxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sVXJsTWF0Y2ggVGhlIG1hdGNoIFVSTCBzdHJpbmcgZm9yIGEgcHJvdG9jb2wgbWF0Y2guIEV4OiAnaHR0cDovL3lhaG9vLmNvbScuIFRoaXMgaXMgdXNlZCB0byBtYXRjaFxyXG5cdFx0ICogICBzb21ldGhpbmcgbGlrZSAnaHR0cDovL2xvY2FsaG9zdCcsIHdoZXJlIHdlIHdvbid0IGRvdWJsZSBjaGVjayB0aGF0IHRoZSBkb21haW4gbmFtZSBoYXMgYXQgbGVhc3Qgb25lICcuJyBpbiBpdC5cclxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgVVJMIG1hdGNoIGRvZXMgbm90IGhhdmUgYSBmdWxsIHByb3RvY29sLCBvciBhdCBsZWFzdCBvbmUgZG90ICgnLicpIGluIGEgbm9uLWZ1bGwtcHJvdG9jb2xcclxuXHRcdCAqICAgbWF0Y2guXHJcblx0XHQgKi9cclxuXHRcdHVybE1hdGNoRG9lc05vdEhhdmVQcm90b2NvbE9yRG90IDogZnVuY3Rpb24oIHVybE1hdGNoLCBwcm90b2NvbFVybE1hdGNoICkge1xyXG5cdFx0XHRyZXR1cm4gKCAhIXVybE1hdGNoICYmICggIXByb3RvY29sVXJsTWF0Y2ggfHwgIXRoaXMuaGFzRnVsbFByb3RvY29sUmVnZXgudGVzdCggcHJvdG9jb2xVcmxNYXRjaCApICkgJiYgdXJsTWF0Y2guaW5kZXhPZiggJy4nICkgPT09IC0xICk7XHJcblx0XHR9LFxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIERldGVybWluZXMgaWYgYSBVUkwgbWF0Y2ggZG9lcyBub3QgaGF2ZSBhdCBsZWFzdCBvbmUgd29yZCBjaGFyYWN0ZXIgYWZ0ZXIgdGhlIHByb3RvY29sIChpLmUuIGluIHRoZSBkb21haW4gbmFtZSkuXHJcblx0XHQgKiBcclxuXHRcdCAqIEF0IGxlYXN0IG9uZSBsZXR0ZXIgY2hhcmFjdGVyIG11c3QgZXhpc3QgaW4gdGhlIGRvbWFpbiBuYW1lIGFmdGVyIGEgcHJvdG9jb2wgbWF0Y2guIEV4OiBza2lwIG92ZXIgc29tZXRoaW5nIFxyXG5cdFx0ICogbGlrZSBcImdpdDoxLjBcIlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHVybE1hdGNoIFRoZSBtYXRjaGVkIFVSTCwgaWYgdGhlcmUgd2FzIG9uZS4gV2lsbCBiZSBhbiBlbXB0eSBzdHJpbmcgaWYgdGhlIG1hdGNoIGlzIG5vdCBhIFVSTCBtYXRjaC5cclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBwcm90b2NvbFVybE1hdGNoIFRoZSBtYXRjaCBVUkwgc3RyaW5nIGZvciBhIHByb3RvY29sIG1hdGNoLiBFeDogJ2h0dHA6Ly95YWhvby5jb20nLiBUaGlzIGlzIHVzZWQgdG9cclxuXHRcdCAqICAga25vdyB3aGV0aGVyIG9yIG5vdCB3ZSBoYXZlIGEgcHJvdG9jb2wgaW4gdGhlIFVSTCBzdHJpbmcsIGluIG9yZGVyIHRvIGNoZWNrIGZvciBhIHdvcmQgY2hhcmFjdGVyIGFmdGVyIHRoZSBwcm90b2NvbFxyXG5cdFx0ICogICBzZXBhcmF0b3IgKCc6JykuXHJcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIFVSTCBtYXRjaCBkb2VzIG5vdCBoYXZlIGF0IGxlYXN0IG9uZSB3b3JkIGNoYXJhY3RlciBpbiBpdCBhZnRlciB0aGUgcHJvdG9jb2wsIGBmYWxzZWBcclxuXHRcdCAqICAgb3RoZXJ3aXNlLlxyXG5cdFx0ICovXHJcblx0XHR1cmxNYXRjaERvZXNOb3RIYXZlQXRMZWFzdE9uZVdvcmRDaGFyIDogZnVuY3Rpb24oIHVybE1hdGNoLCBwcm90b2NvbFVybE1hdGNoICkge1xyXG5cdFx0XHRpZiggdXJsTWF0Y2ggJiYgcHJvdG9jb2xVcmxNYXRjaCApIHtcclxuXHRcdFx0XHRyZXR1cm4gIXRoaXMuaGFzV29yZENoYXJBZnRlclByb3RvY29sUmVnZXgudGVzdCggdXJsTWF0Y2ggKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogRGV0ZXJtaW5lcyBpZiBhIHByb3RvY29sLXJlbGF0aXZlIG1hdGNoIGlzIGFuIGludmFsaWQgb25lLiBUaGlzIG1ldGhvZCByZXR1cm5zIGB0cnVlYCBpZiB0aGVyZSBpcyBhIGBwcm90b2NvbFJlbGF0aXZlTWF0Y2hgLFxyXG5cdFx0ICogYW5kIHRoYXQgbWF0Y2ggY29udGFpbnMgYSB3b3JkIGNoYXJhY3RlciBiZWZvcmUgdGhlICcvLycgKGkuZS4gaXQgbXVzdCBjb250YWluIHdoaXRlc3BhY2Ugb3Igbm90aGluZyBiZWZvcmUgdGhlICcvLycgaW5cclxuXHRcdCAqIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgdmFsaWQpLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sUmVsYXRpdmVNYXRjaCBUaGUgcHJvdG9jb2wtcmVsYXRpdmUgc3RyaW5nIGZvciBhIFVSTCBtYXRjaCAoaS5lLiAnLy8nKSwgcG9zc2libHkgd2l0aCBhIHByZWNlZGluZ1xyXG5cdFx0ICogICBjaGFyYWN0ZXIgKGV4LCBhIHNwYWNlLCBzdWNoIGFzOiAnIC8vJywgb3IgYSBsZXR0ZXIsIHN1Y2ggYXM6ICdhLy8nKS4gVGhlIG1hdGNoIGlzIGludmFsaWQgaWYgdGhlcmUgaXMgYSB3b3JkIGNoYXJhY3RlclxyXG5cdFx0ICogICBwcmVjZWRpbmcgdGhlICcvLycuXHJcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgaXQgaXMgYW4gaW52YWxpZCBwcm90b2NvbC1yZWxhdGl2ZSBtYXRjaCwgYGZhbHNlYCBvdGhlcndpc2UuXHJcblx0XHQgKi9cclxuXHRcdGlzSW52YWxpZFByb3RvY29sUmVsYXRpdmVNYXRjaCA6IGZ1bmN0aW9uKCBwcm90b2NvbFJlbGF0aXZlTWF0Y2ggKSB7XHJcblx0XHRcdHJldHVybiAoICEhcHJvdG9jb2xSZWxhdGl2ZU1hdGNoICYmIHRoaXMuaW52YWxpZFByb3RvY29sUmVsTWF0Y2hSZWdleC50ZXN0KCBwcm90b2NvbFJlbGF0aXZlTWF0Y2ggKSApO1xyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblx0LypnbG9iYWwgQXV0b2xpbmtlciAqL1xyXG5cdC8qanNoaW50IHN1Yjp0cnVlICovXHJcblx0LyoqXHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqIEBjbGFzcyBBdXRvbGlua2VyLkFuY2hvclRhZ0J1aWxkZXJcclxuXHQgKiBAZXh0ZW5kcyBPYmplY3RcclxuXHQgKiBcclxuXHQgKiBCdWlsZHMgYW5jaG9yICgmbHQ7YSZndDspIHRhZ3MgZm9yIHRoZSBBdXRvbGlua2VyIHV0aWxpdHkgd2hlbiBhIG1hdGNoIGlzIGZvdW5kLlxyXG5cdCAqIFxyXG5cdCAqIE5vcm1hbGx5IHRoaXMgY2xhc3MgaXMgaW5zdGFudGlhdGVkLCBjb25maWd1cmVkLCBhbmQgdXNlZCBpbnRlcm5hbGx5IGJ5IGFuIHtAbGluayBBdXRvbGlua2VyfSBpbnN0YW5jZSwgYnV0IG1heSBcclxuXHQgKiBhY3R1YWxseSBiZSByZXRyaWV2ZWQgaW4gYSB7QGxpbmsgQXV0b2xpbmtlciNyZXBsYWNlRm4gcmVwbGFjZUZufSB0byBjcmVhdGUge0BsaW5rIEF1dG9saW5rZXIuSHRtbFRhZyBIdG1sVGFnfSBpbnN0YW5jZXNcclxuXHQgKiB3aGljaCBtYXkgYmUgbW9kaWZpZWQgYmVmb3JlIHJldHVybmluZyBmcm9tIHRoZSB7QGxpbmsgQXV0b2xpbmtlciNyZXBsYWNlRm4gcmVwbGFjZUZufS4gRm9yIGV4YW1wbGU6XHJcblx0ICogXHJcblx0ICogICAgIHZhciBodG1sID0gQXV0b2xpbmtlci5saW5rKCBcIlRlc3QgZ29vZ2xlLmNvbVwiLCB7XHJcblx0ICogICAgICAgICByZXBsYWNlRm4gOiBmdW5jdGlvbiggYXV0b2xpbmtlciwgbWF0Y2ggKSB7XHJcblx0ICogICAgICAgICAgICAgdmFyIHRhZyA9IGF1dG9saW5rZXIuZ2V0VGFnQnVpbGRlcigpLmJ1aWxkKCBtYXRjaCApOyAgLy8gcmV0dXJucyBhbiB7QGxpbmsgQXV0b2xpbmtlci5IdG1sVGFnfSBpbnN0YW5jZVxyXG5cdCAqICAgICAgICAgICAgIHRhZy5zZXRBdHRyKCAncmVsJywgJ25vZm9sbG93JyApO1xyXG5cdCAqICAgICAgICAgICAgIFxyXG5cdCAqICAgICAgICAgICAgIHJldHVybiB0YWc7XHJcblx0ICogICAgICAgICB9XHJcblx0ICogICAgIH0gKTtcclxuXHQgKiAgICAgXHJcblx0ICogICAgIC8vIGdlbmVyYXRlZCBodG1sOlxyXG5cdCAqICAgICAvLyAgIFRlc3QgPGEgaHJlZj1cImh0dHA6Ly9nb29nbGUuY29tXCIgdGFyZ2V0PVwiX2JsYW5rXCIgcmVsPVwibm9mb2xsb3dcIj5nb29nbGUuY29tPC9hPlxyXG5cdCAqL1xyXG5cdEF1dG9saW5rZXIuQW5jaG9yVGFnQnVpbGRlciA9IEF1dG9saW5rZXIuVXRpbC5leHRlbmQoIE9iamVjdCwge1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQGNmZyB7Qm9vbGVhbn0gbmV3V2luZG93XHJcblx0XHQgKiBAaW5oZXJpdGRvYyBBdXRvbGlua2VyI25ld1dpbmRvd1xyXG5cdFx0ICovXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBAY2ZnIHtOdW1iZXJ9IHRydW5jYXRlXHJcblx0XHQgKiBAaW5oZXJpdGRvYyBBdXRvbGlua2VyI3RydW5jYXRlXHJcblx0XHQgKi9cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEBjZmcge1N0cmluZ30gY2xhc3NOYW1lXHJcblx0XHQgKiBAaW5oZXJpdGRvYyBBdXRvbGlua2VyI2NsYXNzTmFtZVxyXG5cdFx0ICovXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQGNvbnN0cnVjdG9yXHJcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gW2NmZ10gVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIEFuY2hvclRhZ0J1aWxkZXIgaW5zdGFuY2UsIHNwZWNpZmllZCBpbiBhbiBPYmplY3QgKG1hcCkuXHJcblx0XHQgKi9cclxuXHRcdGNvbnN0cnVjdG9yIDogZnVuY3Rpb24oIGNmZyApIHtcclxuXHRcdFx0QXV0b2xpbmtlci5VdGlsLmFzc2lnbiggdGhpcywgY2ZnICk7XHJcblx0XHR9LFxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEdlbmVyYXRlcyB0aGUgYWN0dWFsIGFuY2hvciAoJmx0O2EmZ3Q7KSB0YWcgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBtYXRjaGVkIFVSTC9lbWFpbC9Ud2l0dGVyIHRleHQsXHJcblx0XHQgKiB2aWEgaXRzIGBtYXRjaGAgb2JqZWN0LlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcGFyYW0ge0F1dG9saW5rZXIubWF0Y2guTWF0Y2h9IG1hdGNoIFRoZSBNYXRjaCBpbnN0YW5jZSB0byBnZW5lcmF0ZSBhbiBhbmNob3IgdGFnIGZyb20uXHJcblx0XHQgKiBAcmV0dXJuIHtBdXRvbGlua2VyLkh0bWxUYWd9IFRoZSBIdG1sVGFnIGluc3RhbmNlIGZvciB0aGUgYW5jaG9yIHRhZy5cclxuXHRcdCAqL1xyXG5cdFx0YnVpbGQgOiBmdW5jdGlvbiggbWF0Y2ggKSB7XHJcblx0XHRcdHZhciB0YWcgPSBuZXcgQXV0b2xpbmtlci5IdG1sVGFnKCB7XHJcblx0XHRcdFx0dGFnTmFtZSAgIDogJ2EnLFxyXG5cdFx0XHRcdGF0dHJzICAgICA6IHRoaXMuY3JlYXRlQXR0cnMoIG1hdGNoLmdldFR5cGUoKSwgbWF0Y2guZ2V0QW5jaG9ySHJlZigpICksXHJcblx0XHRcdFx0aW5uZXJIdG1sIDogdGhpcy5wcm9jZXNzQW5jaG9yVGV4dCggbWF0Y2guZ2V0QW5jaG9yVGV4dCgpIClcclxuXHRcdFx0fSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRhZztcclxuXHRcdH0sXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQ3JlYXRlcyB0aGUgT2JqZWN0IChtYXApIG9mIHRoZSBIVE1MIGF0dHJpYnV0ZXMgZm9yIHRoZSBhbmNob3IgKCZsdDthJmd0OykgdGFnIGJlaW5nIGdlbmVyYXRlZC5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHByb3RlY3RlZFxyXG5cdFx0ICogQHBhcmFtIHtcInVybFwiL1wiZW1haWxcIi9cInR3aXR0ZXJcIn0gbWF0Y2hUeXBlIFRoZSB0eXBlIG9mIG1hdGNoIHRoYXQgYW4gYW5jaG9yIHRhZyBpcyBiZWluZyBnZW5lcmF0ZWQgZm9yLlxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGhyZWYgVGhlIGhyZWYgZm9yIHRoZSBhbmNob3IgdGFnLlxyXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fSBBIGtleS92YWx1ZSBPYmplY3QgKG1hcCkgb2YgdGhlIGFuY2hvciB0YWcncyBhdHRyaWJ1dGVzLiBcclxuXHRcdCAqL1xyXG5cdFx0Y3JlYXRlQXR0cnMgOiBmdW5jdGlvbiggbWF0Y2hUeXBlLCBhbmNob3JIcmVmICkge1xyXG5cdFx0XHR2YXIgYXR0cnMgPSB7XHJcblx0XHRcdFx0J2hyZWYnIDogYW5jaG9ySHJlZiAgLy8gd2UnbGwgYWx3YXlzIGhhdmUgdGhlIGBocmVmYCBhdHRyaWJ1dGVcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdHZhciBjc3NDbGFzcyA9IHRoaXMuY3JlYXRlQ3NzQ2xhc3MoIG1hdGNoVHlwZSApO1xyXG5cdFx0XHRpZiggY3NzQ2xhc3MgKSB7XHJcblx0XHRcdFx0YXR0cnNbICdjbGFzcycgXSA9IGNzc0NsYXNzO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKCB0aGlzLm5ld1dpbmRvdyApIHtcclxuXHRcdFx0XHRhdHRyc1sgJ3RhcmdldCcgXSA9IFwiX2JsYW5rXCI7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBhdHRycztcclxuXHRcdH0sXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQ3JlYXRlcyB0aGUgQ1NTIGNsYXNzIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBhIGdpdmVuIGFuY2hvciB0YWcsIGJhc2VkIG9uIHRoZSBgbWF0Y2hUeXBlYCBhbmQgdGhlIHtAbGluayAjY2xhc3NOYW1lfVxyXG5cdFx0ICogY29uZmlnLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHBhcmFtIHtcInVybFwiL1wiZW1haWxcIi9cInR3aXR0ZXJcIn0gbWF0Y2hUeXBlIFRoZSB0eXBlIG9mIG1hdGNoIHRoYXQgYW4gYW5jaG9yIHRhZyBpcyBiZWluZyBnZW5lcmF0ZWQgZm9yLlxyXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgQ1NTIGNsYXNzIHN0cmluZyBmb3IgdGhlIGxpbmsuIEV4YW1wbGUgcmV0dXJuOiBcIm15TGluayBteUxpbmstdXJsXCIuIElmIG5vIHtAbGluayAjY2xhc3NOYW1lfVxyXG5cdFx0ICogICB3YXMgY29uZmlndXJlZCwgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcuXHJcblx0XHQgKi9cclxuXHRcdGNyZWF0ZUNzc0NsYXNzIDogZnVuY3Rpb24oIG1hdGNoVHlwZSApIHtcclxuXHRcdFx0dmFyIGNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lO1xyXG5cclxuXHRcdFx0aWYoICFjbGFzc05hbWUgKSBcclxuXHRcdFx0XHRyZXR1cm4gXCJcIjtcclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdHJldHVybiBjbGFzc05hbWUgKyBcIiBcIiArIGNsYXNzTmFtZSArIFwiLVwiICsgbWF0Y2hUeXBlOyAgLy8gZXg6IFwibXlMaW5rIG15TGluay11cmxcIiwgXCJteUxpbmsgbXlMaW5rLWVtYWlsXCIsIG9yIFwibXlMaW5rIG15TGluay10d2l0dGVyXCJcclxuXHRcdH0sXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogUHJvY2Vzc2VzIHRoZSBgYW5jaG9yVGV4dGAgYnkgdHJ1bmNhdGluZyB0aGUgdGV4dCBhY2NvcmRpbmcgdG8gdGhlIHtAbGluayAjdHJ1bmNhdGV9IGNvbmZpZy5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBhbmNob3JUZXh0IFRoZSBhbmNob3IgdGFnJ3MgdGV4dCAoaS5lLiB3aGF0IHdpbGwgYmUgZGlzcGxheWVkKS5cclxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHByb2Nlc3NlZCBgYW5jaG9yVGV4dGAuXHJcblx0XHQgKi9cclxuXHRcdHByb2Nlc3NBbmNob3JUZXh0IDogZnVuY3Rpb24oIGFuY2hvclRleHQgKSB7XHJcblx0XHRcdGFuY2hvclRleHQgPSB0aGlzLmRvVHJ1bmNhdGUoIGFuY2hvclRleHQgKTtcclxuXHJcblx0XHRcdHJldHVybiBhbmNob3JUZXh0O1xyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBQZXJmb3JtcyB0aGUgdHJ1bmNhdGlvbiBvZiB0aGUgYGFuY2hvclRleHRgLCBpZiB0aGUgYGFuY2hvclRleHRgIGlzIGxvbmdlciB0aGFuIHRoZSB7QGxpbmsgI3RydW5jYXRlfSBvcHRpb24uXHJcblx0XHQgKiBUcnVuY2F0ZXMgdGhlIHRleHQgdG8gMiBjaGFyYWN0ZXJzIGZld2VyIHRoYW4gdGhlIHtAbGluayAjdHJ1bmNhdGV9IG9wdGlvbiwgYW5kIGFkZHMgXCIuLlwiIHRvIHRoZSBlbmQuXHJcblx0XHQgKiBcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgYW5jaG9yIHRhZydzIHRleHQgKGkuZS4gd2hhdCB3aWxsIGJlIGRpc3BsYXllZCkuXHJcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSB0cnVuY2F0ZWQgYW5jaG9yIHRleHQuXHJcblx0XHQgKi9cclxuXHRcdGRvVHJ1bmNhdGUgOiBmdW5jdGlvbiggYW5jaG9yVGV4dCApIHtcclxuXHRcdFx0cmV0dXJuIEF1dG9saW5rZXIuVXRpbC5lbGxpcHNpcyggYW5jaG9yVGV4dCwgdGhpcy50cnVuY2F0ZSB8fCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgKTtcclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cdC8qZ2xvYmFsIEF1dG9saW5rZXIgKi9cclxuXHQvKipcclxuXHQgKiBAYWJzdHJhY3RcclxuXHQgKiBAY2xhc3MgQXV0b2xpbmtlci5tYXRjaC5NYXRjaFxyXG5cdCAqIFxyXG5cdCAqIFJlcHJlc2VudHMgYSBtYXRjaCBmb3VuZCBpbiBhbiBpbnB1dCBzdHJpbmcgd2hpY2ggc2hvdWxkIGJlIEF1dG9saW5rZWQuIEEgTWF0Y2ggb2JqZWN0IGlzIHdoYXQgaXMgcHJvdmlkZWQgaW4gYSBcclxuXHQgKiB7QGxpbmsgQXV0b2xpbmtlciNyZXBsYWNlRm4gcmVwbGFjZUZufSwgYW5kIG1heSBiZSB1c2VkIHRvIHF1ZXJ5IGZvciBkZXRhaWxzIGFib3V0IHRoZSBtYXRjaC5cclxuXHQgKiBcclxuXHQgKiBGb3IgZXhhbXBsZTpcclxuXHQgKiBcclxuXHQgKiAgICAgdmFyIGlucHV0ID0gXCIuLi5cIjsgIC8vIHN0cmluZyB3aXRoIFVSTHMsIEVtYWlsIEFkZHJlc3NlcywgYW5kIFR3aXR0ZXIgSGFuZGxlc1xyXG5cdCAqICAgICBcclxuXHQgKiAgICAgdmFyIGxpbmtlZFRleHQgPSBBdXRvbGlua2VyLmxpbmsoIGlucHV0LCB7XHJcblx0ICogICAgICAgICByZXBsYWNlRm4gOiBmdW5jdGlvbiggYXV0b2xpbmtlciwgbWF0Y2ggKSB7XHJcblx0ICogICAgICAgICAgICAgY29uc29sZS5sb2coIFwiaHJlZiA9IFwiLCBtYXRjaC5nZXRBbmNob3JIcmVmKCkgKTtcclxuXHQgKiAgICAgICAgICAgICBjb25zb2xlLmxvZyggXCJ0ZXh0ID0gXCIsIG1hdGNoLmdldEFuY2hvclRleHQoKSApO1xyXG5cdCAqICAgICAgICAgXHJcblx0ICogICAgICAgICAgICAgc3dpdGNoKCBtYXRjaC5nZXRUeXBlKCkgKSB7XHJcblx0ICogICAgICAgICAgICAgICAgIGNhc2UgJ3VybCcgOiBcclxuXHQgKiAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCBcInVybDogXCIsIG1hdGNoLmdldFVybCgpICk7XHJcblx0ICogICAgICAgICAgICAgICAgICAgICBcclxuXHQgKiAgICAgICAgICAgICAgICAgY2FzZSAnZW1haWwnIDpcclxuXHQgKiAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCBcImVtYWlsOiBcIiwgbWF0Y2guZ2V0RW1haWwoKSApO1xyXG5cdCAqICAgICAgICAgICAgICAgICAgICAgXHJcblx0ICogICAgICAgICAgICAgICAgIGNhc2UgJ3R3aXR0ZXInIDpcclxuXHQgKiAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCBcInR3aXR0ZXI6IFwiLCBtYXRjaC5nZXRUd2l0dGVySGFuZGxlKCkgKTtcclxuXHQgKiAgICAgICAgICAgICB9XHJcblx0ICogICAgICAgICB9XHJcblx0ICogICAgIH0gKTtcclxuXHQgKiAgICAgXHJcblx0ICogU2VlIHRoZSB7QGxpbmsgQXV0b2xpbmtlcn0gY2xhc3MgZm9yIG1vcmUgZGV0YWlscyBvbiB1c2luZyB0aGUge0BsaW5rIEF1dG9saW5rZXIjcmVwbGFjZUZuIHJlcGxhY2VGbn0uXHJcblx0ICovXHJcblx0QXV0b2xpbmtlci5tYXRjaC5NYXRjaCA9IEF1dG9saW5rZXIuVXRpbC5leHRlbmQoIE9iamVjdCwge1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQGNmZyB7U3RyaW5nfSBtYXRjaGVkVGV4dCAocmVxdWlyZWQpXHJcblx0XHQgKiBcclxuXHRcdCAqIFRoZSBvcmlnaW5hbCB0ZXh0IHRoYXQgd2FzIG1hdGNoZWQuXHJcblx0XHQgKi9cclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBAY29uc3RydWN0b3JcclxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgVGhlIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcyBmb3IgdGhlIE1hdGNoIGluc3RhbmNlLCBzcGVjaWZpZWQgaW4gYW4gT2JqZWN0IChtYXApLlxyXG5cdFx0ICovXHJcblx0XHRjb25zdHJ1Y3RvciA6IGZ1bmN0aW9uKCBjZmcgKSB7XHJcblx0XHRcdEF1dG9saW5rZXIuVXRpbC5hc3NpZ24oIHRoaXMsIGNmZyApO1xyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBSZXR1cm5zIGEgc3RyaW5nIG5hbWUgZm9yIHRoZSB0eXBlIG9mIG1hdGNoIHRoYXQgdGhpcyBjbGFzcyByZXByZXNlbnRzLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAYWJzdHJhY3RcclxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cclxuXHRcdCAqL1xyXG5cdFx0Z2V0VHlwZSA6IEF1dG9saW5rZXIuVXRpbC5hYnN0cmFjdE1ldGhvZCxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCB0ZXh0IHRoYXQgd2FzIG1hdGNoZWQuXHJcblx0XHQgKiBcclxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cclxuXHRcdCAqL1xyXG5cdFx0Z2V0TWF0Y2hlZFRleHQgOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMubWF0Y2hlZFRleHQ7XHJcblx0XHR9LFxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFJldHVybnMgdGhlIGFuY2hvciBocmVmIHRoYXQgc2hvdWxkIGJlIGdlbmVyYXRlZCBmb3IgdGhlIG1hdGNoLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAYWJzdHJhY3RcclxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cclxuXHRcdCAqL1xyXG5cdFx0Z2V0QW5jaG9ySHJlZiA6IEF1dG9saW5rZXIuVXRpbC5hYnN0cmFjdE1ldGhvZCxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBSZXR1cm5zIHRoZSBhbmNob3IgdGV4dCB0aGF0IHNob3VsZCBiZSBnZW5lcmF0ZWQgZm9yIHRoZSBtYXRjaC5cclxuXHRcdCAqIFxyXG5cdFx0ICogQGFic3RyYWN0XHJcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XHJcblx0XHQgKi9cclxuXHRcdGdldEFuY2hvclRleHQgOiBBdXRvbGlua2VyLlV0aWwuYWJzdHJhY3RNZXRob2RcclxuXHJcblx0fSApO1xyXG5cdC8qZ2xvYmFsIEF1dG9saW5rZXIgKi9cclxuXHQvKipcclxuXHQgKiBAY2xhc3MgQXV0b2xpbmtlci5tYXRjaC5FbWFpbFxyXG5cdCAqIEBleHRlbmRzIEF1dG9saW5rZXIubWF0Y2guTWF0Y2hcclxuXHQgKiBcclxuXHQgKiBSZXByZXNlbnRzIGEgRW1haWwgbWF0Y2ggZm91bmQgaW4gYW4gaW5wdXQgc3RyaW5nIHdoaWNoIHNob3VsZCBiZSBBdXRvbGlua2VkLlxyXG5cdCAqIFxyXG5cdCAqIFNlZSB0aGlzIGNsYXNzJ3Mgc3VwZXJjbGFzcyAoe0BsaW5rIEF1dG9saW5rZXIubWF0Y2guTWF0Y2h9KSBmb3IgbW9yZSBkZXRhaWxzLlxyXG5cdCAqL1xyXG5cdEF1dG9saW5rZXIubWF0Y2guRW1haWwgPSBBdXRvbGlua2VyLlV0aWwuZXh0ZW5kKCBBdXRvbGlua2VyLm1hdGNoLk1hdGNoLCB7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBAY2ZnIHtTdHJpbmd9IGVtYWlsIChyZXF1aXJlZClcclxuXHRcdCAqIFxyXG5cdFx0ICogVGhlIGVtYWlsIGFkZHJlc3MgdGhhdCB3YXMgbWF0Y2hlZC5cclxuXHRcdCAqL1xyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFJldHVybnMgYSBzdHJpbmcgbmFtZSBmb3IgdGhlIHR5cGUgb2YgbWF0Y2ggdGhhdCB0aGlzIGNsYXNzIHJlcHJlc2VudHMuXHJcblx0XHQgKiBcclxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cclxuXHRcdCAqL1xyXG5cdFx0Z2V0VHlwZSA6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gJ2VtYWlsJztcclxuXHRcdH0sXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogUmV0dXJucyB0aGUgZW1haWwgYWRkcmVzcyB0aGF0IHdhcyBtYXRjaGVkLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XHJcblx0XHQgKi9cclxuXHRcdGdldEVtYWlsIDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmVtYWlsO1xyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBSZXR1cm5zIHRoZSBhbmNob3IgaHJlZiB0aGF0IHNob3VsZCBiZSBnZW5lcmF0ZWQgZm9yIHRoZSBtYXRjaC5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfVxyXG5cdFx0ICovXHJcblx0XHRnZXRBbmNob3JIcmVmIDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiAnbWFpbHRvOicgKyB0aGlzLmVtYWlsO1xyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBSZXR1cm5zIHRoZSBhbmNob3IgdGV4dCB0aGF0IHNob3VsZCBiZSBnZW5lcmF0ZWQgZm9yIHRoZSBtYXRjaC5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfVxyXG5cdFx0ICovXHJcblx0XHRnZXRBbmNob3JUZXh0IDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmVtYWlsO1xyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblx0LypnbG9iYWwgQXV0b2xpbmtlciAqL1xyXG5cdC8qKlxyXG5cdCAqIEBjbGFzcyBBdXRvbGlua2VyLm1hdGNoLlR3aXR0ZXJcclxuXHQgKiBAZXh0ZW5kcyBBdXRvbGlua2VyLm1hdGNoLk1hdGNoXHJcblx0ICogXHJcblx0ICogUmVwcmVzZW50cyBhIFR3aXR0ZXIgbWF0Y2ggZm91bmQgaW4gYW4gaW5wdXQgc3RyaW5nIHdoaWNoIHNob3VsZCBiZSBBdXRvbGlua2VkLlxyXG5cdCAqIFxyXG5cdCAqIFNlZSB0aGlzIGNsYXNzJ3Mgc3VwZXJjbGFzcyAoe0BsaW5rIEF1dG9saW5rZXIubWF0Y2guTWF0Y2h9KSBmb3IgbW9yZSBkZXRhaWxzLlxyXG5cdCAqL1xyXG5cdEF1dG9saW5rZXIubWF0Y2guVHdpdHRlciA9IEF1dG9saW5rZXIuVXRpbC5leHRlbmQoIEF1dG9saW5rZXIubWF0Y2guTWF0Y2gsIHtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEBjZmcge1N0cmluZ30gdHdpdHRlckhhbmRsZSAocmVxdWlyZWQpXHJcblx0XHQgKiBcclxuXHRcdCAqIFRoZSBUd2l0dGVyIGhhbmRsZSB0aGF0IHdhcyBtYXRjaGVkLlxyXG5cdFx0ICovXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogUmV0dXJucyB0aGUgdHlwZSBvZiBtYXRjaCB0aGF0IHRoaXMgY2xhc3MgcmVwcmVzZW50cy5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfVxyXG5cdFx0ICovXHJcblx0XHRnZXRUeXBlIDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiAndHdpdHRlcic7XHJcblx0XHR9LFxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFJldHVybnMgYSBzdHJpbmcgbmFtZSBmb3IgdGhlIHR5cGUgb2YgbWF0Y2ggdGhhdCB0aGlzIGNsYXNzIHJlcHJlc2VudHMuXHJcblx0XHQgKiBcclxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cclxuXHRcdCAqL1xyXG5cdFx0Z2V0VHdpdHRlckhhbmRsZSA6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy50d2l0dGVySGFuZGxlO1xyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBSZXR1cm5zIHRoZSBhbmNob3IgaHJlZiB0aGF0IHNob3VsZCBiZSBnZW5lcmF0ZWQgZm9yIHRoZSBtYXRjaC5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfVxyXG5cdFx0ICovXHJcblx0XHRnZXRBbmNob3JIcmVmIDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiAnaHR0cHM6Ly90d2l0dGVyLmNvbS8nICsgdGhpcy50d2l0dGVySGFuZGxlO1xyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBSZXR1cm5zIHRoZSBhbmNob3IgdGV4dCB0aGF0IHNob3VsZCBiZSBnZW5lcmF0ZWQgZm9yIHRoZSBtYXRjaC5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfVxyXG5cdFx0ICovXHJcblx0XHRnZXRBbmNob3JUZXh0IDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiAnQCcgKyB0aGlzLnR3aXR0ZXJIYW5kbGU7XHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHQvKmdsb2JhbCBBdXRvbGlua2VyICovXHJcblx0LyoqXHJcblx0ICogQGNsYXNzIEF1dG9saW5rZXIubWF0Y2guVXJsXHJcblx0ICogQGV4dGVuZHMgQXV0b2xpbmtlci5tYXRjaC5NYXRjaFxyXG5cdCAqIFxyXG5cdCAqIFJlcHJlc2VudHMgYSBVcmwgbWF0Y2ggZm91bmQgaW4gYW4gaW5wdXQgc3RyaW5nIHdoaWNoIHNob3VsZCBiZSBBdXRvbGlua2VkLlxyXG5cdCAqIFxyXG5cdCAqIFNlZSB0aGlzIGNsYXNzJ3Mgc3VwZXJjbGFzcyAoe0BsaW5rIEF1dG9saW5rZXIubWF0Y2guTWF0Y2h9KSBmb3IgbW9yZSBkZXRhaWxzLlxyXG5cdCAqL1xyXG5cdEF1dG9saW5rZXIubWF0Y2guVXJsID0gQXV0b2xpbmtlci5VdGlsLmV4dGVuZCggQXV0b2xpbmtlci5tYXRjaC5NYXRjaCwge1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQGNmZyB7U3RyaW5nfSB1cmwgKHJlcXVpcmVkKVxyXG5cdFx0ICogXHJcblx0XHQgKiBUaGUgdXJsIHRoYXQgd2FzIG1hdGNoZWQuXHJcblx0XHQgKi9cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEBjZmcge0Jvb2xlYW59IHByb3RvY29sVXJsTWF0Y2ggKHJlcXVpcmVkKVxyXG5cdFx0ICogXHJcblx0XHQgKiBgdHJ1ZWAgaWYgdGhlIFVSTCBpcyBhIG1hdGNoIHdoaWNoIGFscmVhZHkgaGFzIGEgcHJvdG9jb2wgKGkuZS4gJ2h0dHA6Ly8nKSwgYGZhbHNlYCBpZiB0aGUgbWF0Y2ggd2FzIGZyb20gYSAnd3d3JyBvclxyXG5cdFx0ICoga25vd24gVExEIG1hdGNoLlxyXG5cdFx0ICovXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBAY2ZnIHtCb29sZWFufSBwcm90b2NvbFJlbGF0aXZlTWF0Y2ggKHJlcXVpcmVkKVxyXG5cdFx0ICogXHJcblx0XHQgKiBgdHJ1ZWAgaWYgdGhlIFVSTCBpcyBhIHByb3RvY29sLXJlbGF0aXZlIG1hdGNoLiBBIHByb3RvY29sLXJlbGF0aXZlIG1hdGNoIGlzIGEgVVJMIHRoYXQgc3RhcnRzIHdpdGggJy8vJyxcclxuXHRcdCAqIGFuZCB3aWxsIGJlIGVpdGhlciBodHRwOi8vIG9yIGh0dHBzOi8vIGJhc2VkIG9uIHRoZSBwcm90b2NvbCB0aGF0IHRoZSBzaXRlIGlzIGxvYWRlZCB1bmRlci5cclxuXHRcdCAqL1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQGNmZyB7Qm9vbGVhbn0gc3RyaXBQcmVmaXggKHJlcXVpcmVkKVxyXG5cdFx0ICogQGluaGVyaXRkb2MgQXV0b2xpbmtlciNzdHJpcFByZWZpeFxyXG5cdFx0ICovXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEBwcm9wZXJ0eSB7UmVnRXhwfSB1cmxQcmVmaXhSZWdleFxyXG5cdFx0ICogXHJcblx0XHQgKiBBIHJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHJlbW92ZSB0aGUgJ2h0dHA6Ly8nIG9yICdodHRwczovLycgYW5kL29yIHRoZSAnd3d3LicgZnJvbSBVUkxzLlxyXG5cdFx0ICovXHJcblx0XHR1cmxQcmVmaXhSZWdleDogL14oaHR0cHM/OlxcL1xcLyk/KHd3d1xcLik/L2ksXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHByb3BlcnR5IHtSZWdFeHB9IHByb3RvY29sUmVsYXRpdmVSZWdleFxyXG5cdFx0ICogXHJcblx0XHQgKiBUaGUgcmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gcmVtb3ZlIHRoZSBwcm90b2NvbC1yZWxhdGl2ZSAnLy8nIGZyb20gdGhlIHtAbGluayAjdXJsfSBzdHJpbmcsIGZvciBwdXJwb3Nlc1xyXG5cdFx0ICogb2Yge0BsaW5rICNnZXRBbmNob3JUZXh0fS4gQSBwcm90b2NvbC1yZWxhdGl2ZSBVUkwgaXMsIGZvciBleGFtcGxlLCBcIi8veWFob28uY29tXCJcclxuXHRcdCAqL1xyXG5cdFx0cHJvdG9jb2xSZWxhdGl2ZVJlZ2V4IDogL15cXC9cXC8vLFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gcHJvdG9jb2xQcmVwZW5kZWRcclxuXHRcdCAqIFxyXG5cdFx0ICogV2lsbCBiZSBzZXQgdG8gYHRydWVgIGlmIHRoZSAnaHR0cDovLycgcHJvdG9jb2wgaGFzIGJlZW4gcHJlcGVuZGVkIHRvIHRoZSB7QGxpbmsgI3VybH0gKGJlY2F1c2UgdGhlXHJcblx0XHQgKiB7QGxpbmsgI3VybH0gZGlkIG5vdCBoYXZlIGEgcHJvdG9jb2wpXHJcblx0XHQgKi9cclxuXHRcdHByb3RvY29sUHJlcGVuZGVkIDogZmFsc2UsXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogUmV0dXJucyBhIHN0cmluZyBuYW1lIGZvciB0aGUgdHlwZSBvZiBtYXRjaCB0aGF0IHRoaXMgY2xhc3MgcmVwcmVzZW50cy5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfVxyXG5cdFx0ICovXHJcblx0XHRnZXRUeXBlIDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiAndXJsJztcclxuXHRcdH0sXHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogUmV0dXJucyB0aGUgdXJsIHRoYXQgd2FzIG1hdGNoZWQsIGFzc3VtaW5nIHRoZSBwcm90b2NvbCB0byBiZSAnaHR0cDovLycgaWYgdGhlIG9yaWdpbmFsXHJcblx0XHQgKiBtYXRjaCB3YXMgbWlzc2luZyBhIHByb3RvY29sLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XHJcblx0XHQgKi9cclxuXHRcdGdldFVybCA6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR2YXIgdXJsID0gdGhpcy51cmw7XHJcblxyXG5cdFx0XHQvLyBpZiB0aGUgdXJsIHN0cmluZyBkb2Vzbid0IGJlZ2luIHdpdGggYSBwcm90b2NvbCwgYXNzdW1lICdodHRwOi8vJ1xyXG5cdFx0XHRpZiggIXRoaXMucHJvdG9jb2xSZWxhdGl2ZU1hdGNoICYmICF0aGlzLnByb3RvY29sVXJsTWF0Y2ggJiYgIXRoaXMucHJvdG9jb2xQcmVwZW5kZWQgKSB7XHJcblx0XHRcdFx0dXJsID0gdGhpcy51cmwgPSAnaHR0cDovLycgKyB1cmw7XHJcblxyXG5cdFx0XHRcdHRoaXMucHJvdG9jb2xQcmVwZW5kZWQgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdXJsO1xyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBSZXR1cm5zIHRoZSBhbmNob3IgaHJlZiB0aGF0IHNob3VsZCBiZSBnZW5lcmF0ZWQgZm9yIHRoZSBtYXRjaC5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfVxyXG5cdFx0ICovXHJcblx0XHRnZXRBbmNob3JIcmVmIDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHZhciB1cmwgPSB0aGlzLmdldFVybCgpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHVybC5yZXBsYWNlKCAvJmFtcDsvZywgJyYnICk7ICAvLyBhbnkgJmFtcDsncyBpbiB0aGUgVVJMIHNob3VsZCBiZSBjb252ZXJ0ZWQgYmFjayB0byAnJicgaWYgdGhleSB3ZXJlIGRpc3BsYXllZCBhcyAmYW1wOyBpbiB0aGUgc291cmNlIGh0bWwgXHJcblx0XHR9LFxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFJldHVybnMgdGhlIGFuY2hvciB0ZXh0IHRoYXQgc2hvdWxkIGJlIGdlbmVyYXRlZCBmb3IgdGhlIG1hdGNoLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XHJcblx0XHQgKi9cclxuXHRcdGdldEFuY2hvclRleHQgOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0dmFyIGFuY2hvclRleHQgPSB0aGlzLmdldFVybCgpO1xyXG5cclxuXHRcdFx0aWYoIHRoaXMucHJvdG9jb2xSZWxhdGl2ZU1hdGNoICkge1xyXG5cdFx0XHRcdC8vIFN0cmlwIG9mZiBhbnkgcHJvdG9jb2wtcmVsYXRpdmUgJy8vJyBmcm9tIHRoZSBhbmNob3IgdGV4dFxyXG5cdFx0XHRcdGFuY2hvclRleHQgPSB0aGlzLnN0cmlwUHJvdG9jb2xSZWxhdGl2ZVByZWZpeCggYW5jaG9yVGV4dCApO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKCB0aGlzLnN0cmlwUHJlZml4ICkge1xyXG5cdFx0XHRcdGFuY2hvclRleHQgPSB0aGlzLnN0cmlwVXJsUHJlZml4KCBhbmNob3JUZXh0ICk7XHJcblx0XHRcdH1cclxuXHRcdFx0YW5jaG9yVGV4dCA9IHRoaXMucmVtb3ZlVHJhaWxpbmdTbGFzaCggYW5jaG9yVGV4dCApOyAgLy8gcmVtb3ZlIHRyYWlsaW5nIHNsYXNoLCBpZiB0aGVyZSBpcyBvbmVcclxuXHJcblx0XHRcdHJldHVybiBhbmNob3JUZXh0O1xyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cdFx0Ly8gVXRpbGl0eSBGdW5jdGlvbmFsaXR5XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBTdHJpcHMgdGhlIFVSTCBwcmVmaXggKHN1Y2ggYXMgXCJodHRwOi8vXCIgb3IgXCJodHRwczovL1wiKSBmcm9tIHRoZSBnaXZlbiB0ZXh0LlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGhlIHRleHQgb2YgdGhlIGFuY2hvciB0aGF0IGlzIGJlaW5nIGdlbmVyYXRlZCwgZm9yIHdoaWNoIHRvIHN0cmlwIG9mZiB0aGVcclxuXHRcdCAqICAgdXJsIHByZWZpeCAoc3VjaCBhcyBzdHJpcHBpbmcgb2ZmIFwiaHR0cDovL1wiKVxyXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgYGFuY2hvclRleHRgLCB3aXRoIHRoZSBwcmVmaXggc3RyaXBwZWQuXHJcblx0XHQgKi9cclxuXHRcdHN0cmlwVXJsUHJlZml4IDogZnVuY3Rpb24oIHRleHQgKSB7XHJcblx0XHRcdHJldHVybiB0ZXh0LnJlcGxhY2UoIHRoaXMudXJsUHJlZml4UmVnZXgsICcnICk7XHJcblx0XHR9LFxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFN0cmlwcyBhbnkgcHJvdG9jb2wtcmVsYXRpdmUgJy8vJyBmcm9tIHRoZSBhbmNob3IgdGV4dC5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IG9mIHRoZSBhbmNob3IgdGhhdCBpcyBiZWluZyBnZW5lcmF0ZWQsIGZvciB3aGljaCB0byBzdHJpcCBvZmYgdGhlXHJcblx0XHQgKiAgIHByb3RvY29sLXJlbGF0aXZlIHByZWZpeCAoc3VjaCBhcyBzdHJpcHBpbmcgb2ZmIFwiLy9cIilcclxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGBhbmNob3JUZXh0YCwgd2l0aCB0aGUgcHJvdG9jb2wtcmVsYXRpdmUgcHJlZml4IHN0cmlwcGVkLlxyXG5cdFx0ICovXHJcblx0XHRzdHJpcFByb3RvY29sUmVsYXRpdmVQcmVmaXggOiBmdW5jdGlvbiggdGV4dCApIHtcclxuXHRcdFx0cmV0dXJuIHRleHQucmVwbGFjZSggdGhpcy5wcm90b2NvbFJlbGF0aXZlUmVnZXgsICcnICk7XHJcblx0XHR9LFxyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFJlbW92ZXMgYW55IHRyYWlsaW5nIHNsYXNoIGZyb20gdGhlIGdpdmVuIGBhbmNob3JUZXh0YCwgaW4gcHJlcGFyYXRpb24gZm9yIHRoZSB0ZXh0IHRvIGJlIGRpc3BsYXllZC5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBhbmNob3JUZXh0IFRoZSB0ZXh0IG9mIHRoZSBhbmNob3IgdGhhdCBpcyBiZWluZyBnZW5lcmF0ZWQsIGZvciB3aGljaCB0byByZW1vdmUgYW55IHRyYWlsaW5nXHJcblx0XHQgKiAgIHNsYXNoICgnLycpIHRoYXQgbWF5IGV4aXN0LlxyXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgYGFuY2hvclRleHRgLCB3aXRoIHRoZSB0cmFpbGluZyBzbGFzaCByZW1vdmVkLlxyXG5cdFx0ICovXHJcblx0XHRyZW1vdmVUcmFpbGluZ1NsYXNoIDogZnVuY3Rpb24oIGFuY2hvclRleHQgKSB7XHJcblx0XHRcdGlmKCBhbmNob3JUZXh0LmNoYXJBdCggYW5jaG9yVGV4dC5sZW5ndGggLSAxICkgPT09ICcvJyApIHtcclxuXHRcdFx0XHRhbmNob3JUZXh0ID0gYW5jaG9yVGV4dC5zbGljZSggMCwgLTEgKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gYW5jaG9yVGV4dDtcclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHRyZXR1cm4gQXV0b2xpbmtlcjtcclxuXHJcblxyXG59KSk7XHJcbiIsIi8vICAgICBCYWNrYm9uZS5qcyAxLjEuMlxuXG4vLyAgICAgKGMpIDIwMTAtMjAxNCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuLy8gICAgIEJhY2tib25lIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuLy8gICAgIEZvciBhbGwgZGV0YWlscyBhbmQgZG9jdW1lbnRhdGlvbjpcbi8vICAgICBodHRwOi8vYmFja2JvbmVqcy5vcmdcblxuKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblxuICAvLyBTZXQgdXAgQmFja2JvbmUgYXBwcm9wcmlhdGVseSBmb3IgdGhlIGVudmlyb25tZW50LiBTdGFydCB3aXRoIEFNRC5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbJ3VuZGVyc2NvcmUnLCAnanF1ZXJ5JywgJ2V4cG9ydHMnXSwgZnVuY3Rpb24oXywgJCwgZXhwb3J0cykge1xuICAgICAgLy8gRXhwb3J0IGdsb2JhbCBldmVuIGluIEFNRCBjYXNlIGluIGNhc2UgdGhpcyBzY3JpcHQgaXMgbG9hZGVkIHdpdGhcbiAgICAgIC8vIG90aGVycyB0aGF0IG1heSBzdGlsbCBleHBlY3QgYSBnbG9iYWwgQmFja2JvbmUuXG4gICAgICByb290LkJhY2tib25lID0gZmFjdG9yeShyb290LCBleHBvcnRzLCBfLCAkKTtcbiAgICB9KTtcblxuICAvLyBOZXh0IGZvciBOb2RlLmpzIG9yIENvbW1vbkpTLiBqUXVlcnkgbWF5IG5vdCBiZSBuZWVkZWQgYXMgYSBtb2R1bGUuXG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG4gICAgZmFjdG9yeShyb290LCBleHBvcnRzLCBfKTtcblxuICAvLyBGaW5hbGx5LCBhcyBhIGJyb3dzZXIgZ2xvYmFsLlxuICB9IGVsc2Uge1xuICAgIHJvb3QuQmFja2JvbmUgPSBmYWN0b3J5KHJvb3QsIHt9LCByb290Ll8sIChyb290LmpRdWVyeSB8fCByb290LlplcHRvIHx8IHJvb3QuZW5kZXIgfHwgcm9vdC4kKSk7XG4gIH1cblxufSh0aGlzLCBmdW5jdGlvbihyb290LCBCYWNrYm9uZSwgXywgJCkge1xuXG4gIC8vIEluaXRpYWwgU2V0dXBcbiAgLy8gLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFNhdmUgdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBgQmFja2JvbmVgIHZhcmlhYmxlLCBzbyB0aGF0IGl0IGNhbiBiZVxuICAvLyByZXN0b3JlZCBsYXRlciBvbiwgaWYgYG5vQ29uZmxpY3RgIGlzIHVzZWQuXG4gIHZhciBwcmV2aW91c0JhY2tib25lID0gcm9vdC5CYWNrYm9uZTtcblxuICAvLyBDcmVhdGUgbG9jYWwgcmVmZXJlbmNlcyB0byBhcnJheSBtZXRob2RzIHdlJ2xsIHdhbnQgdG8gdXNlIGxhdGVyLlxuICB2YXIgYXJyYXkgPSBbXTtcbiAgdmFyIHB1c2ggPSBhcnJheS5wdXNoO1xuICB2YXIgc2xpY2UgPSBhcnJheS5zbGljZTtcbiAgdmFyIHNwbGljZSA9IGFycmF5LnNwbGljZTtcblxuICAvLyBDdXJyZW50IHZlcnNpb24gb2YgdGhlIGxpYnJhcnkuIEtlZXAgaW4gc3luYyB3aXRoIGBwYWNrYWdlLmpzb25gLlxuICBCYWNrYm9uZS5WRVJTSU9OID0gJzEuMS4yJztcblxuICAvLyBGb3IgQmFja2JvbmUncyBwdXJwb3NlcywgalF1ZXJ5LCBaZXB0bywgRW5kZXIsIG9yIE15IExpYnJhcnkgKGtpZGRpbmcpIG93bnNcbiAgLy8gdGhlIGAkYCB2YXJpYWJsZS5cbiAgQmFja2JvbmUuJCA9ICQ7XG5cbiAgLy8gUnVucyBCYWNrYm9uZS5qcyBpbiAqbm9Db25mbGljdCogbW9kZSwgcmV0dXJuaW5nIHRoZSBgQmFja2JvbmVgIHZhcmlhYmxlXG4gIC8vIHRvIGl0cyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGlzIEJhY2tib25lIG9iamVjdC5cbiAgQmFja2JvbmUubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJvb3QuQmFja2JvbmUgPSBwcmV2aW91c0JhY2tib25lO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFR1cm4gb24gYGVtdWxhdGVIVFRQYCB0byBzdXBwb3J0IGxlZ2FjeSBIVFRQIHNlcnZlcnMuIFNldHRpbmcgdGhpcyBvcHRpb25cbiAgLy8gd2lsbCBmYWtlIGBcIlBBVENIXCJgLCBgXCJQVVRcImAgYW5kIGBcIkRFTEVURVwiYCByZXF1ZXN0cyB2aWEgdGhlIGBfbWV0aG9kYCBwYXJhbWV0ZXIgYW5kXG4gIC8vIHNldCBhIGBYLUh0dHAtTWV0aG9kLU92ZXJyaWRlYCBoZWFkZXIuXG4gIEJhY2tib25lLmVtdWxhdGVIVFRQID0gZmFsc2U7XG5cbiAgLy8gVHVybiBvbiBgZW11bGF0ZUpTT05gIHRvIHN1cHBvcnQgbGVnYWN5IHNlcnZlcnMgdGhhdCBjYW4ndCBkZWFsIHdpdGggZGlyZWN0XG4gIC8vIGBhcHBsaWNhdGlvbi9qc29uYCByZXF1ZXN0cyAuLi4gd2lsbCBlbmNvZGUgdGhlIGJvZHkgYXNcbiAgLy8gYGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZGAgaW5zdGVhZCBhbmQgd2lsbCBzZW5kIHRoZSBtb2RlbCBpbiBhXG4gIC8vIGZvcm0gcGFyYW0gbmFtZWQgYG1vZGVsYC5cbiAgQmFja2JvbmUuZW11bGF0ZUpTT04gPSBmYWxzZTtcblxuICAvLyBCYWNrYm9uZS5FdmVudHNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gQSBtb2R1bGUgdGhhdCBjYW4gYmUgbWl4ZWQgaW4gdG8gKmFueSBvYmplY3QqIGluIG9yZGVyIHRvIHByb3ZpZGUgaXQgd2l0aFxuICAvLyBjdXN0b20gZXZlbnRzLiBZb3UgbWF5IGJpbmQgd2l0aCBgb25gIG9yIHJlbW92ZSB3aXRoIGBvZmZgIGNhbGxiYWNrXG4gIC8vIGZ1bmN0aW9ucyB0byBhbiBldmVudDsgYHRyaWdnZXJgLWluZyBhbiBldmVudCBmaXJlcyBhbGwgY2FsbGJhY2tzIGluXG4gIC8vIHN1Y2Nlc3Npb24uXG4gIC8vXG4gIC8vICAgICB2YXIgb2JqZWN0ID0ge307XG4gIC8vICAgICBfLmV4dGVuZChvYmplY3QsIEJhY2tib25lLkV2ZW50cyk7XG4gIC8vICAgICBvYmplY3Qub24oJ2V4cGFuZCcsIGZ1bmN0aW9uKCl7IGFsZXJ0KCdleHBhbmRlZCcpOyB9KTtcbiAgLy8gICAgIG9iamVjdC50cmlnZ2VyKCdleHBhbmQnKTtcbiAgLy9cbiAgdmFyIEV2ZW50cyA9IEJhY2tib25lLkV2ZW50cyA9IHtcblxuICAgIC8vIEJpbmQgYW4gZXZlbnQgdG8gYSBgY2FsbGJhY2tgIGZ1bmN0aW9uLiBQYXNzaW5nIGBcImFsbFwiYCB3aWxsIGJpbmRcbiAgICAvLyB0aGUgY2FsbGJhY2sgdG8gYWxsIGV2ZW50cyBmaXJlZC5cbiAgICBvbjogZnVuY3Rpb24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgIGlmICghZXZlbnRzQXBpKHRoaXMsICdvbicsIG5hbWUsIFtjYWxsYmFjaywgY29udGV4dF0pIHx8ICFjYWxsYmFjaykgcmV0dXJuIHRoaXM7XG4gICAgICB0aGlzLl9ldmVudHMgfHwgKHRoaXMuX2V2ZW50cyA9IHt9KTtcbiAgICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHNbbmFtZV0gfHwgKHRoaXMuX2V2ZW50c1tuYW1lXSA9IFtdKTtcbiAgICAgIGV2ZW50cy5wdXNoKHtjYWxsYmFjazogY2FsbGJhY2ssIGNvbnRleHQ6IGNvbnRleHQsIGN0eDogY29udGV4dCB8fCB0aGlzfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQmluZCBhbiBldmVudCB0byBvbmx5IGJlIHRyaWdnZXJlZCBhIHNpbmdsZSB0aW1lLiBBZnRlciB0aGUgZmlyc3QgdGltZVxuICAgIC8vIHRoZSBjYWxsYmFjayBpcyBpbnZva2VkLCBpdCB3aWxsIGJlIHJlbW92ZWQuXG4gICAgb25jZTogZnVuY3Rpb24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgIGlmICghZXZlbnRzQXBpKHRoaXMsICdvbmNlJywgbmFtZSwgW2NhbGxiYWNrLCBjb250ZXh0XSkgfHwgIWNhbGxiYWNrKSByZXR1cm4gdGhpcztcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBvbmNlID0gXy5vbmNlKGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLm9mZihuYW1lLCBvbmNlKTtcbiAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuICAgICAgb25jZS5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIHJldHVybiB0aGlzLm9uKG5hbWUsIG9uY2UsIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgb25lIG9yIG1hbnkgY2FsbGJhY2tzLiBJZiBgY29udGV4dGAgaXMgbnVsbCwgcmVtb3ZlcyBhbGxcbiAgICAvLyBjYWxsYmFja3Mgd2l0aCB0aGF0IGZ1bmN0aW9uLiBJZiBgY2FsbGJhY2tgIGlzIG51bGwsIHJlbW92ZXMgYWxsXG4gICAgLy8gY2FsbGJhY2tzIGZvciB0aGUgZXZlbnQuIElmIGBuYW1lYCBpcyBudWxsLCByZW1vdmVzIGFsbCBib3VuZFxuICAgIC8vIGNhbGxiYWNrcyBmb3IgYWxsIGV2ZW50cy5cbiAgICBvZmY6IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcmV0YWluLCBldiwgZXZlbnRzLCBuYW1lcywgaSwgbCwgaiwgaztcbiAgICAgIGlmICghdGhpcy5fZXZlbnRzIHx8ICFldmVudHNBcGkodGhpcywgJ29mZicsIG5hbWUsIFtjYWxsYmFjaywgY29udGV4dF0pKSByZXR1cm4gdGhpcztcbiAgICAgIGlmICghbmFtZSAmJiAhY2FsbGJhY2sgJiYgIWNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gdm9pZCAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIG5hbWVzID0gbmFtZSA/IFtuYW1lXSA6IF8ua2V5cyh0aGlzLl9ldmVudHMpO1xuICAgICAgZm9yIChpID0gMCwgbCA9IG5hbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgIGlmIChldmVudHMgPSB0aGlzLl9ldmVudHNbbmFtZV0pIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHNbbmFtZV0gPSByZXRhaW4gPSBbXTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sgfHwgY29udGV4dCkge1xuICAgICAgICAgICAgZm9yIChqID0gMCwgayA9IGV2ZW50cy5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgICAgZXYgPSBldmVudHNbal07XG4gICAgICAgICAgICAgIGlmICgoY2FsbGJhY2sgJiYgY2FsbGJhY2sgIT09IGV2LmNhbGxiYWNrICYmIGNhbGxiYWNrICE9PSBldi5jYWxsYmFjay5fY2FsbGJhY2spIHx8XG4gICAgICAgICAgICAgICAgICAoY29udGV4dCAmJiBjb250ZXh0ICE9PSBldi5jb250ZXh0KSkge1xuICAgICAgICAgICAgICAgIHJldGFpbi5wdXNoKGV2KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJldGFpbi5sZW5ndGgpIGRlbGV0ZSB0aGlzLl9ldmVudHNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFRyaWdnZXIgb25lIG9yIG1hbnkgZXZlbnRzLCBmaXJpbmcgYWxsIGJvdW5kIGNhbGxiYWNrcy4gQ2FsbGJhY2tzIGFyZVxuICAgIC8vIHBhc3NlZCB0aGUgc2FtZSBhcmd1bWVudHMgYXMgYHRyaWdnZXJgIGlzLCBhcGFydCBmcm9tIHRoZSBldmVudCBuYW1lXG4gICAgLy8gKHVubGVzcyB5b3UncmUgbGlzdGVuaW5nIG9uIGBcImFsbFwiYCwgd2hpY2ggd2lsbCBjYXVzZSB5b3VyIGNhbGxiYWNrIHRvXG4gICAgLy8gcmVjZWl2ZSB0aGUgdHJ1ZSBuYW1lIG9mIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgYXJndW1lbnQpLlxuICAgIHRyaWdnZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGlmICghdGhpcy5fZXZlbnRzKSByZXR1cm4gdGhpcztcbiAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgaWYgKCFldmVudHNBcGkodGhpcywgJ3RyaWdnZXInLCBuYW1lLCBhcmdzKSkgcmV0dXJuIHRoaXM7XG4gICAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzW25hbWVdO1xuICAgICAgdmFyIGFsbEV2ZW50cyA9IHRoaXMuX2V2ZW50cy5hbGw7XG4gICAgICBpZiAoZXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGV2ZW50cywgYXJncyk7XG4gICAgICBpZiAoYWxsRXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGFsbEV2ZW50cywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBUZWxsIHRoaXMgb2JqZWN0IHRvIHN0b3AgbGlzdGVuaW5nIHRvIGVpdGhlciBzcGVjaWZpYyBldmVudHMgLi4uIG9yXG4gICAgLy8gdG8gZXZlcnkgb2JqZWN0IGl0J3MgY3VycmVudGx5IGxpc3RlbmluZyB0by5cbiAgICBzdG9wTGlzdGVuaW5nOiBmdW5jdGlvbihvYmosIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgbGlzdGVuaW5nVG8gPSB0aGlzLl9saXN0ZW5pbmdUbztcbiAgICAgIGlmICghbGlzdGVuaW5nVG8pIHJldHVybiB0aGlzO1xuICAgICAgdmFyIHJlbW92ZSA9ICFuYW1lICYmICFjYWxsYmFjaztcbiAgICAgIGlmICghY2FsbGJhY2sgJiYgdHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSBjYWxsYmFjayA9IHRoaXM7XG4gICAgICBpZiAob2JqKSAobGlzdGVuaW5nVG8gPSB7fSlbb2JqLl9saXN0ZW5JZF0gPSBvYmo7XG4gICAgICBmb3IgKHZhciBpZCBpbiBsaXN0ZW5pbmdUbykge1xuICAgICAgICBvYmogPSBsaXN0ZW5pbmdUb1tpZF07XG4gICAgICAgIG9iai5vZmYobmFtZSwgY2FsbGJhY2ssIHRoaXMpO1xuICAgICAgICBpZiAocmVtb3ZlIHx8IF8uaXNFbXB0eShvYmouX2V2ZW50cykpIGRlbGV0ZSB0aGlzLl9saXN0ZW5pbmdUb1tpZF07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgfTtcblxuICAvLyBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byBzcGxpdCBldmVudCBzdHJpbmdzLlxuICB2YXIgZXZlbnRTcGxpdHRlciA9IC9cXHMrLztcblxuICAvLyBJbXBsZW1lbnQgZmFuY3kgZmVhdHVyZXMgb2YgdGhlIEV2ZW50cyBBUEkgc3VjaCBhcyBtdWx0aXBsZSBldmVudFxuICAvLyBuYW1lcyBgXCJjaGFuZ2UgYmx1clwiYCBhbmQgalF1ZXJ5LXN0eWxlIGV2ZW50IG1hcHMgYHtjaGFuZ2U6IGFjdGlvbn1gXG4gIC8vIGluIHRlcm1zIG9mIHRoZSBleGlzdGluZyBBUEkuXG4gIHZhciBldmVudHNBcGkgPSBmdW5jdGlvbihvYmosIGFjdGlvbiwgbmFtZSwgcmVzdCkge1xuICAgIGlmICghbmFtZSkgcmV0dXJuIHRydWU7XG5cbiAgICAvLyBIYW5kbGUgZXZlbnQgbWFwcy5cbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gbmFtZSkge1xuICAgICAgICBvYmpbYWN0aW9uXS5hcHBseShvYmosIFtrZXksIG5hbWVba2V5XV0uY29uY2F0KHJlc3QpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgc3BhY2Ugc2VwYXJhdGVkIGV2ZW50IG5hbWVzLlxuICAgIGlmIChldmVudFNwbGl0dGVyLnRlc3QobmFtZSkpIHtcbiAgICAgIHZhciBuYW1lcyA9IG5hbWUuc3BsaXQoZXZlbnRTcGxpdHRlcik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5hbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBvYmpbYWN0aW9uXS5hcHBseShvYmosIFtuYW1lc1tpXV0uY29uY2F0KHJlc3QpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBBIGRpZmZpY3VsdC10by1iZWxpZXZlLCBidXQgb3B0aW1pemVkIGludGVybmFsIGRpc3BhdGNoIGZ1bmN0aW9uIGZvclxuICAvLyB0cmlnZ2VyaW5nIGV2ZW50cy4gVHJpZXMgdG8ga2VlcCB0aGUgdXN1YWwgY2FzZXMgc3BlZWR5IChtb3N0IGludGVybmFsXG4gIC8vIEJhY2tib25lIGV2ZW50cyBoYXZlIDMgYXJndW1lbnRzKS5cbiAgdmFyIHRyaWdnZXJFdmVudHMgPSBmdW5jdGlvbihldmVudHMsIGFyZ3MpIHtcbiAgICB2YXIgZXYsIGkgPSAtMSwgbCA9IGV2ZW50cy5sZW5ndGgsIGExID0gYXJnc1swXSwgYTIgPSBhcmdzWzFdLCBhMyA9IGFyZ3NbMl07XG4gICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOiB3aGlsZSAoKytpIDwgbCkgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5jYWxsKGV2LmN0eCk7IHJldHVybjtcbiAgICAgIGNhc2UgMTogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgsIGExKTsgcmV0dXJuO1xuICAgICAgY2FzZSAyOiB3aGlsZSAoKytpIDwgbCkgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5jYWxsKGV2LmN0eCwgYTEsIGEyKTsgcmV0dXJuO1xuICAgICAgY2FzZSAzOiB3aGlsZSAoKytpIDwgbCkgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5jYWxsKGV2LmN0eCwgYTEsIGEyLCBhMyk7IHJldHVybjtcbiAgICAgIGRlZmF1bHQ6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmFwcGx5KGV2LmN0eCwgYXJncyk7IHJldHVybjtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGxpc3Rlbk1ldGhvZHMgPSB7bGlzdGVuVG86ICdvbicsIGxpc3RlblRvT25jZTogJ29uY2UnfTtcblxuICAvLyBJbnZlcnNpb24tb2YtY29udHJvbCB2ZXJzaW9ucyBvZiBgb25gIGFuZCBgb25jZWAuIFRlbGwgKnRoaXMqIG9iamVjdCB0b1xuICAvLyBsaXN0ZW4gdG8gYW4gZXZlbnQgaW4gYW5vdGhlciBvYmplY3QgLi4uIGtlZXBpbmcgdHJhY2sgb2Ygd2hhdCBpdCdzXG4gIC8vIGxpc3RlbmluZyB0by5cbiAgXy5lYWNoKGxpc3Rlbk1ldGhvZHMsIGZ1bmN0aW9uKGltcGxlbWVudGF0aW9uLCBtZXRob2QpIHtcbiAgICBFdmVudHNbbWV0aG9kXSA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBsaXN0ZW5pbmdUbyA9IHRoaXMuX2xpc3RlbmluZ1RvIHx8ICh0aGlzLl9saXN0ZW5pbmdUbyA9IHt9KTtcbiAgICAgIHZhciBpZCA9IG9iai5fbGlzdGVuSWQgfHwgKG9iai5fbGlzdGVuSWQgPSBfLnVuaXF1ZUlkKCdsJykpO1xuICAgICAgbGlzdGVuaW5nVG9baWRdID0gb2JqO1xuICAgICAgaWYgKCFjYWxsYmFjayAmJiB0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIGNhbGxiYWNrID0gdGhpcztcbiAgICAgIG9ialtpbXBsZW1lbnRhdGlvbl0obmFtZSwgY2FsbGJhY2ssIHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gQWxpYXNlcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gIEV2ZW50cy5iaW5kICAgPSBFdmVudHMub247XG4gIEV2ZW50cy51bmJpbmQgPSBFdmVudHMub2ZmO1xuXG4gIC8vIEFsbG93IHRoZSBgQmFja2JvbmVgIG9iamVjdCB0byBzZXJ2ZSBhcyBhIGdsb2JhbCBldmVudCBidXMsIGZvciBmb2xrcyB3aG9cbiAgLy8gd2FudCBnbG9iYWwgXCJwdWJzdWJcIiBpbiBhIGNvbnZlbmllbnQgcGxhY2UuXG4gIF8uZXh0ZW5kKEJhY2tib25lLCBFdmVudHMpO1xuXG4gIC8vIEJhY2tib25lLk1vZGVsXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gQmFja2JvbmUgKipNb2RlbHMqKiBhcmUgdGhlIGJhc2ljIGRhdGEgb2JqZWN0IGluIHRoZSBmcmFtZXdvcmsgLS1cbiAgLy8gZnJlcXVlbnRseSByZXByZXNlbnRpbmcgYSByb3cgaW4gYSB0YWJsZSBpbiBhIGRhdGFiYXNlIG9uIHlvdXIgc2VydmVyLlxuICAvLyBBIGRpc2NyZXRlIGNodW5rIG9mIGRhdGEgYW5kIGEgYnVuY2ggb2YgdXNlZnVsLCByZWxhdGVkIG1ldGhvZHMgZm9yXG4gIC8vIHBlcmZvcm1pbmcgY29tcHV0YXRpb25zIGFuZCB0cmFuc2Zvcm1hdGlvbnMgb24gdGhhdCBkYXRhLlxuXG4gIC8vIENyZWF0ZSBhIG5ldyBtb2RlbCB3aXRoIHRoZSBzcGVjaWZpZWQgYXR0cmlidXRlcy4gQSBjbGllbnQgaWQgKGBjaWRgKVxuICAvLyBpcyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBhbmQgYXNzaWduZWQgZm9yIHlvdS5cbiAgdmFyIE1vZGVsID0gQmFja2JvbmUuTW9kZWwgPSBmdW5jdGlvbihhdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgdmFyIGF0dHJzID0gYXR0cmlidXRlcyB8fCB7fTtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgIHRoaXMuY2lkID0gXy51bmlxdWVJZCgnYycpO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgIGlmIChvcHRpb25zLmNvbGxlY3Rpb24pIHRoaXMuY29sbGVjdGlvbiA9IG9wdGlvbnMuY29sbGVjdGlvbjtcbiAgICBpZiAob3B0aW9ucy5wYXJzZSkgYXR0cnMgPSB0aGlzLnBhcnNlKGF0dHJzLCBvcHRpb25zKSB8fCB7fTtcbiAgICBhdHRycyA9IF8uZGVmYXVsdHMoe30sIGF0dHJzLCBfLnJlc3VsdCh0aGlzLCAnZGVmYXVsdHMnKSk7XG4gICAgdGhpcy5zZXQoYXR0cnMsIG9wdGlvbnMpO1xuICAgIHRoaXMuY2hhbmdlZCA9IHt9O1xuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIEF0dGFjaCBhbGwgaW5oZXJpdGFibGUgbWV0aG9kcyB0byB0aGUgTW9kZWwgcHJvdG90eXBlLlxuICBfLmV4dGVuZChNb2RlbC5wcm90b3R5cGUsIEV2ZW50cywge1xuXG4gICAgLy8gQSBoYXNoIG9mIGF0dHJpYnV0ZXMgd2hvc2UgY3VycmVudCBhbmQgcHJldmlvdXMgdmFsdWUgZGlmZmVyLlxuICAgIGNoYW5nZWQ6IG51bGwsXG5cbiAgICAvLyBUaGUgdmFsdWUgcmV0dXJuZWQgZHVyaW5nIHRoZSBsYXN0IGZhaWxlZCB2YWxpZGF0aW9uLlxuICAgIHZhbGlkYXRpb25FcnJvcjogbnVsbCxcblxuICAgIC8vIFRoZSBkZWZhdWx0IG5hbWUgZm9yIHRoZSBKU09OIGBpZGAgYXR0cmlidXRlIGlzIGBcImlkXCJgLiBNb25nb0RCIGFuZFxuICAgIC8vIENvdWNoREIgdXNlcnMgbWF5IHdhbnQgdG8gc2V0IHRoaXMgdG8gYFwiX2lkXCJgLlxuICAgIGlkQXR0cmlidXRlOiAnaWQnLFxuXG4gICAgLy8gSW5pdGlhbGl6ZSBpcyBhbiBlbXB0eSBmdW5jdGlvbiBieSBkZWZhdWx0LiBPdmVycmlkZSBpdCB3aXRoIHlvdXIgb3duXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gbG9naWMuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKXt9LFxuXG4gICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgbW9kZWwncyBgYXR0cmlidXRlc2Agb2JqZWN0LlxuICAgIHRvSlNPTjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIF8uY2xvbmUodGhpcy5hdHRyaWJ1dGVzKTtcbiAgICB9LFxuXG4gICAgLy8gUHJveHkgYEJhY2tib25lLnN5bmNgIGJ5IGRlZmF1bHQgLS0gYnV0IG92ZXJyaWRlIHRoaXMgaWYgeW91IG5lZWRcbiAgICAvLyBjdXN0b20gc3luY2luZyBzZW1hbnRpY3MgZm9yICp0aGlzKiBwYXJ0aWN1bGFyIG1vZGVsLlxuICAgIHN5bmM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEJhY2tib25lLnN5bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUuXG4gICAgZ2V0OiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW2F0dHJdO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIEhUTUwtZXNjYXBlZCB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUuXG4gICAgZXNjYXBlOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICByZXR1cm4gXy5lc2NhcGUodGhpcy5nZXQoYXR0cikpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXR0cmlidXRlIGNvbnRhaW5zIGEgdmFsdWUgdGhhdCBpcyBub3QgbnVsbFxuICAgIC8vIG9yIHVuZGVmaW5lZC5cbiAgICBoYXM6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldChhdHRyKSAhPSBudWxsO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgYSBoYXNoIG9mIG1vZGVsIGF0dHJpYnV0ZXMgb24gdGhlIG9iamVjdCwgZmlyaW5nIGBcImNoYW5nZVwiYC4gVGhpcyBpc1xuICAgIC8vIHRoZSBjb3JlIHByaW1pdGl2ZSBvcGVyYXRpb24gb2YgYSBtb2RlbCwgdXBkYXRpbmcgdGhlIGRhdGEgYW5kIG5vdGlmeWluZ1xuICAgIC8vIGFueW9uZSB3aG8gbmVlZHMgdG8ga25vdyBhYm91dCB0aGUgY2hhbmdlIGluIHN0YXRlLiBUaGUgaGVhcnQgb2YgdGhlIGJlYXN0LlxuICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWwsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBhdHRyLCBhdHRycywgdW5zZXQsIGNoYW5nZXMsIHNpbGVudCwgY2hhbmdpbmcsIHByZXYsIGN1cnJlbnQ7XG4gICAgICBpZiAoa2V5ID09IG51bGwpIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBIYW5kbGUgYm90aCBgXCJrZXlcIiwgdmFsdWVgIGFuZCBge2tleTogdmFsdWV9YCAtc3R5bGUgYXJndW1lbnRzLlxuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGF0dHJzID0ga2V5O1xuICAgICAgICBvcHRpb25zID0gdmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKGF0dHJzID0ge30pW2tleV0gPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG5cbiAgICAgIC8vIFJ1biB2YWxpZGF0aW9uLlxuICAgICAgaWYgKCF0aGlzLl92YWxpZGF0ZShhdHRycywgb3B0aW9ucykpIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gRXh0cmFjdCBhdHRyaWJ1dGVzIGFuZCBvcHRpb25zLlxuICAgICAgdW5zZXQgICAgICAgICAgID0gb3B0aW9ucy51bnNldDtcbiAgICAgIHNpbGVudCAgICAgICAgICA9IG9wdGlvbnMuc2lsZW50O1xuICAgICAgY2hhbmdlcyAgICAgICAgID0gW107XG4gICAgICBjaGFuZ2luZyAgICAgICAgPSB0aGlzLl9jaGFuZ2luZztcbiAgICAgIHRoaXMuX2NoYW5naW5nICA9IHRydWU7XG5cbiAgICAgIGlmICghY2hhbmdpbmcpIHtcbiAgICAgICAgdGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzID0gXy5jbG9uZSh0aGlzLmF0dHJpYnV0ZXMpO1xuICAgICAgICB0aGlzLmNoYW5nZWQgPSB7fTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSB0aGlzLmF0dHJpYnV0ZXMsIHByZXYgPSB0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXM7XG5cbiAgICAgIC8vIENoZWNrIGZvciBjaGFuZ2VzIG9mIGBpZGAuXG4gICAgICBpZiAodGhpcy5pZEF0dHJpYnV0ZSBpbiBhdHRycykgdGhpcy5pZCA9IGF0dHJzW3RoaXMuaWRBdHRyaWJ1dGVdO1xuXG4gICAgICAvLyBGb3IgZWFjaCBgc2V0YCBhdHRyaWJ1dGUsIHVwZGF0ZSBvciBkZWxldGUgdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAgICBmb3IgKGF0dHIgaW4gYXR0cnMpIHtcbiAgICAgICAgdmFsID0gYXR0cnNbYXR0cl07XG4gICAgICAgIGlmICghXy5pc0VxdWFsKGN1cnJlbnRbYXR0cl0sIHZhbCkpIGNoYW5nZXMucHVzaChhdHRyKTtcbiAgICAgICAgaWYgKCFfLmlzRXF1YWwocHJldlthdHRyXSwgdmFsKSkge1xuICAgICAgICAgIHRoaXMuY2hhbmdlZFthdHRyXSA9IHZhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5jaGFuZ2VkW2F0dHJdO1xuICAgICAgICB9XG4gICAgICAgIHVuc2V0ID8gZGVsZXRlIGN1cnJlbnRbYXR0cl0gOiBjdXJyZW50W2F0dHJdID0gdmFsO1xuICAgICAgfVxuXG4gICAgICAvLyBUcmlnZ2VyIGFsbCByZWxldmFudCBhdHRyaWJ1dGUgY2hhbmdlcy5cbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmxlbmd0aCkgdGhpcy5fcGVuZGluZyA9IG9wdGlvbnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hhbmdlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZTonICsgY2hhbmdlc1tpXSwgdGhpcywgY3VycmVudFtjaGFuZ2VzW2ldXSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gWW91IG1pZ2h0IGJlIHdvbmRlcmluZyB3aHkgdGhlcmUncyBhIGB3aGlsZWAgbG9vcCBoZXJlLiBDaGFuZ2VzIGNhblxuICAgICAgLy8gYmUgcmVjdXJzaXZlbHkgbmVzdGVkIHdpdGhpbiBgXCJjaGFuZ2VcImAgZXZlbnRzLlxuICAgICAgaWYgKGNoYW5naW5nKSByZXR1cm4gdGhpcztcbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIHdoaWxlICh0aGlzLl9wZW5kaW5nKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHRoaXMuX3BlbmRpbmc7XG4gICAgICAgICAgdGhpcy5fcGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlJywgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX3BlbmRpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2NoYW5naW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGFuIGF0dHJpYnV0ZSBmcm9tIHRoZSBtb2RlbCwgZmlyaW5nIGBcImNoYW5nZVwiYC4gYHVuc2V0YCBpcyBhIG5vb3BcbiAgICAvLyBpZiB0aGUgYXR0cmlidXRlIGRvZXNuJ3QgZXhpc3QuXG4gICAgdW5zZXQ6IGZ1bmN0aW9uKGF0dHIsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldChhdHRyLCB2b2lkIDAsIF8uZXh0ZW5kKHt9LCBvcHRpb25zLCB7dW5zZXQ6IHRydWV9KSk7XG4gICAgfSxcblxuICAgIC8vIENsZWFyIGFsbCBhdHRyaWJ1dGVzIG9uIHRoZSBtb2RlbCwgZmlyaW5nIGBcImNoYW5nZVwiYC5cbiAgICBjbGVhcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGF0dHJzID0ge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5hdHRyaWJ1dGVzKSBhdHRyc1trZXldID0gdm9pZCAwO1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KGF0dHJzLCBfLmV4dGVuZCh7fSwgb3B0aW9ucywge3Vuc2V0OiB0cnVlfSkpO1xuICAgIH0sXG5cbiAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIG1vZGVsIGhhcyBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IGBcImNoYW5nZVwiYCBldmVudC5cbiAgICAvLyBJZiB5b3Ugc3BlY2lmeSBhbiBhdHRyaWJ1dGUgbmFtZSwgZGV0ZXJtaW5lIGlmIHRoYXQgYXR0cmlidXRlIGhhcyBjaGFuZ2VkLlxuICAgIGhhc0NoYW5nZWQ6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIGlmIChhdHRyID09IG51bGwpIHJldHVybiAhXy5pc0VtcHR5KHRoaXMuY2hhbmdlZCk7XG4gICAgICByZXR1cm4gXy5oYXModGhpcy5jaGFuZ2VkLCBhdHRyKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgYXR0cmlidXRlcyB0aGF0IGhhdmUgY2hhbmdlZCwgb3JcbiAgICAvLyBmYWxzZSBpZiB0aGVyZSBhcmUgbm8gY2hhbmdlZCBhdHRyaWJ1dGVzLiBVc2VmdWwgZm9yIGRldGVybWluaW5nIHdoYXRcbiAgICAvLyBwYXJ0cyBvZiBhIHZpZXcgbmVlZCB0byBiZSB1cGRhdGVkIGFuZC9vciB3aGF0IGF0dHJpYnV0ZXMgbmVlZCB0byBiZVxuICAgIC8vIHBlcnNpc3RlZCB0byB0aGUgc2VydmVyLiBVbnNldCBhdHRyaWJ1dGVzIHdpbGwgYmUgc2V0IHRvIHVuZGVmaW5lZC5cbiAgICAvLyBZb3UgY2FuIGFsc28gcGFzcyBhbiBhdHRyaWJ1dGVzIG9iamVjdCB0byBkaWZmIGFnYWluc3QgdGhlIG1vZGVsLFxuICAgIC8vIGRldGVybWluaW5nIGlmIHRoZXJlICp3b3VsZCBiZSogYSBjaGFuZ2UuXG4gICAgY2hhbmdlZEF0dHJpYnV0ZXM6IGZ1bmN0aW9uKGRpZmYpIHtcbiAgICAgIGlmICghZGlmZikgcmV0dXJuIHRoaXMuaGFzQ2hhbmdlZCgpID8gXy5jbG9uZSh0aGlzLmNoYW5nZWQpIDogZmFsc2U7XG4gICAgICB2YXIgdmFsLCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICB2YXIgb2xkID0gdGhpcy5fY2hhbmdpbmcgPyB0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXMgOiB0aGlzLmF0dHJpYnV0ZXM7XG4gICAgICBmb3IgKHZhciBhdHRyIGluIGRpZmYpIHtcbiAgICAgICAgaWYgKF8uaXNFcXVhbChvbGRbYXR0cl0sICh2YWwgPSBkaWZmW2F0dHJdKSkpIGNvbnRpbnVlO1xuICAgICAgICAoY2hhbmdlZCB8fCAoY2hhbmdlZCA9IHt9KSlbYXR0cl0gPSB2YWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBwcmV2aW91cyB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUsIHJlY29yZGVkIGF0IHRoZSB0aW1lIHRoZSBsYXN0XG4gICAgLy8gYFwiY2hhbmdlXCJgIGV2ZW50IHdhcyBmaXJlZC5cbiAgICBwcmV2aW91czogZnVuY3Rpb24oYXR0cikge1xuICAgICAgaWYgKGF0dHIgPT0gbnVsbCB8fCAhdGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzKSByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXNbYXR0cl07XG4gICAgfSxcblxuICAgIC8vIEdldCBhbGwgb2YgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIG1vZGVsIGF0IHRoZSB0aW1lIG9mIHRoZSBwcmV2aW91c1xuICAgIC8vIGBcImNoYW5nZVwiYCBldmVudC5cbiAgICBwcmV2aW91c0F0dHJpYnV0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF8uY2xvbmUodGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzKTtcbiAgICB9LFxuXG4gICAgLy8gRmV0Y2ggdGhlIG1vZGVsIGZyb20gdGhlIHNlcnZlci4gSWYgdGhlIHNlcnZlcidzIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuICAgIC8vIG1vZGVsIGRpZmZlcnMgZnJvbSBpdHMgY3VycmVudCBhdHRyaWJ1dGVzLCB0aGV5IHdpbGwgYmUgb3ZlcnJpZGRlbixcbiAgICAvLyB0cmlnZ2VyaW5nIGEgYFwiY2hhbmdlXCJgIGV2ZW50LlxuICAgIGZldGNoOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyA/IF8uY2xvbmUob3B0aW9ucykgOiB7fTtcbiAgICAgIGlmIChvcHRpb25zLnBhcnNlID09PSB2b2lkIDApIG9wdGlvbnMucGFyc2UgPSB0cnVlO1xuICAgICAgdmFyIG1vZGVsID0gdGhpcztcbiAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xuICAgICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICBpZiAoIW1vZGVsLnNldChtb2RlbC5wYXJzZShyZXNwLCBvcHRpb25zKSwgb3B0aW9ucykpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHN1Y2Nlc3MobW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgICBtb2RlbC50cmlnZ2VyKCdzeW5jJywgbW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgfTtcbiAgICAgIHdyYXBFcnJvcih0aGlzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzLnN5bmMoJ3JlYWQnLCB0aGlzLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLy8gU2V0IGEgaGFzaCBvZiBtb2RlbCBhdHRyaWJ1dGVzLCBhbmQgc3luYyB0aGUgbW9kZWwgdG8gdGhlIHNlcnZlci5cbiAgICAvLyBJZiB0aGUgc2VydmVyIHJldHVybnMgYW4gYXR0cmlidXRlcyBoYXNoIHRoYXQgZGlmZmVycywgdGhlIG1vZGVsJ3NcbiAgICAvLyBzdGF0ZSB3aWxsIGJlIGBzZXRgIGFnYWluLlxuICAgIHNhdmU6IGZ1bmN0aW9uKGtleSwgdmFsLCBvcHRpb25zKSB7XG4gICAgICB2YXIgYXR0cnMsIG1ldGhvZCwgeGhyLCBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXG4gICAgICAvLyBIYW5kbGUgYm90aCBgXCJrZXlcIiwgdmFsdWVgIGFuZCBge2tleTogdmFsdWV9YCAtc3R5bGUgYXJndW1lbnRzLlxuICAgICAgaWYgKGtleSA9PSBudWxsIHx8IHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGF0dHJzID0ga2V5O1xuICAgICAgICBvcHRpb25zID0gdmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKGF0dHJzID0ge30pW2tleV0gPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7dmFsaWRhdGU6IHRydWV9LCBvcHRpb25zKTtcblxuICAgICAgLy8gSWYgd2UncmUgbm90IHdhaXRpbmcgYW5kIGF0dHJpYnV0ZXMgZXhpc3QsIHNhdmUgYWN0cyBhc1xuICAgICAgLy8gYHNldChhdHRyKS5zYXZlKG51bGwsIG9wdHMpYCB3aXRoIHZhbGlkYXRpb24uIE90aGVyd2lzZSwgY2hlY2sgaWZcbiAgICAgIC8vIHRoZSBtb2RlbCB3aWxsIGJlIHZhbGlkIHdoZW4gdGhlIGF0dHJpYnV0ZXMsIGlmIGFueSwgYXJlIHNldC5cbiAgICAgIGlmIChhdHRycyAmJiAhb3B0aW9ucy53YWl0KSB7XG4gICAgICAgIGlmICghdGhpcy5zZXQoYXR0cnMsIG9wdGlvbnMpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMuX3ZhbGlkYXRlKGF0dHJzLCBvcHRpb25zKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgdGVtcG9yYXJ5IGF0dHJpYnV0ZXMgaWYgYHt3YWl0OiB0cnVlfWAuXG4gICAgICBpZiAoYXR0cnMgJiYgb3B0aW9ucy53YWl0KSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IF8uZXh0ZW5kKHt9LCBhdHRyaWJ1dGVzLCBhdHRycyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFmdGVyIGEgc3VjY2Vzc2Z1bCBzZXJ2ZXItc2lkZSBzYXZlLCB0aGUgY2xpZW50IGlzIChvcHRpb25hbGx5KVxuICAgICAgLy8gdXBkYXRlZCB3aXRoIHRoZSBzZXJ2ZXItc2lkZSBzdGF0ZS5cbiAgICAgIGlmIChvcHRpb25zLnBhcnNlID09PSB2b2lkIDApIG9wdGlvbnMucGFyc2UgPSB0cnVlO1xuICAgICAgdmFyIG1vZGVsID0gdGhpcztcbiAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xuICAgICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICAvLyBFbnN1cmUgYXR0cmlidXRlcyBhcmUgcmVzdG9yZWQgZHVyaW5nIHN5bmNocm9ub3VzIHNhdmVzLlxuICAgICAgICBtb2RlbC5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICAgICAgdmFyIHNlcnZlckF0dHJzID0gbW9kZWwucGFyc2UocmVzcCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChvcHRpb25zLndhaXQpIHNlcnZlckF0dHJzID0gXy5leHRlbmQoYXR0cnMgfHwge30sIHNlcnZlckF0dHJzKTtcbiAgICAgICAgaWYgKF8uaXNPYmplY3Qoc2VydmVyQXR0cnMpICYmICFtb2RlbC5zZXQoc2VydmVyQXR0cnMsIG9wdGlvbnMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdWNjZXNzKSBzdWNjZXNzKG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgICAgbW9kZWwudHJpZ2dlcignc3luYycsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgIH07XG4gICAgICB3cmFwRXJyb3IodGhpcywgb3B0aW9ucyk7XG5cbiAgICAgIG1ldGhvZCA9IHRoaXMuaXNOZXcoKSA/ICdjcmVhdGUnIDogKG9wdGlvbnMucGF0Y2ggPyAncGF0Y2gnIDogJ3VwZGF0ZScpO1xuICAgICAgaWYgKG1ldGhvZCA9PT0gJ3BhdGNoJykgb3B0aW9ucy5hdHRycyA9IGF0dHJzO1xuICAgICAgeGhyID0gdGhpcy5zeW5jKG1ldGhvZCwgdGhpcywgb3B0aW9ucyk7XG5cbiAgICAgIC8vIFJlc3RvcmUgYXR0cmlidXRlcy5cbiAgICAgIGlmIChhdHRycyAmJiBvcHRpb25zLndhaXQpIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG5cbiAgICAgIHJldHVybiB4aHI7XG4gICAgfSxcblxuICAgIC8vIERlc3Ryb3kgdGhpcyBtb2RlbCBvbiB0aGUgc2VydmVyIGlmIGl0IHdhcyBhbHJlYWR5IHBlcnNpc3RlZC5cbiAgICAvLyBPcHRpbWlzdGljYWxseSByZW1vdmVzIHRoZSBtb2RlbCBmcm9tIGl0cyBjb2xsZWN0aW9uLCBpZiBpdCBoYXMgb25lLlxuICAgIC8vIElmIGB3YWl0OiB0cnVlYCBpcyBwYXNzZWQsIHdhaXRzIGZvciB0aGUgc2VydmVyIHRvIHJlc3BvbmQgYmVmb3JlIHJlbW92YWwuXG4gICAgZGVzdHJveTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBfLmNsb25lKG9wdGlvbnMpIDoge307XG4gICAgICB2YXIgbW9kZWwgPSB0aGlzO1xuICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG5cbiAgICAgIHZhciBkZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG1vZGVsLnRyaWdnZXIoJ2Rlc3Ryb3knLCBtb2RlbCwgbW9kZWwuY29sbGVjdGlvbiwgb3B0aW9ucyk7XG4gICAgICB9O1xuXG4gICAgICBvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgIGlmIChvcHRpb25zLndhaXQgfHwgbW9kZWwuaXNOZXcoKSkgZGVzdHJveSgpO1xuICAgICAgICBpZiAoc3VjY2Vzcykgc3VjY2Vzcyhtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICAgIGlmICghbW9kZWwuaXNOZXcoKSkgbW9kZWwudHJpZ2dlcignc3luYycsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLmlzTmV3KCkpIHtcbiAgICAgICAgb3B0aW9ucy5zdWNjZXNzKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHdyYXBFcnJvcih0aGlzLCBvcHRpb25zKTtcblxuICAgICAgdmFyIHhociA9IHRoaXMuc3luYygnZGVsZXRlJywgdGhpcywgb3B0aW9ucyk7XG4gICAgICBpZiAoIW9wdGlvbnMud2FpdCkgZGVzdHJveSgpO1xuICAgICAgcmV0dXJuIHhocjtcbiAgICB9LFxuXG4gICAgLy8gRGVmYXVsdCBVUkwgZm9yIHRoZSBtb2RlbCdzIHJlcHJlc2VudGF0aW9uIG9uIHRoZSBzZXJ2ZXIgLS0gaWYgeW91J3JlXG4gICAgLy8gdXNpbmcgQmFja2JvbmUncyByZXN0ZnVsIG1ldGhvZHMsIG92ZXJyaWRlIHRoaXMgdG8gY2hhbmdlIHRoZSBlbmRwb2ludFxuICAgIC8vIHRoYXQgd2lsbCBiZSBjYWxsZWQuXG4gICAgdXJsOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBiYXNlID1cbiAgICAgICAgXy5yZXN1bHQodGhpcywgJ3VybFJvb3QnKSB8fFxuICAgICAgICBfLnJlc3VsdCh0aGlzLmNvbGxlY3Rpb24sICd1cmwnKSB8fFxuICAgICAgICB1cmxFcnJvcigpO1xuICAgICAgaWYgKHRoaXMuaXNOZXcoKSkgcmV0dXJuIGJhc2U7XG4gICAgICByZXR1cm4gYmFzZS5yZXBsYWNlKC8oW15cXC9dKSQvLCAnJDEvJykgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5pZCk7XG4gICAgfSxcblxuICAgIC8vICoqcGFyc2UqKiBjb252ZXJ0cyBhIHJlc3BvbnNlIGludG8gdGhlIGhhc2ggb2YgYXR0cmlidXRlcyB0byBiZSBgc2V0YCBvblxuICAgIC8vIHRoZSBtb2RlbC4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaXMganVzdCB0byBwYXNzIHRoZSByZXNwb25zZSBhbG9uZy5cbiAgICBwYXJzZTogZnVuY3Rpb24ocmVzcCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHJlc3A7XG4gICAgfSxcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBtb2RlbCB3aXRoIGlkZW50aWNhbCBhdHRyaWJ1dGVzIHRvIHRoaXMgb25lLlxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLmF0dHJpYnV0ZXMpO1xuICAgIH0sXG5cbiAgICAvLyBBIG1vZGVsIGlzIG5ldyBpZiBpdCBoYXMgbmV2ZXIgYmVlbiBzYXZlZCB0byB0aGUgc2VydmVyLCBhbmQgbGFja3MgYW4gaWQuXG4gICAgaXNOZXc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICF0aGlzLmhhcyh0aGlzLmlkQXR0cmlidXRlKTtcbiAgICB9LFxuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIG1vZGVsIGlzIGN1cnJlbnRseSBpbiBhIHZhbGlkIHN0YXRlLlxuICAgIGlzVmFsaWQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLl92YWxpZGF0ZSh7fSwgXy5leHRlbmQob3B0aW9ucyB8fCB7fSwgeyB2YWxpZGF0ZTogdHJ1ZSB9KSk7XG4gICAgfSxcblxuICAgIC8vIFJ1biB2YWxpZGF0aW9uIGFnYWluc3QgdGhlIG5leHQgY29tcGxldGUgc2V0IG9mIG1vZGVsIGF0dHJpYnV0ZXMsXG4gICAgLy8gcmV0dXJuaW5nIGB0cnVlYCBpZiBhbGwgaXMgd2VsbC4gT3RoZXJ3aXNlLCBmaXJlIGFuIGBcImludmFsaWRcImAgZXZlbnQuXG4gICAgX3ZhbGlkYXRlOiBmdW5jdGlvbihhdHRycywgb3B0aW9ucykge1xuICAgICAgaWYgKCFvcHRpb25zLnZhbGlkYXRlIHx8ICF0aGlzLnZhbGlkYXRlKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGF0dHJzID0gXy5leHRlbmQoe30sIHRoaXMuYXR0cmlidXRlcywgYXR0cnMpO1xuICAgICAgdmFyIGVycm9yID0gdGhpcy52YWxpZGF0aW9uRXJyb3IgPSB0aGlzLnZhbGlkYXRlKGF0dHJzLCBvcHRpb25zKSB8fCBudWxsO1xuICAgICAgaWYgKCFlcnJvcikgcmV0dXJuIHRydWU7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2ludmFsaWQnLCB0aGlzLCBlcnJvciwgXy5leHRlbmQob3B0aW9ucywge3ZhbGlkYXRpb25FcnJvcjogZXJyb3J9KSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIFVuZGVyc2NvcmUgbWV0aG9kcyB0aGF0IHdlIHdhbnQgdG8gaW1wbGVtZW50IG9uIHRoZSBNb2RlbC5cbiAgdmFyIG1vZGVsTWV0aG9kcyA9IFsna2V5cycsICd2YWx1ZXMnLCAncGFpcnMnLCAnaW52ZXJ0JywgJ3BpY2snLCAnb21pdCddO1xuXG4gIC8vIE1peCBpbiBlYWNoIFVuZGVyc2NvcmUgbWV0aG9kIGFzIGEgcHJveHkgdG8gYE1vZGVsI2F0dHJpYnV0ZXNgLlxuICBfLmVhY2gobW9kZWxNZXRob2RzLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgICBNb2RlbC5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICBhcmdzLnVuc2hpZnQodGhpcy5hdHRyaWJ1dGVzKTtcbiAgICAgIHJldHVybiBfW21ldGhvZF0uYXBwbHkoXywgYXJncyk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gQmFja2JvbmUuQ29sbGVjdGlvblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gSWYgbW9kZWxzIHRlbmQgdG8gcmVwcmVzZW50IGEgc2luZ2xlIHJvdyBvZiBkYXRhLCBhIEJhY2tib25lIENvbGxlY3Rpb24gaXNcbiAgLy8gbW9yZSBhbmFsYWdvdXMgdG8gYSB0YWJsZSBmdWxsIG9mIGRhdGEgLi4uIG9yIGEgc21hbGwgc2xpY2Ugb3IgcGFnZSBvZiB0aGF0XG4gIC8vIHRhYmxlLCBvciBhIGNvbGxlY3Rpb24gb2Ygcm93cyB0aGF0IGJlbG9uZyB0b2dldGhlciBmb3IgYSBwYXJ0aWN1bGFyIHJlYXNvblxuICAvLyAtLSBhbGwgb2YgdGhlIG1lc3NhZ2VzIGluIHRoaXMgcGFydGljdWxhciBmb2xkZXIsIGFsbCBvZiB0aGUgZG9jdW1lbnRzXG4gIC8vIGJlbG9uZ2luZyB0byB0aGlzIHBhcnRpY3VsYXIgYXV0aG9yLCBhbmQgc28gb24uIENvbGxlY3Rpb25zIG1haW50YWluXG4gIC8vIGluZGV4ZXMgb2YgdGhlaXIgbW9kZWxzLCBib3RoIGluIG9yZGVyLCBhbmQgZm9yIGxvb2t1cCBieSBgaWRgLlxuXG4gIC8vIENyZWF0ZSBhIG5ldyAqKkNvbGxlY3Rpb24qKiwgcGVyaGFwcyB0byBjb250YWluIGEgc3BlY2lmaWMgdHlwZSBvZiBgbW9kZWxgLlxuICAvLyBJZiBhIGBjb21wYXJhdG9yYCBpcyBzcGVjaWZpZWQsIHRoZSBDb2xsZWN0aW9uIHdpbGwgbWFpbnRhaW5cbiAgLy8gaXRzIG1vZGVscyBpbiBzb3J0IG9yZGVyLCBhcyB0aGV5J3JlIGFkZGVkIGFuZCByZW1vdmVkLlxuICB2YXIgQ29sbGVjdGlvbiA9IEJhY2tib25lLkNvbGxlY3Rpb24gPSBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgIGlmIChvcHRpb25zLm1vZGVsKSB0aGlzLm1vZGVsID0gb3B0aW9ucy5tb2RlbDtcbiAgICBpZiAob3B0aW9ucy5jb21wYXJhdG9yICE9PSB2b2lkIDApIHRoaXMuY29tcGFyYXRvciA9IG9wdGlvbnMuY29tcGFyYXRvcjtcbiAgICB0aGlzLl9yZXNldCgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChtb2RlbHMpIHRoaXMucmVzZXQobW9kZWxzLCBfLmV4dGVuZCh7c2lsZW50OiB0cnVlfSwgb3B0aW9ucykpO1xuICB9O1xuXG4gIC8vIERlZmF1bHQgb3B0aW9ucyBmb3IgYENvbGxlY3Rpb24jc2V0YC5cbiAgdmFyIHNldE9wdGlvbnMgPSB7YWRkOiB0cnVlLCByZW1vdmU6IHRydWUsIG1lcmdlOiB0cnVlfTtcbiAgdmFyIGFkZE9wdGlvbnMgPSB7YWRkOiB0cnVlLCByZW1vdmU6IGZhbHNlfTtcblxuICAvLyBEZWZpbmUgdGhlIENvbGxlY3Rpb24ncyBpbmhlcml0YWJsZSBtZXRob2RzLlxuICBfLmV4dGVuZChDb2xsZWN0aW9uLnByb3RvdHlwZSwgRXZlbnRzLCB7XG5cbiAgICAvLyBUaGUgZGVmYXVsdCBtb2RlbCBmb3IgYSBjb2xsZWN0aW9uIGlzIGp1c3QgYSAqKkJhY2tib25lLk1vZGVsKiouXG4gICAgLy8gVGhpcyBzaG91bGQgYmUgb3ZlcnJpZGRlbiBpbiBtb3N0IGNhc2VzLlxuICAgIG1vZGVsOiBNb2RlbCxcblxuICAgIC8vIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7fSxcblxuICAgIC8vIFRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgQ29sbGVjdGlvbiBpcyBhbiBhcnJheSBvZiB0aGVcbiAgICAvLyBtb2RlbHMnIGF0dHJpYnV0ZXMuXG4gICAgdG9KU09OOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24obW9kZWwpeyByZXR1cm4gbW9kZWwudG9KU09OKG9wdGlvbnMpOyB9KTtcbiAgICB9LFxuXG4gICAgLy8gUHJveHkgYEJhY2tib25lLnN5bmNgIGJ5IGRlZmF1bHQuXG4gICAgc3luYzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQmFja2JvbmUuc3luYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBtb2RlbCwgb3IgbGlzdCBvZiBtb2RlbHMgdG8gdGhlIHNldC5cbiAgICBhZGQ6IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KG1vZGVscywgXy5leHRlbmQoe21lcmdlOiBmYWxzZX0sIG9wdGlvbnMsIGFkZE9wdGlvbnMpKTtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGEgbW9kZWwsIG9yIGEgbGlzdCBvZiBtb2RlbHMgZnJvbSB0aGUgc2V0LlxuICAgIHJlbW92ZTogZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgICB2YXIgc2luZ3VsYXIgPSAhXy5pc0FycmF5KG1vZGVscyk7XG4gICAgICBtb2RlbHMgPSBzaW5ndWxhciA/IFttb2RlbHNdIDogXy5jbG9uZShtb2RlbHMpO1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICAgIHZhciBpLCBsLCBpbmRleCwgbW9kZWw7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gbW9kZWxzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBtb2RlbCA9IG1vZGVsc1tpXSA9IHRoaXMuZ2V0KG1vZGVsc1tpXSk7XG4gICAgICAgIGlmICghbW9kZWwpIGNvbnRpbnVlO1xuICAgICAgICBkZWxldGUgdGhpcy5fYnlJZFttb2RlbC5pZF07XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ieUlkW21vZGVsLmNpZF07XG4gICAgICAgIGluZGV4ID0gdGhpcy5pbmRleE9mKG1vZGVsKTtcbiAgICAgICAgdGhpcy5tb2RlbHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICAgICAgaWYgKCFvcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgIG9wdGlvbnMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICBtb2RlbC50cmlnZ2VyKCdyZW1vdmUnLCBtb2RlbCwgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVtb3ZlUmVmZXJlbmNlKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzaW5ndWxhciA/IG1vZGVsc1swXSA6IG1vZGVscztcbiAgICB9LFxuXG4gICAgLy8gVXBkYXRlIGEgY29sbGVjdGlvbiBieSBgc2V0YC1pbmcgYSBuZXcgbGlzdCBvZiBtb2RlbHMsIGFkZGluZyBuZXcgb25lcyxcbiAgICAvLyByZW1vdmluZyBtb2RlbHMgdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnQsIGFuZCBtZXJnaW5nIG1vZGVscyB0aGF0XG4gICAgLy8gYWxyZWFkeSBleGlzdCBpbiB0aGUgY29sbGVjdGlvbiwgYXMgbmVjZXNzYXJ5LiBTaW1pbGFyIHRvICoqTW9kZWwjc2V0KiosXG4gICAgLy8gdGhlIGNvcmUgb3BlcmF0aW9uIGZvciB1cGRhdGluZyB0aGUgZGF0YSBjb250YWluZWQgYnkgdGhlIGNvbGxlY3Rpb24uXG4gICAgc2V0OiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBfLmRlZmF1bHRzKHt9LCBvcHRpb25zLCBzZXRPcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLnBhcnNlKSBtb2RlbHMgPSB0aGlzLnBhcnNlKG1vZGVscywgb3B0aW9ucyk7XG4gICAgICB2YXIgc2luZ3VsYXIgPSAhXy5pc0FycmF5KG1vZGVscyk7XG4gICAgICBtb2RlbHMgPSBzaW5ndWxhciA/IChtb2RlbHMgPyBbbW9kZWxzXSA6IFtdKSA6IF8uY2xvbmUobW9kZWxzKTtcbiAgICAgIHZhciBpLCBsLCBpZCwgbW9kZWwsIGF0dHJzLCBleGlzdGluZywgc29ydDtcbiAgICAgIHZhciBhdCA9IG9wdGlvbnMuYXQ7XG4gICAgICB2YXIgdGFyZ2V0TW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgdmFyIHNvcnRhYmxlID0gdGhpcy5jb21wYXJhdG9yICYmIChhdCA9PSBudWxsKSAmJiBvcHRpb25zLnNvcnQgIT09IGZhbHNlO1xuICAgICAgdmFyIHNvcnRBdHRyID0gXy5pc1N0cmluZyh0aGlzLmNvbXBhcmF0b3IpID8gdGhpcy5jb21wYXJhdG9yIDogbnVsbDtcbiAgICAgIHZhciB0b0FkZCA9IFtdLCB0b1JlbW92ZSA9IFtdLCBtb2RlbE1hcCA9IHt9O1xuICAgICAgdmFyIGFkZCA9IG9wdGlvbnMuYWRkLCBtZXJnZSA9IG9wdGlvbnMubWVyZ2UsIHJlbW92ZSA9IG9wdGlvbnMucmVtb3ZlO1xuICAgICAgdmFyIG9yZGVyID0gIXNvcnRhYmxlICYmIGFkZCAmJiByZW1vdmUgPyBbXSA6IGZhbHNlO1xuXG4gICAgICAvLyBUdXJuIGJhcmUgb2JqZWN0cyBpbnRvIG1vZGVsIHJlZmVyZW5jZXMsIGFuZCBwcmV2ZW50IGludmFsaWQgbW9kZWxzXG4gICAgICAvLyBmcm9tIGJlaW5nIGFkZGVkLlxuICAgICAgZm9yIChpID0gMCwgbCA9IG1vZGVscy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgYXR0cnMgPSBtb2RlbHNbaV0gfHwge307XG4gICAgICAgIGlmIChhdHRycyBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgICAgICAgaWQgPSBtb2RlbCA9IGF0dHJzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlkID0gYXR0cnNbdGFyZ2V0TW9kZWwucHJvdG90eXBlLmlkQXR0cmlidXRlIHx8ICdpZCddO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgYSBkdXBsaWNhdGUgaXMgZm91bmQsIHByZXZlbnQgaXQgZnJvbSBiZWluZyBhZGRlZCBhbmRcbiAgICAgICAgLy8gb3B0aW9uYWxseSBtZXJnZSBpdCBpbnRvIHRoZSBleGlzdGluZyBtb2RlbC5cbiAgICAgICAgaWYgKGV4aXN0aW5nID0gdGhpcy5nZXQoaWQpKSB7XG4gICAgICAgICAgaWYgKHJlbW92ZSkgbW9kZWxNYXBbZXhpc3RpbmcuY2lkXSA9IHRydWU7XG4gICAgICAgICAgaWYgKG1lcmdlKSB7XG4gICAgICAgICAgICBhdHRycyA9IGF0dHJzID09PSBtb2RlbCA/IG1vZGVsLmF0dHJpYnV0ZXMgOiBhdHRycztcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBhcnNlKSBhdHRycyA9IGV4aXN0aW5nLnBhcnNlKGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGV4aXN0aW5nLnNldChhdHRycywgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoc29ydGFibGUgJiYgIXNvcnQgJiYgZXhpc3RpbmcuaGFzQ2hhbmdlZChzb3J0QXR0cikpIHNvcnQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb2RlbHNbaV0gPSBleGlzdGluZztcblxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgbmV3LCB2YWxpZCBtb2RlbCwgcHVzaCBpdCB0byB0aGUgYHRvQWRkYCBsaXN0LlxuICAgICAgICB9IGVsc2UgaWYgKGFkZCkge1xuICAgICAgICAgIG1vZGVsID0gbW9kZWxzW2ldID0gdGhpcy5fcHJlcGFyZU1vZGVsKGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgICBpZiAoIW1vZGVsKSBjb250aW51ZTtcbiAgICAgICAgICB0b0FkZC5wdXNoKG1vZGVsKTtcbiAgICAgICAgICB0aGlzLl9hZGRSZWZlcmVuY2UobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG8gbm90IGFkZCBtdWx0aXBsZSBtb2RlbHMgd2l0aCB0aGUgc2FtZSBgaWRgLlxuICAgICAgICBtb2RlbCA9IGV4aXN0aW5nIHx8IG1vZGVsO1xuICAgICAgICBpZiAob3JkZXIgJiYgKG1vZGVsLmlzTmV3KCkgfHwgIW1vZGVsTWFwW21vZGVsLmlkXSkpIG9yZGVyLnB1c2gobW9kZWwpO1xuICAgICAgICBtb2RlbE1hcFttb2RlbC5pZF0gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgbm9uZXhpc3RlbnQgbW9kZWxzIGlmIGFwcHJvcHJpYXRlLlxuICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICBpZiAoIW1vZGVsTWFwWyhtb2RlbCA9IHRoaXMubW9kZWxzW2ldKS5jaWRdKSB0b1JlbW92ZS5wdXNoKG1vZGVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9SZW1vdmUubGVuZ3RoKSB0aGlzLnJlbW92ZSh0b1JlbW92ZSwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNlZSBpZiBzb3J0aW5nIGlzIG5lZWRlZCwgdXBkYXRlIGBsZW5ndGhgIGFuZCBzcGxpY2UgaW4gbmV3IG1vZGVscy5cbiAgICAgIGlmICh0b0FkZC5sZW5ndGggfHwgKG9yZGVyICYmIG9yZGVyLmxlbmd0aCkpIHtcbiAgICAgICAgaWYgKHNvcnRhYmxlKSBzb3J0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sZW5ndGggKz0gdG9BZGQubGVuZ3RoO1xuICAgICAgICBpZiAoYXQgIT0gbnVsbCkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0b0FkZC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMubW9kZWxzLnNwbGljZShhdCArIGksIDAsIHRvQWRkW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG9yZGVyKSB0aGlzLm1vZGVscy5sZW5ndGggPSAwO1xuICAgICAgICAgIHZhciBvcmRlcmVkTW9kZWxzID0gb3JkZXIgfHwgdG9BZGQ7XG4gICAgICAgICAgZm9yIChpID0gMCwgbCA9IG9yZGVyZWRNb2RlbHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVscy5wdXNoKG9yZGVyZWRNb2RlbHNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBTaWxlbnRseSBzb3J0IHRoZSBjb2xsZWN0aW9uIGlmIGFwcHJvcHJpYXRlLlxuICAgICAgaWYgKHNvcnQpIHRoaXMuc29ydCh7c2lsZW50OiB0cnVlfSk7XG5cbiAgICAgIC8vIFVubGVzcyBzaWxlbmNlZCwgaXQncyB0aW1lIHRvIGZpcmUgYWxsIGFwcHJvcHJpYXRlIGFkZC9zb3J0IGV2ZW50cy5cbiAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IHRvQWRkLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIChtb2RlbCA9IHRvQWRkW2ldKS50cmlnZ2VyKCdhZGQnLCBtb2RlbCwgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvcnQgfHwgKG9yZGVyICYmIG9yZGVyLmxlbmd0aCkpIHRoaXMudHJpZ2dlcignc29ydCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gdGhlIGFkZGVkIChvciBtZXJnZWQpIG1vZGVsIChvciBtb2RlbHMpLlxuICAgICAgcmV0dXJuIHNpbmd1bGFyID8gbW9kZWxzWzBdIDogbW9kZWxzO1xuICAgIH0sXG5cbiAgICAvLyBXaGVuIHlvdSBoYXZlIG1vcmUgaXRlbXMgdGhhbiB5b3Ugd2FudCB0byBhZGQgb3IgcmVtb3ZlIGluZGl2aWR1YWxseSxcbiAgICAvLyB5b3UgY2FuIHJlc2V0IHRoZSBlbnRpcmUgc2V0IHdpdGggYSBuZXcgbGlzdCBvZiBtb2RlbHMsIHdpdGhvdXQgZmlyaW5nXG4gICAgLy8gYW55IGdyYW51bGFyIGBhZGRgIG9yIGByZW1vdmVgIGV2ZW50cy4gRmlyZXMgYHJlc2V0YCB3aGVuIGZpbmlzaGVkLlxuICAgIC8vIFVzZWZ1bCBmb3IgYnVsayBvcGVyYXRpb25zIGFuZCBvcHRpbWl6YXRpb25zLlxuICAgIHJlc2V0OiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubW9kZWxzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLl9yZW1vdmVSZWZlcmVuY2UodGhpcy5tb2RlbHNbaV0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy5wcmV2aW91c01vZGVscyA9IHRoaXMubW9kZWxzO1xuICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgIG1vZGVscyA9IHRoaXMuYWRkKG1vZGVscywgXy5leHRlbmQoe3NpbGVudDogdHJ1ZX0sIG9wdGlvbnMpKTtcbiAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHRoaXMudHJpZ2dlcigncmVzZXQnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBtb2RlbHM7XG4gICAgfSxcblxuICAgIC8vIEFkZCBhIG1vZGVsIHRvIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgcHVzaDogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZChtb2RlbCwgXy5leHRlbmQoe2F0OiB0aGlzLmxlbmd0aH0sIG9wdGlvbnMpKTtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGEgbW9kZWwgZnJvbSB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgIHBvcDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIG1vZGVsID0gdGhpcy5hdCh0aGlzLmxlbmd0aCAtIDEpO1xuICAgICAgdGhpcy5yZW1vdmUobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIG1vZGVsO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBtb2RlbCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgIHVuc2hpZnQ6IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGQobW9kZWwsIF8uZXh0ZW5kKHthdDogMH0sIG9wdGlvbnMpKTtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGEgbW9kZWwgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgIHNoaWZ0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgbW9kZWwgPSB0aGlzLmF0KDApO1xuICAgICAgdGhpcy5yZW1vdmUobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIG1vZGVsO1xuICAgIH0sXG5cbiAgICAvLyBTbGljZSBvdXQgYSBzdWItYXJyYXkgb2YgbW9kZWxzIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gICAgc2xpY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNsaWNlLmFwcGx5KHRoaXMubW9kZWxzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgYSBtb2RlbCBmcm9tIHRoZSBzZXQgYnkgaWQuXG4gICAgZ2V0OiBmdW5jdGlvbihvYmopIHtcbiAgICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICAgIHJldHVybiB0aGlzLl9ieUlkW29ial0gfHwgdGhpcy5fYnlJZFtvYmouaWRdIHx8IHRoaXMuX2J5SWRbb2JqLmNpZF07XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgbW9kZWwgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgIGF0OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXMubW9kZWxzW2luZGV4XTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIG1vZGVscyB3aXRoIG1hdGNoaW5nIGF0dHJpYnV0ZXMuIFVzZWZ1bCBmb3Igc2ltcGxlIGNhc2VzIG9mXG4gICAgLy8gYGZpbHRlcmAuXG4gICAgd2hlcmU6IGZ1bmN0aW9uKGF0dHJzLCBmaXJzdCkge1xuICAgICAgaWYgKF8uaXNFbXB0eShhdHRycykpIHJldHVybiBmaXJzdCA/IHZvaWQgMCA6IFtdO1xuICAgICAgcmV0dXJuIHRoaXNbZmlyc3QgPyAnZmluZCcgOiAnZmlsdGVyJ10oZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGF0dHJzKSB7XG4gICAgICAgICAgaWYgKGF0dHJzW2tleV0gIT09IG1vZGVsLmdldChrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIHRoZSBmaXJzdCBtb2RlbCB3aXRoIG1hdGNoaW5nIGF0dHJpYnV0ZXMuIFVzZWZ1bCBmb3Igc2ltcGxlIGNhc2VzXG4gICAgLy8gb2YgYGZpbmRgLlxuICAgIGZpbmRXaGVyZTogZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAgIHJldHVybiB0aGlzLndoZXJlKGF0dHJzLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgLy8gRm9yY2UgdGhlIGNvbGxlY3Rpb24gdG8gcmUtc29ydCBpdHNlbGYuIFlvdSBkb24ndCBuZWVkIHRvIGNhbGwgdGhpcyB1bmRlclxuICAgIC8vIG5vcm1hbCBjaXJjdW1zdGFuY2VzLCBhcyB0aGUgc2V0IHdpbGwgbWFpbnRhaW4gc29ydCBvcmRlciBhcyBlYWNoIGl0ZW1cbiAgICAvLyBpcyBhZGRlZC5cbiAgICBzb3J0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAoIXRoaXMuY29tcGFyYXRvcikgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc29ydCBhIHNldCB3aXRob3V0IGEgY29tcGFyYXRvcicpO1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcblxuICAgICAgLy8gUnVuIHNvcnQgYmFzZWQgb24gdHlwZSBvZiBgY29tcGFyYXRvcmAuXG4gICAgICBpZiAoXy5pc1N0cmluZyh0aGlzLmNvbXBhcmF0b3IpIHx8IHRoaXMuY29tcGFyYXRvci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdGhpcy5tb2RlbHMgPSB0aGlzLnNvcnRCeSh0aGlzLmNvbXBhcmF0b3IsIHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tb2RlbHMuc29ydChfLmJpbmQodGhpcy5jb21wYXJhdG9yLCB0aGlzKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHRoaXMudHJpZ2dlcignc29ydCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFBsdWNrIGFuIGF0dHJpYnV0ZSBmcm9tIGVhY2ggbW9kZWwgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgcGx1Y2s6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIHJldHVybiBfLmludm9rZSh0aGlzLm1vZGVscywgJ2dldCcsIGF0dHIpO1xuICAgIH0sXG5cbiAgICAvLyBGZXRjaCB0aGUgZGVmYXVsdCBzZXQgb2YgbW9kZWxzIGZvciB0aGlzIGNvbGxlY3Rpb24sIHJlc2V0dGluZyB0aGVcbiAgICAvLyBjb2xsZWN0aW9uIHdoZW4gdGhleSBhcnJpdmUuIElmIGByZXNldDogdHJ1ZWAgaXMgcGFzc2VkLCB0aGUgcmVzcG9uc2VcbiAgICAvLyBkYXRhIHdpbGwgYmUgcGFzc2VkIHRocm91Z2ggdGhlIGByZXNldGAgbWV0aG9kIGluc3RlYWQgb2YgYHNldGAuXG4gICAgZmV0Y2g6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgaWYgKG9wdGlvbnMucGFyc2UgPT09IHZvaWQgMCkgb3B0aW9ucy5wYXJzZSA9IHRydWU7XG4gICAgICB2YXIgc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcztcbiAgICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcztcbiAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9wdGlvbnMucmVzZXQgPyAncmVzZXQnIDogJ3NldCc7XG4gICAgICAgIGNvbGxlY3Rpb25bbWV0aG9kXShyZXNwLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHN1Y2Nlc3MoY29sbGVjdGlvbiwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICAgIGNvbGxlY3Rpb24udHJpZ2dlcignc3luYycsIGNvbGxlY3Rpb24sIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgfTtcbiAgICAgIHdyYXBFcnJvcih0aGlzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzLnN5bmMoJ3JlYWQnLCB0aGlzLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIGEgbW9kZWwgaW4gdGhpcyBjb2xsZWN0aW9uLiBBZGQgdGhlIG1vZGVsIHRvIHRoZVxuICAgIC8vIGNvbGxlY3Rpb24gaW1tZWRpYXRlbHksIHVubGVzcyBgd2FpdDogdHJ1ZWAgaXMgcGFzc2VkLCBpbiB3aGljaCBjYXNlIHdlXG4gICAgLy8gd2FpdCBmb3IgdGhlIHNlcnZlciB0byBhZ3JlZS5cbiAgICBjcmVhdGU6IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyA/IF8uY2xvbmUob3B0aW9ucykgOiB7fTtcbiAgICAgIGlmICghKG1vZGVsID0gdGhpcy5fcHJlcGFyZU1vZGVsKG1vZGVsLCBvcHRpb25zKSkpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICghb3B0aW9ucy53YWl0KSB0aGlzLmFkZChtb2RlbCwgb3B0aW9ucyk7XG4gICAgICB2YXIgY29sbGVjdGlvbiA9IHRoaXM7XG4gICAgICB2YXIgc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcztcbiAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKG1vZGVsLCByZXNwKSB7XG4gICAgICAgIGlmIChvcHRpb25zLndhaXQpIGNvbGxlY3Rpb24uYWRkKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHN1Y2Nlc3MobW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgfTtcbiAgICAgIG1vZGVsLnNhdmUobnVsbCwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gbW9kZWw7XG4gICAgfSxcblxuICAgIC8vICoqcGFyc2UqKiBjb252ZXJ0cyBhIHJlc3BvbnNlIGludG8gYSBsaXN0IG9mIG1vZGVscyB0byBiZSBhZGRlZCB0byB0aGVcbiAgICAvLyBjb2xsZWN0aW9uLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBpcyBqdXN0IHRvIHBhc3MgaXQgdGhyb3VnaC5cbiAgICBwYXJzZTogZnVuY3Rpb24ocmVzcCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHJlc3A7XG4gICAgfSxcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBjb2xsZWN0aW9uIHdpdGggYW4gaWRlbnRpY2FsIGxpc3Qgb2YgbW9kZWxzIGFzIHRoaXMgb25lLlxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLm1vZGVscyk7XG4gICAgfSxcblxuICAgIC8vIFByaXZhdGUgbWV0aG9kIHRvIHJlc2V0IGFsbCBpbnRlcm5hbCBzdGF0ZS4gQ2FsbGVkIHdoZW4gdGhlIGNvbGxlY3Rpb25cbiAgICAvLyBpcyBmaXJzdCBpbml0aWFsaXplZCBvciByZXNldC5cbiAgICBfcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5tb2RlbHMgPSBbXTtcbiAgICAgIHRoaXMuX2J5SWQgID0ge307XG4gICAgfSxcblxuICAgIC8vIFByZXBhcmUgYSBoYXNoIG9mIGF0dHJpYnV0ZXMgKG9yIG90aGVyIG1vZGVsKSB0byBiZSBhZGRlZCB0byB0aGlzXG4gICAgLy8gY29sbGVjdGlvbi5cbiAgICBfcHJlcGFyZU1vZGVsOiBmdW5jdGlvbihhdHRycywgb3B0aW9ucykge1xuICAgICAgaWYgKGF0dHJzIGluc3RhbmNlb2YgTW9kZWwpIHJldHVybiBhdHRycztcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgb3B0aW9ucy5jb2xsZWN0aW9uID0gdGhpcztcbiAgICAgIHZhciBtb2RlbCA9IG5ldyB0aGlzLm1vZGVsKGF0dHJzLCBvcHRpb25zKTtcbiAgICAgIGlmICghbW9kZWwudmFsaWRhdGlvbkVycm9yKSByZXR1cm4gbW9kZWw7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2ludmFsaWQnLCB0aGlzLCBtb2RlbC52YWxpZGF0aW9uRXJyb3IsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgdG8gY3JlYXRlIGEgbW9kZWwncyB0aWVzIHRvIGEgY29sbGVjdGlvbi5cbiAgICBfYWRkUmVmZXJlbmNlOiBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgICAgdGhpcy5fYnlJZFttb2RlbC5jaWRdID0gbW9kZWw7XG4gICAgICBpZiAobW9kZWwuaWQgIT0gbnVsbCkgdGhpcy5fYnlJZFttb2RlbC5pZF0gPSBtb2RlbDtcbiAgICAgIGlmICghbW9kZWwuY29sbGVjdGlvbikgbW9kZWwuY29sbGVjdGlvbiA9IHRoaXM7XG4gICAgICBtb2RlbC5vbignYWxsJywgdGhpcy5fb25Nb2RlbEV2ZW50LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIHNldmVyIGEgbW9kZWwncyB0aWVzIHRvIGEgY29sbGVjdGlvbi5cbiAgICBfcmVtb3ZlUmVmZXJlbmNlOiBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMgPT09IG1vZGVsLmNvbGxlY3Rpb24pIGRlbGV0ZSBtb2RlbC5jb2xsZWN0aW9uO1xuICAgICAgbW9kZWwub2ZmKCdhbGwnLCB0aGlzLl9vbk1vZGVsRXZlbnQsIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgY2FsbGVkIGV2ZXJ5IHRpbWUgYSBtb2RlbCBpbiB0aGUgc2V0IGZpcmVzIGFuIGV2ZW50LlxuICAgIC8vIFNldHMgbmVlZCB0byB1cGRhdGUgdGhlaXIgaW5kZXhlcyB3aGVuIG1vZGVscyBjaGFuZ2UgaWRzLiBBbGwgb3RoZXJcbiAgICAvLyBldmVudHMgc2ltcGx5IHByb3h5IHRocm91Z2guIFwiYWRkXCIgYW5kIFwicmVtb3ZlXCIgZXZlbnRzIHRoYXQgb3JpZ2luYXRlXG4gICAgLy8gaW4gb3RoZXIgY29sbGVjdGlvbnMgYXJlIGlnbm9yZWQuXG4gICAgX29uTW9kZWxFdmVudDogZnVuY3Rpb24oZXZlbnQsIG1vZGVsLCBjb2xsZWN0aW9uLCBvcHRpb25zKSB7XG4gICAgICBpZiAoKGV2ZW50ID09PSAnYWRkJyB8fCBldmVudCA9PT0gJ3JlbW92ZScpICYmIGNvbGxlY3Rpb24gIT09IHRoaXMpIHJldHVybjtcbiAgICAgIGlmIChldmVudCA9PT0gJ2Rlc3Ryb3knKSB0aGlzLnJlbW92ZShtb2RlbCwgb3B0aW9ucyk7XG4gICAgICBpZiAobW9kZWwgJiYgZXZlbnQgPT09ICdjaGFuZ2U6JyArIG1vZGVsLmlkQXR0cmlidXRlKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ieUlkW21vZGVsLnByZXZpb3VzKG1vZGVsLmlkQXR0cmlidXRlKV07XG4gICAgICAgIGlmIChtb2RlbC5pZCAhPSBudWxsKSB0aGlzLl9ieUlkW21vZGVsLmlkXSA9IG1vZGVsO1xuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIFVuZGVyc2NvcmUgbWV0aG9kcyB0aGF0IHdlIHdhbnQgdG8gaW1wbGVtZW50IG9uIHRoZSBDb2xsZWN0aW9uLlxuICAvLyA5MCUgb2YgdGhlIGNvcmUgdXNlZnVsbmVzcyBvZiBCYWNrYm9uZSBDb2xsZWN0aW9ucyBpcyBhY3R1YWxseSBpbXBsZW1lbnRlZFxuICAvLyByaWdodCBoZXJlOlxuICB2YXIgbWV0aG9kcyA9IFsnZm9yRWFjaCcsICdlYWNoJywgJ21hcCcsICdjb2xsZWN0JywgJ3JlZHVjZScsICdmb2xkbCcsXG4gICAgJ2luamVjdCcsICdyZWR1Y2VSaWdodCcsICdmb2xkcicsICdmaW5kJywgJ2RldGVjdCcsICdmaWx0ZXInLCAnc2VsZWN0JyxcbiAgICAncmVqZWN0JywgJ2V2ZXJ5JywgJ2FsbCcsICdzb21lJywgJ2FueScsICdpbmNsdWRlJywgJ2NvbnRhaW5zJywgJ2ludm9rZScsXG4gICAgJ21heCcsICdtaW4nLCAndG9BcnJheScsICdzaXplJywgJ2ZpcnN0JywgJ2hlYWQnLCAndGFrZScsICdpbml0aWFsJywgJ3Jlc3QnLFxuICAgICd0YWlsJywgJ2Ryb3AnLCAnbGFzdCcsICd3aXRob3V0JywgJ2RpZmZlcmVuY2UnLCAnaW5kZXhPZicsICdzaHVmZmxlJyxcbiAgICAnbGFzdEluZGV4T2YnLCAnaXNFbXB0eScsICdjaGFpbicsICdzYW1wbGUnXTtcblxuICAvLyBNaXggaW4gZWFjaCBVbmRlcnNjb3JlIG1ldGhvZCBhcyBhIHByb3h5IHRvIGBDb2xsZWN0aW9uI21vZGVsc2AuXG4gIF8uZWFjaChtZXRob2RzLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIGFyZ3MudW5zaGlmdCh0aGlzLm1vZGVscyk7XG4gICAgICByZXR1cm4gX1ttZXRob2RdLmFwcGx5KF8sIGFyZ3MpO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIFVuZGVyc2NvcmUgbWV0aG9kcyB0aGF0IHRha2UgYSBwcm9wZXJ0eSBuYW1lIGFzIGFuIGFyZ3VtZW50LlxuICB2YXIgYXR0cmlidXRlTWV0aG9kcyA9IFsnZ3JvdXBCeScsICdjb3VudEJ5JywgJ3NvcnRCeScsICdpbmRleEJ5J107XG5cbiAgLy8gVXNlIGF0dHJpYnV0ZXMgaW5zdGVhZCBvZiBwcm9wZXJ0aWVzLlxuICBfLmVhY2goYXR0cmlidXRlTWV0aG9kcywgZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgQ29sbGVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUgOiBmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICByZXR1cm4gbW9kZWwuZ2V0KHZhbHVlKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX1ttZXRob2RdKHRoaXMubW9kZWxzLCBpdGVyYXRvciwgY29udGV4dCk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gQmFja2JvbmUuVmlld1xuICAvLyAtLS0tLS0tLS0tLS0tXG5cbiAgLy8gQmFja2JvbmUgVmlld3MgYXJlIGFsbW9zdCBtb3JlIGNvbnZlbnRpb24gdGhhbiB0aGV5IGFyZSBhY3R1YWwgY29kZS4gQSBWaWV3XG4gIC8vIGlzIHNpbXBseSBhIEphdmFTY3JpcHQgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhIGxvZ2ljYWwgY2h1bmsgb2YgVUkgaW4gdGhlXG4gIC8vIERPTS4gVGhpcyBtaWdodCBiZSBhIHNpbmdsZSBpdGVtLCBhbiBlbnRpcmUgbGlzdCwgYSBzaWRlYmFyIG9yIHBhbmVsLCBvclxuICAvLyBldmVuIHRoZSBzdXJyb3VuZGluZyBmcmFtZSB3aGljaCB3cmFwcyB5b3VyIHdob2xlIGFwcC4gRGVmaW5pbmcgYSBjaHVuayBvZlxuICAvLyBVSSBhcyBhICoqVmlldyoqIGFsbG93cyB5b3UgdG8gZGVmaW5lIHlvdXIgRE9NIGV2ZW50cyBkZWNsYXJhdGl2ZWx5LCB3aXRob3V0XG4gIC8vIGhhdmluZyB0byB3b3JyeSBhYm91dCByZW5kZXIgb3JkZXIgLi4uIGFuZCBtYWtlcyBpdCBlYXN5IGZvciB0aGUgdmlldyB0b1xuICAvLyByZWFjdCB0byBzcGVjaWZpYyBjaGFuZ2VzIGluIHRoZSBzdGF0ZSBvZiB5b3VyIG1vZGVscy5cblxuICAvLyBDcmVhdGluZyBhIEJhY2tib25lLlZpZXcgY3JlYXRlcyBpdHMgaW5pdGlhbCBlbGVtZW50IG91dHNpZGUgb2YgdGhlIERPTSxcbiAgLy8gaWYgYW4gZXhpc3RpbmcgZWxlbWVudCBpcyBub3QgcHJvdmlkZWQuLi5cbiAgdmFyIFZpZXcgPSBCYWNrYm9uZS5WaWV3ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuY2lkID0gXy51bmlxdWVJZCgndmlldycpO1xuICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgXy5leHRlbmQodGhpcywgXy5waWNrKG9wdGlvbnMsIHZpZXdPcHRpb25zKSk7XG4gICAgdGhpcy5fZW5zdXJlRWxlbWVudCgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMuZGVsZWdhdGVFdmVudHMoKTtcbiAgfTtcblxuICAvLyBDYWNoZWQgcmVnZXggdG8gc3BsaXQga2V5cyBmb3IgYGRlbGVnYXRlYC5cbiAgdmFyIGRlbGVnYXRlRXZlbnRTcGxpdHRlciA9IC9eKFxcUyspXFxzKiguKikkLztcblxuICAvLyBMaXN0IG9mIHZpZXcgb3B0aW9ucyB0byBiZSBtZXJnZWQgYXMgcHJvcGVydGllcy5cbiAgdmFyIHZpZXdPcHRpb25zID0gWydtb2RlbCcsICdjb2xsZWN0aW9uJywgJ2VsJywgJ2lkJywgJ2F0dHJpYnV0ZXMnLCAnY2xhc3NOYW1lJywgJ3RhZ05hbWUnLCAnZXZlbnRzJ107XG5cbiAgLy8gU2V0IHVwIGFsbCBpbmhlcml0YWJsZSAqKkJhY2tib25lLlZpZXcqKiBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzLlxuICBfLmV4dGVuZChWaWV3LnByb3RvdHlwZSwgRXZlbnRzLCB7XG5cbiAgICAvLyBUaGUgZGVmYXVsdCBgdGFnTmFtZWAgb2YgYSBWaWV3J3MgZWxlbWVudCBpcyBgXCJkaXZcImAuXG4gICAgdGFnTmFtZTogJ2RpdicsXG5cbiAgICAvLyBqUXVlcnkgZGVsZWdhdGUgZm9yIGVsZW1lbnQgbG9va3VwLCBzY29wZWQgdG8gRE9NIGVsZW1lbnRzIHdpdGhpbiB0aGVcbiAgICAvLyBjdXJyZW50IHZpZXcuIFRoaXMgc2hvdWxkIGJlIHByZWZlcnJlZCB0byBnbG9iYWwgbG9va3VwcyB3aGVyZSBwb3NzaWJsZS5cbiAgICAkOiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIHRoaXMuJGVsLmZpbmQoc2VsZWN0b3IpO1xuICAgIH0sXG5cbiAgICAvLyBJbml0aWFsaXplIGlzIGFuIGVtcHR5IGZ1bmN0aW9uIGJ5IGRlZmF1bHQuIE92ZXJyaWRlIGl0IHdpdGggeW91ciBvd25cbiAgICAvLyBpbml0aWFsaXphdGlvbiBsb2dpYy5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpe30sXG5cbiAgICAvLyAqKnJlbmRlcioqIGlzIHRoZSBjb3JlIGZ1bmN0aW9uIHRoYXQgeW91ciB2aWV3IHNob3VsZCBvdmVycmlkZSwgaW4gb3JkZXJcbiAgICAvLyB0byBwb3B1bGF0ZSBpdHMgZWxlbWVudCAoYHRoaXMuZWxgKSwgd2l0aCB0aGUgYXBwcm9wcmlhdGUgSFRNTC4gVGhlXG4gICAgLy8gY29udmVudGlvbiBpcyBmb3IgKipyZW5kZXIqKiB0byBhbHdheXMgcmV0dXJuIGB0aGlzYC5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSB0aGlzIHZpZXcgYnkgdGFraW5nIHRoZSBlbGVtZW50IG91dCBvZiB0aGUgRE9NLCBhbmQgcmVtb3ZpbmcgYW55XG4gICAgLy8gYXBwbGljYWJsZSBCYWNrYm9uZS5FdmVudHMgbGlzdGVuZXJzLlxuICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLiRlbC5yZW1vdmUoKTtcbiAgICAgIHRoaXMuc3RvcExpc3RlbmluZygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIENoYW5nZSB0aGUgdmlldydzIGVsZW1lbnQgKGB0aGlzLmVsYCBwcm9wZXJ0eSksIGluY2x1ZGluZyBldmVudFxuICAgIC8vIHJlLWRlbGVnYXRpb24uXG4gICAgc2V0RWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCwgZGVsZWdhdGUpIHtcbiAgICAgIGlmICh0aGlzLiRlbCkgdGhpcy51bmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICB0aGlzLiRlbCA9IGVsZW1lbnQgaW5zdGFuY2VvZiBCYWNrYm9uZS4kID8gZWxlbWVudCA6IEJhY2tib25lLiQoZWxlbWVudCk7XG4gICAgICB0aGlzLmVsID0gdGhpcy4kZWxbMF07XG4gICAgICBpZiAoZGVsZWdhdGUgIT09IGZhbHNlKSB0aGlzLmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gU2V0IGNhbGxiYWNrcywgd2hlcmUgYHRoaXMuZXZlbnRzYCBpcyBhIGhhc2ggb2ZcbiAgICAvL1xuICAgIC8vICp7XCJldmVudCBzZWxlY3RvclwiOiBcImNhbGxiYWNrXCJ9KlxuICAgIC8vXG4gICAgLy8gICAgIHtcbiAgICAvLyAgICAgICAnbW91c2Vkb3duIC50aXRsZSc6ICAnZWRpdCcsXG4gICAgLy8gICAgICAgJ2NsaWNrIC5idXR0b24nOiAgICAgJ3NhdmUnLFxuICAgIC8vICAgICAgICdjbGljayAub3Blbic6ICAgICAgIGZ1bmN0aW9uKGUpIHsgLi4uIH1cbiAgICAvLyAgICAgfVxuICAgIC8vXG4gICAgLy8gcGFpcnMuIENhbGxiYWNrcyB3aWxsIGJlIGJvdW5kIHRvIHRoZSB2aWV3LCB3aXRoIGB0aGlzYCBzZXQgcHJvcGVybHkuXG4gICAgLy8gVXNlcyBldmVudCBkZWxlZ2F0aW9uIGZvciBlZmZpY2llbmN5LlxuICAgIC8vIE9taXR0aW5nIHRoZSBzZWxlY3RvciBiaW5kcyB0aGUgZXZlbnQgdG8gYHRoaXMuZWxgLlxuICAgIC8vIFRoaXMgb25seSB3b3JrcyBmb3IgZGVsZWdhdGUtYWJsZSBldmVudHM6IG5vdCBgZm9jdXNgLCBgYmx1cmAsIGFuZFxuICAgIC8vIG5vdCBgY2hhbmdlYCwgYHN1Ym1pdGAsIGFuZCBgcmVzZXRgIGluIEludGVybmV0IEV4cGxvcmVyLlxuICAgIGRlbGVnYXRlRXZlbnRzOiBmdW5jdGlvbihldmVudHMpIHtcbiAgICAgIGlmICghKGV2ZW50cyB8fCAoZXZlbnRzID0gXy5yZXN1bHQodGhpcywgJ2V2ZW50cycpKSkpIHJldHVybiB0aGlzO1xuICAgICAgdGhpcy51bmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZXZlbnRzKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBldmVudHNba2V5XTtcbiAgICAgICAgaWYgKCFfLmlzRnVuY3Rpb24obWV0aG9kKSkgbWV0aG9kID0gdGhpc1tldmVudHNba2V5XV07XG4gICAgICAgIGlmICghbWV0aG9kKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgbWF0Y2ggPSBrZXkubWF0Y2goZGVsZWdhdGVFdmVudFNwbGl0dGVyKTtcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IG1hdGNoWzFdLCBzZWxlY3RvciA9IG1hdGNoWzJdO1xuICAgICAgICBtZXRob2QgPSBfLmJpbmQobWV0aG9kLCB0aGlzKTtcbiAgICAgICAgZXZlbnROYW1lICs9ICcuZGVsZWdhdGVFdmVudHMnICsgdGhpcy5jaWQ7XG4gICAgICAgIGlmIChzZWxlY3RvciA9PT0gJycpIHtcbiAgICAgICAgICB0aGlzLiRlbC5vbihldmVudE5hbWUsIG1ldGhvZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy4kZWwub24oZXZlbnROYW1lLCBzZWxlY3RvciwgbWV0aG9kKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIENsZWFycyBhbGwgY2FsbGJhY2tzIHByZXZpb3VzbHkgYm91bmQgdG8gdGhlIHZpZXcgd2l0aCBgZGVsZWdhdGVFdmVudHNgLlxuICAgIC8vIFlvdSB1c3VhbGx5IGRvbid0IG5lZWQgdG8gdXNlIHRoaXMsIGJ1dCBtYXkgd2lzaCB0byBpZiB5b3UgaGF2ZSBtdWx0aXBsZVxuICAgIC8vIEJhY2tib25lIHZpZXdzIGF0dGFjaGVkIHRvIHRoZSBzYW1lIERPTSBlbGVtZW50LlxuICAgIHVuZGVsZWdhdGVFdmVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy4kZWwub2ZmKCcuZGVsZWdhdGVFdmVudHMnICsgdGhpcy5jaWQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBWaWV3IGhhcyBhIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgIC8vIElmIGB0aGlzLmVsYCBpcyBhIHN0cmluZywgcGFzcyBpdCB0aHJvdWdoIGAkKClgLCB0YWtlIHRoZSBmaXJzdFxuICAgIC8vIG1hdGNoaW5nIGVsZW1lbnQsIGFuZCByZS1hc3NpZ24gaXQgdG8gYGVsYC4gT3RoZXJ3aXNlLCBjcmVhdGVcbiAgICAvLyBhbiBlbGVtZW50IGZyb20gdGhlIGBpZGAsIGBjbGFzc05hbWVgIGFuZCBgdGFnTmFtZWAgcHJvcGVydGllcy5cbiAgICBfZW5zdXJlRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuZWwpIHtcbiAgICAgICAgdmFyIGF0dHJzID0gXy5leHRlbmQoe30sIF8ucmVzdWx0KHRoaXMsICdhdHRyaWJ1dGVzJykpO1xuICAgICAgICBpZiAodGhpcy5pZCkgYXR0cnMuaWQgPSBfLnJlc3VsdCh0aGlzLCAnaWQnKTtcbiAgICAgICAgaWYgKHRoaXMuY2xhc3NOYW1lKSBhdHRyc1snY2xhc3MnXSA9IF8ucmVzdWx0KHRoaXMsICdjbGFzc05hbWUnKTtcbiAgICAgICAgdmFyICRlbCA9IEJhY2tib25lLiQoJzwnICsgXy5yZXN1bHQodGhpcywgJ3RhZ05hbWUnKSArICc+JykuYXR0cihhdHRycyk7XG4gICAgICAgIHRoaXMuc2V0RWxlbWVudCgkZWwsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0RWxlbWVudChfLnJlc3VsdCh0aGlzLCAnZWwnKSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICB9KTtcblxuICAvLyBCYWNrYm9uZS5zeW5jXG4gIC8vIC0tLS0tLS0tLS0tLS1cblxuICAvLyBPdmVycmlkZSB0aGlzIGZ1bmN0aW9uIHRvIGNoYW5nZSB0aGUgbWFubmVyIGluIHdoaWNoIEJhY2tib25lIHBlcnNpc3RzXG4gIC8vIG1vZGVscyB0byB0aGUgc2VydmVyLiBZb3Ugd2lsbCBiZSBwYXNzZWQgdGhlIHR5cGUgb2YgcmVxdWVzdCwgYW5kIHRoZVxuICAvLyBtb2RlbCBpbiBxdWVzdGlvbi4gQnkgZGVmYXVsdCwgbWFrZXMgYSBSRVNUZnVsIEFqYXggcmVxdWVzdFxuICAvLyB0byB0aGUgbW9kZWwncyBgdXJsKClgLiBTb21lIHBvc3NpYmxlIGN1c3RvbWl6YXRpb25zIGNvdWxkIGJlOlxuICAvL1xuICAvLyAqIFVzZSBgc2V0VGltZW91dGAgdG8gYmF0Y2ggcmFwaWQtZmlyZSB1cGRhdGVzIGludG8gYSBzaW5nbGUgcmVxdWVzdC5cbiAgLy8gKiBTZW5kIHVwIHRoZSBtb2RlbHMgYXMgWE1MIGluc3RlYWQgb2YgSlNPTi5cbiAgLy8gKiBQZXJzaXN0IG1vZGVscyB2aWEgV2ViU29ja2V0cyBpbnN0ZWFkIG9mIEFqYXguXG4gIC8vXG4gIC8vIFR1cm4gb24gYEJhY2tib25lLmVtdWxhdGVIVFRQYCBpbiBvcmRlciB0byBzZW5kIGBQVVRgIGFuZCBgREVMRVRFYCByZXF1ZXN0c1xuICAvLyBhcyBgUE9TVGAsIHdpdGggYSBgX21ldGhvZGAgcGFyYW1ldGVyIGNvbnRhaW5pbmcgdGhlIHRydWUgSFRUUCBtZXRob2QsXG4gIC8vIGFzIHdlbGwgYXMgYWxsIHJlcXVlc3RzIHdpdGggdGhlIGJvZHkgYXMgYGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZGBcbiAgLy8gaW5zdGVhZCBvZiBgYXBwbGljYXRpb24vanNvbmAgd2l0aCB0aGUgbW9kZWwgaW4gYSBwYXJhbSBuYW1lZCBgbW9kZWxgLlxuICAvLyBVc2VmdWwgd2hlbiBpbnRlcmZhY2luZyB3aXRoIHNlcnZlci1zaWRlIGxhbmd1YWdlcyBsaWtlICoqUEhQKiogdGhhdCBtYWtlXG4gIC8vIGl0IGRpZmZpY3VsdCB0byByZWFkIHRoZSBib2R5IG9mIGBQVVRgIHJlcXVlc3RzLlxuICBCYWNrYm9uZS5zeW5jID0gZnVuY3Rpb24obWV0aG9kLCBtb2RlbCwgb3B0aW9ucykge1xuICAgIHZhciB0eXBlID0gbWV0aG9kTWFwW21ldGhvZF07XG5cbiAgICAvLyBEZWZhdWx0IG9wdGlvbnMsIHVubGVzcyBzcGVjaWZpZWQuXG4gICAgXy5kZWZhdWx0cyhvcHRpb25zIHx8IChvcHRpb25zID0ge30pLCB7XG4gICAgICBlbXVsYXRlSFRUUDogQmFja2JvbmUuZW11bGF0ZUhUVFAsXG4gICAgICBlbXVsYXRlSlNPTjogQmFja2JvbmUuZW11bGF0ZUpTT05cbiAgICB9KTtcblxuICAgIC8vIERlZmF1bHQgSlNPTi1yZXF1ZXN0IG9wdGlvbnMuXG4gICAgdmFyIHBhcmFtcyA9IHt0eXBlOiB0eXBlLCBkYXRhVHlwZTogJ2pzb24nfTtcblxuICAgIC8vIEVuc3VyZSB0aGF0IHdlIGhhdmUgYSBVUkwuXG4gICAgaWYgKCFvcHRpb25zLnVybCkge1xuICAgICAgcGFyYW1zLnVybCA9IF8ucmVzdWx0KG1vZGVsLCAndXJsJykgfHwgdXJsRXJyb3IoKTtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgdGhhdCB3ZSBoYXZlIHRoZSBhcHByb3ByaWF0ZSByZXF1ZXN0IGRhdGEuXG4gICAgaWYgKG9wdGlvbnMuZGF0YSA9PSBudWxsICYmIG1vZGVsICYmIChtZXRob2QgPT09ICdjcmVhdGUnIHx8IG1ldGhvZCA9PT0gJ3VwZGF0ZScgfHwgbWV0aG9kID09PSAncGF0Y2gnKSkge1xuICAgICAgcGFyYW1zLmNvbnRlbnRUeXBlID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgcGFyYW1zLmRhdGEgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLmF0dHJzIHx8IG1vZGVsLnRvSlNPTihvcHRpb25zKSk7XG4gICAgfVxuXG4gICAgLy8gRm9yIG9sZGVyIHNlcnZlcnMsIGVtdWxhdGUgSlNPTiBieSBlbmNvZGluZyB0aGUgcmVxdWVzdCBpbnRvIGFuIEhUTUwtZm9ybS5cbiAgICBpZiAob3B0aW9ucy5lbXVsYXRlSlNPTikge1xuICAgICAgcGFyYW1zLmNvbnRlbnRUeXBlID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XG4gICAgICBwYXJhbXMuZGF0YSA9IHBhcmFtcy5kYXRhID8ge21vZGVsOiBwYXJhbXMuZGF0YX0gOiB7fTtcbiAgICB9XG5cbiAgICAvLyBGb3Igb2xkZXIgc2VydmVycywgZW11bGF0ZSBIVFRQIGJ5IG1pbWlja2luZyB0aGUgSFRUUCBtZXRob2Qgd2l0aCBgX21ldGhvZGBcbiAgICAvLyBBbmQgYW4gYFgtSFRUUC1NZXRob2QtT3ZlcnJpZGVgIGhlYWRlci5cbiAgICBpZiAob3B0aW9ucy5lbXVsYXRlSFRUUCAmJiAodHlwZSA9PT0gJ1BVVCcgfHwgdHlwZSA9PT0gJ0RFTEVURScgfHwgdHlwZSA9PT0gJ1BBVENIJykpIHtcbiAgICAgIHBhcmFtcy50eXBlID0gJ1BPU1QnO1xuICAgICAgaWYgKG9wdGlvbnMuZW11bGF0ZUpTT04pIHBhcmFtcy5kYXRhLl9tZXRob2QgPSB0eXBlO1xuICAgICAgdmFyIGJlZm9yZVNlbmQgPSBvcHRpb25zLmJlZm9yZVNlbmQ7XG4gICAgICBvcHRpb25zLmJlZm9yZVNlbmQgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ1gtSFRUUC1NZXRob2QtT3ZlcnJpZGUnLCB0eXBlKTtcbiAgICAgICAgaWYgKGJlZm9yZVNlbmQpIHJldHVybiBiZWZvcmVTZW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIERvbid0IHByb2Nlc3MgZGF0YSBvbiBhIG5vbi1HRVQgcmVxdWVzdC5cbiAgICBpZiAocGFyYW1zLnR5cGUgIT09ICdHRVQnICYmICFvcHRpb25zLmVtdWxhdGVKU09OKSB7XG4gICAgICBwYXJhbXMucHJvY2Vzc0RhdGEgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSdyZSBzZW5kaW5nIGEgYFBBVENIYCByZXF1ZXN0LCBhbmQgd2UncmUgaW4gYW4gb2xkIEludGVybmV0IEV4cGxvcmVyXG4gICAgLy8gdGhhdCBzdGlsbCBoYXMgQWN0aXZlWCBlbmFibGVkIGJ5IGRlZmF1bHQsIG92ZXJyaWRlIGpRdWVyeSB0byB1c2UgdGhhdFxuICAgIC8vIGZvciBYSFIgaW5zdGVhZC4gUmVtb3ZlIHRoaXMgbGluZSB3aGVuIGpRdWVyeSBzdXBwb3J0cyBgUEFUQ0hgIG9uIElFOC5cbiAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdQQVRDSCcgJiYgbm9YaHJQYXRjaCkge1xuICAgICAgcGFyYW1zLnhociA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gTWFrZSB0aGUgcmVxdWVzdCwgYWxsb3dpbmcgdGhlIHVzZXIgdG8gb3ZlcnJpZGUgYW55IEFqYXggb3B0aW9ucy5cbiAgICB2YXIgeGhyID0gb3B0aW9ucy54aHIgPSBCYWNrYm9uZS5hamF4KF8uZXh0ZW5kKHBhcmFtcywgb3B0aW9ucykpO1xuICAgIG1vZGVsLnRyaWdnZXIoJ3JlcXVlc3QnLCBtb2RlbCwgeGhyLCBvcHRpb25zKTtcbiAgICByZXR1cm4geGhyO1xuICB9O1xuXG4gIHZhciBub1hoclBhdGNoID1cbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhIXdpbmRvdy5BY3RpdmVYT2JqZWN0ICYmXG4gICAgICAhKHdpbmRvdy5YTUxIdHRwUmVxdWVzdCAmJiAobmV3IFhNTEh0dHBSZXF1ZXN0KS5kaXNwYXRjaEV2ZW50KTtcblxuICAvLyBNYXAgZnJvbSBDUlVEIHRvIEhUVFAgZm9yIG91ciBkZWZhdWx0IGBCYWNrYm9uZS5zeW5jYCBpbXBsZW1lbnRhdGlvbi5cbiAgdmFyIG1ldGhvZE1hcCA9IHtcbiAgICAnY3JlYXRlJzogJ1BPU1QnLFxuICAgICd1cGRhdGUnOiAnUFVUJyxcbiAgICAncGF0Y2gnOiAgJ1BBVENIJyxcbiAgICAnZGVsZXRlJzogJ0RFTEVURScsXG4gICAgJ3JlYWQnOiAgICdHRVQnXG4gIH07XG5cbiAgLy8gU2V0IHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIGBCYWNrYm9uZS5hamF4YCB0byBwcm94eSB0aHJvdWdoIHRvIGAkYC5cbiAgLy8gT3ZlcnJpZGUgdGhpcyBpZiB5b3UnZCBsaWtlIHRvIHVzZSBhIGRpZmZlcmVudCBsaWJyYXJ5LlxuICBCYWNrYm9uZS5hamF4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEJhY2tib25lLiQuYWpheC5hcHBseShCYWNrYm9uZS4kLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIEJhY2tib25lLlJvdXRlclxuICAvLyAtLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSb3V0ZXJzIG1hcCBmYXV4LVVSTHMgdG8gYWN0aW9ucywgYW5kIGZpcmUgZXZlbnRzIHdoZW4gcm91dGVzIGFyZVxuICAvLyBtYXRjaGVkLiBDcmVhdGluZyBhIG5ldyBvbmUgc2V0cyBpdHMgYHJvdXRlc2AgaGFzaCwgaWYgbm90IHNldCBzdGF0aWNhbGx5LlxuICB2YXIgUm91dGVyID0gQmFja2JvbmUuUm91dGVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgaWYgKG9wdGlvbnMucm91dGVzKSB0aGlzLnJvdXRlcyA9IG9wdGlvbnMucm91dGVzO1xuICAgIHRoaXMuX2JpbmRSb3V0ZXMoKTtcbiAgICB0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBDYWNoZWQgcmVndWxhciBleHByZXNzaW9ucyBmb3IgbWF0Y2hpbmcgbmFtZWQgcGFyYW0gcGFydHMgYW5kIHNwbGF0dGVkXG4gIC8vIHBhcnRzIG9mIHJvdXRlIHN0cmluZ3MuXG4gIHZhciBvcHRpb25hbFBhcmFtID0gL1xcKCguKj8pXFwpL2c7XG4gIHZhciBuYW1lZFBhcmFtICAgID0gLyhcXChcXD8pPzpcXHcrL2c7XG4gIHZhciBzcGxhdFBhcmFtICAgID0gL1xcKlxcdysvZztcbiAgdmFyIGVzY2FwZVJlZ0V4cCAgPSAvW1xcLXt9XFxbXFxdKz8uLFxcXFxcXF4kfCNcXHNdL2c7XG5cbiAgLy8gU2V0IHVwIGFsbCBpbmhlcml0YWJsZSAqKkJhY2tib25lLlJvdXRlcioqIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG4gIF8uZXh0ZW5kKFJvdXRlci5wcm90b3R5cGUsIEV2ZW50cywge1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBpcyBhbiBlbXB0eSBmdW5jdGlvbiBieSBkZWZhdWx0LiBPdmVycmlkZSBpdCB3aXRoIHlvdXIgb3duXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gbG9naWMuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKXt9LFxuXG4gICAgLy8gTWFudWFsbHkgYmluZCBhIHNpbmdsZSBuYW1lZCByb3V0ZSB0byBhIGNhbGxiYWNrLiBGb3IgZXhhbXBsZTpcbiAgICAvL1xuICAgIC8vICAgICB0aGlzLnJvdXRlKCdzZWFyY2gvOnF1ZXJ5L3A6bnVtJywgJ3NlYXJjaCcsIGZ1bmN0aW9uKHF1ZXJ5LCBudW0pIHtcbiAgICAvLyAgICAgICAuLi5cbiAgICAvLyAgICAgfSk7XG4gICAgLy9cbiAgICByb3V0ZTogZnVuY3Rpb24ocm91dGUsIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoIV8uaXNSZWdFeHAocm91dGUpKSByb3V0ZSA9IHRoaXMuX3JvdXRlVG9SZWdFeHAocm91dGUpO1xuICAgICAgaWYgKF8uaXNGdW5jdGlvbihuYW1lKSkge1xuICAgICAgICBjYWxsYmFjayA9IG5hbWU7XG4gICAgICAgIG5hbWUgPSAnJztcbiAgICAgIH1cbiAgICAgIGlmICghY2FsbGJhY2spIGNhbGxiYWNrID0gdGhpc1tuYW1lXTtcbiAgICAgIHZhciByb3V0ZXIgPSB0aGlzO1xuICAgICAgQmFja2JvbmUuaGlzdG9yeS5yb3V0ZShyb3V0ZSwgZnVuY3Rpb24oZnJhZ21lbnQpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSByb3V0ZXIuX2V4dHJhY3RQYXJhbWV0ZXJzKHJvdXRlLCBmcmFnbWVudCk7XG4gICAgICAgIHJvdXRlci5leGVjdXRlKGNhbGxiYWNrLCBhcmdzKTtcbiAgICAgICAgcm91dGVyLnRyaWdnZXIuYXBwbHkocm91dGVyLCBbJ3JvdXRlOicgKyBuYW1lXS5jb25jYXQoYXJncykpO1xuICAgICAgICByb3V0ZXIudHJpZ2dlcigncm91dGUnLCBuYW1lLCBhcmdzKTtcbiAgICAgICAgQmFja2JvbmUuaGlzdG9yeS50cmlnZ2VyKCdyb3V0ZScsIHJvdXRlciwgbmFtZSwgYXJncyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBFeGVjdXRlIGEgcm91dGUgaGFuZGxlciB3aXRoIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXJzLiAgVGhpcyBpcyBhblxuICAgIC8vIGV4Y2VsbGVudCBwbGFjZSB0byBkbyBwcmUtcm91dGUgc2V0dXAgb3IgcG9zdC1yb3V0ZSBjbGVhbnVwLlxuICAgIGV4ZWN1dGU6IGZ1bmN0aW9uKGNhbGxiYWNrLCBhcmdzKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0sXG5cbiAgICAvLyBTaW1wbGUgcHJveHkgdG8gYEJhY2tib25lLmhpc3RvcnlgIHRvIHNhdmUgYSBmcmFnbWVudCBpbnRvIHRoZSBoaXN0b3J5LlxuICAgIG5hdmlnYXRlOiBmdW5jdGlvbihmcmFnbWVudCwgb3B0aW9ucykge1xuICAgICAgQmFja2JvbmUuaGlzdG9yeS5uYXZpZ2F0ZShmcmFnbWVudCwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQmluZCBhbGwgZGVmaW5lZCByb3V0ZXMgdG8gYEJhY2tib25lLmhpc3RvcnlgLiBXZSBoYXZlIHRvIHJldmVyc2UgdGhlXG4gICAgLy8gb3JkZXIgb2YgdGhlIHJvdXRlcyBoZXJlIHRvIHN1cHBvcnQgYmVoYXZpb3Igd2hlcmUgdGhlIG1vc3QgZ2VuZXJhbFxuICAgIC8vIHJvdXRlcyBjYW4gYmUgZGVmaW5lZCBhdCB0aGUgYm90dG9tIG9mIHRoZSByb3V0ZSBtYXAuXG4gICAgX2JpbmRSb3V0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLnJvdXRlcykgcmV0dXJuO1xuICAgICAgdGhpcy5yb3V0ZXMgPSBfLnJlc3VsdCh0aGlzLCAncm91dGVzJyk7XG4gICAgICB2YXIgcm91dGUsIHJvdXRlcyA9IF8ua2V5cyh0aGlzLnJvdXRlcyk7XG4gICAgICB3aGlsZSAoKHJvdXRlID0gcm91dGVzLnBvcCgpKSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMucm91dGUocm91dGUsIHRoaXMucm91dGVzW3JvdXRlXSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSByb3V0ZSBzdHJpbmcgaW50byBhIHJlZ3VsYXIgZXhwcmVzc2lvbiwgc3VpdGFibGUgZm9yIG1hdGNoaW5nXG4gICAgLy8gYWdhaW5zdCB0aGUgY3VycmVudCBsb2NhdGlvbiBoYXNoLlxuICAgIF9yb3V0ZVRvUmVnRXhwOiBmdW5jdGlvbihyb3V0ZSkge1xuICAgICAgcm91dGUgPSByb3V0ZS5yZXBsYWNlKGVzY2FwZVJlZ0V4cCwgJ1xcXFwkJicpXG4gICAgICAgICAgICAgICAgICAgLnJlcGxhY2Uob3B0aW9uYWxQYXJhbSwgJyg/OiQxKT8nKVxuICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKG5hbWVkUGFyYW0sIGZ1bmN0aW9uKG1hdGNoLCBvcHRpb25hbCkge1xuICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbmFsID8gbWF0Y2ggOiAnKFteLz9dKyknO1xuICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgLnJlcGxhY2Uoc3BsYXRQYXJhbSwgJyhbXj9dKj8pJyk7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cCgnXicgKyByb3V0ZSArICcoPzpcXFxcPyhbXFxcXHNcXFxcU10qKSk/JCcpO1xuICAgIH0sXG5cbiAgICAvLyBHaXZlbiBhIHJvdXRlLCBhbmQgYSBVUkwgZnJhZ21lbnQgdGhhdCBpdCBtYXRjaGVzLCByZXR1cm4gdGhlIGFycmF5IG9mXG4gICAgLy8gZXh0cmFjdGVkIGRlY29kZWQgcGFyYW1ldGVycy4gRW1wdHkgb3IgdW5tYXRjaGVkIHBhcmFtZXRlcnMgd2lsbCBiZVxuICAgIC8vIHRyZWF0ZWQgYXMgYG51bGxgIHRvIG5vcm1hbGl6ZSBjcm9zcy1icm93c2VyIGJlaGF2aW9yLlxuICAgIF9leHRyYWN0UGFyYW1ldGVyczogZnVuY3Rpb24ocm91dGUsIGZyYWdtZW50KSB7XG4gICAgICB2YXIgcGFyYW1zID0gcm91dGUuZXhlYyhmcmFnbWVudCkuc2xpY2UoMSk7XG4gICAgICByZXR1cm4gXy5tYXAocGFyYW1zLCBmdW5jdGlvbihwYXJhbSwgaSkge1xuICAgICAgICAvLyBEb24ndCBkZWNvZGUgdGhlIHNlYXJjaCBwYXJhbXMuXG4gICAgICAgIGlmIChpID09PSBwYXJhbXMubGVuZ3RoIC0gMSkgcmV0dXJuIHBhcmFtIHx8IG51bGw7XG4gICAgICAgIHJldHVybiBwYXJhbSA/IGRlY29kZVVSSUNvbXBvbmVudChwYXJhbSkgOiBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIEJhY2tib25lLkhpc3RvcnlcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEhhbmRsZXMgY3Jvc3MtYnJvd3NlciBoaXN0b3J5IG1hbmFnZW1lbnQsIGJhc2VkIG9uIGVpdGhlclxuICAvLyBbcHVzaFN0YXRlXShodHRwOi8vZGl2ZWludG9odG1sNS5pbmZvL2hpc3RvcnkuaHRtbCkgYW5kIHJlYWwgVVJMcywgb3JcbiAgLy8gW29uaGFzaGNoYW5nZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9ET00vd2luZG93Lm9uaGFzaGNoYW5nZSlcbiAgLy8gYW5kIFVSTCBmcmFnbWVudHMuIElmIHRoZSBicm93c2VyIHN1cHBvcnRzIG5laXRoZXIgKG9sZCBJRSwgbmF0Y2gpLFxuICAvLyBmYWxscyBiYWNrIHRvIHBvbGxpbmcuXG4gIHZhciBIaXN0b3J5ID0gQmFja2JvbmUuSGlzdG9yeSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcbiAgICBfLmJpbmRBbGwodGhpcywgJ2NoZWNrVXJsJyk7XG5cbiAgICAvLyBFbnN1cmUgdGhhdCBgSGlzdG9yeWAgY2FuIGJlIHVzZWQgb3V0c2lkZSBvZiB0aGUgYnJvd3Nlci5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMubG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG4gICAgICB0aGlzLmhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQ2FjaGVkIHJlZ2V4IGZvciBzdHJpcHBpbmcgYSBsZWFkaW5nIGhhc2gvc2xhc2ggYW5kIHRyYWlsaW5nIHNwYWNlLlxuICB2YXIgcm91dGVTdHJpcHBlciA9IC9eWyNcXC9dfFxccyskL2c7XG5cbiAgLy8gQ2FjaGVkIHJlZ2V4IGZvciBzdHJpcHBpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcy5cbiAgdmFyIHJvb3RTdHJpcHBlciA9IC9eXFwvK3xcXC8rJC9nO1xuXG4gIC8vIENhY2hlZCByZWdleCBmb3IgZGV0ZWN0aW5nIE1TSUUuXG4gIHZhciBpc0V4cGxvcmVyID0gL21zaWUgW1xcdy5dKy87XG5cbiAgLy8gQ2FjaGVkIHJlZ2V4IGZvciByZW1vdmluZyBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgdHJhaWxpbmdTbGFzaCA9IC9cXC8kLztcblxuICAvLyBDYWNoZWQgcmVnZXggZm9yIHN0cmlwcGluZyB1cmxzIG9mIGhhc2guXG4gIHZhciBwYXRoU3RyaXBwZXIgPSAvIy4qJC87XG5cbiAgLy8gSGFzIHRoZSBoaXN0b3J5IGhhbmRsaW5nIGFscmVhZHkgYmVlbiBzdGFydGVkP1xuICBIaXN0b3J5LnN0YXJ0ZWQgPSBmYWxzZTtcblxuICAvLyBTZXQgdXAgYWxsIGluaGVyaXRhYmxlICoqQmFja2JvbmUuSGlzdG9yeSoqIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG4gIF8uZXh0ZW5kKEhpc3RvcnkucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIC8vIFRoZSBkZWZhdWx0IGludGVydmFsIHRvIHBvbGwgZm9yIGhhc2ggY2hhbmdlcywgaWYgbmVjZXNzYXJ5LCBpc1xuICAgIC8vIHR3ZW50eSB0aW1lcyBhIHNlY29uZC5cbiAgICBpbnRlcnZhbDogNTAsXG5cbiAgICAvLyBBcmUgd2UgYXQgdGhlIGFwcCByb290P1xuICAgIGF0Um9vdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5sb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9bXlxcL10kLywgJyQmLycpID09PSB0aGlzLnJvb3Q7XG4gICAgfSxcblxuICAgIC8vIEdldHMgdGhlIHRydWUgaGFzaCB2YWx1ZS4gQ2Fubm90IHVzZSBsb2NhdGlvbi5oYXNoIGRpcmVjdGx5IGR1ZSB0byBidWdcbiAgICAvLyBpbiBGaXJlZm94IHdoZXJlIGxvY2F0aW9uLmhhc2ggd2lsbCBhbHdheXMgYmUgZGVjb2RlZC5cbiAgICBnZXRIYXNoOiBmdW5jdGlvbih3aW5kb3cpIHtcbiAgICAgIHZhciBtYXRjaCA9ICh3aW5kb3cgfHwgdGhpcykubG9jYXRpb24uaHJlZi5tYXRjaCgvIyguKikkLyk7XG4gICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIGNyb3NzLWJyb3dzZXIgbm9ybWFsaXplZCBVUkwgZnJhZ21lbnQsIGVpdGhlciBmcm9tIHRoZSBVUkwsXG4gICAgLy8gdGhlIGhhc2gsIG9yIHRoZSBvdmVycmlkZS5cbiAgICBnZXRGcmFnbWVudDogZnVuY3Rpb24oZnJhZ21lbnQsIGZvcmNlUHVzaFN0YXRlKSB7XG4gICAgICBpZiAoZnJhZ21lbnQgPT0gbnVsbCkge1xuICAgICAgICBpZiAodGhpcy5faGFzUHVzaFN0YXRlIHx8ICF0aGlzLl93YW50c0hhc2hDaGFuZ2UgfHwgZm9yY2VQdXNoU3RhdGUpIHtcbiAgICAgICAgICBmcmFnbWVudCA9IGRlY29kZVVSSSh0aGlzLmxvY2F0aW9uLnBhdGhuYW1lICsgdGhpcy5sb2NhdGlvbi5zZWFyY2gpO1xuICAgICAgICAgIHZhciByb290ID0gdGhpcy5yb290LnJlcGxhY2UodHJhaWxpbmdTbGFzaCwgJycpO1xuICAgICAgICAgIGlmICghZnJhZ21lbnQuaW5kZXhPZihyb290KSkgZnJhZ21lbnQgPSBmcmFnbWVudC5zbGljZShyb290Lmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdldEhhc2goKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyYWdtZW50LnJlcGxhY2Uocm91dGVTdHJpcHBlciwgJycpO1xuICAgIH0sXG5cbiAgICAvLyBTdGFydCB0aGUgaGFzaCBjaGFuZ2UgaGFuZGxpbmcsIHJldHVybmluZyBgdHJ1ZWAgaWYgdGhlIGN1cnJlbnQgVVJMIG1hdGNoZXNcbiAgICAvLyBhbiBleGlzdGluZyByb3V0ZSwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgIHN0YXJ0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAoSGlzdG9yeS5zdGFydGVkKSB0aHJvdyBuZXcgRXJyb3IoXCJCYWNrYm9uZS5oaXN0b3J5IGhhcyBhbHJlYWR5IGJlZW4gc3RhcnRlZFwiKTtcbiAgICAgIEhpc3Rvcnkuc3RhcnRlZCA9IHRydWU7XG5cbiAgICAgIC8vIEZpZ3VyZSBvdXQgdGhlIGluaXRpYWwgY29uZmlndXJhdGlvbi4gRG8gd2UgbmVlZCBhbiBpZnJhbWU/XG4gICAgICAvLyBJcyBwdXNoU3RhdGUgZGVzaXJlZCAuLi4gaXMgaXQgYXZhaWxhYmxlP1xuICAgICAgdGhpcy5vcHRpb25zICAgICAgICAgID0gXy5leHRlbmQoe3Jvb3Q6ICcvJ30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICB0aGlzLnJvb3QgICAgICAgICAgICAgPSB0aGlzLm9wdGlvbnMucm9vdDtcbiAgICAgIHRoaXMuX3dhbnRzSGFzaENoYW5nZSA9IHRoaXMub3B0aW9ucy5oYXNoQ2hhbmdlICE9PSBmYWxzZTtcbiAgICAgIHRoaXMuX3dhbnRzUHVzaFN0YXRlICA9ICEhdGhpcy5vcHRpb25zLnB1c2hTdGF0ZTtcbiAgICAgIHRoaXMuX2hhc1B1c2hTdGF0ZSAgICA9ICEhKHRoaXMub3B0aW9ucy5wdXNoU3RhdGUgJiYgdGhpcy5oaXN0b3J5ICYmIHRoaXMuaGlzdG9yeS5wdXNoU3RhdGUpO1xuICAgICAgdmFyIGZyYWdtZW50ICAgICAgICAgID0gdGhpcy5nZXRGcmFnbWVudCgpO1xuICAgICAgdmFyIGRvY01vZGUgICAgICAgICAgID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xuICAgICAgdmFyIG9sZElFICAgICAgICAgICAgID0gKGlzRXhwbG9yZXIuZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpICYmICghZG9jTW9kZSB8fCBkb2NNb2RlIDw9IDcpKTtcblxuICAgICAgLy8gTm9ybWFsaXplIHJvb3QgdG8gYWx3YXlzIGluY2x1ZGUgYSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaC5cbiAgICAgIHRoaXMucm9vdCA9ICgnLycgKyB0aGlzLnJvb3QgKyAnLycpLnJlcGxhY2Uocm9vdFN0cmlwcGVyLCAnLycpO1xuXG4gICAgICBpZiAob2xkSUUgJiYgdGhpcy5fd2FudHNIYXNoQ2hhbmdlKSB7XG4gICAgICAgIHZhciBmcmFtZSA9IEJhY2tib25lLiQoJzxpZnJhbWUgc3JjPVwiamF2YXNjcmlwdDowXCIgdGFiaW5kZXg9XCItMVwiPicpO1xuICAgICAgICB0aGlzLmlmcmFtZSA9IGZyYW1lLmhpZGUoKS5hcHBlbmRUbygnYm9keScpWzBdLmNvbnRlbnRXaW5kb3c7XG4gICAgICAgIHRoaXMubmF2aWdhdGUoZnJhZ21lbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBEZXBlbmRpbmcgb24gd2hldGhlciB3ZSdyZSB1c2luZyBwdXNoU3RhdGUgb3IgaGFzaGVzLCBhbmQgd2hldGhlclxuICAgICAgLy8gJ29uaGFzaGNoYW5nZScgaXMgc3VwcG9ydGVkLCBkZXRlcm1pbmUgaG93IHdlIGNoZWNrIHRoZSBVUkwgc3RhdGUuXG4gICAgICBpZiAodGhpcy5faGFzUHVzaFN0YXRlKSB7XG4gICAgICAgIEJhY2tib25lLiQod2luZG93KS5vbigncG9wc3RhdGUnLCB0aGlzLmNoZWNrVXJsKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fd2FudHNIYXNoQ2hhbmdlICYmICgnb25oYXNoY2hhbmdlJyBpbiB3aW5kb3cpICYmICFvbGRJRSkge1xuICAgICAgICBCYWNrYm9uZS4kKHdpbmRvdykub24oJ2hhc2hjaGFuZ2UnLCB0aGlzLmNoZWNrVXJsKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fd2FudHNIYXNoQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrVXJsSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCh0aGlzLmNoZWNrVXJsLCB0aGlzLmludGVydmFsKTtcbiAgICAgIH1cblxuICAgICAgLy8gRGV0ZXJtaW5lIGlmIHdlIG5lZWQgdG8gY2hhbmdlIHRoZSBiYXNlIHVybCwgZm9yIGEgcHVzaFN0YXRlIGxpbmtcbiAgICAgIC8vIG9wZW5lZCBieSBhIG5vbi1wdXNoU3RhdGUgYnJvd3Nlci5cbiAgICAgIHRoaXMuZnJhZ21lbnQgPSBmcmFnbWVudDtcbiAgICAgIHZhciBsb2MgPSB0aGlzLmxvY2F0aW9uO1xuXG4gICAgICAvLyBUcmFuc2l0aW9uIGZyb20gaGFzaENoYW5nZSB0byBwdXNoU3RhdGUgb3IgdmljZSB2ZXJzYSBpZiBib3RoIGFyZVxuICAgICAgLy8gcmVxdWVzdGVkLlxuICAgICAgaWYgKHRoaXMuX3dhbnRzSGFzaENoYW5nZSAmJiB0aGlzLl93YW50c1B1c2hTdGF0ZSkge1xuXG4gICAgICAgIC8vIElmIHdlJ3ZlIHN0YXJ0ZWQgb2ZmIHdpdGggYSByb3V0ZSBmcm9tIGEgYHB1c2hTdGF0ZWAtZW5hYmxlZFxuICAgICAgICAvLyBicm93c2VyLCBidXQgd2UncmUgY3VycmVudGx5IGluIGEgYnJvd3NlciB0aGF0IGRvZXNuJ3Qgc3VwcG9ydCBpdC4uLlxuICAgICAgICBpZiAoIXRoaXMuX2hhc1B1c2hTdGF0ZSAmJiAhdGhpcy5hdFJvb3QoKSkge1xuICAgICAgICAgIHRoaXMuZnJhZ21lbnQgPSB0aGlzLmdldEZyYWdtZW50KG51bGwsIHRydWUpO1xuICAgICAgICAgIHRoaXMubG9jYXRpb24ucmVwbGFjZSh0aGlzLnJvb3QgKyAnIycgKyB0aGlzLmZyYWdtZW50KTtcbiAgICAgICAgICAvLyBSZXR1cm4gaW1tZWRpYXRlbHkgYXMgYnJvd3NlciB3aWxsIGRvIHJlZGlyZWN0IHRvIG5ldyB1cmxcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAvLyBPciBpZiB3ZSd2ZSBzdGFydGVkIG91dCB3aXRoIGEgaGFzaC1iYXNlZCByb3V0ZSwgYnV0IHdlJ3JlIGN1cnJlbnRseVxuICAgICAgICAvLyBpbiBhIGJyb3dzZXIgd2hlcmUgaXQgY291bGQgYmUgYHB1c2hTdGF0ZWAtYmFzZWQgaW5zdGVhZC4uLlxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2hhc1B1c2hTdGF0ZSAmJiB0aGlzLmF0Um9vdCgpICYmIGxvYy5oYXNoKSB7XG4gICAgICAgICAgdGhpcy5mcmFnbWVudCA9IHRoaXMuZ2V0SGFzaCgpLnJlcGxhY2Uocm91dGVTdHJpcHBlciwgJycpO1xuICAgICAgICAgIHRoaXMuaGlzdG9yeS5yZXBsYWNlU3RhdGUoe30sIGRvY3VtZW50LnRpdGxlLCB0aGlzLnJvb3QgKyB0aGlzLmZyYWdtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnNpbGVudCkgcmV0dXJuIHRoaXMubG9hZFVybCgpO1xuICAgIH0sXG5cbiAgICAvLyBEaXNhYmxlIEJhY2tib25lLmhpc3RvcnksIHBlcmhhcHMgdGVtcG9yYXJpbHkuIE5vdCB1c2VmdWwgaW4gYSByZWFsIGFwcCxcbiAgICAvLyBidXQgcG9zc2libHkgdXNlZnVsIGZvciB1bml0IHRlc3RpbmcgUm91dGVycy5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIEJhY2tib25lLiQod2luZG93KS5vZmYoJ3BvcHN0YXRlJywgdGhpcy5jaGVja1VybCkub2ZmKCdoYXNoY2hhbmdlJywgdGhpcy5jaGVja1VybCk7XG4gICAgICBpZiAodGhpcy5fY2hlY2tVcmxJbnRlcnZhbCkgY2xlYXJJbnRlcnZhbCh0aGlzLl9jaGVja1VybEludGVydmFsKTtcbiAgICAgIEhpc3Rvcnkuc3RhcnRlZCA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSByb3V0ZSB0byBiZSB0ZXN0ZWQgd2hlbiB0aGUgZnJhZ21lbnQgY2hhbmdlcy4gUm91dGVzIGFkZGVkIGxhdGVyXG4gICAgLy8gbWF5IG92ZXJyaWRlIHByZXZpb3VzIHJvdXRlcy5cbiAgICByb3V0ZTogZnVuY3Rpb24ocm91dGUsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmhhbmRsZXJzLnVuc2hpZnQoe3JvdXRlOiByb3V0ZSwgY2FsbGJhY2s6IGNhbGxiYWNrfSk7XG4gICAgfSxcblxuICAgIC8vIENoZWNrcyB0aGUgY3VycmVudCBVUkwgdG8gc2VlIGlmIGl0IGhhcyBjaGFuZ2VkLCBhbmQgaWYgaXQgaGFzLFxuICAgIC8vIGNhbGxzIGBsb2FkVXJsYCwgbm9ybWFsaXppbmcgYWNyb3NzIHRoZSBoaWRkZW4gaWZyYW1lLlxuICAgIGNoZWNrVXJsOiBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMuZ2V0RnJhZ21lbnQoKTtcbiAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLmZyYWdtZW50ICYmIHRoaXMuaWZyYW1lKSB7XG4gICAgICAgIGN1cnJlbnQgPSB0aGlzLmdldEZyYWdtZW50KHRoaXMuZ2V0SGFzaCh0aGlzLmlmcmFtZSkpO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnQgPT09IHRoaXMuZnJhZ21lbnQpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICh0aGlzLmlmcmFtZSkgdGhpcy5uYXZpZ2F0ZShjdXJyZW50KTtcbiAgICAgIHRoaXMubG9hZFVybCgpO1xuICAgIH0sXG5cbiAgICAvLyBBdHRlbXB0IHRvIGxvYWQgdGhlIGN1cnJlbnQgVVJMIGZyYWdtZW50LiBJZiBhIHJvdXRlIHN1Y2NlZWRzIHdpdGggYVxuICAgIC8vIG1hdGNoLCByZXR1cm5zIGB0cnVlYC4gSWYgbm8gZGVmaW5lZCByb3V0ZXMgbWF0Y2hlcyB0aGUgZnJhZ21lbnQsXG4gICAgLy8gcmV0dXJucyBgZmFsc2VgLlxuICAgIGxvYWRVcmw6IGZ1bmN0aW9uKGZyYWdtZW50KSB7XG4gICAgICBmcmFnbWVudCA9IHRoaXMuZnJhZ21lbnQgPSB0aGlzLmdldEZyYWdtZW50KGZyYWdtZW50KTtcbiAgICAgIHJldHVybiBfLmFueSh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICAgIGlmIChoYW5kbGVyLnJvdXRlLnRlc3QoZnJhZ21lbnQpKSB7XG4gICAgICAgICAgaGFuZGxlci5jYWxsYmFjayhmcmFnbWVudCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBTYXZlIGEgZnJhZ21lbnQgaW50byB0aGUgaGFzaCBoaXN0b3J5LCBvciByZXBsYWNlIHRoZSBVUkwgc3RhdGUgaWYgdGhlXG4gICAgLy8gJ3JlcGxhY2UnIG9wdGlvbiBpcyBwYXNzZWQuIFlvdSBhcmUgcmVzcG9uc2libGUgZm9yIHByb3Blcmx5IFVSTC1lbmNvZGluZ1xuICAgIC8vIHRoZSBmcmFnbWVudCBpbiBhZHZhbmNlLlxuICAgIC8vXG4gICAgLy8gVGhlIG9wdGlvbnMgb2JqZWN0IGNhbiBjb250YWluIGB0cmlnZ2VyOiB0cnVlYCBpZiB5b3Ugd2lzaCB0byBoYXZlIHRoZVxuICAgIC8vIHJvdXRlIGNhbGxiYWNrIGJlIGZpcmVkIChub3QgdXN1YWxseSBkZXNpcmFibGUpLCBvciBgcmVwbGFjZTogdHJ1ZWAsIGlmXG4gICAgLy8geW91IHdpc2ggdG8gbW9kaWZ5IHRoZSBjdXJyZW50IFVSTCB3aXRob3V0IGFkZGluZyBhbiBlbnRyeSB0byB0aGUgaGlzdG9yeS5cbiAgICBuYXZpZ2F0ZTogZnVuY3Rpb24oZnJhZ21lbnQsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghSGlzdG9yeS5zdGFydGVkKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucyA9PT0gdHJ1ZSkgb3B0aW9ucyA9IHt0cmlnZ2VyOiAhIW9wdGlvbnN9O1xuXG4gICAgICB2YXIgdXJsID0gdGhpcy5yb290ICsgKGZyYWdtZW50ID0gdGhpcy5nZXRGcmFnbWVudChmcmFnbWVudCB8fCAnJykpO1xuXG4gICAgICAvLyBTdHJpcCB0aGUgaGFzaCBmb3IgbWF0Y2hpbmcuXG4gICAgICBmcmFnbWVudCA9IGZyYWdtZW50LnJlcGxhY2UocGF0aFN0cmlwcGVyLCAnJyk7XG5cbiAgICAgIGlmICh0aGlzLmZyYWdtZW50ID09PSBmcmFnbWVudCkgcmV0dXJuO1xuICAgICAgdGhpcy5mcmFnbWVudCA9IGZyYWdtZW50O1xuXG4gICAgICAvLyBEb24ndCBpbmNsdWRlIGEgdHJhaWxpbmcgc2xhc2ggb24gdGhlIHJvb3QuXG4gICAgICBpZiAoZnJhZ21lbnQgPT09ICcnICYmIHVybCAhPT0gJy8nKSB1cmwgPSB1cmwuc2xpY2UoMCwgLTEpO1xuXG4gICAgICAvLyBJZiBwdXNoU3RhdGUgaXMgYXZhaWxhYmxlLCB3ZSB1c2UgaXQgdG8gc2V0IHRoZSBmcmFnbWVudCBhcyBhIHJlYWwgVVJMLlxuICAgICAgaWYgKHRoaXMuX2hhc1B1c2hTdGF0ZSkge1xuICAgICAgICB0aGlzLmhpc3Rvcnlbb3B0aW9ucy5yZXBsYWNlID8gJ3JlcGxhY2VTdGF0ZScgOiAncHVzaFN0YXRlJ10oe30sIGRvY3VtZW50LnRpdGxlLCB1cmwpO1xuXG4gICAgICAvLyBJZiBoYXNoIGNoYW5nZXMgaGF2ZW4ndCBiZWVuIGV4cGxpY2l0bHkgZGlzYWJsZWQsIHVwZGF0ZSB0aGUgaGFzaFxuICAgICAgLy8gZnJhZ21lbnQgdG8gc3RvcmUgaGlzdG9yeS5cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fd2FudHNIYXNoQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUhhc2godGhpcy5sb2NhdGlvbiwgZnJhZ21lbnQsIG9wdGlvbnMucmVwbGFjZSk7XG4gICAgICAgIGlmICh0aGlzLmlmcmFtZSAmJiAoZnJhZ21lbnQgIT09IHRoaXMuZ2V0RnJhZ21lbnQodGhpcy5nZXRIYXNoKHRoaXMuaWZyYW1lKSkpKSB7XG4gICAgICAgICAgLy8gT3BlbmluZyBhbmQgY2xvc2luZyB0aGUgaWZyYW1lIHRyaWNrcyBJRTcgYW5kIGVhcmxpZXIgdG8gcHVzaCBhXG4gICAgICAgICAgLy8gaGlzdG9yeSBlbnRyeSBvbiBoYXNoLXRhZyBjaGFuZ2UuICBXaGVuIHJlcGxhY2UgaXMgdHJ1ZSwgd2UgZG9uJ3RcbiAgICAgICAgICAvLyB3YW50IHRoaXMuXG4gICAgICAgICAgaWYoIW9wdGlvbnMucmVwbGFjZSkgdGhpcy5pZnJhbWUuZG9jdW1lbnQub3BlbigpLmNsb3NlKCk7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlSGFzaCh0aGlzLmlmcmFtZS5sb2NhdGlvbiwgZnJhZ21lbnQsIG9wdGlvbnMucmVwbGFjZSk7XG4gICAgICAgIH1cblxuICAgICAgLy8gSWYgeW91J3ZlIHRvbGQgdXMgdGhhdCB5b3UgZXhwbGljaXRseSBkb24ndCB3YW50IGZhbGxiYWNrIGhhc2hjaGFuZ2UtXG4gICAgICAvLyBiYXNlZCBoaXN0b3J5LCB0aGVuIGBuYXZpZ2F0ZWAgYmVjb21lcyBhIHBhZ2UgcmVmcmVzaC5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2F0aW9uLmFzc2lnbih1cmwpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMudHJpZ2dlcikgcmV0dXJuIHRoaXMubG9hZFVybChmcmFnbWVudCk7XG4gICAgfSxcblxuICAgIC8vIFVwZGF0ZSB0aGUgaGFzaCBsb2NhdGlvbiwgZWl0aGVyIHJlcGxhY2luZyB0aGUgY3VycmVudCBlbnRyeSwgb3IgYWRkaW5nXG4gICAgLy8gYSBuZXcgb25lIHRvIHRoZSBicm93c2VyIGhpc3RvcnkuXG4gICAgX3VwZGF0ZUhhc2g6IGZ1bmN0aW9uKGxvY2F0aW9uLCBmcmFnbWVudCwgcmVwbGFjZSkge1xuICAgICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgICAgdmFyIGhyZWYgPSBsb2NhdGlvbi5ocmVmLnJlcGxhY2UoLyhqYXZhc2NyaXB0OnwjKS4qJC8sICcnKTtcbiAgICAgICAgbG9jYXRpb24ucmVwbGFjZShocmVmICsgJyMnICsgZnJhZ21lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU29tZSBicm93c2VycyByZXF1aXJlIHRoYXQgYGhhc2hgIGNvbnRhaW5zIGEgbGVhZGluZyAjLlxuICAgICAgICBsb2NhdGlvbi5oYXNoID0gJyMnICsgZnJhZ21lbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIENyZWF0ZSB0aGUgZGVmYXVsdCBCYWNrYm9uZS5oaXN0b3J5LlxuICBCYWNrYm9uZS5oaXN0b3J5ID0gbmV3IEhpc3Rvcnk7XG5cbiAgLy8gSGVscGVyc1xuICAvLyAtLS0tLS0tXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvcnJlY3RseSBzZXQgdXAgdGhlIHByb3RvdHlwZSBjaGFpbiwgZm9yIHN1YmNsYXNzZXMuXG4gIC8vIFNpbWlsYXIgdG8gYGdvb2cuaW5oZXJpdHNgLCBidXQgdXNlcyBhIGhhc2ggb2YgcHJvdG90eXBlIHByb3BlcnRpZXMgYW5kXG4gIC8vIGNsYXNzIHByb3BlcnRpZXMgdG8gYmUgZXh0ZW5kZWQuXG4gIHZhciBleHRlbmQgPSBmdW5jdGlvbihwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzO1xuICAgIHZhciBjaGlsZDtcblxuICAgIC8vIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIG5ldyBzdWJjbGFzcyBpcyBlaXRoZXIgZGVmaW5lZCBieSB5b3VcbiAgICAvLyAodGhlIFwiY29uc3RydWN0b3JcIiBwcm9wZXJ0eSBpbiB5b3VyIGBleHRlbmRgIGRlZmluaXRpb24pLCBvciBkZWZhdWx0ZWRcbiAgICAvLyBieSB1cyB0byBzaW1wbHkgY2FsbCB0aGUgcGFyZW50J3MgY29uc3RydWN0b3IuXG4gICAgaWYgKHByb3RvUHJvcHMgJiYgXy5oYXMocHJvdG9Qcm9wcywgJ2NvbnN0cnVjdG9yJykpIHtcbiAgICAgIGNoaWxkID0gcHJvdG9Qcm9wcy5jb25zdHJ1Y3RvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGQgPSBmdW5jdGlvbigpeyByZXR1cm4gcGFyZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gICAgfVxuXG4gICAgLy8gQWRkIHN0YXRpYyBwcm9wZXJ0aWVzIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgaWYgc3VwcGxpZWQuXG4gICAgXy5leHRlbmQoY2hpbGQsIHBhcmVudCwgc3RhdGljUHJvcHMpO1xuXG4gICAgLy8gU2V0IHRoZSBwcm90b3R5cGUgY2hhaW4gdG8gaW5oZXJpdCBmcm9tIGBwYXJlbnRgLCB3aXRob3V0IGNhbGxpbmdcbiAgICAvLyBgcGFyZW50YCdzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgIHZhciBTdXJyb2dhdGUgPSBmdW5jdGlvbigpeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH07XG4gICAgU3Vycm9nYXRlLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG4gICAgY2hpbGQucHJvdG90eXBlID0gbmV3IFN1cnJvZ2F0ZTtcblxuICAgIC8vIEFkZCBwcm90b3R5cGUgcHJvcGVydGllcyAoaW5zdGFuY2UgcHJvcGVydGllcykgdG8gdGhlIHN1YmNsYXNzLFxuICAgIC8vIGlmIHN1cHBsaWVkLlxuICAgIGlmIChwcm90b1Byb3BzKSBfLmV4dGVuZChjaGlsZC5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuXG4gICAgLy8gU2V0IGEgY29udmVuaWVuY2UgcHJvcGVydHkgaW4gY2FzZSB0aGUgcGFyZW50J3MgcHJvdG90eXBlIGlzIG5lZWRlZFxuICAgIC8vIGxhdGVyLlxuICAgIGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7XG5cbiAgICByZXR1cm4gY2hpbGQ7XG4gIH07XG5cbiAgLy8gU2V0IHVwIGluaGVyaXRhbmNlIGZvciB0aGUgbW9kZWwsIGNvbGxlY3Rpb24sIHJvdXRlciwgdmlldyBhbmQgaGlzdG9yeS5cbiAgTW9kZWwuZXh0ZW5kID0gQ29sbGVjdGlvbi5leHRlbmQgPSBSb3V0ZXIuZXh0ZW5kID0gVmlldy5leHRlbmQgPSBIaXN0b3J5LmV4dGVuZCA9IGV4dGVuZDtcblxuICAvLyBUaHJvdyBhbiBlcnJvciB3aGVuIGEgVVJMIGlzIG5lZWRlZCwgYW5kIG5vbmUgaXMgc3VwcGxpZWQuXG4gIHZhciB1cmxFcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQSBcInVybFwiIHByb3BlcnR5IG9yIGZ1bmN0aW9uIG11c3QgYmUgc3BlY2lmaWVkJyk7XG4gIH07XG5cbiAgLy8gV3JhcCBhbiBvcHRpb25hbCBlcnJvciBjYWxsYmFjayB3aXRoIGEgZmFsbGJhY2sgZXJyb3IgZXZlbnQuXG4gIHZhciB3cmFwRXJyb3IgPSBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgIHZhciBlcnJvciA9IG9wdGlvbnMuZXJyb3I7XG4gICAgb3B0aW9ucy5lcnJvciA9IGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgIGlmIChlcnJvcikgZXJyb3IobW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgbW9kZWwudHJpZ2dlcignZXJyb3InLCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgfTtcblxuICByZXR1cm4gQmFja2JvbmU7XG5cbn0pKTtcbiIsIi8qXG4gKiBqUXVlcnkgRmlsZSBVcGxvYWQgUGx1Z2luIDUuNDAuMVxuICogaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvalF1ZXJ5LUZpbGUtVXBsb2FkXG4gKlxuICogQ29weXJpZ2h0IDIwMTAsIFNlYmFzdGlhbiBUc2NoYW5cbiAqIGh0dHBzOi8vYmx1ZWltcC5uZXRcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4gKiBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICovXG5cbi8qIGpzaGludCBub21lbjpmYWxzZSAqL1xuLyogZ2xvYmFsIGRlZmluZSwgd2luZG93LCBkb2N1bWVudCwgbG9jYXRpb24sIEJsb2IsIEZvcm1EYXRhICovXG5cbihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBBTUQgbW9kdWxlOlxuICAgICAgICBkZWZpbmUoW1xuICAgICAgICAgICAgJ2pxdWVyeScsXG4gICAgICAgICAgICAnanF1ZXJ5LnVpLndpZGdldCdcbiAgICAgICAgXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzOlxuICAgICAgICBmYWN0b3J5KHdpbmRvdy5qUXVlcnkpO1xuICAgIH1cbn0oZnVuY3Rpb24gKCQpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvLyBEZXRlY3QgZmlsZSBpbnB1dCBzdXBwb3J0LCBiYXNlZCBvblxuICAgIC8vIGh0dHA6Ly92aWxqYW1pcy5jb20vYmxvZy8yMDEyL2ZpbGUtdXBsb2FkLXN1cHBvcnQtb24tbW9iaWxlL1xuICAgICQuc3VwcG9ydC5maWxlSW5wdXQgPSAhKG5ldyBSZWdFeHAoXG4gICAgICAgIC8vIEhhbmRsZSBkZXZpY2VzIHdoaWNoIGdpdmUgZmFsc2UgcG9zaXRpdmVzIGZvciB0aGUgZmVhdHVyZSBkZXRlY3Rpb246XG4gICAgICAgICcoQW5kcm9pZCAoMVxcXFwuWzAxNTZdfDJcXFxcLlswMV0pKScgK1xuICAgICAgICAgICAgJ3woV2luZG93cyBQaG9uZSAoT1MgN3w4XFxcXC4wKSl8KFhCTFdQKXwoWnVuZVdQKXwoV1BEZXNrdG9wKScgK1xuICAgICAgICAgICAgJ3wodyhlYik/T1NCcm93c2VyKXwod2ViT1MpJyArXG4gICAgICAgICAgICAnfChLaW5kbGUvKDFcXFxcLjB8MlxcXFwuWzA1XXwzXFxcXC4wKSknXG4gICAgKS50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSB8fFxuICAgICAgICAvLyBGZWF0dXJlIGRldGVjdGlvbiBmb3IgYWxsIG90aGVyIGRldmljZXM6XG4gICAgICAgICQoJzxpbnB1dCB0eXBlPVwiZmlsZVwiPicpLnByb3AoJ2Rpc2FibGVkJykpO1xuXG4gICAgLy8gVGhlIEZpbGVSZWFkZXIgQVBJIGlzIG5vdCBhY3R1YWxseSB1c2VkLCBidXQgd29ya3MgYXMgZmVhdHVyZSBkZXRlY3Rpb24sXG4gICAgLy8gYXMgc29tZSBTYWZhcmkgdmVyc2lvbnMgKDU/KSBzdXBwb3J0IFhIUiBmaWxlIHVwbG9hZHMgdmlhIHRoZSBGb3JtRGF0YSBBUEksXG4gICAgLy8gYnV0IG5vdCBub24tbXVsdGlwYXJ0IFhIUiBmaWxlIHVwbG9hZHMuXG4gICAgLy8gd2luZG93LlhNTEh0dHBSZXF1ZXN0VXBsb2FkIGlzIG5vdCBhdmFpbGFibGUgb24gSUUxMCwgc28gd2UgY2hlY2sgZm9yXG4gICAgLy8gd2luZG93LlByb2dyZXNzRXZlbnQgaW5zdGVhZCB0byBkZXRlY3QgWEhSMiBmaWxlIHVwbG9hZCBjYXBhYmlsaXR5OlxuICAgICQuc3VwcG9ydC54aHJGaWxlVXBsb2FkID0gISEod2luZG93LlByb2dyZXNzRXZlbnQgJiYgd2luZG93LkZpbGVSZWFkZXIpO1xuICAgICQuc3VwcG9ydC54aHJGb3JtRGF0YUZpbGVVcGxvYWQgPSAhIXdpbmRvdy5Gb3JtRGF0YTtcblxuICAgIC8vIERldGVjdCBzdXBwb3J0IGZvciBCbG9iIHNsaWNpbmcgKHJlcXVpcmVkIGZvciBjaHVua2VkIHVwbG9hZHMpOlxuICAgICQuc3VwcG9ydC5ibG9iU2xpY2UgPSB3aW5kb3cuQmxvYiAmJiAoQmxvYi5wcm90b3R5cGUuc2xpY2UgfHxcbiAgICAgICAgQmxvYi5wcm90b3R5cGUud2Via2l0U2xpY2UgfHwgQmxvYi5wcm90b3R5cGUubW96U2xpY2UpO1xuXG4gICAgLy8gVGhlIGZpbGV1cGxvYWQgd2lkZ2V0IGxpc3RlbnMgZm9yIGNoYW5nZSBldmVudHMgb24gZmlsZSBpbnB1dCBmaWVsZHMgZGVmaW5lZFxuICAgIC8vIHZpYSBmaWxlSW5wdXQgc2V0dGluZyBhbmQgcGFzdGUgb3IgZHJvcCBldmVudHMgb2YgdGhlIGdpdmVuIGRyb3Bab25lLlxuICAgIC8vIEluIGFkZGl0aW9uIHRvIHRoZSBkZWZhdWx0IGpRdWVyeSBXaWRnZXQgbWV0aG9kcywgdGhlIGZpbGV1cGxvYWQgd2lkZ2V0XG4gICAgLy8gZXhwb3NlcyB0aGUgXCJhZGRcIiBhbmQgXCJzZW5kXCIgbWV0aG9kcywgdG8gYWRkIG9yIGRpcmVjdGx5IHNlbmQgZmlsZXMgdXNpbmdcbiAgICAvLyB0aGUgZmlsZXVwbG9hZCBBUEkuXG4gICAgLy8gQnkgZGVmYXVsdCwgZmlsZXMgYWRkZWQgdmlhIGZpbGUgaW5wdXQgc2VsZWN0aW9uLCBwYXN0ZSwgZHJhZyAmIGRyb3Agb3JcbiAgICAvLyBcImFkZFwiIG1ldGhvZCBhcmUgdXBsb2FkZWQgaW1tZWRpYXRlbHksIGJ1dCBpdCBpcyBwb3NzaWJsZSB0byBvdmVycmlkZVxuICAgIC8vIHRoZSBcImFkZFwiIGNhbGxiYWNrIG9wdGlvbiB0byBxdWV1ZSBmaWxlIHVwbG9hZHMuXG4gICAgJC53aWRnZXQoJ2JsdWVpbXAuZmlsZXVwbG9hZCcsIHtcblxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAvLyBUaGUgZHJvcCB0YXJnZXQgZWxlbWVudChzKSwgYnkgdGhlIGRlZmF1bHQgdGhlIGNvbXBsZXRlIGRvY3VtZW50LlxuICAgICAgICAgICAgLy8gU2V0IHRvIG51bGwgdG8gZGlzYWJsZSBkcmFnICYgZHJvcCBzdXBwb3J0OlxuICAgICAgICAgICAgZHJvcFpvbmU6ICQoZG9jdW1lbnQpLFxuICAgICAgICAgICAgLy8gVGhlIHBhc3RlIHRhcmdldCBlbGVtZW50KHMpLCBieSB0aGUgZGVmYXVsdCB0aGUgY29tcGxldGUgZG9jdW1lbnQuXG4gICAgICAgICAgICAvLyBTZXQgdG8gbnVsbCB0byBkaXNhYmxlIHBhc3RlIHN1cHBvcnQ6XG4gICAgICAgICAgICBwYXN0ZVpvbmU6ICQoZG9jdW1lbnQpLFxuICAgICAgICAgICAgLy8gVGhlIGZpbGUgaW5wdXQgZmllbGQocyksIHRoYXQgYXJlIGxpc3RlbmVkIHRvIGZvciBjaGFuZ2UgZXZlbnRzLlxuICAgICAgICAgICAgLy8gSWYgdW5kZWZpbmVkLCBpdCBpcyBzZXQgdG8gdGhlIGZpbGUgaW5wdXQgZmllbGRzIGluc2lkZVxuICAgICAgICAgICAgLy8gb2YgdGhlIHdpZGdldCBlbGVtZW50IG9uIHBsdWdpbiBpbml0aWFsaXphdGlvbi5cbiAgICAgICAgICAgIC8vIFNldCB0byBudWxsIHRvIGRpc2FibGUgdGhlIGNoYW5nZSBsaXN0ZW5lci5cbiAgICAgICAgICAgIGZpbGVJbnB1dDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCwgdGhlIGZpbGUgaW5wdXQgZmllbGQgaXMgcmVwbGFjZWQgd2l0aCBhIGNsb25lIGFmdGVyXG4gICAgICAgICAgICAvLyBlYWNoIGlucHV0IGZpZWxkIGNoYW5nZSBldmVudC4gVGhpcyBpcyByZXF1aXJlZCBmb3IgaWZyYW1lIHRyYW5zcG9ydFxuICAgICAgICAgICAgLy8gcXVldWVzIGFuZCBhbGxvd3MgY2hhbmdlIGV2ZW50cyB0byBiZSBmaXJlZCBmb3IgdGhlIHNhbWUgZmlsZVxuICAgICAgICAgICAgLy8gc2VsZWN0aW9uLCBidXQgY2FuIGJlIGRpc2FibGVkIGJ5IHNldHRpbmcgdGhlIGZvbGxvd2luZyBvcHRpb24gdG8gZmFsc2U6XG4gICAgICAgICAgICByZXBsYWNlRmlsZUlucHV0OiB0cnVlLFxuICAgICAgICAgICAgLy8gVGhlIHBhcmFtZXRlciBuYW1lIGZvciB0aGUgZmlsZSBmb3JtIGRhdGEgKHRoZSByZXF1ZXN0IGFyZ3VtZW50IG5hbWUpLlxuICAgICAgICAgICAgLy8gSWYgdW5kZWZpbmVkIG9yIGVtcHR5LCB0aGUgbmFtZSBwcm9wZXJ0eSBvZiB0aGUgZmlsZSBpbnB1dCBmaWVsZCBpc1xuICAgICAgICAgICAgLy8gdXNlZCwgb3IgXCJmaWxlc1tdXCIgaWYgdGhlIGZpbGUgaW5wdXQgbmFtZSBwcm9wZXJ0eSBpcyBhbHNvIGVtcHR5LFxuICAgICAgICAgICAgLy8gY2FuIGJlIGEgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHN0cmluZ3M6XG4gICAgICAgICAgICBwYXJhbU5hbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIEJ5IGRlZmF1bHQsIGVhY2ggZmlsZSBvZiBhIHNlbGVjdGlvbiBpcyB1cGxvYWRlZCB1c2luZyBhbiBpbmRpdmlkdWFsXG4gICAgICAgICAgICAvLyByZXF1ZXN0IGZvciBYSFIgdHlwZSB1cGxvYWRzLiBTZXQgdG8gZmFsc2UgdG8gdXBsb2FkIGZpbGVcbiAgICAgICAgICAgIC8vIHNlbGVjdGlvbnMgaW4gb25lIHJlcXVlc3QgZWFjaDpcbiAgICAgICAgICAgIHNpbmdsZUZpbGVVcGxvYWRzOiB0cnVlLFxuICAgICAgICAgICAgLy8gVG8gbGltaXQgdGhlIG51bWJlciBvZiBmaWxlcyB1cGxvYWRlZCB3aXRoIG9uZSBYSFIgcmVxdWVzdCxcbiAgICAgICAgICAgIC8vIHNldCB0aGUgZm9sbG93aW5nIG9wdGlvbiB0byBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiAwOlxuICAgICAgICAgICAgbGltaXRNdWx0aUZpbGVVcGxvYWRzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIG9wdGlvbiBsaW1pdHMgdGhlIG51bWJlciBvZiBmaWxlcyB1cGxvYWRlZCB3aXRoIG9uZVxuICAgICAgICAgICAgLy8gWEhSIHJlcXVlc3QgdG8ga2VlcCB0aGUgcmVxdWVzdCBzaXplIHVuZGVyIG9yIGVxdWFsIHRvIHRoZSBkZWZpbmVkXG4gICAgICAgICAgICAvLyBsaW1pdCBpbiBieXRlczpcbiAgICAgICAgICAgIGxpbWl0TXVsdGlGaWxlVXBsb2FkU2l6ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgLy8gTXVsdGlwYXJ0IGZpbGUgdXBsb2FkcyBhZGQgYSBudW1iZXIgb2YgYnl0ZXMgdG8gZWFjaCB1cGxvYWRlZCBmaWxlLFxuICAgICAgICAgICAgLy8gdGhlcmVmb3JlIHRoZSBmb2xsb3dpbmcgb3B0aW9uIGFkZHMgYW4gb3ZlcmhlYWQgZm9yIGVhY2ggZmlsZSB1c2VkXG4gICAgICAgICAgICAvLyBpbiB0aGUgbGltaXRNdWx0aUZpbGVVcGxvYWRTaXplIGNvbmZpZ3VyYXRpb246XG4gICAgICAgICAgICBsaW1pdE11bHRpRmlsZVVwbG9hZFNpemVPdmVyaGVhZDogNTEyLFxuICAgICAgICAgICAgLy8gU2V0IHRoZSBmb2xsb3dpbmcgb3B0aW9uIHRvIHRydWUgdG8gaXNzdWUgYWxsIGZpbGUgdXBsb2FkIHJlcXVlc3RzXG4gICAgICAgICAgICAvLyBpbiBhIHNlcXVlbnRpYWwgb3JkZXI6XG4gICAgICAgICAgICBzZXF1ZW50aWFsVXBsb2FkczogZmFsc2UsXG4gICAgICAgICAgICAvLyBUbyBsaW1pdCB0aGUgbnVtYmVyIG9mIGNvbmN1cnJlbnQgdXBsb2FkcyxcbiAgICAgICAgICAgIC8vIHNldCB0aGUgZm9sbG93aW5nIG9wdGlvbiB0byBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiAwOlxuICAgICAgICAgICAgbGltaXRDb25jdXJyZW50VXBsb2FkczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgLy8gU2V0IHRoZSBmb2xsb3dpbmcgb3B0aW9uIHRvIHRydWUgdG8gZm9yY2UgaWZyYW1lIHRyYW5zcG9ydCB1cGxvYWRzOlxuICAgICAgICAgICAgZm9yY2VJZnJhbWVUcmFuc3BvcnQ6IGZhbHNlLFxuICAgICAgICAgICAgLy8gU2V0IHRoZSBmb2xsb3dpbmcgb3B0aW9uIHRvIHRoZSBsb2NhdGlvbiBvZiBhIHJlZGlyZWN0IHVybCBvbiB0aGVcbiAgICAgICAgICAgIC8vIG9yaWdpbiBzZXJ2ZXIsIGZvciBjcm9zcy1kb21haW4gaWZyYW1lIHRyYW5zcG9ydCB1cGxvYWRzOlxuICAgICAgICAgICAgcmVkaXJlY3Q6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIFRoZSBwYXJhbWV0ZXIgbmFtZSBmb3IgdGhlIHJlZGlyZWN0IHVybCwgc2VudCBhcyBwYXJ0IG9mIHRoZSBmb3JtXG4gICAgICAgICAgICAvLyBkYXRhIGFuZCBzZXQgdG8gJ3JlZGlyZWN0JyBpZiB0aGlzIG9wdGlvbiBpcyBlbXB0eTpcbiAgICAgICAgICAgIHJlZGlyZWN0UGFyYW1OYW1lOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAvLyBTZXQgdGhlIGZvbGxvd2luZyBvcHRpb24gdG8gdGhlIGxvY2F0aW9uIG9mIGEgcG9zdE1lc3NhZ2Ugd2luZG93LFxuICAgICAgICAgICAgLy8gdG8gZW5hYmxlIHBvc3RNZXNzYWdlIHRyYW5zcG9ydCB1cGxvYWRzOlxuICAgICAgICAgICAgcG9zdE1lc3NhZ2U6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIEJ5IGRlZmF1bHQsIFhIUiBmaWxlIHVwbG9hZHMgYXJlIHNlbnQgYXMgbXVsdGlwYXJ0L2Zvcm0tZGF0YS5cbiAgICAgICAgICAgIC8vIFRoZSBpZnJhbWUgdHJhbnNwb3J0IGlzIGFsd2F5cyB1c2luZyBtdWx0aXBhcnQvZm9ybS1kYXRhLlxuICAgICAgICAgICAgLy8gU2V0IHRvIGZhbHNlIHRvIGVuYWJsZSBub24tbXVsdGlwYXJ0IFhIUiB1cGxvYWRzOlxuICAgICAgICAgICAgbXVsdGlwYXJ0OiB0cnVlLFxuICAgICAgICAgICAgLy8gVG8gdXBsb2FkIGxhcmdlIGZpbGVzIGluIHNtYWxsZXIgY2h1bmtzLCBzZXQgdGhlIGZvbGxvd2luZyBvcHRpb25cbiAgICAgICAgICAgIC8vIHRvIGEgcHJlZmVycmVkIG1heGltdW0gY2h1bmsgc2l6ZS4gSWYgc2V0IHRvIDAsIG51bGwgb3IgdW5kZWZpbmVkLFxuICAgICAgICAgICAgLy8gb3IgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgcmVxdWlyZWQgQmxvYiBBUEksIGZpbGVzIHdpbGxcbiAgICAgICAgICAgIC8vIGJlIHVwbG9hZGVkIGFzIGEgd2hvbGUuXG4gICAgICAgICAgICBtYXhDaHVua1NpemU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIFdoZW4gYSBub24tbXVsdGlwYXJ0IHVwbG9hZCBvciBhIGNodW5rZWQgbXVsdGlwYXJ0IHVwbG9hZCBoYXMgYmVlblxuICAgICAgICAgICAgLy8gYWJvcnRlZCwgdGhpcyBvcHRpb24gY2FuIGJlIHVzZWQgdG8gcmVzdW1lIHRoZSB1cGxvYWQgYnkgc2V0dGluZ1xuICAgICAgICAgICAgLy8gaXQgdG8gdGhlIHNpemUgb2YgdGhlIGFscmVhZHkgdXBsb2FkZWQgYnl0ZXMuIFRoaXMgb3B0aW9uIGlzIG1vc3RcbiAgICAgICAgICAgIC8vIHVzZWZ1bCB3aGVuIG1vZGlmeWluZyB0aGUgb3B0aW9ucyBvYmplY3QgaW5zaWRlIG9mIHRoZSBcImFkZFwiIG9yXG4gICAgICAgICAgICAvLyBcInNlbmRcIiBjYWxsYmFja3MsIGFzIHRoZSBvcHRpb25zIGFyZSBjbG9uZWQgZm9yIGVhY2ggZmlsZSB1cGxvYWQuXG4gICAgICAgICAgICB1cGxvYWRlZEJ5dGVzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCBmYWlsZWQgKGFib3J0IG9yIGVycm9yKSBmaWxlIHVwbG9hZHMgYXJlIHJlbW92ZWQgZnJvbSB0aGVcbiAgICAgICAgICAgIC8vIGdsb2JhbCBwcm9ncmVzcyBjYWxjdWxhdGlvbi4gU2V0IHRoZSBmb2xsb3dpbmcgb3B0aW9uIHRvIGZhbHNlIHRvXG4gICAgICAgICAgICAvLyBwcmV2ZW50IHJlY2FsY3VsYXRpbmcgdGhlIGdsb2JhbCBwcm9ncmVzcyBkYXRhOlxuICAgICAgICAgICAgcmVjYWxjdWxhdGVQcm9ncmVzczogdHJ1ZSxcbiAgICAgICAgICAgIC8vIEludGVydmFsIGluIG1pbGxpc2Vjb25kcyB0byBjYWxjdWxhdGUgYW5kIHRyaWdnZXIgcHJvZ3Jlc3MgZXZlbnRzOlxuICAgICAgICAgICAgcHJvZ3Jlc3NJbnRlcnZhbDogMTAwLFxuICAgICAgICAgICAgLy8gSW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzIHRvIGNhbGN1bGF0ZSBwcm9ncmVzcyBiaXRyYXRlOlxuICAgICAgICAgICAgYml0cmF0ZUludGVydmFsOiA1MDAsXG4gICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCB1cGxvYWRzIGFyZSBzdGFydGVkIGF1dG9tYXRpY2FsbHkgd2hlbiBhZGRpbmcgZmlsZXM6XG4gICAgICAgICAgICBhdXRvVXBsb2FkOiB0cnVlLFxuXG4gICAgICAgICAgICAvLyBFcnJvciBhbmQgaW5mbyBtZXNzYWdlczpcbiAgICAgICAgICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICAgICAgICAgdXBsb2FkZWRCeXRlczogJ1VwbG9hZGVkIGJ5dGVzIGV4Y2VlZCBmaWxlIHNpemUnXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBUcmFuc2xhdGlvbiBmdW5jdGlvbiwgZ2V0cyB0aGUgbWVzc2FnZSBrZXkgdG8gYmUgdHJhbnNsYXRlZFxuICAgICAgICAgICAgLy8gYW5kIGFuIG9iamVjdCB3aXRoIGNvbnRleHQgc3BlY2lmaWMgZGF0YSBhcyBhcmd1bWVudHM6XG4gICAgICAgICAgICBpMThuOiBmdW5jdGlvbiAobWVzc2FnZSwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2VzW21lc3NhZ2VdIHx8IG1lc3NhZ2UudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAkLmVhY2goY29udGV4dCwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoJ3snICsga2V5ICsgJ30nLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIEFkZGl0aW9uYWwgZm9ybSBkYXRhIHRvIGJlIHNlbnQgYWxvbmcgd2l0aCB0aGUgZmlsZSB1cGxvYWRzIGNhbiBiZSBzZXRcbiAgICAgICAgICAgIC8vIHVzaW5nIHRoaXMgb3B0aW9uLCB3aGljaCBhY2NlcHRzIGFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCBuYW1lIGFuZFxuICAgICAgICAgICAgLy8gdmFsdWUgcHJvcGVydGllcywgYSBmdW5jdGlvbiByZXR1cm5pbmcgc3VjaCBhbiBhcnJheSwgYSBGb3JtRGF0YVxuICAgICAgICAgICAgLy8gb2JqZWN0IChmb3IgWEhSIGZpbGUgdXBsb2FkcyksIG9yIGEgc2ltcGxlIG9iamVjdC5cbiAgICAgICAgICAgIC8vIFRoZSBmb3JtIG9mIHRoZSBmaXJzdCBmaWxlSW5wdXQgaXMgZ2l2ZW4gYXMgcGFyYW1ldGVyIHRvIHRoZSBmdW5jdGlvbjpcbiAgICAgICAgICAgIGZvcm1EYXRhOiBmdW5jdGlvbiAoZm9ybSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtLnNlcmlhbGl6ZUFycmF5KCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBUaGUgYWRkIGNhbGxiYWNrIGlzIGludm9rZWQgYXMgc29vbiBhcyBmaWxlcyBhcmUgYWRkZWQgdG8gdGhlIGZpbGV1cGxvYWRcbiAgICAgICAgICAgIC8vIHdpZGdldCAodmlhIGZpbGUgaW5wdXQgc2VsZWN0aW9uLCBkcmFnICYgZHJvcCwgcGFzdGUgb3IgYWRkIEFQSSBjYWxsKS5cbiAgICAgICAgICAgIC8vIElmIHRoZSBzaW5nbGVGaWxlVXBsb2FkcyBvcHRpb24gaXMgZW5hYmxlZCwgdGhpcyBjYWxsYmFjayB3aWxsIGJlXG4gICAgICAgICAgICAvLyBjYWxsZWQgb25jZSBmb3IgZWFjaCBmaWxlIGluIHRoZSBzZWxlY3Rpb24gZm9yIFhIUiBmaWxlIHVwbG9hZHMsIGVsc2VcbiAgICAgICAgICAgIC8vIG9uY2UgZm9yIGVhY2ggZmlsZSBzZWxlY3Rpb24uXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVGhlIHVwbG9hZCBzdGFydHMgd2hlbiB0aGUgc3VibWl0IG1ldGhvZCBpcyBpbnZva2VkIG9uIHRoZSBkYXRhIHBhcmFtZXRlci5cbiAgICAgICAgICAgIC8vIFRoZSBkYXRhIG9iamVjdCBjb250YWlucyBhIGZpbGVzIHByb3BlcnR5IGhvbGRpbmcgdGhlIGFkZGVkIGZpbGVzXG4gICAgICAgICAgICAvLyBhbmQgYWxsb3dzIHlvdSB0byBvdmVycmlkZSBwbHVnaW4gb3B0aW9ucyBhcyB3ZWxsIGFzIGRlZmluZSBhamF4IHNldHRpbmdzLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIExpc3RlbmVycyBmb3IgdGhpcyBjYWxsYmFjayBjYW4gYWxzbyBiZSBib3VuZCB0aGUgZm9sbG93aW5nIHdheTpcbiAgICAgICAgICAgIC8vIC5iaW5kKCdmaWxldXBsb2FkYWRkJywgZnVuYyk7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gZGF0YS5zdWJtaXQoKSByZXR1cm5zIGEgUHJvbWlzZSBvYmplY3QgYW5kIGFsbG93cyB0byBhdHRhY2ggYWRkaXRpb25hbFxuICAgICAgICAgICAgLy8gaGFuZGxlcnMgdXNpbmcgalF1ZXJ5J3MgRGVmZXJyZWQgY2FsbGJhY2tzOlxuICAgICAgICAgICAgLy8gZGF0YS5zdWJtaXQoKS5kb25lKGZ1bmMpLmZhaWwoZnVuYykuYWx3YXlzKGZ1bmMpO1xuICAgICAgICAgICAgYWRkOiBmdW5jdGlvbiAoZSwgZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuYXV0b1VwbG9hZCB8fCAoZGF0YS5hdXRvVXBsb2FkICE9PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5maWxldXBsb2FkKCdvcHRpb24nLCAnYXV0b1VwbG9hZCcpKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnByb2Nlc3MoKS5kb25lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc3VibWl0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIE90aGVyIGNhbGxiYWNrczpcblxuICAgICAgICAgICAgLy8gQ2FsbGJhY2sgZm9yIHRoZSBzdWJtaXQgZXZlbnQgb2YgZWFjaCBmaWxlIHVwbG9hZDpcbiAgICAgICAgICAgIC8vIHN1Ym1pdDogZnVuY3Rpb24gKGUsIGRhdGEpIHt9LCAvLyAuYmluZCgnZmlsZXVwbG9hZHN1Ym1pdCcsIGZ1bmMpO1xuXG4gICAgICAgICAgICAvLyBDYWxsYmFjayBmb3IgdGhlIHN0YXJ0IG9mIGVhY2ggZmlsZSB1cGxvYWQgcmVxdWVzdDpcbiAgICAgICAgICAgIC8vIHNlbmQ6IGZ1bmN0aW9uIChlLCBkYXRhKSB7fSwgLy8gLmJpbmQoJ2ZpbGV1cGxvYWRzZW5kJywgZnVuYyk7XG5cbiAgICAgICAgICAgIC8vIENhbGxiYWNrIGZvciBzdWNjZXNzZnVsIHVwbG9hZHM6XG4gICAgICAgICAgICAvLyBkb25lOiBmdW5jdGlvbiAoZSwgZGF0YSkge30sIC8vIC5iaW5kKCdmaWxldXBsb2FkZG9uZScsIGZ1bmMpO1xuXG4gICAgICAgICAgICAvLyBDYWxsYmFjayBmb3IgZmFpbGVkIChhYm9ydCBvciBlcnJvcikgdXBsb2FkczpcbiAgICAgICAgICAgIC8vIGZhaWw6IGZ1bmN0aW9uIChlLCBkYXRhKSB7fSwgLy8gLmJpbmQoJ2ZpbGV1cGxvYWRmYWlsJywgZnVuYyk7XG5cbiAgICAgICAgICAgIC8vIENhbGxiYWNrIGZvciBjb21wbGV0ZWQgKHN1Y2Nlc3MsIGFib3J0IG9yIGVycm9yKSByZXF1ZXN0czpcbiAgICAgICAgICAgIC8vIGFsd2F5czogZnVuY3Rpb24gKGUsIGRhdGEpIHt9LCAvLyAuYmluZCgnZmlsZXVwbG9hZGFsd2F5cycsIGZ1bmMpO1xuXG4gICAgICAgICAgICAvLyBDYWxsYmFjayBmb3IgdXBsb2FkIHByb2dyZXNzIGV2ZW50czpcbiAgICAgICAgICAgIC8vIHByb2dyZXNzOiBmdW5jdGlvbiAoZSwgZGF0YSkge30sIC8vIC5iaW5kKCdmaWxldXBsb2FkcHJvZ3Jlc3MnLCBmdW5jKTtcblxuICAgICAgICAgICAgLy8gQ2FsbGJhY2sgZm9yIGdsb2JhbCB1cGxvYWQgcHJvZ3Jlc3MgZXZlbnRzOlxuICAgICAgICAgICAgLy8gcHJvZ3Jlc3NhbGw6IGZ1bmN0aW9uIChlLCBkYXRhKSB7fSwgLy8gLmJpbmQoJ2ZpbGV1cGxvYWRwcm9ncmVzc2FsbCcsIGZ1bmMpO1xuXG4gICAgICAgICAgICAvLyBDYWxsYmFjayBmb3IgdXBsb2FkcyBzdGFydCwgZXF1aXZhbGVudCB0byB0aGUgZ2xvYmFsIGFqYXhTdGFydCBldmVudDpcbiAgICAgICAgICAgIC8vIHN0YXJ0OiBmdW5jdGlvbiAoZSkge30sIC8vIC5iaW5kKCdmaWxldXBsb2Fkc3RhcnQnLCBmdW5jKTtcblxuICAgICAgICAgICAgLy8gQ2FsbGJhY2sgZm9yIHVwbG9hZHMgc3RvcCwgZXF1aXZhbGVudCB0byB0aGUgZ2xvYmFsIGFqYXhTdG9wIGV2ZW50OlxuICAgICAgICAgICAgLy8gc3RvcDogZnVuY3Rpb24gKGUpIHt9LCAvLyAuYmluZCgnZmlsZXVwbG9hZHN0b3AnLCBmdW5jKTtcblxuICAgICAgICAgICAgLy8gQ2FsbGJhY2sgZm9yIGNoYW5nZSBldmVudHMgb2YgdGhlIGZpbGVJbnB1dChzKTpcbiAgICAgICAgICAgIC8vIGNoYW5nZTogZnVuY3Rpb24gKGUsIGRhdGEpIHt9LCAvLyAuYmluZCgnZmlsZXVwbG9hZGNoYW5nZScsIGZ1bmMpO1xuXG4gICAgICAgICAgICAvLyBDYWxsYmFjayBmb3IgcGFzdGUgZXZlbnRzIHRvIHRoZSBwYXN0ZVpvbmUocyk6XG4gICAgICAgICAgICAvLyBwYXN0ZTogZnVuY3Rpb24gKGUsIGRhdGEpIHt9LCAvLyAuYmluZCgnZmlsZXVwbG9hZHBhc3RlJywgZnVuYyk7XG5cbiAgICAgICAgICAgIC8vIENhbGxiYWNrIGZvciBkcm9wIGV2ZW50cyBvZiB0aGUgZHJvcFpvbmUocyk6XG4gICAgICAgICAgICAvLyBkcm9wOiBmdW5jdGlvbiAoZSwgZGF0YSkge30sIC8vIC5iaW5kKCdmaWxldXBsb2FkZHJvcCcsIGZ1bmMpO1xuXG4gICAgICAgICAgICAvLyBDYWxsYmFjayBmb3IgZHJhZ292ZXIgZXZlbnRzIG9mIHRoZSBkcm9wWm9uZShzKTpcbiAgICAgICAgICAgIC8vIGRyYWdvdmVyOiBmdW5jdGlvbiAoZSkge30sIC8vIC5iaW5kKCdmaWxldXBsb2FkZHJhZ292ZXInLCBmdW5jKTtcblxuICAgICAgICAgICAgLy8gQ2FsbGJhY2sgZm9yIHRoZSBzdGFydCBvZiBlYWNoIGNodW5rIHVwbG9hZCByZXF1ZXN0OlxuICAgICAgICAgICAgLy8gY2h1bmtzZW5kOiBmdW5jdGlvbiAoZSwgZGF0YSkge30sIC8vIC5iaW5kKCdmaWxldXBsb2FkY2h1bmtzZW5kJywgZnVuYyk7XG5cbiAgICAgICAgICAgIC8vIENhbGxiYWNrIGZvciBzdWNjZXNzZnVsIGNodW5rIHVwbG9hZHM6XG4gICAgICAgICAgICAvLyBjaHVua2RvbmU6IGZ1bmN0aW9uIChlLCBkYXRhKSB7fSwgLy8gLmJpbmQoJ2ZpbGV1cGxvYWRjaHVua2RvbmUnLCBmdW5jKTtcblxuICAgICAgICAgICAgLy8gQ2FsbGJhY2sgZm9yIGZhaWxlZCAoYWJvcnQgb3IgZXJyb3IpIGNodW5rIHVwbG9hZHM6XG4gICAgICAgICAgICAvLyBjaHVua2ZhaWw6IGZ1bmN0aW9uIChlLCBkYXRhKSB7fSwgLy8gLmJpbmQoJ2ZpbGV1cGxvYWRjaHVua2ZhaWwnLCBmdW5jKTtcblxuICAgICAgICAgICAgLy8gQ2FsbGJhY2sgZm9yIGNvbXBsZXRlZCAoc3VjY2VzcywgYWJvcnQgb3IgZXJyb3IpIGNodW5rIHVwbG9hZCByZXF1ZXN0czpcbiAgICAgICAgICAgIC8vIGNodW5rYWx3YXlzOiBmdW5jdGlvbiAoZSwgZGF0YSkge30sIC8vIC5iaW5kKCdmaWxldXBsb2FkY2h1bmthbHdheXMnLCBmdW5jKTtcblxuICAgICAgICAgICAgLy8gVGhlIHBsdWdpbiBvcHRpb25zIGFyZSB1c2VkIGFzIHNldHRpbmdzIG9iamVjdCBmb3IgdGhlIGFqYXggY2FsbHMuXG4gICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGFyZSBqUXVlcnkgYWpheCBzZXR0aW5ncyByZXF1aXJlZCBmb3IgdGhlIGZpbGUgdXBsb2FkczpcbiAgICAgICAgICAgIHByb2Nlc3NEYXRhOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBmYWxzZSxcbiAgICAgICAgICAgIGNhY2hlOiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEEgbGlzdCBvZiBvcHRpb25zIHRoYXQgcmVxdWlyZSByZWluaXRpYWxpemluZyBldmVudCBsaXN0ZW5lcnMgYW5kL29yXG4gICAgICAgIC8vIHNwZWNpYWwgaW5pdGlhbGl6YXRpb24gY29kZTpcbiAgICAgICAgX3NwZWNpYWxPcHRpb25zOiBbXG4gICAgICAgICAgICAnZmlsZUlucHV0JyxcbiAgICAgICAgICAgICdkcm9wWm9uZScsXG4gICAgICAgICAgICAncGFzdGVab25lJyxcbiAgICAgICAgICAgICdtdWx0aXBhcnQnLFxuICAgICAgICAgICAgJ2ZvcmNlSWZyYW1lVHJhbnNwb3J0J1xuICAgICAgICBdLFxuXG4gICAgICAgIF9ibG9iU2xpY2U6ICQuc3VwcG9ydC5ibG9iU2xpY2UgJiYgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNsaWNlID0gdGhpcy5zbGljZSB8fCB0aGlzLndlYmtpdFNsaWNlIHx8IHRoaXMubW96U2xpY2U7XG4gICAgICAgICAgICByZXR1cm4gc2xpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfQml0cmF0ZVRpbWVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVzdGFtcCA9ICgoRGF0ZS5ub3cpID8gRGF0ZS5ub3coKSA6IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZWQgPSAwO1xuICAgICAgICAgICAgdGhpcy5iaXRyYXRlID0gMDtcbiAgICAgICAgICAgIHRoaXMuZ2V0Qml0cmF0ZSA9IGZ1bmN0aW9uIChub3csIGxvYWRlZCwgaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGltZURpZmYgPSBub3cgLSB0aGlzLnRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYml0cmF0ZSB8fCAhaW50ZXJ2YWwgfHwgdGltZURpZmYgPiBpbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJpdHJhdGUgPSAobG9hZGVkIC0gdGhpcy5sb2FkZWQpICogKDEwMDAgLyB0aW1lRGlmZikgKiA4O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRlZCA9IGxvYWRlZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lc3RhbXAgPSBub3c7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJpdHJhdGU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIF9pc1hIUlVwbG9hZDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiAhb3B0aW9ucy5mb3JjZUlmcmFtZVRyYW5zcG9ydCAmJlxuICAgICAgICAgICAgICAgICgoIW9wdGlvbnMubXVsdGlwYXJ0ICYmICQuc3VwcG9ydC54aHJGaWxlVXBsb2FkKSB8fFxuICAgICAgICAgICAgICAgICQuc3VwcG9ydC54aHJGb3JtRGF0YUZpbGVVcGxvYWQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRGb3JtRGF0YTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBmb3JtRGF0YTtcbiAgICAgICAgICAgIGlmICgkLnR5cGUob3B0aW9ucy5mb3JtRGF0YSkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5mb3JtRGF0YShvcHRpb25zLmZvcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCQuaXNBcnJheShvcHRpb25zLmZvcm1EYXRhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmZvcm1EYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCQudHlwZShvcHRpb25zLmZvcm1EYXRhKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBmb3JtRGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgICQuZWFjaChvcHRpb25zLmZvcm1EYXRhLCBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybURhdGEucHVzaCh7bmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1EYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRUb3RhbDogZnVuY3Rpb24gKGZpbGVzKSB7XG4gICAgICAgICAgICB2YXIgdG90YWwgPSAwO1xuICAgICAgICAgICAgJC5lYWNoKGZpbGVzLCBmdW5jdGlvbiAoaW5kZXgsIGZpbGUpIHtcbiAgICAgICAgICAgICAgICB0b3RhbCArPSBmaWxlLnNpemUgfHwgMTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9pbml0UHJvZ3Jlc3NPYmplY3Q6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHZhciBwcm9ncmVzcyA9IHtcbiAgICAgICAgICAgICAgICBsb2FkZWQ6IDAsXG4gICAgICAgICAgICAgICAgdG90YWw6IDAsXG4gICAgICAgICAgICAgICAgYml0cmF0ZTogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChvYmouX3Byb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgJC5leHRlbmQob2JqLl9wcm9ncmVzcywgcHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYmouX3Byb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2luaXRSZXNwb25zZU9iamVjdDogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgdmFyIHByb3A7XG4gICAgICAgICAgICBpZiAob2JqLl9yZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGZvciAocHJvcCBpbiBvYmouX3Jlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmouX3Jlc3BvbnNlLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb2JqLl9yZXNwb25zZVtwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb2JqLl9yZXNwb25zZSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9vblByb2dyZXNzOiBmdW5jdGlvbiAoZSwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKGUubGVuZ3RoQ29tcHV0YWJsZSkge1xuICAgICAgICAgICAgICAgIHZhciBub3cgPSAoKERhdGUubm93KSA/IERhdGUubm93KCkgOiAobmV3IERhdGUoKSkuZ2V0VGltZSgpKSxcbiAgICAgICAgICAgICAgICAgICAgbG9hZGVkO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLl90aW1lICYmIGRhdGEucHJvZ3Jlc3NJbnRlcnZhbCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKG5vdyAtIGRhdGEuX3RpbWUgPCBkYXRhLnByb2dyZXNzSW50ZXJ2YWwpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBlLmxvYWRlZCAhPT0gZS50b3RhbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGEuX3RpbWUgPSBub3c7XG4gICAgICAgICAgICAgICAgbG9hZGVkID0gTWF0aC5mbG9vcihcbiAgICAgICAgICAgICAgICAgICAgZS5sb2FkZWQgLyBlLnRvdGFsICogKGRhdGEuY2h1bmtTaXplIHx8IGRhdGEuX3Byb2dyZXNzLnRvdGFsKVxuICAgICAgICAgICAgICAgICkgKyAoZGF0YS51cGxvYWRlZEJ5dGVzIHx8IDApO1xuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgZGlmZmVyZW5jZSBmcm9tIHRoZSBwcmV2aW91c2x5IGxvYWRlZCBzdGF0ZVxuICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBnbG9iYWwgbG9hZGVkIGNvdW50ZXI6XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3MubG9hZGVkICs9IChsb2FkZWQgLSBkYXRhLl9wcm9ncmVzcy5sb2FkZWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzLmJpdHJhdGUgPSB0aGlzLl9iaXRyYXRlVGltZXIuZ2V0Qml0cmF0ZShcbiAgICAgICAgICAgICAgICAgICAgbm93LFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9ncmVzcy5sb2FkZWQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuYml0cmF0ZUludGVydmFsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBkYXRhLl9wcm9ncmVzcy5sb2FkZWQgPSBkYXRhLmxvYWRlZCA9IGxvYWRlZDtcbiAgICAgICAgICAgICAgICBkYXRhLl9wcm9ncmVzcy5iaXRyYXRlID0gZGF0YS5iaXRyYXRlID0gZGF0YS5fYml0cmF0ZVRpbWVyLmdldEJpdHJhdGUoXG4gICAgICAgICAgICAgICAgICAgIG5vdyxcbiAgICAgICAgICAgICAgICAgICAgbG9hZGVkLFxuICAgICAgICAgICAgICAgICAgICBkYXRhLmJpdHJhdGVJbnRlcnZhbFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgLy8gVHJpZ2dlciBhIGN1c3RvbSBwcm9ncmVzcyBldmVudCB3aXRoIGEgdG90YWwgZGF0YSBwcm9wZXJ0eSBzZXRcbiAgICAgICAgICAgICAgICAvLyB0byB0aGUgZmlsZSBzaXplKHMpIG9mIHRoZSBjdXJyZW50IHVwbG9hZCBhbmQgYSBsb2FkZWQgZGF0YVxuICAgICAgICAgICAgICAgIC8vIHByb3BlcnR5IGNhbGN1bGF0ZWQgYWNjb3JkaW5nbHk6XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcihcbiAgICAgICAgICAgICAgICAgICAgJ3Byb2dyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgJC5FdmVudCgncHJvZ3Jlc3MnLCB7ZGVsZWdhdGVkRXZlbnQ6IGV9KSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgLy8gVHJpZ2dlciBhIGdsb2JhbCBwcm9ncmVzcyBldmVudCBmb3IgYWxsIGN1cnJlbnQgZmlsZSB1cGxvYWRzLFxuICAgICAgICAgICAgICAgIC8vIGluY2x1ZGluZyBhamF4IGNhbGxzIHF1ZXVlZCBmb3Igc2VxdWVudGlhbCBmaWxlIHVwbG9hZHM6XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcihcbiAgICAgICAgICAgICAgICAgICAgJ3Byb2dyZXNzYWxsJyxcbiAgICAgICAgICAgICAgICAgICAgJC5FdmVudCgncHJvZ3Jlc3NhbGwnLCB7ZGVsZWdhdGVkRXZlbnQ6IGV9KSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9pbml0UHJvZ3Jlc3NMaXN0ZW5lcjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICB4aHIgPSBvcHRpb25zLnhociA/IG9wdGlvbnMueGhyKCkgOiAkLmFqYXhTZXR0aW5ncy54aHIoKTtcbiAgICAgICAgICAgIC8vIEFjY2Vzc3MgdG8gdGhlIG5hdGl2ZSBYSFIgb2JqZWN0IGlzIHJlcXVpcmVkIHRvIGFkZCBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgICAgIC8vIGZvciB0aGUgdXBsb2FkIHByb2dyZXNzIGV2ZW50OlxuICAgICAgICAgICAgaWYgKHhoci51cGxvYWQpIHtcbiAgICAgICAgICAgICAgICAkKHhoci51cGxvYWQpLmJpbmQoJ3Byb2dyZXNzJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9lID0gZS5vcmlnaW5hbEV2ZW50O1xuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHByb2dyZXNzIGV2ZW50IHByb3BlcnRpZXMgZ2V0IGNvcGllZCBvdmVyOlxuICAgICAgICAgICAgICAgICAgICBlLmxlbmd0aENvbXB1dGFibGUgPSBvZS5sZW5ndGhDb21wdXRhYmxlO1xuICAgICAgICAgICAgICAgICAgICBlLmxvYWRlZCA9IG9lLmxvYWRlZDtcbiAgICAgICAgICAgICAgICAgICAgZS50b3RhbCA9IG9lLnRvdGFsO1xuICAgICAgICAgICAgICAgICAgICB0aGF0Ll9vblByb2dyZXNzKGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMueGhyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geGhyO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2lzSW5zdGFuY2VPZjogZnVuY3Rpb24gKHR5cGUsIG9iaikge1xuICAgICAgICAgICAgLy8gQ3Jvc3MtZnJhbWUgaW5zdGFuY2VvZiBjaGVja1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCAnICsgdHlwZSArICddJztcbiAgICAgICAgfSxcblxuICAgICAgICBfaW5pdFhIUkRhdGE6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgZm9ybURhdGEsXG4gICAgICAgICAgICAgICAgZmlsZSA9IG9wdGlvbnMuZmlsZXNbMF0sXG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIG5vbi1tdWx0aXBhcnQgc2V0dGluZyBpZiBub3Qgc3VwcG9ydGVkOlxuICAgICAgICAgICAgICAgIG11bHRpcGFydCA9IG9wdGlvbnMubXVsdGlwYXJ0IHx8ICEkLnN1cHBvcnQueGhyRmlsZVVwbG9hZCxcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWUgPSAkLnR5cGUob3B0aW9ucy5wYXJhbU5hbWUpID09PSAnYXJyYXknID9cbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXJhbU5hbWVbMF0gOiBvcHRpb25zLnBhcmFtTmFtZTtcbiAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVycyA9ICQuZXh0ZW5kKHt9LCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29udGVudFJhbmdlKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5oZWFkZXJzWydDb250ZW50LVJhbmdlJ10gPSBvcHRpb25zLmNvbnRlbnRSYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbXVsdGlwYXJ0IHx8IG9wdGlvbnMuYmxvYiB8fCAhdGhpcy5faXNJbnN0YW5jZU9mKCdGaWxlJywgZmlsZSkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmhlYWRlcnNbJ0NvbnRlbnQtRGlzcG9zaXRpb24nXSA9ICdhdHRhY2htZW50OyBmaWxlbmFtZT1cIicgK1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUkkoZmlsZS5uYW1lKSArICdcIic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW11bHRpcGFydCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuY29udGVudFR5cGUgPSBmaWxlLnR5cGUgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gb3B0aW9ucy5ibG9iIHx8IGZpbGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCQuc3VwcG9ydC54aHJGb3JtRGF0YUZpbGVVcGxvYWQpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wb3N0TWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB3aW5kb3cucG9zdE1lc3NhZ2UgZG9lcyBub3QgYWxsb3cgc2VuZGluZyBGb3JtRGF0YVxuICAgICAgICAgICAgICAgICAgICAvLyBvYmplY3RzLCBzbyB3ZSBqdXN0IGFkZCB0aGUgRmlsZS9CbG9iIG9iamVjdHMgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGZvcm1EYXRhIGFycmF5IGFuZCBsZXQgdGhlIHBvc3RNZXNzYWdlIHdpbmRvd1xuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgdGhlIEZvcm1EYXRhIG9iamVjdCBvdXQgb2YgdGhpcyBhcnJheTpcbiAgICAgICAgICAgICAgICAgICAgZm9ybURhdGEgPSB0aGlzLl9nZXRGb3JtRGF0YShvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYmxvYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybURhdGEucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcGFyYW1OYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLmJsb2JcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKG9wdGlvbnMuZmlsZXMsIGZ1bmN0aW9uIChpbmRleCwgZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAoJC50eXBlKG9wdGlvbnMucGFyYW1OYW1lKSA9PT0gJ2FycmF5JyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXJhbU5hbWVbaW5kZXhdKSB8fCBwYXJhbU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGF0Ll9pc0luc3RhbmNlT2YoJ0Zvcm1EYXRhJywgb3B0aW9ucy5mb3JtRGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhID0gb3B0aW9ucy5mb3JtRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkLmVhY2godGhpcy5fZ2V0Rm9ybURhdGEob3B0aW9ucyksIGZ1bmN0aW9uIChpbmRleCwgZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoZmllbGQubmFtZSwgZmllbGQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYmxvYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKHBhcmFtTmFtZSwgb3B0aW9ucy5ibG9iLCBmaWxlLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKG9wdGlvbnMuZmlsZXMsIGZ1bmN0aW9uIChpbmRleCwgZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgY2hlY2sgYWxsb3dzIHRoZSB0ZXN0cyB0byBydW4gd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGR1bW15IG9iamVjdHM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQuX2lzSW5zdGFuY2VPZignRmlsZScsIGZpbGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll9pc0luc3RhbmNlT2YoJ0Jsb2InLCBmaWxlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoJC50eXBlKG9wdGlvbnMucGFyYW1OYW1lKSA9PT0gJ2FycmF5JyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGFyYW1OYW1lW2luZGV4XSkgfHwgcGFyYW1OYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUudXBsb2FkTmFtZSB8fCBmaWxlLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBmb3JtRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEJsb2IgcmVmZXJlbmNlIGlzIG5vdCBuZWVkZWQgYW55bW9yZSwgZnJlZSBtZW1vcnk6XG4gICAgICAgICAgICBvcHRpb25zLmJsb2IgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9pbml0SWZyYW1lU2V0dGluZ3M6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0SG9zdCA9ICQoJzxhPjwvYT4nKS5wcm9wKCdocmVmJywgb3B0aW9ucy51cmwpLnByb3AoJ2hvc3QnKTtcbiAgICAgICAgICAgIC8vIFNldHRpbmcgdGhlIGRhdGFUeXBlIHRvIGlmcmFtZSBlbmFibGVzIHRoZSBpZnJhbWUgdHJhbnNwb3J0OlxuICAgICAgICAgICAgb3B0aW9ucy5kYXRhVHlwZSA9ICdpZnJhbWUgJyArIChvcHRpb25zLmRhdGFUeXBlIHx8ICcnKTtcbiAgICAgICAgICAgIC8vIFRoZSBpZnJhbWUgdHJhbnNwb3J0IGFjY2VwdHMgYSBzZXJpYWxpemVkIGFycmF5IGFzIGZvcm0gZGF0YTpcbiAgICAgICAgICAgIG9wdGlvbnMuZm9ybURhdGEgPSB0aGlzLl9nZXRGb3JtRGF0YShvcHRpb25zKTtcbiAgICAgICAgICAgIC8vIEFkZCByZWRpcmVjdCB1cmwgdG8gZm9ybSBkYXRhIG9uIGNyb3NzLWRvbWFpbiB1cGxvYWRzOlxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVkaXJlY3QgJiYgdGFyZ2V0SG9zdCAmJiB0YXJnZXRIb3N0ICE9PSBsb2NhdGlvbi5ob3N0KSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5mb3JtRGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogb3B0aW9ucy5yZWRpcmVjdFBhcmFtTmFtZSB8fCAncmVkaXJlY3QnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5yZWRpcmVjdFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9pbml0RGF0YVNldHRpbmdzOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzWEhSVXBsb2FkKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9jaHVua2VkVXBsb2FkKG9wdGlvbnMsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0WEhSRGF0YShvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0UHJvZ3Jlc3NMaXN0ZW5lcihvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucG9zdE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0dGluZyB0aGUgZGF0YVR5cGUgdG8gcG9zdG1lc3NhZ2UgZW5hYmxlcyB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gcG9zdE1lc3NhZ2UgdHJhbnNwb3J0OlxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGFUeXBlID0gJ3Bvc3RtZXNzYWdlICcgKyAob3B0aW9ucy5kYXRhVHlwZSB8fCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0SWZyYW1lU2V0dGluZ3Mob3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldFBhcmFtTmFtZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBmaWxlSW5wdXQgPSAkKG9wdGlvbnMuZmlsZUlucHV0KSxcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWUgPSBvcHRpb25zLnBhcmFtTmFtZTtcbiAgICAgICAgICAgIGlmICghcGFyYW1OYW1lKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lID0gW107XG4gICAgICAgICAgICAgICAgZmlsZUlucHV0LmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSAkKHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGlucHV0LnByb3AoJ25hbWUnKSB8fCAnZmlsZXNbXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gKGlucHV0LnByb3AoJ2ZpbGVzJykgfHwgWzFdKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbU5hbWUucHVzaChuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICghcGFyYW1OYW1lLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbU5hbWUgPSBbZmlsZUlucHV0LnByb3AoJ25hbWUnKSB8fCAnZmlsZXNbXSddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoISQuaXNBcnJheShwYXJhbU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lID0gW3BhcmFtTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1OYW1lO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9pbml0Rm9ybVNldHRpbmdzOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgLy8gUmV0cmlldmUgbWlzc2luZyBvcHRpb25zIGZyb20gdGhlIGlucHV0IGZpZWxkIGFuZCB0aGVcbiAgICAgICAgICAgIC8vIGFzc29jaWF0ZWQgZm9ybSwgaWYgYXZhaWxhYmxlOlxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmZvcm0gfHwgIW9wdGlvbnMuZm9ybS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmZvcm0gPSAkKG9wdGlvbnMuZmlsZUlucHV0LnByb3AoJ2Zvcm0nKSk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGdpdmVuIGZpbGUgaW5wdXQgZG9lc24ndCBoYXZlIGFuIGFzc29jaWF0ZWQgZm9ybSxcbiAgICAgICAgICAgICAgICAvLyB1c2UgdGhlIGRlZmF1bHQgd2lkZ2V0IGZpbGUgaW5wdXQncyBmb3JtOlxuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5mb3JtLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmZvcm0gPSAkKHRoaXMub3B0aW9ucy5maWxlSW5wdXQucHJvcCgnZm9ybScpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zLnBhcmFtTmFtZSA9IHRoaXMuX2dldFBhcmFtTmFtZShvcHRpb25zKTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy51cmwpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnVybCA9IG9wdGlvbnMuZm9ybS5wcm9wKCdhY3Rpb24nKSB8fCBsb2NhdGlvbi5ocmVmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIEhUVFAgcmVxdWVzdCBtZXRob2QgbXVzdCBiZSBcIlBPU1RcIiBvciBcIlBVVFwiOlxuICAgICAgICAgICAgb3B0aW9ucy50eXBlID0gKG9wdGlvbnMudHlwZSB8fFxuICAgICAgICAgICAgICAgICgkLnR5cGUob3B0aW9ucy5mb3JtLnByb3AoJ21ldGhvZCcpKSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5mb3JtLnByb3AoJ21ldGhvZCcpKSB8fCAnJ1xuICAgICAgICAgICAgICAgICkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnR5cGUgIT09ICdQT1NUJyAmJiBvcHRpb25zLnR5cGUgIT09ICdQVVQnICYmXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudHlwZSAhPT0gJ1BBVENIJykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudHlwZSA9ICdQT1NUJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5mb3JtQWNjZXB0Q2hhcnNldCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZm9ybUFjY2VwdENoYXJzZXQgPSBvcHRpb25zLmZvcm0uYXR0cignYWNjZXB0LWNoYXJzZXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0QUpBWFNldHRpbmdzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCBkYXRhKTtcbiAgICAgICAgICAgIHRoaXMuX2luaXRGb3JtU2V0dGluZ3Mob3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLl9pbml0RGF0YVNldHRpbmdzKG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8galF1ZXJ5IDEuNiBkb2Vzbid0IHByb3ZpZGUgLnN0YXRlKCksXG4gICAgICAgIC8vIHdoaWxlIGpRdWVyeSAxLjgrIHJlbW92ZWQgLmlzUmVqZWN0ZWQoKSBhbmQgLmlzUmVzb2x2ZWQoKTpcbiAgICAgICAgX2dldERlZmVycmVkU3RhdGU6IGZ1bmN0aW9uIChkZWZlcnJlZCkge1xuICAgICAgICAgICAgaWYgKGRlZmVycmVkLnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnN0YXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVmZXJyZWQuaXNSZXNvbHZlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdyZXNvbHZlZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVmZXJyZWQuaXNSZWplY3RlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdyZWplY3RlZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ3BlbmRpbmcnO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIE1hcHMganFYSFIgY2FsbGJhY2tzIHRvIHRoZSBlcXVpdmFsZW50XG4gICAgICAgIC8vIG1ldGhvZHMgb2YgdGhlIGdpdmVuIFByb21pc2Ugb2JqZWN0OlxuICAgICAgICBfZW5oYW5jZVByb21pc2U6IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgICAgICBwcm9taXNlLnN1Y2Nlc3MgPSBwcm9taXNlLmRvbmU7XG4gICAgICAgICAgICBwcm9taXNlLmVycm9yID0gcHJvbWlzZS5mYWlsO1xuICAgICAgICAgICAgcHJvbWlzZS5jb21wbGV0ZSA9IHByb21pc2UuYWx3YXlzO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQ3JlYXRlcyBhbmQgcmV0dXJucyBhIFByb21pc2Ugb2JqZWN0IGVuaGFuY2VkIHdpdGhcbiAgICAgICAgLy8gdGhlIGpxWEhSIG1ldGhvZHMgYWJvcnQsIHN1Y2Nlc3MsIGVycm9yIGFuZCBjb21wbGV0ZTpcbiAgICAgICAgX2dldFhIUlByb21pc2U6IGZ1bmN0aW9uIChyZXNvbHZlT3JSZWplY3QsIGNvbnRleHQsIGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBkZmQgPSAkLkRlZmVycmVkKCksXG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9IGRmZC5wcm9taXNlKCk7XG4gICAgICAgICAgICBjb250ZXh0ID0gY29udGV4dCB8fCB0aGlzLm9wdGlvbnMuY29udGV4dCB8fCBwcm9taXNlO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVPclJlamVjdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGRmZC5yZXNvbHZlV2l0aChjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzb2x2ZU9yUmVqZWN0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGRmZC5yZWplY3RXaXRoKGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvbWlzZS5hYm9ydCA9IGRmZC5wcm9taXNlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VuaGFuY2VQcm9taXNlKHByb21pc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEFkZHMgY29udmVuaWVuY2UgbWV0aG9kcyB0byB0aGUgZGF0YSBjYWxsYmFjayBhcmd1bWVudDpcbiAgICAgICAgX2FkZENvbnZlbmllbmNlTWV0aG9kczogZnVuY3Rpb24gKGUsIGRhdGEpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICBnZXRQcm9taXNlID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQuRGVmZXJyZWQoKS5yZXNvbHZlV2l0aCh0aGF0LCBhcmdzKS5wcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRhdGEucHJvY2VzcyA9IGZ1bmN0aW9uIChyZXNvbHZlRnVuYywgcmVqZWN0RnVuYykge1xuICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlRnVuYyB8fCByZWplY3RGdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuX3Byb2Nlc3NRdWV1ZSA9IHRoaXMuX3Byb2Nlc3NRdWV1ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5fcHJvY2Vzc1F1ZXVlIHx8IGdldFByb21pc2UoW3RoaXNdKSkucGlwZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmVycm9yVGhyb3duKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJC5EZWZlcnJlZCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlamVjdFdpdGgodGhhdCwgW2RhdGFdKS5wcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFByb21pc2UoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICApLnBpcGUocmVzb2x2ZUZ1bmMsIHJlamVjdEZ1bmMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvY2Vzc1F1ZXVlIHx8IGdldFByb21pc2UoW3RoaXNdKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkYXRhLnN1Ym1pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSgpICE9PSAncGVuZGluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5qcVhIUiA9IHRoaXMuanFYSFIgPVxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoYXQuX3RyaWdnZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N1Ym1pdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5FdmVudCgnc3VibWl0Jywge2RlbGVnYXRlZEV2ZW50OiBlfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgKSAhPT0gZmFsc2UpICYmIHRoYXQuX29uU2VuZChlLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuanFYSFIgfHwgdGhhdC5fZ2V0WEhSUHJvbWlzZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRhdGEuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuanFYSFIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuanFYSFIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvclRocm93biA9ICdhYm9ydCc7XG4gICAgICAgICAgICAgICAgdGhhdC5fdHJpZ2dlcignZmFpbCcsIG51bGwsIHRoaXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGF0Ll9nZXRYSFJQcm9taXNlKGZhbHNlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkYXRhLnN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmpxWEhSKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0Ll9nZXREZWZlcnJlZFN0YXRlKHRoaXMuanFYSFIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcHJvY2Vzc1F1ZXVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0Ll9nZXREZWZlcnJlZFN0YXRlKHRoaXMuX3Byb2Nlc3NRdWV1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRhdGEucHJvY2Vzc2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXRoaXMuanFYSFIgJiYgdGhpcy5fcHJvY2Vzc1F1ZXVlICYmIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgLl9nZXREZWZlcnJlZFN0YXRlKHRoaXMuX3Byb2Nlc3NRdWV1ZSkgPT09ICdwZW5kaW5nJztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkYXRhLnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9ncmVzcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkYXRhLnJlc3BvbnNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXNwb25zZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gUGFyc2VzIHRoZSBSYW5nZSBoZWFkZXIgZnJvbSB0aGUgc2VydmVyIHJlc3BvbnNlXG4gICAgICAgIC8vIGFuZCByZXR1cm5zIHRoZSB1cGxvYWRlZCBieXRlczpcbiAgICAgICAgX2dldFVwbG9hZGVkQnl0ZXM6IGZ1bmN0aW9uIChqcVhIUikge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoJ1JhbmdlJyksXG4gICAgICAgICAgICAgICAgcGFydHMgPSByYW5nZSAmJiByYW5nZS5zcGxpdCgnLScpLFxuICAgICAgICAgICAgICAgIHVwcGVyQnl0ZXNQb3MgPSBwYXJ0cyAmJiBwYXJ0cy5sZW5ndGggPiAxICYmXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KHBhcnRzWzFdLCAxMCk7XG4gICAgICAgICAgICByZXR1cm4gdXBwZXJCeXRlc1BvcyAmJiB1cHBlckJ5dGVzUG9zICsgMTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBVcGxvYWRzIGEgZmlsZSBpbiBtdWx0aXBsZSwgc2VxdWVudGlhbCByZXF1ZXN0c1xuICAgICAgICAvLyBieSBzcGxpdHRpbmcgdGhlIGZpbGUgdXAgaW4gbXVsdGlwbGUgYmxvYiBjaHVua3MuXG4gICAgICAgIC8vIElmIHRoZSBzZWNvbmQgcGFyYW1ldGVyIGlzIHRydWUsIG9ubHkgdGVzdHMgaWYgdGhlIGZpbGVcbiAgICAgICAgLy8gc2hvdWxkIGJlIHVwbG9hZGVkIGluIGNodW5rcywgYnV0IGRvZXMgbm90IGludm9rZSBhbnlcbiAgICAgICAgLy8gdXBsb2FkIHJlcXVlc3RzOlxuICAgICAgICBfY2h1bmtlZFVwbG9hZDogZnVuY3Rpb24gKG9wdGlvbnMsIHRlc3RPbmx5KSB7XG4gICAgICAgICAgICBvcHRpb25zLnVwbG9hZGVkQnl0ZXMgPSBvcHRpb25zLnVwbG9hZGVkQnl0ZXMgfHwgMDtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICBmaWxlID0gb3B0aW9ucy5maWxlc1swXSxcbiAgICAgICAgICAgICAgICBmcyA9IGZpbGUuc2l6ZSxcbiAgICAgICAgICAgICAgICB1YiA9IG9wdGlvbnMudXBsb2FkZWRCeXRlcyxcbiAgICAgICAgICAgICAgICBtY3MgPSBvcHRpb25zLm1heENodW5rU2l6ZSB8fCBmcyxcbiAgICAgICAgICAgICAgICBzbGljZSA9IHRoaXMuX2Jsb2JTbGljZSxcbiAgICAgICAgICAgICAgICBkZmQgPSAkLkRlZmVycmVkKCksXG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9IGRmZC5wcm9taXNlKCksXG4gICAgICAgICAgICAgICAganFYSFIsXG4gICAgICAgICAgICAgICAgdXBsb2FkO1xuICAgICAgICAgICAgaWYgKCEodGhpcy5faXNYSFJVcGxvYWQob3B0aW9ucykgJiYgc2xpY2UgJiYgKHViIHx8IG1jcyA8IGZzKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRlc3RPbmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodWIgPj0gZnMpIHtcbiAgICAgICAgICAgICAgICBmaWxlLmVycm9yID0gb3B0aW9ucy5pMThuKCd1cGxvYWRlZEJ5dGVzJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFhIUlByb21pc2UoXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIFtudWxsLCAnZXJyb3InLCBmaWxlLmVycm9yXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgY2h1bmsgdXBsb2FkIG1ldGhvZDpcbiAgICAgICAgICAgIHVwbG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBDbG9uZSB0aGUgb3B0aW9ucyBvYmplY3QgZm9yIGVhY2ggY2h1bmsgdXBsb2FkOlxuICAgICAgICAgICAgICAgIHZhciBvID0gJC5leHRlbmQoe30sIG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TG9hZGVkID0gby5fcHJvZ3Jlc3MubG9hZGVkO1xuICAgICAgICAgICAgICAgIG8uYmxvYiA9IHNsaWNlLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgICAgICAgICAgIHViLFxuICAgICAgICAgICAgICAgICAgICB1YiArIG1jcyxcbiAgICAgICAgICAgICAgICAgICAgZmlsZS50eXBlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSB0aGUgY3VycmVudCBjaHVuayBzaXplLCBhcyB0aGUgYmxvYiBpdHNlbGZcbiAgICAgICAgICAgICAgICAvLyB3aWxsIGJlIGRlcmVmZXJlbmNlZCBhZnRlciBkYXRhIHByb2Nlc3Npbmc6XG4gICAgICAgICAgICAgICAgby5jaHVua1NpemUgPSBvLmJsb2Iuc2l6ZTtcbiAgICAgICAgICAgICAgICAvLyBFeHBvc2UgdGhlIGNodW5rIGJ5dGVzIHBvc2l0aW9uIHJhbmdlOlxuICAgICAgICAgICAgICAgIG8uY29udGVudFJhbmdlID0gJ2J5dGVzICcgKyB1YiArICctJyArXG4gICAgICAgICAgICAgICAgICAgICh1YiArIG8uY2h1bmtTaXplIC0gMSkgKyAnLycgKyBmcztcbiAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIHRoZSB1cGxvYWQgZGF0YSAodGhlIGJsb2IgYW5kIHBvdGVudGlhbCBmb3JtIGRhdGEpOlxuICAgICAgICAgICAgICAgIHRoYXQuX2luaXRYSFJEYXRhKG8pO1xuICAgICAgICAgICAgICAgIC8vIEFkZCBwcm9ncmVzcyBsaXN0ZW5lcnMgZm9yIHRoaXMgY2h1bmsgdXBsb2FkOlxuICAgICAgICAgICAgICAgIHRoYXQuX2luaXRQcm9ncmVzc0xpc3RlbmVyKG8pO1xuICAgICAgICAgICAgICAgIGpxWEhSID0gKCh0aGF0Ll90cmlnZ2VyKCdjaHVua3NlbmQnLCBudWxsLCBvKSAhPT0gZmFsc2UgJiYgJC5hamF4KG8pKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fZ2V0WEhSUHJvbWlzZShmYWxzZSwgby5jb250ZXh0KSlcbiAgICAgICAgICAgICAgICAgICAgLmRvbmUoZnVuY3Rpb24gKHJlc3VsdCwgdGV4dFN0YXR1cywganFYSFIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHViID0gdGhhdC5fZ2V0VXBsb2FkZWRCeXRlcyhqcVhIUikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodWIgKyBvLmNodW5rU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBwcm9ncmVzcyBldmVudCBpZiBubyBmaW5hbCBwcm9ncmVzcyBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCBsb2FkZWQgZXF1YWxpbmcgdG90YWwgaGFzIGJlZW4gdHJpZ2dlcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgdGhpcyBjaHVuazpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TG9hZGVkICsgby5jaHVua1NpemUgLSBvLl9wcm9ncmVzcy5sb2FkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll9vblByb2dyZXNzKCQuRXZlbnQoJ3Byb2dyZXNzJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGhDb21wdXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkZWQ6IHViIC0gby51cGxvYWRlZEJ5dGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbDogdWIgLSBvLnVwbG9hZGVkQnl0ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnVwbG9hZGVkQnl0ZXMgPSBvLnVwbG9hZGVkQnl0ZXMgPSB1YjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG8ucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgby50ZXh0U3RhdHVzID0gdGV4dFN0YXR1cztcbiAgICAgICAgICAgICAgICAgICAgICAgIG8uanFYSFIgPSBqcVhIUjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX3RyaWdnZXIoJ2NodW5rZG9uZScsIG51bGwsIG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fdHJpZ2dlcignY2h1bmthbHdheXMnLCBudWxsLCBvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1YiA8IGZzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlsZSB1cGxvYWQgbm90IHlldCBjb21wbGV0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb250aW51ZSB3aXRoIHRoZSBuZXh0IGNodW5rOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZmQucmVzb2x2ZVdpdGgoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8uY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3Jlc3VsdCwgdGV4dFN0YXR1cywganFYSFJdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmZhaWwoZnVuY3Rpb24gKGpxWEhSLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgby5qcVhIUiA9IGpxWEhSO1xuICAgICAgICAgICAgICAgICAgICAgICAgby50ZXh0U3RhdHVzID0gdGV4dFN0YXR1cztcbiAgICAgICAgICAgICAgICAgICAgICAgIG8uZXJyb3JUaHJvd24gPSBlcnJvclRocm93bjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX3RyaWdnZXIoJ2NodW5rZmFpbCcsIG51bGwsIG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fdHJpZ2dlcignY2h1bmthbHdheXMnLCBudWxsLCBvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRmZC5yZWplY3RXaXRoKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8uY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duXVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fZW5oYW5jZVByb21pc2UocHJvbWlzZSk7XG4gICAgICAgICAgICBwcm9taXNlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBqcVhIUi5hYm9ydCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHVwbG9hZCgpO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2JlZm9yZVNlbmQ6IGZ1bmN0aW9uIChlLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fYWN0aXZlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIHN0YXJ0IGNhbGxiYWNrIGlzIHRyaWdnZXJlZCB3aGVuIGFuIHVwbG9hZCBzdGFydHNcbiAgICAgICAgICAgICAgICAvLyBhbmQgbm8gb3RoZXIgdXBsb2FkcyBhcmUgY3VycmVudGx5IHJ1bm5pbmcsXG4gICAgICAgICAgICAgICAgLy8gZXF1aXZhbGVudCB0byB0aGUgZ2xvYmFsIGFqYXhTdGFydCBldmVudDpcbiAgICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyKCdzdGFydCcpO1xuICAgICAgICAgICAgICAgIC8vIFNldCB0aW1lciBmb3IgZ2xvYmFsIGJpdHJhdGUgcHJvZ3Jlc3MgY2FsY3VsYXRpb246XG4gICAgICAgICAgICAgICAgdGhpcy5fYml0cmF0ZVRpbWVyID0gbmV3IHRoaXMuX0JpdHJhdGVUaW1lcigpO1xuICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBnbG9iYWwgcHJvZ3Jlc3MgdmFsdWVzOlxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzLmxvYWRlZCA9IHRoaXMuX3Byb2dyZXNzLnRvdGFsID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9ncmVzcy5iaXRyYXRlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgY29udGFpbmVyIG9iamVjdHMgZm9yIHRoZSAucmVzcG9uc2UoKSBhbmRcbiAgICAgICAgICAgIC8vIC5wcm9ncmVzcygpIG1ldGhvZHMgb24gdGhlIGRhdGEgb2JqZWN0IGFyZSBhdmFpbGFibGVcbiAgICAgICAgICAgIC8vIGFuZCByZXNldCB0byB0aGVpciBpbml0aWFsIHN0YXRlOlxuICAgICAgICAgICAgdGhpcy5faW5pdFJlc3BvbnNlT2JqZWN0KGRhdGEpO1xuICAgICAgICAgICAgdGhpcy5faW5pdFByb2dyZXNzT2JqZWN0KGRhdGEpO1xuICAgICAgICAgICAgZGF0YS5fcHJvZ3Jlc3MubG9hZGVkID0gZGF0YS5sb2FkZWQgPSBkYXRhLnVwbG9hZGVkQnl0ZXMgfHwgMDtcbiAgICAgICAgICAgIGRhdGEuX3Byb2dyZXNzLnRvdGFsID0gZGF0YS50b3RhbCA9IHRoaXMuX2dldFRvdGFsKGRhdGEuZmlsZXMpIHx8IDE7XG4gICAgICAgICAgICBkYXRhLl9wcm9ncmVzcy5iaXRyYXRlID0gZGF0YS5iaXRyYXRlID0gMDtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZSArPSAxO1xuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgZ2xvYmFsIHByb2dyZXNzIHZhbHVlczpcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzLmxvYWRlZCArPSBkYXRhLmxvYWRlZDtcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzLnRvdGFsICs9IGRhdGEudG90YWw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX29uRG9uZTogZnVuY3Rpb24gKHJlc3VsdCwgdGV4dFN0YXR1cywganFYSFIsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciB0b3RhbCA9IG9wdGlvbnMuX3Byb2dyZXNzLnRvdGFsLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gb3B0aW9ucy5fcmVzcG9uc2U7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5fcHJvZ3Jlc3MubG9hZGVkIDwgdG90YWwpIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBwcm9ncmVzcyBldmVudCBpZiBubyBmaW5hbCBwcm9ncmVzcyBldmVudFxuICAgICAgICAgICAgICAgIC8vIHdpdGggbG9hZGVkIGVxdWFsaW5nIHRvdGFsIGhhcyBiZWVuIHRyaWdnZXJlZDpcbiAgICAgICAgICAgICAgICB0aGlzLl9vblByb2dyZXNzKCQuRXZlbnQoJ3Byb2dyZXNzJywge1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGhDb21wdXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBsb2FkZWQ6IHRvdGFsLFxuICAgICAgICAgICAgICAgICAgICB0b3RhbDogdG90YWxcbiAgICAgICAgICAgICAgICB9KSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNwb25zZS5yZXN1bHQgPSBvcHRpb25zLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgICAgIHJlc3BvbnNlLnRleHRTdGF0dXMgPSBvcHRpb25zLnRleHRTdGF0dXMgPSB0ZXh0U3RhdHVzO1xuICAgICAgICAgICAgcmVzcG9uc2UuanFYSFIgPSBvcHRpb25zLmpxWEhSID0ganFYSFI7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyKCdkb25lJywgbnVsbCwgb3B0aW9ucyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX29uRmFpbDogZnVuY3Rpb24gKGpxWEhSLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93biwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gb3B0aW9ucy5fcmVzcG9uc2U7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5yZWNhbGN1bGF0ZVByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBmYWlsZWQgKGVycm9yIG9yIGFib3J0KSBmaWxlIHVwbG9hZCBmcm9tXG4gICAgICAgICAgICAgICAgLy8gdGhlIGdsb2JhbCBwcm9ncmVzcyBjYWxjdWxhdGlvbjpcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9ncmVzcy5sb2FkZWQgLT0gb3B0aW9ucy5fcHJvZ3Jlc3MubG9hZGVkO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzLnRvdGFsIC09IG9wdGlvbnMuX3Byb2dyZXNzLnRvdGFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzcG9uc2UuanFYSFIgPSBvcHRpb25zLmpxWEhSID0ganFYSFI7XG4gICAgICAgICAgICByZXNwb25zZS50ZXh0U3RhdHVzID0gb3B0aW9ucy50ZXh0U3RhdHVzID0gdGV4dFN0YXR1cztcbiAgICAgICAgICAgIHJlc3BvbnNlLmVycm9yVGhyb3duID0gb3B0aW9ucy5lcnJvclRocm93biA9IGVycm9yVGhyb3duO1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcignZmFpbCcsIG51bGwsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9vbkFsd2F5czogZnVuY3Rpb24gKGpxWEhSb3JSZXN1bHQsIHRleHRTdGF0dXMsIGpxWEhSb3JFcnJvciwgb3B0aW9ucykge1xuICAgICAgICAgICAgLy8ganFYSFJvclJlc3VsdCwgdGV4dFN0YXR1cyBhbmQganFYSFJvckVycm9yIGFyZSBhZGRlZCB0byB0aGVcbiAgICAgICAgICAgIC8vIG9wdGlvbnMgb2JqZWN0IHZpYSBkb25lIGFuZCBmYWlsIGNhbGxiYWNrc1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcignYWx3YXlzJywgbnVsbCwgb3B0aW9ucyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX29uU2VuZDogZnVuY3Rpb24gKGUsIGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghZGF0YS5zdWJtaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRDb252ZW5pZW5jZU1ldGhvZHMoZSwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICAgICAganFYSFIsXG4gICAgICAgICAgICAgICAgYWJvcnRlZCxcbiAgICAgICAgICAgICAgICBzbG90LFxuICAgICAgICAgICAgICAgIHBpcGUsXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHRoYXQuX2dldEFKQVhTZXR0aW5ncyhkYXRhKSxcbiAgICAgICAgICAgICAgICBzZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGF0Ll9zZW5kaW5nICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCB0aW1lciBmb3IgYml0cmF0ZSBwcm9ncmVzcyBjYWxjdWxhdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5fYml0cmF0ZVRpbWVyID0gbmV3IHRoYXQuX0JpdHJhdGVUaW1lcigpO1xuICAgICAgICAgICAgICAgICAgICBqcVhIUiA9IGpxWEhSIHx8IChcbiAgICAgICAgICAgICAgICAgICAgICAgICgoYWJvcnRlZCB8fCB0aGF0Ll90cmlnZ2VyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLkV2ZW50KCdzZW5kJywge2RlbGVnYXRlZEV2ZW50OiBlfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgKSA9PT0gZmFsc2UpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll9nZXRYSFJQcm9taXNlKGZhbHNlLCBvcHRpb25zLmNvbnRleHQsIGFib3J0ZWQpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fY2h1bmtlZFVwbG9hZChvcHRpb25zKSB8fCAkLmFqYXgob3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgKS5kb25lKGZ1bmN0aW9uIChyZXN1bHQsIHRleHRTdGF0dXMsIGpxWEhSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll9vbkRvbmUocmVzdWx0LCB0ZXh0U3RhdHVzLCBqcVhIUiwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH0pLmZhaWwoZnVuY3Rpb24gKGpxWEhSLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fb25GYWlsKGpxWEhSLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93biwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH0pLmFsd2F5cyhmdW5jdGlvbiAoanFYSFJvclJlc3VsdCwgdGV4dFN0YXR1cywganFYSFJvckVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll9vbkFsd2F5cyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcVhIUm9yUmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRTdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganFYSFJvckVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll9zZW5kaW5nIC09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll9hY3RpdmUgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmxpbWl0Q29uY3VycmVudFVwbG9hZHMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5saW1pdENvbmN1cnJlbnRVcGxvYWRzID4gdGhhdC5fc2VuZGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSBuZXh0IHF1ZXVlZCB1cGxvYWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCBoYXMgbm90IGJlZW4gYWJvcnRlZDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dFNsb3QgPSB0aGF0Ll9zbG90cy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0U2xvdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5fZ2V0RGVmZXJyZWRTdGF0ZShuZXh0U2xvdCkgPT09ICdwZW5kaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFNsb3QucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFNsb3QgPSB0aGF0Ll9zbG90cy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0Ll9hY3RpdmUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgc3RvcCBjYWxsYmFjayBpcyB0cmlnZ2VyZWQgd2hlbiBhbGwgdXBsb2FkcyBoYXZlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmVlbiBjb21wbGV0ZWQsIGVxdWl2YWxlbnQgdG8gdGhlIGdsb2JhbCBhamF4U3RvcCBldmVudDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll90cmlnZ2VyKCdzdG9wJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ganFYSFI7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX2JlZm9yZVNlbmQoZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNlcXVlbnRpYWxVcGxvYWRzIHx8XG4gICAgICAgICAgICAgICAgICAgICh0aGlzLm9wdGlvbnMubGltaXRDb25jdXJyZW50VXBsb2FkcyAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMubGltaXRDb25jdXJyZW50VXBsb2FkcyA8PSB0aGlzLl9zZW5kaW5nKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGltaXRDb25jdXJyZW50VXBsb2FkcyA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2xvdCA9ICQuRGVmZXJyZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2xvdHMucHVzaChzbG90KTtcbiAgICAgICAgICAgICAgICAgICAgcGlwZSA9IHNsb3QucGlwZShzZW5kKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXF1ZW5jZSA9IHRoaXMuX3NlcXVlbmNlLnBpcGUoc2VuZCwgc2VuZCk7XG4gICAgICAgICAgICAgICAgICAgIHBpcGUgPSB0aGlzLl9zZXF1ZW5jZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBwaXBlZCBQcm9taXNlIG9iamVjdCwgZW5oYW5jZWQgd2l0aCBhbiBhYm9ydCBtZXRob2QsXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggaXMgZGVsZWdhdGVkIHRvIHRoZSBqcVhIUiBvYmplY3Qgb2YgdGhlIGN1cnJlbnQgdXBsb2FkLFxuICAgICAgICAgICAgICAgIC8vIGFuZCBqcVhIUiBjYWxsYmFja3MgbWFwcGVkIHRvIHRoZSBlcXVpdmFsZW50IFByb21pc2UgbWV0aG9kczpcbiAgICAgICAgICAgICAgICBwaXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBhYm9ydGVkID0gW3VuZGVmaW5lZCwgJ2Fib3J0JywgJ2Fib3J0J107XG4gICAgICAgICAgICAgICAgICAgIGlmICghanFYSFIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzbG90KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xvdC5yZWplY3RXaXRoKG9wdGlvbnMuY29udGV4dCwgYWJvcnRlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VuZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBqcVhIUi5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VuaGFuY2VQcm9taXNlKHBpcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlbmQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfb25BZGQ6IGZ1bmN0aW9uIChlLCBkYXRhKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gJC5leHRlbmQoe30sIHRoaXMub3B0aW9ucywgZGF0YSksXG4gICAgICAgICAgICAgICAgZmlsZXMgPSBkYXRhLmZpbGVzLFxuICAgICAgICAgICAgICAgIGZpbGVzTGVuZ3RoID0gZmlsZXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGxpbWl0ID0gb3B0aW9ucy5saW1pdE11bHRpRmlsZVVwbG9hZHMsXG4gICAgICAgICAgICAgICAgbGltaXRTaXplID0gb3B0aW9ucy5saW1pdE11bHRpRmlsZVVwbG9hZFNpemUsXG4gICAgICAgICAgICAgICAgb3ZlcmhlYWQgPSBvcHRpb25zLmxpbWl0TXVsdGlGaWxlVXBsb2FkU2l6ZU92ZXJoZWFkLFxuICAgICAgICAgICAgICAgIGJhdGNoU2l6ZSA9IDAsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lID0gdGhpcy5fZ2V0UGFyYW1OYW1lKG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZVNldCxcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWVTbGljZSxcbiAgICAgICAgICAgICAgICBmaWxlU2V0LFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgICBpZiAobGltaXRTaXplICYmICghZmlsZXNMZW5ndGggfHwgZmlsZXNbMF0uc2l6ZSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgIGxpbWl0U2l6ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKG9wdGlvbnMuc2luZ2xlRmlsZVVwbG9hZHMgfHwgbGltaXQgfHwgbGltaXRTaXplKSB8fFxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5faXNYSFJVcGxvYWQob3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICBmaWxlU2V0ID0gW2ZpbGVzXTtcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWVTZXQgPSBbcGFyYW1OYW1lXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIShvcHRpb25zLnNpbmdsZUZpbGVVcGxvYWRzIHx8IGxpbWl0U2l6ZSkgJiYgbGltaXQpIHtcbiAgICAgICAgICAgICAgICBmaWxlU2V0ID0gW107XG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lU2V0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGZpbGVzTGVuZ3RoOyBpICs9IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVTZXQucHVzaChmaWxlcy5zbGljZShpLCBpICsgbGltaXQpKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lU2xpY2UgPSBwYXJhbU5hbWUuc2xpY2UoaSwgaSArIGxpbWl0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJhbU5hbWVTbGljZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtTmFtZVNsaWNlID0gcGFyYW1OYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtTmFtZVNldC5wdXNoKHBhcmFtTmFtZVNsaWNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFvcHRpb25zLnNpbmdsZUZpbGVVcGxvYWRzICYmIGxpbWl0U2l6ZSkge1xuICAgICAgICAgICAgICAgIGZpbGVTZXQgPSBbXTtcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWVTZXQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZmlsZXNMZW5ndGg7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgICAgICBiYXRjaFNpemUgKz0gZmlsZXNbaV0uc2l6ZSArIG92ZXJoZWFkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSArIDEgPT09IGZpbGVzTGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKChiYXRjaFNpemUgKyBmaWxlc1tpICsgMV0uc2l6ZSArIG92ZXJoZWFkKSA+IGxpbWl0U2l6ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobGltaXQgJiYgaSArIDEgLSBqID49IGxpbWl0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZVNldC5wdXNoKGZpbGVzLnNsaWNlKGosIGkgKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbU5hbWVTbGljZSA9IHBhcmFtTmFtZS5zbGljZShqLCBpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmFtTmFtZVNsaWNlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtTmFtZVNsaWNlID0gcGFyYW1OYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lU2V0LnB1c2gocGFyYW1OYW1lU2xpY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaiA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmF0Y2hTaXplID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lU2V0ID0gcGFyYW1OYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YS5vcmlnaW5hbEZpbGVzID0gZmlsZXM7XG4gICAgICAgICAgICAkLmVhY2goZmlsZVNldCB8fCBmaWxlcywgZnVuY3Rpb24gKGluZGV4LCBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0RhdGEgPSAkLmV4dGVuZCh7fSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgbmV3RGF0YS5maWxlcyA9IGZpbGVTZXQgPyBlbGVtZW50IDogW2VsZW1lbnRdO1xuICAgICAgICAgICAgICAgIG5ld0RhdGEucGFyYW1OYW1lID0gcGFyYW1OYW1lU2V0W2luZGV4XTtcbiAgICAgICAgICAgICAgICB0aGF0Ll9pbml0UmVzcG9uc2VPYmplY3QobmV3RGF0YSk7XG4gICAgICAgICAgICAgICAgdGhhdC5faW5pdFByb2dyZXNzT2JqZWN0KG5ld0RhdGEpO1xuICAgICAgICAgICAgICAgIHRoYXQuX2FkZENvbnZlbmllbmNlTWV0aG9kcyhlLCBuZXdEYXRhKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGF0Ll90cmlnZ2VyKFxuICAgICAgICAgICAgICAgICAgICAnYWRkJyxcbiAgICAgICAgICAgICAgICAgICAgJC5FdmVudCgnYWRkJywge2RlbGVnYXRlZEV2ZW50OiBlfSksXG4gICAgICAgICAgICAgICAgICAgIG5ld0RhdGFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3JlcGxhY2VGaWxlSW5wdXQ6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgdmFyIGlucHV0Q2xvbmUgPSBpbnB1dC5jbG9uZSh0cnVlKTtcbiAgICAgICAgICAgICQoJzxmb3JtPjwvZm9ybT4nKS5hcHBlbmQoaW5wdXRDbG9uZSlbMF0ucmVzZXQoKTtcbiAgICAgICAgICAgIC8vIERldGFjaGluZyBhbGxvd3MgdG8gaW5zZXJ0IHRoZSBmaWxlSW5wdXQgb24gYW5vdGhlciBmb3JtXG4gICAgICAgICAgICAvLyB3aXRob3V0IGxvb3NpbmcgdGhlIGZpbGUgaW5wdXQgdmFsdWU6XG4gICAgICAgICAgICBpbnB1dC5hZnRlcihpbnB1dENsb25lKS5kZXRhY2goKTtcbiAgICAgICAgICAgIC8vIEF2b2lkIG1lbW9yeSBsZWFrcyB3aXRoIHRoZSBkZXRhY2hlZCBmaWxlIGlucHV0OlxuICAgICAgICAgICAgJC5jbGVhbkRhdGEoaW5wdXQudW5iaW5kKCdyZW1vdmUnKSk7XG4gICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSBvcmlnaW5hbCBmaWxlIGlucHV0IGVsZW1lbnQgaW4gdGhlIGZpbGVJbnB1dFxuICAgICAgICAgICAgLy8gZWxlbWVudHMgc2V0IHdpdGggdGhlIGNsb25lLCB3aGljaCBoYXMgYmVlbiBjb3BpZWQgaW5jbHVkaW5nXG4gICAgICAgICAgICAvLyBldmVudCBoYW5kbGVyczpcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5maWxlSW5wdXQgPSB0aGlzLm9wdGlvbnMuZmlsZUlucHV0Lm1hcChmdW5jdGlvbiAoaSwgZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWwgPT09IGlucHV0WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dENsb25lWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIElmIHRoZSB3aWRnZXQgaGFzIGJlZW4gaW5pdGlhbGl6ZWQgb24gdGhlIGZpbGUgaW5wdXQgaXRzZWxmLFxuICAgICAgICAgICAgLy8gb3ZlcnJpZGUgdGhpcy5lbGVtZW50IHdpdGggdGhlIGZpbGUgaW5wdXQgY2xvbmU6XG4gICAgICAgICAgICBpZiAoaW5wdXRbMF0gPT09IHRoaXMuZWxlbWVudFswXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IGlucHV0Q2xvbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2hhbmRsZUZpbGVUcmVlRW50cnk6IGZ1bmN0aW9uIChlbnRyeSwgcGF0aCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGRmZCA9ICQuRGVmZXJyZWQoKSxcbiAgICAgICAgICAgICAgICBlcnJvckhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSAmJiAhZS5lbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5lbnRyeSA9IGVudHJ5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlICQud2hlbiByZXR1cm5zIGltbWVkaWF0ZWx5IGlmIG9uZVxuICAgICAgICAgICAgICAgICAgICAvLyBEZWZlcnJlZCBpcyByZWplY3RlZCwgd2UgdXNlIHJlc29sdmUgaW5zdGVhZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBhbGxvd3MgdmFsaWQgZmlsZXMgYW5kIGludmFsaWQgaXRlbXNcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gYmUgcmV0dXJuZWQgdG9nZXRoZXIgaW4gb25lIHNldDpcbiAgICAgICAgICAgICAgICAgICAgZGZkLnJlc29sdmUoW2VdKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRpclJlYWRlcjtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoIHx8ICcnO1xuICAgICAgICAgICAgaWYgKGVudHJ5LmlzRmlsZSkge1xuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5fZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBDaHJvbWUgYnVnICMxNDk3MzVcbiAgICAgICAgICAgICAgICAgICAgZW50cnkuX2ZpbGUucmVsYXRpdmVQYXRoID0gcGF0aDtcbiAgICAgICAgICAgICAgICAgICAgZGZkLnJlc29sdmUoZW50cnkuX2ZpbGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVudHJ5LmZpbGUoZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUucmVsYXRpdmVQYXRoID0gcGF0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRmZC5yZXNvbHZlKGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICB9LCBlcnJvckhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZW50cnkuaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgICAgICAgICBkaXJSZWFkZXIgPSBlbnRyeS5jcmVhdGVSZWFkZXIoKTtcbiAgICAgICAgICAgICAgICBkaXJSZWFkZXIucmVhZEVudHJpZXMoZnVuY3Rpb24gKGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5faGFuZGxlRmlsZVRyZWVFbnRyaWVzKFxuICAgICAgICAgICAgICAgICAgICAgICAgZW50cmllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggKyBlbnRyeS5uYW1lICsgJy8nXG4gICAgICAgICAgICAgICAgICAgICkuZG9uZShmdW5jdGlvbiAoZmlsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRmZC5yZXNvbHZlKGZpbGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfSkuZmFpbChlcnJvckhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIH0sIGVycm9ySGFuZGxlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFJldHVybiBhbiBlbXB5IGxpc3QgZm9yIGZpbGUgc3lzdGVtIGl0ZW1zXG4gICAgICAgICAgICAgICAgLy8gb3RoZXIgdGhhbiBmaWxlcyBvciBkaXJlY3RvcmllczpcbiAgICAgICAgICAgICAgICBkZmQucmVzb2x2ZShbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGZkLnByb21pc2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfaGFuZGxlRmlsZVRyZWVFbnRyaWVzOiBmdW5jdGlvbiAoZW50cmllcywgcGF0aCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuICQud2hlbi5hcHBseShcbiAgICAgICAgICAgICAgICAkLFxuICAgICAgICAgICAgICAgICQubWFwKGVudHJpZXMsIGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5faGFuZGxlRmlsZVRyZWVFbnRyeShlbnRyeSwgcGF0aCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICkucGlwZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIFtdLFxuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldERyb3BwZWRGaWxlczogZnVuY3Rpb24gKGRhdGFUcmFuc2Zlcikge1xuICAgICAgICAgICAgZGF0YVRyYW5zZmVyID0gZGF0YVRyYW5zZmVyIHx8IHt9O1xuICAgICAgICAgICAgdmFyIGl0ZW1zID0gZGF0YVRyYW5zZmVyLml0ZW1zO1xuICAgICAgICAgICAgaWYgKGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCAmJiAoaXRlbXNbMF0ud2Via2l0R2V0QXNFbnRyeSB8fFxuICAgICAgICAgICAgICAgICAgICBpdGVtc1swXS5nZXRBc0VudHJ5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVGaWxlVHJlZUVudHJpZXMoXG4gICAgICAgICAgICAgICAgICAgICQubWFwKGl0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ud2Via2l0R2V0QXNFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5ID0gaXRlbS53ZWJraXRHZXRBc0VudHJ5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIENocm9tZSBidWcgIzE0OTczNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkuX2ZpbGUgPSBpdGVtLmdldEFzRmlsZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5nZXRBc0VudHJ5KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkLkRlZmVycmVkKCkucmVzb2x2ZShcbiAgICAgICAgICAgICAgICAkLm1ha2VBcnJheShkYXRhVHJhbnNmZXIuZmlsZXMpXG4gICAgICAgICAgICApLnByb21pc2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0U2luZ2xlRmlsZUlucHV0RmlsZXM6IGZ1bmN0aW9uIChmaWxlSW5wdXQpIHtcbiAgICAgICAgICAgIGZpbGVJbnB1dCA9ICQoZmlsZUlucHV0KTtcbiAgICAgICAgICAgIHZhciBlbnRyaWVzID0gZmlsZUlucHV0LnByb3AoJ3dlYmtpdEVudHJpZXMnKSB8fFxuICAgICAgICAgICAgICAgICAgICBmaWxlSW5wdXQucHJvcCgnZW50cmllcycpLFxuICAgICAgICAgICAgICAgIGZpbGVzLFxuICAgICAgICAgICAgICAgIHZhbHVlO1xuICAgICAgICAgICAgaWYgKGVudHJpZXMgJiYgZW50cmllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlRmlsZVRyZWVFbnRyaWVzKGVudHJpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsZXMgPSAkLm1ha2VBcnJheShmaWxlSW5wdXQucHJvcCgnZmlsZXMnKSk7XG4gICAgICAgICAgICBpZiAoIWZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZmlsZUlucHV0LnByb3AoJ3ZhbHVlJyk7XG4gICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJC5EZWZlcnJlZCgpLnJlc29sdmUoW10pLnByb21pc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGZpbGVzIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUsIHRoZSBicm93c2VyIGRvZXMgbm90XG4gICAgICAgICAgICAgICAgLy8gc3VwcG9ydCB0aGUgRmlsZSBBUEkgYW5kIHdlIGFkZCBhIHBzZXVkbyBGaWxlIG9iamVjdCB3aXRoXG4gICAgICAgICAgICAgICAgLy8gdGhlIGlucHV0IHZhbHVlIGFzIG5hbWUgd2l0aCBwYXRoIGluZm9ybWF0aW9uIHJlbW92ZWQ6XG4gICAgICAgICAgICAgICAgZmlsZXMgPSBbe25hbWU6IHZhbHVlLnJlcGxhY2UoL14uKlxcXFwvLCAnJyl9XTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlsZXNbMF0ubmFtZSA9PT0gdW5kZWZpbmVkICYmIGZpbGVzWzBdLmZpbGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gRmlsZSBub3JtYWxpemF0aW9uIGZvciBTYWZhcmkgNCBhbmQgRmlyZWZveCAzOlxuICAgICAgICAgICAgICAgICQuZWFjaChmaWxlcywgZnVuY3Rpb24gKGluZGV4LCBmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGUubmFtZSA9IGZpbGUuZmlsZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGZpbGUuc2l6ZSA9IGZpbGUuZmlsZVNpemU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJC5EZWZlcnJlZCgpLnJlc29sdmUoZmlsZXMpLnByb21pc2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0RmlsZUlucHV0RmlsZXM6IGZ1bmN0aW9uIChmaWxlSW5wdXQpIHtcbiAgICAgICAgICAgIGlmICghKGZpbGVJbnB1dCBpbnN0YW5jZW9mICQpIHx8IGZpbGVJbnB1dC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U2luZ2xlRmlsZUlucHV0RmlsZXMoZmlsZUlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkLndoZW4uYXBwbHkoXG4gICAgICAgICAgICAgICAgJCxcbiAgICAgICAgICAgICAgICAkLm1hcChmaWxlSW5wdXQsIHRoaXMuX2dldFNpbmdsZUZpbGVJbnB1dEZpbGVzKVxuICAgICAgICAgICAgKS5waXBlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgW10sXG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfb25DaGFuZ2U6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZUlucHV0OiAkKGUudGFyZ2V0KSxcbiAgICAgICAgICAgICAgICAgICAgZm9ybTogJChlLnRhcmdldC5mb3JtKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9nZXRGaWxlSW5wdXRGaWxlcyhkYXRhLmZpbGVJbnB1dCkuYWx3YXlzKGZ1bmN0aW9uIChmaWxlcykge1xuICAgICAgICAgICAgICAgIGRhdGEuZmlsZXMgPSBmaWxlcztcbiAgICAgICAgICAgICAgICBpZiAodGhhdC5vcHRpb25zLnJlcGxhY2VGaWxlSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5fcmVwbGFjZUZpbGVJbnB1dChkYXRhLmZpbGVJbnB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGF0Ll90cmlnZ2VyKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NoYW5nZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAkLkV2ZW50KCdjaGFuZ2UnLCB7ZGVsZWdhdGVkRXZlbnQ6IGV9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5fb25BZGQoZSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX29uUGFzdGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSBlLm9yaWdpbmFsRXZlbnQgJiYgZS5vcmlnaW5hbEV2ZW50LmNsaXBib2FyZERhdGEgJiZcbiAgICAgICAgICAgICAgICAgICAgZS5vcmlnaW5hbEV2ZW50LmNsaXBib2FyZERhdGEuaXRlbXMsXG4gICAgICAgICAgICAgICAgZGF0YSA9IHtmaWxlczogW119O1xuICAgICAgICAgICAgaWYgKGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICQuZWFjaChpdGVtcywgZnVuY3Rpb24gKGluZGV4LCBpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWxlID0gaXRlbS5nZXRBc0ZpbGUgJiYgaXRlbS5nZXRBc0ZpbGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZmlsZXMucHVzaChmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl90cmlnZ2VyKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Bhc3RlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICQuRXZlbnQoJ3Bhc3RlJywge2RlbGVnYXRlZEV2ZW50OiBlfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhXG4gICAgICAgICAgICAgICAgICAgICkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uQWRkKGUsIGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfb25Ecm9wOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5kYXRhVHJhbnNmZXIgPSBlLm9yaWdpbmFsRXZlbnQgJiYgZS5vcmlnaW5hbEV2ZW50LmRhdGFUcmFuc2ZlcjtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICBkYXRhVHJhbnNmZXIgPSBlLmRhdGFUcmFuc2ZlcixcbiAgICAgICAgICAgICAgICBkYXRhID0ge307XG4gICAgICAgICAgICBpZiAoZGF0YVRyYW5zZmVyICYmIGRhdGFUcmFuc2Zlci5maWxlcyAmJiBkYXRhVHJhbnNmZXIuZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2dldERyb3BwZWRGaWxlcyhkYXRhVHJhbnNmZXIpLmFsd2F5cyhmdW5jdGlvbiAoZmlsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5maWxlcyA9IGZpbGVzO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5fdHJpZ2dlcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZHJvcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5FdmVudCgnZHJvcCcsIHtkZWxlZ2F0ZWRFdmVudDogZX0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll9vbkFkZChlLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9vbkRyYWdPdmVyOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5kYXRhVHJhbnNmZXIgPSBlLm9yaWdpbmFsRXZlbnQgJiYgZS5vcmlnaW5hbEV2ZW50LmRhdGFUcmFuc2ZlcjtcbiAgICAgICAgICAgIHZhciBkYXRhVHJhbnNmZXIgPSBlLmRhdGFUcmFuc2ZlcjtcbiAgICAgICAgICAgIGlmIChkYXRhVHJhbnNmZXIgJiYgJC5pbkFycmF5KCdGaWxlcycsIGRhdGFUcmFuc2Zlci50eXBlcykgIT09IC0xICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICAnZHJhZ292ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJC5FdmVudCgnZHJhZ292ZXInLCB7ZGVsZWdhdGVkRXZlbnQ6IGV9KVxuICAgICAgICAgICAgICAgICAgICApICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBkYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9ICdjb3B5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfaW5pdEV2ZW50SGFuZGxlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1hIUlVwbG9hZCh0aGlzLm9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb24odGhpcy5vcHRpb25zLmRyb3Bab25lLCB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdvdmVyOiB0aGlzLl9vbkRyYWdPdmVyLFxuICAgICAgICAgICAgICAgICAgICBkcm9wOiB0aGlzLl9vbkRyb3BcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbih0aGlzLm9wdGlvbnMucGFzdGVab25lLCB7XG4gICAgICAgICAgICAgICAgICAgIHBhc3RlOiB0aGlzLl9vblBhc3RlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJC5zdXBwb3J0LmZpbGVJbnB1dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uKHRoaXMub3B0aW9ucy5maWxlSW5wdXQsIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlOiB0aGlzLl9vbkNoYW5nZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9kZXN0cm95RXZlbnRIYW5kbGVyczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fb2ZmKHRoaXMub3B0aW9ucy5kcm9wWm9uZSwgJ2RyYWdvdmVyIGRyb3AnKTtcbiAgICAgICAgICAgIHRoaXMuX29mZih0aGlzLm9wdGlvbnMucGFzdGVab25lLCAncGFzdGUnKTtcbiAgICAgICAgICAgIHRoaXMuX29mZih0aGlzLm9wdGlvbnMuZmlsZUlucHV0LCAnY2hhbmdlJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3NldE9wdGlvbjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciByZWluaXQgPSAkLmluQXJyYXkoa2V5LCB0aGlzLl9zcGVjaWFsT3B0aW9ucykgIT09IC0xO1xuICAgICAgICAgICAgaWYgKHJlaW5pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zdXBlcihrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChyZWluaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0U3BlY2lhbE9wdGlvbnMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RXZlbnRIYW5kbGVycygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9pbml0U3BlY2lhbE9wdGlvbnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZmlsZUlucHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmZpbGVJbnB1dCA9IHRoaXMuZWxlbWVudC5pcygnaW5wdXRbdHlwZT1cImZpbGVcIl0nKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQgOiB0aGlzLmVsZW1lbnQuZmluZCgnaW5wdXRbdHlwZT1cImZpbGVcIl0nKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIShvcHRpb25zLmZpbGVJbnB1dCBpbnN0YW5jZW9mICQpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5maWxlSW5wdXQgPSAkKG9wdGlvbnMuZmlsZUlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKG9wdGlvbnMuZHJvcFpvbmUgaW5zdGFuY2VvZiAkKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZHJvcFpvbmUgPSAkKG9wdGlvbnMuZHJvcFpvbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEob3B0aW9ucy5wYXN0ZVpvbmUgaW5zdGFuY2VvZiAkKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucGFzdGVab25lID0gJChvcHRpb25zLnBhc3RlWm9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldFJlZ0V4cDogZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KCcvJyksXG4gICAgICAgICAgICAgICAgbW9kaWZpZXJzID0gcGFydHMucG9wKCk7XG4gICAgICAgICAgICBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocGFydHMuam9pbignLycpLCBtb2RpZmllcnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9pc1JlZ0V4cE9wdGlvbjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXkgIT09ICd1cmwnICYmICQudHlwZSh2YWx1ZSkgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgL15cXC8uKlxcL1tpZ21dezAsM30kLy50ZXN0KHZhbHVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfaW5pdERhdGFBdHRyaWJ1dGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBjbG9uZSA9ICQodGhpcy5lbGVtZW50WzBdLmNsb25lTm9kZShmYWxzZSkpO1xuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSBvcHRpb25zIHNldCB2aWEgSFRNTDUgZGF0YS1hdHRyaWJ1dGVzOlxuICAgICAgICAgICAgJC5lYWNoKFxuICAgICAgICAgICAgICAgIGNsb25lLmRhdGEoKSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YUF0dHJpYnV0ZU5hbWUgPSAnZGF0YS0nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgY2FtZWxDYXNlIHRvIGh5cGhlbi1hdGVkIGtleTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleS5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2xvbmUuYXR0cihkYXRhQXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0Ll9pc1JlZ0V4cE9wdGlvbihrZXksIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhhdC5fZ2V0UmVnRXhwKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfY3JlYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9pbml0RGF0YUF0dHJpYnV0ZXMoKTtcbiAgICAgICAgICAgIHRoaXMuX2luaXRTcGVjaWFsT3B0aW9ucygpO1xuICAgICAgICAgICAgdGhpcy5fc2xvdHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3NlcXVlbmNlID0gdGhpcy5fZ2V0WEhSUHJvbWlzZSh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRpbmcgPSB0aGlzLl9hY3RpdmUgPSAwO1xuICAgICAgICAgICAgdGhpcy5faW5pdFByb2dyZXNzT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5faW5pdEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBUaGlzIG1ldGhvZCBpcyBleHBvc2VkIHRvIHRoZSB3aWRnZXQgQVBJIGFuZCBhbGxvd3MgdG8gcXVlcnlcbiAgICAgICAgLy8gdGhlIG51bWJlciBvZiBhY3RpdmUgdXBsb2FkczpcbiAgICAgICAgYWN0aXZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIGlzIGV4cG9zZWQgdG8gdGhlIHdpZGdldCBBUEkgYW5kIGFsbG93cyB0byBxdWVyeVxuICAgICAgICAvLyB0aGUgd2lkZ2V0IHVwbG9hZCBwcm9ncmVzcy5cbiAgICAgICAgLy8gSXQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBsb2FkZWQsIHRvdGFsIGFuZCBiaXRyYXRlIHByb3BlcnRpZXNcbiAgICAgICAgLy8gZm9yIHRoZSBydW5uaW5nIHVwbG9hZHM6XG4gICAgICAgIHByb2dyZXNzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvZ3Jlc3M7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVGhpcyBtZXRob2QgaXMgZXhwb3NlZCB0byB0aGUgd2lkZ2V0IEFQSSBhbmQgYWxsb3dzIGFkZGluZyBmaWxlc1xuICAgICAgICAvLyB1c2luZyB0aGUgZmlsZXVwbG9hZCBBUEkuIFRoZSBkYXRhIHBhcmFtZXRlciBhY2NlcHRzIGFuIG9iamVjdCB3aGljaFxuICAgICAgICAvLyBtdXN0IGhhdmUgYSBmaWxlcyBwcm9wZXJ0eSBhbmQgY2FuIGNvbnRhaW4gYWRkaXRpb25hbCBvcHRpb25zOlxuICAgICAgICAvLyAuZmlsZXVwbG9hZCgnYWRkJywge2ZpbGVzOiBmaWxlc0xpc3R9KTtcbiAgICAgICAgYWRkOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCFkYXRhIHx8IHRoaXMub3B0aW9ucy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLmZpbGVJbnB1dCAmJiAhZGF0YS5maWxlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2dldEZpbGVJbnB1dEZpbGVzKGRhdGEuZmlsZUlucHV0KS5hbHdheXMoZnVuY3Rpb24gKGZpbGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZmlsZXMgPSBmaWxlcztcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5fb25BZGQobnVsbCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEuZmlsZXMgPSAkLm1ha2VBcnJheShkYXRhLmZpbGVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkFkZChudWxsLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBUaGlzIG1ldGhvZCBpcyBleHBvc2VkIHRvIHRoZSB3aWRnZXQgQVBJIGFuZCBhbGxvd3Mgc2VuZGluZyBmaWxlc1xuICAgICAgICAvLyB1c2luZyB0aGUgZmlsZXVwbG9hZCBBUEkuIFRoZSBkYXRhIHBhcmFtZXRlciBhY2NlcHRzIGFuIG9iamVjdCB3aGljaFxuICAgICAgICAvLyBtdXN0IGhhdmUgYSBmaWxlcyBvciBmaWxlSW5wdXQgcHJvcGVydHkgYW5kIGNhbiBjb250YWluIGFkZGl0aW9uYWwgb3B0aW9uczpcbiAgICAgICAgLy8gLmZpbGV1cGxvYWQoJ3NlbmQnLCB7ZmlsZXM6IGZpbGVzTGlzdH0pO1xuICAgICAgICAvLyBUaGUgbWV0aG9kIHJldHVybnMgYSBQcm9taXNlIG9iamVjdCBmb3IgdGhlIGZpbGUgdXBsb2FkIGNhbGwuXG4gICAgICAgIHNlbmQ6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZGF0YSAmJiAhdGhpcy5vcHRpb25zLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuZmlsZUlucHV0ICYmICFkYXRhLmZpbGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRmZCA9ICQuRGVmZXJyZWQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSBkZmQucHJvbWlzZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAganFYSFIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhYm9ydGVkO1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoanFYSFIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ganFYSFIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRmZC5yZWplY3QobnVsbCwgJ2Fib3J0JywgJ2Fib3J0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2V0RmlsZUlucHV0RmlsZXMoZGF0YS5maWxlSW5wdXQpLmFsd2F5cyhcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChmaWxlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGZkLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZmlsZXMgPSBmaWxlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcVhIUiA9IHRoYXQuX29uU2VuZChudWxsLCBkYXRhKS50aGVuKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAocmVzdWx0LCB0ZXh0U3RhdHVzLCBqcVhIUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGZkLnJlc29sdmUocmVzdWx0LCB0ZXh0U3RhdHVzLCBqcVhIUik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChqcVhIUiwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRmZC5yZWplY3QoanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbmhhbmNlUHJvbWlzZShwcm9taXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YS5maWxlcyA9ICQubWFrZUFycmF5KGRhdGEuZmlsZXMpO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLmZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fb25TZW5kKG51bGwsIGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRYSFJQcm9taXNlKGZhbHNlLCBkYXRhICYmIGRhdGEuY29udGV4dCk7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG59KSk7XG4iLCIvKlxuICogalF1ZXJ5IElmcmFtZSBUcmFuc3BvcnQgUGx1Z2luIDEuOC4yXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmx1ZWltcC9qUXVlcnktRmlsZS1VcGxvYWRcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSwgU2ViYXN0aWFuIFRzY2hhblxuICogaHR0cHM6Ly9ibHVlaW1wLm5ldFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKi9cblxuLyogZ2xvYmFsIGRlZmluZSwgd2luZG93LCBkb2N1bWVudCAqL1xuXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgQU1EIG1vZHVsZTpcbiAgICAgICAgZGVmaW5lKFsnanF1ZXJ5J10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFsczpcbiAgICAgICAgZmFjdG9yeSh3aW5kb3cualF1ZXJ5KTtcbiAgICB9XG59KGZ1bmN0aW9uICgkKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLy8gSGVscGVyIHZhcmlhYmxlIHRvIGNyZWF0ZSB1bmlxdWUgbmFtZXMgZm9yIHRoZSB0cmFuc3BvcnQgaWZyYW1lczpcbiAgICB2YXIgY291bnRlciA9IDA7XG5cbiAgICAvLyBUaGUgaWZyYW1lIHRyYW5zcG9ydCBhY2NlcHRzIGZvdXIgYWRkaXRpb25hbCBvcHRpb25zOlxuICAgIC8vIG9wdGlvbnMuZmlsZUlucHV0OiBhIGpRdWVyeSBjb2xsZWN0aW9uIG9mIGZpbGUgaW5wdXQgZmllbGRzXG4gICAgLy8gb3B0aW9ucy5wYXJhbU5hbWU6IHRoZSBwYXJhbWV0ZXIgbmFtZSBmb3IgdGhlIGZpbGUgZm9ybSBkYXRhLFxuICAgIC8vICBvdmVycmlkZXMgdGhlIG5hbWUgcHJvcGVydHkgb2YgdGhlIGZpbGUgaW5wdXQgZmllbGQocyksXG4gICAgLy8gIGNhbiBiZSBhIHN0cmluZyBvciBhbiBhcnJheSBvZiBzdHJpbmdzLlxuICAgIC8vIG9wdGlvbnMuZm9ybURhdGE6IGFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCBuYW1lIGFuZCB2YWx1ZSBwcm9wZXJ0aWVzLFxuICAgIC8vICBlcXVpdmFsZW50IHRvIHRoZSByZXR1cm4gZGF0YSBvZiAuc2VyaWFsaXplQXJyYXkoKSwgZS5nLjpcbiAgICAvLyAgW3tuYW1lOiAnYScsIHZhbHVlOiAxfSwge25hbWU6ICdiJywgdmFsdWU6IDJ9XVxuICAgIC8vIG9wdGlvbnMuaW5pdGlhbElmcmFtZVNyYzogdGhlIFVSTCBvZiB0aGUgaW5pdGlhbCBpZnJhbWUgc3JjLFxuICAgIC8vICBieSBkZWZhdWx0IHNldCB0byBcImphdmFzY3JpcHQ6ZmFsc2U7XCJcbiAgICAkLmFqYXhUcmFuc3BvcnQoJ2lmcmFtZScsIGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmFzeW5jKSB7XG4gICAgICAgICAgICAvLyBqYXZhc2NyaXB0OmZhbHNlIGFzIGluaXRpYWwgaWZyYW1lIHNyY1xuICAgICAgICAgICAgLy8gcHJldmVudHMgd2FybmluZyBwb3B1cHMgb24gSFRUUFMgaW4gSUU2OlxuICAgICAgICAgICAgLypqc2hpbnQgc2NyaXB0dXJsOiB0cnVlICovXG4gICAgICAgICAgICB2YXIgaW5pdGlhbElmcmFtZVNyYyA9IG9wdGlvbnMuaW5pdGlhbElmcmFtZVNyYyB8fCAnamF2YXNjcmlwdDpmYWxzZTsnLFxuICAgICAgICAgICAgLypqc2hpbnQgc2NyaXB0dXJsOiBmYWxzZSAqL1xuICAgICAgICAgICAgICAgIGZvcm0sXG4gICAgICAgICAgICAgICAgaWZyYW1lLFxuICAgICAgICAgICAgICAgIGFkZFBhcmFtQ2hhcjtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2VuZDogZnVuY3Rpb24gKF8sIGNvbXBsZXRlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybSA9ICQoJzxmb3JtIHN0eWxlPVwiZGlzcGxheTpub25lO1wiPjwvZm9ybT4nKTtcbiAgICAgICAgICAgICAgICAgICAgZm9ybS5hdHRyKCdhY2NlcHQtY2hhcnNldCcsIG9wdGlvbnMuZm9ybUFjY2VwdENoYXJzZXQpO1xuICAgICAgICAgICAgICAgICAgICBhZGRQYXJhbUNoYXIgPSAvXFw/Ly50ZXN0KG9wdGlvbnMudXJsKSA/ICcmJyA6ICc/JztcbiAgICAgICAgICAgICAgICAgICAgLy8gWERvbWFpblJlcXVlc3Qgb25seSBzdXBwb3J0cyBHRVQgYW5kIFBPU1Q6XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnR5cGUgPT09ICdERUxFVEUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnVybCA9IG9wdGlvbnMudXJsICsgYWRkUGFyYW1DaGFyICsgJ19tZXRob2Q9REVMRVRFJztcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudHlwZSA9ICdQT1NUJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnR5cGUgPT09ICdQVVQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnVybCA9IG9wdGlvbnMudXJsICsgYWRkUGFyYW1DaGFyICsgJ19tZXRob2Q9UFVUJztcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudHlwZSA9ICdQT1NUJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnR5cGUgPT09ICdQQVRDSCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudXJsID0gb3B0aW9ucy51cmwgKyBhZGRQYXJhbUNoYXIgKyAnX21ldGhvZD1QQVRDSCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnR5cGUgPSAnUE9TVCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSUUgdmVyc2lvbnMgYmVsb3cgSUU4IGNhbm5vdCBzZXQgdGhlIG5hbWUgcHJvcGVydHkgb2ZcbiAgICAgICAgICAgICAgICAgICAgLy8gZWxlbWVudHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBhZGRlZCB0byB0aGUgRE9NLFxuICAgICAgICAgICAgICAgICAgICAvLyBzbyB3ZSBzZXQgdGhlIG5hbWUgYWxvbmcgd2l0aCB0aGUgaWZyYW1lIEhUTUwgbWFya3VwOlxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmcmFtZSA9ICQoXG4gICAgICAgICAgICAgICAgICAgICAgICAnPGlmcmFtZSBzcmM9XCInICsgaW5pdGlhbElmcmFtZVNyYyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1wiIG5hbWU9XCJpZnJhbWUtdHJhbnNwb3J0LScgKyBjb3VudGVyICsgJ1wiPjwvaWZyYW1lPidcbiAgICAgICAgICAgICAgICAgICAgKS5iaW5kKCdsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVJbnB1dENsb25lcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbU5hbWVzID0gJC5pc0FycmF5KG9wdGlvbnMucGFyYW1OYW1lKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhcmFtTmFtZSA6IFtvcHRpb25zLnBhcmFtTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZnJhbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudW5iaW5kKCdsb2FkJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYmluZCgnbG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXcmFwIGluIGEgdHJ5L2NhdGNoIGJsb2NrIHRvIGNhdGNoIGV4Y2VwdGlvbnMgdGhyb3duXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdHJ5aW5nIHRvIGFjY2VzcyBjcm9zcy1kb21haW4gaWZyYW1lIGNvbnRlbnRzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBpZnJhbWUuY29udGVudHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdvb2dsZSBDaHJvbWUgYW5kIEZpcmVmb3ggZG8gbm90IHRocm93IGFuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBleGNlcHRpb24gd2hlbiBjYWxsaW5nIGlmcmFtZS5jb250ZW50cygpIG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNvIHdlIHVuaWZ5IHRoZSByZXNwb25zZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2UubGVuZ3RoIHx8ICFyZXNwb25zZVswXS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBjb21wbGV0ZSBjYWxsYmFjayByZXR1cm5zIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZnJhbWUgY29udGVudCBkb2N1bWVudCBhcyByZXNwb25zZSBvYmplY3Q6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlQ2FsbGJhY2soXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3VjY2VzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7J2lmcmFtZSc6IHJlc3BvbnNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXggZm9yIElFIGVuZGxlc3MgcHJvZ3Jlc3MgYmFyIGFjdGl2aXR5IGJ1Z1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAoaGFwcGVucyBvbiBmb3JtIHN1Ym1pdHMgdG8gaWZyYW1lIHRhcmdldHMpOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCc8aWZyYW1lIHNyYz1cIicgKyBpbml0aWFsSWZyYW1lU3JjICsgJ1wiPjwvaWZyYW1lPicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kVG8oZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92aW5nIHRoZSBmb3JtIGluIGEgc2V0VGltZW91dCBjYWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGxvd3MgQ2hyb21lJ3MgZGV2ZWxvcGVyIHRvb2xzIHRvIGRpc3BsYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSByZXNwb25zZSByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wcm9wKCd0YXJnZXQnLCBpZnJhbWUucHJvcCgnbmFtZScpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wcm9wKCdhY3Rpb24nLCBvcHRpb25zLnVybClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucHJvcCgnbWV0aG9kJywgb3B0aW9ucy50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmZvcm1EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKG9wdGlvbnMuZm9ybURhdGEsIGZ1bmN0aW9uIChpbmRleCwgZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnPGlucHV0IHR5cGU9XCJoaWRkZW5cIi8+JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wcm9wKCduYW1lJywgZmllbGQubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC52YWwoZmllbGQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kVG8oZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5maWxlSW5wdXQgJiYgb3B0aW9ucy5maWxlSW5wdXQubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudHlwZSA9PT0gJ1BPU1QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZUlucHV0Q2xvbmVzID0gb3B0aW9ucy5maWxlSW5wdXQuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnNlcnQgYSBjbG9uZSBmb3IgZWFjaCBmaWxlIGlucHV0IGZpZWxkOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZmlsZUlucHV0LmFmdGVyKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlsZUlucHV0Q2xvbmVzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wYXJhbU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5maWxlSW5wdXQuZWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykucHJvcChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lc1tpbmRleF0gfHwgb3B0aW9ucy5wYXJhbU5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmRpbmcgdGhlIGZpbGUgaW5wdXQgZmllbGRzIHRvIHRoZSBoaWRkZW4gZm9ybVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZXMgdGhlbSBmcm9tIHRoZWlyIG9yaWdpbmFsIGxvY2F0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChvcHRpb25zLmZpbGVJbnB1dClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnByb3AoJ2VuY3R5cGUnLCAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVuY3R5cGUgbXVzdCBiZSBzZXQgYXMgZW5jb2RpbmcgZm9yIElFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucHJvcCgnZW5jb2RpbmcnLCAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgSFRNTDUgZm9ybSBhdHRyaWJ1dGUgZnJvbSB0aGUgaW5wdXQocyk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5maWxlSW5wdXQucmVtb3ZlQXR0cignZm9ybScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybS5zdWJtaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluc2VydCB0aGUgZmlsZSBpbnB1dCBmaWVsZHMgYXQgdGhlaXIgb3JpZ2luYWwgbG9jYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ5IHJlcGxhY2luZyB0aGUgY2xvbmVzIHdpdGggdGhlIG9yaWdpbmFsczpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWxlSW5wdXRDbG9uZXMgJiYgZmlsZUlucHV0Q2xvbmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZmlsZUlucHV0LmVhY2goZnVuY3Rpb24gKGluZGV4LCBpbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xvbmUgPSAkKGZpbGVJbnB1dENsb25lc1tpbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBuYW1lIGFuZCBmb3JtIHByb3BlcnRpZXM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoaW5wdXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucHJvcCgnbmFtZScsIGNsb25lLnByb3AoJ25hbWUnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdmb3JtJywgY2xvbmUuYXR0cignZm9ybScpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUucmVwbGFjZVdpdGgoaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZm9ybS5hcHBlbmQoaWZyYW1lKS5hcHBlbmRUbyhkb2N1bWVudC5ib2R5KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGphdmFzY3JpcHQ6ZmFsc2UgYXMgaWZyYW1lIHNyYyBhYm9ydHMgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBwcmV2ZW50cyB3YXJuaW5nIHBvcHVwcyBvbiBIVFRQUyBpbiBJRTYuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25jYXQgaXMgdXNlZCB0byBhdm9pZCB0aGUgXCJTY3JpcHQgVVJMXCIgSlNMaW50IGVycm9yOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWZyYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnVuYmluZCgnbG9hZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnByb3AoJ3NyYycsIGluaXRpYWxJZnJhbWVTcmMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gVGhlIGlmcmFtZSB0cmFuc3BvcnQgcmV0dXJucyB0aGUgaWZyYW1lIGNvbnRlbnQgZG9jdW1lbnQgYXMgcmVzcG9uc2UuXG4gICAgLy8gVGhlIGZvbGxvd2luZyBhZGRzIGNvbnZlcnRlcnMgZnJvbSBpZnJhbWUgdG8gdGV4dCwganNvbiwgaHRtbCwgeG1sXG4gICAgLy8gYW5kIHNjcmlwdC5cbiAgICAvLyBQbGVhc2Ugbm90ZSB0aGF0IHRoZSBDb250ZW50LVR5cGUgZm9yIEpTT04gcmVzcG9uc2VzIGhhcyB0byBiZSB0ZXh0L3BsYWluXG4gICAgLy8gb3IgdGV4dC9odG1sLCBpZiB0aGUgYnJvd3NlciBkb2Vzbid0IGluY2x1ZGUgYXBwbGljYXRpb24vanNvbiBpbiB0aGVcbiAgICAvLyBBY2NlcHQgaGVhZGVyLCBlbHNlIElFIHdpbGwgc2hvdyBhIGRvd25sb2FkIGRpYWxvZy5cbiAgICAvLyBUaGUgQ29udGVudC1UeXBlIGZvciBYTUwgcmVzcG9uc2VzIG9uIHRoZSBvdGhlciBoYW5kIGhhcyB0byBiZSBhbHdheXNcbiAgICAvLyBhcHBsaWNhdGlvbi94bWwgb3IgdGV4dC94bWwsIHNvIElFIHByb3Blcmx5IHBhcnNlcyB0aGUgWE1MIHJlc3BvbnNlLlxuICAgIC8vIFNlZSBhbHNvXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvalF1ZXJ5LUZpbGUtVXBsb2FkL3dpa2kvU2V0dXAjY29udGVudC10eXBlLW5lZ290aWF0aW9uXG4gICAgJC5hamF4U2V0dXAoe1xuICAgICAgICBjb252ZXJ0ZXJzOiB7XG4gICAgICAgICAgICAnaWZyYW1lIHRleHQnOiBmdW5jdGlvbiAoaWZyYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlmcmFtZSAmJiAkKGlmcmFtZVswXS5ib2R5KS50ZXh0KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2lmcmFtZSBqc29uJzogZnVuY3Rpb24gKGlmcmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZnJhbWUgJiYgJC5wYXJzZUpTT04oJChpZnJhbWVbMF0uYm9keSkudGV4dCgpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnaWZyYW1lIGh0bWwnOiBmdW5jdGlvbiAoaWZyYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlmcmFtZSAmJiAkKGlmcmFtZVswXS5ib2R5KS5odG1sKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2lmcmFtZSB4bWwnOiBmdW5jdGlvbiAoaWZyYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHhtbERvYyA9IGlmcmFtZSAmJiBpZnJhbWVbMF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHhtbERvYyAmJiAkLmlzWE1MRG9jKHhtbERvYykgPyB4bWxEb2MgOlxuICAgICAgICAgICAgICAgICAgICAgICAgJC5wYXJzZVhNTCgoeG1sRG9jLlhNTERvY3VtZW50ICYmIHhtbERvYy5YTUxEb2N1bWVudC54bWwpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJCh4bWxEb2MuYm9keSkuaHRtbCgpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnaWZyYW1lIHNjcmlwdCc6IGZ1bmN0aW9uIChpZnJhbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWZyYW1lICYmICQuZ2xvYmFsRXZhbCgkKGlmcmFtZVswXS5ib2R5KS50ZXh0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbn0pKTtcbiIsIi8qIVxuICogalF1ZXJ5IFVJIFdpZGdldCAxLjEwLjQrYW1kXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmx1ZWltcC9qUXVlcnktRmlsZS1VcGxvYWRcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20valF1ZXJ5LndpZGdldC9cbiAqL1xuXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIEFNRCBtb2R1bGU6XG4gICAgICAgIGRlZmluZShbXCJqcXVlcnlcIl0sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFsczpcbiAgICAgICAgZmFjdG9yeShqUXVlcnkpO1xuICAgIH1cbn0oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxudmFyIHV1aWQgPSAwLFxuXHRzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZSxcblx0X2NsZWFuRGF0YSA9ICQuY2xlYW5EYXRhO1xuJC5jbGVhbkRhdGEgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG5cdGZvciAoIHZhciBpID0gMCwgZWxlbTsgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdHRyeSB7XG5cdFx0XHQkKCBlbGVtICkudHJpZ2dlckhhbmRsZXIoIFwicmVtb3ZlXCIgKTtcblx0XHQvLyBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC84MjM1XG5cdFx0fSBjYXRjaCggZSApIHt9XG5cdH1cblx0X2NsZWFuRGF0YSggZWxlbXMgKTtcbn07XG5cbiQud2lkZ2V0ID0gZnVuY3Rpb24oIG5hbWUsIGJhc2UsIHByb3RvdHlwZSApIHtcblx0dmFyIGZ1bGxOYW1lLCBleGlzdGluZ0NvbnN0cnVjdG9yLCBjb25zdHJ1Y3RvciwgYmFzZVByb3RvdHlwZSxcblx0XHQvLyBwcm94aWVkUHJvdG90eXBlIGFsbG93cyB0aGUgcHJvdmlkZWQgcHJvdG90eXBlIHRvIHJlbWFpbiB1bm1vZGlmaWVkXG5cdFx0Ly8gc28gdGhhdCBpdCBjYW4gYmUgdXNlZCBhcyBhIG1peGluIGZvciBtdWx0aXBsZSB3aWRnZXRzICgjODg3Nilcblx0XHRwcm94aWVkUHJvdG90eXBlID0ge30sXG5cdFx0bmFtZXNwYWNlID0gbmFtZS5zcGxpdCggXCIuXCIgKVsgMCBdO1xuXG5cdG5hbWUgPSBuYW1lLnNwbGl0KCBcIi5cIiApWyAxIF07XG5cdGZ1bGxOYW1lID0gbmFtZXNwYWNlICsgXCItXCIgKyBuYW1lO1xuXG5cdGlmICggIXByb3RvdHlwZSApIHtcblx0XHRwcm90b3R5cGUgPSBiYXNlO1xuXHRcdGJhc2UgPSAkLldpZGdldDtcblx0fVxuXG5cdC8vIGNyZWF0ZSBzZWxlY3RvciBmb3IgcGx1Z2luXG5cdCQuZXhwclsgXCI6XCIgXVsgZnVsbE5hbWUudG9Mb3dlckNhc2UoKSBdID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuICEhJC5kYXRhKCBlbGVtLCBmdWxsTmFtZSApO1xuXHR9O1xuXG5cdCRbIG5hbWVzcGFjZSBdID0gJFsgbmFtZXNwYWNlIF0gfHwge307XG5cdGV4aXN0aW5nQ29uc3RydWN0b3IgPSAkWyBuYW1lc3BhY2UgXVsgbmFtZSBdO1xuXHRjb25zdHJ1Y3RvciA9ICRbIG5hbWVzcGFjZSBdWyBuYW1lIF0gPSBmdW5jdGlvbiggb3B0aW9ucywgZWxlbWVudCApIHtcblx0XHQvLyBhbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgXCJuZXdcIiBrZXl3b3JkXG5cdFx0aWYgKCAhdGhpcy5fY3JlYXRlV2lkZ2V0ICkge1xuXHRcdFx0cmV0dXJuIG5ldyBjb25zdHJ1Y3Rvciggb3B0aW9ucywgZWxlbWVudCApO1xuXHRcdH1cblxuXHRcdC8vIGFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCBpbml0aWFsaXppbmcgZm9yIHNpbXBsZSBpbmhlcml0YW5jZVxuXHRcdC8vIG11c3QgdXNlIFwibmV3XCIga2V5d29yZCAodGhlIGNvZGUgYWJvdmUgYWx3YXlzIHBhc3NlcyBhcmdzKVxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHRoaXMuX2NyZWF0ZVdpZGdldCggb3B0aW9ucywgZWxlbWVudCApO1xuXHRcdH1cblx0fTtcblx0Ly8gZXh0ZW5kIHdpdGggdGhlIGV4aXN0aW5nIGNvbnN0cnVjdG9yIHRvIGNhcnJ5IG92ZXIgYW55IHN0YXRpYyBwcm9wZXJ0aWVzXG5cdCQuZXh0ZW5kKCBjb25zdHJ1Y3RvciwgZXhpc3RpbmdDb25zdHJ1Y3Rvciwge1xuXHRcdHZlcnNpb246IHByb3RvdHlwZS52ZXJzaW9uLFxuXHRcdC8vIGNvcHkgdGhlIG9iamVjdCB1c2VkIHRvIGNyZWF0ZSB0aGUgcHJvdG90eXBlIGluIGNhc2Ugd2UgbmVlZCB0b1xuXHRcdC8vIHJlZGVmaW5lIHRoZSB3aWRnZXQgbGF0ZXJcblx0XHRfcHJvdG86ICQuZXh0ZW5kKCB7fSwgcHJvdG90eXBlICksXG5cdFx0Ly8gdHJhY2sgd2lkZ2V0cyB0aGF0IGluaGVyaXQgZnJvbSB0aGlzIHdpZGdldCBpbiBjYXNlIHRoaXMgd2lkZ2V0IGlzXG5cdFx0Ly8gcmVkZWZpbmVkIGFmdGVyIGEgd2lkZ2V0IGluaGVyaXRzIGZyb20gaXRcblx0XHRfY2hpbGRDb25zdHJ1Y3RvcnM6IFtdXG5cdH0pO1xuXG5cdGJhc2VQcm90b3R5cGUgPSBuZXcgYmFzZSgpO1xuXHQvLyB3ZSBuZWVkIHRvIG1ha2UgdGhlIG9wdGlvbnMgaGFzaCBhIHByb3BlcnR5IGRpcmVjdGx5IG9uIHRoZSBuZXcgaW5zdGFuY2Vcblx0Ly8gb3RoZXJ3aXNlIHdlJ2xsIG1vZGlmeSB0aGUgb3B0aW9ucyBoYXNoIG9uIHRoZSBwcm90b3R5cGUgdGhhdCB3ZSdyZVxuXHQvLyBpbmhlcml0aW5nIGZyb21cblx0YmFzZVByb3RvdHlwZS5vcHRpb25zID0gJC53aWRnZXQuZXh0ZW5kKCB7fSwgYmFzZVByb3RvdHlwZS5vcHRpb25zICk7XG5cdCQuZWFjaCggcHJvdG90eXBlLCBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG5cdFx0aWYgKCAhJC5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cHJveGllZFByb3RvdHlwZVsgcHJvcCBdID0gdmFsdWU7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHByb3hpZWRQcm90b3R5cGVbIHByb3AgXSA9IChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBfc3VwZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gYmFzZS5wcm90b3R5cGVbIHByb3AgXS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdF9zdXBlckFwcGx5ID0gZnVuY3Rpb24oIGFyZ3MgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJhc2UucHJvdG90eXBlWyBwcm9wIF0uYXBwbHkoIHRoaXMsIGFyZ3MgKTtcblx0XHRcdFx0fTtcblx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIF9fc3VwZXIgPSB0aGlzLl9zdXBlcixcblx0XHRcdFx0XHRfX3N1cGVyQXBwbHkgPSB0aGlzLl9zdXBlckFwcGx5LFxuXHRcdFx0XHRcdHJldHVyblZhbHVlO1xuXG5cdFx0XHRcdHRoaXMuX3N1cGVyID0gX3N1cGVyO1xuXHRcdFx0XHR0aGlzLl9zdXBlckFwcGx5ID0gX3N1cGVyQXBwbHk7XG5cblx0XHRcdFx0cmV0dXJuVmFsdWUgPSB2YWx1ZS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cblx0XHRcdFx0dGhpcy5fc3VwZXIgPSBfX3N1cGVyO1xuXHRcdFx0XHR0aGlzLl9zdXBlckFwcGx5ID0gX19zdXBlckFwcGx5O1xuXG5cdFx0XHRcdHJldHVybiByZXR1cm5WYWx1ZTtcblx0XHRcdH07XG5cdFx0fSkoKTtcblx0fSk7XG5cdGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9ICQud2lkZ2V0LmV4dGVuZCggYmFzZVByb3RvdHlwZSwge1xuXHRcdC8vIFRPRE86IHJlbW92ZSBzdXBwb3J0IGZvciB3aWRnZXRFdmVudFByZWZpeFxuXHRcdC8vIGFsd2F5cyB1c2UgdGhlIG5hbWUgKyBhIGNvbG9uIGFzIHRoZSBwcmVmaXgsIGUuZy4sIGRyYWdnYWJsZTpzdGFydFxuXHRcdC8vIGRvbid0IHByZWZpeCBmb3Igd2lkZ2V0cyB0aGF0IGFyZW4ndCBET00tYmFzZWRcblx0XHR3aWRnZXRFdmVudFByZWZpeDogZXhpc3RpbmdDb25zdHJ1Y3RvciA/IChiYXNlUHJvdG90eXBlLndpZGdldEV2ZW50UHJlZml4IHx8IG5hbWUpIDogbmFtZVxuXHR9LCBwcm94aWVkUHJvdG90eXBlLCB7XG5cdFx0Y29uc3RydWN0b3I6IGNvbnN0cnVjdG9yLFxuXHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuXHRcdHdpZGdldE5hbWU6IG5hbWUsXG5cdFx0d2lkZ2V0RnVsbE5hbWU6IGZ1bGxOYW1lXG5cdH0pO1xuXG5cdC8vIElmIHRoaXMgd2lkZ2V0IGlzIGJlaW5nIHJlZGVmaW5lZCB0aGVuIHdlIG5lZWQgdG8gZmluZCBhbGwgd2lkZ2V0cyB0aGF0XG5cdC8vIGFyZSBpbmhlcml0aW5nIGZyb20gaXQgYW5kIHJlZGVmaW5lIGFsbCBvZiB0aGVtIHNvIHRoYXQgdGhleSBpbmhlcml0IGZyb21cblx0Ly8gdGhlIG5ldyB2ZXJzaW9uIG9mIHRoaXMgd2lkZ2V0LiBXZSdyZSBlc3NlbnRpYWxseSB0cnlpbmcgdG8gcmVwbGFjZSBvbmVcblx0Ly8gbGV2ZWwgaW4gdGhlIHByb3RvdHlwZSBjaGFpbi5cblx0aWYgKCBleGlzdGluZ0NvbnN0cnVjdG9yICkge1xuXHRcdCQuZWFjaCggZXhpc3RpbmdDb25zdHJ1Y3Rvci5fY2hpbGRDb25zdHJ1Y3RvcnMsIGZ1bmN0aW9uKCBpLCBjaGlsZCApIHtcblx0XHRcdHZhciBjaGlsZFByb3RvdHlwZSA9IGNoaWxkLnByb3RvdHlwZTtcblxuXHRcdFx0Ly8gcmVkZWZpbmUgdGhlIGNoaWxkIHdpZGdldCB1c2luZyB0aGUgc2FtZSBwcm90b3R5cGUgdGhhdCB3YXNcblx0XHRcdC8vIG9yaWdpbmFsbHkgdXNlZCwgYnV0IGluaGVyaXQgZnJvbSB0aGUgbmV3IHZlcnNpb24gb2YgdGhlIGJhc2Vcblx0XHRcdCQud2lkZ2V0KCBjaGlsZFByb3RvdHlwZS5uYW1lc3BhY2UgKyBcIi5cIiArIGNoaWxkUHJvdG90eXBlLndpZGdldE5hbWUsIGNvbnN0cnVjdG9yLCBjaGlsZC5fcHJvdG8gKTtcblx0XHR9KTtcblx0XHQvLyByZW1vdmUgdGhlIGxpc3Qgb2YgZXhpc3RpbmcgY2hpbGQgY29uc3RydWN0b3JzIGZyb20gdGhlIG9sZCBjb25zdHJ1Y3RvclxuXHRcdC8vIHNvIHRoZSBvbGQgY2hpbGQgY29uc3RydWN0b3JzIGNhbiBiZSBnYXJiYWdlIGNvbGxlY3RlZFxuXHRcdGRlbGV0ZSBleGlzdGluZ0NvbnN0cnVjdG9yLl9jaGlsZENvbnN0cnVjdG9ycztcblx0fSBlbHNlIHtcblx0XHRiYXNlLl9jaGlsZENvbnN0cnVjdG9ycy5wdXNoKCBjb25zdHJ1Y3RvciApO1xuXHR9XG5cblx0JC53aWRnZXQuYnJpZGdlKCBuYW1lLCBjb25zdHJ1Y3RvciApO1xufTtcblxuJC53aWRnZXQuZXh0ZW5kID0gZnVuY3Rpb24oIHRhcmdldCApIHtcblx0dmFyIGlucHV0ID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAxICksXG5cdFx0aW5wdXRJbmRleCA9IDAsXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0a2V5LFxuXHRcdHZhbHVlO1xuXHRmb3IgKCA7IGlucHV0SW5kZXggPCBpbnB1dExlbmd0aDsgaW5wdXRJbmRleCsrICkge1xuXHRcdGZvciAoIGtleSBpbiBpbnB1dFsgaW5wdXRJbmRleCBdICkge1xuXHRcdFx0dmFsdWUgPSBpbnB1dFsgaW5wdXRJbmRleCBdWyBrZXkgXTtcblx0XHRcdGlmICggaW5wdXRbIGlucHV0SW5kZXggXS5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0Ly8gQ2xvbmUgb2JqZWN0c1xuXHRcdFx0XHRpZiAoICQuaXNQbGFpbk9iamVjdCggdmFsdWUgKSApIHtcblx0XHRcdFx0XHR0YXJnZXRbIGtleSBdID0gJC5pc1BsYWluT2JqZWN0KCB0YXJnZXRbIGtleSBdICkgP1xuXHRcdFx0XHRcdFx0JC53aWRnZXQuZXh0ZW5kKCB7fSwgdGFyZ2V0WyBrZXkgXSwgdmFsdWUgKSA6XG5cdFx0XHRcdFx0XHQvLyBEb24ndCBleHRlbmQgc3RyaW5ncywgYXJyYXlzLCBldGMuIHdpdGggb2JqZWN0c1xuXHRcdFx0XHRcdFx0JC53aWRnZXQuZXh0ZW5kKCB7fSwgdmFsdWUgKTtcblx0XHRcdFx0Ly8gQ29weSBldmVyeXRoaW5nIGVsc2UgYnkgcmVmZXJlbmNlXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG4kLndpZGdldC5icmlkZ2UgPSBmdW5jdGlvbiggbmFtZSwgb2JqZWN0ICkge1xuXHR2YXIgZnVsbE5hbWUgPSBvYmplY3QucHJvdG90eXBlLndpZGdldEZ1bGxOYW1lIHx8IG5hbWU7XG5cdCQuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdHZhciBpc01ldGhvZENhbGwgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIixcblx0XHRcdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKSxcblx0XHRcdHJldHVyblZhbHVlID0gdGhpcztcblxuXHRcdC8vIGFsbG93IG11bHRpcGxlIGhhc2hlcyB0byBiZSBwYXNzZWQgb24gaW5pdFxuXHRcdG9wdGlvbnMgPSAhaXNNZXRob2RDYWxsICYmIGFyZ3MubGVuZ3RoID9cblx0XHRcdCQud2lkZ2V0LmV4dGVuZC5hcHBseSggbnVsbCwgWyBvcHRpb25zIF0uY29uY2F0KGFyZ3MpICkgOlxuXHRcdFx0b3B0aW9ucztcblxuXHRcdGlmICggaXNNZXRob2RDYWxsICkge1xuXHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbWV0aG9kVmFsdWUsXG5cdFx0XHRcdFx0aW5zdGFuY2UgPSAkLmRhdGEoIHRoaXMsIGZ1bGxOYW1lICk7XG5cdFx0XHRcdGlmICggIWluc3RhbmNlICkge1xuXHRcdFx0XHRcdHJldHVybiAkLmVycm9yKCBcImNhbm5vdCBjYWxsIG1ldGhvZHMgb24gXCIgKyBuYW1lICsgXCIgcHJpb3IgdG8gaW5pdGlhbGl6YXRpb247IFwiICtcblx0XHRcdFx0XHRcdFwiYXR0ZW1wdGVkIHRvIGNhbGwgbWV0aG9kICdcIiArIG9wdGlvbnMgKyBcIidcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggISQuaXNGdW5jdGlvbiggaW5zdGFuY2Vbb3B0aW9uc10gKSB8fCBvcHRpb25zLmNoYXJBdCggMCApID09PSBcIl9cIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gJC5lcnJvciggXCJubyBzdWNoIG1ldGhvZCAnXCIgKyBvcHRpb25zICsgXCInIGZvciBcIiArIG5hbWUgKyBcIiB3aWRnZXQgaW5zdGFuY2VcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1ldGhvZFZhbHVlID0gaW5zdGFuY2VbIG9wdGlvbnMgXS5hcHBseSggaW5zdGFuY2UsIGFyZ3MgKTtcblx0XHRcdFx0aWYgKCBtZXRob2RWYWx1ZSAhPT0gaW5zdGFuY2UgJiYgbWV0aG9kVmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm5WYWx1ZSA9IG1ldGhvZFZhbHVlICYmIG1ldGhvZFZhbHVlLmpxdWVyeSA/XG5cdFx0XHRcdFx0XHRyZXR1cm5WYWx1ZS5wdXNoU3RhY2soIG1ldGhvZFZhbHVlLmdldCgpICkgOlxuXHRcdFx0XHRcdFx0bWV0aG9kVmFsdWU7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgaW5zdGFuY2UgPSAkLmRhdGEoIHRoaXMsIGZ1bGxOYW1lICk7XG5cdFx0XHRcdGlmICggaW5zdGFuY2UgKSB7XG5cdFx0XHRcdFx0aW5zdGFuY2Uub3B0aW9uKCBvcHRpb25zIHx8IHt9ICkuX2luaXQoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQkLmRhdGEoIHRoaXMsIGZ1bGxOYW1lLCBuZXcgb2JqZWN0KCBvcHRpb25zLCB0aGlzICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldHVyblZhbHVlO1xuXHR9O1xufTtcblxuJC5XaWRnZXQgPSBmdW5jdGlvbiggLyogb3B0aW9ucywgZWxlbWVudCAqLyApIHt9O1xuJC5XaWRnZXQuX2NoaWxkQ29uc3RydWN0b3JzID0gW107XG5cbiQuV2lkZ2V0LnByb3RvdHlwZSA9IHtcblx0d2lkZ2V0TmFtZTogXCJ3aWRnZXRcIixcblx0d2lkZ2V0RXZlbnRQcmVmaXg6IFwiXCIsXG5cdGRlZmF1bHRFbGVtZW50OiBcIjxkaXY+XCIsXG5cdG9wdGlvbnM6IHtcblx0XHRkaXNhYmxlZDogZmFsc2UsXG5cblx0XHQvLyBjYWxsYmFja3Ncblx0XHRjcmVhdGU6IG51bGxcblx0fSxcblx0X2NyZWF0ZVdpZGdldDogZnVuY3Rpb24oIG9wdGlvbnMsIGVsZW1lbnQgKSB7XG5cdFx0ZWxlbWVudCA9ICQoIGVsZW1lbnQgfHwgdGhpcy5kZWZhdWx0RWxlbWVudCB8fCB0aGlzIClbIDAgXTtcblx0XHR0aGlzLmVsZW1lbnQgPSAkKCBlbGVtZW50ICk7XG5cdFx0dGhpcy51dWlkID0gdXVpZCsrO1xuXHRcdHRoaXMuZXZlbnROYW1lc3BhY2UgPSBcIi5cIiArIHRoaXMud2lkZ2V0TmFtZSArIHRoaXMudXVpZDtcblx0XHR0aGlzLm9wdGlvbnMgPSAkLndpZGdldC5leHRlbmQoIHt9LFxuXHRcdFx0dGhpcy5vcHRpb25zLFxuXHRcdFx0dGhpcy5fZ2V0Q3JlYXRlT3B0aW9ucygpLFxuXHRcdFx0b3B0aW9ucyApO1xuXG5cdFx0dGhpcy5iaW5kaW5ncyA9ICQoKTtcblx0XHR0aGlzLmhvdmVyYWJsZSA9ICQoKTtcblx0XHR0aGlzLmZvY3VzYWJsZSA9ICQoKTtcblxuXHRcdGlmICggZWxlbWVudCAhPT0gdGhpcyApIHtcblx0XHRcdCQuZGF0YSggZWxlbWVudCwgdGhpcy53aWRnZXRGdWxsTmFtZSwgdGhpcyApO1xuXHRcdFx0dGhpcy5fb24oIHRydWUsIHRoaXMuZWxlbWVudCwge1xuXHRcdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHRpZiAoIGV2ZW50LnRhcmdldCA9PT0gZWxlbWVudCApIHtcblx0XHRcdFx0XHRcdHRoaXMuZGVzdHJveSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLmRvY3VtZW50ID0gJCggZWxlbWVudC5zdHlsZSA/XG5cdFx0XHRcdC8vIGVsZW1lbnQgd2l0aGluIHRoZSBkb2N1bWVudFxuXHRcdFx0XHRlbGVtZW50Lm93bmVyRG9jdW1lbnQgOlxuXHRcdFx0XHQvLyBlbGVtZW50IGlzIHdpbmRvdyBvciBkb2N1bWVudFxuXHRcdFx0XHRlbGVtZW50LmRvY3VtZW50IHx8IGVsZW1lbnQgKTtcblx0XHRcdHRoaXMud2luZG93ID0gJCggdGhpcy5kb2N1bWVudFswXS5kZWZhdWx0VmlldyB8fCB0aGlzLmRvY3VtZW50WzBdLnBhcmVudFdpbmRvdyApO1xuXHRcdH1cblxuXHRcdHRoaXMuX2NyZWF0ZSgpO1xuXHRcdHRoaXMuX3RyaWdnZXIoIFwiY3JlYXRlXCIsIG51bGwsIHRoaXMuX2dldENyZWF0ZUV2ZW50RGF0YSgpICk7XG5cdFx0dGhpcy5faW5pdCgpO1xuXHR9LFxuXHRfZ2V0Q3JlYXRlT3B0aW9uczogJC5ub29wLFxuXHRfZ2V0Q3JlYXRlRXZlbnREYXRhOiAkLm5vb3AsXG5cdF9jcmVhdGU6ICQubm9vcCxcblx0X2luaXQ6ICQubm9vcCxcblxuXHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9kZXN0cm95KCk7XG5cdFx0Ly8gd2UgY2FuIHByb2JhYmx5IHJlbW92ZSB0aGUgdW5iaW5kIGNhbGxzIGluIDIuMFxuXHRcdC8vIGFsbCBldmVudCBiaW5kaW5ncyBzaG91bGQgZ28gdGhyb3VnaCB0aGlzLl9vbigpXG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQudW5iaW5kKCB0aGlzLmV2ZW50TmFtZXNwYWNlIClcblx0XHRcdC8vIDEuOSBCQyBmb3IgIzc4MTBcblx0XHRcdC8vIFRPRE8gcmVtb3ZlIGR1YWwgc3RvcmFnZVxuXHRcdFx0LnJlbW92ZURhdGEoIHRoaXMud2lkZ2V0TmFtZSApXG5cdFx0XHQucmVtb3ZlRGF0YSggdGhpcy53aWRnZXRGdWxsTmFtZSApXG5cdFx0XHQvLyBzdXBwb3J0OiBqcXVlcnkgPDEuNi4zXG5cdFx0XHQvLyBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC85NDEzXG5cdFx0XHQucmVtb3ZlRGF0YSggJC5jYW1lbENhc2UoIHRoaXMud2lkZ2V0RnVsbE5hbWUgKSApO1xuXHRcdHRoaXMud2lkZ2V0KClcblx0XHRcdC51bmJpbmQoIHRoaXMuZXZlbnROYW1lc3BhY2UgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1kaXNhYmxlZFwiIClcblx0XHRcdC5yZW1vdmVDbGFzcyhcblx0XHRcdFx0dGhpcy53aWRnZXRGdWxsTmFtZSArIFwiLWRpc2FibGVkIFwiICtcblx0XHRcdFx0XCJ1aS1zdGF0ZS1kaXNhYmxlZFwiICk7XG5cblx0XHQvLyBjbGVhbiB1cCBldmVudHMgYW5kIHN0YXRlc1xuXHRcdHRoaXMuYmluZGluZ3MudW5iaW5kKCB0aGlzLmV2ZW50TmFtZXNwYWNlICk7XG5cdFx0dGhpcy5ob3ZlcmFibGUucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtaG92ZXJcIiApO1xuXHRcdHRoaXMuZm9jdXNhYmxlLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWZvY3VzXCIgKTtcblx0fSxcblx0X2Rlc3Ryb3k6ICQubm9vcCxcblxuXHR3aWRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVsZW1lbnQ7XG5cdH0sXG5cblx0b3B0aW9uOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgb3B0aW9ucyA9IGtleSxcblx0XHRcdHBhcnRzLFxuXHRcdFx0Y3VyT3B0aW9uLFxuXHRcdFx0aTtcblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdC8vIGRvbid0IHJldHVybiBhIHJlZmVyZW5jZSB0byB0aGUgaW50ZXJuYWwgaGFzaFxuXHRcdFx0cmV0dXJuICQud2lkZ2V0LmV4dGVuZCgge30sIHRoaXMub3B0aW9ucyApO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdC8vIGhhbmRsZSBuZXN0ZWQga2V5cywgZS5nLiwgXCJmb28uYmFyXCIgPT4geyBmb286IHsgYmFyOiBfX18gfSB9XG5cdFx0XHRvcHRpb25zID0ge307XG5cdFx0XHRwYXJ0cyA9IGtleS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdGtleSA9IHBhcnRzLnNoaWZ0KCk7XG5cdFx0XHRpZiAoIHBhcnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y3VyT3B0aW9uID0gb3B0aW9uc1sga2V5IF0gPSAkLndpZGdldC5leHRlbmQoIHt9LCB0aGlzLm9wdGlvbnNbIGtleSBdICk7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrICkge1xuXHRcdFx0XHRcdGN1ck9wdGlvblsgcGFydHNbIGkgXSBdID0gY3VyT3B0aW9uWyBwYXJ0c1sgaSBdIF0gfHwge307XG5cdFx0XHRcdFx0Y3VyT3B0aW9uID0gY3VyT3B0aW9uWyBwYXJ0c1sgaSBdIF07XG5cdFx0XHRcdH1cblx0XHRcdFx0a2V5ID0gcGFydHMucG9wKCk7XG5cdFx0XHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gY3VyT3B0aW9uWyBrZXkgXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGN1ck9wdGlvblsga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdFx0Y3VyT3B0aW9uWyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnNbIGtleSBdID09PSB1bmRlZmluZWQgPyBudWxsIDogdGhpcy5vcHRpb25zWyBrZXkgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRvcHRpb25zWyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX3NldE9wdGlvbnMoIG9wdGlvbnMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHRfc2V0T3B0aW9uczogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0dmFyIGtleTtcblxuXHRcdGZvciAoIGtleSBpbiBvcHRpb25zICkge1xuXHRcdFx0dGhpcy5fc2V0T3B0aW9uKCBrZXksIG9wdGlvbnNbIGtleSBdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdF9zZXRPcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHRoaXMub3B0aW9uc1sga2V5IF0gPSB2YWx1ZTtcblxuXHRcdGlmICgga2V5ID09PSBcImRpc2FibGVkXCIgKSB7XG5cdFx0XHR0aGlzLndpZGdldCgpXG5cdFx0XHRcdC50b2dnbGVDbGFzcyggdGhpcy53aWRnZXRGdWxsTmFtZSArIFwiLWRpc2FibGVkIHVpLXN0YXRlLWRpc2FibGVkXCIsICEhdmFsdWUgKVxuXHRcdFx0XHQuYXR0ciggXCJhcmlhLWRpc2FibGVkXCIsIHZhbHVlICk7XG5cdFx0XHR0aGlzLmhvdmVyYWJsZS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1ob3ZlclwiICk7XG5cdFx0XHR0aGlzLmZvY3VzYWJsZS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZW5hYmxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2V0T3B0aW9uKCBcImRpc2FibGVkXCIsIGZhbHNlICk7XG5cdH0sXG5cdGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZXRPcHRpb24oIFwiZGlzYWJsZWRcIiwgdHJ1ZSApO1xuXHR9LFxuXG5cdF9vbjogZnVuY3Rpb24oIHN1cHByZXNzRGlzYWJsZWRDaGVjaywgZWxlbWVudCwgaGFuZGxlcnMgKSB7XG5cdFx0dmFyIGRlbGVnYXRlRWxlbWVudCxcblx0XHRcdGluc3RhbmNlID0gdGhpcztcblxuXHRcdC8vIG5vIHN1cHByZXNzRGlzYWJsZWRDaGVjayBmbGFnLCBzaHVmZmxlIGFyZ3VtZW50c1xuXHRcdGlmICggdHlwZW9mIHN1cHByZXNzRGlzYWJsZWRDaGVjayAhPT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRoYW5kbGVycyA9IGVsZW1lbnQ7XG5cdFx0XHRlbGVtZW50ID0gc3VwcHJlc3NEaXNhYmxlZENoZWNrO1xuXHRcdFx0c3VwcHJlc3NEaXNhYmxlZENoZWNrID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gbm8gZWxlbWVudCBhcmd1bWVudCwgc2h1ZmZsZSBhbmQgdXNlIHRoaXMuZWxlbWVudFxuXHRcdGlmICggIWhhbmRsZXJzICkge1xuXHRcdFx0aGFuZGxlcnMgPSBlbGVtZW50O1xuXHRcdFx0ZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblx0XHRcdGRlbGVnYXRlRWxlbWVudCA9IHRoaXMud2lkZ2V0KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGFjY2VwdCBzZWxlY3RvcnMsIERPTSBlbGVtZW50c1xuXHRcdFx0ZWxlbWVudCA9IGRlbGVnYXRlRWxlbWVudCA9ICQoIGVsZW1lbnQgKTtcblx0XHRcdHRoaXMuYmluZGluZ3MgPSB0aGlzLmJpbmRpbmdzLmFkZCggZWxlbWVudCApO1xuXHRcdH1cblxuXHRcdCQuZWFjaCggaGFuZGxlcnMsIGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlciApIHtcblx0XHRcdGZ1bmN0aW9uIGhhbmRsZXJQcm94eSgpIHtcblx0XHRcdFx0Ly8gYWxsb3cgd2lkZ2V0cyB0byBjdXN0b21pemUgdGhlIGRpc2FibGVkIGhhbmRsaW5nXG5cdFx0XHRcdC8vIC0gZGlzYWJsZWQgYXMgYW4gYXJyYXkgaW5zdGVhZCBvZiBib29sZWFuXG5cdFx0XHRcdC8vIC0gZGlzYWJsZWQgY2xhc3MgYXMgbWV0aG9kIGZvciBkaXNhYmxpbmcgaW5kaXZpZHVhbCBwYXJ0c1xuXHRcdFx0XHRpZiAoICFzdXBwcmVzc0Rpc2FibGVkQ2hlY2sgJiZcblx0XHRcdFx0XHRcdCggaW5zdGFuY2Uub3B0aW9ucy5kaXNhYmxlZCA9PT0gdHJ1ZSB8fFxuXHRcdFx0XHRcdFx0XHQkKCB0aGlzICkuaGFzQ2xhc3MoIFwidWktc3RhdGUtZGlzYWJsZWRcIiApICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAoIHR5cGVvZiBoYW5kbGVyID09PSBcInN0cmluZ1wiID8gaW5zdGFuY2VbIGhhbmRsZXIgXSA6IGhhbmRsZXIgKVxuXHRcdFx0XHRcdC5hcHBseSggaW5zdGFuY2UsIGFyZ3VtZW50cyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjb3B5IHRoZSBndWlkIHNvIGRpcmVjdCB1bmJpbmRpbmcgd29ya3Ncblx0XHRcdGlmICggdHlwZW9mIGhhbmRsZXIgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdGhhbmRsZXJQcm94eS5ndWlkID0gaGFuZGxlci5ndWlkID1cblx0XHRcdFx0XHRoYW5kbGVyLmd1aWQgfHwgaGFuZGxlclByb3h5Lmd1aWQgfHwgJC5ndWlkKys7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBtYXRjaCA9IGV2ZW50Lm1hdGNoKCAvXihcXHcrKVxccyooLiopJC8gKSxcblx0XHRcdFx0ZXZlbnROYW1lID0gbWF0Y2hbMV0gKyBpbnN0YW5jZS5ldmVudE5hbWVzcGFjZSxcblx0XHRcdFx0c2VsZWN0b3IgPSBtYXRjaFsyXTtcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGRlbGVnYXRlRWxlbWVudC5kZWxlZ2F0ZSggc2VsZWN0b3IsIGV2ZW50TmFtZSwgaGFuZGxlclByb3h5ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtZW50LmJpbmQoIGV2ZW50TmFtZSwgaGFuZGxlclByb3h5ICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0X29mZjogZnVuY3Rpb24oIGVsZW1lbnQsIGV2ZW50TmFtZSApIHtcblx0XHRldmVudE5hbWUgPSAoZXZlbnROYW1lIHx8IFwiXCIpLnNwbGl0KCBcIiBcIiApLmpvaW4oIHRoaXMuZXZlbnROYW1lc3BhY2UgKyBcIiBcIiApICsgdGhpcy5ldmVudE5hbWVzcGFjZTtcblx0XHRlbGVtZW50LnVuYmluZCggZXZlbnROYW1lICkudW5kZWxlZ2F0ZSggZXZlbnROYW1lICk7XG5cdH0sXG5cblx0X2RlbGF5OiBmdW5jdGlvbiggaGFuZGxlciwgZGVsYXkgKSB7XG5cdFx0ZnVuY3Rpb24gaGFuZGxlclByb3h5KCkge1xuXHRcdFx0cmV0dXJuICggdHlwZW9mIGhhbmRsZXIgPT09IFwic3RyaW5nXCIgPyBpbnN0YW5jZVsgaGFuZGxlciBdIDogaGFuZGxlciApXG5cdFx0XHRcdC5hcHBseSggaW5zdGFuY2UsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0XHR2YXIgaW5zdGFuY2UgPSB0aGlzO1xuXHRcdHJldHVybiBzZXRUaW1lb3V0KCBoYW5kbGVyUHJveHksIGRlbGF5IHx8IDAgKTtcblx0fSxcblxuXHRfaG92ZXJhYmxlOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHR0aGlzLmhvdmVyYWJsZSA9IHRoaXMuaG92ZXJhYmxlLmFkZCggZWxlbWVudCApO1xuXHRcdHRoaXMuX29uKCBlbGVtZW50LCB7XG5cdFx0XHRtb3VzZWVudGVyOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdCQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKS5hZGRDbGFzcyggXCJ1aS1zdGF0ZS1ob3ZlclwiICk7XG5cdFx0XHR9LFxuXHRcdFx0bW91c2VsZWF2ZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHQkKCBldmVudC5jdXJyZW50VGFyZ2V0ICkucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtaG92ZXJcIiApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdF9mb2N1c2FibGU6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHRoaXMuZm9jdXNhYmxlID0gdGhpcy5mb2N1c2FibGUuYWRkKCBlbGVtZW50ICk7XG5cdFx0dGhpcy5fb24oIGVsZW1lbnQsIHtcblx0XHRcdGZvY3VzaW46IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0JCggZXZlbnQuY3VycmVudFRhcmdldCApLmFkZENsYXNzKCBcInVpLXN0YXRlLWZvY3VzXCIgKTtcblx0XHRcdH0sXG5cdFx0XHRmb2N1c291dDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHQkKCBldmVudC5jdXJyZW50VGFyZ2V0ICkucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdF90cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZXZlbnQsIGRhdGEgKSB7XG5cdFx0dmFyIHByb3AsIG9yaWcsXG5cdFx0XHRjYWxsYmFjayA9IHRoaXMub3B0aW9uc1sgdHlwZSBdO1xuXG5cdFx0ZGF0YSA9IGRhdGEgfHwge307XG5cdFx0ZXZlbnQgPSAkLkV2ZW50KCBldmVudCApO1xuXHRcdGV2ZW50LnR5cGUgPSAoIHR5cGUgPT09IHRoaXMud2lkZ2V0RXZlbnRQcmVmaXggP1xuXHRcdFx0dHlwZSA6XG5cdFx0XHR0aGlzLndpZGdldEV2ZW50UHJlZml4ICsgdHlwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0Ly8gdGhlIG9yaWdpbmFsIGV2ZW50IG1heSBjb21lIGZyb20gYW55IGVsZW1lbnRcblx0XHQvLyBzbyB3ZSBuZWVkIHRvIHJlc2V0IHRoZSB0YXJnZXQgb24gdGhlIG5ldyBldmVudFxuXHRcdGV2ZW50LnRhcmdldCA9IHRoaXMuZWxlbWVudFsgMCBdO1xuXG5cdFx0Ly8gY29weSBvcmlnaW5hbCBldmVudCBwcm9wZXJ0aWVzIG92ZXIgdG8gdGhlIG5ldyBldmVudFxuXHRcdG9yaWcgPSBldmVudC5vcmlnaW5hbEV2ZW50O1xuXHRcdGlmICggb3JpZyApIHtcblx0XHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdFx0aWYgKCAhKCBwcm9wIGluIGV2ZW50ICkgKSB7XG5cdFx0XHRcdFx0ZXZlbnRbIHByb3AgXSA9IG9yaWdbIHByb3AgXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuZWxlbWVudC50cmlnZ2VyKCBldmVudCwgZGF0YSApO1xuXHRcdHJldHVybiAhKCAkLmlzRnVuY3Rpb24oIGNhbGxiYWNrICkgJiZcblx0XHRcdGNhbGxiYWNrLmFwcGx5KCB0aGlzLmVsZW1lbnRbMF0sIFsgZXZlbnQgXS5jb25jYXQoIGRhdGEgKSApID09PSBmYWxzZSB8fFxuXHRcdFx0ZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKTtcblx0fVxufTtcblxuJC5lYWNoKCB7IHNob3c6IFwiZmFkZUluXCIsIGhpZGU6IFwiZmFkZU91dFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIGRlZmF1bHRFZmZlY3QgKSB7XG5cdCQuV2lkZ2V0LnByb3RvdHlwZVsgXCJfXCIgKyBtZXRob2QgXSA9IGZ1bmN0aW9uKCBlbGVtZW50LCBvcHRpb25zLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b3B0aW9ucyA9IHsgZWZmZWN0OiBvcHRpb25zIH07XG5cdFx0fVxuXHRcdHZhciBoYXNPcHRpb25zLFxuXHRcdFx0ZWZmZWN0TmFtZSA9ICFvcHRpb25zID9cblx0XHRcdFx0bWV0aG9kIDpcblx0XHRcdFx0b3B0aW9ucyA9PT0gdHJ1ZSB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIiA/XG5cdFx0XHRcdFx0ZGVmYXVsdEVmZmVjdCA6XG5cdFx0XHRcdFx0b3B0aW9ucy5lZmZlY3QgfHwgZGVmYXVsdEVmZmVjdDtcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRpZiAoIHR5cGVvZiBvcHRpb25zID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0b3B0aW9ucyA9IHsgZHVyYXRpb246IG9wdGlvbnMgfTtcblx0XHR9XG5cdFx0aGFzT3B0aW9ucyA9ICEkLmlzRW1wdHlPYmplY3QoIG9wdGlvbnMgKTtcblx0XHRvcHRpb25zLmNvbXBsZXRlID0gY2FsbGJhY2s7XG5cdFx0aWYgKCBvcHRpb25zLmRlbGF5ICkge1xuXHRcdFx0ZWxlbWVudC5kZWxheSggb3B0aW9ucy5kZWxheSApO1xuXHRcdH1cblx0XHRpZiAoIGhhc09wdGlvbnMgJiYgJC5lZmZlY3RzICYmICQuZWZmZWN0cy5lZmZlY3RbIGVmZmVjdE5hbWUgXSApIHtcblx0XHRcdGVsZW1lbnRbIG1ldGhvZCBdKCBvcHRpb25zICk7XG5cdFx0fSBlbHNlIGlmICggZWZmZWN0TmFtZSAhPT0gbWV0aG9kICYmIGVsZW1lbnRbIGVmZmVjdE5hbWUgXSApIHtcblx0XHRcdGVsZW1lbnRbIGVmZmVjdE5hbWUgXSggb3B0aW9ucy5kdXJhdGlvbiwgb3B0aW9ucy5lYXNpbmcsIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW1lbnQucXVldWUoZnVuY3Rpb24oIG5leHQgKSB7XG5cdFx0XHRcdCQoIHRoaXMgKVsgbWV0aG9kIF0oKTtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKCBlbGVtZW50WyAwIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRuZXh0KCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG59KTtcblxufSkpO1xuIiwiLyoqXG4gKiB2ZXJzaW9uIDIuMS4zMFxuICogQGxpY2Vuc2VcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLmpzXG4gKiBodHRwOi8vd3d3LmV5ZWNvbi5yby9ib290c3RyYXAtZGF0ZXBpY2tlclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMiBTdGVmYW4gUGV0cmVcbiAqXG4gKiBDb250cmlidXRpb25zOlxuICogLSB1cGRhdGVkIGZvciBCb290c3RyYXAgdjMgYnkgSm9uYXRoYW4gUGV0ZXJzb24gKEBFb25hc2RhbikgYW5kIChhbG1vc3QpXG4gKiAgICBjb21wbGV0ZWx5IHJld3JpdHRlbiB0byB1c2UgTW9tZW50anNcbiAqIC0gYmFzZWQgb24gdGFycnVkYSdzIGJvb3RzdHJhcC1kYXRlcGlja2VyXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuOyAoZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQU1EIGlzIHVzZWQgLSBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgICBkZWZpbmUoWydqcXVlcnknLCAnbW9tZW50J10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFNRCBpcyBub3QgdXNlZCAtIEF0dGVtcHQgdG8gZmV0Y2ggZGVwZW5kZW5jaWVzIGZyb20gc2NvcGUuXG4gICAgICAgIGlmKCFqUXVlcnkpe1xuICAgICAgICAgICAgdGhyb3cgJ2Jvb3RzdHJhcC1kYXRldGltZXBpY2tlciByZXF1aXJlcyBqUXVlcnkgdG8gYmUgbG9hZGVkIGZpcnN0JztcbiAgICAgICAgfWVsc2UgaWYoIW1vbWVudCkge1xuICAgICAgICAgICAgdGhyb3cgJ2Jvb3RzdHJhcC1kYXRldGltZXBpY2tlciByZXF1aXJlcyBtb21lbnQuanMgdG8gYmUgbG9hZGVkIGZpcnN0JztcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBmYWN0b3J5KGpRdWVyeSwgbW9tZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuKGZ1bmN0aW9uICgkLCBtb21lbnQpIHtcbiAgICBpZiAodHlwZW9mIG1vbWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgYWxlcnQoXCJtb21lbnRqcyBpcyByZXF1cmllZFwiKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtb21lbnRqcyBpcyByZXF1aXJlZCcpO1xuICAgIH07XG5cbiAgICB2YXIgZHBnSWQgPSAwLFxuXG4gICAgcE1vbWVudCA9IG1vbWVudCxcblxuLy8gUmVTaGFycGVyIGRpc2FibGUgb25jZSBJbmNvbnNpc3RlbnROYW1pbmdcbiAgICBEYXRlVGltZVBpY2tlciA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgICAgIHBpY2tEYXRlOiB0cnVlLFxuICAgICAgICAgICAgcGlja1RpbWU6IHRydWUsXG4gICAgICAgICAgICB1c2VNaW51dGVzOiB0cnVlLFxuICAgICAgICAgICAgdXNlU2Vjb25kczogZmFsc2UsXG4gICAgICAgICAgICBtaW51dGVTdGVwcGluZzogMSxcbiAgICAgICAgICAgIHN0YXJ0RGF0ZTogbmV3IHBNb21lbnQoeyB5OiAxOTcwIH0pLFxuICAgICAgICAgICAgZW5kRGF0ZTogbmV3IHBNb21lbnQoKS5hZGQoNTAsIFwieVwiKSxcbiAgICAgICAgICAgIGNvbGxhcHNlOiB0cnVlLFxuICAgICAgICAgICAgbGFuZ3VhZ2U6IHBNb21lbnQubGFuZygpLFxuICAgICAgICAgICAgZGVmYXVsdERhdGU6IFwiXCIsXG4gICAgICAgICAgICBkaXNhYmxlZERhdGVzOiBbXSxcbiAgICAgICAgICAgIGVuYWJsZWREYXRlczogZmFsc2UsXG4gICAgICAgICAgICBpY29uczoge30sXG4gICAgICAgICAgICB1c2VTdHJpY3Q6IGZhbHNlLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBcImF1dG9cIlxuICAgICAgICB9LFxuXG5cdFx0aWNvbnMgPSB7XG5cdFx0ICAgIHRpbWU6ICdnbHlwaGljb24gZ2x5cGhpY29uLXRpbWUnLFxuXHRcdCAgICBkYXRlOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1jYWxlbmRhcicsXG5cdFx0ICAgIHVwOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLXVwJyxcblx0XHQgICAgZG93bjogJ2dseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi1kb3duJ1xuXHRcdH0sXG5cbiAgICAgICAgcGlja2VyID0gdGhpcyxcblxuICAgICAgICBpbml0ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICB2YXIgaWNvbiA9IGZhbHNlLCBpLCBkRGF0ZSwgbG9uZ0RhdGVGb3JtYXQ7XG4gICAgICAgICAgICBwaWNrZXIub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgICAgICAgICBwaWNrZXIub3B0aW9ucy5pY29ucyA9ICQuZXh0ZW5kKHt9LCBpY29ucywgcGlja2VyLm9wdGlvbnMuaWNvbnMpO1xuXG4gICAgICAgICAgICBwaWNrZXIuZWxlbWVudCA9ICQoZWxlbWVudCk7XG5cbiAgICAgICAgICAgIGRhdGFUb09wdGlvbnMoKTtcblxuICAgICAgICAgICAgaWYgKCEocGlja2VyLm9wdGlvbnMucGlja1RpbWUgfHwgcGlja2VyLm9wdGlvbnMucGlja0RhdGUpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBjaG9vc2UgYXQgbGVhc3Qgb25lIHBpY2tlcicpO1xuXG4gICAgICAgICAgICBwaWNrZXIuaWQgPSBkcGdJZCsrO1xuICAgICAgICAgICAgcE1vbWVudC5sYW5nKHBpY2tlci5vcHRpb25zLmxhbmd1YWdlKTtcbiAgICAgICAgICAgIHBpY2tlci5kYXRlID0gcE1vbWVudCgpO1xuICAgICAgICAgICAgcGlja2VyLnVuc2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBwaWNrZXIuaXNJbnB1dCA9IHBpY2tlci5lbGVtZW50LmlzKCdpbnB1dCcpO1xuICAgICAgICAgICAgcGlja2VyLmNvbXBvbmVudCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAocGlja2VyLmVsZW1lbnQuaGFzQ2xhc3MoJ2lucHV0LWdyb3VwJykpIHtcbiAgICAgICAgICAgICAgICBpZiAocGlja2VyLmVsZW1lbnQuZmluZCgnLmRhdGVwaWNrZXJidXR0b24nKS5zaXplKCkgPT0gMCkgey8vaW4gY2FzZSB0aGVyZSBpcyBtb3JlIHRoZW4gb25lICdpbnB1dC1ncm91cC1hZGRvbmAgIzQ4XG4gICAgICAgICAgICAgICAgICAgIHBpY2tlci5jb21wb25lbnQgPSBwaWNrZXIuZWxlbWVudC5maW5kKFwiW2NsYXNzXj0naW5wdXQtZ3JvdXAtJ11cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwaWNrZXIuY29tcG9uZW50ID0gcGlja2VyLmVsZW1lbnQuZmluZCgnLmRhdGVwaWNrZXJidXR0b24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwaWNrZXIuZm9ybWF0ID0gcGlja2VyLm9wdGlvbnMuZm9ybWF0O1xuXG4gICAgICAgICAgICBsb25nRGF0ZUZvcm1hdCA9IHBNb21lbnQoKS5fbGFuZy5fbG9uZ0RhdGVGb3JtYXQ7XG5cbiAgICAgICAgICAgIGlmICghcGlja2VyLmZvcm1hdCkge1xuICAgICAgICAgICAgICAgIGlmIChwaWNrZXIuaXNJbnB1dCkgcGlja2VyLmZvcm1hdCA9IHBpY2tlci5lbGVtZW50LmRhdGEoJ2Zvcm1hdCcpO1xuICAgICAgICAgICAgICAgIGVsc2UgcGlja2VyLmZvcm1hdCA9IHBpY2tlci5lbGVtZW50LmZpbmQoJ2lucHV0JykuZGF0YSgnZm9ybWF0Jyk7XG4gICAgICAgICAgICAgICAgaWYgKCFwaWNrZXIuZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBpY2tlci5mb3JtYXQgPSAocGlja2VyLm9wdGlvbnMucGlja0RhdGUgPyBsb25nRGF0ZUZvcm1hdC5MIDogJycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGlja2VyLm9wdGlvbnMucGlja0RhdGUgJiYgcGlja2VyLm9wdGlvbnMucGlja1RpbWUpIHBpY2tlci5mb3JtYXQgKz0gJyAnO1xuICAgICAgICAgICAgICAgICAgICBwaWNrZXIuZm9ybWF0ICs9IChwaWNrZXIub3B0aW9ucy5waWNrVGltZSA/IGxvbmdEYXRlRm9ybWF0LkxUIDogJycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGlja2VyLm9wdGlvbnMudXNlU2Vjb25kcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKH5sb25nRGF0ZUZvcm1hdC5MVC5pbmRleE9mKCcgQScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGlja2VyLmZvcm1hdCA9IHBpY2tlci5mb3JtYXQuc3BsaXQoXCIgQVwiKVswXSArIFwiOnNzIEFcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpY2tlci5mb3JtYXQgKz0gJzpzcyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBpY2tlci5vcHRpb25zLnVzZTI0aG91cnMgPSBwaWNrZXIuZm9ybWF0LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcImFcIikgPCAxO1xuXG4gICAgICAgICAgICBpZiAocGlja2VyLmNvbXBvbmVudCkgaWNvbiA9IHBpY2tlci5jb21wb25lbnQuZmluZCgnc3BhbicpO1xuXG4gICAgICAgICAgICBpZiAocGlja2VyLm9wdGlvbnMucGlja1RpbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaWNvbikgaWNvbi5hZGRDbGFzcyhwaWNrZXIub3B0aW9ucy5pY29ucy50aW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwaWNrZXIub3B0aW9ucy5waWNrRGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChpY29uKSB7XG4gICAgICAgICAgICAgICAgICAgIGljb24ucmVtb3ZlQ2xhc3MocGlja2VyLm9wdGlvbnMuaWNvbnMudGltZSk7XG4gICAgICAgICAgICAgICAgICAgIGljb24uYWRkQ2xhc3MocGlja2VyLm9wdGlvbnMuaWNvbnMuZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwaWNrZXIud2lkZ2V0ID0gJChnZXRUZW1wbGF0ZShwaWNrZXIub3B0aW9ucy5waWNrRGF0ZSwgcGlja2VyLm9wdGlvbnMucGlja1RpbWUsIHBpY2tlci5vcHRpb25zLmNvbGxhcHNlKSkuYXBwZW5kVG8oJ2JvZHknKTtcbiAgICAgICAgICAgIHBpY2tlci5taW5WaWV3TW9kZSA9IHBpY2tlci5vcHRpb25zLm1pblZpZXdNb2RlIHx8IHBpY2tlci5lbGVtZW50LmRhdGEoJ2RhdGUtbWludmlld21vZGUnKSB8fCAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwaWNrZXIubWluVmlld01vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChwaWNrZXIubWluVmlld01vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbW9udGhzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpY2tlci5taW5WaWV3TW9kZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAneWVhcnMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGlja2VyLm1pblZpZXdNb2RlID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcGlja2VyLm1pblZpZXdNb2RlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBpY2tlci52aWV3TW9kZSA9IHBpY2tlci5vcHRpb25zLnZpZXdNb2RlIHx8IHBpY2tlci5lbGVtZW50LmRhdGEoJ2RhdGUtdmlld21vZGUnKSB8fCAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwaWNrZXIudmlld01vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChwaWNrZXIudmlld01vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbW9udGhzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpY2tlci52aWV3TW9kZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAneWVhcnMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGlja2VyLnZpZXdNb2RlID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcGlja2VyLnZpZXdNb2RlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHBpY2tlci5vcHRpb25zLmRpc2FibGVkRGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkRGF0ZSA9IHBpY2tlci5vcHRpb25zLmRpc2FibGVkRGF0ZXNbaV07XG4gICAgICAgICAgICAgICAgZERhdGUgPSBwTW9tZW50KGREYXRlKTtcbiAgICAgICAgICAgICAgICAvL2lmIHRoaXMgaXMgbm90IGEgdmFsaWQgZGF0ZSB0aGVuIHNldCBpdCB0byB0aGUgc3RhcnRkYXRlIC0xIGRheSBzbyBpdCdzIGRpc2FibGVkLlxuICAgICAgICAgICAgICAgIGlmICghZERhdGUuaXNWYWxpZCgpKSBkRGF0ZSA9IHBNb21lbnQocGlja2VyLm9wdGlvbnMuc3RhcnREYXRlKS5zdWJ0cmFjdCgxLCBcImRheVwiKTtcbiAgICAgICAgICAgICAgICBwaWNrZXIub3B0aW9ucy5kaXNhYmxlZERhdGVzW2ldID0gZERhdGUuZm9ybWF0KFwiTFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHBpY2tlci5vcHRpb25zLmVuYWJsZWREYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGREYXRlID0gcGlja2VyLm9wdGlvbnMuZW5hYmxlZERhdGVzW2ldO1xuICAgICAgICAgICAgICAgIGREYXRlID0gcE1vbWVudChkRGF0ZSk7XG4gICAgICAgICAgICAgICAgLy9pZiB0aGlzIGlzIG5vdCBhIHZhbGlkIGRhdGUgdGhlbiBzZXQgaXQgdG8gdGhlIHN0YXJ0ZGF0ZSAtMSBkYXkgc28gaXQncyBkaXNhYmxlZC5cbiAgICAgICAgICAgICAgICBpZiAoIWREYXRlLmlzVmFsaWQoKSkgZERhdGUgPSBwTW9tZW50KHBpY2tlci5vcHRpb25zLnN0YXJ0RGF0ZSkuc3VidHJhY3QoMSwgXCJkYXlcIik7XG4gICAgICAgICAgICAgICAgcGlja2VyLm9wdGlvbnMuZW5hYmxlZERhdGVzW2ldID0gZERhdGUuZm9ybWF0KFwiTFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBpY2tlci5zdGFydFZpZXdNb2RlID0gcGlja2VyLnZpZXdNb2RlO1xuICAgICAgICAgICAgcGlja2VyLnNldFN0YXJ0RGF0ZShwaWNrZXIub3B0aW9ucy5zdGFydERhdGUgfHwgcGlja2VyLmVsZW1lbnQuZGF0YSgnZGF0ZS1zdGFydGRhdGUnKSk7XG4gICAgICAgICAgICBwaWNrZXIuc2V0RW5kRGF0ZShwaWNrZXIub3B0aW9ucy5lbmREYXRlIHx8IHBpY2tlci5lbGVtZW50LmRhdGEoJ2RhdGUtZW5kZGF0ZScpKTtcbiAgICAgICAgICAgIGZpbGxEb3coKTtcbiAgICAgICAgICAgIGZpbGxNb250aHMoKTtcbiAgICAgICAgICAgIGZpbGxIb3VycygpO1xuICAgICAgICAgICAgZmlsbE1pbnV0ZXMoKTtcblx0XHRcdGZpbGxTZWNvbmRzKCk7XG4gICAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgICAgIHNob3dNb2RlKCk7XG4gICAgICAgICAgICBhdHRhY2hEYXRlUGlja2VyRXZlbnRzKCk7XG4gICAgICAgICAgICBpZiAocGlja2VyLm9wdGlvbnMuZGVmYXVsdERhdGUgIT09IFwiXCIpIHBpY2tlci5zZXRWYWx1ZShwaWNrZXIub3B0aW9ucy5kZWZhdWx0RGF0ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGF0YVRvT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlRGF0YSA9IHBpY2tlci5lbGVtZW50LmRhdGEoKTtcbiAgICAgICAgICAgIGlmIChlRGF0YS5waWNrZGF0ZSAhPT0gdW5kZWZpbmVkKSBwaWNrZXIub3B0aW9ucy5waWNrRGF0ZSA9IGVEYXRhLnBpY2tkYXRlO1xuICAgICAgICAgICAgaWYgKGVEYXRhLnBpY2t0aW1lICE9PSB1bmRlZmluZWQpIHBpY2tlci5vcHRpb25zLnBpY2tUaW1lID0gZURhdGEucGlja3RpbWU7XG4gICAgICAgICAgICBpZiAoZURhdGEudXNlbWludXRlcyAhPT0gdW5kZWZpbmVkKSBwaWNrZXIub3B0aW9ucy51c2VNaW51dGVzID0gZURhdGEudXNlbWludXRlcztcbiAgICAgICAgICAgIGlmIChlRGF0YS51c2VzZWNvbmRzICE9PSB1bmRlZmluZWQpIHBpY2tlci5vcHRpb25zLnVzZVNlY29uZHMgPSBlRGF0YS51c2VzZWNvbmRzO1xuICAgICAgICAgICAgaWYgKGVEYXRhLm1pbnV0ZXN0ZXBwaW5nICE9PSB1bmRlZmluZWQpIHBpY2tlci5vcHRpb25zLm1pbnV0ZVN0ZXBwaW5nID0gZURhdGEubWludXRlc3RlcHBpbmc7XG4gICAgICAgICAgICBpZiAoZURhdGEuc3RhcnRkYXRlICE9PSB1bmRlZmluZWQpIHBpY2tlci5vcHRpb25zLnN0YXJ0RGF0ZSA9IGVEYXRhLnN0YXJ0ZGF0ZTtcbiAgICAgICAgICAgIGlmIChlRGF0YS5lbmRkYXRlICE9PSB1bmRlZmluZWQpIHBpY2tlci5vcHRpb25zLmVuZERhdGUgPSBlRGF0YS5lbmRkYXRlO1xuICAgICAgICAgICAgaWYgKGVEYXRhLmNvbGxhcHNlICE9PSB1bmRlZmluZWQpIHBpY2tlci5vcHRpb25zLmNvbGxhcHNlID0gZURhdGEuY29sbGFwc2U7XG4gICAgICAgICAgICBpZiAoZURhdGEubGFuZ3VhZ2UgIT09IHVuZGVmaW5lZCkgcGlja2VyLm9wdGlvbnMubGFuZ3VhZ2UgPSBlRGF0YS5sYW5ndWFnZTtcbiAgICAgICAgICAgIGlmIChlRGF0YS5kZWZhdWx0ZGF0ZSAhPT0gdW5kZWZpbmVkKSBwaWNrZXIub3B0aW9ucy5kZWZhdWx0RGF0ZSA9IGVEYXRhLmRlZmF1bHRkYXRlO1xuICAgICAgICAgICAgaWYgKGVEYXRhLmRpc2FibGVkZGF0ZXMgIT09IHVuZGVmaW5lZCkgcGlja2VyLm9wdGlvbnMuZGlzYWJsZWREYXRlcyA9IGVEYXRhLmRpc2FibGVkZGF0ZXM7XG4gICAgICAgICAgICBpZiAoZURhdGEuZW5hYmxlZGRhdGVzICE9PSB1bmRlZmluZWQpIHBpY2tlci5vcHRpb25zLmVuYWJsZWREYXRlcyA9IGVEYXRhLmVuYWJsZWRkYXRlcztcbiAgICAgICAgICAgIGlmIChlRGF0YS5pY29ucyAhPT0gdW5kZWZpbmVkKSBwaWNrZXIub3B0aW9ucy5pY29ucyA9IGVEYXRhLmljb25zO1xuICAgICAgICAgICAgaWYgKGVEYXRhLnVzZXN0cmljdCAhPT0gdW5kZWZpbmVkKSBwaWNrZXIub3B0aW9ucy51c2VTdHJpY3QgPSBlRGF0YS51c2VzdHJpY3Q7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGxhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgb2Zmc2V0ID0gcGlja2VyLmNvbXBvbmVudCA/IHBpY2tlci5jb21wb25lbnQub2Zmc2V0KCkgOiBwaWNrZXIuZWxlbWVudC5vZmZzZXQoKSwgJHdpbmRvdyA9ICQod2luZG93KTtcbiAgICAgICAgICAgIHBpY2tlci53aWR0aCA9IHBpY2tlci5jb21wb25lbnQgPyBwaWNrZXIuY29tcG9uZW50Lm91dGVyV2lkdGgoKSA6IHBpY2tlci5lbGVtZW50Lm91dGVyV2lkdGgoKTtcbiAgICAgICAgICAgIG9mZnNldC50b3AgPSBvZmZzZXQudG9wICsgcGlja2VyLmVsZW1lbnQub3V0ZXJIZWlnaHQoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gaWYgKHBpY2tlci5vcHRpb25zLmRpcmVjdGlvbiA9PT0gJ3VwJyB8fCBwaWNrZXIub3B0aW9ucy5kaXJlY3Rpb24gPT09ICdhdXRvJyAmJiBvZmZzZXQudG9wICsgcGlja2VyLndpZGdldC5oZWlnaHQoKSA+ICR3aW5kb3cuaGVpZ2h0KCkpIHtcbiAgICAgICAgXHRcdC8vIG9mZnNldC50b3AgLT0gcGlja2VyLndpZGdldC5oZWlnaHQoKSArIHBpY2tlci5lbGVtZW50Lm91dGVySGVpZ2h0KCk7XG4gICAgICAgICAgICBcdC8vIHBpY2tlci53aWRnZXQuYWRkQ2xhc3MoJ3VwJyk7XG4gICAgICAgICAgICAvLyB9IGVsc2UgaWYgKHBpY2tlci5vcHRpb25zLmRpcmVjdGlvbiA9PT0gJ2Rvd24nIHx8IHBpY2tlci5vcHRpb25zLmRpcmVjdGlvbiA9PT0gJ2F1dG8nICYmIG9mZnNldC50b3AgKyBwaWNrZXIud2lkZ2V0LmhlaWdodCgpIDw9ICR3aW5kb3cuaGVpZ2h0KCkpIHtcbiAgICAgICAgICAgIFx0Ly8gb2Zmc2V0LnRvcCArPSBwaWNrZXIuZWxlbWVudC5vdXRlckhlaWdodCgpO1xuICAgICAgICAgICAgXHQvLyBwaWNrZXIud2lkZ2V0LmFkZENsYXNzKCdkb3duJyk7XG4gICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgIGlmIChwaWNrZXIub3B0aW9ucy53aWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGlja2VyLndpZGdldC53aWR0aChwaWNrZXIub3B0aW9ucy53aWR0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwaWNrZXIub3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICAgICAgcGlja2VyLndpZGdldC5hZGRDbGFzcygnbGVmdC1vcmllbnRlZCcpO1xuICAgICAgICAgICAgICAgIG9mZnNldC5sZWZ0ID0gb2Zmc2V0LmxlZnQgLSBwaWNrZXIud2lkZ2V0LndpZHRoKCkgKyAyMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzSW5GaXhlZCgpKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSAnZml4ZWQnO1xuICAgICAgICAgICAgICAgIG9mZnNldC50b3AgLT0gJHdpbmRvdy5zY3JvbGxUb3AoKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQubGVmdCAtPSAkd2luZG93LnNjcm9sbExlZnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCR3aW5kb3cud2lkdGgoKSA8IG9mZnNldC5sZWZ0ICsgcGlja2VyLndpZGdldC5vdXRlcldpZHRoKCkpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQucmlnaHQgPSAkd2luZG93LndpZHRoKCkgLSBvZmZzZXQubGVmdCAtIHBpY2tlci53aWR0aDtcbiAgICAgICAgICAgICAgICBvZmZzZXQubGVmdCA9ICdhdXRvJztcbiAgICAgICAgICAgICAgICBwaWNrZXIud2lkZ2V0LmFkZENsYXNzKCdwdWxsLXJpZ2h0Jyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9mZnNldC5yaWdodCA9ICdhdXRvJztcbiAgICAgICAgICAgICAgICBwaWNrZXIud2lkZ2V0LnJlbW92ZUNsYXNzKCdwdWxsLXJpZ2h0Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBpY2tlci53aWRnZXQuY3NzKHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgdG9wOiBvZmZzZXQudG9wLFxuICAgICAgICAgICAgICAgIGxlZnQ6IG9mZnNldC5sZWZ0LFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBvZmZzZXQucmlnaHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIG5vdGlmeUNoYW5nZSA9IGZ1bmN0aW9uIChvbGREYXRlLCBldmVudFR5cGUpIHtcbiAgICAgICAgICAgIHBpY2tlci5lbGVtZW50LnRyaWdnZXIoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdjaGFuZ2UuZHAnLFxuICAgICAgICAgICAgICAgIGRhdGU6IHBNb21lbnQocGlja2VyLmRhdGUpLFxuICAgICAgICAgICAgICAgIG9sZERhdGU6IHBNb21lbnQob2xkRGF0ZSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoZXZlbnRUeXBlICE9PSAnY2hhbmdlJylcbiAgICAgICAgICAgICAgICBwaWNrZXIuZWxlbWVudC5jaGFuZ2UoKTtcbiAgICAgICAgfSxcblxuXHRcdG5vdGlmeUVycm9yID0gZnVuY3Rpb24gKGRhdGUpIHtcblx0XHQgICAgcGlja2VyLmVsZW1lbnQudHJpZ2dlcih7XG5cdFx0ICAgICAgICB0eXBlOiAnZXJyb3IuZHAnLFxuXHRcdCAgICAgICAgZGF0ZTogcE1vbWVudChkYXRlKVxuXHRcdCAgICB9KTtcblx0XHR9LFxuXG4gICAgICAgIHVwZGF0ZSA9IGZ1bmN0aW9uIChuZXdEYXRlKSB7XG4gICAgICAgICAgICBwTW9tZW50LmxhbmcocGlja2VyLm9wdGlvbnMubGFuZ3VhZ2UpO1xuICAgICAgICAgICAgdmFyIGRhdGVTdHIgPSBuZXdEYXRlO1xuICAgICAgICAgICAgaWYgKCFkYXRlU3RyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBpY2tlci5pc0lucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVTdHIgPSBwaWNrZXIuZWxlbWVudC52YWwoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRlU3RyID0gcGlja2VyLmVsZW1lbnQuZmluZCgnaW5wdXQnKS52YWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGVTdHIpIHBpY2tlci5kYXRlID0gcE1vbWVudChkYXRlU3RyLCBwaWNrZXIuZm9ybWF0LCBwaWNrZXIub3B0aW9ucy51c2VTdHJpY3QpO1xuICAgICAgICAgICAgICAgIGlmICghcGlja2VyLmRhdGUpIHBpY2tlci5kYXRlID0gcE1vbWVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGlja2VyLnZpZXdEYXRlID0gcE1vbWVudChwaWNrZXIuZGF0ZSkuc3RhcnRPZihcIm1vbnRoXCIpO1xuICAgICAgICAgICAgZmlsbERhdGUoKTtcbiAgICAgICAgICAgIGZpbGxUaW1lKCk7XG4gICAgICAgIH0sXG5cblx0XHRmaWxsRG93ID0gZnVuY3Rpb24gKCkge1xuXHRcdCAgICBwTW9tZW50LmxhbmcocGlja2VyLm9wdGlvbnMubGFuZ3VhZ2UpO1xuXHRcdCAgICB2YXIgaHRtbCA9ICQoJzx0cj4nKSwgd2Vla2RheXNNaW4gPSBwTW9tZW50LndlZWtkYXlzTWluKCksIGk7XG5cdFx0ICAgIGlmIChwTW9tZW50KCkuX2xhbmcuX3dlZWsuZG93ID09IDApIHsgLy8gc3RhcnRzIG9uIFN1bmRheVxuXHRcdCAgICAgICAgZm9yKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG5cdFx0ICAgICAgICAgICAgaHRtbC5hcHBlbmQoJzx0aCBjbGFzcz1cImRvd1wiPicgKyB3ZWVrZGF5c01pbltpXSArICc8L3RoPicpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9IGVsc2Uge1xuXHRcdCAgICAgICAgZm9yIChpID0gMTsgaSA8IDg7IGkrKykge1xuXHRcdCAgICAgICAgICAgIGlmIChpID09IDcpIHtcblx0XHQgICAgICAgICAgICAgICAgaHRtbC5hcHBlbmQoJzx0aCBjbGFzcz1cImRvd1wiPicgKyB3ZWVrZGF5c01pblswXSArICc8L3RoPicpO1xuXHRcdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgIGh0bWwuYXBwZW5kKCc8dGggY2xhc3M9XCJkb3dcIj4nICsgd2Vla2RheXNNaW5baV0gKyAnPC90aD4nKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgcGlja2VyLndpZGdldC5maW5kKCcuZGF0ZXBpY2tlci1kYXlzIHRoZWFkJykuYXBwZW5kKGh0bWwpO1xuXHRcdH0sXG5cbiAgICAgICAgZmlsbE1vbnRocyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHBNb21lbnQubGFuZyhwaWNrZXIub3B0aW9ucy5sYW5ndWFnZSk7XG4gICAgICAgICAgICB2YXIgaHRtbCA9ICcnLCBpID0gMCwgbW9udGhzU2hvcnQgPSBwTW9tZW50Lm1vbnRoc1Nob3J0KCk7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IDEyKSB7XG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPHNwYW4gY2xhc3M9XCJtb250aFwiPicgKyBtb250aHNTaG9ydFtpKytdICsgJzwvc3Bhbj4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGlja2VyLndpZGdldC5maW5kKCcuZGF0ZXBpY2tlci1tb250aHMgdGQnKS5hcHBlbmQoaHRtbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmlsbERhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBwTW9tZW50LmxhbmcocGlja2VyLm9wdGlvbnMubGFuZ3VhZ2UpO1xuICAgICAgICAgICAgdmFyIHllYXIgPSBwaWNrZXIudmlld0RhdGUueWVhcigpLFxuICAgICAgICAgICAgICAgIG1vbnRoID0gcGlja2VyLnZpZXdEYXRlLm1vbnRoKCksXG4gICAgICAgICAgICAgICAgc3RhcnRZZWFyID0gcGlja2VyLm9wdGlvbnMuc3RhcnREYXRlLnllYXIoKSxcbiAgICAgICAgICAgICAgICBzdGFydE1vbnRoID0gcGlja2VyLm9wdGlvbnMuc3RhcnREYXRlLm1vbnRoKCksXG4gICAgICAgICAgICAgICAgZW5kWWVhciA9IHBpY2tlci5vcHRpb25zLmVuZERhdGUueWVhcigpLFxuICAgICAgICAgICAgICAgIGVuZE1vbnRoID0gcGlja2VyLm9wdGlvbnMuZW5kRGF0ZS5tb250aCgpLFxuICAgICAgICAgICAgICAgIHByZXZNb250aCwgbmV4dE1vbnRoLCBodG1sID0gW10sIHJvdywgY2xzTmFtZSwgaSwgZGF5cywgeWVhckNvbnQsIGN1cnJlbnRZZWFyLCBtb250aHMgPSBwTW9tZW50Lm1vbnRocygpO1xuXG4gICAgICAgICAgICBwaWNrZXIud2lkZ2V0LmZpbmQoJy5kYXRlcGlja2VyLWRheXMnKS5maW5kKCcuZGlzYWJsZWQnKS5yZW1vdmVDbGFzcygnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIHBpY2tlci53aWRnZXQuZmluZCgnLmRhdGVwaWNrZXItbW9udGhzJykuZmluZCgnLmRpc2FibGVkJykucmVtb3ZlQ2xhc3MoJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICBwaWNrZXIud2lkZ2V0LmZpbmQoJy5kYXRlcGlja2VyLXllYXJzJykuZmluZCgnLmRpc2FibGVkJykucmVtb3ZlQ2xhc3MoJ2Rpc2FibGVkJyk7XG5cbiAgICAgICAgICAgIHBpY2tlci53aWRnZXQuZmluZCgnLmRhdGVwaWNrZXItZGF5cyB0aDplcSgxKScpLnRleHQoXG4gICAgICAgICAgICAgICAgbW9udGhzW21vbnRoXSArICcgJyArIHllYXIpO1xuXG4gICAgICAgICAgICBwcmV2TW9udGggPSBwTW9tZW50KHBpY2tlci52aWV3RGF0ZSkuc3VidHJhY3QoXCJtb250aHNcIiwgMSk7XG4gICAgICAgICAgICBkYXlzID0gcHJldk1vbnRoLmRheXNJbk1vbnRoKCk7XG4gICAgICAgICAgICBwcmV2TW9udGguZGF0ZShkYXlzKS5zdGFydE9mKCd3ZWVrJyk7XG4gICAgICAgICAgICBpZiAoKHllYXIgPT0gc3RhcnRZZWFyICYmIG1vbnRoIDw9IHN0YXJ0TW9udGgpIHx8IHllYXIgPCBzdGFydFllYXIpIHtcbiAgICAgICAgICAgICAgICBwaWNrZXIud2lkZ2V0LmZpbmQoJy5kYXRlcGlja2VyLWRheXMgdGg6ZXEoMCknKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoeWVhciA9PSBlbmRZZWFyICYmIG1vbnRoID49IGVuZE1vbnRoKSB8fCB5ZWFyID4gZW5kWWVhcikge1xuICAgICAgICAgICAgICAgIHBpY2tlci53aWRnZXQuZmluZCgnLmRhdGVwaWNrZXItZGF5cyB0aDplcSgyKScpLmFkZENsYXNzKCdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuZXh0TW9udGggPSBwTW9tZW50KHByZXZNb250aCkuYWRkKDQyLCBcImRcIik7XG4gICAgICAgICAgICB3aGlsZSAocHJldk1vbnRoLmlzQmVmb3JlKG5leHRNb250aCkpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJldk1vbnRoLndlZWtkYXkoKSA9PT0gcE1vbWVudCgpLnN0YXJ0T2YoJ3dlZWsnKS53ZWVrZGF5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gJCgnPHRyPicpO1xuICAgICAgICAgICAgICAgICAgICBodG1sLnB1c2gocm93KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xzTmFtZSA9ICcnO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2TW9udGgueWVhcigpIDwgeWVhciB8fCAocHJldk1vbnRoLnllYXIoKSA9PSB5ZWFyICYmIHByZXZNb250aC5tb250aCgpIDwgbW9udGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsc05hbWUgKz0gJyBvbGQnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldk1vbnRoLnllYXIoKSA+IHllYXIgfHwgKHByZXZNb250aC55ZWFyKCkgPT0geWVhciAmJiBwcmV2TW9udGgubW9udGgoKSA+IG1vbnRoKSkge1xuICAgICAgICAgICAgICAgICAgICBjbHNOYW1lICs9ICcgbmV3JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByZXZNb250aC5pc1NhbWUocE1vbWVudCh7IHk6IHBpY2tlci5kYXRlLnllYXIoKSwgTTogcGlja2VyLmRhdGUubW9udGgoKSwgZDogcGlja2VyLmRhdGUuZGF0ZSgpIH0pKSkge1xuICAgICAgICAgICAgICAgICAgICBjbHNOYW1lICs9ICcgYWN0aXZlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzSW5EaXNhYmxlRGF0ZXMocHJldk1vbnRoKSB8fCAhaXNJbkVuYWJsZURhdGVzKHByZXZNb250aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xzTmFtZSArPSAnIGRpc2FibGVkJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcm93LmFwcGVuZCgnPHRkIGNsYXNzPVwiZGF5JyArIGNsc05hbWUgKyAnXCI+JyArIHByZXZNb250aC5kYXRlKCkgKyAnPC90ZD4nKTtcbiAgICAgICAgICAgICAgICBwcmV2TW9udGguYWRkKDEsIFwiZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBpY2tlci53aWRnZXQuZmluZCgnLmRhdGVwaWNrZXItZGF5cyB0Ym9keScpLmVtcHR5KCkuYXBwZW5kKGh0bWwpO1xuICAgICAgICAgICAgY3VycmVudFllYXIgPSBwTW9tZW50KCkueWVhcigpLCBtb250aHMgPSBwaWNrZXIud2lkZ2V0LmZpbmQoJy5kYXRlcGlja2VyLW1vbnRocycpXG5cdFx0XHRcdC5maW5kKCd0aDplcSgxKScpLnRleHQoeWVhcikuZW5kKCkuZmluZCgnc3BhbicpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50WWVhciA9PT0geWVhcikge1xuICAgICAgICAgICAgICAgIG1vbnRocy5lcShwTW9tZW50KCkubW9udGgoKSkuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRZZWFyIC0gMSA8IHN0YXJ0WWVhcikge1xuICAgICAgICAgICAgICAgIHBpY2tlci53aWRnZXQuZmluZCgnLmRhdGVwaWNrZXItbW9udGhzIHRoOmVxKDApJykuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudFllYXIgKyAxID4gZW5kWWVhcikge1xuICAgICAgICAgICAgICAgIHBpY2tlci53aWRnZXQuZmluZCgnLmRhdGVwaWNrZXItbW9udGhzIHRoOmVxKDIpJykuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICgoeWVhciA9PSBzdGFydFllYXIgJiYgc3RhcnRNb250aCA+IGkpIHx8ICh5ZWFyIDwgc3RhcnRZZWFyKSkge1xuICAgICAgICAgICAgICAgICAgICAkKG1vbnRoc1tpXSkuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgoeWVhciA9PSBlbmRZZWFyICYmIGVuZE1vbnRoIDwgaSkgfHwgKHllYXIgPiBlbmRZZWFyKSkge1xuICAgICAgICAgICAgICAgICAgICAkKG1vbnRoc1tpXSkuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBodG1sID0gJyc7XG4gICAgICAgICAgICB5ZWFyID0gcGFyc2VJbnQoeWVhciAvIDEwLCAxMCkgKiAxMDtcbiAgICAgICAgICAgIHllYXJDb250ID0gcGlja2VyLndpZGdldC5maW5kKCcuZGF0ZXBpY2tlci15ZWFycycpLmZpbmQoXG4gICAgICAgICAgICAgICAgJ3RoOmVxKDEpJykudGV4dCh5ZWFyICsgJy0nICsgKHllYXIgKyA5KSkuZW5kKCkuZmluZCgndGQnKTtcbiAgICAgICAgICAgIHBpY2tlci53aWRnZXQuZmluZCgnLmRhdGVwaWNrZXIteWVhcnMnKS5maW5kKCd0aCcpLnJlbW92ZUNsYXNzKCdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0WWVhciA+IHllYXIpIHtcbiAgICAgICAgICAgICAgICBwaWNrZXIud2lkZ2V0LmZpbmQoJy5kYXRlcGlja2VyLXllYXJzJykuZmluZCgndGg6ZXEoMCknKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmRZZWFyIDwgeWVhciArIDkpIHtcbiAgICAgICAgICAgICAgICBwaWNrZXIud2lkZ2V0LmZpbmQoJy5kYXRlcGlja2VyLXllYXJzJykuZmluZCgndGg6ZXEoMiknKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHllYXIgLT0gMTtcbiAgICAgICAgICAgIGZvciAoaSA9IC0xOyBpIDwgMTE7IGkrKykge1xuICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxzcGFuIGNsYXNzPVwieWVhcicgKyAoaSA9PT0gLTEgfHwgaSA9PT0gMTAgPyAnIG9sZCcgOiAnJykgKyAoY3VycmVudFllYXIgPT09IHllYXIgPyAnIGFjdGl2ZScgOiAnJykgKyAoKHllYXIgPCBzdGFydFllYXIgfHwgeWVhciA+IGVuZFllYXIpID8gJyBkaXNhYmxlZCcgOiAnJykgKyAnXCI+JyArIHllYXIgKyAnPC9zcGFuPic7XG4gICAgICAgICAgICAgICAgeWVhciArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWVhckNvbnQuaHRtbChodG1sKTtcbiAgICAgICAgfSxcblxuICAgICAgICBmaWxsSG91cnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBwTW9tZW50LmxhbmcocGlja2VyLm9wdGlvbnMubGFuZ3VhZ2UpO1xuICAgICAgICAgICAgdmFyIHRhYmxlID0gcGlja2VyLndpZGdldC5maW5kKCcudGltZXBpY2tlciAudGltZXBpY2tlci1ob3VycyB0YWJsZScpLCBodG1sID0gJycsIGN1cnJlbnQsIGksIGo7XG4gICAgICAgICAgICB0YWJsZS5wYXJlbnQoKS5oaWRlKCk7XG4gICAgICAgICAgICBpZiAocGlja2VyLm9wdGlvbnMudXNlMjRob3Vycykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA2OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnPHRyPic7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCA0OyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJzx0ZCBjbGFzcz1cImhvdXJcIj4nICsgcGFkTGVmdChjdXJyZW50LnRvU3RyaW5nKCkpICsgJzwvdGQ+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBodG1sICs9ICc8L3RyPic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IDE7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDM7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBodG1sICs9ICc8dHI+JztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IDQ7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnPHRkIGNsYXNzPVwiaG91clwiPicgKyBwYWRMZWZ0KGN1cnJlbnQudG9TdHJpbmcoKSkgKyAnPC90ZD4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJzwvdHI+JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YWJsZS5odG1sKGh0bWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbGxNaW51dGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRhYmxlID0gcGlja2VyLndpZGdldC5maW5kKCcudGltZXBpY2tlciAudGltZXBpY2tlci1taW51dGVzIHRhYmxlJyksIGh0bWwgPSAnJywgY3VycmVudCA9IDAsIGksIGo7XG4gICAgICAgICAgICB0YWJsZS5wYXJlbnQoKS5oaWRlKCk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPHRyPic7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IDQ7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBodG1sICs9ICc8dGQgY2xhc3M9XCJtaW51dGVcIj4nICsgcGFkTGVmdChjdXJyZW50LnRvU3RyaW5nKCkpICsgJzwvdGQ+JztcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCArPSAzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBodG1sICs9ICc8L3RyPic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YWJsZS5odG1sKGh0bWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbGxTZWNvbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRhYmxlID0gcGlja2VyLndpZGdldC5maW5kKCcudGltZXBpY2tlciAudGltZXBpY2tlci1zZWNvbmRzIHRhYmxlJyksIGh0bWwgPSAnJywgY3VycmVudCA9IDAsIGksIGo7XG4gICAgICAgICAgICB0YWJsZS5wYXJlbnQoKS5oaWRlKCk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPHRyPic7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IDQ7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgICAgaHRtbCArPSAnPHRkIGNsYXNzPVwic2Vjb25kXCI+JyArIHBhZExlZnQoY3VycmVudC50b1N0cmluZygpKSArICc8L3RkPic7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50ICs9IDM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGh0bWwgKz0gJzwvdHI+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhYmxlLmh0bWwoaHRtbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmlsbFRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXBpY2tlci5kYXRlKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgdGltZUNvbXBvbmVudHMgPSBwaWNrZXIud2lkZ2V0LmZpbmQoJy50aW1lcGlja2VyIHNwYW5bZGF0YS10aW1lLWNvbXBvbmVudF0nKSxcbiAgICAgICAgICAgIGhvdXIgPSBwaWNrZXIuZGF0ZS5ob3VycygpLFxuICAgICAgICAgICAgcGVyaW9kID0gJ0FNJztcbiAgICAgICAgICAgIGlmICghcGlja2VyLm9wdGlvbnMudXNlMjRob3Vycykge1xuICAgICAgICAgICAgICAgIGlmIChob3VyID49IDEyKSBwZXJpb2QgPSAnUE0nO1xuICAgICAgICAgICAgICAgIGlmIChob3VyID09PSAwKSBob3VyID0gMTI7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaG91ciAhPSAxMikgaG91ciA9IGhvdXIgJSAxMjtcbiAgICAgICAgICAgICAgICBwaWNrZXIud2lkZ2V0LmZpbmQoJy50aW1lcGlja2VyIFtkYXRhLWFjdGlvbj10b2dnbGVQZXJpb2RdJykudGV4dChwZXJpb2QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGltZUNvbXBvbmVudHMuZmlsdGVyKCdbZGF0YS10aW1lLWNvbXBvbmVudD1ob3Vyc10nKS50ZXh0KHBhZExlZnQoaG91cikpO1xuICAgICAgICAgICAgdGltZUNvbXBvbmVudHMuZmlsdGVyKCdbZGF0YS10aW1lLWNvbXBvbmVudD1taW51dGVzXScpLnRleHQocGFkTGVmdChwaWNrZXIuZGF0ZS5taW51dGVzKCkpKTtcbiAgICAgICAgICAgIHRpbWVDb21wb25lbnRzLmZpbHRlcignW2RhdGEtdGltZS1jb21wb25lbnQ9c2Vjb25kc10nKS50ZXh0KHBhZExlZnQocGlja2VyLmRhdGUuc2Vjb25kKCkpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGljayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcGlja2VyLnVuc2V0ID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gJChlLnRhcmdldCkuY2xvc2VzdCgnc3BhbiwgdGQsIHRoJyksIG1vbnRoLCB5ZWFyLCBzdGVwLCBkYXksIG9sZERhdGUgPSBwTW9tZW50KHBpY2tlci5kYXRlKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0YXJnZXQuaXMoJy5kaXNhYmxlZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGFyZ2V0WzBdLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RoJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhcmdldFswXS5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3dpdGNoJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dNb2RlKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3ByZXYnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICduZXh0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXAgPSBkcEdsb2JhbC5tb2Rlc1twaWNrZXIudmlld01vZGVdLm5hdlN0ZXA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0WzBdLmNsYXNzTmFtZSA9PT0gJ3ByZXYnKSBzdGVwID0gc3RlcCAqIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGlja2VyLnZpZXdEYXRlLmFkZChzdGVwLCBkcEdsb2JhbC5tb2Rlc1twaWNrZXIudmlld01vZGVdLm5hdkZuYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3Bhbic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldC5pcygnLm1vbnRoJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9udGggPSB0YXJnZXQucGFyZW50KCkuZmluZCgnc3BhbicpLmluZGV4KHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpY2tlci52aWV3RGF0ZS5tb250aChtb250aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWVhciA9IHBhcnNlSW50KHRhcmdldC50ZXh0KCksIDEwKSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaWNrZXIudmlld0RhdGUueWVhcih5ZWFyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBpY2tlci52aWV3TW9kZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaWNrZXIuZGF0ZSA9IHBNb21lbnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogcGlja2VyLnZpZXdEYXRlLnllYXIoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE06IHBpY2tlci52aWV3RGF0ZS5tb250aCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZDogcGlja2VyLnZpZXdEYXRlLmRhdGUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGg6IHBpY2tlci5kYXRlLmhvdXJzKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtOiBwaWNrZXIuZGF0ZS5taW51dGVzKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmeUNoYW5nZShvbGREYXRlLCBlLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93TW9kZSgtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmlzKCcuZGF5JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF5ID0gcGFyc2VJbnQodGFyZ2V0LnRleHQoKSwgMTApIHx8IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoID0gcGlja2VyLnZpZXdEYXRlLm1vbnRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHllYXIgPSBwaWNrZXIudmlld0RhdGUueWVhcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmlzKCcub2xkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb250aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoID0gMTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWVhciAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb250aCAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldC5pcygnLm5ldycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9udGggPT0gMTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb250aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWVhciArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb250aCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpY2tlci5kYXRlID0gcE1vbWVudCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiB5ZWFyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTTogbW9udGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkOiBkYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoOiBwaWNrZXIuZGF0ZS5ob3VycygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbTogcGlja2VyLmRhdGUubWludXRlcygpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGlja2VyLnZpZXdEYXRlID0gcE1vbWVudCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiB5ZWFyLCBNOiBtb250aCwgZDogTWF0aC5taW4oMjgsIGRheSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxEYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RpZnlDaGFuZ2Uob2xkRGF0ZSwgZS50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cblx0XHRhY3Rpb25zID0ge1xuXHRcdCAgICBpbmNyZW1lbnRIb3VyczogZnVuY3Rpb24gKCkge1xuXHRcdCAgICAgICAgY2hlY2tEYXRlKFwiYWRkXCIsIFwiaG91cnNcIiwgMSk7XG5cdFx0ICAgIH0sXG5cblx0XHQgICAgaW5jcmVtZW50TWludXRlczogZnVuY3Rpb24gKCkge1xuXHRcdCAgICAgICAgY2hlY2tEYXRlKFwiYWRkXCIsIFwibWludXRlc1wiLCBwaWNrZXIub3B0aW9ucy5taW51dGVTdGVwcGluZyk7XG5cdFx0ICAgIH0sXG5cblx0XHQgICAgaW5jcmVtZW50U2Vjb25kczogZnVuY3Rpb24gKCkge1xuXHRcdCAgICAgICAgY2hlY2tEYXRlKFwiYWRkXCIsIFwic2Vjb25kc1wiLCAxKTtcblx0XHQgICAgfSxcblxuXHRcdCAgICBkZWNyZW1lbnRIb3VyczogZnVuY3Rpb24gKCkge1xuXHRcdCAgICAgICAgY2hlY2tEYXRlKFwic3VidHJhY3RcIiwgXCJob3Vyc1wiLCAxKTtcblx0XHQgICAgfSxcblxuXHRcdCAgICBkZWNyZW1lbnRNaW51dGVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICBjaGVja0RhdGUoXCJzdWJ0cmFjdFwiLCBcIm1pbnV0ZXNcIiwgcGlja2VyLm9wdGlvbnMubWludXRlU3RlcHBpbmcpO1xuXHRcdCAgICB9LFxuXG5cdFx0ICAgIGRlY3JlbWVudFNlY29uZHM6IGZ1bmN0aW9uICgpIHtcblx0XHQgICAgICAgIGNoZWNrRGF0ZShcInN1YnRyYWN0XCIsIFwic2Vjb25kc1wiLCAxKTtcblx0XHQgICAgfSxcblxuXHRcdCAgICB0b2dnbGVQZXJpb2Q6IGZ1bmN0aW9uICgpIHtcblx0XHQgICAgICAgIHZhciBob3VyID0gcGlja2VyLmRhdGUuaG91cnMoKTtcblx0XHQgICAgICAgIGlmIChob3VyID49IDEyKSBob3VyIC09IDEyO1xuXHRcdCAgICAgICAgZWxzZSBob3VyICs9IDEyO1xuXHRcdCAgICAgICAgcGlja2VyLmRhdGUuaG91cnMoaG91cik7XG5cdFx0ICAgIH0sXG5cblx0XHQgICAgc2hvd1BpY2tlcjogZnVuY3Rpb24gKCkge1xuXHRcdCAgICAgICAgcGlja2VyLndpZGdldC5maW5kKCcudGltZXBpY2tlciA+IGRpdjpub3QoLnRpbWVwaWNrZXItcGlja2VyKScpLmhpZGUoKTtcblx0XHQgICAgICAgIHBpY2tlci53aWRnZXQuZmluZCgnLnRpbWVwaWNrZXIgLnRpbWVwaWNrZXItcGlja2VyJykuc2hvdygpO1xuXHRcdCAgICB9LFxuXG5cdFx0ICAgIHNob3dIb3VyczogZnVuY3Rpb24gKCkge1xuXHRcdCAgICAgICAgcGlja2VyLndpZGdldC5maW5kKCcudGltZXBpY2tlciAudGltZXBpY2tlci1waWNrZXInKS5oaWRlKCk7XG5cdFx0ICAgICAgICBwaWNrZXIud2lkZ2V0LmZpbmQoJy50aW1lcGlja2VyIC50aW1lcGlja2VyLWhvdXJzJykuc2hvdygpO1xuXHRcdCAgICB9LFxuXG5cdFx0ICAgIHNob3dNaW51dGVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICBwaWNrZXIud2lkZ2V0LmZpbmQoJy50aW1lcGlja2VyIC50aW1lcGlja2VyLXBpY2tlcicpLmhpZGUoKTtcblx0XHQgICAgICAgIHBpY2tlci53aWRnZXQuZmluZCgnLnRpbWVwaWNrZXIgLnRpbWVwaWNrZXItbWludXRlcycpLnNob3coKTtcblx0XHQgICAgfSxcblxuXHRcdCAgICBzaG93U2Vjb25kczogZnVuY3Rpb24gKCkge1xuXHRcdCAgICAgICAgcGlja2VyLndpZGdldC5maW5kKCcudGltZXBpY2tlciAudGltZXBpY2tlci1waWNrZXInKS5oaWRlKCk7XG5cdFx0ICAgICAgICBwaWNrZXIud2lkZ2V0LmZpbmQoJy50aW1lcGlja2VyIC50aW1lcGlja2VyLXNlY29uZHMnKS5zaG93KCk7XG5cdFx0ICAgIH0sXG5cblx0XHQgICAgc2VsZWN0SG91cjogZnVuY3Rpb24gKGUpIHtcblx0XHQgICAgICAgIHBpY2tlci5kYXRlLmhvdXJzKHBhcnNlSW50KCQoZS50YXJnZXQpLnRleHQoKSwgMTApKTtcblx0XHQgICAgICAgIGFjdGlvbnMuc2hvd1BpY2tlci5jYWxsKHBpY2tlcik7XG5cdFx0ICAgIH0sXG5cblx0XHQgICAgc2VsZWN0TWludXRlOiBmdW5jdGlvbiAoZSkge1xuXHRcdCAgICAgICAgcGlja2VyLmRhdGUubWludXRlcyhwYXJzZUludCgkKGUudGFyZ2V0KS50ZXh0KCksIDEwKSk7XG5cdFx0ICAgICAgICBhY3Rpb25zLnNob3dQaWNrZXIuY2FsbChwaWNrZXIpO1xuXHRcdCAgICB9LFxuXG5cdFx0ICAgIHNlbGVjdFNlY29uZDogZnVuY3Rpb24gKGUpIHtcblx0XHQgICAgICAgIHBpY2tlci5kYXRlLnNlY29uZHMocGFyc2VJbnQoJChlLnRhcmdldCkudGV4dCgpLCAxMCkpO1xuXHRcdCAgICAgICAgYWN0aW9ucy5zaG93UGlja2VyLmNhbGwocGlja2VyKTtcblx0XHQgICAgfVxuXHRcdH0sXG5cblx0ICAgIGRvQWN0aW9uID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICB2YXIgb2xkRGF0ZSA9IHBNb21lbnQocGlja2VyLmRhdGUpLCBhY3Rpb24gPSAkKGUuY3VycmVudFRhcmdldCkuZGF0YSgnYWN0aW9uJyksIHJ2ID0gYWN0aW9uc1thY3Rpb25dLmFwcGx5KHBpY2tlciwgYXJndW1lbnRzKTtcblx0ICAgICAgICBzdG9wRXZlbnQoZSk7XG5cdCAgICAgICAgaWYgKCFwaWNrZXIuZGF0ZSkgcGlja2VyLmRhdGUgPSBwTW9tZW50KHsgeTogMTk3MCB9KTtcblx0ICAgICAgICBzZXQoKTtcblx0ICAgICAgICBmaWxsVGltZSgpO1xuXHQgICAgICAgIG5vdGlmeUNoYW5nZShvbGREYXRlLCBlLnR5cGUpO1xuXHQgICAgICAgIHJldHVybiBydjtcblx0ICAgIH0sXG5cbiAgICAgICAgc3RvcEV2ZW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2hhbmdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHBNb21lbnQubGFuZyhwaWNrZXIub3B0aW9ucy5sYW5ndWFnZSk7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSAkKGUudGFyZ2V0KSwgb2xkRGF0ZSA9IHBNb21lbnQocGlja2VyLmRhdGUpLCBuZXdEYXRlID0gcE1vbWVudChpbnB1dC52YWwoKSwgcGlja2VyLmZvcm1hdCwgcGlja2VyLm9wdGlvbnMudXNlU3RyaWN0KTtcbiAgICAgICAgICAgIGlmIChuZXdEYXRlLmlzVmFsaWQoKSAmJiAhaXNJbkRpc2FibGVEYXRlcyhuZXdEYXRlKSAmJiBpc0luRW5hYmxlRGF0ZXMobmV3RGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgICAgICAgICBwaWNrZXIuc2V0VmFsdWUobmV3RGF0ZSk7XG4gICAgICAgICAgICAgICAgbm90aWZ5Q2hhbmdlKG9sZERhdGUsIGUudHlwZSk7XG4gICAgICAgICAgICAgICAgc2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwaWNrZXIudmlld0RhdGUgPSBvbGREYXRlO1xuICAgICAgICAgICAgICAgIGlucHV0LnZhbChwTW9tZW50KG9sZERhdGUpLmZvcm1hdChwaWNrZXIuZm9ybWF0KSk7XG4gICAgICAgICAgICAgICAgLy9waWNrZXIuc2V0VmFsdWUoXCJcIik7IC8vIHVuc2V0IHRoZSBkYXRlIHdoZW4gdGhlIGlucHV0IGlzIGVyYXNlZFxuICAgICAgICAgICAgICAgIG5vdGlmeUNoYW5nZShvbGREYXRlLCBlLnR5cGUpO1xuICAgICAgICAgICAgICAgIG5vdGlmeUVycm9yKG5ld0RhdGUpO1xuICAgICAgICAgICAgICAgIHBpY2tlci51bnNldCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2hvd01vZGUgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgICAgICBpZiAoZGlyKSB7XG4gICAgICAgICAgICAgICAgcGlja2VyLnZpZXdNb2RlID0gTWF0aC5tYXgocGlja2VyLm1pblZpZXdNb2RlLCBNYXRoLm1pbigyLCBwaWNrZXIudmlld01vZGUgKyBkaXIpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGlja2VyLndpZGdldC5maW5kKCcuZGF0ZXBpY2tlciA+IGRpdicpLmhpZGUoKS5maWx0ZXIoJy5kYXRlcGlja2VyLScgKyBkcEdsb2JhbC5tb2Rlc1twaWNrZXIudmlld01vZGVdLmNsc05hbWUpLnNob3coKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhdHRhY2hEYXRlUGlja2VyRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyICR0aGlzLCAkcGFyZW50LCBleHBhbmRlZCwgY2xvc2VkLCBjb2xsYXBzZURhdGE7XG4gICAgICAgICAgICBwaWNrZXIud2lkZ2V0Lm9uKCdjbGljaycsICcuZGF0ZXBpY2tlciAqJywgJC5wcm94eShjbGljaywgdGhpcykpOyAvLyB0aGlzIGhhbmRsZXMgZGF0ZSBwaWNrZXIgY2xpY2tzXG4gICAgICAgICAgICBwaWNrZXIud2lkZ2V0Lm9uKCdjbGljaycsICdbZGF0YS1hY3Rpb25dJywgJC5wcm94eShkb0FjdGlvbiwgdGhpcykpOyAvLyB0aGlzIGhhbmRsZXMgdGltZSBwaWNrZXIgY2xpY2tzXG4gICAgICAgICAgICBwaWNrZXIud2lkZ2V0Lm9uKCdtb3VzZWRvd24nLCAkLnByb3h5KHN0b3BFdmVudCwgdGhpcykpO1xuICAgICAgICAgICAgaWYgKHBpY2tlci5vcHRpb25zLnBpY2tEYXRlICYmIHBpY2tlci5vcHRpb25zLnBpY2tUaW1lKSB7XG4gICAgICAgICAgICAgICAgcGlja2VyLndpZGdldC5vbignY2xpY2sudG9nZ2xlUGlja2VyJywgJy5hY2NvcmRpb24tdG9nZ2xlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMgPSAkKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAkcGFyZW50ID0gJHRoaXMuY2xvc2VzdCgndWwnKTtcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWQgPSAkcGFyZW50LmZpbmQoJy5pbicpO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZWQgPSAkcGFyZW50LmZpbmQoJy5jb2xsYXBzZTpub3QoLmluKScpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBhbmRlZCAmJiBleHBhbmRlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxhcHNlRGF0YSA9IGV4cGFuZGVkLmRhdGEoJ2NvbGxhcHNlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sbGFwc2VEYXRhICYmIGNvbGxhcHNlRGF0YS50cmFuc2l0aW9uaW5nKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBhbmRlZC5jb2xsYXBzZSgnaGlkZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VkLmNvbGxhcHNlKCdzaG93Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5maW5kKCdzcGFuJykudG9nZ2xlQ2xhc3MocGlja2VyLm9wdGlvbnMuaWNvbnMudGltZSArICcgJyArIHBpY2tlci5vcHRpb25zLmljb25zLmRhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGlja2VyLmVsZW1lbnQuZmluZCgnLmlucHV0LWdyb3VwLWFkZG9uIHNwYW4nKS50b2dnbGVDbGFzcyhwaWNrZXIub3B0aW9ucy5pY29ucy50aW1lICsgJyAnICsgcGlja2VyLm9wdGlvbnMuaWNvbnMuZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwaWNrZXIuaXNJbnB1dCkge1xuICAgICAgICAgICAgICAgIHBpY2tlci5lbGVtZW50Lm9uKHtcbiAgICAgICAgICAgICAgICAgICAgJ2ZvY3VzJzogJC5wcm94eShwaWNrZXIuc2hvdywgdGhpcyksXG4gICAgICAgICAgICAgICAgICAgICdjaGFuZ2UnOiAkLnByb3h5KGNoYW5nZSwgdGhpcyksXG4gICAgICAgICAgICAgICAgICAgICdibHVyJzogJC5wcm94eShwaWNrZXIuaGlkZSwgdGhpcylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGlja2VyLmVsZW1lbnQub24oe1xuICAgICAgICAgICAgICAgICAgICAnY2hhbmdlJzogJC5wcm94eShjaGFuZ2UsIHRoaXMpXG4gICAgICAgICAgICAgICAgfSwgJ2lucHV0Jyk7XG4gICAgICAgICAgICAgICAgaWYgKHBpY2tlci5jb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGlja2VyLmNvbXBvbmVudC5vbignY2xpY2snLCAkLnByb3h5KHBpY2tlci5zaG93LCB0aGlzKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGlja2VyLmVsZW1lbnQub24oJ2NsaWNrJywgJC5wcm94eShwaWNrZXIuc2hvdywgdGhpcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhdHRhY2hEYXRlUGlja2VyR2xvYmFsRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJCh3aW5kb3cpLm9uKFxuICAgICAgICAgICAgICAgICdyZXNpemUuZGF0ZXRpbWVwaWNrZXInICsgcGlja2VyLmlkLCAkLnByb3h5KHBsYWNlLCB0aGlzKSk7XG4gICAgICAgICAgICBpZiAoIXBpY2tlci5pc0lucHV0KSB7XG4gICAgICAgICAgICAgICAgJChkb2N1bWVudCkub24oXG4gICAgICAgICAgICAgICAgICAgICdtb3VzZWRvd24uZGF0ZXRpbWVwaWNrZXInICsgcGlja2VyLmlkLCAkLnByb3h5KHBpY2tlci5oaWRlLCB0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGV0YWNoRGF0ZVBpY2tlckV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHBpY2tlci53aWRnZXQub2ZmKCdjbGljaycsICcuZGF0ZXBpY2tlciAqJywgcGlja2VyLmNsaWNrKTtcbiAgICAgICAgICAgIHBpY2tlci53aWRnZXQub2ZmKCdjbGljaycsICdbZGF0YS1hY3Rpb25dJyk7XG4gICAgICAgICAgICBwaWNrZXIud2lkZ2V0Lm9mZignbW91c2Vkb3duJywgcGlja2VyLnN0b3BFdmVudCk7XG4gICAgICAgICAgICBpZiAocGlja2VyLm9wdGlvbnMucGlja0RhdGUgJiYgcGlja2VyLm9wdGlvbnMucGlja1RpbWUpIHtcbiAgICAgICAgICAgICAgICBwaWNrZXIud2lkZ2V0Lm9mZignY2xpY2sudG9nZ2xlUGlja2VyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGlja2VyLmlzSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBwaWNrZXIuZWxlbWVudC5vZmYoe1xuICAgICAgICAgICAgICAgICAgICAnZm9jdXMnOiBwaWNrZXIuc2hvdyxcbiAgICAgICAgICAgICAgICAgICAgJ2NoYW5nZSc6IHBpY2tlci5jaGFuZ2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGlja2VyLmVsZW1lbnQub2ZmKHtcbiAgICAgICAgICAgICAgICAgICAgJ2NoYW5nZSc6IHBpY2tlci5jaGFuZ2VcbiAgICAgICAgICAgICAgICB9LCAnaW5wdXQnKTtcbiAgICAgICAgICAgICAgICBpZiAocGlja2VyLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICBwaWNrZXIuY29tcG9uZW50Lm9mZignY2xpY2snLCBwaWNrZXIuc2hvdyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGlja2VyLmVsZW1lbnQub2ZmKCdjbGljaycsIHBpY2tlci5zaG93KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGV0YWNoRGF0ZVBpY2tlckdsb2JhbEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICQod2luZG93KS5vZmYoJ3Jlc2l6ZS5kYXRldGltZXBpY2tlcicgKyBwaWNrZXIuaWQpO1xuICAgICAgICAgICAgaWYgKCFwaWNrZXIuaXNJbnB1dCkge1xuICAgICAgICAgICAgICAgICQoZG9jdW1lbnQpLm9mZignbW91c2Vkb3duLmRhdGV0aW1lcGlja2VyJyArIHBpY2tlci5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNJbkZpeGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHBpY2tlci5lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudHMgPSBwaWNrZXIuZWxlbWVudC5wYXJlbnRzKCksIGluRml4ZWQgPSBmYWxzZSwgaTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoJChwYXJlbnRzW2ldKS5jc3MoJ3Bvc2l0aW9uJykgPT0gJ2ZpeGVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5GaXhlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluRml4ZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBwTW9tZW50LmxhbmcocGlja2VyLm9wdGlvbnMubGFuZ3VhZ2UpO1xuICAgICAgICAgICAgdmFyIGZvcm1hdHRlZCA9ICcnLCBpbnB1dDtcbiAgICAgICAgICAgIGlmICghcGlja2VyLnVuc2V0KSBmb3JtYXR0ZWQgPSBwTW9tZW50KHBpY2tlci5kYXRlKS5mb3JtYXQocGlja2VyLmZvcm1hdCk7XG4gICAgICAgICAgICBpZiAoIXBpY2tlci5pc0lucHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHBpY2tlci5jb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQgPSBwaWNrZXIuZWxlbWVudC5maW5kKCdpbnB1dCcpO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dC52YWwoZm9ybWF0dGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGlja2VyLmVsZW1lbnQuZGF0YSgnZGF0ZScsIGZvcm1hdHRlZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBpY2tlci5lbGVtZW50LnZhbChmb3JtYXR0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwaWNrZXIub3B0aW9ucy5waWNrVGltZSkgcGlja2VyLmhpZGUoKTtcbiAgICAgICAgfSxcblxuXHRcdGNoZWNrRGF0ZSA9IGZ1bmN0aW9uIChkaXJlY3Rpb24sIHVuaXQsIGFtb3VudCkge1xuXHRcdCAgICBwTW9tZW50LmxhbmcocGlja2VyLm9wdGlvbnMubGFuZ3VhZ2UpO1xuXHRcdCAgICB2YXIgbmV3RGF0ZTtcblx0XHQgICAgaWYgKGRpcmVjdGlvbiA9PSBcImFkZFwiKSB7XG5cdFx0ICAgICAgICBuZXdEYXRlID0gcE1vbWVudChwaWNrZXIuZGF0ZSk7XG5cdFx0ICAgICAgICBpZiAobmV3RGF0ZS5ob3VycygpID09IDIzKSBuZXdEYXRlLmFkZChhbW91bnQsIHVuaXQpO1xuXHRcdCAgICAgICAgbmV3RGF0ZS5hZGQoYW1vdW50LCB1bml0KTtcblx0XHQgICAgfVxuXHRcdCAgICBlbHNlIHtcblx0XHQgICAgICAgIG5ld0RhdGUgPSBwTW9tZW50KHBpY2tlci5kYXRlKS5zdWJ0cmFjdChhbW91bnQsIHVuaXQpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGlmIChpc0luRGlzYWJsZURhdGVzKHBNb21lbnQobmV3RGF0ZS5zdWJ0cmFjdChhbW91bnQsIHVuaXQpKSkgfHwgaXNJbkRpc2FibGVEYXRlcyhuZXdEYXRlKSkge1xuXHRcdCAgICAgICAgbm90aWZ5RXJyb3IobmV3RGF0ZS5mb3JtYXQocGlja2VyLmZvcm1hdCkpO1xuXHRcdCAgICAgICAgcmV0dXJuO1xuXHRcdCAgICB9XG5cblx0XHQgICAgaWYgKGRpcmVjdGlvbiA9PSBcImFkZFwiKSB7XG5cdFx0ICAgICAgICBwaWNrZXIuZGF0ZS5hZGQoYW1vdW50LCB1bml0KTtcblx0XHQgICAgfVxuXHRcdCAgICBlbHNlIHtcblx0XHQgICAgICAgIHBpY2tlci5kYXRlLnN1YnRyYWN0KGFtb3VudCwgdW5pdCk7XG5cdFx0ICAgIH1cbiAgICAgICAgICAgIHBpY2tlci51bnNldCA9IGZhbHNlO1xuXHRcdH0sXG5cblx0XHRpc0luRGlzYWJsZURhdGVzID0gZnVuY3Rpb24gKGRhdGUpIHtcblx0XHQgICAgcE1vbWVudC5sYW5nKHBpY2tlci5vcHRpb25zLmxhbmd1YWdlKTtcbiAgICAgICAgICAgIGlmIChkYXRlLmlzQWZ0ZXIocGlja2VyLm9wdGlvbnMuZW5kRGF0ZSkgfHwgZGF0ZS5pc0JlZm9yZShwaWNrZXIub3B0aW9ucy5zdGFydERhdGUpKSByZXR1cm4gdHJ1ZTtcblx0XHQgICAgdmFyIGRpc2FibGVkID0gcGlja2VyLm9wdGlvbnMuZGlzYWJsZWREYXRlcywgaTtcblx0XHQgICAgZm9yIChpIGluIGRpc2FibGVkKSB7XG5cdFx0ICAgICAgICBpZiAoZGlzYWJsZWRbaV0gPT0gcE1vbWVudChkYXRlKS5mb3JtYXQoXCJMXCIpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgcmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cbiAgICAgICAgaXNJbkVuYWJsZURhdGVzID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgICAgIHBNb21lbnQubGFuZyhwaWNrZXIub3B0aW9ucy5sYW5ndWFnZSk7XG4gICAgICAgICAgICB2YXIgZW5hYmxlZCA9IHBpY2tlci5vcHRpb25zLmVuYWJsZWREYXRlcywgaTtcbiAgICAgICAgICAgIGlmIChlbmFibGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAoaSBpbiBlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmFibGVkW2ldID09IHBNb21lbnQoZGF0ZSkuZm9ybWF0KFwiTFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVuYWJsZWQgPT09IGZhbHNlID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBwYWRMZWZ0ID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAoc3RyaW5nLmxlbmd0aCA+PSAyKSByZXR1cm4gc3RyaW5nO1xuICAgICAgICAgICAgZWxzZSByZXR1cm4gJzAnICsgc3RyaW5nO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFRlbXBsYXRlID0gZnVuY3Rpb24gKHBpY2tEYXRlLCBwaWNrVGltZSwgY29sbGFwc2UpIHtcbiAgICAgICAgICAgIGlmIChwaWNrRGF0ZSAmJiBwaWNrVGltZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCBkcm9wZG93bi1tZW51XCIgc3R5bGU9XCJ6LWluZGV4Ojk5OTkgIWltcG9ydGFudDtcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8dWwgY2xhc3M9XCJsaXN0LXVuc3R5bGVkXCI+JyArXG5cdFx0XHRcdFx0XHRcdCc8bGknICsgKGNvbGxhcHNlID8gJyBjbGFzcz1cImNvbGxhcHNlIGluXCInIDogJycpICsgJz4nICtcblx0XHRcdFx0XHRcdFx0XHQnPGRpdiBjbGFzcz1cImRhdGVwaWNrZXJcIj4nICsgZHBHbG9iYWwudGVtcGxhdGUgKyAnPC9kaXY+JyArXG5cdFx0XHRcdFx0XHRcdCc8L2xpPicgK1xuXHRcdFx0XHRcdFx0XHQnPGxpIGNsYXNzPVwicGlja2VyLXN3aXRjaCBhY2NvcmRpb24tdG9nZ2xlXCI+PGEgY2xhc3M9XCJidG5cIiBzdHlsZT1cIndpZHRoOjEwMCVcIj48c3BhbiBjbGFzcz1cIicgKyBwaWNrZXIub3B0aW9ucy5pY29ucy50aW1lICsgJ1wiPjwvc3Bhbj48L2E+PC9saT4nICtcblx0XHRcdFx0XHRcdFx0JzxsaScgKyAoY29sbGFwc2UgPyAnIGNsYXNzPVwiY29sbGFwc2VcIicgOiAnJykgKyAnPicgK1xuXHRcdFx0XHRcdFx0XHRcdCc8ZGl2IGNsYXNzPVwidGltZXBpY2tlclwiPicgKyB0cEdsb2JhbC5nZXRUZW1wbGF0ZSgpICsgJzwvZGl2PicgK1xuXHRcdFx0XHRcdFx0XHQnPC9saT4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8L3VsPicgK1xuICAgICAgICAgICAgICAgICAgICAnPC9kaXY+J1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBpY2tUaW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0IGRyb3Bkb3duLW1lbnVcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwidGltZXBpY2tlclwiPicgKyB0cEdsb2JhbC5nZXRUZW1wbGF0ZSgpICsgJzwvZGl2PicgK1xuICAgICAgICAgICAgICAgICAgICAnPC9kaXY+J1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCBkcm9wZG93bi1tZW51XCI+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImRhdGVwaWNrZXJcIj4nICsgZHBHbG9iYWwudGVtcGxhdGUgKyAnPC9kaXY+JyArXG4gICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuXHRcdGRwR2xvYmFsID0ge1xuXHRcdCAgICBtb2RlczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY2xzTmFtZTogJ2RheXMnLFxuICAgICAgICAgICAgICAgICAgICBuYXZGbmM6ICdtb250aCcsXG4gICAgICAgICAgICAgICAgICAgIG5hdlN0ZXA6IDFcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY2xzTmFtZTogJ21vbnRocycsXG4gICAgICAgICAgICAgICAgICAgIG5hdkZuYzogJ3llYXInLFxuICAgICAgICAgICAgICAgICAgICBuYXZTdGVwOiAxXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNsc05hbWU6ICd5ZWFycycsXG4gICAgICAgICAgICAgICAgICAgIG5hdkZuYzogJ3llYXInLFxuICAgICAgICAgICAgICAgICAgICBuYXZTdGVwOiAxMFxuICAgICAgICAgICAgICAgIH1dLFxuXHRcdCAgICBoZWFkVGVtcGxhdGU6XG4gICAgICAgICAgICAgICAgICAgICc8dGhlYWQ+JyArXG5cdFx0XHRcdFx0XHQnPHRyPicgK1xuXHRcdFx0XHRcdFx0XHQnPHRoIGNsYXNzPVwicHJldlwiPiZsc2FxdW87PC90aD48dGggY29sc3Bhbj1cIjVcIiBjbGFzcz1cInN3aXRjaFwiPjwvdGg+PHRoIGNsYXNzPVwibmV4dFwiPiZyc2FxdW87PC90aD4nICtcblx0XHRcdFx0XHRcdCc8L3RyPicgK1xuICAgICAgICAgICAgICAgICAgICAnPC90aGVhZD4nLFxuXHRcdCAgICBjb250VGVtcGxhdGU6XG4gICAgICAgICc8dGJvZHk+PHRyPjx0ZCBjb2xzcGFuPVwiN1wiPjwvdGQ+PC90cj48L3Rib2R5Pidcblx0XHR9LFxuXG4gICAgICAgIHRwR2xvYmFsID0ge1xuICAgICAgICAgICAgaG91clRlbXBsYXRlOiAgICc8c3BhbiBkYXRhLWFjdGlvbj1cInNob3dIb3Vyc1wiICAgZGF0YS10aW1lLWNvbXBvbmVudD1cImhvdXJzXCIgICBjbGFzcz1cInRpbWVwaWNrZXItaG91clwiPjwvc3Bhbj4nLFxuICAgICAgICAgICAgbWludXRlVGVtcGxhdGU6ICc8c3BhbiBkYXRhLWFjdGlvbj1cInNob3dNaW51dGVzXCIgZGF0YS10aW1lLWNvbXBvbmVudD1cIm1pbnV0ZXNcIiBjbGFzcz1cInRpbWVwaWNrZXItbWludXRlXCI+PC9zcGFuPicsXG5cdFx0XHRzZWNvbmRUZW1wbGF0ZTogJzxzcGFuIGRhdGEtYWN0aW9uPVwic2hvd1NlY29uZHNcIiAgZGF0YS10aW1lLWNvbXBvbmVudD1cInNlY29uZHNcIiBjbGFzcz1cInRpbWVwaWNrZXItc2Vjb25kXCI+PC9zcGFuPidcbiAgICAgICAgfTtcblxuICAgICAgICBkcEdsb2JhbC50ZW1wbGF0ZSA9XG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItZGF5c1wiPicgK1xuICAgICAgICAgICAgICAgICc8dGFibGUgY2xhc3M9XCJ0YWJsZS1jb25kZW5zZWRcIj4nICsgZHBHbG9iYWwuaGVhZFRlbXBsYXRlICsgJzx0Ym9keT48L3Rib2R5PjwvdGFibGU+JyArXG4gICAgICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItbW9udGhzXCI+JyArXG4gICAgICAgICAgICAgICAgJzx0YWJsZSBjbGFzcz1cInRhYmxlLWNvbmRlbnNlZFwiPicgKyBkcEdsb2JhbC5oZWFkVGVtcGxhdGUgKyBkcEdsb2JhbC5jb250VGVtcGxhdGUgKyAnPC90YWJsZT4nICtcbiAgICAgICAgICAgICc8L2Rpdj4nICtcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci15ZWFyc1wiPicgK1xuXHRcdFx0XHQnPHRhYmxlIGNsYXNzPVwidGFibGUtY29uZGVuc2VkXCI+JyArIGRwR2xvYmFsLmhlYWRUZW1wbGF0ZSArIGRwR2xvYmFsLmNvbnRUZW1wbGF0ZSArICc8L3RhYmxlPicgK1xuICAgICAgICAgICAgJzwvZGl2Pic7XG5cbiAgICAgICAgdHBHbG9iYWwuZ2V0VGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwidGltZXBpY2tlci1waWNrZXJcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgJzx0YWJsZSBjbGFzcz1cInRhYmxlLWNvbmRlbnNlZFwiPicgK1xuXHRcdFx0XHRcdFx0Jzx0cj4nICtcblx0XHRcdFx0XHRcdFx0Jzx0ZD48YSBocmVmPVwiI1wiIGNsYXNzPVwiYnRuXCIgZGF0YS1hY3Rpb249XCJpbmNyZW1lbnRIb3Vyc1wiPjxzcGFuIGNsYXNzPVwiJyArIHBpY2tlci5vcHRpb25zLmljb25zLnVwICsgJ1wiPjwvc3Bhbj48L2E+PC90ZD4nICtcblx0XHRcdFx0XHRcdFx0Jzx0ZCBjbGFzcz1cInNlcGFyYXRvclwiPjwvdGQ+JyArXG5cdFx0XHRcdFx0XHRcdCc8dGQ+JyArIChwaWNrZXIub3B0aW9ucy51c2VNaW51dGVzID8gJzxhIGhyZWY9XCIjXCIgY2xhc3M9XCJidG5cIiBkYXRhLWFjdGlvbj1cImluY3JlbWVudE1pbnV0ZXNcIj48c3BhbiBjbGFzcz1cIicgKyBwaWNrZXIub3B0aW9ucy5pY29ucy51cCArICdcIj48L3NwYW4+PC9hPicgOiAnJykgKyAnPC90ZD4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocGlja2VyLm9wdGlvbnMudXNlU2Vjb25kcyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8dGQgY2xhc3M9XCJzZXBhcmF0b3JcIj48L3RkPjx0ZD48YSBocmVmPVwiI1wiIGNsYXNzPVwiYnRuXCIgZGF0YS1hY3Rpb249XCJpbmNyZW1lbnRTZWNvbmRzXCI+PHNwYW4gY2xhc3M9XCInICsgcGlja2VyLm9wdGlvbnMuaWNvbnMudXAgKyAnXCI+PC9zcGFuPjwvYT48L3RkPicgOiAnJykgK1xuXHRcdFx0XHRcdFx0XHQocGlja2VyLm9wdGlvbnMudXNlMjRob3VycyA/ICcnIDogJzx0ZCBjbGFzcz1cInNlcGFyYXRvclwiPjwvdGQ+JykgK1xuXHRcdFx0XHRcdFx0JzwvdHI+JyArXG5cdFx0XHRcdFx0XHQnPHRyPicgK1xuXHRcdFx0XHRcdFx0XHQnPHRkPicgKyB0cEdsb2JhbC5ob3VyVGVtcGxhdGUgKyAnPC90ZD4gJyArXG5cdFx0XHRcdFx0XHRcdCc8dGQgY2xhc3M9XCJzZXBhcmF0b3JcIj46PC90ZD4nICtcblx0XHRcdFx0XHRcdFx0Jzx0ZD4nICsgKHBpY2tlci5vcHRpb25zLnVzZU1pbnV0ZXMgPyB0cEdsb2JhbC5taW51dGVUZW1wbGF0ZSA6ICc8c3BhbiBjbGFzcz1cInRpbWVwaWNrZXItbWludXRlXCI+MDA8L3NwYW4+JykgKyAnPC90ZD4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHBpY2tlci5vcHRpb25zLnVzZVNlY29uZHMgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHRkIGNsYXNzPVwic2VwYXJhdG9yXCI+OjwvdGQ+PHRkPicgKyB0cEdsb2JhbC5zZWNvbmRUZW1wbGF0ZSArICc8L3RkPicgOiAnJykgK1xuXHRcdFx0XHRcdFx0XHQocGlja2VyLm9wdGlvbnMudXNlMjRob3VycyA/ICcnIDogJzx0ZCBjbGFzcz1cInNlcGFyYXRvclwiPjwvdGQ+JyArXG5cdFx0XHRcdFx0XHRcdCc8dGQ+PGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLXByaW1hcnlcIiBkYXRhLWFjdGlvbj1cInRvZ2dsZVBlcmlvZFwiPjwvYnV0dG9uPjwvdGQ+JykgK1xuXHRcdFx0XHRcdFx0JzwvdHI+JyArXG5cdFx0XHRcdFx0XHQnPHRyPicgK1xuXHRcdFx0XHRcdFx0XHQnPHRkPjxhIGhyZWY9XCIjXCIgY2xhc3M9XCJidG5cIiBkYXRhLWFjdGlvbj1cImRlY3JlbWVudEhvdXJzXCI+PHNwYW4gY2xhc3M9XCInICsgcGlja2VyLm9wdGlvbnMuaWNvbnMuZG93biArICdcIj48L3NwYW4+PC9hPjwvdGQ+JyArXG5cdFx0XHRcdFx0XHRcdCc8dGQgY2xhc3M9XCJzZXBhcmF0b3JcIj48L3RkPicgK1xuXHRcdFx0XHRcdFx0XHQnPHRkPicgKyAocGlja2VyLm9wdGlvbnMudXNlTWludXRlcyA/ICc8YSBocmVmPVwiI1wiIGNsYXNzPVwiYnRuXCIgZGF0YS1hY3Rpb249XCJkZWNyZW1lbnRNaW51dGVzXCI+PHNwYW4gY2xhc3M9XCInICsgcGlja2VyLm9wdGlvbnMuaWNvbnMuZG93biArICdcIj48L3NwYW4+PC9hPicgOiAnJykgKyAnPC90ZD4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocGlja2VyLm9wdGlvbnMudXNlU2Vjb25kcyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8dGQgY2xhc3M9XCJzZXBhcmF0b3JcIj48L3RkPjx0ZD48YSBocmVmPVwiI1wiIGNsYXNzPVwiYnRuXCIgZGF0YS1hY3Rpb249XCJkZWNyZW1lbnRTZWNvbmRzXCI+PHNwYW4gY2xhc3M9XCInICsgcGlja2VyLm9wdGlvbnMuaWNvbnMuZG93biArICdcIj48L3NwYW4+PC9hPjwvdGQ+JyA6ICcnKSArXG5cdFx0XHRcdFx0XHRcdChwaWNrZXIub3B0aW9ucy51c2UyNGhvdXJzID8gJycgOiAnPHRkIGNsYXNzPVwic2VwYXJhdG9yXCI+PC90ZD4nKSArXG5cdFx0XHRcdFx0XHQnPC90cj4nICtcbiAgICAgICAgICAgICAgICAgICAgJzwvdGFibGU+JyArXG4gICAgICAgICAgICAgICAgJzwvZGl2PicgK1xuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwidGltZXBpY2tlci1ob3Vyc1wiIGRhdGEtYWN0aW9uPVwic2VsZWN0SG91clwiPicgK1xuICAgICAgICAgICAgICAgICAgICAnPHRhYmxlIGNsYXNzPVwidGFibGUtY29uZGVuc2VkXCI+PC90YWJsZT4nICtcbiAgICAgICAgICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJ0aW1lcGlja2VyLW1pbnV0ZXNcIiBkYXRhLWFjdGlvbj1cInNlbGVjdE1pbnV0ZVwiPicgK1xuICAgICAgICAgICAgICAgICAgICAnPHRhYmxlIGNsYXNzPVwidGFibGUtY29uZGVuc2VkXCI+PC90YWJsZT4nICtcbiAgICAgICAgICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICAgICAgICAgKHBpY2tlci5vcHRpb25zLnVzZVNlY29uZHMgP1xuICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cInRpbWVwaWNrZXItc2Vjb25kc1wiIGRhdGEtYWN0aW9uPVwic2VsZWN0U2Vjb25kXCI+PHRhYmxlIGNsYXNzPVwidGFibGUtY29uZGVuc2VkXCI+PC90YWJsZT48L2Rpdj4nIDogJycpXG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIHBpY2tlci5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGV0YWNoRGF0ZVBpY2tlckV2ZW50cygpO1xuICAgICAgICAgICAgZGV0YWNoRGF0ZVBpY2tlckdsb2JhbEV2ZW50cygpO1xuICAgICAgICAgICAgcGlja2VyLndpZGdldC5yZW1vdmUoKTtcbiAgICAgICAgICAgIHBpY2tlci5lbGVtZW50LnJlbW92ZURhdGEoJ0RhdGVUaW1lUGlja2VyJyk7XG4gICAgICAgICAgICBpZiAocGlja2VyLmNvbXBvbmVudClcbiAgICAgICAgICAgICAgICBwaWNrZXIuY29tcG9uZW50LnJlbW92ZURhdGEoJ0RhdGVUaW1lUGlja2VyJyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcGlja2VyLnNob3cgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcGlja2VyLndpZGdldC5zaG93KCk7XG4gICAgICAgICAgICBwaWNrZXIuaGVpZ2h0ID0gcGlja2VyLmNvbXBvbmVudCA/IHBpY2tlci5jb21wb25lbnQub3V0ZXJIZWlnaHQoKSA6IHBpY2tlci5lbGVtZW50Lm91dGVySGVpZ2h0KCk7XG4gICAgICAgICAgICBwbGFjZSgpO1xuICAgICAgICAgICAgcGlja2VyLmVsZW1lbnQudHJpZ2dlcih7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3Nob3cuZHAnLFxuICAgICAgICAgICAgICAgIGRhdGU6IHBNb21lbnQocGlja2VyLmRhdGUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF0dGFjaERhdGVQaWNrZXJHbG9iYWxFdmVudHMoKTtcbiAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgc3RvcEV2ZW50KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHBpY2tlci5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gcGlja2VyLmVsZW1lbnQuZmluZCgnaW5wdXQnKTtcbiAgICAgICAgICAgIGlmKGlucHV0LnByb3AoJ2Rpc2FibGVkJykpIHJldHVybjtcblxuICAgICAgICAgICAgaW5wdXQucHJvcCgnZGlzYWJsZWQnLCB0cnVlKTtcbiAgICAgICAgICAgIGRldGFjaERhdGVQaWNrZXJFdmVudHMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBwaWNrZXIuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gcGlja2VyLmVsZW1lbnQuZmluZCgnaW5wdXQnKTtcbiAgICAgICAgICAgIGlmKCFpbnB1dC5wcm9wKCdkaXNhYmxlZCcpKSByZXR1cm47XG5cbiAgICAgICAgICAgIGlucHV0LnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpO1xuICAgICAgICAgICAgYXR0YWNoRGF0ZVBpY2tlckV2ZW50cygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBpY2tlci5oaWRlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQgJiYgJChldmVudC50YXJnZXQpLmlzKHBpY2tlci5lbGVtZW50LmF0dHIoXCJpZFwiKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gSWdub3JlIGV2ZW50IGlmIGluIHRoZSBtaWRkbGUgb2YgYSBwaWNrZXIgdHJhbnNpdGlvblxuICAgICAgICAgICAgdmFyIGNvbGxhcHNlID0gcGlja2VyLndpZGdldC5maW5kKCcuY29sbGFwc2UnKSwgaSwgY29sbGFwc2VEYXRhO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbGxhcHNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29sbGFwc2VEYXRhID0gY29sbGFwc2UuZXEoaSkuZGF0YSgnY29sbGFwc2UnKTtcbiAgICAgICAgICAgICAgICBpZiAoY29sbGFwc2VEYXRhICYmIGNvbGxhcHNlRGF0YS50cmFuc2l0aW9uaW5nKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwaWNrZXIud2lkZ2V0LmhpZGUoKTtcbiAgICAgICAgICAgIHBpY2tlci52aWV3TW9kZSA9IHBpY2tlci5zdGFydFZpZXdNb2RlO1xuICAgICAgICAgICAgc2hvd01vZGUoKTtcbiAgICAgICAgICAgIHBpY2tlci5lbGVtZW50LnRyaWdnZXIoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdoaWRlLmRwJyxcbiAgICAgICAgICAgICAgICBkYXRlOiBwTW9tZW50KHBpY2tlci5kYXRlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZXRhY2hEYXRlUGlja2VyR2xvYmFsRXZlbnRzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGlja2VyLnNldFZhbHVlID0gZnVuY3Rpb24gKG5ld0RhdGUpIHtcbiAgICAgICAgICAgIHBNb21lbnQubGFuZyhwaWNrZXIub3B0aW9ucy5sYW5ndWFnZSk7XG4gICAgICAgICAgICBpZiAoIW5ld0RhdGUpIHtcbiAgICAgICAgICAgICAgICBwaWNrZXIudW5zZXQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwaWNrZXIudW5zZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcE1vbWVudC5pc01vbWVudChuZXdEYXRlKSkgbmV3RGF0ZSA9IHBNb21lbnQobmV3RGF0ZSk7XG4gICAgICAgICAgICBpZiAobmV3RGF0ZS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICBwaWNrZXIuZGF0ZSA9IG5ld0RhdGU7XG4gICAgICAgICAgICAgICAgc2V0KCk7XG4gICAgICAgICAgICAgICAgcGlja2VyLnZpZXdEYXRlID0gcE1vbWVudCh7IHk6IHBpY2tlci5kYXRlLnllYXIoKSwgTTogcGlja2VyLmRhdGUubW9udGgoKSB9KTtcbiAgICAgICAgICAgICAgICBmaWxsRGF0ZSgpO1xuICAgICAgICAgICAgICAgIGZpbGxUaW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub3RpZnlFcnJvcihuZXdEYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwaWNrZXIuZ2V0RGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChwaWNrZXIudW5zZXQpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHBpY2tlci5kYXRlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBpY2tlci5zZXREYXRlID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgICAgIGRhdGUgPSBwTW9tZW50KGRhdGUpO1xuICAgICAgICAgICAgaWYgKCFkYXRlKSBwaWNrZXIuc2V0VmFsdWUobnVsbCk7XG4gICAgICAgICAgICBlbHNlIHBpY2tlci5zZXRWYWx1ZShkYXRlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBwaWNrZXIuc2V0RW5hYmxlZERhdGVzID0gZnVuY3Rpb24gKGRhdGVzKSB7XG4gICAgICAgICAgICBpZiAoIWRhdGVzKSBwaWNrZXIub3B0aW9ucy5lbmFibGVkRGF0ZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIGVsc2UgcGlja2VyLm9wdGlvbnMuZW5hYmxlZERhdGVzID0gZGF0ZXM7XG4gICAgICAgICAgICBpZiAocGlja2VyLnZpZXdEYXRlKSB1cGRhdGUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBwaWNrZXIuc2V0RW5kRGF0ZSA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgICAgICBpZiAoZGF0ZSA9PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgICAgICAgIHBpY2tlci5vcHRpb25zLmVuZERhdGUgPSBwTW9tZW50KGRhdGUpO1xuICAgICAgICAgICAgaWYgKHBpY2tlci52aWV3RGF0ZSkgdXBkYXRlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGlja2VyLnNldFN0YXJ0RGF0ZSA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgICAgICBpZiAoZGF0ZSA9PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgICAgICAgIHBpY2tlci5vcHRpb25zLnN0YXJ0RGF0ZSA9IHBNb21lbnQoZGF0ZSk7XG4gICAgICAgICAgICBpZiAocGlja2VyLnZpZXdEYXRlKSB1cGRhdGUoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpbml0KCk7XG4gICAgfTtcblxuICAgICQuZm4uZGF0ZXRpbWVwaWNrZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksIGRhdGEgPSAkdGhpcy5kYXRhKCdEYXRlVGltZVBpY2tlcicpO1xuICAgICAgICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdEYXRlVGltZVBpY2tlcicsIG5ldyBEYXRlVGltZVBpY2tlcih0aGlzLCBvcHRpb25zKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG59KSk7IiwiLy8gVGhpcyBmaWxlIGlzIGF1dG9nZW5lcmF0ZWQgdmlhIHRoZSBgY29tbW9uanNgIEdydW50IHRhc2suIFlvdSBjYW4gcmVxdWlyZSgpIHRoaXMgZmlsZSBpbiBhIENvbW1vbkpTIGVudmlyb25tZW50LlxucmVxdWlyZSgnLi4vLi4vanMvdHJhbnNpdGlvbi5qcycpXG5yZXF1aXJlKCcuLi8uLi9qcy9hbGVydC5qcycpXG5yZXF1aXJlKCcuLi8uLi9qcy9idXR0b24uanMnKVxucmVxdWlyZSgnLi4vLi4vanMvY2Fyb3VzZWwuanMnKVxucmVxdWlyZSgnLi4vLi4vanMvY29sbGFwc2UuanMnKVxucmVxdWlyZSgnLi4vLi4vanMvZHJvcGRvd24uanMnKVxucmVxdWlyZSgnLi4vLi4vanMvbW9kYWwuanMnKVxucmVxdWlyZSgnLi4vLi4vanMvdG9vbHRpcC5qcycpXG5yZXF1aXJlKCcuLi8uLi9qcy9wb3BvdmVyLmpzJylcbnJlcXVpcmUoJy4uLy4uL2pzL3Njcm9sbHNweS5qcycpXG5yZXF1aXJlKCcuLi8uLi9qcy90YWIuanMnKVxucmVxdWlyZSgnLi4vLi4vanMvYWZmaXguanMnKSIsIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBhZmZpeC5qcyB2My4zLjRcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI2FmZml4XG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTUgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gQUZGSVggQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIEFmZml4ID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgQWZmaXguREVGQVVMVFMsIG9wdGlvbnMpXG5cbiAgICB0aGlzLiR0YXJnZXQgPSAkKHRoaXMub3B0aW9ucy50YXJnZXQpXG4gICAgICAub24oJ3Njcm9sbC5icy5hZmZpeC5kYXRhLWFwaScsICQucHJveHkodGhpcy5jaGVja1Bvc2l0aW9uLCB0aGlzKSlcbiAgICAgIC5vbignY2xpY2suYnMuYWZmaXguZGF0YS1hcGknLCAgJC5wcm94eSh0aGlzLmNoZWNrUG9zaXRpb25XaXRoRXZlbnRMb29wLCB0aGlzKSlcblxuICAgIHRoaXMuJGVsZW1lbnQgICAgID0gJChlbGVtZW50KVxuICAgIHRoaXMuYWZmaXhlZCAgICAgID0gbnVsbFxuICAgIHRoaXMudW5waW4gICAgICAgID0gbnVsbFxuICAgIHRoaXMucGlubmVkT2Zmc2V0ID0gbnVsbFxuXG4gICAgdGhpcy5jaGVja1Bvc2l0aW9uKClcbiAgfVxuXG4gIEFmZml4LlZFUlNJT04gID0gJzMuMy40J1xuXG4gIEFmZml4LlJFU0VUICAgID0gJ2FmZml4IGFmZml4LXRvcCBhZmZpeC1ib3R0b20nXG5cbiAgQWZmaXguREVGQVVMVFMgPSB7XG4gICAgb2Zmc2V0OiAwLFxuICAgIHRhcmdldDogd2luZG93XG4gIH1cblxuICBBZmZpeC5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoc2Nyb2xsSGVpZ2h0LCBoZWlnaHQsIG9mZnNldFRvcCwgb2Zmc2V0Qm90dG9tKSB7XG4gICAgdmFyIHNjcm9sbFRvcCAgICA9IHRoaXMuJHRhcmdldC5zY3JvbGxUb3AoKVxuICAgIHZhciBwb3NpdGlvbiAgICAgPSB0aGlzLiRlbGVtZW50Lm9mZnNldCgpXG4gICAgdmFyIHRhcmdldEhlaWdodCA9IHRoaXMuJHRhcmdldC5oZWlnaHQoKVxuXG4gICAgaWYgKG9mZnNldFRvcCAhPSBudWxsICYmIHRoaXMuYWZmaXhlZCA9PSAndG9wJykgcmV0dXJuIHNjcm9sbFRvcCA8IG9mZnNldFRvcCA/ICd0b3AnIDogZmFsc2VcblxuICAgIGlmICh0aGlzLmFmZml4ZWQgPT0gJ2JvdHRvbScpIHtcbiAgICAgIGlmIChvZmZzZXRUb3AgIT0gbnVsbCkgcmV0dXJuIChzY3JvbGxUb3AgKyB0aGlzLnVucGluIDw9IHBvc2l0aW9uLnRvcCkgPyBmYWxzZSA6ICdib3R0b20nXG4gICAgICByZXR1cm4gKHNjcm9sbFRvcCArIHRhcmdldEhlaWdodCA8PSBzY3JvbGxIZWlnaHQgLSBvZmZzZXRCb3R0b20pID8gZmFsc2UgOiAnYm90dG9tJ1xuICAgIH1cblxuICAgIHZhciBpbml0aWFsaXppbmcgICA9IHRoaXMuYWZmaXhlZCA9PSBudWxsXG4gICAgdmFyIGNvbGxpZGVyVG9wICAgID0gaW5pdGlhbGl6aW5nID8gc2Nyb2xsVG9wIDogcG9zaXRpb24udG9wXG4gICAgdmFyIGNvbGxpZGVySGVpZ2h0ID0gaW5pdGlhbGl6aW5nID8gdGFyZ2V0SGVpZ2h0IDogaGVpZ2h0XG5cbiAgICBpZiAob2Zmc2V0VG9wICE9IG51bGwgJiYgc2Nyb2xsVG9wIDw9IG9mZnNldFRvcCkgcmV0dXJuICd0b3AnXG4gICAgaWYgKG9mZnNldEJvdHRvbSAhPSBudWxsICYmIChjb2xsaWRlclRvcCArIGNvbGxpZGVySGVpZ2h0ID49IHNjcm9sbEhlaWdodCAtIG9mZnNldEJvdHRvbSkpIHJldHVybiAnYm90dG9tJ1xuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBBZmZpeC5wcm90b3R5cGUuZ2V0UGlubmVkT2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnBpbm5lZE9mZnNldCkgcmV0dXJuIHRoaXMucGlubmVkT2Zmc2V0XG4gICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhBZmZpeC5SRVNFVCkuYWRkQ2xhc3MoJ2FmZml4JylcbiAgICB2YXIgc2Nyb2xsVG9wID0gdGhpcy4kdGFyZ2V0LnNjcm9sbFRvcCgpXG4gICAgdmFyIHBvc2l0aW9uICA9IHRoaXMuJGVsZW1lbnQub2Zmc2V0KClcbiAgICByZXR1cm4gKHRoaXMucGlubmVkT2Zmc2V0ID0gcG9zaXRpb24udG9wIC0gc2Nyb2xsVG9wKVxuICB9XG5cbiAgQWZmaXgucHJvdG90eXBlLmNoZWNrUG9zaXRpb25XaXRoRXZlbnRMb29wID0gZnVuY3Rpb24gKCkge1xuICAgIHNldFRpbWVvdXQoJC5wcm94eSh0aGlzLmNoZWNrUG9zaXRpb24sIHRoaXMpLCAxKVxuICB9XG5cbiAgQWZmaXgucHJvdG90eXBlLmNoZWNrUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLiRlbGVtZW50LmlzKCc6dmlzaWJsZScpKSByZXR1cm5cblxuICAgIHZhciBoZWlnaHQgICAgICAgPSB0aGlzLiRlbGVtZW50LmhlaWdodCgpXG4gICAgdmFyIG9mZnNldCAgICAgICA9IHRoaXMub3B0aW9ucy5vZmZzZXRcbiAgICB2YXIgb2Zmc2V0VG9wICAgID0gb2Zmc2V0LnRvcFxuICAgIHZhciBvZmZzZXRCb3R0b20gPSBvZmZzZXQuYm90dG9tXG4gICAgdmFyIHNjcm9sbEhlaWdodCA9ICQoZG9jdW1lbnQuYm9keSkuaGVpZ2h0KClcblxuICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9ICdvYmplY3QnKSAgICAgICAgIG9mZnNldEJvdHRvbSA9IG9mZnNldFRvcCA9IG9mZnNldFxuICAgIGlmICh0eXBlb2Ygb2Zmc2V0VG9wID09ICdmdW5jdGlvbicpICAgIG9mZnNldFRvcCAgICA9IG9mZnNldC50b3AodGhpcy4kZWxlbWVudClcbiAgICBpZiAodHlwZW9mIG9mZnNldEJvdHRvbSA9PSAnZnVuY3Rpb24nKSBvZmZzZXRCb3R0b20gPSBvZmZzZXQuYm90dG9tKHRoaXMuJGVsZW1lbnQpXG5cbiAgICB2YXIgYWZmaXggPSB0aGlzLmdldFN0YXRlKHNjcm9sbEhlaWdodCwgaGVpZ2h0LCBvZmZzZXRUb3AsIG9mZnNldEJvdHRvbSlcblxuICAgIGlmICh0aGlzLmFmZml4ZWQgIT0gYWZmaXgpIHtcbiAgICAgIGlmICh0aGlzLnVucGluICE9IG51bGwpIHRoaXMuJGVsZW1lbnQuY3NzKCd0b3AnLCAnJylcblxuICAgICAgdmFyIGFmZml4VHlwZSA9ICdhZmZpeCcgKyAoYWZmaXggPyAnLScgKyBhZmZpeCA6ICcnKVxuICAgICAgdmFyIGUgICAgICAgICA9ICQuRXZlbnQoYWZmaXhUeXBlICsgJy5icy5hZmZpeCcpXG5cbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihlKVxuXG4gICAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICAgIHRoaXMuYWZmaXhlZCA9IGFmZml4XG4gICAgICB0aGlzLnVucGluID0gYWZmaXggPT0gJ2JvdHRvbScgPyB0aGlzLmdldFBpbm5lZE9mZnNldCgpIDogbnVsbFxuXG4gICAgICB0aGlzLiRlbGVtZW50XG4gICAgICAgIC5yZW1vdmVDbGFzcyhBZmZpeC5SRVNFVClcbiAgICAgICAgLmFkZENsYXNzKGFmZml4VHlwZSlcbiAgICAgICAgLnRyaWdnZXIoYWZmaXhUeXBlLnJlcGxhY2UoJ2FmZml4JywgJ2FmZml4ZWQnKSArICcuYnMuYWZmaXgnKVxuICAgIH1cblxuICAgIGlmIChhZmZpeCA9PSAnYm90dG9tJykge1xuICAgICAgdGhpcy4kZWxlbWVudC5vZmZzZXQoe1xuICAgICAgICB0b3A6IHNjcm9sbEhlaWdodCAtIGhlaWdodCAtIG9mZnNldEJvdHRvbVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuXG4gIC8vIEFGRklYIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgICA9ICR0aGlzLmRhdGEoJ2JzLmFmZml4JylcbiAgICAgIHZhciBvcHRpb25zID0gdHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0JyAmJiBvcHRpb25cblxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy5hZmZpeCcsIChkYXRhID0gbmV3IEFmZml4KHRoaXMsIG9wdGlvbnMpKSlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0oKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5hZmZpeFxuXG4gICQuZm4uYWZmaXggICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi5hZmZpeC5Db25zdHJ1Y3RvciA9IEFmZml4XG5cblxuICAvLyBBRkZJWCBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PVxuXG4gICQuZm4uYWZmaXgubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLmFmZml4ID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gQUZGSVggREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09PT1cblxuICAkKHdpbmRvdykub24oJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgJCgnW2RhdGEtc3B5PVwiYWZmaXhcIl0nKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkc3B5ID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgPSAkc3B5LmRhdGEoKVxuXG4gICAgICBkYXRhLm9mZnNldCA9IGRhdGEub2Zmc2V0IHx8IHt9XG5cbiAgICAgIGlmIChkYXRhLm9mZnNldEJvdHRvbSAhPSBudWxsKSBkYXRhLm9mZnNldC5ib3R0b20gPSBkYXRhLm9mZnNldEJvdHRvbVxuICAgICAgaWYgKGRhdGEub2Zmc2V0VG9wICAgICE9IG51bGwpIGRhdGEub2Zmc2V0LnRvcCAgICA9IGRhdGEub2Zmc2V0VG9wXG5cbiAgICAgIFBsdWdpbi5jYWxsKCRzcHksIGRhdGEpXG4gICAgfSlcbiAgfSlcblxufShqUXVlcnkpO1xuIiwiLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IGFsZXJ0LmpzIHYzLjMuNFxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jYWxlcnRzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTUgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gQUxFUlQgQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIGRpc21pc3MgPSAnW2RhdGEtZGlzbWlzcz1cImFsZXJ0XCJdJ1xuICB2YXIgQWxlcnQgICA9IGZ1bmN0aW9uIChlbCkge1xuICAgICQoZWwpLm9uKCdjbGljaycsIGRpc21pc3MsIHRoaXMuY2xvc2UpXG4gIH1cblxuICBBbGVydC5WRVJTSU9OID0gJzMuMy40J1xuXG4gIEFsZXJ0LlRSQU5TSVRJT05fRFVSQVRJT04gPSAxNTBcblxuICBBbGVydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciAkdGhpcyAgICA9ICQodGhpcylcbiAgICB2YXIgc2VsZWN0b3IgPSAkdGhpcy5hdHRyKCdkYXRhLXRhcmdldCcpXG5cbiAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICBzZWxlY3RvciA9ICR0aGlzLmF0dHIoJ2hyZWYnKVxuICAgICAgc2VsZWN0b3IgPSBzZWxlY3RvciAmJiBzZWxlY3Rvci5yZXBsYWNlKC8uKig/PSNbXlxcc10qJCkvLCAnJykgLy8gc3RyaXAgZm9yIGllN1xuICAgIH1cblxuICAgIHZhciAkcGFyZW50ID0gJChzZWxlY3RvcilcblxuICAgIGlmIChlKSBlLnByZXZlbnREZWZhdWx0KClcblxuICAgIGlmICghJHBhcmVudC5sZW5ndGgpIHtcbiAgICAgICRwYXJlbnQgPSAkdGhpcy5jbG9zZXN0KCcuYWxlcnQnKVxuICAgIH1cblxuICAgICRwYXJlbnQudHJpZ2dlcihlID0gJC5FdmVudCgnY2xvc2UuYnMuYWxlcnQnKSlcblxuICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgICRwYXJlbnQucmVtb3ZlQ2xhc3MoJ2luJylcblxuICAgIGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoKSB7XG4gICAgICAvLyBkZXRhY2ggZnJvbSBwYXJlbnQsIGZpcmUgZXZlbnQgdGhlbiBjbGVhbiB1cCBkYXRhXG4gICAgICAkcGFyZW50LmRldGFjaCgpLnRyaWdnZXIoJ2Nsb3NlZC5icy5hbGVydCcpLnJlbW92ZSgpXG4gICAgfVxuXG4gICAgJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgJHBhcmVudC5oYXNDbGFzcygnZmFkZScpID9cbiAgICAgICRwYXJlbnRcbiAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgcmVtb3ZlRWxlbWVudClcbiAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKEFsZXJ0LlRSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgIHJlbW92ZUVsZW1lbnQoKVxuICB9XG5cblxuICAvLyBBTEVSVCBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICA9ICR0aGlzLmRhdGEoJ2JzLmFsZXJ0JylcblxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy5hbGVydCcsIChkYXRhID0gbmV3IEFsZXJ0KHRoaXMpKSlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0uY2FsbCgkdGhpcylcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4uYWxlcnRcblxuICAkLmZuLmFsZXJ0ICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4uYWxlcnQuQ29uc3RydWN0b3IgPSBBbGVydFxuXG5cbiAgLy8gQUxFUlQgTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT1cblxuICAkLmZuLmFsZXJ0Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi5hbGVydCA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIEFMRVJUIERBVEEtQVBJXG4gIC8vID09PT09PT09PT09PT09XG5cbiAgJChkb2N1bWVudCkub24oJ2NsaWNrLmJzLmFsZXJ0LmRhdGEtYXBpJywgZGlzbWlzcywgQWxlcnQucHJvdG90eXBlLmNsb3NlKVxuXG59KGpRdWVyeSk7XG4iLCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogYnV0dG9uLmpzIHYzLjMuNFxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jYnV0dG9uc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE1IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIEJVVFRPTiBQVUJMSUMgQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgQnV0dG9uID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ICA9ICQoZWxlbWVudClcbiAgICB0aGlzLm9wdGlvbnMgICA9ICQuZXh0ZW5kKHt9LCBCdXR0b24uREVGQVVMVFMsIG9wdGlvbnMpXG4gICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZVxuICB9XG5cbiAgQnV0dG9uLlZFUlNJT04gID0gJzMuMy40J1xuXG4gIEJ1dHRvbi5ERUZBVUxUUyA9IHtcbiAgICBsb2FkaW5nVGV4dDogJ2xvYWRpbmcuLi4nXG4gIH1cblxuICBCdXR0b24ucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgdmFyIGQgICAgPSAnZGlzYWJsZWQnXG4gICAgdmFyICRlbCAgPSB0aGlzLiRlbGVtZW50XG4gICAgdmFyIHZhbCAgPSAkZWwuaXMoJ2lucHV0JykgPyAndmFsJyA6ICdodG1sJ1xuICAgIHZhciBkYXRhID0gJGVsLmRhdGEoKVxuXG4gICAgc3RhdGUgPSBzdGF0ZSArICdUZXh0J1xuXG4gICAgaWYgKGRhdGEucmVzZXRUZXh0ID09IG51bGwpICRlbC5kYXRhKCdyZXNldFRleHQnLCAkZWxbdmFsXSgpKVxuXG4gICAgLy8gcHVzaCB0byBldmVudCBsb29wIHRvIGFsbG93IGZvcm1zIHRvIHN1Ym1pdFxuICAgIHNldFRpbWVvdXQoJC5wcm94eShmdW5jdGlvbiAoKSB7XG4gICAgICAkZWxbdmFsXShkYXRhW3N0YXRlXSA9PSBudWxsID8gdGhpcy5vcHRpb25zW3N0YXRlXSA6IGRhdGFbc3RhdGVdKVxuXG4gICAgICBpZiAoc3RhdGUgPT0gJ2xvYWRpbmdUZXh0Jykge1xuICAgICAgICB0aGlzLmlzTG9hZGluZyA9IHRydWVcbiAgICAgICAgJGVsLmFkZENsYXNzKGQpLmF0dHIoZCwgZClcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0xvYWRpbmcpIHtcbiAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZVxuICAgICAgICAkZWwucmVtb3ZlQ2xhc3MoZCkucmVtb3ZlQXR0cihkKVxuICAgICAgfVxuICAgIH0sIHRoaXMpLCAwKVxuICB9XG5cbiAgQnV0dG9uLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNoYW5nZWQgPSB0cnVlXG4gICAgdmFyICRwYXJlbnQgPSB0aGlzLiRlbGVtZW50LmNsb3Nlc3QoJ1tkYXRhLXRvZ2dsZT1cImJ1dHRvbnNcIl0nKVxuXG4gICAgaWYgKCRwYXJlbnQubGVuZ3RoKSB7XG4gICAgICB2YXIgJGlucHV0ID0gdGhpcy4kZWxlbWVudC5maW5kKCdpbnB1dCcpXG4gICAgICBpZiAoJGlucHV0LnByb3AoJ3R5cGUnKSA9PSAncmFkaW8nKSB7XG4gICAgICAgIGlmICgkaW5wdXQucHJvcCgnY2hlY2tlZCcpICYmIHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2FjdGl2ZScpKSBjaGFuZ2VkID0gZmFsc2VcbiAgICAgICAgZWxzZSAkcGFyZW50LmZpbmQoJy5hY3RpdmUnKS5yZW1vdmVDbGFzcygnYWN0aXZlJylcbiAgICAgIH1cbiAgICAgIGlmIChjaGFuZ2VkKSAkaW5wdXQucHJvcCgnY2hlY2tlZCcsICF0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdhY3RpdmUnKSkudHJpZ2dlcignY2hhbmdlJylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLXByZXNzZWQnLCAhdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnYWN0aXZlJykpXG4gICAgfVxuXG4gICAgaWYgKGNoYW5nZWQpIHRoaXMuJGVsZW1lbnQudG9nZ2xlQ2xhc3MoJ2FjdGl2ZScpXG4gIH1cblxuXG4gIC8vIEJVVFRPTiBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICAgID0gJHRoaXMuZGF0YSgnYnMuYnV0dG9uJylcbiAgICAgIHZhciBvcHRpb25zID0gdHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0JyAmJiBvcHRpb25cblxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy5idXR0b24nLCAoZGF0YSA9IG5ldyBCdXR0b24odGhpcywgb3B0aW9ucykpKVxuXG4gICAgICBpZiAob3B0aW9uID09ICd0b2dnbGUnKSBkYXRhLnRvZ2dsZSgpXG4gICAgICBlbHNlIGlmIChvcHRpb24pIGRhdGEuc2V0U3RhdGUob3B0aW9uKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5idXR0b25cblxuICAkLmZuLmJ1dHRvbiAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLmJ1dHRvbi5Db25zdHJ1Y3RvciA9IEJ1dHRvblxuXG5cbiAgLy8gQlVUVE9OIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09PVxuXG4gICQuZm4uYnV0dG9uLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi5idXR0b24gPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICAvLyBCVVRUT04gREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09PT09XG5cbiAgJChkb2N1bWVudClcbiAgICAub24oJ2NsaWNrLmJzLmJ1dHRvbi5kYXRhLWFwaScsICdbZGF0YS10b2dnbGVePVwiYnV0dG9uXCJdJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciAkYnRuID0gJChlLnRhcmdldClcbiAgICAgIGlmICghJGJ0bi5oYXNDbGFzcygnYnRuJykpICRidG4gPSAkYnRuLmNsb3Nlc3QoJy5idG4nKVxuICAgICAgUGx1Z2luLmNhbGwoJGJ0biwgJ3RvZ2dsZScpXG4gICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICB9KVxuICAgIC5vbignZm9jdXMuYnMuYnV0dG9uLmRhdGEtYXBpIGJsdXIuYnMuYnV0dG9uLmRhdGEtYXBpJywgJ1tkYXRhLXRvZ2dsZV49XCJidXR0b25cIl0nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgJChlLnRhcmdldCkuY2xvc2VzdCgnLmJ0bicpLnRvZ2dsZUNsYXNzKCdmb2N1cycsIC9eZm9jdXMoaW4pPyQvLnRlc3QoZS50eXBlKSlcbiAgICB9KVxuXG59KGpRdWVyeSk7XG4iLCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogY2Fyb3VzZWwuanMgdjMuMy40XG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNjYXJvdXNlbFxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE1IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIENBUk9VU0VMIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBDYXJvdXNlbCA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy4kZWxlbWVudCAgICA9ICQoZWxlbWVudClcbiAgICB0aGlzLiRpbmRpY2F0b3JzID0gdGhpcy4kZWxlbWVudC5maW5kKCcuY2Fyb3VzZWwtaW5kaWNhdG9ycycpXG4gICAgdGhpcy5vcHRpb25zICAgICA9IG9wdGlvbnNcbiAgICB0aGlzLnBhdXNlZCAgICAgID0gbnVsbFxuICAgIHRoaXMuc2xpZGluZyAgICAgPSBudWxsXG4gICAgdGhpcy5pbnRlcnZhbCAgICA9IG51bGxcbiAgICB0aGlzLiRhY3RpdmUgICAgID0gbnVsbFxuICAgIHRoaXMuJGl0ZW1zICAgICAgPSBudWxsXG5cbiAgICB0aGlzLm9wdGlvbnMua2V5Ym9hcmQgJiYgdGhpcy4kZWxlbWVudC5vbigna2V5ZG93bi5icy5jYXJvdXNlbCcsICQucHJveHkodGhpcy5rZXlkb3duLCB0aGlzKSlcblxuICAgIHRoaXMub3B0aW9ucy5wYXVzZSA9PSAnaG92ZXInICYmICEoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSAmJiB0aGlzLiRlbGVtZW50XG4gICAgICAub24oJ21vdXNlZW50ZXIuYnMuY2Fyb3VzZWwnLCAkLnByb3h5KHRoaXMucGF1c2UsIHRoaXMpKVxuICAgICAgLm9uKCdtb3VzZWxlYXZlLmJzLmNhcm91c2VsJywgJC5wcm94eSh0aGlzLmN5Y2xlLCB0aGlzKSlcbiAgfVxuXG4gIENhcm91c2VsLlZFUlNJT04gID0gJzMuMy40J1xuXG4gIENhcm91c2VsLlRSQU5TSVRJT05fRFVSQVRJT04gPSA2MDBcblxuICBDYXJvdXNlbC5ERUZBVUxUUyA9IHtcbiAgICBpbnRlcnZhbDogNTAwMCxcbiAgICBwYXVzZTogJ2hvdmVyJyxcbiAgICB3cmFwOiB0cnVlLFxuICAgIGtleWJvYXJkOiB0cnVlXG4gIH1cblxuICBDYXJvdXNlbC5wcm90b3R5cGUua2V5ZG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZS50YXJnZXQudGFnTmFtZSkpIHJldHVyblxuICAgIHN3aXRjaCAoZS53aGljaCkge1xuICAgICAgY2FzZSAzNzogdGhpcy5wcmV2KCk7IGJyZWFrXG4gICAgICBjYXNlIDM5OiB0aGlzLm5leHQoKTsgYnJlYWtcbiAgICAgIGRlZmF1bHQ6IHJldHVyblxuICAgIH1cblxuICAgIGUucHJldmVudERlZmF1bHQoKVxuICB9XG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLmN5Y2xlID0gZnVuY3Rpb24gKGUpIHtcbiAgICBlIHx8ICh0aGlzLnBhdXNlZCA9IGZhbHNlKVxuXG4gICAgdGhpcy5pbnRlcnZhbCAmJiBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpXG5cbiAgICB0aGlzLm9wdGlvbnMuaW50ZXJ2YWxcbiAgICAgICYmICF0aGlzLnBhdXNlZFxuICAgICAgJiYgKHRoaXMuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgkLnByb3h5KHRoaXMubmV4dCwgdGhpcyksIHRoaXMub3B0aW9ucy5pbnRlcnZhbCkpXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLmdldEl0ZW1JbmRleCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgdGhpcy4kaXRlbXMgPSBpdGVtLnBhcmVudCgpLmNoaWxkcmVuKCcuaXRlbScpXG4gICAgcmV0dXJuIHRoaXMuJGl0ZW1zLmluZGV4KGl0ZW0gfHwgdGhpcy4kYWN0aXZlKVxuICB9XG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLmdldEl0ZW1Gb3JEaXJlY3Rpb24gPSBmdW5jdGlvbiAoZGlyZWN0aW9uLCBhY3RpdmUpIHtcbiAgICB2YXIgYWN0aXZlSW5kZXggPSB0aGlzLmdldEl0ZW1JbmRleChhY3RpdmUpXG4gICAgdmFyIHdpbGxXcmFwID0gKGRpcmVjdGlvbiA9PSAncHJldicgJiYgYWN0aXZlSW5kZXggPT09IDApXG4gICAgICAgICAgICAgICAgfHwgKGRpcmVjdGlvbiA9PSAnbmV4dCcgJiYgYWN0aXZlSW5kZXggPT0gKHRoaXMuJGl0ZW1zLmxlbmd0aCAtIDEpKVxuICAgIGlmICh3aWxsV3JhcCAmJiAhdGhpcy5vcHRpb25zLndyYXApIHJldHVybiBhY3RpdmVcbiAgICB2YXIgZGVsdGEgPSBkaXJlY3Rpb24gPT0gJ3ByZXYnID8gLTEgOiAxXG4gICAgdmFyIGl0ZW1JbmRleCA9IChhY3RpdmVJbmRleCArIGRlbHRhKSAlIHRoaXMuJGl0ZW1zLmxlbmd0aFxuICAgIHJldHVybiB0aGlzLiRpdGVtcy5lcShpdGVtSW5kZXgpXG4gIH1cblxuICBDYXJvdXNlbC5wcm90b3R5cGUudG8gPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgdmFyIHRoYXQgICAgICAgID0gdGhpc1xuICAgIHZhciBhY3RpdmVJbmRleCA9IHRoaXMuZ2V0SXRlbUluZGV4KHRoaXMuJGFjdGl2ZSA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLml0ZW0uYWN0aXZlJykpXG5cbiAgICBpZiAocG9zID4gKHRoaXMuJGl0ZW1zLmxlbmd0aCAtIDEpIHx8IHBvcyA8IDApIHJldHVyblxuXG4gICAgaWYgKHRoaXMuc2xpZGluZykgICAgICAgcmV0dXJuIHRoaXMuJGVsZW1lbnQub25lKCdzbGlkLmJzLmNhcm91c2VsJywgZnVuY3Rpb24gKCkgeyB0aGF0LnRvKHBvcykgfSkgLy8geWVzLCBcInNsaWRcIlxuICAgIGlmIChhY3RpdmVJbmRleCA9PSBwb3MpIHJldHVybiB0aGlzLnBhdXNlKCkuY3ljbGUoKVxuXG4gICAgcmV0dXJuIHRoaXMuc2xpZGUocG9zID4gYWN0aXZlSW5kZXggPyAnbmV4dCcgOiAncHJldicsIHRoaXMuJGl0ZW1zLmVxKHBvcykpXG4gIH1cblxuICBDYXJvdXNlbC5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoZSkge1xuICAgIGUgfHwgKHRoaXMucGF1c2VkID0gdHJ1ZSlcblxuICAgIGlmICh0aGlzLiRlbGVtZW50LmZpbmQoJy5uZXh0LCAucHJldicpLmxlbmd0aCAmJiAkLnN1cHBvcnQudHJhbnNpdGlvbikge1xuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCQuc3VwcG9ydC50cmFuc2l0aW9uLmVuZClcbiAgICAgIHRoaXMuY3ljbGUodHJ1ZSlcbiAgICB9XG5cbiAgICB0aGlzLmludGVydmFsID0gY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnNsaWRpbmcpIHJldHVyblxuICAgIHJldHVybiB0aGlzLnNsaWRlKCduZXh0JylcbiAgfVxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnNsaWRpbmcpIHJldHVyblxuICAgIHJldHVybiB0aGlzLnNsaWRlKCdwcmV2JylcbiAgfVxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5zbGlkZSA9IGZ1bmN0aW9uICh0eXBlLCBuZXh0KSB7XG4gICAgdmFyICRhY3RpdmUgICA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLml0ZW0uYWN0aXZlJylcbiAgICB2YXIgJG5leHQgICAgID0gbmV4dCB8fCB0aGlzLmdldEl0ZW1Gb3JEaXJlY3Rpb24odHlwZSwgJGFjdGl2ZSlcbiAgICB2YXIgaXNDeWNsaW5nID0gdGhpcy5pbnRlcnZhbFxuICAgIHZhciBkaXJlY3Rpb24gPSB0eXBlID09ICduZXh0JyA/ICdsZWZ0JyA6ICdyaWdodCdcbiAgICB2YXIgdGhhdCAgICAgID0gdGhpc1xuXG4gICAgaWYgKCRuZXh0Lmhhc0NsYXNzKCdhY3RpdmUnKSkgcmV0dXJuICh0aGlzLnNsaWRpbmcgPSBmYWxzZSlcblxuICAgIHZhciByZWxhdGVkVGFyZ2V0ID0gJG5leHRbMF1cbiAgICB2YXIgc2xpZGVFdmVudCA9ICQuRXZlbnQoJ3NsaWRlLmJzLmNhcm91c2VsJywge1xuICAgICAgcmVsYXRlZFRhcmdldDogcmVsYXRlZFRhcmdldCxcbiAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gICAgfSlcbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoc2xpZGVFdmVudClcbiAgICBpZiAoc2xpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICB0aGlzLnNsaWRpbmcgPSB0cnVlXG5cbiAgICBpc0N5Y2xpbmcgJiYgdGhpcy5wYXVzZSgpXG5cbiAgICBpZiAodGhpcy4kaW5kaWNhdG9ycy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuJGluZGljYXRvcnMuZmluZCgnLmFjdGl2ZScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKVxuICAgICAgdmFyICRuZXh0SW5kaWNhdG9yID0gJCh0aGlzLiRpbmRpY2F0b3JzLmNoaWxkcmVuKClbdGhpcy5nZXRJdGVtSW5kZXgoJG5leHQpXSlcbiAgICAgICRuZXh0SW5kaWNhdG9yICYmICRuZXh0SW5kaWNhdG9yLmFkZENsYXNzKCdhY3RpdmUnKVxuICAgIH1cblxuICAgIHZhciBzbGlkRXZlbnQgPSAkLkV2ZW50KCdzbGlkLmJzLmNhcm91c2VsJywgeyByZWxhdGVkVGFyZ2V0OiByZWxhdGVkVGFyZ2V0LCBkaXJlY3Rpb246IGRpcmVjdGlvbiB9KSAvLyB5ZXMsIFwic2xpZFwiXG4gICAgaWYgKCQuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ3NsaWRlJykpIHtcbiAgICAgICRuZXh0LmFkZENsYXNzKHR5cGUpXG4gICAgICAkbmV4dFswXS5vZmZzZXRXaWR0aCAvLyBmb3JjZSByZWZsb3dcbiAgICAgICRhY3RpdmUuYWRkQ2xhc3MoZGlyZWN0aW9uKVxuICAgICAgJG5leHQuYWRkQ2xhc3MoZGlyZWN0aW9uKVxuICAgICAgJGFjdGl2ZVxuICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgJG5leHQucmVtb3ZlQ2xhc3MoW3R5cGUsIGRpcmVjdGlvbl0uam9pbignICcpKS5hZGRDbGFzcygnYWN0aXZlJylcbiAgICAgICAgICAkYWN0aXZlLnJlbW92ZUNsYXNzKFsnYWN0aXZlJywgZGlyZWN0aW9uXS5qb2luKCcgJykpXG4gICAgICAgICAgdGhhdC5zbGlkaW5nID0gZmFsc2VcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcihzbGlkRXZlbnQpXG4gICAgICAgICAgfSwgMClcbiAgICAgICAgfSlcbiAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKENhcm91c2VsLlRSQU5TSVRJT05fRFVSQVRJT04pXG4gICAgfSBlbHNlIHtcbiAgICAgICRhY3RpdmUucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpXG4gICAgICAkbmV4dC5hZGRDbGFzcygnYWN0aXZlJylcbiAgICAgIHRoaXMuc2xpZGluZyA9IGZhbHNlXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoc2xpZEV2ZW50KVxuICAgIH1cblxuICAgIGlzQ3ljbGluZyAmJiB0aGlzLmN5Y2xlKClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIENBUk9VU0VMIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgICA9ICR0aGlzLmRhdGEoJ2JzLmNhcm91c2VsJylcbiAgICAgIHZhciBvcHRpb25zID0gJC5leHRlbmQoe30sIENhcm91c2VsLkRFRkFVTFRTLCAkdGhpcy5kYXRhKCksIHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uKVxuICAgICAgdmFyIGFjdGlvbiAgPSB0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnID8gb3B0aW9uIDogb3B0aW9ucy5zbGlkZVxuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLmNhcm91c2VsJywgKGRhdGEgPSBuZXcgQ2Fyb3VzZWwodGhpcywgb3B0aW9ucykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ251bWJlcicpIGRhdGEudG8ob3B0aW9uKVxuICAgICAgZWxzZSBpZiAoYWN0aW9uKSBkYXRhW2FjdGlvbl0oKVxuICAgICAgZWxzZSBpZiAob3B0aW9ucy5pbnRlcnZhbCkgZGF0YS5wYXVzZSgpLmN5Y2xlKClcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4uY2Fyb3VzZWxcblxuICAkLmZuLmNhcm91c2VsICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4uY2Fyb3VzZWwuQ29uc3RydWN0b3IgPSBDYXJvdXNlbFxuXG5cbiAgLy8gQ0FST1VTRUwgTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT09PT1cblxuICAkLmZuLmNhcm91c2VsLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi5jYXJvdXNlbCA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIENBUk9VU0VMIERBVEEtQVBJXG4gIC8vID09PT09PT09PT09PT09PT09XG5cbiAgdmFyIGNsaWNrSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGhyZWZcbiAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICB2YXIgJHRhcmdldCA9ICQoJHRoaXMuYXR0cignZGF0YS10YXJnZXQnKSB8fCAoaHJlZiA9ICR0aGlzLmF0dHIoJ2hyZWYnKSkgJiYgaHJlZi5yZXBsYWNlKC8uKig/PSNbXlxcc10rJCkvLCAnJykpIC8vIHN0cmlwIGZvciBpZTdcbiAgICBpZiAoISR0YXJnZXQuaGFzQ2xhc3MoJ2Nhcm91c2VsJykpIHJldHVyblxuICAgIHZhciBvcHRpb25zID0gJC5leHRlbmQoe30sICR0YXJnZXQuZGF0YSgpLCAkdGhpcy5kYXRhKCkpXG4gICAgdmFyIHNsaWRlSW5kZXggPSAkdGhpcy5hdHRyKCdkYXRhLXNsaWRlLXRvJylcbiAgICBpZiAoc2xpZGVJbmRleCkgb3B0aW9ucy5pbnRlcnZhbCA9IGZhbHNlXG5cbiAgICBQbHVnaW4uY2FsbCgkdGFyZ2V0LCBvcHRpb25zKVxuXG4gICAgaWYgKHNsaWRlSW5kZXgpIHtcbiAgICAgICR0YXJnZXQuZGF0YSgnYnMuY2Fyb3VzZWwnKS50byhzbGlkZUluZGV4KVxuICAgIH1cblxuICAgIGUucHJldmVudERlZmF1bHQoKVxuICB9XG5cbiAgJChkb2N1bWVudClcbiAgICAub24oJ2NsaWNrLmJzLmNhcm91c2VsLmRhdGEtYXBpJywgJ1tkYXRhLXNsaWRlXScsIGNsaWNrSGFuZGxlcilcbiAgICAub24oJ2NsaWNrLmJzLmNhcm91c2VsLmRhdGEtYXBpJywgJ1tkYXRhLXNsaWRlLXRvXScsIGNsaWNrSGFuZGxlcilcblxuICAkKHdpbmRvdykub24oJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgJCgnW2RhdGEtcmlkZT1cImNhcm91c2VsXCJdJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJGNhcm91c2VsID0gJCh0aGlzKVxuICAgICAgUGx1Z2luLmNhbGwoJGNhcm91c2VsLCAkY2Fyb3VzZWwuZGF0YSgpKVxuICAgIH0pXG4gIH0pXG5cbn0oalF1ZXJ5KTtcbiIsIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBjb2xsYXBzZS5qcyB2My4zLjRcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI2NvbGxhcHNlXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTUgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gQ09MTEFQU0UgUFVCTElDIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgQ29sbGFwc2UgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuJGVsZW1lbnQgICAgICA9ICQoZWxlbWVudClcbiAgICB0aGlzLm9wdGlvbnMgICAgICAgPSAkLmV4dGVuZCh7fSwgQ29sbGFwc2UuREVGQVVMVFMsIG9wdGlvbnMpXG4gICAgdGhpcy4kdHJpZ2dlciAgICAgID0gJCgnW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl1baHJlZj1cIiMnICsgZWxlbWVudC5pZCArICdcIl0sJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAnW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl1bZGF0YS10YXJnZXQ9XCIjJyArIGVsZW1lbnQuaWQgKyAnXCJdJylcbiAgICB0aGlzLnRyYW5zaXRpb25pbmcgPSBudWxsXG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnBhcmVudCkge1xuICAgICAgdGhpcy4kcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0aGlzLiRlbGVtZW50LCB0aGlzLiR0cmlnZ2VyKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMudG9nZ2xlKSB0aGlzLnRvZ2dsZSgpXG4gIH1cblxuICBDb2xsYXBzZS5WRVJTSU9OICA9ICczLjMuNCdcblxuICBDb2xsYXBzZS5UUkFOU0lUSU9OX0RVUkFUSU9OID0gMzUwXG5cbiAgQ29sbGFwc2UuREVGQVVMVFMgPSB7XG4gICAgdG9nZ2xlOiB0cnVlXG4gIH1cblxuICBDb2xsYXBzZS5wcm90b3R5cGUuZGltZW5zaW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYXNXaWR0aCA9IHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ3dpZHRoJylcbiAgICByZXR1cm4gaGFzV2lkdGggPyAnd2lkdGgnIDogJ2hlaWdodCdcbiAgfVxuXG4gIENvbGxhcHNlLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnRyYW5zaXRpb25pbmcgfHwgdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnaW4nKSkgcmV0dXJuXG5cbiAgICB2YXIgYWN0aXZlc0RhdGFcbiAgICB2YXIgYWN0aXZlcyA9IHRoaXMuJHBhcmVudCAmJiB0aGlzLiRwYXJlbnQuY2hpbGRyZW4oJy5wYW5lbCcpLmNoaWxkcmVuKCcuaW4sIC5jb2xsYXBzaW5nJylcblxuICAgIGlmIChhY3RpdmVzICYmIGFjdGl2ZXMubGVuZ3RoKSB7XG4gICAgICBhY3RpdmVzRGF0YSA9IGFjdGl2ZXMuZGF0YSgnYnMuY29sbGFwc2UnKVxuICAgICAgaWYgKGFjdGl2ZXNEYXRhICYmIGFjdGl2ZXNEYXRhLnRyYW5zaXRpb25pbmcpIHJldHVyblxuICAgIH1cblxuICAgIHZhciBzdGFydEV2ZW50ID0gJC5FdmVudCgnc2hvdy5icy5jb2xsYXBzZScpXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKHN0YXJ0RXZlbnQpXG4gICAgaWYgKHN0YXJ0RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgaWYgKGFjdGl2ZXMgJiYgYWN0aXZlcy5sZW5ndGgpIHtcbiAgICAgIFBsdWdpbi5jYWxsKGFjdGl2ZXMsICdoaWRlJylcbiAgICAgIGFjdGl2ZXNEYXRhIHx8IGFjdGl2ZXMuZGF0YSgnYnMuY29sbGFwc2UnLCBudWxsKVxuICAgIH1cblxuICAgIHZhciBkaW1lbnNpb24gPSB0aGlzLmRpbWVuc2lvbigpXG5cbiAgICB0aGlzLiRlbGVtZW50XG4gICAgICAucmVtb3ZlQ2xhc3MoJ2NvbGxhcHNlJylcbiAgICAgIC5hZGRDbGFzcygnY29sbGFwc2luZycpW2RpbWVuc2lvbl0oMClcbiAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSlcblxuICAgIHRoaXMuJHRyaWdnZXJcbiAgICAgIC5yZW1vdmVDbGFzcygnY29sbGFwc2VkJylcbiAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSlcblxuICAgIHRoaXMudHJhbnNpdGlvbmluZyA9IDFcblxuICAgIHZhciBjb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgLnJlbW92ZUNsYXNzKCdjb2xsYXBzaW5nJylcbiAgICAgICAgLmFkZENsYXNzKCdjb2xsYXBzZSBpbicpW2RpbWVuc2lvbl0oJycpXG4gICAgICB0aGlzLnRyYW5zaXRpb25pbmcgPSAwXG4gICAgICB0aGlzLiRlbGVtZW50XG4gICAgICAgIC50cmlnZ2VyKCdzaG93bi5icy5jb2xsYXBzZScpXG4gICAgfVxuXG4gICAgaWYgKCEkLnN1cHBvcnQudHJhbnNpdGlvbikgcmV0dXJuIGNvbXBsZXRlLmNhbGwodGhpcylcblxuICAgIHZhciBzY3JvbGxTaXplID0gJC5jYW1lbENhc2UoWydzY3JvbGwnLCBkaW1lbnNpb25dLmpvaW4oJy0nKSlcblxuICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsICQucHJveHkoY29tcGxldGUsIHRoaXMpKVxuICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKENvbGxhcHNlLlRSQU5TSVRJT05fRFVSQVRJT04pW2RpbWVuc2lvbl0odGhpcy4kZWxlbWVudFswXVtzY3JvbGxTaXplXSlcbiAgfVxuXG4gIENvbGxhcHNlLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnRyYW5zaXRpb25pbmcgfHwgIXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2luJykpIHJldHVyblxuXG4gICAgdmFyIHN0YXJ0RXZlbnQgPSAkLkV2ZW50KCdoaWRlLmJzLmNvbGxhcHNlJylcbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoc3RhcnRFdmVudClcbiAgICBpZiAoc3RhcnRFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICB2YXIgZGltZW5zaW9uID0gdGhpcy5kaW1lbnNpb24oKVxuXG4gICAgdGhpcy4kZWxlbWVudFtkaW1lbnNpb25dKHRoaXMuJGVsZW1lbnRbZGltZW5zaW9uXSgpKVswXS5vZmZzZXRIZWlnaHRcblxuICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgIC5hZGRDbGFzcygnY29sbGFwc2luZycpXG4gICAgICAucmVtb3ZlQ2xhc3MoJ2NvbGxhcHNlIGluJylcbiAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgZmFsc2UpXG5cbiAgICB0aGlzLiR0cmlnZ2VyXG4gICAgICAuYWRkQ2xhc3MoJ2NvbGxhcHNlZCcpXG4gICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIGZhbHNlKVxuXG4gICAgdGhpcy50cmFuc2l0aW9uaW5nID0gMVxuXG4gICAgdmFyIGNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy50cmFuc2l0aW9uaW5nID0gMFxuICAgICAgdGhpcy4kZWxlbWVudFxuICAgICAgICAucmVtb3ZlQ2xhc3MoJ2NvbGxhcHNpbmcnKVxuICAgICAgICAuYWRkQ2xhc3MoJ2NvbGxhcHNlJylcbiAgICAgICAgLnRyaWdnZXIoJ2hpZGRlbi5icy5jb2xsYXBzZScpXG4gICAgfVxuXG4gICAgaWYgKCEkLnN1cHBvcnQudHJhbnNpdGlvbikgcmV0dXJuIGNvbXBsZXRlLmNhbGwodGhpcylcblxuICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgIFtkaW1lbnNpb25dKDApXG4gICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCAkLnByb3h5KGNvbXBsZXRlLCB0aGlzKSlcbiAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChDb2xsYXBzZS5UUkFOU0lUSU9OX0RVUkFUSU9OKVxuICB9XG5cbiAgQ29sbGFwc2UucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzW3RoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2luJykgPyAnaGlkZScgOiAnc2hvdyddKClcbiAgfVxuXG4gIENvbGxhcHNlLnByb3RvdHlwZS5nZXRQYXJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICQodGhpcy5vcHRpb25zLnBhcmVudClcbiAgICAgIC5maW5kKCdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXVtkYXRhLXBhcmVudD1cIicgKyB0aGlzLm9wdGlvbnMucGFyZW50ICsgJ1wiXScpXG4gICAgICAuZWFjaCgkLnByb3h5KGZ1bmN0aW9uIChpLCBlbGVtZW50KSB7XG4gICAgICAgIHZhciAkZWxlbWVudCA9ICQoZWxlbWVudClcbiAgICAgICAgdGhpcy5hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MoZ2V0VGFyZ2V0RnJvbVRyaWdnZXIoJGVsZW1lbnQpLCAkZWxlbWVudClcbiAgICAgIH0sIHRoaXMpKVxuICAgICAgLmVuZCgpXG4gIH1cblxuICBDb2xsYXBzZS5wcm90b3R5cGUuYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzID0gZnVuY3Rpb24gKCRlbGVtZW50LCAkdHJpZ2dlcikge1xuICAgIHZhciBpc09wZW4gPSAkZWxlbWVudC5oYXNDbGFzcygnaW4nKVxuXG4gICAgJGVsZW1lbnQuYXR0cignYXJpYS1leHBhbmRlZCcsIGlzT3BlbilcbiAgICAkdHJpZ2dlclxuICAgICAgLnRvZ2dsZUNsYXNzKCdjb2xsYXBzZWQnLCAhaXNPcGVuKVxuICAgICAgLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBpc09wZW4pXG4gIH1cblxuICBmdW5jdGlvbiBnZXRUYXJnZXRGcm9tVHJpZ2dlcigkdHJpZ2dlcikge1xuICAgIHZhciBocmVmXG4gICAgdmFyIHRhcmdldCA9ICR0cmlnZ2VyLmF0dHIoJ2RhdGEtdGFyZ2V0JylcbiAgICAgIHx8IChocmVmID0gJHRyaWdnZXIuYXR0cignaHJlZicpKSAmJiBocmVmLnJlcGxhY2UoLy4qKD89I1teXFxzXSskKS8sICcnKSAvLyBzdHJpcCBmb3IgaWU3XG5cbiAgICByZXR1cm4gJCh0YXJnZXQpXG4gIH1cblxuXG4gIC8vIENPTExBUFNFIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgICA9ICR0aGlzLmRhdGEoJ2JzLmNvbGxhcHNlJylcbiAgICAgIHZhciBvcHRpb25zID0gJC5leHRlbmQoe30sIENvbGxhcHNlLkRFRkFVTFRTLCAkdGhpcy5kYXRhKCksIHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uKVxuXG4gICAgICBpZiAoIWRhdGEgJiYgb3B0aW9ucy50b2dnbGUgJiYgL3Nob3d8aGlkZS8udGVzdChvcHRpb24pKSBvcHRpb25zLnRvZ2dsZSA9IGZhbHNlXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLmNvbGxhcHNlJywgKGRhdGEgPSBuZXcgQ29sbGFwc2UodGhpcywgb3B0aW9ucykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXSgpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLmNvbGxhcHNlXG5cbiAgJC5mbi5jb2xsYXBzZSAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLmNvbGxhcHNlLkNvbnN0cnVjdG9yID0gQ29sbGFwc2VcblxuXG4gIC8vIENPTExBUFNFIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi5jb2xsYXBzZS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4uY29sbGFwc2UgPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICAvLyBDT0xMQVBTRSBEQVRBLUFQSVxuICAvLyA9PT09PT09PT09PT09PT09PVxuXG4gICQoZG9jdW1lbnQpLm9uKCdjbGljay5icy5jb2xsYXBzZS5kYXRhLWFwaScsICdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXScsIGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG5cbiAgICBpZiAoISR0aGlzLmF0dHIoJ2RhdGEtdGFyZ2V0JykpIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgdmFyICR0YXJnZXQgPSBnZXRUYXJnZXRGcm9tVHJpZ2dlcigkdGhpcylcbiAgICB2YXIgZGF0YSAgICA9ICR0YXJnZXQuZGF0YSgnYnMuY29sbGFwc2UnKVxuICAgIHZhciBvcHRpb24gID0gZGF0YSA/ICd0b2dnbGUnIDogJHRoaXMuZGF0YSgpXG5cbiAgICBQbHVnaW4uY2FsbCgkdGFyZ2V0LCBvcHRpb24pXG4gIH0pXG5cbn0oalF1ZXJ5KTtcbiIsIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBkcm9wZG93bi5qcyB2My4zLjRcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI2Ryb3Bkb3duc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE1IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIERST1BET1dOIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBiYWNrZHJvcCA9ICcuZHJvcGRvd24tYmFja2Ryb3AnXG4gIHZhciB0b2dnbGUgICA9ICdbZGF0YS10b2dnbGU9XCJkcm9wZG93blwiXSdcbiAgdmFyIERyb3Bkb3duID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAkKGVsZW1lbnQpLm9uKCdjbGljay5icy5kcm9wZG93bicsIHRoaXMudG9nZ2xlKVxuICB9XG5cbiAgRHJvcGRvd24uVkVSU0lPTiA9ICczLjMuNCdcblxuICBEcm9wZG93bi5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgJHRoaXMgPSAkKHRoaXMpXG5cbiAgICBpZiAoJHRoaXMuaXMoJy5kaXNhYmxlZCwgOmRpc2FibGVkJykpIHJldHVyblxuXG4gICAgdmFyICRwYXJlbnQgID0gZ2V0UGFyZW50KCR0aGlzKVxuICAgIHZhciBpc0FjdGl2ZSA9ICRwYXJlbnQuaGFzQ2xhc3MoJ29wZW4nKVxuXG4gICAgY2xlYXJNZW51cygpXG5cbiAgICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmICEkcGFyZW50LmNsb3Nlc3QoJy5uYXZiYXItbmF2JykubGVuZ3RoKSB7XG4gICAgICAgIC8vIGlmIG1vYmlsZSB3ZSB1c2UgYSBiYWNrZHJvcCBiZWNhdXNlIGNsaWNrIGV2ZW50cyBkb24ndCBkZWxlZ2F0ZVxuICAgICAgICAkKCc8ZGl2IGNsYXNzPVwiZHJvcGRvd24tYmFja2Ryb3BcIi8+JykuaW5zZXJ0QWZ0ZXIoJCh0aGlzKSkub24oJ2NsaWNrJywgY2xlYXJNZW51cylcbiAgICAgIH1cblxuICAgICAgdmFyIHJlbGF0ZWRUYXJnZXQgPSB7IHJlbGF0ZWRUYXJnZXQ6IHRoaXMgfVxuICAgICAgJHBhcmVudC50cmlnZ2VyKGUgPSAkLkV2ZW50KCdzaG93LmJzLmRyb3Bkb3duJywgcmVsYXRlZFRhcmdldCkpXG5cbiAgICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgICAgJHRoaXNcbiAgICAgICAgLnRyaWdnZXIoJ2ZvY3VzJylcbiAgICAgICAgLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCAndHJ1ZScpXG5cbiAgICAgICRwYXJlbnRcbiAgICAgICAgLnRvZ2dsZUNsYXNzKCdvcGVuJylcbiAgICAgICAgLnRyaWdnZXIoJ3Nob3duLmJzLmRyb3Bkb3duJywgcmVsYXRlZFRhcmdldClcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIERyb3Bkb3duLnByb3RvdHlwZS5rZXlkb3duID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoIS8oMzh8NDB8Mjd8MzIpLy50ZXN0KGUud2hpY2gpIHx8IC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZS50YXJnZXQudGFnTmFtZSkpIHJldHVyblxuXG4gICAgdmFyICR0aGlzID0gJCh0aGlzKVxuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuXG4gICAgaWYgKCR0aGlzLmlzKCcuZGlzYWJsZWQsIDpkaXNhYmxlZCcpKSByZXR1cm5cblxuICAgIHZhciAkcGFyZW50ICA9IGdldFBhcmVudCgkdGhpcylcbiAgICB2YXIgaXNBY3RpdmUgPSAkcGFyZW50Lmhhc0NsYXNzKCdvcGVuJylcblxuICAgIGlmICgoIWlzQWN0aXZlICYmIGUud2hpY2ggIT0gMjcpIHx8IChpc0FjdGl2ZSAmJiBlLndoaWNoID09IDI3KSkge1xuICAgICAgaWYgKGUud2hpY2ggPT0gMjcpICRwYXJlbnQuZmluZCh0b2dnbGUpLnRyaWdnZXIoJ2ZvY3VzJylcbiAgICAgIHJldHVybiAkdGhpcy50cmlnZ2VyKCdjbGljaycpXG4gICAgfVxuXG4gICAgdmFyIGRlc2MgPSAnIGxpOm5vdCguZGlzYWJsZWQpOnZpc2libGUgYSdcbiAgICB2YXIgJGl0ZW1zID0gJHBhcmVudC5maW5kKCdbcm9sZT1cIm1lbnVcIl0nICsgZGVzYyArICcsIFtyb2xlPVwibGlzdGJveFwiXScgKyBkZXNjKVxuXG4gICAgaWYgKCEkaXRlbXMubGVuZ3RoKSByZXR1cm5cblxuICAgIHZhciBpbmRleCA9ICRpdGVtcy5pbmRleChlLnRhcmdldClcblxuICAgIGlmIChlLndoaWNoID09IDM4ICYmIGluZGV4ID4gMCkgICAgICAgICAgICAgICAgIGluZGV4LS0gICAgICAgICAgICAgICAgICAgICAgICAvLyB1cFxuICAgIGlmIChlLndoaWNoID09IDQwICYmIGluZGV4IDwgJGl0ZW1zLmxlbmd0aCAtIDEpIGluZGV4KysgICAgICAgICAgICAgICAgICAgICAgICAvLyBkb3duXG4gICAgaWYgKCF+aW5kZXgpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IDBcblxuICAgICRpdGVtcy5lcShpbmRleCkudHJpZ2dlcignZm9jdXMnKVxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJNZW51cyhlKSB7XG4gICAgaWYgKGUgJiYgZS53aGljaCA9PT0gMykgcmV0dXJuXG4gICAgJChiYWNrZHJvcCkucmVtb3ZlKClcbiAgICAkKHRvZ2dsZSkuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgICAgICAgICA9ICQodGhpcylcbiAgICAgIHZhciAkcGFyZW50ICAgICAgID0gZ2V0UGFyZW50KCR0aGlzKVxuICAgICAgdmFyIHJlbGF0ZWRUYXJnZXQgPSB7IHJlbGF0ZWRUYXJnZXQ6IHRoaXMgfVxuXG4gICAgICBpZiAoISRwYXJlbnQuaGFzQ2xhc3MoJ29wZW4nKSkgcmV0dXJuXG5cbiAgICAgICRwYXJlbnQudHJpZ2dlcihlID0gJC5FdmVudCgnaGlkZS5icy5kcm9wZG93bicsIHJlbGF0ZWRUYXJnZXQpKVxuXG4gICAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICAgICR0aGlzLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKVxuICAgICAgJHBhcmVudC5yZW1vdmVDbGFzcygnb3BlbicpLnRyaWdnZXIoJ2hpZGRlbi5icy5kcm9wZG93bicsIHJlbGF0ZWRUYXJnZXQpXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFBhcmVudCgkdGhpcykge1xuICAgIHZhciBzZWxlY3RvciA9ICR0aGlzLmF0dHIoJ2RhdGEtdGFyZ2V0JylcblxuICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgIHNlbGVjdG9yID0gJHRoaXMuYXR0cignaHJlZicpXG4gICAgICBzZWxlY3RvciA9IHNlbGVjdG9yICYmIC8jW0EtWmEtel0vLnRlc3Qoc2VsZWN0b3IpICYmIHNlbGVjdG9yLnJlcGxhY2UoLy4qKD89I1teXFxzXSokKS8sICcnKSAvLyBzdHJpcCBmb3IgaWU3XG4gICAgfVxuXG4gICAgdmFyICRwYXJlbnQgPSBzZWxlY3RvciAmJiAkKHNlbGVjdG9yKVxuXG4gICAgcmV0dXJuICRwYXJlbnQgJiYgJHBhcmVudC5sZW5ndGggPyAkcGFyZW50IDogJHRoaXMucGFyZW50KClcbiAgfVxuXG5cbiAgLy8gRFJPUERPV04gUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgPSAkdGhpcy5kYXRhKCdicy5kcm9wZG93bicpXG5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMuZHJvcGRvd24nLCAoZGF0YSA9IG5ldyBEcm9wZG93bih0aGlzKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dLmNhbGwoJHRoaXMpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLmRyb3Bkb3duXG5cbiAgJC5mbi5kcm9wZG93biAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLmRyb3Bkb3duLkNvbnN0cnVjdG9yID0gRHJvcGRvd25cblxuXG4gIC8vIERST1BET1dOIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi5kcm9wZG93bi5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4uZHJvcGRvd24gPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICAvLyBBUFBMWSBUTyBTVEFOREFSRCBEUk9QRE9XTiBFTEVNRU5UU1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICQoZG9jdW1lbnQpXG4gICAgLm9uKCdjbGljay5icy5kcm9wZG93bi5kYXRhLWFwaScsIGNsZWFyTWVudXMpXG4gICAgLm9uKCdjbGljay5icy5kcm9wZG93bi5kYXRhLWFwaScsICcuZHJvcGRvd24gZm9ybScsIGZ1bmN0aW9uIChlKSB7IGUuc3RvcFByb3BhZ2F0aW9uKCkgfSlcbiAgICAub24oJ2NsaWNrLmJzLmRyb3Bkb3duLmRhdGEtYXBpJywgdG9nZ2xlLCBEcm9wZG93bi5wcm90b3R5cGUudG9nZ2xlKVxuICAgIC5vbigna2V5ZG93bi5icy5kcm9wZG93bi5kYXRhLWFwaScsIHRvZ2dsZSwgRHJvcGRvd24ucHJvdG90eXBlLmtleWRvd24pXG4gICAgLm9uKCdrZXlkb3duLmJzLmRyb3Bkb3duLmRhdGEtYXBpJywgJ1tyb2xlPVwibWVudVwiXScsIERyb3Bkb3duLnByb3RvdHlwZS5rZXlkb3duKVxuICAgIC5vbigna2V5ZG93bi5icy5kcm9wZG93bi5kYXRhLWFwaScsICdbcm9sZT1cImxpc3Rib3hcIl0nLCBEcm9wZG93bi5wcm90b3R5cGUua2V5ZG93bilcblxufShqUXVlcnkpO1xuIiwiLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IG1vZGFsLmpzIHYzLjMuNFxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jbW9kYWxzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTUgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gTU9EQUwgQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIE1vZGFsID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgICAgICAgICAgICAgPSBvcHRpb25zXG4gICAgdGhpcy4kYm9keSAgICAgICAgICAgICAgID0gJChkb2N1bWVudC5ib2R5KVxuICAgIHRoaXMuJGVsZW1lbnQgICAgICAgICAgICA9ICQoZWxlbWVudClcbiAgICB0aGlzLiRkaWFsb2cgICAgICAgICAgICAgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy5tb2RhbC1kaWFsb2cnKVxuICAgIHRoaXMuJGJhY2tkcm9wICAgICAgICAgICA9IG51bGxcbiAgICB0aGlzLmlzU2hvd24gICAgICAgICAgICAgPSBudWxsXG4gICAgdGhpcy5vcmlnaW5hbEJvZHlQYWQgICAgID0gbnVsbFxuICAgIHRoaXMuc2Nyb2xsYmFyV2lkdGggICAgICA9IDBcbiAgICB0aGlzLmlnbm9yZUJhY2tkcm9wQ2xpY2sgPSBmYWxzZVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZW1vdGUpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgLmZpbmQoJy5tb2RhbC1jb250ZW50JylcbiAgICAgICAgLmxvYWQodGhpcy5vcHRpb25zLnJlbW90ZSwgJC5wcm94eShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdsb2FkZWQuYnMubW9kYWwnKVxuICAgICAgICB9LCB0aGlzKSlcbiAgICB9XG4gIH1cblxuICBNb2RhbC5WRVJTSU9OICA9ICczLjMuNCdcblxuICBNb2RhbC5UUkFOU0lUSU9OX0RVUkFUSU9OID0gMzAwXG4gIE1vZGFsLkJBQ0tEUk9QX1RSQU5TSVRJT05fRFVSQVRJT04gPSAxNTBcblxuICBNb2RhbC5ERUZBVUxUUyA9IHtcbiAgICBiYWNrZHJvcDogdHJ1ZSxcbiAgICBrZXlib2FyZDogdHJ1ZSxcbiAgICBzaG93OiB0cnVlXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKF9yZWxhdGVkVGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTaG93biA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KF9yZWxhdGVkVGFyZ2V0KVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoX3JlbGF0ZWRUYXJnZXQpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICB2YXIgZSAgICA9ICQuRXZlbnQoJ3Nob3cuYnMubW9kYWwnLCB7IHJlbGF0ZWRUYXJnZXQ6IF9yZWxhdGVkVGFyZ2V0IH0pXG5cbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoZSlcblxuICAgIGlmICh0aGlzLmlzU2hvd24gfHwgZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICB0aGlzLmlzU2hvd24gPSB0cnVlXG5cbiAgICB0aGlzLmNoZWNrU2Nyb2xsYmFyKClcbiAgICB0aGlzLnNldFNjcm9sbGJhcigpXG4gICAgdGhpcy4kYm9keS5hZGRDbGFzcygnbW9kYWwtb3BlbicpXG5cbiAgICB0aGlzLmVzY2FwZSgpXG4gICAgdGhpcy5yZXNpemUoKVxuXG4gICAgdGhpcy4kZWxlbWVudC5vbignY2xpY2suZGlzbWlzcy5icy5tb2RhbCcsICdbZGF0YS1kaXNtaXNzPVwibW9kYWxcIl0nLCAkLnByb3h5KHRoaXMuaGlkZSwgdGhpcykpXG5cbiAgICB0aGlzLiRkaWFsb2cub24oJ21vdXNlZG93bi5kaXNtaXNzLmJzLm1vZGFsJywgZnVuY3Rpb24gKCkge1xuICAgICAgdGhhdC4kZWxlbWVudC5vbmUoJ21vdXNldXAuZGlzbWlzcy5icy5tb2RhbCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICgkKGUudGFyZ2V0KS5pcyh0aGF0LiRlbGVtZW50KSkgdGhhdC5pZ25vcmVCYWNrZHJvcENsaWNrID0gdHJ1ZVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgdGhpcy5iYWNrZHJvcChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdHJhbnNpdGlvbiA9ICQuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoYXQuJGVsZW1lbnQuaGFzQ2xhc3MoJ2ZhZGUnKVxuXG4gICAgICBpZiAoIXRoYXQuJGVsZW1lbnQucGFyZW50KCkubGVuZ3RoKSB7XG4gICAgICAgIHRoYXQuJGVsZW1lbnQuYXBwZW5kVG8odGhhdC4kYm9keSkgLy8gZG9uJ3QgbW92ZSBtb2RhbHMgZG9tIHBvc2l0aW9uXG4gICAgICB9XG5cbiAgICAgIHRoYXQuJGVsZW1lbnRcbiAgICAgICAgLnNob3coKVxuICAgICAgICAuc2Nyb2xsVG9wKDApXG5cbiAgICAgIHRoYXQuYWRqdXN0RGlhbG9nKClcblxuICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgdGhhdC4kZWxlbWVudFswXS5vZmZzZXRXaWR0aCAvLyBmb3JjZSByZWZsb3dcbiAgICAgIH1cblxuICAgICAgdGhhdC4kZWxlbWVudFxuICAgICAgICAuYWRkQ2xhc3MoJ2luJylcbiAgICAgICAgLmF0dHIoJ2FyaWEtaGlkZGVuJywgZmFsc2UpXG5cbiAgICAgIHRoYXQuZW5mb3JjZUZvY3VzKClcblxuICAgICAgdmFyIGUgPSAkLkV2ZW50KCdzaG93bi5icy5tb2RhbCcsIHsgcmVsYXRlZFRhcmdldDogX3JlbGF0ZWRUYXJnZXQgfSlcblxuICAgICAgdHJhbnNpdGlvbiA/XG4gICAgICAgIHRoYXQuJGRpYWxvZyAvLyB3YWl0IGZvciBtb2RhbCB0byBzbGlkZSBpblxuICAgICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignZm9jdXMnKS50cmlnZ2VyKGUpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoTW9kYWwuVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ2ZvY3VzJykudHJpZ2dlcihlKVxuICAgIH0pXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUpIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgZSA9ICQuRXZlbnQoJ2hpZGUuYnMubW9kYWwnKVxuXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKGUpXG5cbiAgICBpZiAoIXRoaXMuaXNTaG93biB8fCBlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgIHRoaXMuaXNTaG93biA9IGZhbHNlXG5cbiAgICB0aGlzLmVzY2FwZSgpXG4gICAgdGhpcy5yZXNpemUoKVxuXG4gICAgJChkb2N1bWVudCkub2ZmKCdmb2N1c2luLmJzLm1vZGFsJylcblxuICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgIC5yZW1vdmVDbGFzcygnaW4nKVxuICAgICAgLmF0dHIoJ2FyaWEtaGlkZGVuJywgdHJ1ZSlcbiAgICAgIC5vZmYoJ2NsaWNrLmRpc21pc3MuYnMubW9kYWwnKVxuICAgICAgLm9mZignbW91c2V1cC5kaXNtaXNzLmJzLm1vZGFsJylcblxuICAgIHRoaXMuJGRpYWxvZy5vZmYoJ21vdXNlZG93bi5kaXNtaXNzLmJzLm1vZGFsJylcblxuICAgICQuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2ZhZGUnKSA/XG4gICAgICB0aGlzLiRlbGVtZW50XG4gICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsICQucHJveHkodGhpcy5oaWRlTW9kYWwsIHRoaXMpKVxuICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoTW9kYWwuVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgdGhpcy5oaWRlTW9kYWwoKVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmVuZm9yY2VGb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAkKGRvY3VtZW50KVxuICAgICAgLm9mZignZm9jdXNpbi5icy5tb2RhbCcpIC8vIGd1YXJkIGFnYWluc3QgaW5maW5pdGUgZm9jdXMgbG9vcFxuICAgICAgLm9uKCdmb2N1c2luLmJzLm1vZGFsJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy4kZWxlbWVudFswXSAhPT0gZS50YXJnZXQgJiYgIXRoaXMuJGVsZW1lbnQuaGFzKGUudGFyZ2V0KS5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2ZvY3VzJylcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcykpXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuZXNjYXBlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmlzU2hvd24gJiYgdGhpcy5vcHRpb25zLmtleWJvYXJkKSB7XG4gICAgICB0aGlzLiRlbGVtZW50Lm9uKCdrZXlkb3duLmRpc21pc3MuYnMubW9kYWwnLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUud2hpY2ggPT0gMjcgJiYgdGhpcy5oaWRlKClcbiAgICAgIH0sIHRoaXMpKVxuICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNTaG93bikge1xuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJ2tleWRvd24uZGlzbWlzcy5icy5tb2RhbCcpXG4gICAgfVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pc1Nob3duKSB7XG4gICAgICAkKHdpbmRvdykub24oJ3Jlc2l6ZS5icy5tb2RhbCcsICQucHJveHkodGhpcy5oYW5kbGVVcGRhdGUsIHRoaXMpKVxuICAgIH0gZWxzZSB7XG4gICAgICAkKHdpbmRvdykub2ZmKCdyZXNpemUuYnMubW9kYWwnKVxuICAgIH1cbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5oaWRlTW9kYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgdGhpcy4kZWxlbWVudC5oaWRlKClcbiAgICB0aGlzLmJhY2tkcm9wKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoYXQuJGJvZHkucmVtb3ZlQ2xhc3MoJ21vZGFsLW9wZW4nKVxuICAgICAgdGhhdC5yZXNldEFkanVzdG1lbnRzKClcbiAgICAgIHRoYXQucmVzZXRTY3JvbGxiYXIoKVxuICAgICAgdGhhdC4kZWxlbWVudC50cmlnZ2VyKCdoaWRkZW4uYnMubW9kYWwnKVxuICAgIH0pXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUucmVtb3ZlQmFja2Ryb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy4kYmFja2Ryb3AgJiYgdGhpcy4kYmFja2Ryb3AucmVtb3ZlKClcbiAgICB0aGlzLiRiYWNrZHJvcCA9IG51bGxcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5iYWNrZHJvcCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIHZhciBhbmltYXRlID0gdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnZmFkZScpID8gJ2ZhZGUnIDogJydcblxuICAgIGlmICh0aGlzLmlzU2hvd24gJiYgdGhpcy5vcHRpb25zLmJhY2tkcm9wKSB7XG4gICAgICB2YXIgZG9BbmltYXRlID0gJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgYW5pbWF0ZVxuXG4gICAgICB0aGlzLiRiYWNrZHJvcCA9ICQoJzxkaXYgY2xhc3M9XCJtb2RhbC1iYWNrZHJvcCAnICsgYW5pbWF0ZSArICdcIiAvPicpXG4gICAgICAgIC5hcHBlbmRUbyh0aGlzLiRib2R5KVxuXG4gICAgICB0aGlzLiRlbGVtZW50Lm9uKCdjbGljay5kaXNtaXNzLmJzLm1vZGFsJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy5pZ25vcmVCYWNrZHJvcENsaWNrKSB7XG4gICAgICAgICAgdGhpcy5pZ25vcmVCYWNrZHJvcENsaWNrID0gZmFsc2VcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAoZS50YXJnZXQgIT09IGUuY3VycmVudFRhcmdldCkgcmV0dXJuXG4gICAgICAgIHRoaXMub3B0aW9ucy5iYWNrZHJvcCA9PSAnc3RhdGljJ1xuICAgICAgICAgID8gdGhpcy4kZWxlbWVudFswXS5mb2N1cygpXG4gICAgICAgICAgOiB0aGlzLmhpZGUoKVxuICAgICAgfSwgdGhpcykpXG5cbiAgICAgIGlmIChkb0FuaW1hdGUpIHRoaXMuJGJhY2tkcm9wWzBdLm9mZnNldFdpZHRoIC8vIGZvcmNlIHJlZmxvd1xuXG4gICAgICB0aGlzLiRiYWNrZHJvcC5hZGRDbGFzcygnaW4nKVxuXG4gICAgICBpZiAoIWNhbGxiYWNrKSByZXR1cm5cblxuICAgICAgZG9BbmltYXRlID9cbiAgICAgICAgdGhpcy4kYmFja2Ryb3BcbiAgICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCBjYWxsYmFjaylcbiAgICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoTW9kYWwuQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgICBjYWxsYmFjaygpXG5cbiAgICB9IGVsc2UgaWYgKCF0aGlzLmlzU2hvd24gJiYgdGhpcy4kYmFja2Ryb3ApIHtcbiAgICAgIHRoaXMuJGJhY2tkcm9wLnJlbW92ZUNsYXNzKCdpbicpXG5cbiAgICAgIHZhciBjYWxsYmFja1JlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhhdC5yZW1vdmVCYWNrZHJvcCgpXG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbiAgICAgIH1cbiAgICAgICQuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2ZhZGUnKSA/XG4gICAgICAgIHRoaXMuJGJhY2tkcm9wXG4gICAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgY2FsbGJhY2tSZW1vdmUpXG4gICAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKE1vZGFsLkJBQ0tEUk9QX1RSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgICAgY2FsbGJhY2tSZW1vdmUoKVxuXG4gICAgfSBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soKVxuICAgIH1cbiAgfVxuXG4gIC8vIHRoZXNlIGZvbGxvd2luZyBtZXRob2RzIGFyZSB1c2VkIHRvIGhhbmRsZSBvdmVyZmxvd2luZyBtb2RhbHNcblxuICBNb2RhbC5wcm90b3R5cGUuaGFuZGxlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYWRqdXN0RGlhbG9nKClcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5hZGp1c3REaWFsb2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGFsSXNPdmVyZmxvd2luZyA9IHRoaXMuJGVsZW1lbnRbMF0uc2Nyb2xsSGVpZ2h0ID4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodFxuXG4gICAgdGhpcy4kZWxlbWVudC5jc3Moe1xuICAgICAgcGFkZGluZ0xlZnQ6ICAhdGhpcy5ib2R5SXNPdmVyZmxvd2luZyAmJiBtb2RhbElzT3ZlcmZsb3dpbmcgPyB0aGlzLnNjcm9sbGJhcldpZHRoIDogJycsXG4gICAgICBwYWRkaW5nUmlnaHQ6IHRoaXMuYm9keUlzT3ZlcmZsb3dpbmcgJiYgIW1vZGFsSXNPdmVyZmxvd2luZyA/IHRoaXMuc2Nyb2xsYmFyV2lkdGggOiAnJ1xuICAgIH0pXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUucmVzZXRBZGp1c3RtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLiRlbGVtZW50LmNzcyh7XG4gICAgICBwYWRkaW5nTGVmdDogJycsXG4gICAgICBwYWRkaW5nUmlnaHQ6ICcnXG4gICAgfSlcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5jaGVja1Njcm9sbGJhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZnVsbFdpbmRvd1dpZHRoID0gd2luZG93LmlubmVyV2lkdGhcbiAgICBpZiAoIWZ1bGxXaW5kb3dXaWR0aCkgeyAvLyB3b3JrYXJvdW5kIGZvciBtaXNzaW5nIHdpbmRvdy5pbm5lcldpZHRoIGluIElFOFxuICAgICAgdmFyIGRvY3VtZW50RWxlbWVudFJlY3QgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgIGZ1bGxXaW5kb3dXaWR0aCA9IGRvY3VtZW50RWxlbWVudFJlY3QucmlnaHQgLSBNYXRoLmFicyhkb2N1bWVudEVsZW1lbnRSZWN0LmxlZnQpXG4gICAgfVxuICAgIHRoaXMuYm9keUlzT3ZlcmZsb3dpbmcgPSBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoIDwgZnVsbFdpbmRvd1dpZHRoXG4gICAgdGhpcy5zY3JvbGxiYXJXaWR0aCA9IHRoaXMubWVhc3VyZVNjcm9sbGJhcigpXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuc2V0U2Nyb2xsYmFyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBib2R5UGFkID0gcGFyc2VJbnQoKHRoaXMuJGJvZHkuY3NzKCdwYWRkaW5nLXJpZ2h0JykgfHwgMCksIDEwKVxuICAgIHRoaXMub3JpZ2luYWxCb2R5UGFkID0gZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQgfHwgJydcbiAgICBpZiAodGhpcy5ib2R5SXNPdmVyZmxvd2luZykgdGhpcy4kYm9keS5jc3MoJ3BhZGRpbmctcmlnaHQnLCBib2R5UGFkICsgdGhpcy5zY3JvbGxiYXJXaWR0aClcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5yZXNldFNjcm9sbGJhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLiRib2R5LmNzcygncGFkZGluZy1yaWdodCcsIHRoaXMub3JpZ2luYWxCb2R5UGFkKVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLm1lYXN1cmVTY3JvbGxiYXIgPSBmdW5jdGlvbiAoKSB7IC8vIHRoeCB3YWxzaFxuICAgIHZhciBzY3JvbGxEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIHNjcm9sbERpdi5jbGFzc05hbWUgPSAnbW9kYWwtc2Nyb2xsYmFyLW1lYXN1cmUnXG4gICAgdGhpcy4kYm9keS5hcHBlbmQoc2Nyb2xsRGl2KVxuICAgIHZhciBzY3JvbGxiYXJXaWR0aCA9IHNjcm9sbERpdi5vZmZzZXRXaWR0aCAtIHNjcm9sbERpdi5jbGllbnRXaWR0aFxuICAgIHRoaXMuJGJvZHlbMF0ucmVtb3ZlQ2hpbGQoc2Nyb2xsRGl2KVxuICAgIHJldHVybiBzY3JvbGxiYXJXaWR0aFxuICB9XG5cblxuICAvLyBNT0RBTCBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24sIF9yZWxhdGVkVGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICAgID0gJHRoaXMuZGF0YSgnYnMubW9kYWwnKVxuICAgICAgdmFyIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgTW9kYWwuREVGQVVMVFMsICR0aGlzLmRhdGEoKSwgdHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0JyAmJiBvcHRpb24pXG5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMubW9kYWwnLCAoZGF0YSA9IG5ldyBNb2RhbCh0aGlzLCBvcHRpb25zKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dKF9yZWxhdGVkVGFyZ2V0KVxuICAgICAgZWxzZSBpZiAob3B0aW9ucy5zaG93KSBkYXRhLnNob3coX3JlbGF0ZWRUYXJnZXQpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLm1vZGFsXG5cbiAgJC5mbi5tb2RhbCAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLm1vZGFsLkNvbnN0cnVjdG9yID0gTW9kYWxcblxuXG4gIC8vIE1PREFMIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi5tb2RhbC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4ubW9kYWwgPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICAvLyBNT0RBTCBEQVRBLUFQSVxuICAvLyA9PT09PT09PT09PT09PVxuXG4gICQoZG9jdW1lbnQpLm9uKCdjbGljay5icy5tb2RhbC5kYXRhLWFwaScsICdbZGF0YS10b2dnbGU9XCJtb2RhbFwiXScsIGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG4gICAgdmFyIGhyZWYgICAgPSAkdGhpcy5hdHRyKCdocmVmJylcbiAgICB2YXIgJHRhcmdldCA9ICQoJHRoaXMuYXR0cignZGF0YS10YXJnZXQnKSB8fCAoaHJlZiAmJiBocmVmLnJlcGxhY2UoLy4qKD89I1teXFxzXSskKS8sICcnKSkpIC8vIHN0cmlwIGZvciBpZTdcbiAgICB2YXIgb3B0aW9uICA9ICR0YXJnZXQuZGF0YSgnYnMubW9kYWwnKSA/ICd0b2dnbGUnIDogJC5leHRlbmQoeyByZW1vdGU6ICEvIy8udGVzdChocmVmKSAmJiBocmVmIH0sICR0YXJnZXQuZGF0YSgpLCAkdGhpcy5kYXRhKCkpXG5cbiAgICBpZiAoJHRoaXMuaXMoJ2EnKSkgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICAkdGFyZ2V0Lm9uZSgnc2hvdy5icy5tb2RhbCcsIGZ1bmN0aW9uIChzaG93RXZlbnQpIHtcbiAgICAgIGlmIChzaG93RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVybiAvLyBvbmx5IHJlZ2lzdGVyIGZvY3VzIHJlc3RvcmVyIGlmIG1vZGFsIHdpbGwgYWN0dWFsbHkgZ2V0IHNob3duXG4gICAgICAkdGFyZ2V0Lm9uZSgnaGlkZGVuLmJzLm1vZGFsJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAkdGhpcy5pcygnOnZpc2libGUnKSAmJiAkdGhpcy50cmlnZ2VyKCdmb2N1cycpXG4gICAgICB9KVxuICAgIH0pXG4gICAgUGx1Z2luLmNhbGwoJHRhcmdldCwgb3B0aW9uLCB0aGlzKVxuICB9KVxuXG59KGpRdWVyeSk7XG4iLCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogcG9wb3Zlci5qcyB2My4zLjRcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI3BvcG92ZXJzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTUgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gUE9QT1ZFUiBQVUJMSUMgQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIFBvcG92ZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuaW5pdCgncG9wb3ZlcicsIGVsZW1lbnQsIG9wdGlvbnMpXG4gIH1cblxuICBpZiAoISQuZm4udG9vbHRpcCkgdGhyb3cgbmV3IEVycm9yKCdQb3BvdmVyIHJlcXVpcmVzIHRvb2x0aXAuanMnKVxuXG4gIFBvcG92ZXIuVkVSU0lPTiAgPSAnMy4zLjQnXG5cbiAgUG9wb3Zlci5ERUZBVUxUUyA9ICQuZXh0ZW5kKHt9LCAkLmZuLnRvb2x0aXAuQ29uc3RydWN0b3IuREVGQVVMVFMsIHtcbiAgICBwbGFjZW1lbnQ6ICdyaWdodCcsXG4gICAgdHJpZ2dlcjogJ2NsaWNrJyxcbiAgICBjb250ZW50OiAnJyxcbiAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJwb3BvdmVyXCIgcm9sZT1cInRvb2x0aXBcIj48ZGl2IGNsYXNzPVwiYXJyb3dcIj48L2Rpdj48aDMgY2xhc3M9XCJwb3BvdmVyLXRpdGxlXCI+PC9oMz48ZGl2IGNsYXNzPVwicG9wb3Zlci1jb250ZW50XCI+PC9kaXY+PC9kaXY+J1xuICB9KVxuXG5cbiAgLy8gTk9URTogUE9QT1ZFUiBFWFRFTkRTIHRvb2x0aXAuanNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBQb3BvdmVyLnByb3RvdHlwZSA9ICQuZXh0ZW5kKHt9LCAkLmZuLnRvb2x0aXAuQ29uc3RydWN0b3IucHJvdG90eXBlKVxuXG4gIFBvcG92ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUG9wb3ZlclxuXG4gIFBvcG92ZXIucHJvdG90eXBlLmdldERlZmF1bHRzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBQb3BvdmVyLkRFRkFVTFRTXG4gIH1cblxuICBQb3BvdmVyLnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciAkdGlwICAgID0gdGhpcy50aXAoKVxuICAgIHZhciB0aXRsZSAgID0gdGhpcy5nZXRUaXRsZSgpXG4gICAgdmFyIGNvbnRlbnQgPSB0aGlzLmdldENvbnRlbnQoKVxuXG4gICAgJHRpcC5maW5kKCcucG9wb3Zlci10aXRsZScpW3RoaXMub3B0aW9ucy5odG1sID8gJ2h0bWwnIDogJ3RleHQnXSh0aXRsZSlcbiAgICAkdGlwLmZpbmQoJy5wb3BvdmVyLWNvbnRlbnQnKS5jaGlsZHJlbigpLmRldGFjaCgpLmVuZCgpWyAvLyB3ZSB1c2UgYXBwZW5kIGZvciBodG1sIG9iamVjdHMgdG8gbWFpbnRhaW4ganMgZXZlbnRzXG4gICAgICB0aGlzLm9wdGlvbnMuaHRtbCA/ICh0eXBlb2YgY29udGVudCA9PSAnc3RyaW5nJyA/ICdodG1sJyA6ICdhcHBlbmQnKSA6ICd0ZXh0J1xuICAgIF0oY29udGVudClcblxuICAgICR0aXAucmVtb3ZlQ2xhc3MoJ2ZhZGUgdG9wIGJvdHRvbSBsZWZ0IHJpZ2h0IGluJylcblxuICAgIC8vIElFOCBkb2Vzbid0IGFjY2VwdCBoaWRpbmcgdmlhIHRoZSBgOmVtcHR5YCBwc2V1ZG8gc2VsZWN0b3IsIHdlIGhhdmUgdG8gZG9cbiAgICAvLyB0aGlzIG1hbnVhbGx5IGJ5IGNoZWNraW5nIHRoZSBjb250ZW50cy5cbiAgICBpZiAoISR0aXAuZmluZCgnLnBvcG92ZXItdGl0bGUnKS5odG1sKCkpICR0aXAuZmluZCgnLnBvcG92ZXItdGl0bGUnKS5oaWRlKClcbiAgfVxuXG4gIFBvcG92ZXIucHJvdG90eXBlLmhhc0NvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VGl0bGUoKSB8fCB0aGlzLmdldENvbnRlbnQoKVxuICB9XG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuZ2V0Q29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgJGUgPSB0aGlzLiRlbGVtZW50XG4gICAgdmFyIG8gID0gdGhpcy5vcHRpb25zXG5cbiAgICByZXR1cm4gJGUuYXR0cignZGF0YS1jb250ZW50JylcbiAgICAgIHx8ICh0eXBlb2Ygby5jb250ZW50ID09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgby5jb250ZW50LmNhbGwoJGVbMF0pIDpcbiAgICAgICAgICAgIG8uY29udGVudClcbiAgfVxuXG4gIFBvcG92ZXIucHJvdG90eXBlLmFycm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy4kYXJyb3cgPSB0aGlzLiRhcnJvdyB8fCB0aGlzLnRpcCgpLmZpbmQoJy5hcnJvdycpKVxuICB9XG5cblxuICAvLyBQT1BPVkVSIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICAgID0gJHRoaXMuZGF0YSgnYnMucG9wb3ZlcicpXG4gICAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uXG5cbiAgICAgIGlmICghZGF0YSAmJiAvZGVzdHJveXxoaWRlLy50ZXN0KG9wdGlvbikpIHJldHVyblxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy5wb3BvdmVyJywgKGRhdGEgPSBuZXcgUG9wb3Zlcih0aGlzLCBvcHRpb25zKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dKClcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4ucG9wb3ZlclxuXG4gICQuZm4ucG9wb3ZlciAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLnBvcG92ZXIuQ29uc3RydWN0b3IgPSBQb3BvdmVyXG5cblxuICAvLyBQT1BPVkVSIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09PT1cblxuICAkLmZuLnBvcG92ZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLnBvcG92ZXIgPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbn0oalF1ZXJ5KTtcbiIsIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBzY3JvbGxzcHkuanMgdjMuMy40XG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNzY3JvbGxzcHlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNSBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBTQ1JPTExTUFkgQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFNjcm9sbFNweShlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy4kYm9keSAgICAgICAgICA9ICQoZG9jdW1lbnQuYm9keSlcbiAgICB0aGlzLiRzY3JvbGxFbGVtZW50ID0gJChlbGVtZW50KS5pcyhkb2N1bWVudC5ib2R5KSA/ICQod2luZG93KSA6ICQoZWxlbWVudClcbiAgICB0aGlzLm9wdGlvbnMgICAgICAgID0gJC5leHRlbmQoe30sIFNjcm9sbFNweS5ERUZBVUxUUywgb3B0aW9ucylcbiAgICB0aGlzLnNlbGVjdG9yICAgICAgID0gKHRoaXMub3B0aW9ucy50YXJnZXQgfHwgJycpICsgJyAubmF2IGxpID4gYSdcbiAgICB0aGlzLm9mZnNldHMgICAgICAgID0gW11cbiAgICB0aGlzLnRhcmdldHMgICAgICAgID0gW11cbiAgICB0aGlzLmFjdGl2ZVRhcmdldCAgID0gbnVsbFxuICAgIHRoaXMuc2Nyb2xsSGVpZ2h0ICAgPSAwXG5cbiAgICB0aGlzLiRzY3JvbGxFbGVtZW50Lm9uKCdzY3JvbGwuYnMuc2Nyb2xsc3B5JywgJC5wcm94eSh0aGlzLnByb2Nlc3MsIHRoaXMpKVxuICAgIHRoaXMucmVmcmVzaCgpXG4gICAgdGhpcy5wcm9jZXNzKClcbiAgfVxuXG4gIFNjcm9sbFNweS5WRVJTSU9OICA9ICczLjMuNCdcblxuICBTY3JvbGxTcHkuREVGQVVMVFMgPSB7XG4gICAgb2Zmc2V0OiAxMFxuICB9XG5cbiAgU2Nyb2xsU3B5LnByb3RvdHlwZS5nZXRTY3JvbGxIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuJHNjcm9sbEVsZW1lbnRbMF0uc2Nyb2xsSGVpZ2h0IHx8IE1hdGgubWF4KHRoaXMuJGJvZHlbMF0uc2Nyb2xsSGVpZ2h0LCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0KVxuICB9XG5cbiAgU2Nyb2xsU3B5LnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0aGF0ICAgICAgICAgID0gdGhpc1xuICAgIHZhciBvZmZzZXRNZXRob2QgID0gJ29mZnNldCdcbiAgICB2YXIgb2Zmc2V0QmFzZSAgICA9IDBcblxuICAgIHRoaXMub2Zmc2V0cyAgICAgID0gW11cbiAgICB0aGlzLnRhcmdldHMgICAgICA9IFtdXG4gICAgdGhpcy5zY3JvbGxIZWlnaHQgPSB0aGlzLmdldFNjcm9sbEhlaWdodCgpXG5cbiAgICBpZiAoISQuaXNXaW5kb3codGhpcy4kc2Nyb2xsRWxlbWVudFswXSkpIHtcbiAgICAgIG9mZnNldE1ldGhvZCA9ICdwb3NpdGlvbidcbiAgICAgIG9mZnNldEJhc2UgICA9IHRoaXMuJHNjcm9sbEVsZW1lbnQuc2Nyb2xsVG9wKClcbiAgICB9XG5cbiAgICB0aGlzLiRib2R5XG4gICAgICAuZmluZCh0aGlzLnNlbGVjdG9yKVxuICAgICAgLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkZWwgICA9ICQodGhpcylcbiAgICAgICAgdmFyIGhyZWYgID0gJGVsLmRhdGEoJ3RhcmdldCcpIHx8ICRlbC5hdHRyKCdocmVmJylcbiAgICAgICAgdmFyICRocmVmID0gL14jLi8udGVzdChocmVmKSAmJiAkKGhyZWYpXG5cbiAgICAgICAgcmV0dXJuICgkaHJlZlxuICAgICAgICAgICYmICRocmVmLmxlbmd0aFxuICAgICAgICAgICYmICRocmVmLmlzKCc6dmlzaWJsZScpXG4gICAgICAgICAgJiYgW1skaHJlZltvZmZzZXRNZXRob2RdKCkudG9wICsgb2Zmc2V0QmFzZSwgaHJlZl1dKSB8fCBudWxsXG4gICAgICB9KVxuICAgICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGFbMF0gLSBiWzBdIH0pXG4gICAgICAuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoYXQub2Zmc2V0cy5wdXNoKHRoaXNbMF0pXG4gICAgICAgIHRoYXQudGFyZ2V0cy5wdXNoKHRoaXNbMV0pXG4gICAgICB9KVxuICB9XG5cbiAgU2Nyb2xsU3B5LnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzY3JvbGxUb3AgICAgPSB0aGlzLiRzY3JvbGxFbGVtZW50LnNjcm9sbFRvcCgpICsgdGhpcy5vcHRpb25zLm9mZnNldFxuICAgIHZhciBzY3JvbGxIZWlnaHQgPSB0aGlzLmdldFNjcm9sbEhlaWdodCgpXG4gICAgdmFyIG1heFNjcm9sbCAgICA9IHRoaXMub3B0aW9ucy5vZmZzZXQgKyBzY3JvbGxIZWlnaHQgLSB0aGlzLiRzY3JvbGxFbGVtZW50LmhlaWdodCgpXG4gICAgdmFyIG9mZnNldHMgICAgICA9IHRoaXMub2Zmc2V0c1xuICAgIHZhciB0YXJnZXRzICAgICAgPSB0aGlzLnRhcmdldHNcbiAgICB2YXIgYWN0aXZlVGFyZ2V0ID0gdGhpcy5hY3RpdmVUYXJnZXRcbiAgICB2YXIgaVxuXG4gICAgaWYgKHRoaXMuc2Nyb2xsSGVpZ2h0ICE9IHNjcm9sbEhlaWdodCkge1xuICAgICAgdGhpcy5yZWZyZXNoKClcbiAgICB9XG5cbiAgICBpZiAoc2Nyb2xsVG9wID49IG1heFNjcm9sbCkge1xuICAgICAgcmV0dXJuIGFjdGl2ZVRhcmdldCAhPSAoaSA9IHRhcmdldHNbdGFyZ2V0cy5sZW5ndGggLSAxXSkgJiYgdGhpcy5hY3RpdmF0ZShpKVxuICAgIH1cblxuICAgIGlmIChhY3RpdmVUYXJnZXQgJiYgc2Nyb2xsVG9wIDwgb2Zmc2V0c1swXSkge1xuICAgICAgdGhpcy5hY3RpdmVUYXJnZXQgPSBudWxsXG4gICAgICByZXR1cm4gdGhpcy5jbGVhcigpXG4gICAgfVxuXG4gICAgZm9yIChpID0gb2Zmc2V0cy5sZW5ndGg7IGktLTspIHtcbiAgICAgIGFjdGl2ZVRhcmdldCAhPSB0YXJnZXRzW2ldXG4gICAgICAgICYmIHNjcm9sbFRvcCA+PSBvZmZzZXRzW2ldXG4gICAgICAgICYmIChvZmZzZXRzW2kgKyAxXSA9PT0gdW5kZWZpbmVkIHx8IHNjcm9sbFRvcCA8IG9mZnNldHNbaSArIDFdKVxuICAgICAgICAmJiB0aGlzLmFjdGl2YXRlKHRhcmdldHNbaV0pXG4gICAgfVxuICB9XG5cbiAgU2Nyb2xsU3B5LnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICB0aGlzLmFjdGl2ZVRhcmdldCA9IHRhcmdldFxuXG4gICAgdGhpcy5jbGVhcigpXG5cbiAgICB2YXIgc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yICtcbiAgICAgICdbZGF0YS10YXJnZXQ9XCInICsgdGFyZ2V0ICsgJ1wiXSwnICtcbiAgICAgIHRoaXMuc2VsZWN0b3IgKyAnW2hyZWY9XCInICsgdGFyZ2V0ICsgJ1wiXSdcblxuICAgIHZhciBhY3RpdmUgPSAkKHNlbGVjdG9yKVxuICAgICAgLnBhcmVudHMoJ2xpJylcbiAgICAgIC5hZGRDbGFzcygnYWN0aXZlJylcblxuICAgIGlmIChhY3RpdmUucGFyZW50KCcuZHJvcGRvd24tbWVudScpLmxlbmd0aCkge1xuICAgICAgYWN0aXZlID0gYWN0aXZlXG4gICAgICAgIC5jbG9zZXN0KCdsaS5kcm9wZG93bicpXG4gICAgICAgIC5hZGRDbGFzcygnYWN0aXZlJylcbiAgICB9XG5cbiAgICBhY3RpdmUudHJpZ2dlcignYWN0aXZhdGUuYnMuc2Nyb2xsc3B5JylcbiAgfVxuXG4gIFNjcm9sbFNweS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgJCh0aGlzLnNlbGVjdG9yKVxuICAgICAgLnBhcmVudHNVbnRpbCh0aGlzLm9wdGlvbnMudGFyZ2V0LCAnLmFjdGl2ZScpXG4gICAgICAucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpXG4gIH1cblxuXG4gIC8vIFNDUk9MTFNQWSBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICAgID0gJHRoaXMuZGF0YSgnYnMuc2Nyb2xsc3B5JylcbiAgICAgIHZhciBvcHRpb25zID0gdHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0JyAmJiBvcHRpb25cblxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy5zY3JvbGxzcHknLCAoZGF0YSA9IG5ldyBTY3JvbGxTcHkodGhpcywgb3B0aW9ucykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXSgpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLnNjcm9sbHNweVxuXG4gICQuZm4uc2Nyb2xsc3B5ICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4uc2Nyb2xsc3B5LkNvbnN0cnVjdG9yID0gU2Nyb2xsU3B5XG5cblxuICAvLyBTQ1JPTExTUFkgTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi5zY3JvbGxzcHkubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLnNjcm9sbHNweSA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIFNDUk9MTFNQWSBEQVRBLUFQSVxuICAvLyA9PT09PT09PT09PT09PT09PT1cblxuICAkKHdpbmRvdykub24oJ2xvYWQuYnMuc2Nyb2xsc3B5LmRhdGEtYXBpJywgZnVuY3Rpb24gKCkge1xuICAgICQoJ1tkYXRhLXNweT1cInNjcm9sbFwiXScpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICRzcHkgPSAkKHRoaXMpXG4gICAgICBQbHVnaW4uY2FsbCgkc3B5LCAkc3B5LmRhdGEoKSlcbiAgICB9KVxuICB9KVxuXG59KGpRdWVyeSk7XG4iLCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogdGFiLmpzIHYzLjMuNFxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jdGFic1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE1IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIFRBQiBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIFRhYiA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgdGhpcy5lbGVtZW50ID0gJChlbGVtZW50KVxuICB9XG5cbiAgVGFiLlZFUlNJT04gPSAnMy4zLjQnXG5cbiAgVGFiLlRSQU5TSVRJT05fRFVSQVRJT04gPSAxNTBcblxuICBUYWIucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyICR0aGlzICAgID0gdGhpcy5lbGVtZW50XG4gICAgdmFyICR1bCAgICAgID0gJHRoaXMuY2xvc2VzdCgndWw6bm90KC5kcm9wZG93bi1tZW51KScpXG4gICAgdmFyIHNlbGVjdG9yID0gJHRoaXMuZGF0YSgndGFyZ2V0JylcblxuICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgIHNlbGVjdG9yID0gJHRoaXMuYXR0cignaHJlZicpXG4gICAgICBzZWxlY3RvciA9IHNlbGVjdG9yICYmIHNlbGVjdG9yLnJlcGxhY2UoLy4qKD89I1teXFxzXSokKS8sICcnKSAvLyBzdHJpcCBmb3IgaWU3XG4gICAgfVxuXG4gICAgaWYgKCR0aGlzLnBhcmVudCgnbGknKS5oYXNDbGFzcygnYWN0aXZlJykpIHJldHVyblxuXG4gICAgdmFyICRwcmV2aW91cyA9ICR1bC5maW5kKCcuYWN0aXZlOmxhc3QgYScpXG4gICAgdmFyIGhpZGVFdmVudCA9ICQuRXZlbnQoJ2hpZGUuYnMudGFiJywge1xuICAgICAgcmVsYXRlZFRhcmdldDogJHRoaXNbMF1cbiAgICB9KVxuICAgIHZhciBzaG93RXZlbnQgPSAkLkV2ZW50KCdzaG93LmJzLnRhYicsIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6ICRwcmV2aW91c1swXVxuICAgIH0pXG5cbiAgICAkcHJldmlvdXMudHJpZ2dlcihoaWRlRXZlbnQpXG4gICAgJHRoaXMudHJpZ2dlcihzaG93RXZlbnQpXG5cbiAgICBpZiAoc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8IGhpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICB2YXIgJHRhcmdldCA9ICQoc2VsZWN0b3IpXG5cbiAgICB0aGlzLmFjdGl2YXRlKCR0aGlzLmNsb3Nlc3QoJ2xpJyksICR1bClcbiAgICB0aGlzLmFjdGl2YXRlKCR0YXJnZXQsICR0YXJnZXQucGFyZW50KCksIGZ1bmN0aW9uICgpIHtcbiAgICAgICRwcmV2aW91cy50cmlnZ2VyKHtcbiAgICAgICAgdHlwZTogJ2hpZGRlbi5icy50YWInLFxuICAgICAgICByZWxhdGVkVGFyZ2V0OiAkdGhpc1swXVxuICAgICAgfSlcbiAgICAgICR0aGlzLnRyaWdnZXIoe1xuICAgICAgICB0eXBlOiAnc2hvd24uYnMudGFiJyxcbiAgICAgICAgcmVsYXRlZFRhcmdldDogJHByZXZpb3VzWzBdXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBUYWIucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICB2YXIgJGFjdGl2ZSAgICA9IGNvbnRhaW5lci5maW5kKCc+IC5hY3RpdmUnKVxuICAgIHZhciB0cmFuc2l0aW9uID0gY2FsbGJhY2tcbiAgICAgICYmICQuc3VwcG9ydC50cmFuc2l0aW9uXG4gICAgICAmJiAoKCRhY3RpdmUubGVuZ3RoICYmICRhY3RpdmUuaGFzQ2xhc3MoJ2ZhZGUnKSkgfHwgISFjb250YWluZXIuZmluZCgnPiAuZmFkZScpLmxlbmd0aClcblxuICAgIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAkYWN0aXZlXG4gICAgICAgIC5yZW1vdmVDbGFzcygnYWN0aXZlJylcbiAgICAgICAgLmZpbmQoJz4gLmRyb3Bkb3duLW1lbnUgPiAuYWN0aXZlJylcbiAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpXG4gICAgICAgIC5lbmQoKVxuICAgICAgICAuZmluZCgnW2RhdGEtdG9nZ2xlPVwidGFiXCJdJylcbiAgICAgICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIGZhbHNlKVxuXG4gICAgICBlbGVtZW50XG4gICAgICAgIC5hZGRDbGFzcygnYWN0aXZlJylcbiAgICAgICAgLmZpbmQoJ1tkYXRhLXRvZ2dsZT1cInRhYlwiXScpXG4gICAgICAgICAgLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKVxuXG4gICAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgICBlbGVtZW50WzBdLm9mZnNldFdpZHRoIC8vIHJlZmxvdyBmb3IgdHJhbnNpdGlvblxuICAgICAgICBlbGVtZW50LmFkZENsYXNzKCdpbicpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUNsYXNzKCdmYWRlJylcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnQucGFyZW50KCcuZHJvcGRvd24tbWVudScpLmxlbmd0aCkge1xuICAgICAgICBlbGVtZW50XG4gICAgICAgICAgLmNsb3Nlc3QoJ2xpLmRyb3Bkb3duJylcbiAgICAgICAgICAgIC5hZGRDbGFzcygnYWN0aXZlJylcbiAgICAgICAgICAuZW5kKClcbiAgICAgICAgICAuZmluZCgnW2RhdGEtdG9nZ2xlPVwidGFiXCJdJylcbiAgICAgICAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSlcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKVxuICAgIH1cblxuICAgICRhY3RpdmUubGVuZ3RoICYmIHRyYW5zaXRpb24gP1xuICAgICAgJGFjdGl2ZVxuICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCBuZXh0KVxuICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoVGFiLlRSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgIG5leHQoKVxuXG4gICAgJGFjdGl2ZS5yZW1vdmVDbGFzcygnaW4nKVxuICB9XG5cblxuICAvLyBUQUIgUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgID0gJHRoaXMuZGF0YSgnYnMudGFiJylcblxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy50YWInLCAoZGF0YSA9IG5ldyBUYWIodGhpcykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXSgpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLnRhYlxuXG4gICQuZm4udGFiICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4udGFiLkNvbnN0cnVjdG9yID0gVGFiXG5cblxuICAvLyBUQUIgTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09XG5cbiAgJC5mbi50YWIubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLnRhYiA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIFRBQiBEQVRBLUFQSVxuICAvLyA9PT09PT09PT09PT1cblxuICB2YXIgY2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBQbHVnaW4uY2FsbCgkKHRoaXMpLCAnc2hvdycpXG4gIH1cblxuICAkKGRvY3VtZW50KVxuICAgIC5vbignY2xpY2suYnMudGFiLmRhdGEtYXBpJywgJ1tkYXRhLXRvZ2dsZT1cInRhYlwiXScsIGNsaWNrSGFuZGxlcilcbiAgICAub24oJ2NsaWNrLmJzLnRhYi5kYXRhLWFwaScsICdbZGF0YS10b2dnbGU9XCJwaWxsXCJdJywgY2xpY2tIYW5kbGVyKVxuXG59KGpRdWVyeSk7XG4iLCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogdG9vbHRpcC5qcyB2My4zLjRcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI3Rvb2x0aXBcbiAqIEluc3BpcmVkIGJ5IHRoZSBvcmlnaW5hbCBqUXVlcnkudGlwc3kgYnkgSmFzb24gRnJhbWVcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNSBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBUT09MVElQIFBVQkxJQyBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgVG9vbHRpcCA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy50eXBlICAgICAgID0gbnVsbFxuICAgIHRoaXMub3B0aW9ucyAgICA9IG51bGxcbiAgICB0aGlzLmVuYWJsZWQgICAgPSBudWxsXG4gICAgdGhpcy50aW1lb3V0ICAgID0gbnVsbFxuICAgIHRoaXMuaG92ZXJTdGF0ZSA9IG51bGxcbiAgICB0aGlzLiRlbGVtZW50ICAgPSBudWxsXG5cbiAgICB0aGlzLmluaXQoJ3Rvb2x0aXAnLCBlbGVtZW50LCBvcHRpb25zKVxuICB9XG5cbiAgVG9vbHRpcC5WRVJTSU9OICA9ICczLjMuNCdcblxuICBUb29sdGlwLlRSQU5TSVRJT05fRFVSQVRJT04gPSAxNTBcblxuICBUb29sdGlwLkRFRkFVTFRTID0ge1xuICAgIGFuaW1hdGlvbjogdHJ1ZSxcbiAgICBwbGFjZW1lbnQ6ICd0b3AnLFxuICAgIHNlbGVjdG9yOiBmYWxzZSxcbiAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJ0b29sdGlwXCIgcm9sZT1cInRvb2x0aXBcIj48ZGl2IGNsYXNzPVwidG9vbHRpcC1hcnJvd1wiPjwvZGl2PjxkaXYgY2xhc3M9XCJ0b29sdGlwLWlubmVyXCI+PC9kaXY+PC9kaXY+JyxcbiAgICB0cmlnZ2VyOiAnaG92ZXIgZm9jdXMnLFxuICAgIHRpdGxlOiAnJyxcbiAgICBkZWxheTogMCxcbiAgICBodG1sOiBmYWxzZSxcbiAgICBjb250YWluZXI6IGZhbHNlLFxuICAgIHZpZXdwb3J0OiB7XG4gICAgICBzZWxlY3RvcjogJ2JvZHknLFxuICAgICAgcGFkZGluZzogMFxuICAgIH1cbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAodHlwZSwgZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuZW5hYmxlZCAgID0gdHJ1ZVxuICAgIHRoaXMudHlwZSAgICAgID0gdHlwZVxuICAgIHRoaXMuJGVsZW1lbnQgID0gJChlbGVtZW50KVxuICAgIHRoaXMub3B0aW9ucyAgID0gdGhpcy5nZXRPcHRpb25zKG9wdGlvbnMpXG4gICAgdGhpcy4kdmlld3BvcnQgPSB0aGlzLm9wdGlvbnMudmlld3BvcnQgJiYgJCh0aGlzLm9wdGlvbnMudmlld3BvcnQuc2VsZWN0b3IgfHwgdGhpcy5vcHRpb25zLnZpZXdwb3J0KVxuXG4gICAgaWYgKHRoaXMuJGVsZW1lbnRbMF0gaW5zdGFuY2VvZiBkb2N1bWVudC5jb25zdHJ1Y3RvciAmJiAhdGhpcy5vcHRpb25zLnNlbGVjdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BzZWxlY3RvcmAgb3B0aW9uIG11c3QgYmUgc3BlY2lmaWVkIHdoZW4gaW5pdGlhbGl6aW5nICcgKyB0aGlzLnR5cGUgKyAnIG9uIHRoZSB3aW5kb3cuZG9jdW1lbnQgb2JqZWN0IScpXG4gICAgfVxuXG4gICAgdmFyIHRyaWdnZXJzID0gdGhpcy5vcHRpb25zLnRyaWdnZXIuc3BsaXQoJyAnKVxuXG4gICAgZm9yICh2YXIgaSA9IHRyaWdnZXJzLmxlbmd0aDsgaS0tOykge1xuICAgICAgdmFyIHRyaWdnZXIgPSB0cmlnZ2Vyc1tpXVxuXG4gICAgICBpZiAodHJpZ2dlciA9PSAnY2xpY2snKSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ2NsaWNrLicgKyB0aGlzLnR5cGUsIHRoaXMub3B0aW9ucy5zZWxlY3RvciwgJC5wcm94eSh0aGlzLnRvZ2dsZSwgdGhpcykpXG4gICAgICB9IGVsc2UgaWYgKHRyaWdnZXIgIT0gJ21hbnVhbCcpIHtcbiAgICAgICAgdmFyIGV2ZW50SW4gID0gdHJpZ2dlciA9PSAnaG92ZXInID8gJ21vdXNlZW50ZXInIDogJ2ZvY3VzaW4nXG4gICAgICAgIHZhciBldmVudE91dCA9IHRyaWdnZXIgPT0gJ2hvdmVyJyA/ICdtb3VzZWxlYXZlJyA6ICdmb2N1c291dCdcblxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKGV2ZW50SW4gICsgJy4nICsgdGhpcy50eXBlLCB0aGlzLm9wdGlvbnMuc2VsZWN0b3IsICQucHJveHkodGhpcy5lbnRlciwgdGhpcykpXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oZXZlbnRPdXQgKyAnLicgKyB0aGlzLnR5cGUsIHRoaXMub3B0aW9ucy5zZWxlY3RvciwgJC5wcm94eSh0aGlzLmxlYXZlLCB0aGlzKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMuc2VsZWN0b3IgP1xuICAgICAgKHRoaXMuX29wdGlvbnMgPSAkLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCB7IHRyaWdnZXI6ICdtYW51YWwnLCBzZWxlY3RvcjogJycgfSkpIDpcbiAgICAgIHRoaXMuZml4VGl0bGUoKVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZ2V0RGVmYXVsdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRvb2x0aXAuREVGQVVMVFNcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmdldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgdGhpcy5nZXREZWZhdWx0cygpLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucylcblxuICAgIGlmIChvcHRpb25zLmRlbGF5ICYmIHR5cGVvZiBvcHRpb25zLmRlbGF5ID09ICdudW1iZXInKSB7XG4gICAgICBvcHRpb25zLmRlbGF5ID0ge1xuICAgICAgICBzaG93OiBvcHRpb25zLmRlbGF5LFxuICAgICAgICBoaWRlOiBvcHRpb25zLmRlbGF5XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdGlvbnNcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmdldERlbGVnYXRlT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9ucyAgPSB7fVxuICAgIHZhciBkZWZhdWx0cyA9IHRoaXMuZ2V0RGVmYXVsdHMoKVxuXG4gICAgdGhpcy5fb3B0aW9ucyAmJiAkLmVhY2godGhpcy5fb3B0aW9ucywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChkZWZhdWx0c1trZXldICE9IHZhbHVlKSBvcHRpb25zW2tleV0gPSB2YWx1ZVxuICAgIH0pXG5cbiAgICByZXR1cm4gb3B0aW9uc1xuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZW50ZXIgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHNlbGYgPSBvYmogaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yID9cbiAgICAgIG9iaiA6ICQob2JqLmN1cnJlbnRUYXJnZXQpLmRhdGEoJ2JzLicgKyB0aGlzLnR5cGUpXG5cbiAgICBpZiAoc2VsZiAmJiBzZWxmLiR0aXAgJiYgc2VsZi4kdGlwLmlzKCc6dmlzaWJsZScpKSB7XG4gICAgICBzZWxmLmhvdmVyU3RhdGUgPSAnaW4nXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoIXNlbGYpIHtcbiAgICAgIHNlbGYgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihvYmouY3VycmVudFRhcmdldCwgdGhpcy5nZXREZWxlZ2F0ZU9wdGlvbnMoKSlcbiAgICAgICQob2JqLmN1cnJlbnRUYXJnZXQpLmRhdGEoJ2JzLicgKyB0aGlzLnR5cGUsIHNlbGYpXG4gICAgfVxuXG4gICAgY2xlYXJUaW1lb3V0KHNlbGYudGltZW91dClcblxuICAgIHNlbGYuaG92ZXJTdGF0ZSA9ICdpbidcblxuICAgIGlmICghc2VsZi5vcHRpb25zLmRlbGF5IHx8ICFzZWxmLm9wdGlvbnMuZGVsYXkuc2hvdykgcmV0dXJuIHNlbGYuc2hvdygpXG5cbiAgICBzZWxmLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLmhvdmVyU3RhdGUgPT0gJ2luJykgc2VsZi5zaG93KClcbiAgICB9LCBzZWxmLm9wdGlvbnMuZGVsYXkuc2hvdylcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmxlYXZlID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBzZWxmID0gb2JqIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3RvciA/XG4gICAgICBvYmogOiAkKG9iai5jdXJyZW50VGFyZ2V0KS5kYXRhKCdicy4nICsgdGhpcy50eXBlKVxuXG4gICAgaWYgKCFzZWxmKSB7XG4gICAgICBzZWxmID0gbmV3IHRoaXMuY29uc3RydWN0b3Iob2JqLmN1cnJlbnRUYXJnZXQsIHRoaXMuZ2V0RGVsZWdhdGVPcHRpb25zKCkpXG4gICAgICAkKG9iai5jdXJyZW50VGFyZ2V0KS5kYXRhKCdicy4nICsgdGhpcy50eXBlLCBzZWxmKVxuICAgIH1cblxuICAgIGNsZWFyVGltZW91dChzZWxmLnRpbWVvdXQpXG5cbiAgICBzZWxmLmhvdmVyU3RhdGUgPSAnb3V0J1xuXG4gICAgaWYgKCFzZWxmLm9wdGlvbnMuZGVsYXkgfHwgIXNlbGYub3B0aW9ucy5kZWxheS5oaWRlKSByZXR1cm4gc2VsZi5oaWRlKClcblxuICAgIHNlbGYudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuaG92ZXJTdGF0ZSA9PSAnb3V0Jykgc2VsZi5oaWRlKClcbiAgICB9LCBzZWxmLm9wdGlvbnMuZGVsYXkuaGlkZSlcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGUgPSAkLkV2ZW50KCdzaG93LmJzLicgKyB0aGlzLnR5cGUpXG5cbiAgICBpZiAodGhpcy5oYXNDb250ZW50KCkgJiYgdGhpcy5lbmFibGVkKSB7XG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoZSlcblxuICAgICAgdmFyIGluRG9tID0gJC5jb250YWlucyh0aGlzLiRlbGVtZW50WzBdLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB0aGlzLiRlbGVtZW50WzBdKVxuICAgICAgaWYgKGUuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgIWluRG9tKSByZXR1cm5cbiAgICAgIHZhciB0aGF0ID0gdGhpc1xuXG4gICAgICB2YXIgJHRpcCA9IHRoaXMudGlwKClcblxuICAgICAgdmFyIHRpcElkID0gdGhpcy5nZXRVSUQodGhpcy50eXBlKVxuXG4gICAgICB0aGlzLnNldENvbnRlbnQoKVxuICAgICAgJHRpcC5hdHRyKCdpZCcsIHRpcElkKVxuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLWRlc2NyaWJlZGJ5JywgdGlwSWQpXG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYW5pbWF0aW9uKSAkdGlwLmFkZENsYXNzKCdmYWRlJylcblxuICAgICAgdmFyIHBsYWNlbWVudCA9IHR5cGVvZiB0aGlzLm9wdGlvbnMucGxhY2VtZW50ID09ICdmdW5jdGlvbicgP1xuICAgICAgICB0aGlzLm9wdGlvbnMucGxhY2VtZW50LmNhbGwodGhpcywgJHRpcFswXSwgdGhpcy4kZWxlbWVudFswXSkgOlxuICAgICAgICB0aGlzLm9wdGlvbnMucGxhY2VtZW50XG5cbiAgICAgIHZhciBhdXRvVG9rZW4gPSAvXFxzP2F1dG8/XFxzPy9pXG4gICAgICB2YXIgYXV0b1BsYWNlID0gYXV0b1Rva2VuLnRlc3QocGxhY2VtZW50KVxuICAgICAgaWYgKGF1dG9QbGFjZSkgcGxhY2VtZW50ID0gcGxhY2VtZW50LnJlcGxhY2UoYXV0b1Rva2VuLCAnJykgfHwgJ3RvcCdcblxuICAgICAgJHRpcFxuICAgICAgICAuZGV0YWNoKClcbiAgICAgICAgLmNzcyh7IHRvcDogMCwgbGVmdDogMCwgZGlzcGxheTogJ2Jsb2NrJyB9KVxuICAgICAgICAuYWRkQ2xhc3MocGxhY2VtZW50KVxuICAgICAgICAuZGF0YSgnYnMuJyArIHRoaXMudHlwZSwgdGhpcylcblxuICAgICAgdGhpcy5vcHRpb25zLmNvbnRhaW5lciA/ICR0aXAuYXBwZW5kVG8odGhpcy5vcHRpb25zLmNvbnRhaW5lcikgOiAkdGlwLmluc2VydEFmdGVyKHRoaXMuJGVsZW1lbnQpXG5cbiAgICAgIHZhciBwb3MgICAgICAgICAgPSB0aGlzLmdldFBvc2l0aW9uKClcbiAgICAgIHZhciBhY3R1YWxXaWR0aCAgPSAkdGlwWzBdLm9mZnNldFdpZHRoXG4gICAgICB2YXIgYWN0dWFsSGVpZ2h0ID0gJHRpcFswXS5vZmZzZXRIZWlnaHRcblxuICAgICAgaWYgKGF1dG9QbGFjZSkge1xuICAgICAgICB2YXIgb3JnUGxhY2VtZW50ID0gcGxhY2VtZW50XG4gICAgICAgIHZhciAkY29udGFpbmVyICAgPSB0aGlzLm9wdGlvbnMuY29udGFpbmVyID8gJCh0aGlzLm9wdGlvbnMuY29udGFpbmVyKSA6IHRoaXMuJGVsZW1lbnQucGFyZW50KClcbiAgICAgICAgdmFyIGNvbnRhaW5lckRpbSA9IHRoaXMuZ2V0UG9zaXRpb24oJGNvbnRhaW5lcilcblxuICAgICAgICBwbGFjZW1lbnQgPSBwbGFjZW1lbnQgPT0gJ2JvdHRvbScgJiYgcG9zLmJvdHRvbSArIGFjdHVhbEhlaWdodCA+IGNvbnRhaW5lckRpbS5ib3R0b20gPyAndG9wJyAgICA6XG4gICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9PSAndG9wJyAgICAmJiBwb3MudG9wICAgIC0gYWN0dWFsSGVpZ2h0IDwgY29udGFpbmVyRGltLnRvcCAgICA/ICdib3R0b20nIDpcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID09ICdyaWdodCcgICYmIHBvcy5yaWdodCAgKyBhY3R1YWxXaWR0aCAgPiBjb250YWluZXJEaW0ud2lkdGggID8gJ2xlZnQnICAgOlxuICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPT0gJ2xlZnQnICAgJiYgcG9zLmxlZnQgICAtIGFjdHVhbFdpZHRoICA8IGNvbnRhaW5lckRpbS5sZWZ0ICAgPyAncmlnaHQnICA6XG4gICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudFxuXG4gICAgICAgICR0aXBcbiAgICAgICAgICAucmVtb3ZlQ2xhc3Mob3JnUGxhY2VtZW50KVxuICAgICAgICAgIC5hZGRDbGFzcyhwbGFjZW1lbnQpXG4gICAgICB9XG5cbiAgICAgIHZhciBjYWxjdWxhdGVkT2Zmc2V0ID0gdGhpcy5nZXRDYWxjdWxhdGVkT2Zmc2V0KHBsYWNlbWVudCwgcG9zLCBhY3R1YWxXaWR0aCwgYWN0dWFsSGVpZ2h0KVxuXG4gICAgICB0aGlzLmFwcGx5UGxhY2VtZW50KGNhbGN1bGF0ZWRPZmZzZXQsIHBsYWNlbWVudClcblxuICAgICAgdmFyIGNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJldkhvdmVyU3RhdGUgPSB0aGF0LmhvdmVyU3RhdGVcbiAgICAgICAgdGhhdC4kZWxlbWVudC50cmlnZ2VyKCdzaG93bi5icy4nICsgdGhhdC50eXBlKVxuICAgICAgICB0aGF0LmhvdmVyU3RhdGUgPSBudWxsXG5cbiAgICAgICAgaWYgKHByZXZIb3ZlclN0YXRlID09ICdvdXQnKSB0aGF0LmxlYXZlKHRoYXQpXG4gICAgICB9XG5cbiAgICAgICQuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoaXMuJHRpcC5oYXNDbGFzcygnZmFkZScpID9cbiAgICAgICAgJHRpcFxuICAgICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGNvbXBsZXRlKVxuICAgICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChUb29sdGlwLlRSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgICAgY29tcGxldGUoKVxuICAgIH1cbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmFwcGx5UGxhY2VtZW50ID0gZnVuY3Rpb24gKG9mZnNldCwgcGxhY2VtZW50KSB7XG4gICAgdmFyICR0aXAgICA9IHRoaXMudGlwKClcbiAgICB2YXIgd2lkdGggID0gJHRpcFswXS5vZmZzZXRXaWR0aFxuICAgIHZhciBoZWlnaHQgPSAkdGlwWzBdLm9mZnNldEhlaWdodFxuXG4gICAgLy8gbWFudWFsbHkgcmVhZCBtYXJnaW5zIGJlY2F1c2UgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGluY2x1ZGVzIGRpZmZlcmVuY2VcbiAgICB2YXIgbWFyZ2luVG9wID0gcGFyc2VJbnQoJHRpcC5jc3MoJ21hcmdpbi10b3AnKSwgMTApXG4gICAgdmFyIG1hcmdpbkxlZnQgPSBwYXJzZUludCgkdGlwLmNzcygnbWFyZ2luLWxlZnQnKSwgMTApXG5cbiAgICAvLyB3ZSBtdXN0IGNoZWNrIGZvciBOYU4gZm9yIGllIDgvOVxuICAgIGlmIChpc05hTihtYXJnaW5Ub3ApKSAgbWFyZ2luVG9wICA9IDBcbiAgICBpZiAoaXNOYU4obWFyZ2luTGVmdCkpIG1hcmdpbkxlZnQgPSAwXG5cbiAgICBvZmZzZXQudG9wICA9IG9mZnNldC50b3AgICsgbWFyZ2luVG9wXG4gICAgb2Zmc2V0LmxlZnQgPSBvZmZzZXQubGVmdCArIG1hcmdpbkxlZnRcblxuICAgIC8vICQuZm4ub2Zmc2V0IGRvZXNuJ3Qgcm91bmQgcGl4ZWwgdmFsdWVzXG4gICAgLy8gc28gd2UgdXNlIHNldE9mZnNldCBkaXJlY3RseSB3aXRoIG91ciBvd24gZnVuY3Rpb24gQi0wXG4gICAgJC5vZmZzZXQuc2V0T2Zmc2V0KCR0aXBbMF0sICQuZXh0ZW5kKHtcbiAgICAgIHVzaW5nOiBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgJHRpcC5jc3Moe1xuICAgICAgICAgIHRvcDogTWF0aC5yb3VuZChwcm9wcy50b3ApLFxuICAgICAgICAgIGxlZnQ6IE1hdGgucm91bmQocHJvcHMubGVmdClcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9LCBvZmZzZXQpLCAwKVxuXG4gICAgJHRpcC5hZGRDbGFzcygnaW4nKVxuXG4gICAgLy8gY2hlY2sgdG8gc2VlIGlmIHBsYWNpbmcgdGlwIGluIG5ldyBvZmZzZXQgY2F1c2VkIHRoZSB0aXAgdG8gcmVzaXplIGl0c2VsZlxuICAgIHZhciBhY3R1YWxXaWR0aCAgPSAkdGlwWzBdLm9mZnNldFdpZHRoXG4gICAgdmFyIGFjdHVhbEhlaWdodCA9ICR0aXBbMF0ub2Zmc2V0SGVpZ2h0XG5cbiAgICBpZiAocGxhY2VtZW50ID09ICd0b3AnICYmIGFjdHVhbEhlaWdodCAhPSBoZWlnaHQpIHtcbiAgICAgIG9mZnNldC50b3AgPSBvZmZzZXQudG9wICsgaGVpZ2h0IC0gYWN0dWFsSGVpZ2h0XG4gICAgfVxuXG4gICAgdmFyIGRlbHRhID0gdGhpcy5nZXRWaWV3cG9ydEFkanVzdGVkRGVsdGEocGxhY2VtZW50LCBvZmZzZXQsIGFjdHVhbFdpZHRoLCBhY3R1YWxIZWlnaHQpXG5cbiAgICBpZiAoZGVsdGEubGVmdCkgb2Zmc2V0LmxlZnQgKz0gZGVsdGEubGVmdFxuICAgIGVsc2Ugb2Zmc2V0LnRvcCArPSBkZWx0YS50b3BcblxuICAgIHZhciBpc1ZlcnRpY2FsICAgICAgICAgID0gL3RvcHxib3R0b20vLnRlc3QocGxhY2VtZW50KVxuICAgIHZhciBhcnJvd0RlbHRhICAgICAgICAgID0gaXNWZXJ0aWNhbCA/IGRlbHRhLmxlZnQgKiAyIC0gd2lkdGggKyBhY3R1YWxXaWR0aCA6IGRlbHRhLnRvcCAqIDIgLSBoZWlnaHQgKyBhY3R1YWxIZWlnaHRcbiAgICB2YXIgYXJyb3dPZmZzZXRQb3NpdGlvbiA9IGlzVmVydGljYWwgPyAnb2Zmc2V0V2lkdGgnIDogJ29mZnNldEhlaWdodCdcblxuICAgICR0aXAub2Zmc2V0KG9mZnNldClcbiAgICB0aGlzLnJlcGxhY2VBcnJvdyhhcnJvd0RlbHRhLCAkdGlwWzBdW2Fycm93T2Zmc2V0UG9zaXRpb25dLCBpc1ZlcnRpY2FsKVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUucmVwbGFjZUFycm93ID0gZnVuY3Rpb24gKGRlbHRhLCBkaW1lbnNpb24sIGlzVmVydGljYWwpIHtcbiAgICB0aGlzLmFycm93KClcbiAgICAgIC5jc3MoaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnLCA1MCAqICgxIC0gZGVsdGEgLyBkaW1lbnNpb24pICsgJyUnKVxuICAgICAgLmNzcyhpc1ZlcnRpY2FsID8gJ3RvcCcgOiAnbGVmdCcsICcnKVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgJHRpcCAgPSB0aGlzLnRpcCgpXG4gICAgdmFyIHRpdGxlID0gdGhpcy5nZXRUaXRsZSgpXG5cbiAgICAkdGlwLmZpbmQoJy50b29sdGlwLWlubmVyJylbdGhpcy5vcHRpb25zLmh0bWwgPyAnaHRtbCcgOiAndGV4dCddKHRpdGxlKVxuICAgICR0aXAucmVtb3ZlQ2xhc3MoJ2ZhZGUgaW4gdG9wIGJvdHRvbSBsZWZ0IHJpZ2h0JylcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICB2YXIgJHRpcCA9ICQodGhpcy4kdGlwKVxuICAgIHZhciBlICAgID0gJC5FdmVudCgnaGlkZS5icy4nICsgdGhpcy50eXBlKVxuXG4gICAgZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgICBpZiAodGhhdC5ob3ZlclN0YXRlICE9ICdpbicpICR0aXAuZGV0YWNoKClcbiAgICAgIHRoYXQuJGVsZW1lbnRcbiAgICAgICAgLnJlbW92ZUF0dHIoJ2FyaWEtZGVzY3JpYmVkYnknKVxuICAgICAgICAudHJpZ2dlcignaGlkZGVuLmJzLicgKyB0aGF0LnR5cGUpXG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpXG4gICAgfVxuXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKGUpXG5cbiAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICAkdGlwLnJlbW92ZUNsYXNzKCdpbicpXG5cbiAgICAkLnN1cHBvcnQudHJhbnNpdGlvbiAmJiAkdGlwLmhhc0NsYXNzKCdmYWRlJykgP1xuICAgICAgJHRpcFxuICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCBjb21wbGV0ZSlcbiAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKFRvb2x0aXAuVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgY29tcGxldGUoKVxuXG4gICAgdGhpcy5ob3ZlclN0YXRlID0gbnVsbFxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmZpeFRpdGxlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciAkZSA9IHRoaXMuJGVsZW1lbnRcbiAgICBpZiAoJGUuYXR0cigndGl0bGUnKSB8fCB0eXBlb2YgKCRlLmF0dHIoJ2RhdGEtb3JpZ2luYWwtdGl0bGUnKSkgIT0gJ3N0cmluZycpIHtcbiAgICAgICRlLmF0dHIoJ2RhdGEtb3JpZ2luYWwtdGl0bGUnLCAkZS5hdHRyKCd0aXRsZScpIHx8ICcnKS5hdHRyKCd0aXRsZScsICcnKVxuICAgIH1cbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmhhc0NvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VGl0bGUoKVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoJGVsZW1lbnQpIHtcbiAgICAkZWxlbWVudCAgID0gJGVsZW1lbnQgfHwgdGhpcy4kZWxlbWVudFxuXG4gICAgdmFyIGVsICAgICA9ICRlbGVtZW50WzBdXG4gICAgdmFyIGlzQm9keSA9IGVsLnRhZ05hbWUgPT0gJ0JPRFknXG5cbiAgICB2YXIgZWxSZWN0ICAgID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICBpZiAoZWxSZWN0LndpZHRoID09IG51bGwpIHtcbiAgICAgIC8vIHdpZHRoIGFuZCBoZWlnaHQgYXJlIG1pc3NpbmcgaW4gSUU4LCBzbyBjb21wdXRlIHRoZW0gbWFudWFsbHk7IHNlZSBodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvaXNzdWVzLzE0MDkzXG4gICAgICBlbFJlY3QgPSAkLmV4dGVuZCh7fSwgZWxSZWN0LCB7IHdpZHRoOiBlbFJlY3QucmlnaHQgLSBlbFJlY3QubGVmdCwgaGVpZ2h0OiBlbFJlY3QuYm90dG9tIC0gZWxSZWN0LnRvcCB9KVxuICAgIH1cbiAgICB2YXIgZWxPZmZzZXQgID0gaXNCb2R5ID8geyB0b3A6IDAsIGxlZnQ6IDAgfSA6ICRlbGVtZW50Lm9mZnNldCgpXG4gICAgdmFyIHNjcm9sbCAgICA9IHsgc2Nyb2xsOiBpc0JvZHkgPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wIDogJGVsZW1lbnQuc2Nyb2xsVG9wKCkgfVxuICAgIHZhciBvdXRlckRpbXMgPSBpc0JvZHkgPyB7IHdpZHRoOiAkKHdpbmRvdykud2lkdGgoKSwgaGVpZ2h0OiAkKHdpbmRvdykuaGVpZ2h0KCkgfSA6IG51bGxcblxuICAgIHJldHVybiAkLmV4dGVuZCh7fSwgZWxSZWN0LCBzY3JvbGwsIG91dGVyRGltcywgZWxPZmZzZXQpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXRDYWxjdWxhdGVkT2Zmc2V0ID0gZnVuY3Rpb24gKHBsYWNlbWVudCwgcG9zLCBhY3R1YWxXaWR0aCwgYWN0dWFsSGVpZ2h0KSB7XG4gICAgcmV0dXJuIHBsYWNlbWVudCA9PSAnYm90dG9tJyA/IHsgdG9wOiBwb3MudG9wICsgcG9zLmhlaWdodCwgICBsZWZ0OiBwb3MubGVmdCArIHBvcy53aWR0aCAvIDIgLSBhY3R1YWxXaWR0aCAvIDIgfSA6XG4gICAgICAgICAgIHBsYWNlbWVudCA9PSAndG9wJyAgICA/IHsgdG9wOiBwb3MudG9wIC0gYWN0dWFsSGVpZ2h0LCBsZWZ0OiBwb3MubGVmdCArIHBvcy53aWR0aCAvIDIgLSBhY3R1YWxXaWR0aCAvIDIgfSA6XG4gICAgICAgICAgIHBsYWNlbWVudCA9PSAnbGVmdCcgICA/IHsgdG9wOiBwb3MudG9wICsgcG9zLmhlaWdodCAvIDIgLSBhY3R1YWxIZWlnaHQgLyAyLCBsZWZ0OiBwb3MubGVmdCAtIGFjdHVhbFdpZHRoIH0gOlxuICAgICAgICAvKiBwbGFjZW1lbnQgPT0gJ3JpZ2h0JyAqLyB7IHRvcDogcG9zLnRvcCArIHBvcy5oZWlnaHQgLyAyIC0gYWN0dWFsSGVpZ2h0IC8gMiwgbGVmdDogcG9zLmxlZnQgKyBwb3Mud2lkdGggfVxuXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXRWaWV3cG9ydEFkanVzdGVkRGVsdGEgPSBmdW5jdGlvbiAocGxhY2VtZW50LCBwb3MsIGFjdHVhbFdpZHRoLCBhY3R1YWxIZWlnaHQpIHtcbiAgICB2YXIgZGVsdGEgPSB7IHRvcDogMCwgbGVmdDogMCB9XG4gICAgaWYgKCF0aGlzLiR2aWV3cG9ydCkgcmV0dXJuIGRlbHRhXG5cbiAgICB2YXIgdmlld3BvcnRQYWRkaW5nID0gdGhpcy5vcHRpb25zLnZpZXdwb3J0ICYmIHRoaXMub3B0aW9ucy52aWV3cG9ydC5wYWRkaW5nIHx8IDBcbiAgICB2YXIgdmlld3BvcnREaW1lbnNpb25zID0gdGhpcy5nZXRQb3NpdGlvbih0aGlzLiR2aWV3cG9ydClcblxuICAgIGlmICgvcmlnaHR8bGVmdC8udGVzdChwbGFjZW1lbnQpKSB7XG4gICAgICB2YXIgdG9wRWRnZU9mZnNldCAgICA9IHBvcy50b3AgLSB2aWV3cG9ydFBhZGRpbmcgLSB2aWV3cG9ydERpbWVuc2lvbnMuc2Nyb2xsXG4gICAgICB2YXIgYm90dG9tRWRnZU9mZnNldCA9IHBvcy50b3AgKyB2aWV3cG9ydFBhZGRpbmcgLSB2aWV3cG9ydERpbWVuc2lvbnMuc2Nyb2xsICsgYWN0dWFsSGVpZ2h0XG4gICAgICBpZiAodG9wRWRnZU9mZnNldCA8IHZpZXdwb3J0RGltZW5zaW9ucy50b3ApIHsgLy8gdG9wIG92ZXJmbG93XG4gICAgICAgIGRlbHRhLnRvcCA9IHZpZXdwb3J0RGltZW5zaW9ucy50b3AgLSB0b3BFZGdlT2Zmc2V0XG4gICAgICB9IGVsc2UgaWYgKGJvdHRvbUVkZ2VPZmZzZXQgPiB2aWV3cG9ydERpbWVuc2lvbnMudG9wICsgdmlld3BvcnREaW1lbnNpb25zLmhlaWdodCkgeyAvLyBib3R0b20gb3ZlcmZsb3dcbiAgICAgICAgZGVsdGEudG9wID0gdmlld3BvcnREaW1lbnNpb25zLnRvcCArIHZpZXdwb3J0RGltZW5zaW9ucy5oZWlnaHQgLSBib3R0b21FZGdlT2Zmc2V0XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsZWZ0RWRnZU9mZnNldCAgPSBwb3MubGVmdCAtIHZpZXdwb3J0UGFkZGluZ1xuICAgICAgdmFyIHJpZ2h0RWRnZU9mZnNldCA9IHBvcy5sZWZ0ICsgdmlld3BvcnRQYWRkaW5nICsgYWN0dWFsV2lkdGhcbiAgICAgIGlmIChsZWZ0RWRnZU9mZnNldCA8IHZpZXdwb3J0RGltZW5zaW9ucy5sZWZ0KSB7IC8vIGxlZnQgb3ZlcmZsb3dcbiAgICAgICAgZGVsdGEubGVmdCA9IHZpZXdwb3J0RGltZW5zaW9ucy5sZWZ0IC0gbGVmdEVkZ2VPZmZzZXRcbiAgICAgIH0gZWxzZSBpZiAocmlnaHRFZGdlT2Zmc2V0ID4gdmlld3BvcnREaW1lbnNpb25zLndpZHRoKSB7IC8vIHJpZ2h0IG92ZXJmbG93XG4gICAgICAgIGRlbHRhLmxlZnQgPSB2aWV3cG9ydERpbWVuc2lvbnMubGVmdCArIHZpZXdwb3J0RGltZW5zaW9ucy53aWR0aCAtIHJpZ2h0RWRnZU9mZnNldFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkZWx0YVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRpdGxlXG4gICAgdmFyICRlID0gdGhpcy4kZWxlbWVudFxuICAgIHZhciBvICA9IHRoaXMub3B0aW9uc1xuXG4gICAgdGl0bGUgPSAkZS5hdHRyKCdkYXRhLW9yaWdpbmFsLXRpdGxlJylcbiAgICAgIHx8ICh0eXBlb2Ygby50aXRsZSA9PSAnZnVuY3Rpb24nID8gby50aXRsZS5jYWxsKCRlWzBdKSA6ICBvLnRpdGxlKVxuXG4gICAgcmV0dXJuIHRpdGxlXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXRVSUQgPSBmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgZG8gcHJlZml4ICs9IH5+KE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwKVxuICAgIHdoaWxlIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwcmVmaXgpKVxuICAgIHJldHVybiBwcmVmaXhcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLnRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuJHRpcCA9IHRoaXMuJHRpcCB8fCAkKHRoaXMub3B0aW9ucy50ZW1wbGF0ZSkpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5hcnJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuJGFycm93ID0gdGhpcy4kYXJyb3cgfHwgdGhpcy50aXAoKS5maW5kKCcudG9vbHRpcC1hcnJvdycpKVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWVcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbmFibGVkID0gZmFsc2VcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLnRvZ2dsZUVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbmFibGVkID0gIXRoaXMuZW5hYmxlZFxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICBpZiAoZSkge1xuICAgICAgc2VsZiA9ICQoZS5jdXJyZW50VGFyZ2V0KS5kYXRhKCdicy4nICsgdGhpcy50eXBlKVxuICAgICAgaWYgKCFzZWxmKSB7XG4gICAgICAgIHNlbGYgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihlLmN1cnJlbnRUYXJnZXQsIHRoaXMuZ2V0RGVsZWdhdGVPcHRpb25zKCkpXG4gICAgICAgICQoZS5jdXJyZW50VGFyZ2V0KS5kYXRhKCdicy4nICsgdGhpcy50eXBlLCBzZWxmKVxuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGYudGlwKCkuaGFzQ2xhc3MoJ2luJykgPyBzZWxmLmxlYXZlKHNlbGYpIDogc2VsZi5lbnRlcihzZWxmKVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KVxuICAgIHRoaXMuaGlkZShmdW5jdGlvbiAoKSB7XG4gICAgICB0aGF0LiRlbGVtZW50Lm9mZignLicgKyB0aGF0LnR5cGUpLnJlbW92ZURhdGEoJ2JzLicgKyB0aGF0LnR5cGUpXG4gICAgfSlcbiAgfVxuXG5cbiAgLy8gVE9PTFRJUCBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgICA9ICR0aGlzLmRhdGEoJ2JzLnRvb2x0aXAnKVxuICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uID09ICdvYmplY3QnICYmIG9wdGlvblxuXG4gICAgICBpZiAoIWRhdGEgJiYgL2Rlc3Ryb3l8aGlkZS8udGVzdChvcHRpb24pKSByZXR1cm5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMudG9vbHRpcCcsIChkYXRhID0gbmV3IFRvb2x0aXAodGhpcywgb3B0aW9ucykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXSgpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLnRvb2x0aXBcblxuICAkLmZuLnRvb2x0aXAgICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi50b29sdGlwLkNvbnN0cnVjdG9yID0gVG9vbHRpcFxuXG5cbiAgLy8gVE9PTFRJUCBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi50b29sdGlwLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi50b29sdGlwID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG59KGpRdWVyeSk7XG4iLCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogdHJhbnNpdGlvbi5qcyB2My4zLjRcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI3RyYW5zaXRpb25zXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTUgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gQ1NTIFRSQU5TSVRJT04gU1VQUE9SVCAoU2hvdXRvdXQ6IGh0dHA6Ly93d3cubW9kZXJuaXpyLmNvbS8pXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIHRyYW5zaXRpb25FbmQoKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYm9vdHN0cmFwJylcblxuICAgIHZhciB0cmFuc0VuZEV2ZW50TmFtZXMgPSB7XG4gICAgICBXZWJraXRUcmFuc2l0aW9uIDogJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxuICAgICAgTW96VHJhbnNpdGlvbiAgICA6ICd0cmFuc2l0aW9uZW5kJyxcbiAgICAgIE9UcmFuc2l0aW9uICAgICAgOiAnb1RyYW5zaXRpb25FbmQgb3RyYW5zaXRpb25lbmQnLFxuICAgICAgdHJhbnNpdGlvbiAgICAgICA6ICd0cmFuc2l0aW9uZW5kJ1xuICAgIH1cblxuICAgIGZvciAodmFyIG5hbWUgaW4gdHJhbnNFbmRFdmVudE5hbWVzKSB7XG4gICAgICBpZiAoZWwuc3R5bGVbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4geyBlbmQ6IHRyYW5zRW5kRXZlbnROYW1lc1tuYW1lXSB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlIC8vIGV4cGxpY2l0IGZvciBpZTggKCAgLl8uKVxuICB9XG5cbiAgLy8gaHR0cDovL2Jsb2cuYWxleG1hY2Nhdy5jb20vY3NzLXRyYW5zaXRpb25zXG4gICQuZm4uZW11bGF0ZVRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbiAoZHVyYXRpb24pIHtcbiAgICB2YXIgY2FsbGVkID0gZmFsc2VcbiAgICB2YXIgJGVsID0gdGhpc1xuICAgICQodGhpcykub25lKCdic1RyYW5zaXRpb25FbmQnLCBmdW5jdGlvbiAoKSB7IGNhbGxlZCA9IHRydWUgfSlcbiAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7IGlmICghY2FsbGVkKSAkKCRlbCkudHJpZ2dlcigkLnN1cHBvcnQudHJhbnNpdGlvbi5lbmQpIH1cbiAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCBkdXJhdGlvbilcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgJChmdW5jdGlvbiAoKSB7XG4gICAgJC5zdXBwb3J0LnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRW5kKClcblxuICAgIGlmICghJC5zdXBwb3J0LnRyYW5zaXRpb24pIHJldHVyblxuXG4gICAgJC5ldmVudC5zcGVjaWFsLmJzVHJhbnNpdGlvbkVuZCA9IHtcbiAgICAgIGJpbmRUeXBlOiAkLnN1cHBvcnQudHJhbnNpdGlvbi5lbmQsXG4gICAgICBkZWxlZ2F0ZVR5cGU6ICQuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCxcbiAgICAgIGhhbmRsZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCQoZS50YXJnZXQpLmlzKHRoaXMpKSByZXR1cm4gZS5oYW5kbGVPYmouaGFuZGxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG59KGpRdWVyeSk7XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRRdWV1ZTtcbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgICAgICAgY3VycmVudFF1ZXVlW2ldKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xufVxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICBxdWV1ZS5wdXNoKGZ1bik7XG4gICAgaWYgKCFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLy8gaTE4bmV4dCwgdjEuOC4xXG4vLyBDb3B5cmlnaHQgKGMpMjAxNSBKYW4gTcO8aGxlbWFubiAoamFtdWhsKS5cbi8vIERpc3RyaWJ1dGVkIHVuZGVyIE1JVCBsaWNlbnNlXG4vLyBodHRwOi8vaTE4bmV4dC5jb21cbihmdW5jdGlvbihyb290KSB7XG5cbiAgICAvLyBhZGQgaW5kZXhPZiB0byBub24gRUNNQS0yNjIgc3RhbmRhcmQgY29tcGxpYW50IGJyb3dzZXJzXG4gICAgaWYgKCFBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuICAgICAgICBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIChzZWFyY2hFbGVtZW50IC8qLCBmcm9tSW5kZXggKi8gKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGlmICh0aGlzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdCA9IE9iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcbiAgICAgICAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbiA9IDA7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBuID0gTnVtYmVyKGFyZ3VtZW50c1sxXSk7XG4gICAgICAgICAgICAgICAgaWYgKG4gIT0gbikgeyAvLyBzaG9ydGN1dCBmb3IgdmVyaWZ5aW5nIGlmIGl0J3MgTmFOXG4gICAgICAgICAgICAgICAgICAgIG4gPSAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobiAhPSAwICYmIG4gIT0gSW5maW5pdHkgJiYgbiAhPSAtSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgbiA9IChuID4gMCB8fCAtMSkgKiBNYXRoLmZsb29yKE1hdGguYWJzKG4pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobiA+PSBsZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgayA9IG4gPj0gMCA/IG4gOiBNYXRoLm1heChsZW4gLSBNYXRoLmFicyhuKSwgMCk7XG4gICAgICAgICAgICBmb3IgKDsgayA8IGxlbjsgaysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGsgaW4gdCAmJiB0W2tdID09PSBzZWFyY2hFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkZCBsYXN0SW5kZXhPZiB0byBub24gRUNNQS0yNjIgc3RhbmRhcmQgY29tcGxpYW50IGJyb3dzZXJzXG4gICAgaWYgKCFBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YpIHtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24oc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4Ki8pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgaWYgKHRoaXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xuICAgICAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuID0gbGVuO1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgbiA9IE51bWJlcihhcmd1bWVudHNbMV0pO1xuICAgICAgICAgICAgICAgIGlmIChuICE9IG4pIHtcbiAgICAgICAgICAgICAgICAgICAgbiA9IDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuICE9IDAgJiYgbiAhPSAoMSAvIDApICYmIG4gIT0gLSgxIC8gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbiA9IChuID4gMCB8fCAtMSkgKiBNYXRoLmZsb29yKE1hdGguYWJzKG4pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgayA9IG4gPj0gMCA/IE1hdGgubWluKG4sIGxlbiAtIDEpIDogbGVuIC0gTWF0aC5hYnMobik7XG4gICAgICAgICAgICBmb3IgKDsgayA+PSAwOyBrLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoayBpbiB0ICYmIHRba10gPT09IHNlYXJjaEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEFkZCBzdHJpbmcgdHJpbSBmb3IgSUU4LlxuICAgIGlmICh0eXBlb2YgU3RyaW5nLnByb3RvdHlwZS50cmltICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIFN0cmluZy5wcm90b3R5cGUudHJpbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyICQgPSByb290LmpRdWVyeSB8fCByb290LlplcHRvXG4gICAgICAsIGkxOG4gPSB7fVxuICAgICAgLCByZXNTdG9yZSA9IHt9XG4gICAgICAsIGN1cnJlbnRMbmdcbiAgICAgICwgcmVwbGFjZW1lbnRDb3VudGVyID0gMFxuICAgICAgLCBsYW5ndWFnZXMgPSBbXVxuICAgICAgLCBpbml0aWFsaXplZCA9IGZhbHNlXG4gICAgICAsIHN5bmMgPSB7fTtcblxuXG5cbiAgICAvLyBFeHBvcnQgdGhlIGkxOG5leHQgb2JqZWN0IGZvciAqKkNvbW1vbkpTKiouXG4gICAgLy8gSWYgd2UncmUgbm90IGluIENvbW1vbkpTLCBhZGQgYGkxOG5gIHRvIHRoZVxuICAgIC8vIGdsb2JhbCBvYmplY3Qgb3IgdG8ganF1ZXJ5LlxuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGkxOG47XG4gICAgICAgIGlmICghJCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBqdXN0IGlnbm9yZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LmkxOG4gPSByb290LmkxOG4gfHwgaTE4bjtcbiAgICB9XG5cbiAgICBpZiAoJCkge1xuICAgICAgICAkLmkxOG4gPSAkLmkxOG4gfHwgaTE4bjtcbiAgICB9XG4gICAgc3luYyA9IHtcblxuICAgICAgICBsb2FkOiBmdW5jdGlvbihsbmdzLCBvcHRpb25zLCBjYikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMudXNlTG9jYWxTdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgc3luYy5fbG9hZExvY2FsKGxuZ3MsIG9wdGlvbnMsIGZ1bmN0aW9uKGVyciwgc3RvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pc3NpbmdMbmdzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0b3JlW2xuZ3NbaV1dKSBtaXNzaW5nTG5ncy5wdXNoKGxuZ3NbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pc3NpbmdMbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bmMuX2ZldGNoKG1pc3NpbmdMbmdzLCBvcHRpb25zLCBmdW5jdGlvbihlcnIsIGZldGNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLmV4dGVuZChzdG9yZSwgZmV0Y2hlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3luYy5fc3RvcmVMb2NhbChmZXRjaGVkKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiKG51bGwsIHN0b3JlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2IobnVsbCwgc3RvcmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN5bmMuX2ZldGNoKGxuZ3MsIG9wdGlvbnMsIGZ1bmN0aW9uKGVyciwgc3RvcmUpe1xuICAgICAgICAgICAgICAgICAgICBjYihudWxsLCBzdG9yZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2xvYWRMb2NhbDogZnVuY3Rpb24obG5ncywgb3B0aW9ucywgY2IpIHtcbiAgICAgICAgICAgIHZhciBzdG9yZSA9IHt9XG4gICAgICAgICAgICAgICwgbm93TVMgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgICAgICAgICAgaWYod2luZG93LmxvY2FsU3RvcmFnZSkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHRvZG8gPSBsbmdzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGYuZWFjaChsbmdzLCBmdW5jdGlvbihrZXksIGxuZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG9jYWwgPSBmLmxvY2FsU3RvcmFnZS5nZXRJdGVtKCdyZXNfJyArIGxuZyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbCA9IEpTT04ucGFyc2UobG9jYWwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWwuaTE4blN0YW1wICYmIGxvY2FsLmkxOG5TdGFtcCArIG9wdGlvbnMubG9jYWxTdG9yYWdlRXhwaXJhdGlvblRpbWUgPiBub3dNUykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlW2xuZ10gPSBsb2NhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRvZG8tLTsgLy8gd2FpdCBmb3IgYWxsIGRvbmUgYmVmb3IgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvZG8gPT09IDApIGNiKG51bGwsIHN0b3JlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfc3RvcmVMb2NhbDogZnVuY3Rpb24oc3RvcmUpIHtcbiAgICAgICAgICAgIGlmKHdpbmRvdy5sb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBtIGluIHN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlW21dLmkxOG5TdGFtcCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgICAgICBmLmxvY2FsU3RvcmFnZS5zZXRJdGVtKCdyZXNfJyArIG0sIEpTT04uc3RyaW5naWZ5KHN0b3JlW21dKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9mZXRjaDogZnVuY3Rpb24obG5ncywgb3B0aW9ucywgY2IpIHtcbiAgICAgICAgICAgIHZhciBucyA9IG9wdGlvbnMubnNcbiAgICAgICAgICAgICAgLCBzdG9yZSA9IHt9O1xuXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuZHluYW1pY0xvYWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9kbyA9IG5zLm5hbWVzcGFjZXMubGVuZ3RoICogbG5ncy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICwgZXJyb3JzO1xuXG4gICAgICAgICAgICAgICAgLy8gbG9hZCBlYWNoIGZpbGUgaW5kaXZpZHVhbFxuICAgICAgICAgICAgICAgIGYuZWFjaChucy5uYW1lc3BhY2VzLCBmdW5jdGlvbihuc0luZGV4LCBuc1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGYuZWFjaChsbmdzLCBmdW5jdGlvbihsbmdJbmRleCwgbG5nVmFsdWUpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCB0aGlzIG9uY2Ugb3VyIHRyYW5zbGF0aW9uIGhhcyByZXR1cm5lZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsb2FkQ29tcGxldGUgPSBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVbbG5nVmFsdWVdID0gc3RvcmVbbG5nVmFsdWVdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlW2xuZ1ZhbHVlXVtuc1ZhbHVlXSA9IGRhdGE7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2RvLS07IC8vIHdhaXQgZm9yIGFsbCBkb25lIGJlZm9yIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvZG8gPT09IDApIGNiKGVycm9ycywgc3RvcmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIG9wdGlvbnMuY3VzdG9tTG9hZCA9PSAnZnVuY3Rpb24nKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIHNwZWNpZmllZCBjdXN0b20gY2FsbGJhY2suXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5jdXN0b21Mb2FkKGxuZ1ZhbHVlLCBuc1ZhbHVlLCBvcHRpb25zLCBsb2FkQ29tcGxldGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34gLy8gVXNlIG91ciBpbmJ1aWx0IHN5bmMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3luYy5fZmV0Y2hPbmUobG5nVmFsdWUsIG5zVmFsdWUsIG9wdGlvbnMsIGxvYWRDb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDYWxsIHRoaXMgb25jZSBvdXIgdHJhbnNsYXRpb24gaGFzIHJldHVybmVkLlxuICAgICAgICAgICAgICAgIHZhciBsb2FkQ29tcGxldGUgPSBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgY2IobnVsbCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBvcHRpb25zLmN1c3RvbUxvYWQgPT0gJ2Z1bmN0aW9uJyl7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgc3BlY2lmaWVkIGN1c3RvbSBjYWxsYmFjay5cbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5jdXN0b21Mb2FkKGxuZ3MsIG5zLm5hbWVzcGFjZXMsIG9wdGlvbnMsIGxvYWRDb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9IGFwcGx5UmVwbGFjZW1lbnQob3B0aW9ucy5yZXNHZXRQYXRoLCB7IGxuZzogbG5ncy5qb2luKCcrJyksIG5zOiBucy5uYW1lc3BhY2VzLmpvaW4oJysnKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9hZCBhbGwgbmVlZGVkIHN0dWZmIG9uY2VcbiAgICAgICAgICAgICAgICAgICAgZi5hamF4KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oZGF0YSwgc3RhdHVzLCB4aHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLmxvZygnbG9hZGVkOiAnICsgdXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkQ29tcGxldGUobnVsbCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgOiBmdW5jdGlvbih4aHIsIHN0YXR1cywgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLmxvZygnZmFpbGVkIGxvYWRpbmc6ICcgKyB1cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRDb21wbGV0ZSgnZmFpbGVkIGxvYWRpbmcgcmVzb3VyY2UuanNvbiBlcnJvcjogJyArIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogXCJqc29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhc3luYyA6IG9wdGlvbnMuZ2V0QXN5bmNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9mZXRjaE9uZTogZnVuY3Rpb24obG5nLCBucywgb3B0aW9ucywgZG9uZSkge1xuICAgICAgICAgICAgdmFyIHVybCA9IGFwcGx5UmVwbGFjZW1lbnQob3B0aW9ucy5yZXNHZXRQYXRoLCB7IGxuZzogbG5nLCBuczogbnMgfSk7XG4gICAgICAgICAgICBmLmFqYXgoe1xuICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGRhdGEsIHN0YXR1cywgeGhyKSB7XG4gICAgICAgICAgICAgICAgICAgIGYubG9nKCdsb2FkZWQ6ICcgKyB1cmwpO1xuICAgICAgICAgICAgICAgICAgICBkb25lKG51bGwsIGRhdGEpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3IgOiBmdW5jdGlvbih4aHIsIHN0YXR1cywgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChzdGF0dXMgJiYgc3RhdHVzID09IDIwMCkgfHwgKHhociAmJiB4aHIuc3RhdHVzICYmIHhoci5zdGF0dXMgPT0gMjAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmlsZSBsb2FkZWQgYnV0IGludmFsaWQganNvbiwgc3RvcCB3YXN0ZSB0aW1lICFcbiAgICAgICAgICAgICAgICAgICAgICAgIGYuZXJyb3IoJ1RoZXJlIGlzIGEgdHlwbyBpbjogJyArIHVybCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKHN0YXR1cyAmJiBzdGF0dXMgPT0gNDA0KSB8fCAoeGhyICYmIHhoci5zdGF0dXMgJiYgeGhyLnN0YXR1cyA9PSA0MDQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmLmxvZygnRG9lcyBub3QgZXhpc3Q6ICcgKyB1cmwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRoZVN0YXR1cyA9IHN0YXR1cyA/IHN0YXR1cyA6ICgoeGhyICYmIHhoci5zdGF0dXMpID8geGhyLnN0YXR1cyA6IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZi5sb2codGhlU3RhdHVzICsgJyB3aGVuIGxvYWRpbmcgJyArIHVybCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBkb25lKGVycm9yLCB7fSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogXCJqc29uXCIsXG4gICAgICAgICAgICAgICAgYXN5bmMgOiBvcHRpb25zLmdldEFzeW5jXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBwb3N0TWlzc2luZzogZnVuY3Rpb24obG5nLCBucywga2V5LCBkZWZhdWx0VmFsdWUsIGxuZ3MpIHtcbiAgICAgICAgICAgIHZhciBwYXlsb2FkID0ge307XG4gICAgICAgICAgICBwYXlsb2FkW2tleV0gPSBkZWZhdWx0VmFsdWU7XG5cbiAgICAgICAgICAgIHZhciB1cmxzID0gW107XG5cbiAgICAgICAgICAgIGlmIChvLnNlbmRNaXNzaW5nVG8gPT09ICdmYWxsYmFjaycgJiYgby5mYWxsYmFja0xuZ1swXSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG8uZmFsbGJhY2tMbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdXJscy5wdXNoKHtsbmc6IG8uZmFsbGJhY2tMbmdbaV0sIHVybDogYXBwbHlSZXBsYWNlbWVudChvLnJlc1Bvc3RQYXRoLCB7IGxuZzogby5mYWxsYmFja0xuZ1tpXSwgbnM6IG5zIH0pfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChvLnNlbmRNaXNzaW5nVG8gPT09ICdjdXJyZW50JyB8fCAoby5zZW5kTWlzc2luZ1RvID09PSAnZmFsbGJhY2snICYmIG8uZmFsbGJhY2tMbmdbMF0gPT09IGZhbHNlKSApIHtcbiAgICAgICAgICAgICAgICB1cmxzLnB1c2goe2xuZzogbG5nLCB1cmw6IGFwcGx5UmVwbGFjZW1lbnQoby5yZXNQb3N0UGF0aCwgeyBsbmc6IGxuZywgbnM6IG5zIH0pfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG8uc2VuZE1pc3NpbmdUbyA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxuZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHVybHMucHVzaCh7bG5nOiBsbmdzW2ldLCB1cmw6IGFwcGx5UmVwbGFjZW1lbnQoby5yZXNQb3N0UGF0aCwgeyBsbmc6IGxuZ3NbaV0sIG5zOiBucyB9KX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgeSA9IDAsIGxlbiA9IHVybHMubGVuZ3RoOyB5IDwgbGVuOyB5KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHVybHNbeV07XG4gICAgICAgICAgICAgICAgZi5hamF4KHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBpdGVtLnVybCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogby5zZW5kVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogcGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oZGF0YSwgc3RhdHVzLCB4aHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGYubG9nKCdwb3N0ZWQgbWlzc2luZyBrZXkgXFwnJyArIGtleSArICdcXCcgdG86ICcgKyBpdGVtLnVybCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCBrZXkgdG8gcmVzU3RvcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlzID0ga2V5LnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSByZXNTdG9yZVtpdGVtLmxuZ11bbnNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGtleXNbeF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeCA9PT0ga2V5cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVba2V5c1t4XV0gPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVtrZXlzW3hdXSA9IHZhbHVlW2tleXNbeF1dIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVycm9yIDogZnVuY3Rpb24oeGhyLCBzdGF0dXMsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmLmxvZygnZmFpbGVkIHBvc3RpbmcgbWlzc2luZyBrZXkgXFwnJyArIGtleSArICdcXCcgdG86ICcgKyBpdGVtLnVybCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlOiBcImpzb25cIixcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMgOiBvLnBvc3RBc3luY1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlbG9hZDogcmVsb2FkXG4gICAgfTtcbiAgICAvLyBkZWZhdWx0c1xuICAgIHZhciBvID0ge1xuICAgICAgICBsbmc6IHVuZGVmaW5lZCxcbiAgICAgICAgbG9hZDogJ2FsbCcsXG4gICAgICAgIHByZWxvYWQ6IFtdLFxuICAgICAgICBsb3dlckNhc2VMbmc6IGZhbHNlLFxuICAgICAgICByZXR1cm5PYmplY3RUcmVlczogZmFsc2UsXG4gICAgICAgIGZhbGxiYWNrTG5nOiBbJ2RldiddLFxuICAgICAgICBmYWxsYmFja05TOiBbXSxcbiAgICAgICAgZGV0ZWN0TG5nUVM6ICdzZXRMbmcnLFxuICAgICAgICBkZXRlY3RMbmdGcm9tTG9jYWxTdG9yYWdlOiBmYWxzZSxcbiAgICAgICAgbnM6ICd0cmFuc2xhdGlvbicsXG4gICAgICAgIGZhbGxiYWNrT25OdWxsOiB0cnVlLFxuICAgICAgICBmYWxsYmFja09uRW1wdHk6IGZhbHNlLFxuICAgICAgICBmYWxsYmFja1RvRGVmYXVsdE5TOiBmYWxzZSxcbiAgICAgICAgbnNzZXBhcmF0b3I6ICc6JyxcbiAgICAgICAga2V5c2VwYXJhdG9yOiAnLicsXG4gICAgICAgIHNlbGVjdG9yQXR0cjogJ2RhdGEtaTE4bicsXG4gICAgICAgIGRlYnVnOiBmYWxzZSxcblxuICAgICAgICByZXNHZXRQYXRoOiAnbG9jYWxlcy9fX2xuZ19fL19fbnNfXy5qc29uJyxcbiAgICAgICAgcmVzUG9zdFBhdGg6ICdsb2NhbGVzL2FkZC9fX2xuZ19fL19fbnNfXycsXG5cbiAgICAgICAgZ2V0QXN5bmM6IHRydWUsXG4gICAgICAgIHBvc3RBc3luYzogdHJ1ZSxcblxuICAgICAgICByZXNTdG9yZTogdW5kZWZpbmVkLFxuICAgICAgICB1c2VMb2NhbFN0b3JhZ2U6IGZhbHNlLFxuICAgICAgICBsb2NhbFN0b3JhZ2VFeHBpcmF0aW9uVGltZTogNyoyNCo2MCo2MCoxMDAwLFxuXG4gICAgICAgIGR5bmFtaWNMb2FkOiBmYWxzZSxcbiAgICAgICAgc2VuZE1pc3Npbmc6IGZhbHNlLFxuICAgICAgICBzZW5kTWlzc2luZ1RvOiAnZmFsbGJhY2snLCAvLyBjdXJyZW50IHwgYWxsXG4gICAgICAgIHNlbmRUeXBlOiAnUE9TVCcsXG5cbiAgICAgICAgaW50ZXJwb2xhdGlvblByZWZpeDogJ19fJyxcbiAgICAgICAgaW50ZXJwb2xhdGlvblN1ZmZpeDogJ19fJyxcbiAgICAgICAgZGVmYXVsdFZhcmlhYmxlczogZmFsc2UsXG4gICAgICAgIHJldXNlUHJlZml4OiAnJHQoJyxcbiAgICAgICAgcmV1c2VTdWZmaXg6ICcpJyxcbiAgICAgICAgcGx1cmFsU3VmZml4OiAnX3BsdXJhbCcsXG4gICAgICAgIHBsdXJhbE5vdEZvdW5kOiBbJ3BsdXJhbF9ub3RfZm91bmQnLCBNYXRoLnJhbmRvbSgpXS5qb2luKCcnKSxcbiAgICAgICAgY29udGV4dE5vdEZvdW5kOiBbJ2NvbnRleHRfbm90X2ZvdW5kJywgTWF0aC5yYW5kb20oKV0uam9pbignJyksXG4gICAgICAgIGVzY2FwZUludGVycG9sYXRpb246IGZhbHNlLFxuICAgICAgICBpbmRlZmluaXRlU3VmZml4OiAnX2luZGVmaW5pdGUnLFxuICAgICAgICBpbmRlZmluaXRlTm90Rm91bmQ6IFsnaW5kZWZpbml0ZV9ub3RfZm91bmQnLCBNYXRoLnJhbmRvbSgpXS5qb2luKCcnKSxcblxuICAgICAgICBzZXRKcXVlcnlFeHQ6IHRydWUsXG4gICAgICAgIGRlZmF1bHRWYWx1ZUZyb21Db250ZW50OiB0cnVlLFxuICAgICAgICB1c2VEYXRhQXR0ck9wdGlvbnM6IGZhbHNlLFxuICAgICAgICBjb29raWVFeHBpcmF0aW9uVGltZTogdW5kZWZpbmVkLFxuICAgICAgICB1c2VDb29raWU6IHRydWUsXG4gICAgICAgIGNvb2tpZU5hbWU6ICdpMThuZXh0JyxcbiAgICAgICAgY29va2llRG9tYWluOiB1bmRlZmluZWQsXG5cbiAgICAgICAgb2JqZWN0VHJlZUtleUhhbmRsZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgcG9zdFByb2Nlc3M6IHVuZGVmaW5lZCxcbiAgICAgICAgcGFyc2VNaXNzaW5nS2V5OiB1bmRlZmluZWQsXG4gICAgICAgIG1pc3NpbmdLZXlIYW5kbGVyOiBzeW5jLnBvc3RNaXNzaW5nLFxuXG4gICAgICAgIHNob3J0Y3V0RnVuY3Rpb246ICdzcHJpbnRmJyAvLyBvcjogZGVmYXVsdFZhbHVlXG4gICAgfTtcbiAgICBmdW5jdGlvbiBfZXh0ZW5kKHRhcmdldCwgc291cmNlKSB7XG4gICAgICAgIGlmICghc291cmNlIHx8IHR5cGVvZiBzb3VyY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBhdHRyIGluIHNvdXJjZSkgeyB0YXJnZXRbYXR0cl0gPSBzb3VyY2VbYXR0cl07IH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZGVlcEV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSlcbiAgICAgICAgICAgIGlmIChwcm9wIGluIHRhcmdldClcbiAgICAgICAgICAgICAgICBfZGVlcEV4dGVuZCh0YXJnZXRbcHJvcF0sIHNvdXJjZVtwcm9wXSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9lYWNoKG9iamVjdCwgY2FsbGJhY2ssIGFyZ3MpIHtcbiAgICAgICAgdmFyIG5hbWUsIGkgPSAwLFxuICAgICAgICAgICAgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aCxcbiAgICAgICAgICAgIGlzT2JqID0gbGVuZ3RoID09PSB1bmRlZmluZWQgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseShvYmplY3QpICE9PSAnW29iamVjdCBBcnJheV0nIHx8IHR5cGVvZiBvYmplY3QgPT09IFwiZnVuY3Rpb25cIjtcblxuICAgICAgICBpZiAoYXJncykge1xuICAgICAgICAgICAgaWYgKGlzT2JqKSB7XG4gICAgICAgICAgICAgICAgZm9yIChuYW1lIGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2suYXBwbHkob2JqZWN0W25hbWVdLCBhcmdzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBsZW5ndGg7ICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2suYXBwbHkob2JqZWN0W2krK10sIGFyZ3MpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgLy8gQSBzcGVjaWFsLCBmYXN0LCBjYXNlIGZvciB0aGUgbW9zdCBjb21tb24gdXNlIG9mIGVhY2hcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc09iaikge1xuICAgICAgICAgICAgICAgIGZvciAobmFtZSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmNhbGwob2JqZWN0W25hbWVdLCBuYW1lLCBvYmplY3RbbmFtZV0pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IGxlbmd0aDsgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjay5jYWxsKG9iamVjdFtpXSwgaSwgb2JqZWN0W2krK10pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIHZhciBfZW50aXR5TWFwID0ge1xuICAgICAgICBcIiZcIjogXCImYW1wO1wiLFxuICAgICAgICBcIjxcIjogXCImbHQ7XCIsXG4gICAgICAgIFwiPlwiOiBcIiZndDtcIixcbiAgICAgICAgJ1wiJzogJyZxdW90OycsXG4gICAgICAgIFwiJ1wiOiAnJiMzOTsnLFxuICAgICAgICBcIi9cIjogJyYjeDJGOydcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX2VzY2FwZShkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLnJlcGxhY2UoL1smPD5cIidcXC9dL2csIGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9lbnRpdHlNYXBbc107XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9hamF4KG9wdGlvbnMpIHtcblxuICAgICAgICAvLyB2MC41LjAgb2YgaHR0cHM6Ly9naXRodWIuY29tL2dvbG9yb2Rlbi9odHRwLmpzXG4gICAgICAgIHZhciBnZXRYaHIgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgbmF0aXZlIFhIUiBvYmplY3QgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgaXQuXG4gICAgICAgICAgICBpZiAod2luZG93LlhNTEh0dHBSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG5ldyBYTUxIdHRwUmVxdWVzdCgpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAod2luZG93LkFjdGl2ZVhPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBJbnRlcm5ldCBFeHBsb3JlciBjaGVjayBmb3IgQWN0aXZlWCB2ZXJzaW9ucyBvZiB0aGUgWEhSIG9iamVjdC5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbmV3IEFjdGl2ZVhPYmplY3QoXCJNc3htbDIuWE1MSFRUUFwiKSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbmV3IEFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBubyBYSFIgc3VwcG9ydCB3YXMgZm91bmQsIHRocm93IGFuIGVycm9yLlxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcigpKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZW5jb2RlVXNpbmdVcmxFbmNvZGluZyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICBpZih0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yKHZhciBkYXRhSXRlbSBpbiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYoZGF0YS5oYXNPd25Qcm9wZXJ0eShkYXRhSXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGRhdGFJdGVtKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChkYXRhW2RhdGFJdGVtXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcmJyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHV0ZjggPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxyXFxuL2csICdcXG4nKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSAnJztcblxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHRleHQuY2hhckNvZGVBdChpKTtcblxuICAgICAgICAgICAgICAgIGlmKGMgPCAxMjgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZigoYyA+IDEyNykgJiYgKGMgPCAyMDQ4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgPj4gNikgfCAxOTIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgJiA2MykgfCAxMjgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyA+PiAxMikgfCAyMjQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjID4+IDYpICYgNjMpIHwgMTI4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgNjMpIHwgMTI4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGJhc2U2NCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgICAgICB2YXIga2V5U3RyID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89JztcblxuICAgICAgICAgICAgdGV4dCA9IHV0ZjgodGV4dCk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gJycsXG4gICAgICAgICAgICAgICAgICAgIGNocjEsIGNocjIsIGNocjMsXG4gICAgICAgICAgICAgICAgICAgIGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQsXG4gICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgY2hyMSA9IHRleHQuY2hhckNvZGVBdChpKyspO1xuICAgICAgICAgICAgICAgIGNocjIgPSB0ZXh0LmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgICAgICAgICBjaHIzID0gdGV4dC5jaGFyQ29kZUF0KGkrKyk7XG5cbiAgICAgICAgICAgICAgICBlbmMxID0gY2hyMSA+PiAyO1xuICAgICAgICAgICAgICAgIGVuYzIgPSAoKGNocjEgJiAzKSA8PCA0KSB8IChjaHIyID4+IDQpO1xuICAgICAgICAgICAgICAgIGVuYzMgPSAoKGNocjIgJiAxNSkgPDwgMikgfCAoY2hyMyA+PiA2KTtcbiAgICAgICAgICAgICAgICBlbmM0ID0gY2hyMyAmIDYzO1xuXG4gICAgICAgICAgICAgICAgaWYoaXNOYU4oY2hyMikpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5jMyA9IGVuYzQgPSA2NDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoaXNOYU4oY2hyMykpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5jNCA9IDY0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc3VsdCArPVxuICAgICAgICAgICAgICAgICAgICBrZXlTdHIuY2hhckF0KGVuYzEpICtcbiAgICAgICAgICAgICAgICAgICAga2V5U3RyLmNoYXJBdChlbmMyKSArXG4gICAgICAgICAgICAgICAgICAgIGtleVN0ci5jaGFyQXQoZW5jMykgK1xuICAgICAgICAgICAgICAgICAgICBrZXlTdHIuY2hhckF0KGVuYzQpO1xuICAgICAgICAgICAgICAgIGNocjEgPSBjaHIyID0gY2hyMyA9ICcnO1xuICAgICAgICAgICAgICAgIGVuYzEgPSBlbmMyID0gZW5jMyA9IGVuYzQgPSAnJztcbiAgICAgICAgICAgIH0gd2hpbGUoaSA8IHRleHQubGVuZ3RoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbWVyZ2VIZWFkZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBmaXJzdCBoZWFkZXIgb2JqZWN0IGFzIGJhc2UuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gYXJndW1lbnRzWzBdO1xuXG4gICAgICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIHJlbWFpbmluZyBoZWFkZXIgb2JqZWN0cyBhbmQgYWRkIHRoZW0uXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRIZWFkZXJzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaGVhZGVyIGluIGN1cnJlbnRIZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRIZWFkZXJzLmhhc093blByb3BlcnR5KGhlYWRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtoZWFkZXJdID0gY3VycmVudEhlYWRlcnNbaGVhZGVyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBtZXJnZWQgaGVhZGVycy5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGFqYXggPSBmdW5jdGlvbiAobWV0aG9kLCB1cmwsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBBZGp1c3QgcGFyYW1ldGVycy5cbiAgICAgICAgICAgIGlmKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0IGRlZmF1bHQgcGFyYW1ldGVyIHZhbHVlcy5cbiAgICAgICAgICAgIG9wdGlvbnMuY2FjaGUgPSBvcHRpb25zLmNhY2hlIHx8IGZhbHNlO1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gb3B0aW9ucy5kYXRhIHx8IHt9O1xuICAgICAgICAgICAgb3B0aW9ucy5oZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9O1xuICAgICAgICAgICAgb3B0aW9ucy5qc29ucCA9IG9wdGlvbnMuanNvbnAgfHwgZmFsc2U7XG4gICAgICAgICAgICBvcHRpb25zLmFzeW5jID0gb3B0aW9ucy5hc3luYyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMuYXN5bmM7XG5cbiAgICAgICAgICAgIC8vIE1lcmdlIHRoZSB2YXJpb3VzIGhlYWRlciBvYmplY3RzLlxuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSBtZXJnZUhlYWRlcnMoe1xuICAgICAgICAgICAgICAgICdhY2NlcHQnOiAnKi8qJyxcbiAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04J1xuICAgICAgICAgICAgfSwgYWpheC5oZWFkZXJzLCBvcHRpb25zLmhlYWRlcnMpO1xuXG4gICAgICAgICAgICAvLyBFbmNvZGUgdGhlIGRhdGEgYWNjb3JkaW5nIHRvIHRoZSBjb250ZW50LXR5cGUuXG4gICAgICAgICAgICB2YXIgcGF5bG9hZDtcbiAgICAgICAgICAgIGlmIChoZWFkZXJzWydjb250ZW50LXR5cGUnXSA9PT0gJ2FwcGxpY2F0aW9uL2pzb24nKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBheWxvYWQgPSBlbmNvZGVVc2luZ1VybEVuY29kaW5nKG9wdGlvbnMuZGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNwZWNpYWxseSBwcmVwYXJlIEdFVCByZXF1ZXN0czogU2V0dXAgdGhlIHF1ZXJ5IHN0cmluZywgaGFuZGxlIGNhY2hpbmcgYW5kIG1ha2UgYSBKU09OUCBjYWxsXG4gICAgICAgICAgICAvLyBpZiBuZWNjZXNzYXJ5LlxuICAgICAgICAgICAgaWYobWV0aG9kID09PSAnR0VUJykge1xuICAgICAgICAgICAgICAgIC8vIFNldHVwIHRoZSBxdWVyeSBzdHJpbmcuXG4gICAgICAgICAgICAgICAgdmFyIHF1ZXJ5U3RyaW5nID0gW107XG4gICAgICAgICAgICAgICAgaWYocGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeVN0cmluZy5wdXNoKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgY2FjaGluZy5cbiAgICAgICAgICAgICAgICBpZighb3B0aW9ucy5jYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeVN0cmluZy5wdXNoKCdfPScgKyAobmV3IERhdGUoKSkuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBuZWNjZXNzYXJ5IHByZXBhcmUgdGhlIHF1ZXJ5IHN0cmluZyBmb3IgYSBKU09OUCBjYWxsLlxuICAgICAgICAgICAgICAgIGlmKG9wdGlvbnMuanNvbnApIHtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlTdHJpbmcucHVzaCgnY2FsbGJhY2s9JyArIG9wdGlvbnMuanNvbnApO1xuICAgICAgICAgICAgICAgICAgICBxdWVyeVN0cmluZy5wdXNoKCdqc29ucD0nICsgb3B0aW9ucy5qc29ucCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTWVyZ2UgdGhlIHF1ZXJ5IHN0cmluZyBhbmQgYXR0YWNoIGl0IHRvIHRoZSB1cmwuXG4gICAgICAgICAgICAgICAgcXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZy5qb2luKCcmJyk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXJ5U3RyaW5nLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVybC5pbmRleE9mKCc/JykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9ICcmJyArIHF1ZXJ5U3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHF1ZXJ5U3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBhIEpTT05QIGNhbGwgaWYgbmVjY2Vzc2FyeS5cbiAgICAgICAgICAgICAgICBpZihvcHRpb25zLmpzb25wKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICAgICAgICAgICAgICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICAgICAgICAgICAgICAgICAgICBzY3JpcHQuc3JjID0gdXJsO1xuICAgICAgICAgICAgICAgICAgICBoZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNpbmNlIHdlIGdvdCBoZXJlLCBpdCBpcyBubyBKU09OUCByZXF1ZXN0LCBzbyBtYWtlIGEgbm9ybWFsIFhIUiByZXF1ZXN0LlxuICAgICAgICAgICAgZ2V0WGhyKGZ1bmN0aW9uIChlcnIsIHhocikge1xuICAgICAgICAgICAgICAgIGlmKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG5cbiAgICAgICAgICAgICAgICAvLyBPcGVuIHRoZSByZXF1ZXN0LlxuICAgICAgICAgICAgICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsLCBvcHRpb25zLmFzeW5jKTtcblxuICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgcmVxdWVzdCBoZWFkZXJzLlxuICAgICAgICAgICAgICAgIGZvcih2YXIgaGVhZGVyIGluIGhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShoZWFkZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXIsIGhlYWRlcnNbaGVhZGVyXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgdGhlIHJlcXVlc3QgZXZlbnRzLlxuICAgICAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHhoci5yZXNwb25zZVRleHQgfHwgJyc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG5vIGNhbGxiYWNrIGlzIGdpdmVuLCByZXR1cm4uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBhbiBvYmplY3QgdGhhdCBwcm92aWRlcyBhY2Nlc3MgdG8gdGhlIGRhdGEgYXMgdGV4dCBhbmQgSlNPTi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHhoci5zdGF0dXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLmVycm9yKCdDYW4gbm90IHBhcnNlIEpTT04uIFVSTDogJyArIHVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBBY3R1YWxseSBzZW5kIHRoZSBYSFIgcmVxdWVzdC5cbiAgICAgICAgICAgICAgICB4aHIuc2VuZChwYXlsb2FkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIERlZmluZSB0aGUgZXh0ZXJuYWwgaW50ZXJmYWNlLlxuICAgICAgICB2YXIgaHR0cCA9IHtcbiAgICAgICAgICAgIGF1dGhCYXNpYzogZnVuY3Rpb24gKHVzZXJuYW1lLCBwYXNzd29yZCkge1xuICAgICAgICAgICAgICAgIGFqYXguaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gJ0Jhc2ljICcgKyBiYXNlNjQodXNlcm5hbWUgKyAnOicgKyBwYXNzd29yZCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjb25uZWN0OiBmdW5jdGlvbiAodXJsLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhamF4KCdDT05ORUNUJywgdXJsLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBkZWw6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFqYXgoJ0RFTEVURScsIHVybCwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAodXJsLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhamF4KCdHRVQnLCB1cmwsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGhlYWQ6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFqYXgoJ0hFQUQnLCB1cmwsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGhlYWRlcnM6IGZ1bmN0aW9uIChoZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgYWpheC5oZWFkZXJzID0gaGVhZGVycyB8fCB7fTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGlzQWxsb3dlZDogZnVuY3Rpb24gKHVybCwgdmVyYiwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnModXJsLCBmdW5jdGlvbiAoc3RhdHVzLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEudGV4dCgpLmluZGV4T2YodmVyYikgIT09IC0xKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9wdGlvbnM6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFqYXgoJ09QVElPTlMnLCB1cmwsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHBhdGNoOiBmdW5jdGlvbiAodXJsLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhamF4KCdQQVRDSCcsIHVybCwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcG9zdDogZnVuY3Rpb24gKHVybCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWpheCgnUE9TVCcsIHVybCwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcHV0OiBmdW5jdGlvbiAodXJsLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhamF4KCdQVVQnLCB1cmwsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHRyYWNlOiBmdW5jdGlvbiAodXJsLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhamF4KCdUUkFDRScsIHVybCwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG5cbiAgICAgICAgdmFyIG1ldGhvZGUgPSBvcHRpb25zLnR5cGUgPyBvcHRpb25zLnR5cGUudG9Mb3dlckNhc2UoKSA6ICdnZXQnO1xuXG4gICAgICAgIGh0dHBbbWV0aG9kZV0ob3B0aW9ucy51cmwsIG9wdGlvbnMsIGZ1bmN0aW9uIChzdGF0dXMsIGRhdGEpIHtcbiAgICAgICAgICAgIC8vIGZpbGU6IHByb3RvY29sIGFsd2F5cyBnaXZlcyBzdGF0dXMgY29kZSAwLCBzbyBjaGVjayBmb3IgZGF0YVxuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gMjAwIHx8IChzdGF0dXMgPT09IDAgJiYgZGF0YS50ZXh0KCkpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zdWNjZXNzKGRhdGEuanNvbigpLCBzdGF0dXMsIG51bGwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmVycm9yKGRhdGEudGV4dCgpLCBzdGF0dXMsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgX2Nvb2tpZSA9IHtcbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbihuYW1lLHZhbHVlLG1pbnV0ZXMsZG9tYWluKSB7XG4gICAgICAgICAgICB2YXIgZXhwaXJlcztcbiAgICAgICAgICAgIGlmIChtaW51dGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSsobWludXRlcyo2MCoxMDAwKSk7XG4gICAgICAgICAgICAgICAgZXhwaXJlcyA9IFwiOyBleHBpcmVzPVwiK2RhdGUudG9HTVRTdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgZXhwaXJlcyA9IFwiXCI7XG4gICAgICAgICAgICBkb21haW4gPSAoZG9tYWluKT8gXCJkb21haW49XCIrZG9tYWluK1wiO1wiIDogXCJcIjtcbiAgICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IG5hbWUrXCI9XCIrdmFsdWUrZXhwaXJlcytcIjtcIitkb21haW4rXCJwYXRoPS9cIjtcbiAgICAgICAgfSxcblxuICAgICAgICByZWFkOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICB2YXIgbmFtZUVRID0gbmFtZSArIFwiPVwiO1xuICAgICAgICAgICAgdmFyIGNhID0gZG9jdW1lbnQuY29va2llLnNwbGl0KCc7Jyk7XG4gICAgICAgICAgICBmb3IodmFyIGk9MDtpIDwgY2EubGVuZ3RoO2krKykge1xuICAgICAgICAgICAgICAgIHZhciBjID0gY2FbaV07XG4gICAgICAgICAgICAgICAgd2hpbGUgKGMuY2hhckF0KDApPT0nICcpIGMgPSBjLnN1YnN0cmluZygxLGMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAoYy5pbmRleE9mKG5hbWVFUSkgPT09IDApIHJldHVybiBjLnN1YnN0cmluZyhuYW1lRVEubGVuZ3RoLGMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGUobmFtZSxcIlwiLC0xKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgY29va2llX25vb3AgPSB7XG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24obmFtZSx2YWx1ZSxtaW51dGVzLGRvbWFpbikge30sXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG5hbWUpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24obmFtZSkge31cbiAgICB9O1xuXG5cblxuICAgIC8vIG1vdmUgZGVwZW5kZW50IGZ1bmN0aW9ucyB0byBhIGNvbnRhaW5lciBzbyB0aGF0XG4gICAgLy8gdGhleSBjYW4gYmUgb3ZlcnJpZGVuIGVhc2llciBpbiBubyBqcXVlcnkgZW52aXJvbm1lbnQgKG5vZGUuanMpXG4gICAgdmFyIGYgPSB7XG4gICAgICAgIGV4dGVuZDogJCA/ICQuZXh0ZW5kIDogX2V4dGVuZCxcbiAgICAgICAgZGVlcEV4dGVuZDogX2RlZXBFeHRlbmQsXG4gICAgICAgIGVhY2g6ICQgPyAkLmVhY2ggOiBfZWFjaCxcbiAgICAgICAgYWpheDogJCA/ICQuYWpheCA6ICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gX2FqYXggOiBmdW5jdGlvbigpIHt9KSxcbiAgICAgICAgY29va2llOiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gX2Nvb2tpZSA6IGNvb2tpZV9ub29wLFxuICAgICAgICBkZXRlY3RMYW5ndWFnZTogZGV0ZWN0TGFuZ3VhZ2UsXG4gICAgICAgIGVzY2FwZTogX2VzY2FwZSxcbiAgICAgICAgbG9nOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIGlmIChvLmRlYnVnICYmIHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKSBjb25zb2xlLmxvZyhzdHIpO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIpIGNvbnNvbGUuZXJyb3Ioc3RyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Q291bnR5SW5kZXhPZkxuZzogZnVuY3Rpb24obG5nKSB7XG4gICAgICAgICAgICB2YXIgbG5nX2luZGV4ID0gMDtcbiAgICAgICAgICAgIGlmIChsbmcgPT09ICduYi1OTycgfHwgbG5nID09PSAnbm4tTk8nIHx8IGxuZyA9PT0gJ25iLW5vJyB8fCBsbmcgPT09ICdubi1ubycpIGxuZ19pbmRleCA9IDE7XG4gICAgICAgICAgICByZXR1cm4gbG5nX2luZGV4O1xuICAgICAgICB9LFxuICAgICAgICB0b0xhbmd1YWdlczogZnVuY3Rpb24obG5nKSB7XG4gICAgICAgICAgICB2YXIgbG9nID0gdGhpcy5sb2c7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGFwcGx5Q2FzZShsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IGw7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGwgPT09ICdzdHJpbmcnICYmIGwuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gbC5zcGxpdCgnLScpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldCA9IG8ubG93ZXJDYXNlTG5nID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzWzBdLnRvTG93ZXJDYXNlKCkgKyAgJy0nICsgcGFydHNbMV0udG9Mb3dlckNhc2UoKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0c1swXS50b0xvd2VyQ2FzZSgpICsgICctJyArIHBhcnRzWzFdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gby5sb3dlckNhc2VMbmcgPyBsLnRvTG93ZXJDYXNlKCkgOiBsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsYW5ndWFnZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciB3aGl0ZWxpc3QgPSBvLmxuZ1doaXRlbGlzdCB8fCBmYWxzZTtcbiAgICAgICAgICAgIHZhciBhZGRMYW5ndWFnZSA9IGZ1bmN0aW9uKGxhbmd1YWdlKXtcbiAgICAgICAgICAgICAgLy9yZWplY3QgbGFuZ3Mgbm90IHdoaXRlbGlzdGVkXG4gICAgICAgICAgICAgIGlmKCF3aGl0ZWxpc3QgfHwgd2hpdGVsaXN0LmluZGV4T2YobGFuZ3VhZ2UpID4gLTEpe1xuICAgICAgICAgICAgICAgIGxhbmd1YWdlcy5wdXNoKGxhbmd1YWdlKTtcbiAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgbG9nKCdyZWplY3Rpbmcgbm9uLXdoaXRlbGlzdGVkIGxhbmd1YWdlOiAnICsgbGFuZ3VhZ2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsbmcgPT09ICdzdHJpbmcnICYmIGxuZy5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IGxuZy5zcGxpdCgnLScpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG8ubG9hZCAhPT0gJ3Vuc3BlY2lmaWMnKSBhZGRMYW5ndWFnZShhcHBseUNhc2UobG5nKSk7XG4gICAgICAgICAgICAgICAgaWYgKG8ubG9hZCAhPT0gJ2N1cnJlbnQnKSBhZGRMYW5ndWFnZShhcHBseUNhc2UocGFydHNbdGhpcy5nZXRDb3VudHlJbmRleE9mTG5nKGxuZyldKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZExhbmd1YWdlKGFwcGx5Q2FzZShsbmcpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvLmZhbGxiYWNrTG5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhbmd1YWdlcy5pbmRleE9mKG8uZmFsbGJhY2tMbmdbaV0pID09PSAtMSAmJiBvLmZhbGxiYWNrTG5nW2ldKSBsYW5ndWFnZXMucHVzaChhcHBseUNhc2Uoby5mYWxsYmFja0xuZ1tpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxhbmd1YWdlcztcbiAgICAgICAgfSxcbiAgICAgICAgcmVnZXhFc2NhcGU6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bXFwtXFxbXFxdXFwvXFx7XFx9XFwoXFwpXFwqXFwrXFw/XFwuXFxcXFxcXlxcJFxcfF0vZywgXCJcXFxcJCZcIik7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZ2V4UmVwbGFjZW1lbnRFc2NhcGU6IGZ1bmN0aW9uKHN0ck9yRm4pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RyT3JGbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyT3JGbi5yZXBsYWNlKC9cXCQvZywgXCIkJCQkXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyT3JGbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbG9jYWxTdG9yYWdlOiB7XG4gICAgICAgICAgICBzZXRJdGVtOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5sb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZi5sb2coJ2ZhaWxlZCB0byBzZXQgdmFsdWUgZm9yIGtleSBcIicgKyBrZXkgKyAnXCIgdG8gbG9jYWxTdG9yYWdlLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEl0ZW06IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAod2luZG93LmxvY2FsU3RvcmFnZSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZi5sb2coJ2ZhaWxlZCB0byBnZXQgdmFsdWUgZm9yIGtleSBcIicgKyBrZXkgKyAnXCIgZnJvbSBsb2NhbFN0b3JhZ2UuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBpbml0KG9wdGlvbnMsIGNiKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYiA9IG9wdGlvbnM7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgLy8gb3ZlcnJpZGUgZGVmYXVsdHMgd2l0aCBwYXNzZWQgaW4gb3B0aW9uc1xuICAgICAgICBmLmV4dGVuZChvLCBvcHRpb25zKTtcbiAgICAgICAgZGVsZXRlIG8uZml4TG5nOyAvKiBwYXNzZWQgaW4gZWFjaCB0aW1lICovXG5cbiAgICAgICAgLy8gb3ZlcnJpZGUgZnVuY3Rpb25zOiAubG9nKCksIC5kZXRlY3RMYW5ndWFnZSgpLCBldGNcbiAgICAgICAgaWYgKG8uZnVuY3Rpb25zKSB7XG4gICAgICAgICAgICBkZWxldGUgby5mdW5jdGlvbnM7XG4gICAgICAgICAgICBmLmV4dGVuZChmLCBvcHRpb25zLmZ1bmN0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgbmFtZXNwYWNlIG9iamVjdCBpZiBuYW1lc3BhY2UgaXMgcGFzc2VkIGluIGFzIHN0cmluZ1xuICAgICAgICBpZiAodHlwZW9mIG8ubnMgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG8ubnMgPSB7IG5hbWVzcGFjZXM6IFtvLm5zXSwgZGVmYXVsdE5zOiBvLm5zfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZhbGxiYWNrIG5hbWVzcGFjZXNcbiAgICAgICAgaWYgKHR5cGVvZiBvLmZhbGxiYWNrTlMgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG8uZmFsbGJhY2tOUyA9IFtvLmZhbGxiYWNrTlNdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmFsbGJhY2sgbGFuZ3VhZ2VzXG4gICAgICAgIGlmICh0eXBlb2Ygby5mYWxsYmFja0xuZyA9PSAnc3RyaW5nJyB8fCB0eXBlb2Ygby5mYWxsYmFja0xuZyA9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIG8uZmFsbGJhY2tMbmcgPSBbby5mYWxsYmFja0xuZ107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlc2NhcGUgcHJlZml4L3N1ZmZpeFxuICAgICAgICBvLmludGVycG9sYXRpb25QcmVmaXhFc2NhcGVkID0gZi5yZWdleEVzY2FwZShvLmludGVycG9sYXRpb25QcmVmaXgpO1xuICAgICAgICBvLmludGVycG9sYXRpb25TdWZmaXhFc2NhcGVkID0gZi5yZWdleEVzY2FwZShvLmludGVycG9sYXRpb25TdWZmaXgpO1xuXG4gICAgICAgIGlmICghby5sbmcpIG8ubG5nID0gZi5kZXRlY3RMYW5ndWFnZSgpO1xuXG4gICAgICAgIGxhbmd1YWdlcyA9IGYudG9MYW5ndWFnZXMoby5sbmcpO1xuICAgICAgICBjdXJyZW50TG5nID0gbGFuZ3VhZ2VzWzBdO1xuICAgICAgICBmLmxvZygnY3VycmVudExuZyBzZXQgdG86ICcgKyBjdXJyZW50TG5nKTtcblxuICAgICAgICBpZiAoby51c2VDb29raWUgJiYgZi5jb29raWUucmVhZChvLmNvb2tpZU5hbWUpICE9PSBjdXJyZW50TG5nKXsgLy9jb29raWUgaXMgdW5zZXQgb3IgaW52YWxpZFxuICAgICAgICAgICAgZi5jb29raWUuY3JlYXRlKG8uY29va2llTmFtZSwgY3VycmVudExuZywgby5jb29raWVFeHBpcmF0aW9uVGltZSwgby5jb29raWVEb21haW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvLmRldGVjdExuZ0Zyb21Mb2NhbFN0b3JhZ2UgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubG9jYWxTdG9yYWdlKSB7XG4gICAgICAgICAgICBmLmxvY2FsU3RvcmFnZS5zZXRJdGVtKCdpMThuZXh0X2xuZycsIGN1cnJlbnRMbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxuZ1RyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZml4TG5nKSB7XG4gICAgICAgICAgICBsbmdUcmFuc2xhdGUgPSBmdW5jdGlvbihrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmxuZyA9IG9wdGlvbnMubG5nIHx8IGxuZ1RyYW5zbGF0ZS5sbmc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zbGF0ZShrZXksIG9wdGlvbnMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxuZ1RyYW5zbGF0ZS5sbmcgPSBjdXJyZW50TG5nO1xuICAgICAgICB9XG5cbiAgICAgICAgcGx1cmFsRXh0ZW5zaW9ucy5zZXRDdXJyZW50TG5nKGN1cnJlbnRMbmcpO1xuXG4gICAgICAgIC8vIGFkZCBKUXVlcnkgZXh0ZW5zaW9uc1xuICAgICAgICBpZiAoJCAmJiBvLnNldEpxdWVyeUV4dCkgYWRkSnF1ZXJ5RnVuY3QoKTtcblxuICAgICAgICAvLyBqUXVlcnkgZGVmZXJyZWRcbiAgICAgICAgdmFyIGRlZmVycmVkO1xuICAgICAgICBpZiAoJCAmJiAkLkRlZmVycmVkKSB7XG4gICAgICAgICAgICBkZWZlcnJlZCA9ICQuRGVmZXJyZWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJldHVybiBpbW1pZGlhdGx5IGlmIHJlcyBhcmUgcGFzc2VkIGluXG4gICAgICAgIGlmIChvLnJlc1N0b3JlKSB7XG4gICAgICAgICAgICByZXNTdG9yZSA9IG8ucmVzU3RvcmU7XG4gICAgICAgICAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoY2IpIGNiKGxuZ1RyYW5zbGF0ZSk7XG4gICAgICAgICAgICBpZiAoZGVmZXJyZWQpIGRlZmVycmVkLnJlc29sdmUobG5nVHJhbnNsYXRlKTtcbiAgICAgICAgICAgIGlmIChkZWZlcnJlZCkgcmV0dXJuIGRlZmVycmVkLnByb21pc2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxhbmd1YWdlcyB0byBsb2FkXG4gICAgICAgIHZhciBsbmdzVG9Mb2FkID0gZi50b0xhbmd1YWdlcyhvLmxuZyk7XG4gICAgICAgIGlmICh0eXBlb2Ygby5wcmVsb2FkID09PSAnc3RyaW5nJykgby5wcmVsb2FkID0gW28ucHJlbG9hZF07XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gby5wcmVsb2FkLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIHByZXMgPSBmLnRvTGFuZ3VhZ2VzKG8ucHJlbG9hZFtpXSk7XG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gMCwgbGVuID0gcHJlcy5sZW5ndGg7IHkgPCBsZW47IHkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsbmdzVG9Mb2FkLmluZGV4T2YocHJlc1t5XSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxuZ3NUb0xvYWQucHVzaChwcmVzW3ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbHNlIGxvYWQgdGhlbVxuICAgICAgICBpMThuLnN5bmMubG9hZChsbmdzVG9Mb2FkLCBvLCBmdW5jdGlvbihlcnIsIHN0b3JlKSB7XG4gICAgICAgICAgICByZXNTdG9yZSA9IHN0b3JlO1xuICAgICAgICAgICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoY2IpIGNiKGxuZ1RyYW5zbGF0ZSk7XG4gICAgICAgICAgICBpZiAoZGVmZXJyZWQpIGRlZmVycmVkLnJlc29sdmUobG5nVHJhbnNsYXRlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGRlZmVycmVkKSByZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVsb2FkKGxuZ3MsIGNiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbG5ncyA9PT0gJ3N0cmluZycpIGxuZ3MgPSBbbG5nc107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbG5ncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChvLnByZWxvYWQuaW5kZXhPZihsbmdzW2ldKSA8IDApIHtcbiAgICAgICAgICAgICAgICBvLnByZWxvYWQucHVzaChsbmdzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5pdChjYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkUmVzb3VyY2VCdW5kbGUobG5nLCBucywgcmVzb3VyY2VzLCBkZWVwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbnMgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXNvdXJjZXMgPSBucztcbiAgICAgICAgICAgIG5zID0gby5ucy5kZWZhdWx0TnM7XG4gICAgICAgIH0gZWxzZSBpZiAoby5ucy5uYW1lc3BhY2VzLmluZGV4T2YobnMpIDwgMCkge1xuICAgICAgICAgICAgby5ucy5uYW1lc3BhY2VzLnB1c2gobnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzU3RvcmVbbG5nXSA9IHJlc1N0b3JlW2xuZ10gfHwge307XG4gICAgICAgIHJlc1N0b3JlW2xuZ11bbnNdID0gcmVzU3RvcmVbbG5nXVtuc10gfHwge307XG5cbiAgICAgICAgaWYgKGRlZXApIHtcbiAgICAgICAgICAgIGYuZGVlcEV4dGVuZChyZXNTdG9yZVtsbmddW25zXSwgcmVzb3VyY2VzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGYuZXh0ZW5kKHJlc1N0b3JlW2xuZ11bbnNdLCByZXNvdXJjZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvLnVzZUxvY2FsU3RvcmFnZSkge1xuICAgICAgICAgICAgc3luYy5fc3RvcmVMb2NhbChyZXNTdG9yZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNSZXNvdXJjZUJ1bmRsZShsbmcsIG5zKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbnMgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBucyA9IG8ubnMuZGVmYXVsdE5zO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzU3RvcmVbbG5nXSA9IHJlc1N0b3JlW2xuZ10gfHwge307XG4gICAgICAgIHZhciByZXMgPSByZXNTdG9yZVtsbmddW25zXSB8fCB7fTtcblxuICAgICAgICB2YXIgaGFzVmFsdWVzID0gZmFsc2U7XG4gICAgICAgIGZvcih2YXIgcHJvcCBpbiByZXMpIHtcbiAgICAgICAgICAgIGlmIChyZXMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICBoYXNWYWx1ZXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhhc1ZhbHVlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRSZXNvdXJjZUJ1bmRsZShsbmcsIG5zKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbnMgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBucyA9IG8ubnMuZGVmYXVsdE5zO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzU3RvcmVbbG5nXSA9IHJlc1N0b3JlW2xuZ10gfHwge307XG4gICAgICAgIHJldHVybiBmLmV4dGVuZCh7fSwgcmVzU3RvcmVbbG5nXVtuc10pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZVJlc291cmNlQnVuZGxlKGxuZywgbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBucyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG5zID0gby5ucy5kZWZhdWx0TnM7XG4gICAgICAgIH1cblxuICAgICAgICByZXNTdG9yZVtsbmddID0gcmVzU3RvcmVbbG5nXSB8fCB7fTtcbiAgICAgICAgcmVzU3RvcmVbbG5nXVtuc10gPSB7fTtcbiAgICAgICAgaWYgKG8udXNlTG9jYWxTdG9yYWdlKSB7XG4gICAgICAgICAgICBzeW5jLl9zdG9yZUxvY2FsKHJlc1N0b3JlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFJlc291cmNlKGxuZywgbnMsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBucyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJlc291cmNlID0gbnM7XG4gICAgICAgICAgICBucyA9IG8ubnMuZGVmYXVsdE5zO1xuICAgICAgICB9IGVsc2UgaWYgKG8ubnMubmFtZXNwYWNlcy5pbmRleE9mKG5zKSA8IDApIHtcbiAgICAgICAgICAgIG8ubnMubmFtZXNwYWNlcy5wdXNoKG5zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc1N0b3JlW2xuZ10gPSByZXNTdG9yZVtsbmddIHx8IHt9O1xuICAgICAgICByZXNTdG9yZVtsbmddW25zXSA9IHJlc1N0b3JlW2xuZ11bbnNdIHx8IHt9O1xuXG4gICAgICAgIHZhciBrZXlzID0ga2V5LnNwbGl0KG8ua2V5c2VwYXJhdG9yKTtcbiAgICAgICAgdmFyIHggPSAwO1xuICAgICAgICB2YXIgbm9kZSA9IHJlc1N0b3JlW2xuZ11bbnNdO1xuICAgICAgICB2YXIgb3JpZ1JlZiA9IG5vZGU7XG5cbiAgICAgICAgd2hpbGUgKGtleXNbeF0pIHtcbiAgICAgICAgICAgIGlmICh4ID09IGtleXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICBub2RlW2tleXNbeF1dID0gdmFsdWU7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZVtrZXlzW3hdXSA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBub2RlW2tleXNbeF1dID0ge307XG5cbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZVtrZXlzW3hdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHgrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoby51c2VMb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgICAgIHN5bmMuX3N0b3JlTG9jYWwocmVzU3RvcmUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkUmVzb3VyY2VzKGxuZywgbnMsIHJlc291cmNlcykge1xuICAgICAgICBpZiAodHlwZW9mIG5zICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmVzb3VyY2UgPSBucztcbiAgICAgICAgICAgIG5zID0gby5ucy5kZWZhdWx0TnM7XG4gICAgICAgIH0gZWxzZSBpZiAoby5ucy5uYW1lc3BhY2VzLmluZGV4T2YobnMpIDwgMCkge1xuICAgICAgICAgICAgby5ucy5uYW1lc3BhY2VzLnB1c2gobnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgbSBpbiByZXNvdXJjZXMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzb3VyY2VzW21dID09PSAnc3RyaW5nJykgYWRkUmVzb3VyY2UobG5nLCBucywgbSwgcmVzb3VyY2VzW21dKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldERlZmF1bHROYW1lc3BhY2UobnMpIHtcbiAgICAgICAgby5ucy5kZWZhdWx0TnMgPSBucztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkTmFtZXNwYWNlKG5hbWVzcGFjZSwgY2IpIHtcbiAgICAgICAgbG9hZE5hbWVzcGFjZXMoW25hbWVzcGFjZV0sIGNiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkTmFtZXNwYWNlcyhuYW1lc3BhY2VzLCBjYikge1xuICAgICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgICAgIGR5bmFtaWNMb2FkOiBvLmR5bmFtaWNMb2FkLFxuICAgICAgICAgICAgcmVzR2V0UGF0aDogby5yZXNHZXRQYXRoLFxuICAgICAgICAgICAgZ2V0QXN5bmM6IG8uZ2V0QXN5bmMsXG4gICAgICAgICAgICBjdXN0b21Mb2FkOiBvLmN1c3RvbUxvYWQsXG4gICAgICAgICAgICBuczogeyBuYW1lc3BhY2VzOiBuYW1lc3BhY2VzLCBkZWZhdWx0TnM6ICcnfSAvKiBuZXcgbmFtZXNwYWNlcyB0byBsb2FkICovXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gbGFuZ3VhZ2VzIHRvIGxvYWRcbiAgICAgICAgdmFyIGxuZ3NUb0xvYWQgPSBmLnRvTGFuZ3VhZ2VzKG8ubG5nKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvLnByZWxvYWQgPT09ICdzdHJpbmcnKSBvLnByZWxvYWQgPSBbby5wcmVsb2FkXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvLnByZWxvYWQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcHJlcyA9IGYudG9MYW5ndWFnZXMoby5wcmVsb2FkW2ldKTtcbiAgICAgICAgICAgIGZvciAodmFyIHkgPSAwLCBsZW4gPSBwcmVzLmxlbmd0aDsgeSA8IGxlbjsgeSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxuZ3NUb0xvYWQuaW5kZXhPZihwcmVzW3ldKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbG5nc1RvTG9hZC5wdXNoKHByZXNbeV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIGhhdmUgdG8gbG9hZFxuICAgICAgICB2YXIgbG5nTmVlZExvYWQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgYSA9IDAsIGxlbkEgPSBsbmdzVG9Mb2FkLmxlbmd0aDsgYSA8IGxlbkE7IGErKykge1xuICAgICAgICAgICAgdmFyIG5lZWRMb2FkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgcmVzU2V0ID0gcmVzU3RvcmVbbG5nc1RvTG9hZFthXV07XG4gICAgICAgICAgICBpZiAocmVzU2V0KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYiA9IDAsIGxlbkIgPSBuYW1lc3BhY2VzLmxlbmd0aDsgYiA8IGxlbkI7IGIrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc1NldFtuYW1lc3BhY2VzW2JdXSkgbmVlZExvYWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmVlZExvYWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmVlZExvYWQpIGxuZ05lZWRMb2FkLnB1c2gobG5nc1RvTG9hZFthXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG5nTmVlZExvYWQubGVuZ3RoKSB7XG4gICAgICAgICAgICBpMThuLnN5bmMuX2ZldGNoKGxuZ05lZWRMb2FkLCBvcHRzLCBmdW5jdGlvbihlcnIsIHN0b3JlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvZG8gPSBuYW1lc3BhY2VzLmxlbmd0aCAqIGxuZ05lZWRMb2FkLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIC8vIGxvYWQgZWFjaCBmaWxlIGluZGl2aWR1YWxcbiAgICAgICAgICAgICAgICBmLmVhY2gobmFtZXNwYWNlcywgZnVuY3Rpb24obnNJbmRleCwgbnNWYWx1ZSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFwcGVuZCBuYW1lc3BhY2UgdG8gbmFtZXNwYWNlIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIGlmIChvLm5zLm5hbWVzcGFjZXMuaW5kZXhPZihuc1ZhbHVlKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG8ubnMubmFtZXNwYWNlcy5wdXNoKG5zVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZi5lYWNoKGxuZ05lZWRMb2FkLCBmdW5jdGlvbihsbmdJbmRleCwgbG5nVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc1N0b3JlW2xuZ1ZhbHVlXSA9IHJlc1N0b3JlW2xuZ1ZhbHVlXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc1N0b3JlW2xuZ1ZhbHVlXVtuc1ZhbHVlXSA9IHN0b3JlW2xuZ1ZhbHVlXVtuc1ZhbHVlXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdG9kby0tOyAvLyB3YWl0IGZvciBhbGwgZG9uZSBiZWZvciBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvZG8gPT09IDAgJiYgY2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoby51c2VMb2NhbFN0b3JhZ2UpIGkxOG4uc3luYy5fc3RvcmVMb2NhbChyZXNTdG9yZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjYikgY2IoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldExuZyhsbmcsIG9wdGlvbnMsIGNiKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2IgPSBvcHRpb25zO1xuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICB9IGVsc2UgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zLmxuZyA9IGxuZztcbiAgICAgICAgcmV0dXJuIGluaXQob3B0aW9ucywgY2IpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxuZygpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRMbmc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVsb2FkKGNiKSB7XG4gICAgICAgIHJlc1N0b3JlID0ge307XG4gICAgICAgIHNldExuZyhjdXJyZW50TG5nLCBjYik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZEpxdWVyeUZ1bmN0KCkge1xuICAgICAgICAvLyAkLnQgc2hvcnRjdXRcbiAgICAgICAgJC50ID0gJC50IHx8IHRyYW5zbGF0ZTtcblxuICAgICAgICBmdW5jdGlvbiBwYXJzZShlbGUsIGtleSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKGtleS5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgICAgICAgICAgdmFyIGF0dHIgPSAndGV4dCc7XG5cbiAgICAgICAgICAgIGlmIChrZXkuaW5kZXhPZignWycpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnRzID0ga2V5LnNwbGl0KCddJyk7XG4gICAgICAgICAgICAgICAga2V5ID0gcGFydHNbMV07XG4gICAgICAgICAgICAgICAgYXR0ciA9IHBhcnRzWzBdLnN1YnN0cigxLCBwYXJ0c1swXS5sZW5ndGgtMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChrZXkuaW5kZXhPZignOycpID09PSBrZXkubGVuZ3RoLTEpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBrZXkuc3Vic3RyKDAsIGtleS5sZW5ndGgtMik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvcHRpb25zVG9Vc2U7XG4gICAgICAgICAgICBpZiAoYXR0ciA9PT0gJ2h0bWwnKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1RvVXNlID0gby5kZWZhdWx0VmFsdWVGcm9tQ29udGVudCA/ICQuZXh0ZW5kKHsgZGVmYXVsdFZhbHVlOiBlbGUuaHRtbCgpIH0sIG9wdGlvbnMpIDogb3B0aW9ucztcbiAgICAgICAgICAgICAgICBlbGUuaHRtbCgkLnQoa2V5LCBvcHRpb25zVG9Vc2UpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXR0ciA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1RvVXNlID0gby5kZWZhdWx0VmFsdWVGcm9tQ29udGVudCA/ICQuZXh0ZW5kKHsgZGVmYXVsdFZhbHVlOiBlbGUudGV4dCgpIH0sIG9wdGlvbnMpIDogb3B0aW9ucztcbiAgICAgICAgICAgICAgICBlbGUudGV4dCgkLnQoa2V5LCBvcHRpb25zVG9Vc2UpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXR0ciA9PT0gJ3ByZXBlbmQnKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1RvVXNlID0gby5kZWZhdWx0VmFsdWVGcm9tQ29udGVudCA/ICQuZXh0ZW5kKHsgZGVmYXVsdFZhbHVlOiBlbGUuaHRtbCgpIH0sIG9wdGlvbnMpIDogb3B0aW9ucztcbiAgICAgICAgICAgICAgICBlbGUucHJlcGVuZCgkLnQoa2V5LCBvcHRpb25zVG9Vc2UpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXR0ciA9PT0gJ2FwcGVuZCcpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zVG9Vc2UgPSBvLmRlZmF1bHRWYWx1ZUZyb21Db250ZW50ID8gJC5leHRlbmQoeyBkZWZhdWx0VmFsdWU6IGVsZS5odG1sKCkgfSwgb3B0aW9ucykgOiBvcHRpb25zO1xuICAgICAgICAgICAgICAgIGVsZS5hcHBlbmQoJC50KGtleSwgb3B0aW9uc1RvVXNlKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGF0dHIuaW5kZXhPZihcImRhdGEtXCIpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFBdHRyID0gYXR0ci5zdWJzdHIoKFwiZGF0YS1cIikubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zVG9Vc2UgPSBvLmRlZmF1bHRWYWx1ZUZyb21Db250ZW50ID8gJC5leHRlbmQoeyBkZWZhdWx0VmFsdWU6IGVsZS5kYXRhKGRhdGFBdHRyKSB9LCBvcHRpb25zKSA6IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zbGF0ZWQgPSAkLnQoa2V5LCBvcHRpb25zVG9Vc2UpO1xuICAgICAgICAgICAgICAgIC8vd2UgY2hhbmdlIGludG8gdGhlIGRhdGEgY2FjaGVcbiAgICAgICAgICAgICAgICBlbGUuZGF0YShkYXRhQXR0ciwgdHJhbnNsYXRlZCk7XG4gICAgICAgICAgICAgICAgLy93ZSBjaGFuZ2UgaW50byB0aGUgZG9tXG4gICAgICAgICAgICAgICAgZWxlLmF0dHIoYXR0ciwgdHJhbnNsYXRlZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbnNUb1VzZSA9IG8uZGVmYXVsdFZhbHVlRnJvbUNvbnRlbnQgPyAkLmV4dGVuZCh7IGRlZmF1bHRWYWx1ZTogZWxlLmF0dHIoYXR0cikgfSwgb3B0aW9ucykgOiBvcHRpb25zO1xuICAgICAgICAgICAgICAgIGVsZS5hdHRyKGF0dHIsICQudChrZXksIG9wdGlvbnNUb1VzZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbG9jYWxpemUoZWxlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gZWxlLmF0dHIoby5zZWxlY3RvckF0dHIpO1xuICAgICAgICAgICAgaWYgKCFrZXkgJiYgdHlwZW9mIGtleSAhPT0gJ3VuZGVmaW5lZCcgJiYga2V5ICE9PSBmYWxzZSkga2V5ID0gZWxlLnRleHQoKSB8fCBlbGUudmFsKCk7XG4gICAgICAgICAgICBpZiAoIWtleSkgcmV0dXJuO1xuXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZWxlXG4gICAgICAgICAgICAgICwgdGFyZ2V0U2VsZWN0b3IgPSBlbGUuZGF0YShcImkxOG4tdGFyZ2V0XCIpO1xuICAgICAgICAgICAgaWYgKHRhcmdldFNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gZWxlLmZpbmQodGFyZ2V0U2VsZWN0b3IpIHx8IGVsZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFvcHRpb25zICYmIG8udXNlRGF0YUF0dHJPcHRpb25zID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IGVsZS5kYXRhKFwiaTE4bi1vcHRpb25zXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgICAgIGlmIChrZXkuaW5kZXhPZignOycpID49IDApIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IGtleS5zcGxpdCgnOycpO1xuXG4gICAgICAgICAgICAgICAgJC5lYWNoKGtleXMsIGZ1bmN0aW9uKG0sIGspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGsgIT09ICcnKSBwYXJzZSh0YXJnZXQsIGssIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnNlKHRhcmdldCwga2V5LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG8udXNlRGF0YUF0dHJPcHRpb25zID09PSB0cnVlKSBlbGUuZGF0YShcImkxOG4tb3B0aW9uc1wiLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZuXG4gICAgICAgICQuZm4uaTE4biA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIGxvY2FsaXplIGVsZW1lbnQgaXRzZWxmXG4gICAgICAgICAgICAgICAgbG9jYWxpemUoJCh0aGlzKSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICAvLyBsb2NhbGl6ZSBjaGlsZHNcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudHMgPSAgJCh0aGlzKS5maW5kKCdbJyArIG8uc2VsZWN0b3JBdHRyICsgJ10nKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50cy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGl6ZSgkKHRoaXMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcHBseVJlcGxhY2VtZW50KHN0ciwgcmVwbGFjZW1lbnRIYXNoLCBuZXN0ZWRLZXksIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFzdHIpIHJldHVybiBzdHI7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgcmVwbGFjZW1lbnRIYXNoOyAvLyBmaXJzdCBjYWxsIHVzZXMgcmVwbGFjZW1lbnQgaGFzaCBjb21iaW5lZCB3aXRoIG9wdGlvbnNcbiAgICAgICAgaWYgKHN0ci5pbmRleE9mKG9wdGlvbnMuaW50ZXJwb2xhdGlvblByZWZpeCB8fCBvLmludGVycG9sYXRpb25QcmVmaXgpIDwgMCkgcmV0dXJuIHN0cjtcblxuICAgICAgICB2YXIgcHJlZml4ID0gb3B0aW9ucy5pbnRlcnBvbGF0aW9uUHJlZml4ID8gZi5yZWdleEVzY2FwZShvcHRpb25zLmludGVycG9sYXRpb25QcmVmaXgpIDogby5pbnRlcnBvbGF0aW9uUHJlZml4RXNjYXBlZFxuICAgICAgICAgICwgc3VmZml4ID0gb3B0aW9ucy5pbnRlcnBvbGF0aW9uU3VmZml4ID8gZi5yZWdleEVzY2FwZShvcHRpb25zLmludGVycG9sYXRpb25TdWZmaXgpIDogby5pbnRlcnBvbGF0aW9uU3VmZml4RXNjYXBlZFxuICAgICAgICAgICwgdW5Fc2NhcGluZ1N1ZmZpeCA9ICdIVE1MJytzdWZmaXg7XG5cbiAgICAgICAgdmFyIGhhc2ggPSByZXBsYWNlbWVudEhhc2gucmVwbGFjZSAmJiB0eXBlb2YgcmVwbGFjZW1lbnRIYXNoLnJlcGxhY2UgPT09ICdvYmplY3QnID8gcmVwbGFjZW1lbnRIYXNoLnJlcGxhY2UgOiByZXBsYWNlbWVudEhhc2g7XG4gICAgICAgIGYuZWFjaChoYXNoLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgbmV4dEtleSA9IG5lc3RlZEtleSA/IG5lc3RlZEtleSArIG8ua2V5c2VwYXJhdG9yICsga2V5IDoga2V5O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSBhcHBseVJlcGxhY2VtZW50KHN0ciwgdmFsdWUsIG5leHRLZXksIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5lc2NhcGVJbnRlcnBvbGF0aW9uIHx8IG8uZXNjYXBlSW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShuZXcgUmVnRXhwKFtwcmVmaXgsIG5leHRLZXksIHVuRXNjYXBpbmdTdWZmaXhdLmpvaW4oJycpLCAnZycpLCBmLnJlZ2V4UmVwbGFjZW1lbnRFc2NhcGUodmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cChbcHJlZml4LCBuZXh0S2V5LCBzdWZmaXhdLmpvaW4oJycpLCAnZycpLCBmLnJlZ2V4UmVwbGFjZW1lbnRFc2NhcGUoZi5lc2NhcGUodmFsdWUpKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cChbcHJlZml4LCBuZXh0S2V5LCBzdWZmaXhdLmpvaW4oJycpLCAnZycpLCBmLnJlZ2V4UmVwbGFjZW1lbnRFc2NhcGUodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gc3RyID0gb3B0aW9ucy5lc2NhcGVJbnRlcnBvbGF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICAvLyBhcHBlbmQgaXQgdG8gZnVuY3Rpb25zXG4gICAgZi5hcHBseVJlcGxhY2VtZW50ID0gYXBwbHlSZXBsYWNlbWVudDtcblxuICAgIGZ1bmN0aW9uIGFwcGx5UmV1c2UodHJhbnNsYXRlZCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgY29tbWEgPSAnLCc7XG4gICAgICAgIHZhciBvcHRpb25zX29wZW4gPSAneyc7XG4gICAgICAgIHZhciBvcHRpb25zX2Nsb3NlID0gJ30nO1xuXG4gICAgICAgIHZhciBvcHRzID0gZi5leHRlbmQoe30sIG9wdGlvbnMpO1xuICAgICAgICBkZWxldGUgb3B0cy5wb3N0UHJvY2VzcztcblxuICAgICAgICB3aGlsZSAodHJhbnNsYXRlZC5pbmRleE9mKG8ucmV1c2VQcmVmaXgpICE9IC0xKSB7XG4gICAgICAgICAgICByZXBsYWNlbWVudENvdW50ZXIrKztcbiAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudENvdW50ZXIgPiBvLm1heFJlY3Vyc2lvbikgeyBicmVhazsgfSAvLyBzYWZldHkgbmV0IGZvciB0b28gbXVjaCByZWN1cnNpb25cbiAgICAgICAgICAgIHZhciBpbmRleF9vZl9vcGVuaW5nID0gdHJhbnNsYXRlZC5sYXN0SW5kZXhPZihvLnJldXNlUHJlZml4KTtcbiAgICAgICAgICAgIHZhciBpbmRleF9vZl9lbmRfb2ZfY2xvc2luZyA9IHRyYW5zbGF0ZWQuaW5kZXhPZihvLnJldXNlU3VmZml4LCBpbmRleF9vZl9vcGVuaW5nKSArIG8ucmV1c2VTdWZmaXgubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHRva2VuID0gdHJhbnNsYXRlZC5zdWJzdHJpbmcoaW5kZXhfb2Zfb3BlbmluZywgaW5kZXhfb2ZfZW5kX29mX2Nsb3NpbmcpO1xuICAgICAgICAgICAgdmFyIHRva2VuX3dpdGhvdXRfc3ltYm9scyA9IHRva2VuLnJlcGxhY2Uoby5yZXVzZVByZWZpeCwgJycpLnJlcGxhY2Uoby5yZXVzZVN1ZmZpeCwgJycpO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXhfb2ZfZW5kX29mX2Nsb3NpbmcgPD0gaW5kZXhfb2Zfb3BlbmluZykge1xuICAgICAgICAgICAgICAgIGYuZXJyb3IoJ3RoZXJlIGlzIGFuIG1pc3NpbmcgY2xvc2luZyBpbiBmb2xsb3dpbmcgdHJhbnNsYXRpb24gdmFsdWUnLCB0cmFuc2xhdGVkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0b2tlbl93aXRob3V0X3N5bWJvbHMuaW5kZXhPZihjb21tYSkgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhfb2ZfdG9rZW5fZW5kX29mX2Nsb3NpbmcgPSB0b2tlbl93aXRob3V0X3N5bWJvbHMuaW5kZXhPZihjb21tYSk7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuX3dpdGhvdXRfc3ltYm9scy5pbmRleE9mKG9wdGlvbnNfb3BlbiwgaW5kZXhfb2ZfdG9rZW5fZW5kX29mX2Nsb3NpbmcpICE9IC0xICYmIHRva2VuX3dpdGhvdXRfc3ltYm9scy5pbmRleE9mKG9wdGlvbnNfY2xvc2UsIGluZGV4X29mX3Rva2VuX2VuZF9vZl9jbG9zaW5nKSAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXhfb2Zfb3B0c19vcGVuaW5nID0gdG9rZW5fd2l0aG91dF9zeW1ib2xzLmluZGV4T2Yob3B0aW9uc19vcGVuLCBpbmRleF9vZl90b2tlbl9lbmRfb2ZfY2xvc2luZyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleF9vZl9vcHRzX2VuZF9vZl9jbG9zaW5nID0gdG9rZW5fd2l0aG91dF9zeW1ib2xzLmluZGV4T2Yob3B0aW9uc19jbG9zZSwgaW5kZXhfb2Zfb3B0c19vcGVuaW5nKSArIG9wdGlvbnNfY2xvc2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0cyA9IGYuZXh0ZW5kKG9wdHMsIEpTT04ucGFyc2UodG9rZW5fd2l0aG91dF9zeW1ib2xzLnN1YnN0cmluZyhpbmRleF9vZl9vcHRzX29wZW5pbmcsIGluZGV4X29mX29wdHNfZW5kX29mX2Nsb3NpbmcpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbl93aXRob3V0X3N5bWJvbHMgPSB0b2tlbl93aXRob3V0X3N5bWJvbHMuc3Vic3RyaW5nKDAsIGluZGV4X29mX3Rva2VuX2VuZF9vZl9jbG9zaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdHJhbnNsYXRlZF90b2tlbiA9IF90cmFuc2xhdGUodG9rZW5fd2l0aG91dF9zeW1ib2xzLCBvcHRzKTtcbiAgICAgICAgICAgIHRyYW5zbGF0ZWQgPSB0cmFuc2xhdGVkLnJlcGxhY2UodG9rZW4sIGYucmVnZXhSZXBsYWNlbWVudEVzY2FwZSh0cmFuc2xhdGVkX3Rva2VuKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYW5zbGF0ZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzQ29udGV4dChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucy5jb250ZXh0ICYmICh0eXBlb2Ygb3B0aW9ucy5jb250ZXh0ID09ICdzdHJpbmcnIHx8IHR5cGVvZiBvcHRpb25zLmNvbnRleHQgPT0gJ251bWJlcicpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBuZWVkc1BsdXJhbChvcHRpb25zLCBsbmcpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLmNvdW50ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdGlvbnMuY291bnQgIT0gJ3N0cmluZycvKiAmJiBwbHVyYWxFeHRlbnNpb25zLm5lZWRzUGx1cmFsKGxuZywgb3B0aW9ucy5jb3VudCkqLyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbmVlZHNJbmRlZmluaXRlQXJ0aWNsZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucy5pbmRlZmluaXRlX2FydGljbGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucy5pbmRlZmluaXRlX2FydGljbGUgIT0gJ3N0cmluZycgJiYgb3B0aW9ucy5pbmRlZmluaXRlX2FydGljbGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4aXN0cyhrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdmFyIG5vdEZvdW5kID0gX2dldERlZmF1bHRWYWx1ZShrZXksIG9wdGlvbnMpXG4gICAgICAgICAgICAsIGZvdW5kID0gX2ZpbmQoa2V5LCBvcHRpb25zKTtcblxuICAgICAgICByZXR1cm4gZm91bmQgIT09IHVuZGVmaW5lZCB8fCBmb3VuZCA9PT0gbm90Rm91bmQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhbnNsYXRlKGtleSwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICBpZiAoIWluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICBmLmxvZygnaTE4bmV4dCBub3QgZmluaXNoZWQgaW5pdGlhbGl6YXRpb24uIHlvdSBtaWdodCBoYXZlIGNhbGxlZCB0IGZ1bmN0aW9uIGJlZm9yZSBsb2FkaW5nIHJlc291cmNlcyBmaW5pc2hlZC4nKVxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGVmYXVsdFZhbHVlIHx8ICcnO1xuICAgICAgICB9O1xuICAgICAgICByZXBsYWNlbWVudENvdW50ZXIgPSAwO1xuICAgICAgICByZXR1cm4gX3RyYW5zbGF0ZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9nZXREZWZhdWx0VmFsdWUoa2V5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCkgPyBvcHRpb25zLmRlZmF1bHRWYWx1ZSA6IGtleTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaW5qZWN0U3ByaW50ZlByb2Nlc3NvcigpIHtcblxuICAgICAgICB2YXIgdmFsdWVzID0gW107XG5cbiAgICAgICAgLy8gbWg6IGJ1aWxkIGFycmF5IGZyb20gc2Vjb25kIGFyZ3VtZW50IG9ud2FyZHNcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcG9zdFByb2Nlc3M6ICdzcHJpbnRmJyxcbiAgICAgICAgICAgIHNwcmludGY6ICAgICB2YWx1ZXNcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfdHJhbnNsYXRlKHBvdGVudGlhbEtleXMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoby5zaG9ydGN1dEZ1bmN0aW9uID09PSAnc3ByaW50ZicpIHtcbiAgICAgICAgICAgICAgICAvLyBtaDogZ2V0dGV4dCBsaWtlIHNwcmludGYgc3ludGF4IGZvdW5kLCBhdXRvbWF0aWNhbGx5IGNyZWF0ZSBzcHJpbnRmIHByb2Nlc3NvclxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBfaW5qZWN0U3ByaW50ZlByb2Nlc3Nvci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvLnNob3J0Y3V0RnVuY3Rpb24gPT09ICdkZWZhdWx0VmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBvcHRpb25zXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG8uZGVmYXVsdFZhcmlhYmxlcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBmLmV4dGVuZCh7fSwgby5kZWZhdWx0VmFyaWFibGVzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3RlbnRpYWxLZXlzID09PSB1bmRlZmluZWQgfHwgcG90ZW50aWFsS2V5cyA9PT0gbnVsbCB8fCBwb3RlbnRpYWxLZXlzID09PSAnJykgcmV0dXJuICcnO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcG90ZW50aWFsS2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHBvdGVudGlhbEtleXMgPSBTdHJpbmcocG90ZW50aWFsS2V5cyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBvdGVudGlhbEtleXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBwb3RlbnRpYWxLZXlzID0gW3BvdGVudGlhbEtleXNdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleSA9IHBvdGVudGlhbEtleXNbMF07XG5cbiAgICAgICAgaWYgKHBvdGVudGlhbEtleXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3RlbnRpYWxLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gcG90ZW50aWFsS2V5c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RzKGtleSwgb3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vdEZvdW5kID0gX2dldERlZmF1bHRWYWx1ZShrZXksIG9wdGlvbnMpXG4gICAgICAgICAgICAsIGZvdW5kID0gX2ZpbmQoa2V5LCBvcHRpb25zKVxuICAgICAgICAgICAgLCBsbmdzID0gb3B0aW9ucy5sbmcgPyBmLnRvTGFuZ3VhZ2VzKG9wdGlvbnMubG5nLCBvcHRpb25zLmZhbGxiYWNrTG5nKSA6IGxhbmd1YWdlc1xuICAgICAgICAgICAgLCBucyA9IG9wdGlvbnMubnMgfHwgby5ucy5kZWZhdWx0TnNcbiAgICAgICAgICAgICwgcGFydHM7XG5cbiAgICAgICAgLy8gc3BsaXQgbnMgYW5kIGtleVxuICAgICAgICBpZiAoa2V5LmluZGV4T2Yoby5uc3NlcGFyYXRvcikgPiAtMSkge1xuICAgICAgICAgICAgcGFydHMgPSBrZXkuc3BsaXQoby5uc3NlcGFyYXRvcik7XG4gICAgICAgICAgICBucyA9IHBhcnRzWzBdO1xuICAgICAgICAgICAga2V5ID0gcGFydHNbMV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm91bmQgPT09IHVuZGVmaW5lZCAmJiBvLnNlbmRNaXNzaW5nICYmIHR5cGVvZiBvLm1pc3NpbmdLZXlIYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sbmcpIHtcbiAgICAgICAgICAgICAgICBvLm1pc3NpbmdLZXlIYW5kbGVyKGxuZ3NbMF0sIG5zLCBrZXksIG5vdEZvdW5kLCBsbmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgby5taXNzaW5nS2V5SGFuZGxlcihvLmxuZywgbnMsIGtleSwgbm90Rm91bmQsIGxuZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvc3RQcm9jZXNzb3JzVG9BcHBseTtcbiAgICAgICAgaWYgKHR5cGVvZiBvLnBvc3RQcm9jZXNzID09PSAnc3RyaW5nJyAmJiBvLnBvc3RQcm9jZXNzICE9PSAnJykge1xuICAgICAgICAgICAgcG9zdFByb2Nlc3NvcnNUb0FwcGx5ID0gW28ucG9zdFByb2Nlc3NdO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvLnBvc3RQcm9jZXNzID09PSAnYXJyYXknIHx8IHR5cGVvZiBvLnBvc3RQcm9jZXNzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcG9zdFByb2Nlc3NvcnNUb0FwcGx5ID0gby5wb3N0UHJvY2VzcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvc3RQcm9jZXNzb3JzVG9BcHBseSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnBvc3RQcm9jZXNzID09PSAnc3RyaW5nJyAmJiBvcHRpb25zLnBvc3RQcm9jZXNzICE9PSAnJykge1xuICAgICAgICAgICAgcG9zdFByb2Nlc3NvcnNUb0FwcGx5ID0gcG9zdFByb2Nlc3NvcnNUb0FwcGx5LmNvbmNhdChbb3B0aW9ucy5wb3N0UHJvY2Vzc10pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLnBvc3RQcm9jZXNzID09PSAnYXJyYXknIHx8IHR5cGVvZiBvcHRpb25zLnBvc3RQcm9jZXNzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcG9zdFByb2Nlc3NvcnNUb0FwcGx5ID0gcG9zdFByb2Nlc3NvcnNUb0FwcGx5LmNvbmNhdChvcHRpb25zLnBvc3RQcm9jZXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb3VuZCAhPT0gdW5kZWZpbmVkICYmIHBvc3RQcm9jZXNzb3JzVG9BcHBseS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBvc3RQcm9jZXNzb3JzVG9BcHBseS5mb3JFYWNoKGZ1bmN0aW9uKHBvc3RQcm9jZXNzb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zdFByb2Nlc3NvcnNbcG9zdFByb2Nlc3Nvcl0pIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBwb3N0UHJvY2Vzc29yc1twb3N0UHJvY2Vzc29yXShmb3VuZCwga2V5LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByb2Nlc3Mgbm90Rm91bmQgaWYgZnVuY3Rpb24gZXhpc3RzXG4gICAgICAgIHZhciBzcGxpdE5vdEZvdW5kID0gbm90Rm91bmQ7XG4gICAgICAgIGlmIChub3RGb3VuZC5pbmRleE9mKG8ubnNzZXBhcmF0b3IpID4gLTEpIHtcbiAgICAgICAgICAgIHBhcnRzID0gbm90Rm91bmQuc3BsaXQoby5uc3NlcGFyYXRvcik7XG4gICAgICAgICAgICBzcGxpdE5vdEZvdW5kID0gcGFydHNbMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwbGl0Tm90Rm91bmQgPT09IGtleSAmJiBvLnBhcnNlTWlzc2luZ0tleSkge1xuICAgICAgICAgICAgbm90Rm91bmQgPSBvLnBhcnNlTWlzc2luZ0tleShub3RGb3VuZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm91bmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm90Rm91bmQgPSBhcHBseVJlcGxhY2VtZW50KG5vdEZvdW5kLCBvcHRpb25zKTtcbiAgICAgICAgICAgIG5vdEZvdW5kID0gYXBwbHlSZXVzZShub3RGb3VuZCwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIGlmIChwb3N0UHJvY2Vzc29yc1RvQXBwbHkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IF9nZXREZWZhdWx0VmFsdWUoa2V5LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBwb3N0UHJvY2Vzc29yc1RvQXBwbHkuZm9yRWFjaChmdW5jdGlvbihwb3N0UHJvY2Vzc29yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3N0UHJvY2Vzc29yc1twb3N0UHJvY2Vzc29yXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBwb3N0UHJvY2Vzc29yc1twb3N0UHJvY2Vzc29yXSh2YWwsIGtleSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoZm91bmQgIT09IHVuZGVmaW5lZCkgPyBmb3VuZCA6IG5vdEZvdW5kO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9maW5kKGtleSwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB2YXIgb3B0aW9uV2l0aG91dENvdW50LCB0cmFuc2xhdGVkXG4gICAgICAgICAgICAsIG5vdEZvdW5kID0gX2dldERlZmF1bHRWYWx1ZShrZXksIG9wdGlvbnMpXG4gICAgICAgICAgICAsIGxuZ3MgPSBsYW5ndWFnZXM7XG5cbiAgICAgICAgaWYgKCFyZXNTdG9yZSkgeyByZXR1cm4gbm90Rm91bmQ7IH0gLy8gbm8gcmVzU3RvcmUgdG8gdHJhbnNsYXRlIGZyb21cblxuICAgICAgICAvLyBDSSBtb2RlXG4gICAgICAgIGlmIChsbmdzWzBdLnRvTG93ZXJDYXNlKCkgPT09ICdjaW1vZGUnKSByZXR1cm4gbm90Rm91bmQ7XG5cbiAgICAgICAgLy8gcGFzc2VkIGluIGxuZ1xuICAgICAgICBpZiAob3B0aW9ucy5sbmdzKSBsbmdzID0gb3B0aW9ucy5sbmdzO1xuICAgICAgICBpZiAob3B0aW9ucy5sbmcpIHtcbiAgICAgICAgICAgIGxuZ3MgPSBmLnRvTGFuZ3VhZ2VzKG9wdGlvbnMubG5nLCBvcHRpb25zLmZhbGxiYWNrTG5nKTtcblxuICAgICAgICAgICAgaWYgKCFyZXNTdG9yZVtsbmdzWzBdXSkge1xuICAgICAgICAgICAgICAgIHZhciBvbGRBc3luYyA9IG8uZ2V0QXN5bmM7XG4gICAgICAgICAgICAgICAgby5nZXRBc3luYyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgaTE4bi5zeW5jLmxvYWQobG5ncywgbywgZnVuY3Rpb24oZXJyLCBzdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICBmLmV4dGVuZChyZXNTdG9yZSwgc3RvcmUpO1xuICAgICAgICAgICAgICAgICAgICBvLmdldEFzeW5jID0gb2xkQXN5bmM7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbnMgPSBvcHRpb25zLm5zIHx8IG8ubnMuZGVmYXVsdE5zO1xuICAgICAgICBpZiAoa2V5LmluZGV4T2Yoby5uc3NlcGFyYXRvcikgPiAtMSkge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0ga2V5LnNwbGl0KG8ubnNzZXBhcmF0b3IpO1xuICAgICAgICAgICAgbnMgPSBwYXJ0c1swXTtcbiAgICAgICAgICAgIGtleSA9IHBhcnRzWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc0NvbnRleHQob3B0aW9ucykpIHtcbiAgICAgICAgICAgIG9wdGlvbldpdGhvdXRDb3VudCA9IGYuZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25XaXRob3V0Q291bnQuY29udGV4dDtcbiAgICAgICAgICAgIG9wdGlvbldpdGhvdXRDb3VudC5kZWZhdWx0VmFsdWUgPSBvLmNvbnRleHROb3RGb3VuZDtcblxuICAgICAgICAgICAgdmFyIGNvbnRleHRLZXkgPSBucyArIG8ubnNzZXBhcmF0b3IgKyBrZXkgKyAnXycgKyBvcHRpb25zLmNvbnRleHQ7XG5cbiAgICAgICAgICAgIHRyYW5zbGF0ZWQgPSB0cmFuc2xhdGUoY29udGV4dEtleSwgb3B0aW9uV2l0aG91dENvdW50KTtcbiAgICAgICAgICAgIGlmICh0cmFuc2xhdGVkICE9IG8uY29udGV4dE5vdEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcGx5UmVwbGFjZW1lbnQodHJhbnNsYXRlZCwgeyBjb250ZXh0OiBvcHRpb25zLmNvbnRleHQgfSk7IC8vIGFwcGx5IHJlcGxhY2VtZW50IGZvciBjb250ZXh0IG9ubHlcbiAgICAgICAgICAgIH0gLy8gZWxzZSBjb250aW51ZSB0cmFuc2xhdGlvbiB3aXRoIG9yaWdpbmFsL25vbkNvbnRleHQga2V5XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmVlZHNQbHVyYWwob3B0aW9ucywgbG5nc1swXSkpIHtcbiAgICAgICAgICAgIG9wdGlvbldpdGhvdXRDb3VudCA9IGYuZXh0ZW5kKHsgbG5nczogW2xuZ3NbMF1dfSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBkZWxldGUgb3B0aW9uV2l0aG91dENvdW50LmNvdW50O1xuICAgICAgICAgICAgb3B0aW9uV2l0aG91dENvdW50Ll9vcmlnTG5nID0gb3B0aW9uV2l0aG91dENvdW50Ll9vcmlnTG5nIHx8IG9wdGlvbldpdGhvdXRDb3VudC5sbmcgfHwgbG5nc1swXTtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25XaXRob3V0Q291bnQubG5nO1xuICAgICAgICAgICAgb3B0aW9uV2l0aG91dENvdW50LmRlZmF1bHRWYWx1ZSA9IG8ucGx1cmFsTm90Rm91bmQ7XG5cbiAgICAgICAgICAgIHZhciBwbHVyYWxLZXk7XG4gICAgICAgICAgICBpZiAoIXBsdXJhbEV4dGVuc2lvbnMubmVlZHNQbHVyYWwobG5nc1swXSwgb3B0aW9ucy5jb3VudCkpIHtcbiAgICAgICAgICAgICAgICBwbHVyYWxLZXkgPSBucyArIG8ubnNzZXBhcmF0b3IgKyBrZXk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBsdXJhbEtleSA9IG5zICsgby5uc3NlcGFyYXRvciArIGtleSArIG8ucGx1cmFsU3VmZml4O1xuICAgICAgICAgICAgICAgIHZhciBwbHVyYWxFeHRlbnNpb24gPSBwbHVyYWxFeHRlbnNpb25zLmdldChsbmdzWzBdLCBvcHRpb25zLmNvdW50KTtcbiAgICAgICAgICAgICAgICBpZiAocGx1cmFsRXh0ZW5zaW9uID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcGx1cmFsS2V5ID0gcGx1cmFsS2V5ICsgJ18nICsgcGx1cmFsRXh0ZW5zaW9uO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGx1cmFsRXh0ZW5zaW9uID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsdXJhbEtleSA9IG5zICsgby5uc3NlcGFyYXRvciArIGtleTsgLy8gc2luZ3VsYXJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyYW5zbGF0ZWQgPSB0cmFuc2xhdGUocGx1cmFsS2V5LCBvcHRpb25XaXRob3V0Q291bnQpO1xuXG4gICAgICAgICAgICBpZiAodHJhbnNsYXRlZCAhPSBvLnBsdXJhbE5vdEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcGx5UmVwbGFjZW1lbnQodHJhbnNsYXRlZCwge1xuICAgICAgICAgICAgICAgICAgICBjb3VudDogb3B0aW9ucy5jb3VudCxcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvblByZWZpeDogb3B0aW9ucy5pbnRlcnBvbGF0aW9uUHJlZml4LFxuICAgICAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uU3VmZml4OiBvcHRpb25zLmludGVycG9sYXRpb25TdWZmaXhcbiAgICAgICAgICAgICAgICB9KTsgLy8gYXBwbHkgcmVwbGFjZW1lbnQgZm9yIGNvdW50IG9ubHlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobG5ncy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGZhaWxlZCBsbmdcbiAgICAgICAgICAgICAgICB2YXIgY2xvbmUgPSBsbmdzLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgY2xvbmUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gZi5leHRlbmQob3B0aW9ucywgeyBsbmdzOiBjbG9uZSB9KTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLl9vcmlnTG5nID0gb3B0aW9uV2l0aG91dENvdW50Ll9vcmlnTG5nO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmxuZztcbiAgICAgICAgICAgICAgICAvLyByZXRyeSB3aXRoIGZhbGxiYWNrc1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZWQgPSB0cmFuc2xhdGUobnMgKyBvLm5zc2VwYXJhdG9yICsga2V5LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNsYXRlZCAhPSBvLnBsdXJhbE5vdEZvdW5kKSByZXR1cm4gdHJhbnNsYXRlZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uV2l0aG91dENvdW50LmxuZyA9IG9wdGlvbldpdGhvdXRDb3VudC5fb3JpZ0xuZztcbiAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9uV2l0aG91dENvdW50Ll9vcmlnTG5nO1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZWQgPSB0cmFuc2xhdGUobnMgKyBvLm5zc2VwYXJhdG9yICsga2V5LCBvcHRpb25XaXRob3V0Q291bnQpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcGx5UmVwbGFjZW1lbnQodHJhbnNsYXRlZCwge1xuICAgICAgICAgICAgICAgICAgICBjb3VudDogb3B0aW9ucy5jb3VudCxcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvblByZWZpeDogb3B0aW9ucy5pbnRlcnBvbGF0aW9uUHJlZml4LFxuICAgICAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uU3VmZml4OiBvcHRpb25zLmludGVycG9sYXRpb25TdWZmaXhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZWVkc0luZGVmaW5pdGVBcnRpY2xlKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uc1dpdGhvdXRJbmRlZiA9IGYuZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zV2l0aG91dEluZGVmLmluZGVmaW5pdGVfYXJ0aWNsZTtcbiAgICAgICAgICAgIG9wdGlvbnNXaXRob3V0SW5kZWYuZGVmYXVsdFZhbHVlID0gby5pbmRlZmluaXRlTm90Rm91bmQ7XG4gICAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY291bnQsIHdlIHdhbnQgdGhlIGluZGVmaW5pdGUsIGlmIHdlIGRvIGhhdmUgYSBjb3VudCwgYW5kIG5lZWRzUGx1cmFsIGlzIGZhbHNlXG4gICAgICAgICAgICB2YXIgaW5kZWZpbml0ZUtleSA9IG5zICsgby5uc3NlcGFyYXRvciArIGtleSArICgoKG9wdGlvbnMuY291bnQgJiYgIW5lZWRzUGx1cmFsKG9wdGlvbnMsIGxuZ3NbMF0pKSB8fCAhb3B0aW9ucy5jb3VudCkgPyBvLmluZGVmaW5pdGVTdWZmaXggOiBcIlwiKTtcbiAgICAgICAgICAgIHRyYW5zbGF0ZWQgPSB0cmFuc2xhdGUoaW5kZWZpbml0ZUtleSwgb3B0aW9uc1dpdGhvdXRJbmRlZik7XG4gICAgICAgICAgICBpZiAodHJhbnNsYXRlZCAhPSBvLmluZGVmaW5pdGVOb3RGb3VuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2xhdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZvdW5kO1xuICAgICAgICB2YXIga2V5cyA9IGtleS5zcGxpdChvLmtleXNlcGFyYXRvcik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgaWYgKGZvdW5kICE9PSB1bmRlZmluZWQpIGJyZWFrO1xuXG4gICAgICAgICAgICB2YXIgbCA9IGxuZ3NbaV07XG5cbiAgICAgICAgICAgIHZhciB4ID0gMDtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHJlc1N0b3JlW2xdICYmIHJlc1N0b3JlW2xdW25zXTtcbiAgICAgICAgICAgIHdoaWxlIChrZXlzW3hdKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAmJiB2YWx1ZVtrZXlzW3hdXTtcbiAgICAgICAgICAgICAgICB4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZVR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGFwcGx5UmVwbGFjZW1lbnQodmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGFwcGx5UmV1c2UodmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVUeXBlID09PSAnW29iamVjdCBBcnJheV0nICYmICFvLnJldHVybk9iamVjdFRyZWVzICYmICFvcHRpb25zLnJldHVybk9iamVjdFRyZWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuam9pbignXFxuJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYXBwbHlSZXBsYWNlbWVudCh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYXBwbHlSZXVzZSh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCAmJiBvLmZhbGxiYWNrT25OdWxsID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvLnJldHVybk9iamVjdFRyZWVzICYmICFvcHRpb25zLnJldHVybk9iamVjdFRyZWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoby5vYmplY3RUcmVlS2V5SGFuZGxlciAmJiB0eXBlb2Ygby5vYmplY3RUcmVlS2V5SGFuZGxlciA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBvLm9iamVjdFRyZWVLZXlIYW5kbGVyKGtleSwgdmFsdWUsIGwsIG5zLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAna2V5IFxcJycgKyBucyArICc6JyArIGtleSArICcgKCcgKyBsICsgJylcXCcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyZXR1cm5lZCBhbiBvYmplY3QgaW5zdGVhZCBvZiBzdHJpbmcuJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLmxvZyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVUeXBlICE9PSAnW29iamVjdCBOdW1iZXJdJyAmJiB2YWx1ZVR5cGUgIT09ICdbb2JqZWN0IEZ1bmN0aW9uXScgJiYgdmFsdWVUeXBlICE9PSAnW29iamVjdCBSZWdFeHBdJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvcHkgPSAodmFsdWVUeXBlID09PSAnW29iamVjdCBBcnJheV0nKSA/IFtdIDoge307IC8vIGFwcGx5IGNoaWxkIHRyYW5zbGF0aW9uIG9uIGEgY29weVxuICAgICAgICAgICAgICAgICAgICAgICAgZi5lYWNoKHZhbHVlLCBmdW5jdGlvbihtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weVttXSA9IF90cmFuc2xhdGUobnMgKyBvLm5zc2VwYXJhdG9yICsga2V5ICsgby5rZXlzZXBhcmF0b3IgKyBtLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjb3B5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUudHJpbSgpID09PSAnJyAmJiBvLmZhbGxiYWNrT25FbXB0eSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICBmb3VuZCA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvdW5kID09PSB1bmRlZmluZWQgJiYgIW9wdGlvbnMuaXNGYWxsYmFja0xvb2t1cCAmJiAoby5mYWxsYmFja1RvRGVmYXVsdE5TID09PSB0cnVlIHx8IChvLmZhbGxiYWNrTlMgJiYgby5mYWxsYmFja05TLmxlbmd0aCA+IDApKSkge1xuICAgICAgICAgICAgLy8gc2V0IGZsYWcgZm9yIGZhbGxiYWNrIGxvb2t1cCAtIGF2b2lkIHJlY3Vyc2lvblxuICAgICAgICAgICAgb3B0aW9ucy5pc0ZhbGxiYWNrTG9va3VwID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKG8uZmFsbGJhY2tOUy5sZW5ndGgpIHtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSAwLCBsZW5ZID0gby5mYWxsYmFja05TLmxlbmd0aDsgeSA8IGxlblk7IHkrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IF9maW5kKG8uZmFsbGJhY2tOU1t5XSArIG8ubnNzZXBhcmF0b3IgKyBrZXksIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZCB8fCAoZm91bmQ9PT1cIlwiICYmIG8uZmFsbGJhY2tPbkVtcHR5ID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGNvbXBhcmUgdmFsdWUgd2l0aG91dCBuYW1lc3BhY2UgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmb3VuZFZhbHVlID0gZm91bmQuaW5kZXhPZihvLm5zc2VwYXJhdG9yKSA+IC0xID8gZm91bmQuc3BsaXQoby5uc3NlcGFyYXRvcilbMV0gOiBmb3VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAsIG5vdEZvdW5kVmFsdWUgPSBub3RGb3VuZC5pbmRleE9mKG8ubnNzZXBhcmF0b3IpID4gLTEgPyBub3RGb3VuZC5zcGxpdChvLm5zc2VwYXJhdG9yKVsxXSA6IG5vdEZvdW5kO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmRWYWx1ZSAhPT0gbm90Rm91bmRWYWx1ZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvdW5kID0gX2ZpbmQoa2V5LCBvcHRpb25zKTsgLy8gZmFsbGJhY2sgdG8gZGVmYXVsdCBOU1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucy5pc0ZhbGxiYWNrTG9va3VwID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRldGVjdExhbmd1YWdlKCkge1xuICAgICAgICB2YXIgZGV0ZWN0ZWRMbmc7XG4gICAgICAgIHZhciB3aGl0ZWxpc3QgPSBvLmxuZ1doaXRlbGlzdCB8fCBbXTtcbiAgICAgICAgdmFyIHVzZXJMbmdDaG9pY2VzID0gW107XG5cbiAgICAgICAgLy8gZ2V0IGZyb20gcXNcbiAgICAgICAgdmFyIHFzUGFybSA9IFtdO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgcXVlcnkgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gcXVlcnkuc3BsaXQoJyYnKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8cGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSBwYXJhbXNbaV0uaW5kZXhPZignPScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IHBhcmFtc1tpXS5zdWJzdHJpbmcoMCxwb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PSBvLmRldGVjdExuZ1FTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlckxuZ0Nob2ljZXMucHVzaChwYXJhbXNbaV0uc3Vic3RyaW5nKHBvcysxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IGZyb20gY29va2llXG4gICAgICAgIGlmIChvLnVzZUNvb2tpZSAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGYuY29va2llLnJlYWQoby5jb29raWVOYW1lKTtcbiAgICAgICAgICAgIGlmIChjKSB1c2VyTG5nQ2hvaWNlcy5wdXNoKGMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IGZyb20gbG9jYWxTdG9yYWdlXG4gICAgICAgIGlmIChvLmRldGVjdExuZ0Zyb21Mb2NhbFN0b3JhZ2UgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmxvY2FsU3RvcmFnZSkge1xuICAgICAgICAgICAgdXNlckxuZ0Nob2ljZXMucHVzaChmLmxvY2FsU3RvcmFnZS5nZXRJdGVtKCdpMThuZXh0X2xuZycpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCBmcm9tIG5hdmlnYXRvclxuICAgICAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmIChuYXZpZ2F0b3IubGFuZ3VhZ2VzKSB7IC8vIGNocm9tZSBvbmx5OyBub3QgYW4gYXJyYXksIHNvIGNhbid0IHVzZSAucHVzaC5hcHBseSBpbnN0ZWFkIG9mIGl0ZXJhdGluZ1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDtpPG5hdmlnYXRvci5sYW5ndWFnZXMubGVuZ3RoO2krKykge1xuICAgICAgICAgICAgICAgICAgICB1c2VyTG5nQ2hvaWNlcy5wdXNoKG5hdmlnYXRvci5sYW5ndWFnZXNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYXZpZ2F0b3IudXNlckxhbmd1YWdlKSB7XG4gICAgICAgICAgICAgICAgdXNlckxuZ0Nob2ljZXMucHVzaChuYXZpZ2F0b3IudXNlckxhbmd1YWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYXZpZ2F0b3IubGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgICAgICB1c2VyTG5nQ2hvaWNlcy5wdXNoKG5hdmlnYXRvci5sYW5ndWFnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7aTx1c2VyTG5nQ2hvaWNlcy5sZW5ndGg7aSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxuZyA9IHVzZXJMbmdDaG9pY2VzW2ldO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxuZy5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBsbmcuc3BsaXQoJy0nKTtcbiAgICAgICAgICAgICAgICAgICAgbG5nID0gby5sb3dlckNhc2VMbmcgP1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHNbMF0udG9Mb3dlckNhc2UoKSArICAnLScgKyBwYXJ0c1sxXS50b0xvd2VyQ2FzZSgpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzWzBdLnRvTG93ZXJDYXNlKCkgKyAgJy0nICsgcGFydHNbMV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAod2hpdGVsaXN0Lmxlbmd0aCA9PT0gMCB8fCB3aGl0ZWxpc3QuaW5kZXhPZihsbmcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGV0ZWN0ZWRMbmcgPSBsbmc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcblxuICAgICAgICAvL2ZhbGxiYWNrXG4gICAgICAgIGlmICghZGV0ZWN0ZWRMbmcpe1xuICAgICAgICAgIGRldGVjdGVkTG5nID0gby5mYWxsYmFja0xuZ1swXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZXRlY3RlZExuZztcbiAgICB9XG4gICAgLy8gZGVmaW5pdGlvbiBodHRwOi8vdHJhbnNsYXRlLnNvdXJjZWZvcmdlLm5ldC93aWtpL2wxMG4vcGx1cmFsZm9ybXNcblxuICAgIC8qIFtjb2RlLCBuYW1lLCBudW1iZXJzLCBwbHVyYWxzVHlwZV0gKi9cbiAgICB2YXIgX3J1bGVzID0gW1xuICAgICAgICBbXCJhY2hcIiwgXCJBY2hvbGlcIiwgWzEsMl0sIDFdLFxuICAgICAgICBbXCJhZlwiLCBcIkFmcmlrYWFuc1wiLFsxLDJdLCAyXSxcbiAgICAgICAgW1wiYWtcIiwgXCJBa2FuXCIsIFsxLDJdLCAxXSxcbiAgICAgICAgW1wiYW1cIiwgXCJBbWhhcmljXCIsIFsxLDJdLCAxXSxcbiAgICAgICAgW1wiYW5cIiwgXCJBcmFnb25lc2VcIixbMSwyXSwgMl0sXG4gICAgICAgIFtcImFyXCIsIFwiQXJhYmljXCIsIFswLDEsMiwzLDExLDEwMF0sNV0sXG4gICAgICAgIFtcImFyblwiLCBcIk1hcHVkdW5ndW5cIixbMSwyXSwgMV0sXG4gICAgICAgIFtcImFzdFwiLCBcIkFzdHVyaWFuXCIsIFsxLDJdLCAyXSxcbiAgICAgICAgW1wiYXlcIiwgXCJBeW1hcsOhXCIsIFsxXSwgM10sXG4gICAgICAgIFtcImF6XCIsIFwiQXplcmJhaWphbmlcIixbMSwyXSwyXSxcbiAgICAgICAgW1wiYmVcIiwgXCJCZWxhcnVzaWFuXCIsWzEsMiw1XSw0XSxcbiAgICAgICAgW1wiYmdcIiwgXCJCdWxnYXJpYW5cIixbMSwyXSwgMl0sXG4gICAgICAgIFtcImJuXCIsIFwiQmVuZ2FsaVwiLCBbMSwyXSwgMl0sXG4gICAgICAgIFtcImJvXCIsIFwiVGliZXRhblwiLCBbMV0sIDNdLFxuICAgICAgICBbXCJiclwiLCBcIkJyZXRvblwiLCBbMSwyXSwgMV0sXG4gICAgICAgIFtcImJzXCIsIFwiQm9zbmlhblwiLCBbMSwyLDVdLDRdLFxuICAgICAgICBbXCJjYVwiLCBcIkNhdGFsYW5cIiwgWzEsMl0sIDJdLFxuICAgICAgICBbXCJjZ2dcIiwgXCJDaGlnYVwiLCBbMV0sIDNdLFxuICAgICAgICBbXCJjc1wiLCBcIkN6ZWNoXCIsIFsxLDIsNV0sNl0sXG4gICAgICAgIFtcImNzYlwiLCBcIkthc2h1YmlhblwiLFsxLDIsNV0sN10sXG4gICAgICAgIFtcImN5XCIsIFwiV2Vsc2hcIiwgWzEsMiwzLDhdLDhdLFxuICAgICAgICBbXCJkYVwiLCBcIkRhbmlzaFwiLCBbMSwyXSwgMl0sXG4gICAgICAgIFtcImRlXCIsIFwiR2VybWFuXCIsIFsxLDJdLCAyXSxcbiAgICAgICAgW1wiZGV2XCIsIFwiRGV2ZWxvcG1lbnQgRmFsbGJhY2tcIiwgWzEsMl0sIDJdLFxuICAgICAgICBbXCJkelwiLCBcIkR6b25na2hhXCIsIFsxXSwgM10sXG4gICAgICAgIFtcImVsXCIsIFwiR3JlZWtcIiwgWzEsMl0sIDJdLFxuICAgICAgICBbXCJlblwiLCBcIkVuZ2xpc2hcIiwgWzEsMl0sIDJdLFxuICAgICAgICBbXCJlb1wiLCBcIkVzcGVyYW50b1wiLFsxLDJdLCAyXSxcbiAgICAgICAgW1wiZXNcIiwgXCJTcGFuaXNoXCIsIFsxLDJdLCAyXSxcbiAgICAgICAgW1wiZXNfYXJcIixcIkFyZ2VudGluZWFuIFNwYW5pc2hcIiwgWzEsMl0sIDJdLFxuICAgICAgICBbXCJldFwiLCBcIkVzdG9uaWFuXCIsIFsxLDJdLCAyXSxcbiAgICAgICAgW1wiZXVcIiwgXCJCYXNxdWVcIiwgWzEsMl0sIDJdLFxuICAgICAgICBbXCJmYVwiLCBcIlBlcnNpYW5cIiwgWzFdLCAzXSxcbiAgICAgICAgW1wiZmlcIiwgXCJGaW5uaXNoXCIsIFsxLDJdLCAyXSxcbiAgICAgICAgW1wiZmlsXCIsIFwiRmlsaXBpbm9cIiwgWzEsMl0sIDFdLFxuICAgICAgICBbXCJmb1wiLCBcIkZhcm9lc2VcIiwgWzEsMl0sIDJdLFxuICAgICAgICBbXCJmclwiLCBcIkZyZW5jaFwiLCBbMSwyXSwgOV0sXG4gICAgICAgIFtcImZ1clwiLCBcIkZyaXVsaWFuXCIsIFsxLDJdLCAyXSxcbiAgICAgICAgW1wiZnlcIiwgXCJGcmlzaWFuXCIsIFsxLDJdLCAyXSxcbiAgICAgICAgW1wiZ2FcIiwgXCJJcmlzaFwiLCBbMSwyLDMsNywxMV0sMTBdLFxuICAgICAgICBbXCJnZFwiLCBcIlNjb3R0aXNoIEdhZWxpY1wiLFsxLDIsMywyMF0sMTFdLFxuICAgICAgICBbXCJnbFwiLCBcIkdhbGljaWFuXCIsIFsxLDJdLCAyXSxcbiAgICAgICAgW1wiZ3VcIiwgXCJHdWphcmF0aVwiLCBbMSwyXSwgMl0sXG4gICAgICAgIFtcImd1blwiLCBcIkd1blwiLCBbMSwyXSwgMV0sXG4gICAgICAgIFtcImhhXCIsIFwiSGF1c2FcIiwgWzEsMl0sIDJdLFxuICAgICAgICBbXCJoZVwiLCBcIkhlYnJld1wiLCBbMSwyXSwgMl0sXG4gICAgICAgIFtcImhpXCIsIFwiSGluZGlcIiwgWzEsMl0sIDJdLFxuICAgICAgICBbXCJoclwiLCBcIkNyb2F0aWFuXCIsIFsxLDIsNV0sNF0sXG4gICAgICAgIFtcImh1XCIsIFwiSHVuZ2FyaWFuXCIsWzEsMl0sIDJdLFxuICAgICAgICBbXCJoeVwiLCBcIkFybWVuaWFuXCIsIFsxLDJdLCAyXSxcbiAgICAgICAgW1wiaWFcIiwgXCJJbnRlcmxpbmd1YVwiLFsxLDJdLDJdLFxuICAgICAgICBbXCJpZFwiLCBcIkluZG9uZXNpYW5cIixbMV0sIDNdLFxuICAgICAgICBbXCJpc1wiLCBcIkljZWxhbmRpY1wiLFsxLDJdLCAxMl0sXG4gICAgICAgIFtcIml0XCIsIFwiSXRhbGlhblwiLCBbMSwyXSwgMl0sXG4gICAgICAgIFtcImphXCIsIFwiSmFwYW5lc2VcIiwgWzFdLCAzXSxcbiAgICAgICAgW1wiamJvXCIsIFwiTG9qYmFuXCIsIFsxXSwgM10sXG4gICAgICAgIFtcImp2XCIsIFwiSmF2YW5lc2VcIiwgWzAsMV0sIDEzXSxcbiAgICAgICAgW1wia2FcIiwgXCJHZW9yZ2lhblwiLCBbMV0sIDNdLFxuICAgICAgICBbXCJra1wiLCBcIkthemFraFwiLCBbMV0sIDNdLFxuICAgICAgICBbXCJrbVwiLCBcIktobWVyXCIsIFsxXSwgM10sXG4gICAgICAgIFtcImtuXCIsIFwiS2FubmFkYVwiLCBbMSwyXSwgMl0sXG4gICAgICAgIFtcImtvXCIsIFwiS29yZWFuXCIsIFsxXSwgM10sXG4gICAgICAgIFtcImt1XCIsIFwiS3VyZGlzaFwiLCBbMSwyXSwgMl0sXG4gICAgICAgIFtcImt3XCIsIFwiQ29ybmlzaFwiLCBbMSwyLDMsNF0sMTRdLFxuICAgICAgICBbXCJreVwiLCBcIkt5cmd5elwiLCBbMV0sIDNdLFxuICAgICAgICBbXCJsYlwiLCBcIkxldHplYnVyZ2VzY2hcIixbMSwyXSwyXSxcbiAgICAgICAgW1wibG5cIiwgXCJMaW5nYWxhXCIsIFsxLDJdLCAxXSxcbiAgICAgICAgW1wibG9cIiwgXCJMYW9cIiwgWzFdLCAzXSxcbiAgICAgICAgW1wibHRcIiwgXCJMaXRodWFuaWFuXCIsWzEsMiwxMF0sMTVdLFxuICAgICAgICBbXCJsdlwiLCBcIkxhdHZpYW5cIiwgWzEsMiwwXSwxNl0sXG4gICAgICAgIFtcIm1haVwiLCBcIk1haXRoaWxpXCIsIFsxLDJdLCAyXSxcbiAgICAgICAgW1wibWZlXCIsIFwiTWF1cml0aWFuIENyZW9sZVwiLFsxLDJdLDFdLFxuICAgICAgICBbXCJtZ1wiLCBcIk1hbGFnYXN5XCIsIFsxLDJdLCAxXSxcbiAgICAgICAgW1wibWlcIiwgXCJNYW9yaVwiLCBbMSwyXSwgMV0sXG4gICAgICAgIFtcIm1rXCIsIFwiTWFjZWRvbmlhblwiLFsxLDJdLDE3XSxcbiAgICAgICAgW1wibWxcIiwgXCJNYWxheWFsYW1cIixbMSwyXSwgMl0sXG4gICAgICAgIFtcIm1uXCIsIFwiTW9uZ29saWFuXCIsWzEsMl0sIDJdLFxuICAgICAgICBbXCJtbmtcIiwgXCJNYW5kaW5rYVwiLCBbMCwxLDJdLDE4XSxcbiAgICAgICAgW1wibXJcIiwgXCJNYXJhdGhpXCIsIFsxLDJdLCAyXSxcbiAgICAgICAgW1wibXNcIiwgXCJNYWxheVwiLCBbMV0sIDNdLFxuICAgICAgICBbXCJtdFwiLCBcIk1hbHRlc2VcIiwgWzEsMiwxMSwyMF0sMTldLFxuICAgICAgICBbXCJuYWhcIiwgXCJOYWh1YXRsXCIsIFsxLDJdLCAyXSxcbiAgICAgICAgW1wibmFwXCIsIFwiTmVhcG9saXRhblwiLFsxLDJdLCAyXSxcbiAgICAgICAgW1wibmJcIiwgXCJOb3J3ZWdpYW4gQm9rbWFsXCIsWzEsMl0sMl0sXG4gICAgICAgIFtcIm5lXCIsIFwiTmVwYWxpXCIsIFsxLDJdLCAyXSxcbiAgICAgICAgW1wibmxcIiwgXCJEdXRjaFwiLCBbMSwyXSwgMl0sXG4gICAgICAgIFtcIm5uXCIsIFwiTm9yd2VnaWFuIE55bm9yc2tcIixbMSwyXSwyXSxcbiAgICAgICAgW1wibm9cIiwgXCJOb3J3ZWdpYW5cIixbMSwyXSwgMl0sXG4gICAgICAgIFtcIm5zb1wiLCBcIk5vcnRoZXJuIFNvdGhvXCIsWzEsMl0sMl0sXG4gICAgICAgIFtcIm9jXCIsIFwiT2NjaXRhblwiLCBbMSwyXSwgMV0sXG4gICAgICAgIFtcIm9yXCIsIFwiT3JpeWFcIiwgWzIsMV0sIDJdLFxuICAgICAgICBbXCJwYVwiLCBcIlB1bmphYmlcIiwgWzEsMl0sIDJdLFxuICAgICAgICBbXCJwYXBcIiwgXCJQYXBpYW1lbnRvXCIsWzEsMl0sIDJdLFxuICAgICAgICBbXCJwbFwiLCBcIlBvbGlzaFwiLCBbMSwyLDVdLDddLFxuICAgICAgICBbXCJwbXNcIiwgXCJQaWVtb250ZXNlXCIsWzEsMl0sIDJdLFxuICAgICAgICBbXCJwc1wiLCBcIlBhc2h0b1wiLCBbMSwyXSwgMl0sXG4gICAgICAgIFtcInB0XCIsIFwiUG9ydHVndWVzZVwiLFsxLDJdLCAyXSxcbiAgICAgICAgW1wicHRfYnJcIixcIkJyYXppbGlhbiBQb3J0dWd1ZXNlXCIsWzEsMl0sIDJdLFxuICAgICAgICBbXCJybVwiLCBcIlJvbWFuc2hcIiwgWzEsMl0sIDJdLFxuICAgICAgICBbXCJyb1wiLCBcIlJvbWFuaWFuXCIsIFsxLDIsMjBdLDIwXSxcbiAgICAgICAgW1wicnVcIiwgXCJSdXNzaWFuXCIsIFsxLDIsNV0sNF0sXG4gICAgICAgIFtcInNhaFwiLCBcIllha3V0XCIsIFsxXSwgM10sXG4gICAgICAgIFtcInNjb1wiLCBcIlNjb3RzXCIsIFsxLDJdLCAyXSxcbiAgICAgICAgW1wic2VcIiwgXCJOb3J0aGVybiBTYW1pXCIsWzEsMl0sIDJdLFxuICAgICAgICBbXCJzaVwiLCBcIlNpbmhhbGFcIiwgWzEsMl0sIDJdLFxuICAgICAgICBbXCJza1wiLCBcIlNsb3Zha1wiLCBbMSwyLDVdLDZdLFxuICAgICAgICBbXCJzbFwiLCBcIlNsb3ZlbmlhblwiLFs1LDEsMiwzXSwyMV0sXG4gICAgICAgIFtcInNvXCIsIFwiU29tYWxpXCIsIFsxLDJdLCAyXSxcbiAgICAgICAgW1wic29uXCIsIFwiU29uZ2hheVwiLCBbMSwyXSwgMl0sXG4gICAgICAgIFtcInNxXCIsIFwiQWxiYW5pYW5cIiwgWzEsMl0sIDJdLFxuICAgICAgICBbXCJzclwiLCBcIlNlcmJpYW5cIiwgWzEsMiw1XSw0XSxcbiAgICAgICAgW1wic3VcIiwgXCJTdW5kYW5lc2VcIixbMV0sIDNdLFxuICAgICAgICBbXCJzdlwiLCBcIlN3ZWRpc2hcIiwgWzEsMl0sIDJdLFxuICAgICAgICBbXCJzd1wiLCBcIlN3YWhpbGlcIiwgWzEsMl0sIDJdLFxuICAgICAgICBbXCJ0YVwiLCBcIlRhbWlsXCIsIFsxLDJdLCAyXSxcbiAgICAgICAgW1widGVcIiwgXCJUZWx1Z3VcIiwgWzEsMl0sIDJdLFxuICAgICAgICBbXCJ0Z1wiLCBcIlRhamlrXCIsIFsxLDJdLCAxXSxcbiAgICAgICAgW1widGhcIiwgXCJUaGFpXCIsIFsxXSwgM10sXG4gICAgICAgIFtcInRpXCIsIFwiVGlncmlueWFcIiwgWzEsMl0sIDFdLFxuICAgICAgICBbXCJ0a1wiLCBcIlR1cmttZW5cIiwgWzEsMl0sIDJdLFxuICAgICAgICBbXCJ0clwiLCBcIlR1cmtpc2hcIiwgWzEsMl0sIDFdLFxuICAgICAgICBbXCJ0dFwiLCBcIlRhdGFyXCIsIFsxXSwgM10sXG4gICAgICAgIFtcInVnXCIsIFwiVXlnaHVyXCIsIFsxXSwgM10sXG4gICAgICAgIFtcInVrXCIsIFwiVWtyYWluaWFuXCIsWzEsMiw1XSw0XSxcbiAgICAgICAgW1widXJcIiwgXCJVcmR1XCIsIFsxLDJdLCAyXSxcbiAgICAgICAgW1widXpcIiwgXCJVemJla1wiLCBbMSwyXSwgMV0sXG4gICAgICAgIFtcInZpXCIsIFwiVmlldG5hbWVzZVwiLFsxXSwgM10sXG4gICAgICAgIFtcIndhXCIsIFwiV2FsbG9vblwiLCBbMSwyXSwgMV0sXG4gICAgICAgIFtcIndvXCIsIFwiV29sb2ZcIiwgWzFdLCAzXSxcbiAgICAgICAgW1wieW9cIiwgXCJZb3J1YmFcIiwgWzEsMl0sIDJdLFxuICAgICAgICBbXCJ6aFwiLCBcIkNoaW5lc2VcIiwgWzFdLCAzXVxuICAgIF07XG5cbiAgICB2YXIgX3J1bGVzUGx1cmFsc1R5cGVzID0ge1xuICAgICAgICAxOiBmdW5jdGlvbihuKSB7cmV0dXJuIE51bWJlcihuID4gMSk7fSxcbiAgICAgICAgMjogZnVuY3Rpb24obikge3JldHVybiBOdW1iZXIobiAhPSAxKTt9LFxuICAgICAgICAzOiBmdW5jdGlvbihuKSB7cmV0dXJuIDA7fSxcbiAgICAgICAgNDogZnVuY3Rpb24obikge3JldHVybiBOdW1iZXIobiUxMD09MSAmJiBuJTEwMCE9MTEgPyAwIDogbiUxMD49MiAmJiBuJTEwPD00ICYmIChuJTEwMDwxMCB8fCBuJTEwMD49MjApID8gMSA6IDIpO30sXG4gICAgICAgIDU6IGZ1bmN0aW9uKG4pIHtyZXR1cm4gTnVtYmVyKG49PT0wID8gMCA6IG49PTEgPyAxIDogbj09MiA/IDIgOiBuJTEwMD49MyAmJiBuJTEwMDw9MTAgPyAzIDogbiUxMDA+PTExID8gNCA6IDUpO30sXG4gICAgICAgIDY6IGZ1bmN0aW9uKG4pIHtyZXR1cm4gTnVtYmVyKChuPT0xKSA/IDAgOiAobj49MiAmJiBuPD00KSA/IDEgOiAyKTt9LFxuICAgICAgICA3OiBmdW5jdGlvbihuKSB7cmV0dXJuIE51bWJlcihuPT0xID8gMCA6IG4lMTA+PTIgJiYgbiUxMDw9NCAmJiAobiUxMDA8MTAgfHwgbiUxMDA+PTIwKSA/IDEgOiAyKTt9LFxuICAgICAgICA4OiBmdW5jdGlvbihuKSB7cmV0dXJuIE51bWJlcigobj09MSkgPyAwIDogKG49PTIpID8gMSA6IChuICE9IDggJiYgbiAhPSAxMSkgPyAyIDogMyk7fSxcbiAgICAgICAgOTogZnVuY3Rpb24obikge3JldHVybiBOdW1iZXIobiA+PSAyKTt9LFxuICAgICAgICAxMDogZnVuY3Rpb24obikge3JldHVybiBOdW1iZXIobj09MSA/IDAgOiBuPT0yID8gMSA6IG48NyA/IDIgOiBuPDExID8gMyA6IDQpIDt9LFxuICAgICAgICAxMTogZnVuY3Rpb24obikge3JldHVybiBOdW1iZXIoKG49PTEgfHwgbj09MTEpID8gMCA6IChuPT0yIHx8IG49PTEyKSA/IDEgOiAobiA+IDIgJiYgbiA8IDIwKSA/IDIgOiAzKTt9LFxuICAgICAgICAxMjogZnVuY3Rpb24obikge3JldHVybiBOdW1iZXIobiUxMCE9MSB8fCBuJTEwMD09MTEpO30sXG4gICAgICAgIDEzOiBmdW5jdGlvbihuKSB7cmV0dXJuIE51bWJlcihuICE9PSAwKTt9LFxuICAgICAgICAxNDogZnVuY3Rpb24obikge3JldHVybiBOdW1iZXIoKG49PTEpID8gMCA6IChuPT0yKSA/IDEgOiAobiA9PSAzKSA/IDIgOiAzKTt9LFxuICAgICAgICAxNTogZnVuY3Rpb24obikge3JldHVybiBOdW1iZXIobiUxMD09MSAmJiBuJTEwMCE9MTEgPyAwIDogbiUxMD49MiAmJiAobiUxMDA8MTAgfHwgbiUxMDA+PTIwKSA/IDEgOiAyKTt9LFxuICAgICAgICAxNjogZnVuY3Rpb24obikge3JldHVybiBOdW1iZXIobiUxMD09MSAmJiBuJTEwMCE9MTEgPyAwIDogbiAhPT0gMCA/IDEgOiAyKTt9LFxuICAgICAgICAxNzogZnVuY3Rpb24obikge3JldHVybiBOdW1iZXIobj09MSB8fCBuJTEwPT0xID8gMCA6IDEpO30sXG4gICAgICAgIDE4OiBmdW5jdGlvbihuKSB7cmV0dXJuIE51bWJlcigwID8gMCA6IG49PTEgPyAxIDogMik7fSxcbiAgICAgICAgMTk6IGZ1bmN0aW9uKG4pIHtyZXR1cm4gTnVtYmVyKG49PTEgPyAwIDogbj09PTAgfHwgKCBuJTEwMD4xICYmIG4lMTAwPDExKSA/IDEgOiAobiUxMDA+MTAgJiYgbiUxMDA8MjAgKSA/IDIgOiAzKTt9LFxuICAgICAgICAyMDogZnVuY3Rpb24obikge3JldHVybiBOdW1iZXIobj09MSA/IDAgOiAobj09PTAgfHwgKG4lMTAwID4gMCAmJiBuJTEwMCA8IDIwKSkgPyAxIDogMik7fSxcbiAgICAgICAgMjE6IGZ1bmN0aW9uKG4pIHtyZXR1cm4gTnVtYmVyKG4lMTAwPT0xID8gMSA6IG4lMTAwPT0yID8gMiA6IG4lMTAwPT0zIHx8IG4lMTAwPT00ID8gMyA6IDApOyB9XG4gICAgfTtcblxuICAgIHZhciBwbHVyYWxFeHRlbnNpb25zID0ge1xuXG4gICAgICAgIHJ1bGVzOiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGwsIHJ1bGVzID0ge307XG4gICAgICAgICAgICBmb3IgKGw9X3J1bGVzLmxlbmd0aDsgbC0tIDspIHtcbiAgICAgICAgICAgICAgICBydWxlc1tfcnVsZXNbbF1bMF1dID0ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBfcnVsZXNbbF1bMV0sXG4gICAgICAgICAgICAgICAgICAgIG51bWJlcnM6IF9ydWxlc1tsXVsyXSxcbiAgICAgICAgICAgICAgICAgICAgcGx1cmFsczogX3J1bGVzUGx1cmFsc1R5cGVzW19ydWxlc1tsXVszXV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnVsZXM7XG4gICAgICAgIH0oKSksXG5cbiAgICAgICAgLy8geW91IGNhbiBhZGQgeW91ciBvd24gcGx1cmFsRXh0ZW5zaW9uc1xuICAgICAgICBhZGRSdWxlOiBmdW5jdGlvbihsbmcsIG9iaikge1xuICAgICAgICAgICAgcGx1cmFsRXh0ZW5zaW9ucy5ydWxlc1tsbmddID0gb2JqO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldEN1cnJlbnRMbmc6IGZ1bmN0aW9uKGxuZykge1xuICAgICAgICAgICAgaWYgKCFwbHVyYWxFeHRlbnNpb25zLmN1cnJlbnRSdWxlIHx8IHBsdXJhbEV4dGVuc2lvbnMuY3VycmVudFJ1bGUubG5nICE9PSBsbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBsbmcuc3BsaXQoJy0nKTtcblxuICAgICAgICAgICAgICAgIHBsdXJhbEV4dGVuc2lvbnMuY3VycmVudFJ1bGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxuZzogbG5nLFxuICAgICAgICAgICAgICAgICAgICBydWxlOiBwbHVyYWxFeHRlbnNpb25zLnJ1bGVzW3BhcnRzWzBdXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbmVlZHNQbHVyYWw6IGZ1bmN0aW9uKGxuZywgY291bnQpIHtcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IGxuZy5zcGxpdCgnLScpO1xuXG4gICAgICAgICAgICB2YXIgZXh0O1xuICAgICAgICAgICAgaWYgKHBsdXJhbEV4dGVuc2lvbnMuY3VycmVudFJ1bGUgJiYgcGx1cmFsRXh0ZW5zaW9ucy5jdXJyZW50UnVsZS5sbmcgPT09IGxuZykge1xuICAgICAgICAgICAgICAgIGV4dCA9IHBsdXJhbEV4dGVuc2lvbnMuY3VycmVudFJ1bGUucnVsZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXh0ID0gcGx1cmFsRXh0ZW5zaW9ucy5ydWxlc1twYXJ0c1tmLmdldENvdW50eUluZGV4T2ZMbmcobG5nKV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXh0ICYmIGV4dC5udW1iZXJzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQobG5nLCBjb3VudCkgIT09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbihsbmcsIGNvdW50KSB7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBsbmcuc3BsaXQoJy0nKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0UmVzdWx0KGwsIGMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXh0O1xuICAgICAgICAgICAgICAgIGlmIChwbHVyYWxFeHRlbnNpb25zLmN1cnJlbnRSdWxlICYmIHBsdXJhbEV4dGVuc2lvbnMuY3VycmVudFJ1bGUubG5nID09PSBsbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0ID0gcGx1cmFsRXh0ZW5zaW9ucy5jdXJyZW50UnVsZS5ydWxlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dCA9IHBsdXJhbEV4dGVuc2lvbnMucnVsZXNbbF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHQubm9BYnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBleHQucGx1cmFscyhjKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBleHQucGx1cmFscyhNYXRoLmFicyhjKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtYmVyID0gZXh0Lm51bWJlcnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHQubnVtYmVycy5sZW5ndGggPT09IDIgJiYgZXh0Lm51bWJlcnNbMF0gPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudW1iZXIgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXIgPSAtMTsgLy8gcmVndWxhciBwbHVyYWxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtYmVyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyID0gMTsgLy8gc2luZ3VsYXJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfS8vY29uc29sZS5sb2coY291bnQgKyAnLScgKyBudW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjID09PSAxID8gJzEnIDogJy0xJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBnZXRSZXN1bHQocGFydHNbZi5nZXRDb3VudHlJbmRleE9mTG5nKGxuZyldLCBjb3VudCk7XG4gICAgICAgIH1cblxuICAgIH07XG4gICAgdmFyIHBvc3RQcm9jZXNzb3JzID0ge307XG4gICAgdmFyIGFkZFBvc3RQcm9jZXNzb3IgPSBmdW5jdGlvbihuYW1lLCBmYykge1xuICAgICAgICBwb3N0UHJvY2Vzc29yc1tuYW1lXSA9IGZjO1xuICAgIH07XG4gICAgLy8gc3ByaW50ZiBzdXBwb3J0XG4gICAgdmFyIHNwcmludGYgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIGdldF90eXBlKHZhcmlhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhcmlhYmxlKS5zbGljZSg4LCAtMSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdHJfcmVwZWF0KGlucHV0LCBtdWx0aXBsaWVyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBvdXRwdXQgPSBbXTsgbXVsdGlwbGllciA+IDA7IG91dHB1dFstLW11bHRpcGxpZXJdID0gaW5wdXQpIHsvKiBkbyBub3RoaW5nICovfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdHJfZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIXN0cl9mb3JtYXQuY2FjaGUuaGFzT3duUHJvcGVydHkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICAgICAgICAgIHN0cl9mb3JtYXQuY2FjaGVbYXJndW1lbnRzWzBdXSA9IHN0cl9mb3JtYXQucGFyc2UoYXJndW1lbnRzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHJfZm9ybWF0LmZvcm1hdC5jYWxsKG51bGwsIHN0cl9mb3JtYXQuY2FjaGVbYXJndW1lbnRzWzBdXSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzdHJfZm9ybWF0LmZvcm1hdCA9IGZ1bmN0aW9uKHBhcnNlX3RyZWUsIGFyZ3YpIHtcbiAgICAgICAgICAgIHZhciBjdXJzb3IgPSAxLCB0cmVlX2xlbmd0aCA9IHBhcnNlX3RyZWUubGVuZ3RoLCBub2RlX3R5cGUgPSAnJywgYXJnLCBvdXRwdXQgPSBbXSwgaSwgaywgbWF0Y2gsIHBhZCwgcGFkX2NoYXJhY3RlciwgcGFkX2xlbmd0aDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0cmVlX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbm9kZV90eXBlID0gZ2V0X3R5cGUocGFyc2VfdHJlZVtpXSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVfdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gocGFyc2VfdHJlZVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGVfdHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHBhcnNlX3RyZWVbaV07IC8vIGNvbnZlbmllbmNlIHB1cnBvc2VzIG9ubHlcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoWzJdKSB7IC8vIGtleXdvcmQgYXJndW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3ZbY3Vyc29yXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBtYXRjaFsyXS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXJnLmhhc093blByb3BlcnR5KG1hdGNoWzJdW2tdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyhzcHJpbnRmKCdbc3ByaW50Zl0gcHJvcGVydHkgXCIlc1wiIGRvZXMgbm90IGV4aXN0JywgbWF0Y2hbMl1ba10pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJnW21hdGNoWzJdW2tdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXRjaFsxXSkgeyAvLyBwb3NpdGlvbmFsIGFyZ3VtZW50IChleHBsaWNpdClcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3ZbbWF0Y2hbMV1dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBwb3NpdGlvbmFsIGFyZ3VtZW50IChpbXBsaWNpdClcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3ZbY3Vyc29yKytdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKC9bXnNdLy50ZXN0KG1hdGNoWzhdKSAmJiAoZ2V0X3R5cGUoYXJnKSAhPSAnbnVtYmVyJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93KHNwcmludGYoJ1tzcHJpbnRmXSBleHBlY3RpbmcgbnVtYmVyIGJ1dCBmb3VuZCAlcycsIGdldF90eXBlKGFyZykpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG1hdGNoWzhdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdiJzogYXJnID0gYXJnLnRvU3RyaW5nKDIpOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2MnOiBhcmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGFyZyk7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZCc6IGFyZyA9IHBhcnNlSW50KGFyZywgMTApOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2UnOiBhcmcgPSBtYXRjaFs3XSA/IGFyZy50b0V4cG9uZW50aWFsKG1hdGNoWzddKSA6IGFyZy50b0V4cG9uZW50aWFsKCk7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZic6IGFyZyA9IG1hdGNoWzddID8gcGFyc2VGbG9hdChhcmcpLnRvRml4ZWQobWF0Y2hbN10pIDogcGFyc2VGbG9hdChhcmcpOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ28nOiBhcmcgPSBhcmcudG9TdHJpbmcoOCk7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncyc6IGFyZyA9ICgoYXJnID0gU3RyaW5nKGFyZykpICYmIG1hdGNoWzddID8gYXJnLnN1YnN0cmluZygwLCBtYXRjaFs3XSkgOiBhcmcpOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3UnOiBhcmcgPSBNYXRoLmFicyhhcmcpOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3gnOiBhcmcgPSBhcmcudG9TdHJpbmcoMTYpOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1gnOiBhcmcgPSBhcmcudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFyZyA9ICgvW2RlZl0vLnRlc3QobWF0Y2hbOF0pICYmIG1hdGNoWzNdICYmIGFyZyA+PSAwID8gJysnKyBhcmcgOiBhcmcpO1xuICAgICAgICAgICAgICAgICAgICBwYWRfY2hhcmFjdGVyID0gbWF0Y2hbNF0gPyBtYXRjaFs0XSA9PSAnMCcgPyAnMCcgOiBtYXRjaFs0XS5jaGFyQXQoMSkgOiAnICc7XG4gICAgICAgICAgICAgICAgICAgIHBhZF9sZW5ndGggPSBtYXRjaFs2XSAtIFN0cmluZyhhcmcpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgcGFkID0gbWF0Y2hbNl0gPyBzdHJfcmVwZWF0KHBhZF9jaGFyYWN0ZXIsIHBhZF9sZW5ndGgpIDogJyc7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKG1hdGNoWzVdID8gYXJnICsgcGFkIDogcGFkICsgYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHN0cl9mb3JtYXQuY2FjaGUgPSB7fTtcblxuICAgICAgICBzdHJfZm9ybWF0LnBhcnNlID0gZnVuY3Rpb24oZm10KSB7XG4gICAgICAgICAgICB2YXIgX2ZtdCA9IGZtdCwgbWF0Y2ggPSBbXSwgcGFyc2VfdHJlZSA9IFtdLCBhcmdfbmFtZXMgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKF9mbXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoKG1hdGNoID0gL15bXlxceDI1XSsvLmV4ZWMoX2ZtdCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlX3RyZWUucHVzaChtYXRjaFswXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChtYXRjaCA9IC9eXFx4MjV7Mn0vLmV4ZWMoX2ZtdCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlX3RyZWUucHVzaCgnJScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgobWF0Y2ggPSAvXlxceDI1KD86KFsxLTldXFxkKilcXCR8XFwoKFteXFwpXSspXFwpKT8oXFwrKT8oMHwnW14kXSk/KC0pPyhcXGQrKT8oPzpcXC4oXFxkKykpPyhbYi1mb3N1eFhdKS8uZXhlYyhfZm10KSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoWzJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdfbmFtZXMgfD0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZF9saXN0ID0gW10sIHJlcGxhY2VtZW50X2ZpZWxkID0gbWF0Y2hbMl0sIGZpZWxkX21hdGNoID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGZpZWxkX21hdGNoID0gL14oW2Etel9dW2Etel9cXGRdKikvaS5leGVjKHJlcGxhY2VtZW50X2ZpZWxkKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZF9saXN0LnB1c2goZmllbGRfbWF0Y2hbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgocmVwbGFjZW1lbnRfZmllbGQgPSByZXBsYWNlbWVudF9maWVsZC5zdWJzdHJpbmcoZmllbGRfbWF0Y2hbMF0ubGVuZ3RoKSkgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZmllbGRfbWF0Y2ggPSAvXlxcLihbYS16X11bYS16X1xcZF0qKS9pLmV4ZWMocmVwbGFjZW1lbnRfZmllbGQpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRfbGlzdC5wdXNoKGZpZWxkX21hdGNoWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgoZmllbGRfbWF0Y2ggPSAvXlxcWyhcXGQrKVxcXS8uZXhlYyhyZXBsYWNlbWVudF9maWVsZCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZF9saXN0LnB1c2goZmllbGRfbWF0Y2hbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3coJ1tzcHJpbnRmXSBodWg/Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdygnW3NwcmludGZdIGh1aD8nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzJdID0gZmllbGRfbGlzdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ19uYW1lcyB8PSAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdfbmFtZXMgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93KCdbc3ByaW50Zl0gbWl4aW5nIHBvc2l0aW9uYWwgYW5kIG5hbWVkIHBsYWNlaG9sZGVycyBpcyBub3QgKHlldCkgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VfdHJlZS5wdXNoKG1hdGNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93KCdbc3ByaW50Zl0gaHVoPycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfZm10ID0gX2ZtdC5zdWJzdHJpbmcobWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJzZV90cmVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzdHJfZm9ybWF0O1xuICAgIH0pKCk7XG5cbiAgICB2YXIgdnNwcmludGYgPSBmdW5jdGlvbihmbXQsIGFyZ3YpIHtcbiAgICAgICAgYXJndi51bnNoaWZ0KGZtdCk7XG4gICAgICAgIHJldHVybiBzcHJpbnRmLmFwcGx5KG51bGwsIGFyZ3YpO1xuICAgIH07XG5cbiAgICBhZGRQb3N0UHJvY2Vzc29yKFwic3ByaW50ZlwiLCBmdW5jdGlvbih2YWwsIGtleSwgb3B0cykge1xuICAgICAgICBpZiAoIW9wdHMuc3ByaW50ZikgcmV0dXJuIHZhbDtcblxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseShvcHRzLnNwcmludGYpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgICAgICByZXR1cm4gdnNwcmludGYodmFsLCBvcHRzLnNwcmludGYpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRzLnNwcmludGYgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gc3ByaW50Zih2YWwsIG9wdHMuc3ByaW50Zik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0pO1xuICAgIC8vIHB1YmxpYyBhcGkgaW50ZXJmYWNlXG4gICAgaTE4bi5pbml0ID0gaW5pdDtcbiAgICBpMThuLnNldExuZyA9IHNldExuZztcbiAgICBpMThuLnByZWxvYWQgPSBwcmVsb2FkO1xuICAgIGkxOG4uYWRkUmVzb3VyY2VCdW5kbGUgPSBhZGRSZXNvdXJjZUJ1bmRsZTtcbiAgICBpMThuLmhhc1Jlc291cmNlQnVuZGxlID0gaGFzUmVzb3VyY2VCdW5kbGU7XG4gICAgaTE4bi5nZXRSZXNvdXJjZUJ1bmRsZSA9IGdldFJlc291cmNlQnVuZGxlO1xuICAgIGkxOG4uYWRkUmVzb3VyY2UgPSBhZGRSZXNvdXJjZTtcbiAgICBpMThuLmFkZFJlc291cmNlcyA9IGFkZFJlc291cmNlcztcbiAgICBpMThuLnJlbW92ZVJlc291cmNlQnVuZGxlID0gcmVtb3ZlUmVzb3VyY2VCdW5kbGU7XG4gICAgaTE4bi5sb2FkTmFtZXNwYWNlID0gbG9hZE5hbWVzcGFjZTtcbiAgICBpMThuLmxvYWROYW1lc3BhY2VzID0gbG9hZE5hbWVzcGFjZXM7XG4gICAgaTE4bi5zZXREZWZhdWx0TmFtZXNwYWNlID0gc2V0RGVmYXVsdE5hbWVzcGFjZTtcbiAgICBpMThuLnQgPSB0cmFuc2xhdGU7XG4gICAgaTE4bi50cmFuc2xhdGUgPSB0cmFuc2xhdGU7XG4gICAgaTE4bi5leGlzdHMgPSBleGlzdHM7XG4gICAgaTE4bi5kZXRlY3RMYW5ndWFnZSA9IGYuZGV0ZWN0TGFuZ3VhZ2U7XG4gICAgaTE4bi5wbHVyYWxFeHRlbnNpb25zID0gcGx1cmFsRXh0ZW5zaW9ucztcbiAgICBpMThuLnN5bmMgPSBzeW5jO1xuICAgIGkxOG4uZnVuY3Rpb25zID0gZjtcbiAgICBpMThuLmxuZyA9IGxuZztcbiAgICBpMThuLmFkZFBvc3RQcm9jZXNzb3IgPSBhZGRQb3N0UHJvY2Vzc29yO1xuICAgIGkxOG4uYXBwbHlSZXBsYWNlbWVudCA9IGYuYXBwbHlSZXBsYWNlbWVudDtcbiAgICBpMThuLm9wdGlvbnMgPSBvO1xuXG59KSh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBleHBvcnRzKTtcbiIsIi8qISBqcXVlcnkuYXR3aG8gLSB2MC40LjcgLSAyMDE0LTAyLTIyXG4qIENvcHlyaWdodCAoYykgMjAxNCBjaG9yZC5sdW8gPGNob3JkLmx1b0BnbWFpbC5jb20+OyBcbiogaG9tZXBhZ2U6IGh0dHA6Ly9pY2hvcmQuZ2l0aHViLmNvbS9BdC5qcyBcbiogTGljZW5zZWQgTUlUXG4qL1xuXG4oZnVuY3Rpb24oKSB7XG4gIChmdW5jdGlvbihmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgcmV0dXJuIGRlZmluZShbJ2pxdWVyeSddLCBmYWN0b3J5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhY3Rvcnkod2luZG93LmpRdWVyeSk7XG4gICAgfVxuICB9KShmdW5jdGlvbigkKSB7XG5cbnZhciAkQ09OVEFJTkVSLCBBcGksIEFwcCwgQXR3aG8sIENvbnRyb2xsZXIsIERFRkFVTFRfQ0FMTEJBQ0tTLCBLRVlfQ09ERSwgTW9kZWwsIFZpZXcsXG4gIF9fc2xpY2UgPSBbXS5zbGljZTtcblxuQXBwID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBBcHAoaW5wdXRvcikge1xuICAgIHRoaXMuY3VycmVudF9mbGFnID0gbnVsbDtcbiAgICB0aGlzLmNvbnRyb2xsZXJzID0ge307XG4gICAgdGhpcy5hbGlhc19tYXBzID0ge307XG4gICAgdGhpcy4kaW5wdXRvciA9ICQoaW5wdXRvcik7XG4gICAgdGhpcy5saXN0ZW4oKTtcbiAgfVxuXG4gIEFwcC5wcm90b3R5cGUuY29udHJvbGxlciA9IGZ1bmN0aW9uKGF0KSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJvbGxlcnNbdGhpcy5hbGlhc19tYXBzW2F0XSB8fCBhdCB8fCB0aGlzLmN1cnJlbnRfZmxhZ107XG4gIH07XG5cbiAgQXBwLnByb3RvdHlwZS5zZXRfY29udGV4dF9mb3IgPSBmdW5jdGlvbihhdCkge1xuICAgIHRoaXMuY3VycmVudF9mbGFnID0gYXQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQXBwLnByb3RvdHlwZS5yZWcgPSBmdW5jdGlvbihmbGFnLCBzZXR0aW5nKSB7XG4gICAgdmFyIGNvbnRyb2xsZXIsIF9iYXNlO1xuICAgIGNvbnRyb2xsZXIgPSAoX2Jhc2UgPSB0aGlzLmNvbnRyb2xsZXJzKVtmbGFnXSB8fCAoX2Jhc2VbZmxhZ10gPSBuZXcgQ29udHJvbGxlcih0aGlzLCBmbGFnKSk7XG4gICAgaWYgKHNldHRpbmcuYWxpYXMpIHtcbiAgICAgIHRoaXMuYWxpYXNfbWFwc1tzZXR0aW5nLmFsaWFzXSA9IGZsYWc7XG4gICAgfVxuICAgIGNvbnRyb2xsZXIuaW5pdChzZXR0aW5nKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBBcHAucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiRpbnB1dG9yLm9uKCdrZXl1cC5hdHdob0lubmVyJywgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgICByZXR1cm4gX3RoaXMub25fa2V5dXAoZSk7XG4gICAgICB9O1xuICAgIH0pKHRoaXMpKS5vbigna2V5ZG93bi5hdHdob0lubmVyJywgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgICByZXR1cm4gX3RoaXMub25fa2V5ZG93bihlKTtcbiAgICAgIH07XG4gICAgfSkodGhpcykpLm9uKCdzY3JvbGwuYXR3aG9Jbm5lcicsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIF9yZWY7XG4gICAgICAgIHJldHVybiAoX3JlZiA9IF90aGlzLmNvbnRyb2xsZXIoKSkgIT0gbnVsbCA/IF9yZWYudmlldy5oaWRlKCkgOiB2b2lkIDA7XG4gICAgICB9O1xuICAgIH0pKHRoaXMpKS5vbignYmx1ci5hdHdob0lubmVyJywgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgYztcbiAgICAgICAgaWYgKGMgPSBfdGhpcy5jb250cm9sbGVyKCkpIHtcbiAgICAgICAgICByZXR1cm4gYy52aWV3LmhpZGUoYy5nZXRfb3B0KFwiZGlzcGxheV90aW1lb3V0XCIpKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KSh0aGlzKSk7XG4gIH07XG5cbiAgQXBwLnByb3RvdHlwZS5zaHV0ZG93biA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjLCBfLCBfcmVmO1xuICAgIF9yZWYgPSB0aGlzLmNvbnRyb2xsZXJzO1xuICAgIGZvciAoXyBpbiBfcmVmKSB7XG4gICAgICBjID0gX3JlZltfXTtcbiAgICAgIGMuZGVzdHJveSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4kaW5wdXRvci5vZmYoJy5hdHdob0lubmVyJyk7XG4gIH07XG5cbiAgQXBwLnByb3RvdHlwZS5kaXNwYXRjaCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAkLm1hcCh0aGlzLmNvbnRyb2xsZXJzLCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjKSB7XG4gICAgICAgIGlmIChjLmxvb2tfdXAoKSkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5zZXRfY29udGV4dF9mb3IoYy5hdCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSkodGhpcykpO1xuICB9O1xuXG4gIEFwcC5wcm90b3R5cGUub25fa2V5dXAgPSBmdW5jdGlvbihlKSB7XG4gICAgdmFyIF9yZWY7XG4gICAgc3dpdGNoIChlLmtleUNvZGUpIHtcbiAgICAgIGNhc2UgS0VZX0NPREUuRVNDOlxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmICgoX3JlZiA9IHRoaXMuY29udHJvbGxlcigpKSAhPSBudWxsKSB7XG4gICAgICAgICAgX3JlZi52aWV3LmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgS0VZX0NPREUuRE9XTjpcbiAgICAgIGNhc2UgS0VZX0NPREUuVVA6XG4gICAgICAgICQubm9vcCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goKTtcbiAgICB9XG4gIH07XG5cbiAgQXBwLnByb3RvdHlwZS5vbl9rZXlkb3duID0gZnVuY3Rpb24oZSkge1xuICAgIHZhciB2aWV3LCBfcmVmO1xuICAgIHZpZXcgPSAoX3JlZiA9IHRoaXMuY29udHJvbGxlcigpKSAhPSBudWxsID8gX3JlZi52aWV3IDogdm9pZCAwO1xuICAgIGlmICghKHZpZXcgJiYgdmlldy52aXNpYmxlKCkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAoZS5rZXlDb2RlKSB7XG4gICAgICBjYXNlIEtFWV9DT0RFLkVTQzpcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2aWV3LmhpZGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEtFWV9DT0RFLlVQOlxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZpZXcucHJldigpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgS0VZX0NPREUuRE9XTjpcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2aWV3Lm5leHQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEtFWV9DT0RFLlRBQjpcbiAgICAgIGNhc2UgS0VZX0NPREUuRU5URVI6XG4gICAgICAgIGlmICghdmlldy52aXNpYmxlKCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2aWV3LmNob29zZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgICQubm9vcCgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gQXBwO1xuXG59KSgpO1xuXG5Db250cm9sbGVyID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdXVpZCwgX3V1aWQ7XG5cbiAgX3V1aWQgPSAwO1xuXG4gIHV1aWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gX3V1aWQgKz0gMTtcbiAgfTtcblxuICBmdW5jdGlvbiBDb250cm9sbGVyKGFwcCwgYXQpIHtcbiAgICB0aGlzLmFwcCA9IGFwcDtcbiAgICB0aGlzLmF0ID0gYXQ7XG4gICAgdGhpcy4kaW5wdXRvciA9IHRoaXMuYXBwLiRpbnB1dG9yO1xuICAgIHRoaXMub0RvY3VtZW50ID0gdGhpcy4kaW5wdXRvclswXS5vd25lckRvY3VtZW50O1xuICAgIHRoaXMub1dpbmRvdyA9IHRoaXMub0RvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHRoaXMub0RvY3VtZW50LnBhcmVudFdpbmRvdztcbiAgICB0aGlzLmlkID0gdGhpcy4kaW5wdXRvclswXS5pZCB8fCB1dWlkKCk7XG4gICAgdGhpcy5zZXR0aW5nID0gbnVsbDtcbiAgICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy5jdXJfcmVjdCA9IG51bGw7XG4gICAgdGhpcy5yYW5nZSA9IG51bGw7XG4gICAgJENPTlRBSU5FUi5hcHBlbmQodGhpcy4kZWwgPSAkKFwiPGRpdiBpZD0nYXR3aG8tZ3JvdW5kLVwiICsgdGhpcy5pZCArIFwiJz48L2Rpdj5cIikpO1xuICAgIHRoaXMubW9kZWwgPSBuZXcgTW9kZWwodGhpcyk7XG4gICAgdGhpcy52aWV3ID0gbmV3IFZpZXcodGhpcyk7XG4gIH1cblxuICBDb250cm9sbGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oc2V0dGluZykge1xuICAgIHRoaXMuc2V0dGluZyA9ICQuZXh0ZW5kKHt9LCB0aGlzLnNldHRpbmcgfHwgJC5mbi5hdHdob1tcImRlZmF1bHRcIl0sIHNldHRpbmcpO1xuICAgIHRoaXMudmlldy5pbml0KCk7XG4gICAgcmV0dXJuIHRoaXMubW9kZWwucmVsb2FkKHRoaXMuc2V0dGluZy5kYXRhKTtcbiAgfTtcblxuICBDb250cm9sbGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdiZWZvcmVEZXN0cm95Jyk7XG4gICAgdGhpcy5tb2RlbC5kZXN0cm95KCk7XG4gICAgcmV0dXJuIHRoaXMudmlldy5kZXN0cm95KCk7XG4gIH07XG5cbiAgQ29udHJvbGxlci5wcm90b3R5cGUuY2FsbF9kZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MsIGVycm9yLCBmdW5jX25hbWU7XG4gICAgZnVuY19uYW1lID0gYXJndW1lbnRzWzBdLCBhcmdzID0gMiA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkgOiBbXTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIERFRkFVTFRfQ0FMTEJBQ0tTW2Z1bmNfbmFtZV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICBlcnJvciA9IF9lcnJvcjtcbiAgICAgIHJldHVybiAkLmVycm9yKFwiXCIgKyBlcnJvciArIFwiIE9yIG1heWJlIEF0LmpzIGRvZXNuJ3QgaGF2ZSBmdW5jdGlvbiBcIiArIGZ1bmNfbmFtZSk7XG4gICAgfVxuICB9O1xuXG4gIENvbnRyb2xsZXIucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbihuYW1lLCBkYXRhKSB7XG4gICAgdmFyIGFsaWFzLCBldmVudF9uYW1lO1xuICAgIGlmIChkYXRhID09IG51bGwpIHtcbiAgICAgIGRhdGEgPSBbXTtcbiAgICB9XG4gICAgZGF0YS5wdXNoKHRoaXMpO1xuICAgIGFsaWFzID0gdGhpcy5nZXRfb3B0KCdhbGlhcycpO1xuICAgIGV2ZW50X25hbWUgPSBhbGlhcyA/IFwiXCIgKyBuYW1lICsgXCItXCIgKyBhbGlhcyArIFwiLmF0d2hvXCIgOiBcIlwiICsgbmFtZSArIFwiLmF0d2hvXCI7XG4gICAgcmV0dXJuIHRoaXMuJGlucHV0b3IudHJpZ2dlcihldmVudF9uYW1lLCBkYXRhKTtcbiAgfTtcblxuICBDb250cm9sbGVyLnByb3RvdHlwZS5jYWxsYmFja3MgPSBmdW5jdGlvbihmdW5jX25hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRfb3B0KFwiY2FsbGJhY2tzXCIpW2Z1bmNfbmFtZV0gfHwgREVGQVVMVF9DQUxMQkFDS1NbZnVuY19uYW1lXTtcbiAgfTtcblxuICBDb250cm9sbGVyLnByb3RvdHlwZS5nZXRfb3B0ID0gZnVuY3Rpb24oYXQsIGRlZmF1bHRfdmFsdWUpIHtcbiAgICB2YXIgZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ1thdF07XG4gICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICBlID0gX2Vycm9yO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIENvbnRyb2xsZXIucHJvdG90eXBlLmNvbnRlbnQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy4kaW5wdXRvci5pcygndGV4dGFyZWEsIGlucHV0JykpIHtcbiAgICAgIHJldHVybiB0aGlzLiRpbnB1dG9yLnZhbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy4kaW5wdXRvci50ZXh0KCk7XG4gICAgfVxuICB9O1xuXG4gIENvbnRyb2xsZXIucHJvdG90eXBlLmNhdGNoX3F1ZXJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNhcmV0X3BvcywgY29udGVudCwgZW5kLCBxdWVyeSwgc3RhcnQsIHN1YnRleHQ7XG4gICAgY29udGVudCA9IHRoaXMuY29udGVudCgpO1xuICAgIGNhcmV0X3BvcyA9IHRoaXMuJGlucHV0b3IuY2FyZXQoJ3BvcycpO1xuICAgIHN1YnRleHQgPSBjb250ZW50LnNsaWNlKDAsIGNhcmV0X3Bvcyk7XG4gICAgcXVlcnkgPSB0aGlzLmNhbGxiYWNrcyhcIm1hdGNoZXJcIikuY2FsbCh0aGlzLCB0aGlzLmF0LCBzdWJ0ZXh0LCB0aGlzLmdldF9vcHQoJ3N0YXJ0X3dpdGhfc3BhY2UnKSk7XG4gICAgaWYgKHR5cGVvZiBxdWVyeSA9PT0gXCJzdHJpbmdcIiAmJiBxdWVyeS5sZW5ndGggPD0gdGhpcy5nZXRfb3B0KCdtYXhfbGVuJywgMjApKSB7XG4gICAgICBzdGFydCA9IGNhcmV0X3BvcyAtIHF1ZXJ5Lmxlbmd0aDtcbiAgICAgIGVuZCA9IHN0YXJ0ICsgcXVlcnkubGVuZ3RoO1xuICAgICAgdGhpcy5wb3MgPSBzdGFydDtcbiAgICAgIHF1ZXJ5ID0ge1xuICAgICAgICAndGV4dCc6IHF1ZXJ5LnRvTG93ZXJDYXNlKCksXG4gICAgICAgICdoZWFkX3Bvcyc6IHN0YXJ0LFxuICAgICAgICAnZW5kX3Bvcyc6IGVuZFxuICAgICAgfTtcbiAgICAgIHRoaXMudHJpZ2dlcihcIm1hdGNoZWRcIiwgW3RoaXMuYXQsIHF1ZXJ5LnRleHRdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy52aWV3LmhpZGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgfTtcblxuICBDb250cm9sbGVyLnByb3RvdHlwZS5yZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGMsIHNjYWxlX2JvdHRvbTtcbiAgICBpZiAoIShjID0gdGhpcy4kaW5wdXRvci5jYXJldCgnb2Zmc2V0JywgdGhpcy5wb3MgLSAxKSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuJGlucHV0b3IuYXR0cignY29udGVudEVkaXRhYmxlJykgPT09ICd0cnVlJykge1xuICAgICAgYyA9ICh0aGlzLmN1cl9yZWN0IHx8ICh0aGlzLmN1cl9yZWN0ID0gYykpIHx8IGM7XG4gICAgfVxuICAgIHNjYWxlX2JvdHRvbSA9IGRvY3VtZW50LnNlbGVjdGlvbiA/IDAgOiAyO1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBjLmxlZnQsXG4gICAgICB0b3A6IGMudG9wLFxuICAgICAgYm90dG9tOiBjLnRvcCArIGMuaGVpZ2h0ICsgc2NhbGVfYm90dG9tXG4gICAgfTtcbiAgfTtcblxuICBDb250cm9sbGVyLnByb3RvdHlwZS5yZXNldF9yZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuJGlucHV0b3IuYXR0cignY29udGVudEVkaXRhYmxlJykgPT09ICd0cnVlJykge1xuICAgICAgcmV0dXJuIHRoaXMuY3VyX3JlY3QgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICBDb250cm9sbGVyLnByb3RvdHlwZS5tYXJrX3JhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuJGlucHV0b3IuYXR0cignY29udGVudEVkaXRhYmxlJykgPT09ICd0cnVlJykge1xuICAgICAgaWYgKHRoaXMub1dpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5yYW5nZSA9IHRoaXMub1dpbmRvdy5nZXRTZWxlY3Rpb24oKS5nZXRSYW5nZUF0KDApO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub0RvY3VtZW50LnNlbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5pZThfcmFuZ2UgPSB0aGlzLm9Eb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQ29udHJvbGxlci5wcm90b3R5cGUuaW5zZXJ0X2NvbnRlbnRfZm9yID0gZnVuY3Rpb24oJGxpKSB7XG4gICAgdmFyIGRhdGEsIGRhdGFfdmFsdWUsIHRwbDtcbiAgICBkYXRhX3ZhbHVlID0gJGxpLmRhdGEoJ3ZhbHVlJyk7XG4gICAgdHBsID0gdGhpcy5nZXRfb3B0KCdpbnNlcnRfdHBsJyk7XG4gICAgaWYgKHRoaXMuJGlucHV0b3IuaXMoJ3RleHRhcmVhLCBpbnB1dCcpIHx8ICF0cGwpIHtcbiAgICAgIHJldHVybiBkYXRhX3ZhbHVlO1xuICAgIH1cbiAgICBkYXRhID0gJC5leHRlbmQoe30sICRsaS5kYXRhKCdpdGVtLWRhdGEnKSwge1xuICAgICAgJ2F0d2hvLWRhdGEtdmFsdWUnOiBkYXRhX3ZhbHVlLFxuICAgICAgJ2F0d2hvLWF0JzogdGhpcy5hdFxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmNhbGxiYWNrcyhcInRwbF9ldmFsXCIpLmNhbGwodGhpcywgdHBsLCBkYXRhKTtcbiAgfTtcblxuICBDb250cm9sbGVyLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbihjb250ZW50LCAkbGkpIHtcbiAgICB2YXIgJGlucHV0b3IsICRpbnNlcnRfbm9kZSwgY2xhc3NfbmFtZSwgY29udGVudF9ub2RlLCBpbnNlcnRfbm9kZSwgcG9zLCByYW5nZSwgc2VsLCBzb3VyY2UsIHN0YXJ0X3N0ciwgdGV4dDtcbiAgICAkaW5wdXRvciA9IHRoaXMuJGlucHV0b3I7XG4gICAgaWYgKCRpbnB1dG9yLmF0dHIoJ2NvbnRlbnRFZGl0YWJsZScpID09PSAndHJ1ZScpIHtcbiAgICAgIGNsYXNzX25hbWUgPSBcImF0d2hvLXZpZXctZmxhZyBhdHdoby12aWV3LWZsYWctXCIgKyAodGhpcy5nZXRfb3B0KCdhbGlhcycpIHx8IHRoaXMuYXQpO1xuICAgICAgY29udGVudF9ub2RlID0gXCJcIiArIGNvbnRlbnQgKyBcIjxzcGFuIGNvbnRlbnRlZGl0YWJsZT0nZmFsc2UnPiZuYnNwOzxzcGFuPlwiO1xuICAgICAgaW5zZXJ0X25vZGUgPSBcIjxzcGFuIGNvbnRlbnRlZGl0YWJsZT0nZmFsc2UnIGNsYXNzPSdcIiArIGNsYXNzX25hbWUgKyBcIic+XCIgKyBjb250ZW50X25vZGUgKyBcIjwvc3Bhbj5cIjtcbiAgICAgICRpbnNlcnRfbm9kZSA9ICQoaW5zZXJ0X25vZGUsIHRoaXMub0RvY3VtZW50KS5kYXRhKCdhdHdoby1kYXRhLWl0ZW0nLCAkbGkuZGF0YSgnaXRlbS1kYXRhJykpO1xuICAgICAgaWYgKHRoaXMub0RvY3VtZW50LnNlbGVjdGlvbikge1xuICAgICAgICAkaW5zZXJ0X25vZGUgPSAkKFwiPHNwYW4gY29udGVudGVkaXRhYmxlPSd0cnVlJz48L3NwYW4+XCIsIHRoaXMub0RvY3VtZW50KS5odG1sKCRpbnNlcnRfbm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgkaW5wdXRvci5pcygndGV4dGFyZWEsIGlucHV0JykpIHtcbiAgICAgIGNvbnRlbnQgPSAnJyArIGNvbnRlbnQ7XG4gICAgICBzb3VyY2UgPSAkaW5wdXRvci52YWwoKTtcbiAgICAgIHN0YXJ0X3N0ciA9IHNvdXJjZS5zbGljZSgwLCBNYXRoLm1heCh0aGlzLnF1ZXJ5LmhlYWRfcG9zIC0gdGhpcy5hdC5sZW5ndGgsIDApKTtcbiAgICAgIHRleHQgPSBcIlwiICsgc3RhcnRfc3RyICsgY29udGVudCArIFwiIFwiICsgKHNvdXJjZS5zbGljZSh0aGlzLnF1ZXJ5WydlbmRfcG9zJ10gfHwgMCkpO1xuICAgICAgJGlucHV0b3IudmFsKHRleHQpO1xuICAgICAgJGlucHV0b3IuY2FyZXQoJ3BvcycsIHN0YXJ0X3N0ci5sZW5ndGggKyBjb250ZW50Lmxlbmd0aCArIDEpO1xuICAgIH0gZWxzZSBpZiAocmFuZ2UgPSB0aGlzLnJhbmdlKSB7XG4gICAgICBwb3MgPSByYW5nZS5zdGFydE9mZnNldCAtICh0aGlzLnF1ZXJ5LmVuZF9wb3MgLSB0aGlzLnF1ZXJ5LmhlYWRfcG9zKSAtIHRoaXMuYXQubGVuZ3RoO1xuICAgICAgcmFuZ2Uuc2V0U3RhcnQocmFuZ2UuZW5kQ29udGFpbmVyLCBNYXRoLm1heChwb3MsIDApKTtcbiAgICAgIHJhbmdlLnNldEVuZChyYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCk7XG4gICAgICByYW5nZS5kZWxldGVDb250ZW50cygpO1xuICAgICAgcmFuZ2UuaW5zZXJ0Tm9kZSgkaW5zZXJ0X25vZGVbMF0pO1xuICAgICAgcmFuZ2UuY29sbGFwc2UoZmFsc2UpO1xuICAgICAgc2VsID0gdGhpcy5vV2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgc2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICB9IGVsc2UgaWYgKHJhbmdlID0gdGhpcy5pZThfcmFuZ2UpIHtcbiAgICAgIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgdGhpcy5xdWVyeS5lbmRfcG9zIC0gdGhpcy5xdWVyeS5oZWFkX3BvcyAtIHRoaXMuYXQubGVuZ3RoKTtcbiAgICAgIHJhbmdlLnBhc3RlSFRNTChjb250ZW50X25vZGUpO1xuICAgICAgcmFuZ2UuY29sbGFwc2UoZmFsc2UpO1xuICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgfVxuICAgIGlmICghJGlucHV0b3IuaXMoJzpmb2N1cycpKSB7XG4gICAgICAkaW5wdXRvci5mb2N1cygpO1xuICAgIH1cbiAgICByZXR1cm4gJGlucHV0b3IuY2hhbmdlKCk7XG4gIH07XG5cbiAgQ29udHJvbGxlci5wcm90b3R5cGUucmVuZGVyX3ZpZXcgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIHNlYXJjaF9rZXk7XG4gICAgc2VhcmNoX2tleSA9IHRoaXMuZ2V0X29wdChcInNlYXJjaF9rZXlcIik7XG4gICAgZGF0YSA9IHRoaXMuY2FsbGJhY2tzKFwic29ydGVyXCIpLmNhbGwodGhpcywgdGhpcy5xdWVyeS50ZXh0LCBkYXRhLnNsaWNlKDAsIDEwMDEpLCBzZWFyY2hfa2V5KTtcbiAgICByZXR1cm4gdGhpcy52aWV3LnJlbmRlcihkYXRhLnNsaWNlKDAsIHRoaXMuZ2V0X29wdCgnbGltaXQnKSkpO1xuICB9O1xuXG4gIENvbnRyb2xsZXIucHJvdG90eXBlLmxvb2tfdXAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcXVlcnksIF9jYWxsYmFjaztcbiAgICBpZiAoIShxdWVyeSA9IHRoaXMuY2F0Y2hfcXVlcnkoKSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgX2NhbGxiYWNrID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgaWYgKGRhdGEgJiYgZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcl92aWV3KGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5oaWRlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm1vZGVsLnF1ZXJ5KHF1ZXJ5LnRleHQsICQucHJveHkoX2NhbGxiYWNrLCB0aGlzKSk7XG4gICAgcmV0dXJuIHF1ZXJ5O1xuICB9O1xuXG4gIHJldHVybiBDb250cm9sbGVyO1xuXG59KSgpO1xuXG5Nb2RlbCA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gTW9kZWwoY29udGV4dCkge1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5hdCA9IHRoaXMuY29udGV4dC5hdDtcbiAgICB0aGlzLnN0b3JhZ2UgPSB0aGlzLmNvbnRleHQuJGlucHV0b3I7XG4gIH1cblxuICBNb2RlbC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnN0b3JhZ2UuZGF0YSh0aGlzLmF0LCBudWxsKTtcbiAgfTtcblxuICBNb2RlbC5wcm90b3R5cGUuc2F2ZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaCgpID4gMDtcbiAgfTtcblxuICBNb2RlbC5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbihxdWVyeSwgY2FsbGJhY2spIHtcbiAgICB2YXIgZGF0YSwgc2VhcmNoX2tleSwgX3JlbW90ZV9maWx0ZXI7XG4gICAgZGF0YSA9IHRoaXMuZmV0Y2goKTtcbiAgICBzZWFyY2hfa2V5ID0gdGhpcy5jb250ZXh0LmdldF9vcHQoXCJzZWFyY2hfa2V5XCIpO1xuICAgIGRhdGEgPSB0aGlzLmNvbnRleHQuY2FsbGJhY2tzKCdmaWx0ZXInKS5jYWxsKHRoaXMuY29udGV4dCwgcXVlcnksIGRhdGEsIHNlYXJjaF9rZXkpIHx8IFtdO1xuICAgIF9yZW1vdGVfZmlsdGVyID0gdGhpcy5jb250ZXh0LmNhbGxiYWNrcygncmVtb3RlX2ZpbHRlcicpO1xuICAgIGlmIChkYXRhLmxlbmd0aCA+IDAgfHwgKCFfcmVtb3RlX2ZpbHRlciAmJiBkYXRhLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF9yZW1vdGVfZmlsdGVyLmNhbGwodGhpcy5jb250ZXh0LCBxdWVyeSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfTtcblxuICBNb2RlbC5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlLmRhdGEodGhpcy5hdCkgfHwgW107XG4gIH07XG5cbiAgTW9kZWwucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5kYXRhKHRoaXMuYXQsIHRoaXMuY29udGV4dC5jYWxsYmFja3MoXCJiZWZvcmVfc2F2ZVwiKS5jYWxsKHRoaXMuY29udGV4dCwgZGF0YSB8fCBbXSkpO1xuICB9O1xuXG4gIE1vZGVsLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIGlmICghKHRoaXMuc2F2ZWQoKSB8fCAhZGF0YSkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sb2FkKGRhdGEpO1xuICAgIH1cbiAgfTtcblxuICBNb2RlbC5wcm90b3R5cGUucmVsb2FkID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHJldHVybiB0aGlzLl9sb2FkKGRhdGEpO1xuICB9O1xuXG4gIE1vZGVsLnByb3RvdHlwZS5fbG9hZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiAkLmFqYXgoZGF0YSwge1xuICAgICAgICBkYXRhVHlwZTogXCJqc29uXCJcbiAgICAgIH0pLmRvbmUoKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnNhdmUoZGF0YSk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnNhdmUoZGF0YSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBNb2RlbDtcblxufSkoKTtcblxuVmlldyA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gVmlldyhjb250ZXh0KSB7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLiRlbCA9ICQoXCI8ZGl2IGNsYXNzPSdhdHdoby12aWV3Jz48dWwgY2xhc3M9J2F0d2hvLXZpZXctdWwnPjwvdWw+PC9kaXY+XCIpO1xuICAgIHRoaXMudGltZW91dF9pZCA9IG51bGw7XG4gICAgdGhpcy5jb250ZXh0LiRlbC5hcHBlbmQodGhpcy4kZWwpO1xuICAgIHRoaXMuYmluZF9ldmVudCgpO1xuICB9XG5cbiAgVmlldy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpZDtcbiAgICBpZCA9IHRoaXMuY29udGV4dC5nZXRfb3B0KFwiYWxpYXNcIikgfHwgdGhpcy5jb250ZXh0LmF0LmNoYXJDb2RlQXQoMCk7XG4gICAgcmV0dXJuIHRoaXMuJGVsLmF0dHIoe1xuICAgICAgJ2lkJzogXCJhdC12aWV3LVwiICsgaWRcbiAgICB9KTtcbiAgfTtcblxuICBWaWV3LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuJGVsLnJlbW92ZSgpO1xuICB9O1xuXG4gIFZpZXcucHJvdG90eXBlLmJpbmRfZXZlbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgJG1lbnU7XG4gICAgJG1lbnUgPSB0aGlzLiRlbC5maW5kKCd1bCcpO1xuICAgIHJldHVybiAkbWVudS5vbignbW91c2VlbnRlci5hdHdoby12aWV3JywgJ2xpJywgZnVuY3Rpb24oZSkge1xuICAgICAgJG1lbnUuZmluZCgnLmN1cicpLnJlbW92ZUNsYXNzKCdjdXInKTtcbiAgICAgIHJldHVybiAkKGUuY3VycmVudFRhcmdldCkuYWRkQ2xhc3MoJ2N1cicpO1xuICAgIH0pLm9uKCdjbGljaycsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgX3RoaXMuY2hvb3NlKCk7XG4gICAgICAgIHJldHVybiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9O1xuICAgIH0pKHRoaXMpKTtcbiAgfTtcblxuICBWaWV3LnByb3RvdHlwZS52aXNpYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuJGVsLmlzKFwiOnZpc2libGVcIik7XG4gIH07XG5cbiAgVmlldy5wcm90b3R5cGUuY2hvb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyICRsaSwgY29udGVudDtcbiAgICAkbGkgPSB0aGlzLiRlbC5maW5kKFwiLmN1clwiKTtcbiAgICBjb250ZW50ID0gdGhpcy5jb250ZXh0Lmluc2VydF9jb250ZW50X2ZvcigkbGkpO1xuICAgIHRoaXMuY29udGV4dC5pbnNlcnQodGhpcy5jb250ZXh0LmNhbGxiYWNrcyhcImJlZm9yZV9pbnNlcnRcIikuY2FsbCh0aGlzLmNvbnRleHQsIGNvbnRlbnQsICRsaSksICRsaSk7XG4gICAgdGhpcy5jb250ZXh0LnRyaWdnZXIoXCJpbnNlcnRlZFwiLCBbJGxpXSk7XG4gICAgcmV0dXJuIHRoaXMuaGlkZSgpO1xuICB9O1xuXG4gIFZpZXcucHJvdG90eXBlLnJlcG9zaXRpb24gPSBmdW5jdGlvbihyZWN0KSB7XG4gICAgdmFyIG9mZnNldDtcbiAgICBpZiAocmVjdC5ib3R0b20gKyB0aGlzLiRlbC5oZWlnaHQoKSAtICQod2luZG93KS5zY3JvbGxUb3AoKSA+ICQod2luZG93KS5oZWlnaHQoKSkge1xuICAgICAgcmVjdC5ib3R0b20gPSByZWN0LnRvcCAtIHRoaXMuJGVsLmhlaWdodCgpO1xuICAgIH1cbiAgICBvZmZzZXQgPSB7XG4gICAgICBsZWZ0OiByZWN0LmxlZnQsXG4gICAgICB0b3A6IHJlY3QuYm90dG9tXG4gICAgfTtcbiAgICB0aGlzLiRlbC5vZmZzZXQob2Zmc2V0KTtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LnRyaWdnZXIoXCJyZXBvc2l0aW9uXCIsIFtvZmZzZXRdKTtcbiAgfTtcblxuICBWaWV3LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN1ciwgbmV4dDtcbiAgICBjdXIgPSB0aGlzLiRlbC5maW5kKCcuY3VyJykucmVtb3ZlQ2xhc3MoJ2N1cicpO1xuICAgIG5leHQgPSBjdXIubmV4dCgpO1xuICAgIGlmICghbmV4dC5sZW5ndGgpIHtcbiAgICAgIG5leHQgPSB0aGlzLiRlbC5maW5kKCdsaTpmaXJzdCcpO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dC5hZGRDbGFzcygnY3VyJyk7XG4gIH07XG5cbiAgVmlldy5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdXIsIHByZXY7XG4gICAgY3VyID0gdGhpcy4kZWwuZmluZCgnLmN1cicpLnJlbW92ZUNsYXNzKCdjdXInKTtcbiAgICBwcmV2ID0gY3VyLnByZXYoKTtcbiAgICBpZiAoIXByZXYubGVuZ3RoKSB7XG4gICAgICBwcmV2ID0gdGhpcy4kZWwuZmluZCgnbGk6bGFzdCcpO1xuICAgIH1cbiAgICByZXR1cm4gcHJldi5hZGRDbGFzcygnY3VyJyk7XG4gIH07XG5cbiAgVmlldy5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZWN0O1xuICAgIHRoaXMuY29udGV4dC5tYXJrX3JhbmdlKCk7XG4gICAgaWYgKCF0aGlzLnZpc2libGUoKSkge1xuICAgICAgdGhpcy4kZWwuc2hvdygpO1xuICAgIH1cbiAgICBpZiAocmVjdCA9IHRoaXMuY29udGV4dC5yZWN0KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcG9zaXRpb24ocmVjdCk7XG4gICAgfVxuICB9O1xuXG4gIFZpZXcucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbih0aW1lKSB7XG4gICAgdmFyIGNhbGxiYWNrO1xuICAgIGlmIChpc05hTih0aW1lICYmIHRoaXMudmlzaWJsZSgpKSkge1xuICAgICAgdGhpcy5jb250ZXh0LnJlc2V0X3JlY3QoKTtcbiAgICAgIHJldHVybiB0aGlzLiRlbC5oaWRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuaGlkZSgpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcyk7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0X2lkKTtcbiAgICAgIHJldHVybiB0aGlzLnRpbWVvdXRfaWQgPSBzZXRUaW1lb3V0KGNhbGxiYWNrLCB0aW1lKTtcbiAgICB9XG4gIH07XG5cbiAgVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24obGlzdCkge1xuICAgIHZhciAkbGksICR1bCwgaXRlbSwgbGksIHRwbCwgX2ksIF9sZW47XG4gICAgaWYgKCEoJC5pc0FycmF5KGxpc3QpICYmIGxpc3QubGVuZ3RoID4gMCkpIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiRlbC5maW5kKCd1bCcpLmVtcHR5KCk7XG4gICAgJHVsID0gdGhpcy4kZWwuZmluZCgndWwnKTtcbiAgICB0cGwgPSB0aGlzLmNvbnRleHQuZ2V0X29wdCgndHBsJyk7XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBsaXN0Lmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBpdGVtID0gbGlzdFtfaV07XG4gICAgICBpdGVtID0gJC5leHRlbmQoe30sIGl0ZW0sIHtcbiAgICAgICAgJ2F0d2hvLWF0JzogdGhpcy5jb250ZXh0LmF0XG4gICAgICB9KTtcbiAgICAgIGxpID0gdGhpcy5jb250ZXh0LmNhbGxiYWNrcyhcInRwbF9ldmFsXCIpLmNhbGwodGhpcy5jb250ZXh0LCB0cGwsIGl0ZW0pO1xuICAgICAgJGxpID0gJCh0aGlzLmNvbnRleHQuY2FsbGJhY2tzKFwiaGlnaGxpZ2h0ZXJcIikuY2FsbCh0aGlzLmNvbnRleHQsIGxpLCB0aGlzLmNvbnRleHQucXVlcnkudGV4dCkpO1xuICAgICAgJGxpLmRhdGEoXCJpdGVtLWRhdGFcIiwgaXRlbSk7XG4gICAgICAkdWwuYXBwZW5kKCRsaSk7XG4gICAgfVxuICAgIHRoaXMuc2hvdygpO1xuICAgIHJldHVybiAkdWwuZmluZChcImxpOmZpcnN0XCIpLmFkZENsYXNzKFwiY3VyXCIpO1xuICB9O1xuXG4gIHJldHVybiBWaWV3O1xuXG59KSgpO1xuXG5LRVlfQ09ERSA9IHtcbiAgRE9XTjogNDAsXG4gIFVQOiAzOCxcbiAgRVNDOiAyNyxcbiAgVEFCOiA5LFxuICBFTlRFUjogMTNcbn07XG5cbkRFRkFVTFRfQ0FMTEJBQ0tTID0ge1xuICBiZWZvcmVfc2F2ZTogZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciBpdGVtLCBfaSwgX2xlbiwgX3Jlc3VsdHM7XG4gICAgaWYgKCEkLmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBfcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gZGF0YS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgaXRlbSA9IGRhdGFbX2ldO1xuICAgICAgaWYgKCQuaXNQbGFpbk9iamVjdChpdGVtKSkge1xuICAgICAgICBfcmVzdWx0cy5wdXNoKGl0ZW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3Jlc3VsdHMucHVzaCh7XG4gICAgICAgICAgbmFtZTogaXRlbVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF9yZXN1bHRzO1xuICB9LFxuICBtYXRjaGVyOiBmdW5jdGlvbihmbGFnLCBzdWJ0ZXh0LCBzaG91bGRfc3RhcnRfd2l0aF9zcGFjZSkge1xuICAgIHZhciBtYXRjaCwgcmVnZXhwO1xuICAgIGZsYWcgPSBmbGFnLnJlcGxhY2UoL1tcXC1cXFtcXF1cXC9cXHtcXH1cXChcXClcXCpcXCtcXD9cXC5cXFxcXFxeXFwkXFx8XS9nLCBcIlxcXFwkJlwiKTtcbiAgICBpZiAoc2hvdWxkX3N0YXJ0X3dpdGhfc3BhY2UpIHtcbiAgICAgIGZsYWcgPSAnKD86XnxcXFxccyknICsgZmxhZztcbiAgICB9XG4gICAgcmVnZXhwID0gbmV3IFJlZ0V4cChmbGFnICsgJyhbQS1aYS16MC05X1xcK1xcLV0qKSR8JyArIGZsYWcgKyAnKFteXFxcXHgwMC1cXFxceGZmXSopJCcsICdnaScpO1xuICAgIG1hdGNoID0gcmVnZXhwLmV4ZWMoc3VidGV4dCk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICByZXR1cm4gbWF0Y2hbMl0gfHwgbWF0Y2hbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSxcbiAgZmlsdGVyOiBmdW5jdGlvbihxdWVyeSwgZGF0YSwgc2VhcmNoX2tleSkge1xuICAgIHZhciBpdGVtLCBfaSwgX2xlbiwgX3Jlc3VsdHM7XG4gICAgX3Jlc3VsdHMgPSBbXTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGRhdGEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIGl0ZW0gPSBkYXRhW19pXTtcbiAgICAgIGlmICh+aXRlbVtzZWFyY2hfa2V5XS50b0xvd2VyQ2FzZSgpLmluZGV4T2YocXVlcnkpKSB7XG4gICAgICAgIF9yZXN1bHRzLnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfcmVzdWx0cztcbiAgfSxcbiAgcmVtb3RlX2ZpbHRlcjogbnVsbCxcbiAgc29ydGVyOiBmdW5jdGlvbihxdWVyeSwgaXRlbXMsIHNlYXJjaF9rZXkpIHtcbiAgICB2YXIgaXRlbSwgX2ksIF9sZW4sIF9yZXN1bHRzO1xuICAgIGlmICghcXVlcnkpIHtcbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9XG4gICAgX3Jlc3VsdHMgPSBbXTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGl0ZW1zLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBpdGVtID0gaXRlbXNbX2ldO1xuICAgICAgaXRlbS5hdHdob19vcmRlciA9IGl0ZW1bc2VhcmNoX2tleV0udG9Mb3dlckNhc2UoKS5pbmRleE9mKHF1ZXJ5KTtcbiAgICAgIGlmIChpdGVtLmF0d2hvX29yZGVyID4gLTEpIHtcbiAgICAgICAgX3Jlc3VsdHMucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF9yZXN1bHRzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIGEuYXR3aG9fb3JkZXIgLSBiLmF0d2hvX29yZGVyO1xuICAgIH0pO1xuICB9LFxuICB0cGxfZXZhbDogZnVuY3Rpb24odHBsLCBtYXApIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0cGwucmVwbGFjZSgvXFwkXFx7KFteXFx9XSopXFx9L2csIGZ1bmN0aW9uKHRhZywga2V5LCBwb3MpIHtcbiAgICAgICAgcmV0dXJuIG1hcFtrZXldO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICBlcnJvciA9IF9lcnJvcjtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgfSxcbiAgaGlnaGxpZ2h0ZXI6IGZ1bmN0aW9uKGxpLCBxdWVyeSkge1xuICAgIHZhciByZWdleHA7XG4gICAgaWYgKCFxdWVyeSkge1xuICAgICAgcmV0dXJuIGxpO1xuICAgIH1cbiAgICByZWdleHAgPSBuZXcgUmVnRXhwKFwiPlxcXFxzKihcXFxcdyopKFwiICsgcXVlcnkucmVwbGFjZShcIitcIiwgXCJcXFxcK1wiKSArIFwiKShcXFxcdyopXFxcXHMqPFwiLCAnaWcnKTtcbiAgICByZXR1cm4gbGkucmVwbGFjZShyZWdleHAsIGZ1bmN0aW9uKHN0ciwgJDEsICQyLCAkMykge1xuICAgICAgcmV0dXJuICc+ICcgKyAkMSArICc8c3Ryb25nPicgKyAkMiArICc8L3N0cm9uZz4nICsgJDMgKyAnIDwnO1xuICAgIH0pO1xuICB9LFxuICBiZWZvcmVfaW5zZXJ0OiBmdW5jdGlvbih2YWx1ZSwgJGxpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59O1xuXG5BcGkgPSB7XG4gIGxvYWQ6IGZ1bmN0aW9uKGF0LCBkYXRhKSB7XG4gICAgdmFyIGM7XG4gICAgaWYgKGMgPSB0aGlzLmNvbnRyb2xsZXIoYXQpKSB7XG4gICAgICByZXR1cm4gYy5tb2RlbC5sb2FkKGRhdGEpO1xuICAgIH1cbiAgfSxcbiAgZ2V0SW5zZXJ0ZWRJdGVtc1dpdGhJRHM6IGZ1bmN0aW9uKGF0KSB7XG4gICAgdmFyIGMsIGlkcywgaXRlbXM7XG4gICAgaWYgKCEoYyA9IHRoaXMuY29udHJvbGxlcihhdCkpKSB7XG4gICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgIH1cbiAgICBpZiAoYXQpIHtcbiAgICAgIGF0ID0gXCItXCIgKyAoYy5nZXRfb3B0KCdhbGlhcycpIHx8IGMuYXQpO1xuICAgIH1cbiAgICBpZHMgPSBbXTtcbiAgICBpdGVtcyA9ICQubWFwKHRoaXMuJGlucHV0b3IuZmluZChcInNwYW4uYXR3aG8tdmlldy1mbGFnXCIgKyAoYXQgfHwgXCJcIikpLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICB2YXIgZGF0YTtcbiAgICAgIGRhdGEgPSAkKGl0ZW0pLmRhdGEoJ2F0d2hvLWRhdGEtaXRlbScpO1xuICAgICAgaWYgKGlkcy5pbmRleE9mKGRhdGEuaWQpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEuaWQpIHtcbiAgICAgICAgaWRzLnB1c2ggPSBkYXRhLmlkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtpZHMsIGl0ZW1zXTtcbiAgfSxcbiAgZ2V0SW5zZXJ0ZWRJdGVtczogZnVuY3Rpb24oYXQpIHtcbiAgICByZXR1cm4gQXBpLmdldEluc2VydGVkSXRlbXNXaXRoSURzLmFwcGx5KHRoaXMsIFthdF0pWzFdO1xuICB9LFxuICBnZXRJbnNlcnRlZElEczogZnVuY3Rpb24oYXQpIHtcbiAgICByZXR1cm4gQXBpLmdldEluc2VydGVkSXRlbXNXaXRoSURzLmFwcGx5KHRoaXMsIFthdF0pWzBdO1xuICB9LFxuICBydW46IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKCk7XG4gIH0sXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2h1dGRvd24oKTtcbiAgICByZXR1cm4gdGhpcy4kaW5wdXRvci5kYXRhKCdhdHdobycsIG51bGwpO1xuICB9XG59O1xuXG5BdHdobyA9IHtcbiAgaW5pdDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciAkdGhpcywgYXBwO1xuICAgIGFwcCA9ICgkdGhpcyA9ICQodGhpcykpLmRhdGEoXCJhdHdob1wiKTtcbiAgICBpZiAoIWFwcCkge1xuICAgICAgJHRoaXMuZGF0YSgnYXR3aG8nLCAoYXBwID0gbmV3IEFwcCh0aGlzKSkpO1xuICAgIH1cbiAgICBhcHAucmVnKG9wdGlvbnMuYXQsIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuXG4kQ09OVEFJTkVSID0gJChcIjxkaXYgaWQ9J2F0d2hvLWNvbnRhaW5lcic+PC9kaXY+XCIpO1xuXG4kLmZuLmF0d2hvID0gZnVuY3Rpb24obWV0aG9kKSB7XG4gIHZhciByZXN1bHQsIF9hcmdzO1xuICBfYXJncyA9IGFyZ3VtZW50cztcbiAgJCgnYm9keScpLmFwcGVuZCgkQ09OVEFJTkVSKTtcbiAgcmVzdWx0ID0gbnVsbDtcbiAgdGhpcy5maWx0ZXIoJ3RleHRhcmVhLCBpbnB1dCwgW2NvbnRlbnRlZGl0YWJsZT10cnVlXScpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFwcDtcbiAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ29iamVjdCcgfHwgIW1ldGhvZCkge1xuICAgICAgcmV0dXJuIEF0d2hvLmluaXQuYXBwbHkodGhpcywgX2FyZ3MpO1xuICAgIH0gZWxzZSBpZiAoQXBpW21ldGhvZF0pIHtcbiAgICAgIGlmIChhcHAgPSAkKHRoaXMpLmRhdGEoJ2F0d2hvJykpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA9IEFwaVttZXRob2RdLmFwcGx5KGFwcCwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoX2FyZ3MsIDEpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICQuZXJyb3IoXCJNZXRob2QgXCIgKyBtZXRob2QgKyBcIiBkb2VzIG5vdCBleGlzdCBvbiBqUXVlcnkuY2FyZXRcIik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdCB8fCB0aGlzO1xufTtcblxuJC5mbi5hdHdob1tcImRlZmF1bHRcIl0gPSB7XG4gIGF0OiB2b2lkIDAsXG4gIGFsaWFzOiB2b2lkIDAsXG4gIGRhdGE6IG51bGwsXG4gIHRwbDogXCI8bGkgZGF0YS12YWx1ZT0nJHthdHdoby1hdH0ke25hbWV9Jz4ke25hbWV9PC9saT5cIixcbiAgaW5zZXJ0X3RwbDogXCI8c3Bhbj4ke2F0d2hvLWRhdGEtdmFsdWV9PC9zcGFuPlwiLFxuICBjYWxsYmFja3M6IERFRkFVTFRfQ0FMTEJBQ0tTLFxuICBzZWFyY2hfa2V5OiBcIm5hbWVcIixcbiAgc3RhcnRfd2l0aF9zcGFjZTogdHJ1ZSxcbiAgbGltaXQ6IDUsXG4gIG1heF9sZW46IDIwLFxuICBkaXNwbGF5X3RpbWVvdXQ6IDMwMFxufTtcblxuICB9KTtcbn0pLmNhbGwodGhpcyk7XG4iLCIvKiEganF1ZXJ5LmNhcmV0IDIwMTQtMDMtMTQgKi9cbihmdW5jdGlvbigpeyFmdW5jdGlvbihhKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcImpxdWVyeVwiXSxhKTphKHdpbmRvdy5qUXVlcnkpfShmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjt2YXIgYixjLGQsZSxmLGcsaCxpLGo7cmV0dXJuIGo9XCJjYXJldFwiLGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGEpe3RoaXMuJGlucHV0b3I9YSx0aGlzLmRvbUlucHV0b3I9dGhpcy4kaW5wdXRvclswXX1yZXR1cm4gYi5wcm90b3R5cGUuc2V0UG9zPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZG9tSW5wdXRvcn0sYi5wcm90b3R5cGUuZ2V0SUVQb3NpdGlvbj1mdW5jdGlvbigpe3JldHVybiBhLm5vb3AoKX0sYi5wcm90b3R5cGUuZ2V0UG9zaXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gYS5ub29wKCl9LGIucHJvdG90eXBlLmdldE9sZElFUG9zPWZ1bmN0aW9uKCl7dmFyIGEsYjtyZXR1cm4gYj1nLnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpLGE9Zy5ib2R5LmNyZWF0ZVRleHRSYW5nZSgpLGEubW92ZVRvRWxlbWVudFRleHQodGhpcy5kb21JbnB1dG9yKSxhLnNldEVuZFBvaW50KFwiRW5kVG9FbmRcIixiKSxhLnRleHQubGVuZ3RofSxiLnByb3RvdHlwZS5nZXRQb3M9ZnVuY3Rpb24oKXt2YXIgYSxiLGM7cmV0dXJuKGM9dGhpcy5yYW5nZSgpKT8oYT1jLmNsb25lUmFuZ2UoKSxhLnNlbGVjdE5vZGVDb250ZW50cyh0aGlzLmRvbUlucHV0b3IpLGEuc2V0RW5kKGMuZW5kQ29udGFpbmVyLGMuZW5kT2Zmc2V0KSxiPWEudG9TdHJpbmcoKS5sZW5ndGgsYS5kZXRhY2goKSxiKTpnLnNlbGVjdGlvbj90aGlzLmdldE9sZElFUG9zKCk6dm9pZCAwfSxiLnByb3RvdHlwZS5nZXRPbGRJRU9mZnNldD1mdW5jdGlvbigpe3ZhciBhLGI7cmV0dXJuIGE9Zy5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKS5kdXBsaWNhdGUoKSxhLm1vdmVTdGFydChcImNoYXJhY3RlclwiLC0xKSxiPWEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkse2hlaWdodDpiLmJvdHRvbS1iLnRvcCxsZWZ0OmIubGVmdCx0b3A6Yi50b3B9fSxiLnByb3RvdHlwZS5nZXRPZmZzZXQ9ZnVuY3Rpb24oKXt2YXIgYixjLGQsZTtpZihpLmdldFNlbGVjdGlvbiYmKGQ9dGhpcy5yYW5nZSgpKSl7aWYoZC5lbmRPZmZzZXQtMTwwKXJldHVybiBudWxsO2I9ZC5jbG9uZVJhbmdlKCksYi5zZXRTdGFydChkLmVuZENvbnRhaW5lcixkLmVuZE9mZnNldC0xKSxiLnNldEVuZChkLmVuZENvbnRhaW5lcixkLmVuZE9mZnNldCksZT1iLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGM9e2hlaWdodDplLmhlaWdodCxsZWZ0OmUubGVmdCtlLndpZHRoLHRvcDplLnRvcH0sYi5kZXRhY2goKX1lbHNlIGcuc2VsZWN0aW9uJiYoYz10aGlzLmdldE9sZElFT2Zmc2V0KCkpO3JldHVybiBjJiYhaCYmKGMudG9wKz1hKGkpLnNjcm9sbFRvcCgpLGMubGVmdCs9YShpKS5zY3JvbGxMZWZ0KCkpLGN9LGIucHJvdG90eXBlLnJhbmdlPWZ1bmN0aW9uKCl7dmFyIGE7aWYoaS5nZXRTZWxlY3Rpb24pcmV0dXJuIGE9aS5nZXRTZWxlY3Rpb24oKSxhLnJhbmdlQ291bnQ+MD9hLmdldFJhbmdlQXQoMCk6bnVsbH0sYn0oKSxjPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihhKXt0aGlzLiRpbnB1dG9yPWEsdGhpcy5kb21JbnB1dG9yPXRoaXMuJGlucHV0b3JbMF19cmV0dXJuIGIucHJvdG90eXBlLmdldElFUG9zPWZ1bmN0aW9uKCl7dmFyIGEsYixjLGQsZSxmLGg7cmV0dXJuIGI9dGhpcy5kb21JbnB1dG9yLGY9Zy5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKSxlPTAsZiYmZi5wYXJlbnRFbGVtZW50KCk9PT1iJiYoZD1iLnZhbHVlLnJlcGxhY2UoL1xcclxcbi9nLFwiXFxuXCIpLGM9ZC5sZW5ndGgsaD1iLmNyZWF0ZVRleHRSYW5nZSgpLGgubW92ZVRvQm9va21hcmsoZi5nZXRCb29rbWFyaygpKSxhPWIuY3JlYXRlVGV4dFJhbmdlKCksYS5jb2xsYXBzZSghMSksZT1oLmNvbXBhcmVFbmRQb2ludHMoXCJTdGFydFRvRW5kXCIsYSk+LTE/YzotaC5tb3ZlU3RhcnQoXCJjaGFyYWN0ZXJcIiwtYykpLGV9LGIucHJvdG90eXBlLmdldFBvcz1mdW5jdGlvbigpe3JldHVybiBnLnNlbGVjdGlvbj90aGlzLmdldElFUG9zKCk6dGhpcy5kb21JbnB1dG9yLnNlbGVjdGlvblN0YXJ0fSxiLnByb3RvdHlwZS5zZXRQb3M9ZnVuY3Rpb24oYSl7dmFyIGIsYztyZXR1cm4gYj10aGlzLmRvbUlucHV0b3IsZy5zZWxlY3Rpb24/KGM9Yi5jcmVhdGVUZXh0UmFuZ2UoKSxjLm1vdmUoXCJjaGFyYWN0ZXJcIixhKSxjLnNlbGVjdCgpKTpiLnNldFNlbGVjdGlvblJhbmdlJiZiLnNldFNlbGVjdGlvblJhbmdlKGEsYSksYn0sYi5wcm90b3R5cGUuZ2V0SUVPZmZzZXQ9ZnVuY3Rpb24oYSl7dmFyIGIsYyxkLGU7cmV0dXJuIGM9dGhpcy5kb21JbnB1dG9yLmNyZWF0ZVRleHRSYW5nZSgpLGF8fChhPXRoaXMuZ2V0UG9zKCkpLGMubW92ZShcImNoYXJhY3RlclwiLGEpLGQ9Yy5ib3VuZGluZ0xlZnQsZT1jLmJvdW5kaW5nVG9wLGI9Yy5ib3VuZGluZ0hlaWdodCx7bGVmdDpkLHRvcDplLGhlaWdodDpifX0sYi5wcm90b3R5cGUuZ2V0T2Zmc2V0PWZ1bmN0aW9uKGIpe3ZhciBjLGQsZTtyZXR1cm4gYz10aGlzLiRpbnB1dG9yLGcuc2VsZWN0aW9uPyhkPXRoaXMuZ2V0SUVPZmZzZXQoYiksZC50b3ArPWEoaSkuc2Nyb2xsVG9wKCkrYy5zY3JvbGxUb3AoKSxkLmxlZnQrPWEoaSkuc2Nyb2xsTGVmdCgpK2Muc2Nyb2xsTGVmdCgpLGQpOihkPWMub2Zmc2V0KCksZT10aGlzLmdldFBvc2l0aW9uKGIpLGQ9e2xlZnQ6ZC5sZWZ0K2UubGVmdC1jLnNjcm9sbExlZnQoKSx0b3A6ZC50b3ArZS50b3AtYy5zY3JvbGxUb3AoKSxoZWlnaHQ6ZS5oZWlnaHR9KX0sYi5wcm90b3R5cGUuZ2V0UG9zaXRpb249ZnVuY3Rpb24oYSl7dmFyIGIsYyxlLGYsZyxoO3JldHVybiBiPXRoaXMuJGlucHV0b3IsZT1mdW5jdGlvbihhKXtyZXR1cm4gYS5yZXBsYWNlKC88L2csXCImbHRcIikucmVwbGFjZSgvPi9nLFwiJmd0XCIpLnJlcGxhY2UoL2AvZyxcIiYjOTZcIikucmVwbGFjZSgvXCIvZyxcIiZxdW90XCIpLnJlcGxhY2UoL1xcclxcbnxcXHJ8XFxuL2csXCI8YnIgLz5cIil9LHZvaWQgMD09PWEmJihhPXRoaXMuZ2V0UG9zKCkpLGg9Yi52YWwoKS5zbGljZSgwLGEpLGY9XCI8c3Bhbj5cIitlKGgpK1wiPC9zcGFuPlwiLGYrPVwiPHNwYW4gaWQ9J2NhcmV0Jz58PC9zcGFuPlwiLGc9bmV3IGQoYiksYz1nLmNyZWF0ZShmKS5yZWN0KCl9LGIucHJvdG90eXBlLmdldElFUG9zaXRpb249ZnVuY3Rpb24oYSl7dmFyIGIsYyxkLGUsZjtyZXR1cm4gZD10aGlzLmdldElFT2Zmc2V0KGEpLGM9dGhpcy4kaW5wdXRvci5vZmZzZXQoKSxlPWQubGVmdC1jLmxlZnQsZj1kLnRvcC1jLnRvcCxiPWQuaGVpZ2h0LHtsZWZ0OmUsdG9wOmYsaGVpZ2h0OmJ9fSxifSgpLGQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGEpe3RoaXMuJGlucHV0b3I9YX1yZXR1cm4gYi5wcm90b3R5cGUuY3NzX2F0dHI9W1wib3ZlcmZsb3dZXCIsXCJoZWlnaHRcIixcIndpZHRoXCIsXCJwYWRkaW5nVG9wXCIsXCJwYWRkaW5nTGVmdFwiLFwicGFkZGluZ1JpZ2h0XCIsXCJwYWRkaW5nQm90dG9tXCIsXCJtYXJnaW5Ub3BcIixcIm1hcmdpbkxlZnRcIixcIm1hcmdpblJpZ2h0XCIsXCJtYXJnaW5Cb3R0b21cIixcImZvbnRGYW1pbHlcIixcImJvcmRlclN0eWxlXCIsXCJib3JkZXJXaWR0aFwiLFwid29yZFdyYXBcIixcImZvbnRTaXplXCIsXCJsaW5lSGVpZ2h0XCIsXCJvdmVyZmxvd1hcIixcInRleHQtYWxpZ25cIl0sYi5wcm90b3R5cGUubWlycm9yQ3NzPWZ1bmN0aW9uKCl7dmFyIGIsYz10aGlzO3JldHVybiBiPXtwb3NpdGlvbjpcImFic29sdXRlXCIsbGVmdDotOTk5OSx0b3A6MCx6SW5kZXg6LTJlNCxcIndoaXRlLXNwYWNlXCI6XCJwcmUtd3JhcFwifSxhLmVhY2godGhpcy5jc3NfYXR0cixmdW5jdGlvbihhLGQpe3JldHVybiBiW2RdPWMuJGlucHV0b3IuY3NzKGQpfSksYn0sYi5wcm90b3R5cGUuY3JlYXRlPWZ1bmN0aW9uKGIpe3JldHVybiB0aGlzLiRtaXJyb3I9YShcIjxkaXY+PC9kaXY+XCIpLHRoaXMuJG1pcnJvci5jc3ModGhpcy5taXJyb3JDc3MoKSksdGhpcy4kbWlycm9yLmh0bWwoYiksdGhpcy4kaW5wdXRvci5hZnRlcih0aGlzLiRtaXJyb3IpLHRoaXN9LGIucHJvdG90eXBlLnJlY3Q9ZnVuY3Rpb24oKXt2YXIgYSxiLGM7cmV0dXJuIGE9dGhpcy4kbWlycm9yLmZpbmQoXCIjY2FyZXRcIiksYj1hLnBvc2l0aW9uKCksYz17bGVmdDpiLmxlZnQsdG9wOmIudG9wLGhlaWdodDphLmhlaWdodCgpfSx0aGlzLiRtaXJyb3IucmVtb3ZlKCksY30sYn0oKSxlPXtjb250ZW50RWRpdGFibGU6ZnVuY3Rpb24oYSl7cmV0dXJuISghYVswXS5jb250ZW50RWRpdGFibGV8fFwidHJ1ZVwiIT09YVswXS5jb250ZW50RWRpdGFibGUpfX0sZj17cG9zOmZ1bmN0aW9uKGEpe3JldHVybiBhfHwwPT09YT90aGlzLnNldFBvcyhhKTp0aGlzLmdldFBvcygpfSxwb3NpdGlvbjpmdW5jdGlvbihhKXtyZXR1cm4gZy5zZWxlY3Rpb24/dGhpcy5nZXRJRVBvc2l0aW9uKGEpOnRoaXMuZ2V0UG9zaXRpb24oYSl9LG9mZnNldDpmdW5jdGlvbihiKXt2YXIgYyxkO3JldHVybiBkPXRoaXMuZ2V0T2Zmc2V0KGIpLGgmJihjPWEoaCkub2Zmc2V0KCksZC50b3ArPWMudG9wLGQubGVmdCs9Yy5sZWZ0KSxkfX0sZz1udWxsLGk9bnVsbCxoPW51bGwsYS5mbi5jYXJldD1mdW5jdGlvbihkKXt2YXIgaixrO2c9dGhpc1swXS5vd25lckRvY3VtZW50LGk9Zy5kZWZhdWx0Vmlld3x8Zy5wYXJlbnRXaW5kb3c7dHJ5e2g9aS5mcmFtZUVsZW1lbnR9Y2F0Y2gobCl7az1sfXJldHVybiBqPWUuY29udGVudEVkaXRhYmxlKHRoaXMpP25ldyBiKHRoaXMpOm5ldyBjKHRoaXMpLGZbZF0/ZltkXS5hcHBseShqLEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKSk6YS5lcnJvcihcIk1ldGhvZCBcIitkK1wiIGRvZXMgbm90IGV4aXN0IG9uIGpRdWVyeS5jYXJldFwiKX0sYS5mbi5jYXJldC5FZGl0YWJsZUNhcmV0PWIsYS5mbi5jYXJldC5JbnB1dENhcmV0PWMsYS5mbi5jYXJldC5VdGlscz1lLGEuZm4uY2FyZXQuYXBpcz1mfSl9KS5jYWxsKHRoaXMpOyIsIi8qKlxuICogbWFya2VkIC0gYSBtYXJrZG93biBwYXJzZXJcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDE0LCBDaHJpc3RvcGhlciBKZWZmcmV5LiAoTUlUIExpY2Vuc2VkKVxuICogaHR0cHM6Ly9naXRodWIuY29tL2NoamovbWFya2VkXG4gKi9cblxuOyhmdW5jdGlvbigpIHtcblxuLyoqXG4gKiBCbG9jay1MZXZlbCBHcmFtbWFyXG4gKi9cblxudmFyIGJsb2NrID0ge1xuICBuZXdsaW5lOiAvXlxcbisvLFxuICBjb2RlOiAvXiggezR9W15cXG5dK1xcbiopKy8sXG4gIGZlbmNlczogbm9vcCxcbiAgaHI6IC9eKCAqWy0qX10pezMsfSAqKD86XFxuK3wkKS8sXG4gIGhlYWRpbmc6IC9eICooI3sxLDZ9KSAqKFteXFxuXSs/KSAqIyogKig/Olxcbit8JCkvLFxuICBucHRhYmxlOiBub29wLFxuICBsaGVhZGluZzogL14oW15cXG5dKylcXG4gKig9fC0pezIsfSAqKD86XFxuK3wkKS8sXG4gIGJsb2NrcXVvdGU6IC9eKCAqPlteXFxuXSsoXFxuKD8hZGVmKVteXFxuXSspKlxcbiopKy8sXG4gIGxpc3Q6IC9eKCAqKShidWxsKSBbXFxzXFxTXSs/KD86aHJ8ZGVmfFxcbnsyLH0oPyEgKSg/IVxcMWJ1bGwgKVxcbip8XFxzKiQpLyxcbiAgaHRtbDogL14gKig/OmNvbW1lbnQgKig/OlxcbnxcXHMqJCl8Y2xvc2VkICooPzpcXG57Mix9fFxccyokKXxjbG9zaW5nICooPzpcXG57Mix9fFxccyokKSkvLFxuICBkZWY6IC9eICpcXFsoW15cXF1dKylcXF06ICo8PyhbXlxccz5dKyk+Pyg/OiArW1wiKF0oW15cXG5dKylbXCIpXSk/ICooPzpcXG4rfCQpLyxcbiAgdGFibGU6IG5vb3AsXG4gIHBhcmFncmFwaDogL14oKD86W15cXG5dK1xcbj8oPyFocnxoZWFkaW5nfGxoZWFkaW5nfGJsb2NrcXVvdGV8dGFnfGRlZikpKylcXG4qLyxcbiAgdGV4dDogL15bXlxcbl0rL1xufTtcblxuYmxvY2suYnVsbGV0ID0gLyg/OlsqKy1dfFxcZCtcXC4pLztcbmJsb2NrLml0ZW0gPSAvXiggKikoYnVsbCkgW15cXG5dKig/Olxcbig/IVxcMWJ1bGwgKVteXFxuXSopKi87XG5ibG9jay5pdGVtID0gcmVwbGFjZShibG9jay5pdGVtLCAnZ20nKVxuICAoL2J1bGwvZywgYmxvY2suYnVsbGV0KVxuICAoKTtcblxuYmxvY2subGlzdCA9IHJlcGxhY2UoYmxvY2subGlzdClcbiAgKC9idWxsL2csIGJsb2NrLmJ1bGxldClcbiAgKCdocicsICdcXFxcbisoPz1cXFxcMT8oPzpbLSpfXSAqKXszLH0oPzpcXFxcbit8JCkpJylcbiAgKCdkZWYnLCAnXFxcXG4rKD89JyArIGJsb2NrLmRlZi5zb3VyY2UgKyAnKScpXG4gICgpO1xuXG5ibG9jay5ibG9ja3F1b3RlID0gcmVwbGFjZShibG9jay5ibG9ja3F1b3RlKVxuICAoJ2RlZicsIGJsb2NrLmRlZilcbiAgKCk7XG5cbmJsb2NrLl90YWcgPSAnKD8hKD86J1xuICArICdhfGVtfHN0cm9uZ3xzbWFsbHxzfGNpdGV8cXxkZm58YWJicnxkYXRhfHRpbWV8Y29kZSdcbiAgKyAnfHZhcnxzYW1wfGtiZHxzdWJ8c3VwfGl8Ynx1fG1hcmt8cnVieXxydHxycHxiZGl8YmRvJ1xuICArICd8c3Bhbnxicnx3YnJ8aW5zfGRlbHxpbWcpXFxcXGIpXFxcXHcrKD8hOi98W15cXFxcd1xcXFxzQF0qQClcXFxcYic7XG5cbmJsb2NrLmh0bWwgPSByZXBsYWNlKGJsb2NrLmh0bWwpXG4gICgnY29tbWVudCcsIC88IS0tW1xcc1xcU10qPy0tPi8pXG4gICgnY2xvc2VkJywgLzwodGFnKVtcXHNcXFNdKz88XFwvXFwxPi8pXG4gICgnY2xvc2luZycsIC88dGFnKD86XCJbXlwiXSpcInwnW14nXSonfFteJ1wiPl0pKj8+LylcbiAgKC90YWcvZywgYmxvY2suX3RhZylcbiAgKCk7XG5cbmJsb2NrLnBhcmFncmFwaCA9IHJlcGxhY2UoYmxvY2sucGFyYWdyYXBoKVxuICAoJ2hyJywgYmxvY2suaHIpXG4gICgnaGVhZGluZycsIGJsb2NrLmhlYWRpbmcpXG4gICgnbGhlYWRpbmcnLCBibG9jay5saGVhZGluZylcbiAgKCdibG9ja3F1b3RlJywgYmxvY2suYmxvY2txdW90ZSlcbiAgKCd0YWcnLCAnPCcgKyBibG9jay5fdGFnKVxuICAoJ2RlZicsIGJsb2NrLmRlZilcbiAgKCk7XG5cbi8qKlxuICogTm9ybWFsIEJsb2NrIEdyYW1tYXJcbiAqL1xuXG5ibG9jay5ub3JtYWwgPSBtZXJnZSh7fSwgYmxvY2spO1xuXG4vKipcbiAqIEdGTSBCbG9jayBHcmFtbWFyXG4gKi9cblxuYmxvY2suZ2ZtID0gbWVyZ2Uoe30sIGJsb2NrLm5vcm1hbCwge1xuICBmZW5jZXM6IC9eICooYHszLH18fnszLH0pICooXFxTKyk/ICpcXG4oW1xcc1xcU10rPylcXHMqXFwxICooPzpcXG4rfCQpLyxcbiAgcGFyYWdyYXBoOiAvXi9cbn0pO1xuXG5ibG9jay5nZm0ucGFyYWdyYXBoID0gcmVwbGFjZShibG9jay5wYXJhZ3JhcGgpXG4gICgnKD8hJywgJyg/ISdcbiAgICArIGJsb2NrLmdmbS5mZW5jZXMuc291cmNlLnJlcGxhY2UoJ1xcXFwxJywgJ1xcXFwyJykgKyAnfCdcbiAgICArIGJsb2NrLmxpc3Quc291cmNlLnJlcGxhY2UoJ1xcXFwxJywgJ1xcXFwzJykgKyAnfCcpXG4gICgpO1xuXG4vKipcbiAqIEdGTSArIFRhYmxlcyBCbG9jayBHcmFtbWFyXG4gKi9cblxuYmxvY2sudGFibGVzID0gbWVyZ2Uoe30sIGJsb2NrLmdmbSwge1xuICBucHRhYmxlOiAvXiAqKFxcUy4qXFx8LiopXFxuICooWy06XSsgKlxcfFstfCA6XSopXFxuKCg/Oi4qXFx8LiooPzpcXG58JCkpKilcXG4qLyxcbiAgdGFibGU6IC9eICpcXHwoLispXFxuICpcXHwoICpbLTpdK1stfCA6XSopXFxuKCg/OiAqXFx8LiooPzpcXG58JCkpKilcXG4qL1xufSk7XG5cbi8qKlxuICogQmxvY2sgTGV4ZXJcbiAqL1xuXG5mdW5jdGlvbiBMZXhlcihvcHRpb25zKSB7XG4gIHRoaXMudG9rZW5zID0gW107XG4gIHRoaXMudG9rZW5zLmxpbmtzID0ge307XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgbWFya2VkLmRlZmF1bHRzO1xuICB0aGlzLnJ1bGVzID0gYmxvY2subm9ybWFsO1xuXG4gIGlmICh0aGlzLm9wdGlvbnMuZ2ZtKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50YWJsZXMpIHtcbiAgICAgIHRoaXMucnVsZXMgPSBibG9jay50YWJsZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucnVsZXMgPSBibG9jay5nZm07XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRXhwb3NlIEJsb2NrIFJ1bGVzXG4gKi9cblxuTGV4ZXIucnVsZXMgPSBibG9jaztcblxuLyoqXG4gKiBTdGF0aWMgTGV4IE1ldGhvZFxuICovXG5cbkxleGVyLmxleCA9IGZ1bmN0aW9uKHNyYywgb3B0aW9ucykge1xuICB2YXIgbGV4ZXIgPSBuZXcgTGV4ZXIob3B0aW9ucyk7XG4gIHJldHVybiBsZXhlci5sZXgoc3JjKTtcbn07XG5cbi8qKlxuICogUHJlcHJvY2Vzc2luZ1xuICovXG5cbkxleGVyLnByb3RvdHlwZS5sZXggPSBmdW5jdGlvbihzcmMpIHtcbiAgc3JjID0gc3JjXG4gICAgLnJlcGxhY2UoL1xcclxcbnxcXHIvZywgJ1xcbicpXG4gICAgLnJlcGxhY2UoL1xcdC9nLCAnICAgICcpXG4gICAgLnJlcGxhY2UoL1xcdTAwYTAvZywgJyAnKVxuICAgIC5yZXBsYWNlKC9cXHUyNDI0L2csICdcXG4nKTtcblxuICByZXR1cm4gdGhpcy50b2tlbihzcmMsIHRydWUpO1xufTtcblxuLyoqXG4gKiBMZXhpbmdcbiAqL1xuXG5MZXhlci5wcm90b3R5cGUudG9rZW4gPSBmdW5jdGlvbihzcmMsIHRvcCwgYnEpIHtcbiAgdmFyIHNyYyA9IHNyYy5yZXBsYWNlKC9eICskL2dtLCAnJylcbiAgICAsIG5leHRcbiAgICAsIGxvb3NlXG4gICAgLCBjYXBcbiAgICAsIGJ1bGxcbiAgICAsIGJcbiAgICAsIGl0ZW1cbiAgICAsIHNwYWNlXG4gICAgLCBpXG4gICAgLCBsO1xuXG4gIHdoaWxlIChzcmMpIHtcbiAgICAvLyBuZXdsaW5lXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMubmV3bGluZS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBpZiAoY2FwWzBdLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogJ3NwYWNlJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb2RlXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuY29kZS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBjYXAgPSBjYXBbMF0ucmVwbGFjZSgvXiB7NH0vZ20sICcnKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnY29kZScsXG4gICAgICAgIHRleHQ6ICF0aGlzLm9wdGlvbnMucGVkYW50aWNcbiAgICAgICAgICA/IGNhcC5yZXBsYWNlKC9cXG4rJC8sICcnKVxuICAgICAgICAgIDogY2FwXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGZlbmNlcyAoZ2ZtKVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmZlbmNlcy5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICBsYW5nOiBjYXBbMl0sXG4gICAgICAgIHRleHQ6IGNhcFszXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBoZWFkaW5nXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuaGVhZGluZy5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgICAgICBkZXB0aDogY2FwWzFdLmxlbmd0aCxcbiAgICAgICAgdGV4dDogY2FwWzJdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRhYmxlIG5vIGxlYWRpbmcgcGlwZSAoZ2ZtKVxuICAgIGlmICh0b3AgJiYgKGNhcCA9IHRoaXMucnVsZXMubnB0YWJsZS5leGVjKHNyYykpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuXG4gICAgICBpdGVtID0ge1xuICAgICAgICB0eXBlOiAndGFibGUnLFxuICAgICAgICBoZWFkZXI6IGNhcFsxXS5yZXBsYWNlKC9eICp8ICpcXHwgKiQvZywgJycpLnNwbGl0KC8gKlxcfCAqLyksXG4gICAgICAgIGFsaWduOiBjYXBbMl0ucmVwbGFjZSgvXiAqfFxcfCAqJC9nLCAnJykuc3BsaXQoLyAqXFx8ICovKSxcbiAgICAgICAgY2VsbHM6IGNhcFszXS5yZXBsYWNlKC9cXG4kLywgJycpLnNwbGl0KCdcXG4nKVxuICAgICAgfTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW0uYWxpZ24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKC9eICotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnY2VudGVyJztcbiAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdsZWZ0JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbS5jZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtLmNlbGxzW2ldID0gaXRlbS5jZWxsc1tpXS5zcGxpdCgvICpcXHwgKi8pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRva2Vucy5wdXNoKGl0ZW0pO1xuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBsaGVhZGluZ1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmxoZWFkaW5nLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAgIGRlcHRoOiBjYXBbMl0gPT09ICc9JyA/IDEgOiAyLFxuICAgICAgICB0ZXh0OiBjYXBbMV1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gaHJcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5oci5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2hyJ1xuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBibG9ja3F1b3RlXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuYmxvY2txdW90ZS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG5cbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnYmxvY2txdW90ZV9zdGFydCdcbiAgICAgIH0pO1xuXG4gICAgICBjYXAgPSBjYXBbMF0ucmVwbGFjZSgvXiAqPiA/L2dtLCAnJyk7XG5cbiAgICAgIC8vIFBhc3MgYHRvcGAgdG8ga2VlcCB0aGUgY3VycmVudFxuICAgICAgLy8gXCJ0b3BsZXZlbFwiIHN0YXRlLiBUaGlzIGlzIGV4YWN0bHlcbiAgICAgIC8vIGhvdyBtYXJrZG93bi5wbCB3b3Jrcy5cbiAgICAgIHRoaXMudG9rZW4oY2FwLCB0b3AsIHRydWUpO1xuXG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2Jsb2NrcXVvdGVfZW5kJ1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGxpc3RcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5saXN0LmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIGJ1bGwgPSBjYXBbMl07XG5cbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnbGlzdF9zdGFydCcsXG4gICAgICAgIG9yZGVyZWQ6IGJ1bGwubGVuZ3RoID4gMVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEdldCBlYWNoIHRvcC1sZXZlbCBpdGVtLlxuICAgICAgY2FwID0gY2FwWzBdLm1hdGNoKHRoaXMucnVsZXMuaXRlbSk7XG5cbiAgICAgIG5leHQgPSBmYWxzZTtcbiAgICAgIGwgPSBjYXAubGVuZ3RoO1xuICAgICAgaSA9IDA7XG5cbiAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBjYXBbaV07XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBsaXN0IGl0ZW0ncyBidWxsZXRcbiAgICAgICAgLy8gc28gaXQgaXMgc2VlbiBhcyB0aGUgbmV4dCB0b2tlbi5cbiAgICAgICAgc3BhY2UgPSBpdGVtLmxlbmd0aDtcbiAgICAgICAgaXRlbSA9IGl0ZW0ucmVwbGFjZSgvXiAqKFsqKy1dfFxcZCtcXC4pICsvLCAnJyk7XG5cbiAgICAgICAgLy8gT3V0ZGVudCB3aGF0ZXZlciB0aGVcbiAgICAgICAgLy8gbGlzdCBpdGVtIGNvbnRhaW5zLiBIYWNreS5cbiAgICAgICAgaWYgKH5pdGVtLmluZGV4T2YoJ1xcbiAnKSkge1xuICAgICAgICAgIHNwYWNlIC09IGl0ZW0ubGVuZ3RoO1xuICAgICAgICAgIGl0ZW0gPSAhdGhpcy5vcHRpb25zLnBlZGFudGljXG4gICAgICAgICAgICA/IGl0ZW0ucmVwbGFjZShuZXcgUmVnRXhwKCdeIHsxLCcgKyBzcGFjZSArICd9JywgJ2dtJyksICcnKVxuICAgICAgICAgICAgOiBpdGVtLnJlcGxhY2UoL14gezEsNH0vZ20sICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZSB3aGV0aGVyIHRoZSBuZXh0IGxpc3QgaXRlbSBiZWxvbmdzIGhlcmUuXG4gICAgICAgIC8vIEJhY2twZWRhbCBpZiBpdCBkb2VzIG5vdCBiZWxvbmcgaW4gdGhpcyBsaXN0LlxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNtYXJ0TGlzdHMgJiYgaSAhPT0gbCAtIDEpIHtcbiAgICAgICAgICBiID0gYmxvY2suYnVsbGV0LmV4ZWMoY2FwW2kgKyAxXSlbMF07XG4gICAgICAgICAgaWYgKGJ1bGwgIT09IGIgJiYgIShidWxsLmxlbmd0aCA+IDEgJiYgYi5sZW5ndGggPiAxKSkge1xuICAgICAgICAgICAgc3JjID0gY2FwLnNsaWNlKGkgKyAxKS5qb2luKCdcXG4nKSArIHNyYztcbiAgICAgICAgICAgIGkgPSBsIC0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgd2hldGhlciBpdGVtIGlzIGxvb3NlIG9yIG5vdC5cbiAgICAgICAgLy8gVXNlOiAvKF58XFxuKSg/ISApW15cXG5dK1xcblxcbig/IVxccyokKS9cbiAgICAgICAgLy8gZm9yIGRpc2NvdW50IGJlaGF2aW9yLlxuICAgICAgICBsb29zZSA9IG5leHQgfHwgL1xcblxcbig/IVxccyokKS8udGVzdChpdGVtKTtcbiAgICAgICAgaWYgKGkgIT09IGwgLSAxKSB7XG4gICAgICAgICAgbmV4dCA9IGl0ZW0uY2hhckF0KGl0ZW0ubGVuZ3RoIC0gMSkgPT09ICdcXG4nO1xuICAgICAgICAgIGlmICghbG9vc2UpIGxvb3NlID0gbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6IGxvb3NlXG4gICAgICAgICAgICA/ICdsb29zZV9pdGVtX3N0YXJ0J1xuICAgICAgICAgICAgOiAnbGlzdF9pdGVtX3N0YXJ0J1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBSZWN1cnNlLlxuICAgICAgICB0aGlzLnRva2VuKGl0ZW0sIGZhbHNlLCBicSk7XG5cbiAgICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogJ2xpc3RfaXRlbV9lbmQnXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2xpc3RfZW5kJ1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGh0bWxcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5odG1sLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiB0aGlzLm9wdGlvbnMuc2FuaXRpemVcbiAgICAgICAgICA/ICdwYXJhZ3JhcGgnXG4gICAgICAgICAgOiAnaHRtbCcsXG4gICAgICAgIHByZTogY2FwWzFdID09PSAncHJlJyB8fCBjYXBbMV0gPT09ICdzY3JpcHQnIHx8IGNhcFsxXSA9PT0gJ3N0eWxlJyxcbiAgICAgICAgdGV4dDogY2FwWzBdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGRlZlxuICAgIGlmICgoIWJxICYmIHRvcCkgJiYgKGNhcCA9IHRoaXMucnVsZXMuZGVmLmV4ZWMoc3JjKSkpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5saW5rc1tjYXBbMV0udG9Mb3dlckNhc2UoKV0gPSB7XG4gICAgICAgIGhyZWY6IGNhcFsyXSxcbiAgICAgICAgdGl0bGU6IGNhcFszXVxuICAgICAgfTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRhYmxlIChnZm0pXG4gICAgaWYgKHRvcCAmJiAoY2FwID0gdGhpcy5ydWxlcy50YWJsZS5leGVjKHNyYykpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuXG4gICAgICBpdGVtID0ge1xuICAgICAgICB0eXBlOiAndGFibGUnLFxuICAgICAgICBoZWFkZXI6IGNhcFsxXS5yZXBsYWNlKC9eICp8ICpcXHwgKiQvZywgJycpLnNwbGl0KC8gKlxcfCAqLyksXG4gICAgICAgIGFsaWduOiBjYXBbMl0ucmVwbGFjZSgvXiAqfFxcfCAqJC9nLCAnJykuc3BsaXQoLyAqXFx8ICovKSxcbiAgICAgICAgY2VsbHM6IGNhcFszXS5yZXBsYWNlKC8oPzogKlxcfCAqKT9cXG4kLywgJycpLnNwbGl0KCdcXG4nKVxuICAgICAgfTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW0uYWxpZ24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKC9eICotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnY2VudGVyJztcbiAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdsZWZ0JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbS5jZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtLmNlbGxzW2ldID0gaXRlbS5jZWxsc1tpXVxuICAgICAgICAgIC5yZXBsYWNlKC9eICpcXHwgKnwgKlxcfCAqJC9nLCAnJylcbiAgICAgICAgICAuc3BsaXQoLyAqXFx8ICovKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50b2tlbnMucHVzaChpdGVtKTtcblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdG9wLWxldmVsIHBhcmFncmFwaFxuICAgIGlmICh0b3AgJiYgKGNhcCA9IHRoaXMucnVsZXMucGFyYWdyYXBoLmV4ZWMoc3JjKSkpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ3BhcmFncmFwaCcsXG4gICAgICAgIHRleHQ6IGNhcFsxXS5jaGFyQXQoY2FwWzFdLmxlbmd0aCAtIDEpID09PSAnXFxuJ1xuICAgICAgICAgID8gY2FwWzFdLnNsaWNlKDAsIC0xKVxuICAgICAgICAgIDogY2FwWzFdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRleHRcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy50ZXh0LmV4ZWMoc3JjKSkge1xuICAgICAgLy8gVG9wLWxldmVsIHNob3VsZCBuZXZlciByZWFjaCBoZXJlLlxuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgIHRleHQ6IGNhcFswXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoc3JjKSB7XG4gICAgICB0aHJvdyBuZXdcbiAgICAgICAgRXJyb3IoJ0luZmluaXRlIGxvb3Agb24gYnl0ZTogJyArIHNyYy5jaGFyQ29kZUF0KDApKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcy50b2tlbnM7XG59O1xuXG4vKipcbiAqIElubGluZS1MZXZlbCBHcmFtbWFyXG4gKi9cblxudmFyIGlubGluZSA9IHtcbiAgZXNjYXBlOiAvXlxcXFwoW1xcXFxgKnt9XFxbXFxdKCkjK1xcLS4hXz5dKS8sXG4gIGF1dG9saW5rOiAvXjwoW14gPl0rKEB8OlxcLylbXiA+XSspPi8sXG4gIHVybDogbm9vcCxcbiAgdGFnOiAvXjwhLS1bXFxzXFxTXSo/LS0+fF48XFwvP1xcdysoPzpcIlteXCJdKlwifCdbXiddKid8W14nXCI+XSkqPz4vLFxuICBsaW5rOiAvXiE/XFxbKGluc2lkZSlcXF1cXChocmVmXFwpLyxcbiAgcmVmbGluazogL14hP1xcWyhpbnNpZGUpXFxdXFxzKlxcWyhbXlxcXV0qKVxcXS8sXG4gIG5vbGluazogL14hP1xcWygoPzpcXFtbXlxcXV0qXFxdfFteXFxbXFxdXSkqKVxcXS8sXG4gIHN0cm9uZzogL15fXyhbXFxzXFxTXSs/KV9fKD8hXyl8XlxcKlxcKihbXFxzXFxTXSs/KVxcKlxcKig/IVxcKikvLFxuICBlbTogL15cXGJfKCg/Ol9ffFtcXHNcXFNdKSs/KV9cXGJ8XlxcKigoPzpcXCpcXCp8W1xcc1xcU10pKz8pXFwqKD8hXFwqKS8sXG4gIGNvZGU6IC9eKGArKVxccyooW1xcc1xcU10qP1teYF0pXFxzKlxcMSg/IWApLyxcbiAgYnI6IC9eIHsyLH1cXG4oPyFcXHMqJCkvLFxuICBkZWw6IG5vb3AsXG4gIHRleHQ6IC9eW1xcc1xcU10rPyg/PVtcXFxcPCFcXFtfKmBdfCB7Mix9XFxufCQpL1xufTtcblxuaW5saW5lLl9pbnNpZGUgPSAvKD86XFxbW15cXF1dKlxcXXxbXlxcW1xcXV18XFxdKD89W15cXFtdKlxcXSkpKi87XG5pbmxpbmUuX2hyZWYgPSAvXFxzKjw/KFtcXHNcXFNdKj8pPj8oPzpcXHMrWydcIl0oW1xcc1xcU10qPylbJ1wiXSk/XFxzKi87XG5cbmlubGluZS5saW5rID0gcmVwbGFjZShpbmxpbmUubGluaylcbiAgKCdpbnNpZGUnLCBpbmxpbmUuX2luc2lkZSlcbiAgKCdocmVmJywgaW5saW5lLl9ocmVmKVxuICAoKTtcblxuaW5saW5lLnJlZmxpbmsgPSByZXBsYWNlKGlubGluZS5yZWZsaW5rKVxuICAoJ2luc2lkZScsIGlubGluZS5faW5zaWRlKVxuICAoKTtcblxuLyoqXG4gKiBOb3JtYWwgSW5saW5lIEdyYW1tYXJcbiAqL1xuXG5pbmxpbmUubm9ybWFsID0gbWVyZ2Uoe30sIGlubGluZSk7XG5cbi8qKlxuICogUGVkYW50aWMgSW5saW5lIEdyYW1tYXJcbiAqL1xuXG5pbmxpbmUucGVkYW50aWMgPSBtZXJnZSh7fSwgaW5saW5lLm5vcm1hbCwge1xuICBzdHJvbmc6IC9eX18oPz1cXFMpKFtcXHNcXFNdKj9cXFMpX18oPyFfKXxeXFwqXFwqKD89XFxTKShbXFxzXFxTXSo/XFxTKVxcKlxcKig/IVxcKikvLFxuICBlbTogL15fKD89XFxTKShbXFxzXFxTXSo/XFxTKV8oPyFfKXxeXFwqKD89XFxTKShbXFxzXFxTXSo/XFxTKVxcKig/IVxcKikvXG59KTtcblxuLyoqXG4gKiBHRk0gSW5saW5lIEdyYW1tYXJcbiAqL1xuXG5pbmxpbmUuZ2ZtID0gbWVyZ2Uoe30sIGlubGluZS5ub3JtYWwsIHtcbiAgZXNjYXBlOiByZXBsYWNlKGlubGluZS5lc2NhcGUpKCddKScsICd+fF0pJykoKSxcbiAgdXJsOiAvXihodHRwcz86XFwvXFwvW15cXHM8XStbXjwuLDo7XCInKVxcXVxcc10pLyxcbiAgZGVsOiAvXn5+KD89XFxTKShbXFxzXFxTXSo/XFxTKX5+LyxcbiAgdGV4dDogcmVwbGFjZShpbmxpbmUudGV4dClcbiAgICAoJ118JywgJ35dfCcpXG4gICAgKCd8JywgJ3xodHRwcz86Ly98JylcbiAgICAoKVxufSk7XG5cbi8qKlxuICogR0ZNICsgTGluZSBCcmVha3MgSW5saW5lIEdyYW1tYXJcbiAqL1xuXG5pbmxpbmUuYnJlYWtzID0gbWVyZ2Uoe30sIGlubGluZS5nZm0sIHtcbiAgYnI6IHJlcGxhY2UoaW5saW5lLmJyKSgnezIsfScsICcqJykoKSxcbiAgdGV4dDogcmVwbGFjZShpbmxpbmUuZ2ZtLnRleHQpKCd7Mix9JywgJyonKSgpXG59KTtcblxuLyoqXG4gKiBJbmxpbmUgTGV4ZXIgJiBDb21waWxlclxuICovXG5cbmZ1bmN0aW9uIElubGluZUxleGVyKGxpbmtzLCBvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgbWFya2VkLmRlZmF1bHRzO1xuICB0aGlzLmxpbmtzID0gbGlua3M7XG4gIHRoaXMucnVsZXMgPSBpbmxpbmUubm9ybWFsO1xuICB0aGlzLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyIHx8IG5ldyBSZW5kZXJlcjtcbiAgdGhpcy5yZW5kZXJlci5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gIGlmICghdGhpcy5saW5rcykge1xuICAgIHRocm93IG5ld1xuICAgICAgRXJyb3IoJ1Rva2VucyBhcnJheSByZXF1aXJlcyBhIGBsaW5rc2AgcHJvcGVydHkuJyk7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYnJlYWtzKSB7XG4gICAgICB0aGlzLnJ1bGVzID0gaW5saW5lLmJyZWFrcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ydWxlcyA9IGlubGluZS5nZm07XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgIHRoaXMucnVsZXMgPSBpbmxpbmUucGVkYW50aWM7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHBvc2UgSW5saW5lIFJ1bGVzXG4gKi9cblxuSW5saW5lTGV4ZXIucnVsZXMgPSBpbmxpbmU7XG5cbi8qKlxuICogU3RhdGljIExleGluZy9Db21waWxpbmcgTWV0aG9kXG4gKi9cblxuSW5saW5lTGV4ZXIub3V0cHV0ID0gZnVuY3Rpb24oc3JjLCBsaW5rcywgb3B0aW9ucykge1xuICB2YXIgaW5saW5lID0gbmV3IElubGluZUxleGVyKGxpbmtzLCBvcHRpb25zKTtcbiAgcmV0dXJuIGlubGluZS5vdXRwdXQoc3JjKTtcbn07XG5cbi8qKlxuICogTGV4aW5nL0NvbXBpbGluZ1xuICovXG5cbklubGluZUxleGVyLnByb3RvdHlwZS5vdXRwdXQgPSBmdW5jdGlvbihzcmMpIHtcbiAgdmFyIG91dCA9ICcnXG4gICAgLCBsaW5rXG4gICAgLCB0ZXh0XG4gICAgLCBocmVmXG4gICAgLCBjYXA7XG5cbiAgd2hpbGUgKHNyYykge1xuICAgIC8vIGVzY2FwZVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmVzY2FwZS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gY2FwWzFdO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gYXV0b2xpbmtcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5hdXRvbGluay5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBpZiAoY2FwWzJdID09PSAnQCcpIHtcbiAgICAgICAgdGV4dCA9IGNhcFsxXS5jaGFyQXQoNikgPT09ICc6J1xuICAgICAgICAgID8gdGhpcy5tYW5nbGUoY2FwWzFdLnN1YnN0cmluZyg3KSlcbiAgICAgICAgICA6IHRoaXMubWFuZ2xlKGNhcFsxXSk7XG4gICAgICAgIGhyZWYgPSB0aGlzLm1hbmdsZSgnbWFpbHRvOicpICsgdGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBlc2NhcGUoY2FwWzFdKTtcbiAgICAgICAgaHJlZiA9IHRleHQ7XG4gICAgICB9XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5saW5rKGhyZWYsIG51bGwsIHRleHQpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdXJsIChnZm0pXG4gICAgaWYgKCF0aGlzLmluTGluayAmJiAoY2FwID0gdGhpcy5ydWxlcy51cmwuZXhlYyhzcmMpKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRleHQgPSBlc2NhcGUoY2FwWzFdKTtcbiAgICAgIGhyZWYgPSB0ZXh0O1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIubGluayhocmVmLCBudWxsLCB0ZXh0KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRhZ1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLnRhZy5leGVjKHNyYykpIHtcbiAgICAgIGlmICghdGhpcy5pbkxpbmsgJiYgL148YSAvaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgdGhpcy5pbkxpbmsgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmluTGluayAmJiAvXjxcXC9hPi9pLnRlc3QoY2FwWzBdKSkge1xuICAgICAgICB0aGlzLmluTGluayA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSB0aGlzLm9wdGlvbnMuc2FuaXRpemVcbiAgICAgICAgPyBlc2NhcGUoY2FwWzBdKVxuICAgICAgICA6IGNhcFswXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGxpbmtcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5saW5rLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMuaW5MaW5rID0gdHJ1ZTtcbiAgICAgIG91dCArPSB0aGlzLm91dHB1dExpbmsoY2FwLCB7XG4gICAgICAgIGhyZWY6IGNhcFsyXSxcbiAgICAgICAgdGl0bGU6IGNhcFszXVxuICAgICAgfSk7XG4gICAgICB0aGlzLmluTGluayA9IGZhbHNlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gcmVmbGluaywgbm9saW5rXG4gICAgaWYgKChjYXAgPSB0aGlzLnJ1bGVzLnJlZmxpbmsuZXhlYyhzcmMpKVxuICAgICAgICB8fCAoY2FwID0gdGhpcy5ydWxlcy5ub2xpbmsuZXhlYyhzcmMpKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIGxpbmsgPSAoY2FwWzJdIHx8IGNhcFsxXSkucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuICAgICAgbGluayA9IHRoaXMubGlua3NbbGluay50b0xvd2VyQ2FzZSgpXTtcbiAgICAgIGlmICghbGluayB8fCAhbGluay5ocmVmKSB7XG4gICAgICAgIG91dCArPSBjYXBbMF0uY2hhckF0KDApO1xuICAgICAgICBzcmMgPSBjYXBbMF0uc3Vic3RyaW5nKDEpICsgc3JjO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5MaW5rID0gdHJ1ZTtcbiAgICAgIG91dCArPSB0aGlzLm91dHB1dExpbmsoY2FwLCBsaW5rKTtcbiAgICAgIHRoaXMuaW5MaW5rID0gZmFsc2U7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBzdHJvbmdcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5zdHJvbmcuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuc3Ryb25nKHRoaXMub3V0cHV0KGNhcFsyXSB8fCBjYXBbMV0pKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGVtXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuZW0uZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuZW0odGhpcy5vdXRwdXQoY2FwWzJdIHx8IGNhcFsxXSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gY29kZVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmNvZGUuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuY29kZXNwYW4oZXNjYXBlKGNhcFsyXSwgdHJ1ZSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gYnJcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5ici5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5icigpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZGVsIChnZm0pXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuZGVsLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmRlbCh0aGlzLm91dHB1dChjYXBbMV0pKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRleHRcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy50ZXh0LmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSBlc2NhcGUodGhpcy5zbWFydHlwYW50cyhjYXBbMF0pKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChzcmMpIHtcbiAgICAgIHRocm93IG5ld1xuICAgICAgICBFcnJvcignSW5maW5pdGUgbG9vcCBvbiBieXRlOiAnICsgc3JjLmNoYXJDb2RlQXQoMCkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvbXBpbGUgTGlua1xuICovXG5cbklubGluZUxleGVyLnByb3RvdHlwZS5vdXRwdXRMaW5rID0gZnVuY3Rpb24oY2FwLCBsaW5rKSB7XG4gIHZhciBocmVmID0gZXNjYXBlKGxpbmsuaHJlZilcbiAgICAsIHRpdGxlID0gbGluay50aXRsZSA/IGVzY2FwZShsaW5rLnRpdGxlKSA6IG51bGw7XG5cbiAgcmV0dXJuIGNhcFswXS5jaGFyQXQoMCkgIT09ICchJ1xuICAgID8gdGhpcy5yZW5kZXJlci5saW5rKGhyZWYsIHRpdGxlLCB0aGlzLm91dHB1dChjYXBbMV0pKVxuICAgIDogdGhpcy5yZW5kZXJlci5pbWFnZShocmVmLCB0aXRsZSwgZXNjYXBlKGNhcFsxXSkpO1xufTtcblxuLyoqXG4gKiBTbWFydHlwYW50cyBUcmFuc2Zvcm1hdGlvbnNcbiAqL1xuXG5JbmxpbmVMZXhlci5wcm90b3R5cGUuc21hcnR5cGFudHMgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIGlmICghdGhpcy5vcHRpb25zLnNtYXJ0eXBhbnRzKSByZXR1cm4gdGV4dDtcbiAgcmV0dXJuIHRleHRcbiAgICAvLyBlbS1kYXNoZXNcbiAgICAucmVwbGFjZSgvLS0vZywgJ1xcdTIwMTQnKVxuICAgIC8vIG9wZW5pbmcgc2luZ2xlc1xuICAgIC5yZXBsYWNlKC8oXnxbLVxcdTIwMTQvKFxcW3tcIlxcc10pJy9nLCAnJDFcXHUyMDE4JylcbiAgICAvLyBjbG9zaW5nIHNpbmdsZXMgJiBhcG9zdHJvcGhlc1xuICAgIC5yZXBsYWNlKC8nL2csICdcXHUyMDE5JylcbiAgICAvLyBvcGVuaW5nIGRvdWJsZXNcbiAgICAucmVwbGFjZSgvKF58Wy1cXHUyMDE0LyhcXFt7XFx1MjAxOFxcc10pXCIvZywgJyQxXFx1MjAxYycpXG4gICAgLy8gY2xvc2luZyBkb3VibGVzXG4gICAgLnJlcGxhY2UoL1wiL2csICdcXHUyMDFkJylcbiAgICAvLyBlbGxpcHNlc1xuICAgIC5yZXBsYWNlKC9cXC57M30vZywgJ1xcdTIwMjYnKTtcbn07XG5cbi8qKlxuICogTWFuZ2xlIExpbmtzXG4gKi9cblxuSW5saW5lTGV4ZXIucHJvdG90eXBlLm1hbmdsZSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgdmFyIG91dCA9ICcnXG4gICAgLCBsID0gdGV4dC5sZW5ndGhcbiAgICAsIGkgPSAwXG4gICAgLCBjaDtcblxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIGNoID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC41KSB7XG4gICAgICBjaCA9ICd4JyArIGNoLnRvU3RyaW5nKDE2KTtcbiAgICB9XG4gICAgb3V0ICs9ICcmIycgKyBjaCArICc7JztcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJlbmRlcmVyXG4gKi9cblxuZnVuY3Rpb24gUmVuZGVyZXIob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xufVxuXG5SZW5kZXJlci5wcm90b3R5cGUuY29kZSA9IGZ1bmN0aW9uKGNvZGUsIGxhbmcsIGVzY2FwZWQpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5oaWdobGlnaHQpIHtcbiAgICB2YXIgb3V0ID0gdGhpcy5vcHRpb25zLmhpZ2hsaWdodChjb2RlLCBsYW5nKTtcbiAgICBpZiAob3V0ICE9IG51bGwgJiYgb3V0ICE9PSBjb2RlKSB7XG4gICAgICBlc2NhcGVkID0gdHJ1ZTtcbiAgICAgIGNvZGUgPSBvdXQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFsYW5nKSB7XG4gICAgcmV0dXJuICc8cHJlPjxjb2RlPidcbiAgICAgICsgKGVzY2FwZWQgPyBjb2RlIDogZXNjYXBlKGNvZGUsIHRydWUpKVxuICAgICAgKyAnXFxuPC9jb2RlPjwvcHJlPic7XG4gIH1cblxuICByZXR1cm4gJzxwcmU+PGNvZGUgY2xhc3M9XCInXG4gICAgKyB0aGlzLm9wdGlvbnMubGFuZ1ByZWZpeFxuICAgICsgZXNjYXBlKGxhbmcsIHRydWUpXG4gICAgKyAnXCI+J1xuICAgICsgKGVzY2FwZWQgPyBjb2RlIDogZXNjYXBlKGNvZGUsIHRydWUpKVxuICAgICsgJ1xcbjwvY29kZT48L3ByZT5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmJsb2NrcXVvdGUgPSBmdW5jdGlvbihxdW90ZSkge1xuICByZXR1cm4gJzxibG9ja3F1b3RlPlxcbicgKyBxdW90ZSArICc8L2Jsb2NrcXVvdGU+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5odG1sID0gZnVuY3Rpb24oaHRtbCkge1xuICByZXR1cm4gaHRtbDtcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5oZWFkaW5nID0gZnVuY3Rpb24odGV4dCwgbGV2ZWwsIHJhdykge1xuICByZXR1cm4gJzxoJ1xuICAgICsgbGV2ZWxcbiAgICArICcgaWQ9XCInXG4gICAgKyB0aGlzLm9wdGlvbnMuaGVhZGVyUHJlZml4XG4gICAgKyByYXcudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bXlxcd10rL2csICctJylcbiAgICArICdcIj4nXG4gICAgKyB0ZXh0XG4gICAgKyAnPC9oJ1xuICAgICsgbGV2ZWxcbiAgICArICc+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5ociA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5vcHRpb25zLnhodG1sID8gJzxoci8+XFxuJyA6ICc8aHI+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5saXN0ID0gZnVuY3Rpb24oYm9keSwgb3JkZXJlZCkge1xuICB2YXIgdHlwZSA9IG9yZGVyZWQgPyAnb2wnIDogJ3VsJztcbiAgcmV0dXJuICc8JyArIHR5cGUgKyAnPlxcbicgKyBib2R5ICsgJzwvJyArIHR5cGUgKyAnPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUubGlzdGl0ZW0gPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiAnPGxpPicgKyB0ZXh0ICsgJzwvbGk+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5wYXJhZ3JhcGggPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiAnPHA+JyArIHRleHQgKyAnPC9wPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUudGFibGUgPSBmdW5jdGlvbihoZWFkZXIsIGJvZHkpIHtcbiAgcmV0dXJuICc8dGFibGU+XFxuJ1xuICAgICsgJzx0aGVhZD5cXG4nXG4gICAgKyBoZWFkZXJcbiAgICArICc8L3RoZWFkPlxcbidcbiAgICArICc8dGJvZHk+XFxuJ1xuICAgICsgYm9keVxuICAgICsgJzwvdGJvZHk+XFxuJ1xuICAgICsgJzwvdGFibGU+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS50YWJsZXJvdyA9IGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgcmV0dXJuICc8dHI+XFxuJyArIGNvbnRlbnQgKyAnPC90cj5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnRhYmxlY2VsbCA9IGZ1bmN0aW9uKGNvbnRlbnQsIGZsYWdzKSB7XG4gIHZhciB0eXBlID0gZmxhZ3MuaGVhZGVyID8gJ3RoJyA6ICd0ZCc7XG4gIHZhciB0YWcgPSBmbGFncy5hbGlnblxuICAgID8gJzwnICsgdHlwZSArICcgc3R5bGU9XCJ0ZXh0LWFsaWduOicgKyBmbGFncy5hbGlnbiArICdcIj4nXG4gICAgOiAnPCcgKyB0eXBlICsgJz4nO1xuICByZXR1cm4gdGFnICsgY29udGVudCArICc8LycgKyB0eXBlICsgJz5cXG4nO1xufTtcblxuLy8gc3BhbiBsZXZlbCByZW5kZXJlclxuUmVuZGVyZXIucHJvdG90eXBlLnN0cm9uZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8c3Ryb25nPicgKyB0ZXh0ICsgJzwvc3Ryb25nPic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuZW0gPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiAnPGVtPicgKyB0ZXh0ICsgJzwvZW0+Jztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5jb2Rlc3BhbiA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8Y29kZT4nICsgdGV4dCArICc8L2NvZGU+Jztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5iciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5vcHRpb25zLnhodG1sID8gJzxici8+JyA6ICc8YnI+Jztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiAnPGRlbD4nICsgdGV4dCArICc8L2RlbD4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmxpbmsgPSBmdW5jdGlvbihocmVmLCB0aXRsZSwgdGV4dCkge1xuICBpZiAodGhpcy5vcHRpb25zLnNhbml0aXplKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBwcm90ID0gZGVjb2RlVVJJQ29tcG9uZW50KHVuZXNjYXBlKGhyZWYpKVxuICAgICAgICAucmVwbGFjZSgvW15cXHc6XS9nLCAnJylcbiAgICAgICAgLnRvTG93ZXJDYXNlKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBpZiAocHJvdC5pbmRleE9mKCdqYXZhc2NyaXB0OicpID09PSAwIHx8IHByb3QuaW5kZXhPZigndmJzY3JpcHQ6JykgPT09IDApIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cbiAgdmFyIG91dCA9ICc8YSBocmVmPVwiJyArIGhyZWYgKyAnXCInO1xuICBpZiAodGl0bGUpIHtcbiAgICBvdXQgKz0gJyB0aXRsZT1cIicgKyB0aXRsZSArICdcIic7XG4gIH1cbiAgb3V0ICs9ICc+JyArIHRleHQgKyAnPC9hPic7XG4gIHJldHVybiBvdXQ7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuaW1hZ2UgPSBmdW5jdGlvbihocmVmLCB0aXRsZSwgdGV4dCkge1xuICB2YXIgb3V0ID0gJzxpbWcgc3JjPVwiJyArIGhyZWYgKyAnXCIgYWx0PVwiJyArIHRleHQgKyAnXCInO1xuICBpZiAodGl0bGUpIHtcbiAgICBvdXQgKz0gJyB0aXRsZT1cIicgKyB0aXRsZSArICdcIic7XG4gIH1cbiAgb3V0ICs9IHRoaXMub3B0aW9ucy54aHRtbCA/ICcvPicgOiAnPic7XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBhcnNpbmcgJiBDb21waWxpbmdcbiAqL1xuXG5mdW5jdGlvbiBQYXJzZXIob3B0aW9ucykge1xuICB0aGlzLnRva2VucyA9IFtdO1xuICB0aGlzLnRva2VuID0gbnVsbDtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBtYXJrZWQuZGVmYXVsdHM7XG4gIHRoaXMub3B0aW9ucy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlciB8fCBuZXcgUmVuZGVyZXI7XG4gIHRoaXMucmVuZGVyZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyZXI7XG4gIHRoaXMucmVuZGVyZXIub3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbn1cblxuLyoqXG4gKiBTdGF0aWMgUGFyc2UgTWV0aG9kXG4gKi9cblxuUGFyc2VyLnBhcnNlID0gZnVuY3Rpb24oc3JjLCBvcHRpb25zLCByZW5kZXJlcikge1xuICB2YXIgcGFyc2VyID0gbmV3IFBhcnNlcihvcHRpb25zLCByZW5kZXJlcik7XG4gIHJldHVybiBwYXJzZXIucGFyc2Uoc3JjKTtcbn07XG5cbi8qKlxuICogUGFyc2UgTG9vcFxuICovXG5cblBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihzcmMpIHtcbiAgdGhpcy5pbmxpbmUgPSBuZXcgSW5saW5lTGV4ZXIoc3JjLmxpbmtzLCB0aGlzLm9wdGlvbnMsIHRoaXMucmVuZGVyZXIpO1xuICB0aGlzLnRva2VucyA9IHNyYy5yZXZlcnNlKCk7XG5cbiAgdmFyIG91dCA9ICcnO1xuICB3aGlsZSAodGhpcy5uZXh0KCkpIHtcbiAgICBvdXQgKz0gdGhpcy50b2soKTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE5leHQgVG9rZW5cbiAqL1xuXG5QYXJzZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9rZW4gPSB0aGlzLnRva2Vucy5wb3AoKTtcbn07XG5cbi8qKlxuICogUHJldmlldyBOZXh0IFRva2VuXG4gKi9cblxuUGFyc2VyLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRva2Vuc1t0aGlzLnRva2Vucy5sZW5ndGggLSAxXSB8fCAwO1xufTtcblxuLyoqXG4gKiBQYXJzZSBUZXh0IFRva2Vuc1xuICovXG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VUZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBib2R5ID0gdGhpcy50b2tlbi50ZXh0O1xuXG4gIHdoaWxlICh0aGlzLnBlZWsoKS50eXBlID09PSAndGV4dCcpIHtcbiAgICBib2R5ICs9ICdcXG4nICsgdGhpcy5uZXh0KCkudGV4dDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmlubGluZS5vdXRwdXQoYm9keSk7XG59O1xuXG4vKipcbiAqIFBhcnNlIEN1cnJlbnQgVG9rZW5cbiAqL1xuXG5QYXJzZXIucHJvdG90eXBlLnRvayA9IGZ1bmN0aW9uKCkge1xuICBzd2l0Y2ggKHRoaXMudG9rZW4udHlwZSkge1xuICAgIGNhc2UgJ3NwYWNlJzoge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBjYXNlICdocic6IHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmhyKCk7XG4gICAgfVxuICAgIGNhc2UgJ2hlYWRpbmcnOiB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5oZWFkaW5nKFxuICAgICAgICB0aGlzLmlubGluZS5vdXRwdXQodGhpcy50b2tlbi50ZXh0KSxcbiAgICAgICAgdGhpcy50b2tlbi5kZXB0aCxcbiAgICAgICAgdGhpcy50b2tlbi50ZXh0KTtcbiAgICB9XG4gICAgY2FzZSAnY29kZSc6IHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmNvZGUodGhpcy50b2tlbi50ZXh0LFxuICAgICAgICB0aGlzLnRva2VuLmxhbmcsXG4gICAgICAgIHRoaXMudG9rZW4uZXNjYXBlZCk7XG4gICAgfVxuICAgIGNhc2UgJ3RhYmxlJzoge1xuICAgICAgdmFyIGhlYWRlciA9ICcnXG4gICAgICAgICwgYm9keSA9ICcnXG4gICAgICAgICwgaVxuICAgICAgICAsIHJvd1xuICAgICAgICAsIGNlbGxcbiAgICAgICAgLCBmbGFnc1xuICAgICAgICAsIGo7XG5cbiAgICAgIC8vIGhlYWRlclxuICAgICAgY2VsbCA9ICcnO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMudG9rZW4uaGVhZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZsYWdzID0geyBoZWFkZXI6IHRydWUsIGFsaWduOiB0aGlzLnRva2VuLmFsaWduW2ldIH07XG4gICAgICAgIGNlbGwgKz0gdGhpcy5yZW5kZXJlci50YWJsZWNlbGwoXG4gICAgICAgICAgdGhpcy5pbmxpbmUub3V0cHV0KHRoaXMudG9rZW4uaGVhZGVyW2ldKSxcbiAgICAgICAgICB7IGhlYWRlcjogdHJ1ZSwgYWxpZ246IHRoaXMudG9rZW4uYWxpZ25baV0gfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaGVhZGVyICs9IHRoaXMucmVuZGVyZXIudGFibGVyb3coY2VsbCk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnRva2VuLmNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJvdyA9IHRoaXMudG9rZW4uY2VsbHNbaV07XG5cbiAgICAgICAgY2VsbCA9ICcnO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgcm93Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY2VsbCArPSB0aGlzLnJlbmRlcmVyLnRhYmxlY2VsbChcbiAgICAgICAgICAgIHRoaXMuaW5saW5lLm91dHB1dChyb3dbal0pLFxuICAgICAgICAgICAgeyBoZWFkZXI6IGZhbHNlLCBhbGlnbjogdGhpcy50b2tlbi5hbGlnbltqXSB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJvZHkgKz0gdGhpcy5yZW5kZXJlci50YWJsZXJvdyhjZWxsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnRhYmxlKGhlYWRlciwgYm9keSk7XG4gICAgfVxuICAgIGNhc2UgJ2Jsb2NrcXVvdGVfc3RhcnQnOiB7XG4gICAgICB2YXIgYm9keSA9ICcnO1xuXG4gICAgICB3aGlsZSAodGhpcy5uZXh0KCkudHlwZSAhPT0gJ2Jsb2NrcXVvdGVfZW5kJykge1xuICAgICAgICBib2R5ICs9IHRoaXMudG9rKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmJsb2NrcXVvdGUoYm9keSk7XG4gICAgfVxuICAgIGNhc2UgJ2xpc3Rfc3RhcnQnOiB7XG4gICAgICB2YXIgYm9keSA9ICcnXG4gICAgICAgICwgb3JkZXJlZCA9IHRoaXMudG9rZW4ub3JkZXJlZDtcblxuICAgICAgd2hpbGUgKHRoaXMubmV4dCgpLnR5cGUgIT09ICdsaXN0X2VuZCcpIHtcbiAgICAgICAgYm9keSArPSB0aGlzLnRvaygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5saXN0KGJvZHksIG9yZGVyZWQpO1xuICAgIH1cbiAgICBjYXNlICdsaXN0X2l0ZW1fc3RhcnQnOiB7XG4gICAgICB2YXIgYm9keSA9ICcnO1xuXG4gICAgICB3aGlsZSAodGhpcy5uZXh0KCkudHlwZSAhPT0gJ2xpc3RfaXRlbV9lbmQnKSB7XG4gICAgICAgIGJvZHkgKz0gdGhpcy50b2tlbi50eXBlID09PSAndGV4dCdcbiAgICAgICAgICA/IHRoaXMucGFyc2VUZXh0KClcbiAgICAgICAgICA6IHRoaXMudG9rKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmxpc3RpdGVtKGJvZHkpO1xuICAgIH1cbiAgICBjYXNlICdsb29zZV9pdGVtX3N0YXJ0Jzoge1xuICAgICAgdmFyIGJvZHkgPSAnJztcblxuICAgICAgd2hpbGUgKHRoaXMubmV4dCgpLnR5cGUgIT09ICdsaXN0X2l0ZW1fZW5kJykge1xuICAgICAgICBib2R5ICs9IHRoaXMudG9rKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmxpc3RpdGVtKGJvZHkpO1xuICAgIH1cbiAgICBjYXNlICdodG1sJzoge1xuICAgICAgdmFyIGh0bWwgPSAhdGhpcy50b2tlbi5wcmUgJiYgIXRoaXMub3B0aW9ucy5wZWRhbnRpY1xuICAgICAgICA/IHRoaXMuaW5saW5lLm91dHB1dCh0aGlzLnRva2VuLnRleHQpXG4gICAgICAgIDogdGhpcy50b2tlbi50ZXh0O1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuaHRtbChodG1sKTtcbiAgICB9XG4gICAgY2FzZSAncGFyYWdyYXBoJzoge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIucGFyYWdyYXBoKHRoaXMuaW5saW5lLm91dHB1dCh0aGlzLnRva2VuLnRleHQpKTtcbiAgICB9XG4gICAgY2FzZSAndGV4dCc6IHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnBhcmFncmFwaCh0aGlzLnBhcnNlVGV4dCgpKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSGVscGVyc1xuICovXG5cbmZ1bmN0aW9uIGVzY2FwZShodG1sLCBlbmNvZGUpIHtcbiAgcmV0dXJuIGh0bWxcbiAgICAucmVwbGFjZSghZW5jb2RlID8gLyYoPyEjP1xcdys7KS9nIDogLyYvZywgJyZhbXA7JylcbiAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JylcbiAgICAucmVwbGFjZSgvJy9nLCAnJiMzOTsnKTtcbn1cblxuZnVuY3Rpb24gdW5lc2NhcGUoaHRtbCkge1xuICByZXR1cm4gaHRtbC5yZXBsYWNlKC8mKFsjXFx3XSspOy9nLCBmdW5jdGlvbihfLCBuKSB7XG4gICAgbiA9IG4udG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobiA9PT0gJ2NvbG9uJykgcmV0dXJuICc6JztcbiAgICBpZiAobi5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgcmV0dXJuIG4uY2hhckF0KDEpID09PSAneCdcbiAgICAgICAgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KG4uc3Vic3RyaW5nKDIpLCAxNikpXG4gICAgICAgIDogU3RyaW5nLmZyb21DaGFyQ29kZSgrbi5zdWJzdHJpbmcoMSkpO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlKHJlZ2V4LCBvcHQpIHtcbiAgcmVnZXggPSByZWdleC5zb3VyY2U7XG4gIG9wdCA9IG9wdCB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uIHNlbGYobmFtZSwgdmFsKSB7XG4gICAgaWYgKCFuYW1lKSByZXR1cm4gbmV3IFJlZ0V4cChyZWdleCwgb3B0KTtcbiAgICB2YWwgPSB2YWwuc291cmNlIHx8IHZhbDtcbiAgICB2YWwgPSB2YWwucmVwbGFjZSgvKF58W15cXFtdKVxcXi9nLCAnJDEnKTtcbiAgICByZWdleCA9IHJlZ2V4LnJlcGxhY2UobmFtZSwgdmFsKTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5ub29wLmV4ZWMgPSBub29wO1xuXG5mdW5jdGlvbiBtZXJnZShvYmopIHtcbiAgdmFyIGkgPSAxXG4gICAgLCB0YXJnZXRcbiAgICAsIGtleTtcblxuICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHRhcmdldCA9IGFyZ3VtZW50c1tpXTtcbiAgICBmb3IgKGtleSBpbiB0YXJnZXQpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpKSB7XG4gICAgICAgIG9ialtrZXldID0gdGFyZ2V0W2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuXG4vKipcbiAqIE1hcmtlZFxuICovXG5cbmZ1bmN0aW9uIG1hcmtlZChzcmMsIG9wdCwgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrIHx8IHR5cGVvZiBvcHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdDtcbiAgICAgIG9wdCA9IG51bGw7XG4gICAgfVxuXG4gICAgb3B0ID0gbWVyZ2Uoe30sIG1hcmtlZC5kZWZhdWx0cywgb3B0IHx8IHt9KTtcblxuICAgIHZhciBoaWdobGlnaHQgPSBvcHQuaGlnaGxpZ2h0XG4gICAgICAsIHRva2Vuc1xuICAgICAgLCBwZW5kaW5nXG4gICAgICAsIGkgPSAwO1xuXG4gICAgdHJ5IHtcbiAgICAgIHRva2VucyA9IExleGVyLmxleChzcmMsIG9wdClcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZSk7XG4gICAgfVxuXG4gICAgcGVuZGluZyA9IHRva2Vucy5sZW5ndGg7XG5cbiAgICB2YXIgZG9uZSA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBvcHQuaGlnaGxpZ2h0ID0gaGlnaGxpZ2h0O1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG91dDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgb3V0ID0gUGFyc2VyLnBhcnNlKHRva2Vucywgb3B0KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyID0gZTtcbiAgICAgIH1cblxuICAgICAgb3B0LmhpZ2hsaWdodCA9IGhpZ2hsaWdodDtcblxuICAgICAgcmV0dXJuIGVyclxuICAgICAgICA/IGNhbGxiYWNrKGVycilcbiAgICAgICAgOiBjYWxsYmFjayhudWxsLCBvdXQpO1xuICAgIH07XG5cbiAgICBpZiAoIWhpZ2hsaWdodCB8fCBoaWdobGlnaHQubGVuZ3RoIDwgMykge1xuICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICB9XG5cbiAgICBkZWxldGUgb3B0LmhpZ2hsaWdodDtcblxuICAgIGlmICghcGVuZGluZykgcmV0dXJuIGRvbmUoKTtcblxuICAgIGZvciAoOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAoZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09ICdjb2RlJykge1xuICAgICAgICAgIHJldHVybiAtLXBlbmRpbmcgfHwgZG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaWdobGlnaHQodG9rZW4udGV4dCwgdG9rZW4ubGFuZywgZnVuY3Rpb24oZXJyLCBjb2RlKSB7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIGRvbmUoZXJyKTtcbiAgICAgICAgICBpZiAoY29kZSA9PSBudWxsIHx8IGNvZGUgPT09IHRva2VuLnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiAtLXBlbmRpbmcgfHwgZG9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0b2tlbi50ZXh0ID0gY29kZTtcbiAgICAgICAgICB0b2tlbi5lc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICAtLXBlbmRpbmcgfHwgZG9uZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pKHRva2Vuc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKG9wdCkgb3B0ID0gbWVyZ2Uoe30sIG1hcmtlZC5kZWZhdWx0cywgb3B0KTtcbiAgICByZXR1cm4gUGFyc2VyLnBhcnNlKExleGVyLmxleChzcmMsIG9wdCksIG9wdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlLm1lc3NhZ2UgKz0gJ1xcblBsZWFzZSByZXBvcnQgdGhpcyB0byBodHRwczovL2dpdGh1Yi5jb20vY2hqai9tYXJrZWQuJztcbiAgICBpZiAoKG9wdCB8fCBtYXJrZWQuZGVmYXVsdHMpLnNpbGVudCkge1xuICAgICAgcmV0dXJuICc8cD5BbiBlcnJvciBvY2N1cmVkOjwvcD48cHJlPidcbiAgICAgICAgKyBlc2NhcGUoZS5tZXNzYWdlICsgJycsIHRydWUpXG4gICAgICAgICsgJzwvcHJlPic7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH1cbn1cblxuLyoqXG4gKiBPcHRpb25zXG4gKi9cblxubWFya2VkLm9wdGlvbnMgPVxubWFya2VkLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHQpIHtcbiAgbWVyZ2UobWFya2VkLmRlZmF1bHRzLCBvcHQpO1xuICByZXR1cm4gbWFya2VkO1xufTtcblxubWFya2VkLmRlZmF1bHRzID0ge1xuICBnZm06IHRydWUsXG4gIHRhYmxlczogdHJ1ZSxcbiAgYnJlYWtzOiBmYWxzZSxcbiAgcGVkYW50aWM6IGZhbHNlLFxuICBzYW5pdGl6ZTogZmFsc2UsXG4gIHNtYXJ0TGlzdHM6IGZhbHNlLFxuICBzaWxlbnQ6IGZhbHNlLFxuICBoaWdobGlnaHQ6IG51bGwsXG4gIGxhbmdQcmVmaXg6ICdsYW5nLScsXG4gIHNtYXJ0eXBhbnRzOiBmYWxzZSxcbiAgaGVhZGVyUHJlZml4OiAnJyxcbiAgcmVuZGVyZXI6IG5ldyBSZW5kZXJlcixcbiAgeGh0bWw6IGZhbHNlXG59O1xuXG4vKipcbiAqIEV4cG9zZVxuICovXG5cbm1hcmtlZC5QYXJzZXIgPSBQYXJzZXI7XG5tYXJrZWQucGFyc2VyID0gUGFyc2VyLnBhcnNlO1xuXG5tYXJrZWQuUmVuZGVyZXIgPSBSZW5kZXJlcjtcblxubWFya2VkLkxleGVyID0gTGV4ZXI7XG5tYXJrZWQubGV4ZXIgPSBMZXhlci5sZXg7XG5cbm1hcmtlZC5JbmxpbmVMZXhlciA9IElubGluZUxleGVyO1xubWFya2VkLmlubGluZUxleGVyID0gSW5saW5lTGV4ZXIub3V0cHV0O1xuXG5tYXJrZWQucGFyc2UgPSBtYXJrZWQ7XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBtYXJrZWQ7XG59IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBtYXJrZWQ7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy5tYXJrZWQgPSBtYXJrZWQ7XG59XG5cbn0pLmNhbGwoZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzIHx8ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbCk7XG59KCkpO1xuIiwiLy8hIG1vbWVudC5qc1xuLy8hIHZlcnNpb24gOiAyLjUuMFxuLy8hIGF1dGhvcnMgOiBUaW0gV29vZCwgSXNrcmVuIENoZXJuZXYsIE1vbWVudC5qcyBjb250cmlidXRvcnNcbi8vISBsaWNlbnNlIDogTUlUXG4vLyEgbW9tZW50anMuY29tXG5cbihmdW5jdGlvbiAodW5kZWZpbmVkKSB7XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIENvbnN0YW50c1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIHZhciBtb21lbnQsXG4gICAgICAgIFZFUlNJT04gPSBcIjIuNS4wXCIsXG4gICAgICAgIGdsb2JhbCA9IHRoaXMsXG4gICAgICAgIHJvdW5kID0gTWF0aC5yb3VuZCxcbiAgICAgICAgaSxcblxuICAgICAgICBZRUFSID0gMCxcbiAgICAgICAgTU9OVEggPSAxLFxuICAgICAgICBEQVRFID0gMixcbiAgICAgICAgSE9VUiA9IDMsXG4gICAgICAgIE1JTlVURSA9IDQsXG4gICAgICAgIFNFQ09ORCA9IDUsXG4gICAgICAgIE1JTExJU0VDT05EID0gNixcblxuICAgICAgICAvLyBpbnRlcm5hbCBzdG9yYWdlIGZvciBsYW5ndWFnZSBjb25maWcgZmlsZXNcbiAgICAgICAgbGFuZ3VhZ2VzID0ge30sXG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIG5vZGVKU1xuICAgICAgICBoYXNNb2R1bGUgPSAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMgJiYgdHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSxcblxuICAgICAgICAvLyBBU1AuTkVUIGpzb24gZGF0ZSBmb3JtYXQgcmVnZXhcbiAgICAgICAgYXNwTmV0SnNvblJlZ2V4ID0gL15cXC8/RGF0ZVxcKChcXC0/XFxkKykvaSxcbiAgICAgICAgYXNwTmV0VGltZVNwYW5Kc29uUmVnZXggPSAvKFxcLSk/KD86KFxcZCopXFwuKT8oXFxkKylcXDooXFxkKykoPzpcXDooXFxkKylcXC4/KFxcZHszfSk/KT8vLFxuXG4gICAgICAgIC8vIGZyb20gaHR0cDovL2RvY3MuY2xvc3VyZS1saWJyYXJ5Lmdvb2dsZWNvZGUuY29tL2dpdC9jbG9zdXJlX2dvb2dfZGF0ZV9kYXRlLmpzLnNvdXJjZS5odG1sXG4gICAgICAgIC8vIHNvbWV3aGF0IG1vcmUgaW4gbGluZSB3aXRoIDQuNC4zLjIgMjAwNCBzcGVjLCBidXQgYWxsb3dzIGRlY2ltYWwgYW55d2hlcmVcbiAgICAgICAgaXNvRHVyYXRpb25SZWdleCA9IC9eKC0pP1AoPzooPzooWzAtOSwuXSopWSk/KD86KFswLTksLl0qKU0pPyg/OihbMC05LC5dKilEKT8oPzpUKD86KFswLTksLl0qKUgpPyg/OihbMC05LC5dKilNKT8oPzooWzAtOSwuXSopUyk/KT98KFswLTksLl0qKVcpJC8sXG5cbiAgICAgICAgLy8gZm9ybWF0IHRva2Vuc1xuICAgICAgICBmb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KE1vfE1NP00/TT98RG98REREb3xERD9EP0Q/fGRkZD9kP3xkbz98d1tvfHddP3xXW298V10/fFlZWVlZWXxZWVlZWXxZWVlZfFlZfGdnKGdnZz8pP3xHRyhHR0c/KT98ZXxFfGF8QXxoaD98SEg/fG1tP3xzcz98U3sxLDR9fFh8eno/fFpaP3wuKS9nLFxuICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oTFR8TEw/TD9MP3xsezEsNH0pL2csXG5cbiAgICAgICAgLy8gcGFyc2luZyB0b2tlbiByZWdleGVzXG4gICAgICAgIHBhcnNlVG9rZW5PbmVPclR3b0RpZ2l0cyA9IC9cXGRcXGQ/LywgLy8gMCAtIDk5XG4gICAgICAgIHBhcnNlVG9rZW5PbmVUb1RocmVlRGlnaXRzID0gL1xcZHsxLDN9LywgLy8gMCAtIDk5OVxuICAgICAgICBwYXJzZVRva2VuT25lVG9Gb3VyRGlnaXRzID0gL1xcZHsxLDR9LywgLy8gMCAtIDk5OTlcbiAgICAgICAgcGFyc2VUb2tlbk9uZVRvU2l4RGlnaXRzID0gL1srXFwtXT9cXGR7MSw2fS8sIC8vIC05OTksOTk5IC0gOTk5LDk5OVxuICAgICAgICBwYXJzZVRva2VuRGlnaXRzID0gL1xcZCsvLCAvLyBub256ZXJvIG51bWJlciBvZiBkaWdpdHNcbiAgICAgICAgcGFyc2VUb2tlbldvcmQgPSAvWzAtOV0qWydhLXpcXHUwMEEwLVxcdTA1RkZcXHUwNzAwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdK3xbXFx1MDYwMC1cXHUwNkZGXFwvXSsoXFxzKj9bXFx1MDYwMC1cXHUwNkZGXSspezEsMn0vaSwgLy8gYW55IHdvcmQgKG9yIHR3bykgY2hhcmFjdGVycyBvciBudW1iZXJzIGluY2x1ZGluZyB0d28vdGhyZWUgd29yZCBtb250aCBpbiBhcmFiaWMuXG4gICAgICAgIHBhcnNlVG9rZW5UaW1lem9uZSA9IC9afFtcXCtcXC1dXFxkXFxkOj9cXGRcXGQvZ2ksIC8vICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxuICAgICAgICBwYXJzZVRva2VuVCA9IC9UL2ksIC8vIFQgKElTTyBzZXBhcmF0b3IpXG4gICAgICAgIHBhcnNlVG9rZW5UaW1lc3RhbXBNcyA9IC9bXFwrXFwtXT9cXGQrKFxcLlxcZHsxLDN9KT8vLCAvLyAxMjM0NTY3ODkgMTIzNDU2Nzg5LjEyM1xuXG4gICAgICAgIC8vc3RyaWN0IHBhcnNpbmcgcmVnZXhlc1xuICAgICAgICBwYXJzZVRva2VuT25lRGlnaXQgPSAvXFxkLywgLy8gMCAtIDlcbiAgICAgICAgcGFyc2VUb2tlblR3b0RpZ2l0cyA9IC9cXGRcXGQvLCAvLyAwMCAtIDk5XG4gICAgICAgIHBhcnNlVG9rZW5UaHJlZURpZ2l0cyA9IC9cXGR7M30vLCAvLyAwMDAgLSA5OTlcbiAgICAgICAgcGFyc2VUb2tlbkZvdXJEaWdpdHMgPSAvXFxkezR9LywgLy8gMDAwMCAtIDk5OTlcbiAgICAgICAgcGFyc2VUb2tlblNpeERpZ2l0cyA9IC9bK1xcLV0/XFxkezZ9LywgLy8gLTk5OSw5OTkgLSA5OTksOTk5XG5cbiAgICAgICAgLy8gaXNvIDg2MDEgcmVnZXhcbiAgICAgICAgLy8gMDAwMC0wMC0wMCAwMDAwLVcwMCBvciAwMDAwLVcwMC0wICsgVCArIDAwIG9yIDAwOjAwIG9yIDAwOjAwOjAwIG9yIDAwOjAwOjAwLjAwMCArICswMDowMCBvciArMDAwMCBvciArMDApXG4gICAgICAgIGlzb1JlZ2V4ID0gL15cXHMqXFxkezR9LSg/OihcXGRcXGQtXFxkXFxkKXwoV1xcZFxcZCQpfChXXFxkXFxkLVxcZCl8KFxcZFxcZFxcZCkpKChUfCApKFxcZFxcZCg6XFxkXFxkKDpcXGRcXGQoXFwuXFxkKyk/KT8pPyk/KFtcXCtcXC1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLyxcblxuICAgICAgICBpc29Gb3JtYXQgPSAnWVlZWS1NTS1ERFRISDptbTpzc1onLFxuXG4gICAgICAgIGlzb0RhdGVzID0gW1xuICAgICAgICAgICAgJ1lZWVktTU0tREQnLFxuICAgICAgICAgICAgJ0dHR0ctW1ddV1cnLFxuICAgICAgICAgICAgJ0dHR0ctW1ddV1ctRScsXG4gICAgICAgICAgICAnWVlZWS1EREQnXG4gICAgICAgIF0sXG5cbiAgICAgICAgLy8gaXNvIHRpbWUgZm9ybWF0cyBhbmQgcmVnZXhlc1xuICAgICAgICBpc29UaW1lcyA9IFtcbiAgICAgICAgICAgIFsnSEg6bW06c3MuU1NTUycsIC8oVHwgKVxcZFxcZDpcXGRcXGQ6XFxkXFxkXFwuXFxkezEsM30vXSxcbiAgICAgICAgICAgIFsnSEg6bW06c3MnLCAvKFR8IClcXGRcXGQ6XFxkXFxkOlxcZFxcZC9dLFxuICAgICAgICAgICAgWydISDptbScsIC8oVHwgKVxcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgICAgIFsnSEgnLCAvKFR8IClcXGRcXGQvXVxuICAgICAgICBdLFxuXG4gICAgICAgIC8vIHRpbWV6b25lIGNodW5rZXIgXCIrMTA6MDBcIiA+IFtcIjEwXCIsIFwiMDBcIl0gb3IgXCItMTUzMFwiID4gW1wiLTE1XCIsIFwiMzBcIl1cbiAgICAgICAgcGFyc2VUaW1lem9uZUNodW5rZXIgPSAvKFtcXCtcXC1dfFxcZFxcZCkvZ2ksXG5cbiAgICAgICAgLy8gZ2V0dGVyIGFuZCBzZXR0ZXIgbmFtZXNcbiAgICAgICAgcHJveHlHZXR0ZXJzQW5kU2V0dGVycyA9ICdEYXRlfEhvdXJzfE1pbnV0ZXN8U2Vjb25kc3xNaWxsaXNlY29uZHMnLnNwbGl0KCd8JyksXG4gICAgICAgIHVuaXRNaWxsaXNlY29uZEZhY3RvcnMgPSB7XG4gICAgICAgICAgICAnTWlsbGlzZWNvbmRzJyA6IDEsXG4gICAgICAgICAgICAnU2Vjb25kcycgOiAxZTMsXG4gICAgICAgICAgICAnTWludXRlcycgOiA2ZTQsXG4gICAgICAgICAgICAnSG91cnMnIDogMzZlNSxcbiAgICAgICAgICAgICdEYXlzJyA6IDg2NGU1LFxuICAgICAgICAgICAgJ01vbnRocycgOiAyNTkyZTYsXG4gICAgICAgICAgICAnWWVhcnMnIDogMzE1MzZlNlxuICAgICAgICB9LFxuXG4gICAgICAgIHVuaXRBbGlhc2VzID0ge1xuICAgICAgICAgICAgbXMgOiAnbWlsbGlzZWNvbmQnLFxuICAgICAgICAgICAgcyA6ICdzZWNvbmQnLFxuICAgICAgICAgICAgbSA6ICdtaW51dGUnLFxuICAgICAgICAgICAgaCA6ICdob3VyJyxcbiAgICAgICAgICAgIGQgOiAnZGF5JyxcbiAgICAgICAgICAgIEQgOiAnZGF0ZScsXG4gICAgICAgICAgICB3IDogJ3dlZWsnLFxuICAgICAgICAgICAgVyA6ICdpc29XZWVrJyxcbiAgICAgICAgICAgIE0gOiAnbW9udGgnLFxuICAgICAgICAgICAgeSA6ICd5ZWFyJyxcbiAgICAgICAgICAgIERERCA6ICdkYXlPZlllYXInLFxuICAgICAgICAgICAgZSA6ICd3ZWVrZGF5JyxcbiAgICAgICAgICAgIEUgOiAnaXNvV2Vla2RheScsXG4gICAgICAgICAgICBnZzogJ3dlZWtZZWFyJyxcbiAgICAgICAgICAgIEdHOiAnaXNvV2Vla1llYXInXG4gICAgICAgIH0sXG5cbiAgICAgICAgY2FtZWxGdW5jdGlvbnMgPSB7XG4gICAgICAgICAgICBkYXlvZnllYXIgOiAnZGF5T2ZZZWFyJyxcbiAgICAgICAgICAgIGlzb3dlZWtkYXkgOiAnaXNvV2Vla2RheScsXG4gICAgICAgICAgICBpc293ZWVrIDogJ2lzb1dlZWsnLFxuICAgICAgICAgICAgd2Vla3llYXIgOiAnd2Vla1llYXInLFxuICAgICAgICAgICAgaXNvd2Vla3llYXIgOiAnaXNvV2Vla1llYXInXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gZm9ybWF0IGZ1bmN0aW9uIHN0cmluZ3NcbiAgICAgICAgZm9ybWF0RnVuY3Rpb25zID0ge30sXG5cbiAgICAgICAgLy8gdG9rZW5zIHRvIG9yZGluYWxpemUgYW5kIHBhZFxuICAgICAgICBvcmRpbmFsaXplVG9rZW5zID0gJ0RERCB3IFcgTSBEIGQnLnNwbGl0KCcgJyksXG4gICAgICAgIHBhZGRlZFRva2VucyA9ICdNIEQgSCBoIG0gcyB3IFcnLnNwbGl0KCcgJyksXG5cbiAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnMgPSB7XG4gICAgICAgICAgICBNICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1vbnRoKCkgKyAxO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIE1NTSAgOiBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFuZygpLm1vbnRoc1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgTU1NTSA6IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sYW5nKCkubW9udGhzKHRoaXMsIGZvcm1hdCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgRCAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgREREICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXlPZlllYXIoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRheSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRkICAgOiBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFuZygpLndlZWtkYXlzTWluKHRoaXMsIGZvcm1hdCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGRkICA6IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sYW5nKCkud2Vla2RheXNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRkZGQgOiBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFuZygpLndlZWtkYXlzKHRoaXMsIGZvcm1hdCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdyAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53ZWVrKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgVyAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc29XZWVrKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgWVkgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdFplcm9GaWxsKHRoaXMueWVhcigpICUgMTAwLCAyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBZWVlZIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0WmVyb0ZpbGwodGhpcy55ZWFyKCksIDQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFlZWVlZIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0WmVyb0ZpbGwodGhpcy55ZWFyKCksIDUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFlZWVlZWSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHRoaXMueWVhcigpLCBzaWduID0geSA+PSAwID8gJysnIDogJy0nO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaWduICsgbGVmdFplcm9GaWxsKE1hdGguYWJzKHkpLCA2KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZyAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0WmVyb0ZpbGwodGhpcy53ZWVrWWVhcigpICUgMTAwLCAyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZ2dnIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndlZWtZZWFyKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2dnZ2cgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbCh0aGlzLndlZWtZZWFyKCksIDUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEdHICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbCh0aGlzLmlzb1dlZWtZZWFyKCkgJSAxMDAsIDIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEdHR0cgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNvV2Vla1llYXIoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBHR0dHRyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdFplcm9GaWxsKHRoaXMuaXNvV2Vla1llYXIoKSwgNSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53ZWVrZGF5KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgRSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc29XZWVrZGF5KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYSAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sYW5nKCkubWVyaWRpZW0odGhpcy5ob3VycygpLCB0aGlzLm1pbnV0ZXMoKSwgdHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgQSAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sYW5nKCkubWVyaWRpZW0odGhpcy5ob3VycygpLCB0aGlzLm1pbnV0ZXMoKSwgZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEggICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhvdXJzKCkgJSAxMiB8fCAxMjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1pbnV0ZXMoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlY29uZHMoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBTICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b0ludCh0aGlzLm1pbGxpc2Vjb25kcygpIC8gMTAwKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBTUyAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0WmVyb0ZpbGwodG9JbnQodGhpcy5taWxsaXNlY29uZHMoKSAvIDEwKSwgMik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgU1NTICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdFplcm9GaWxsKHRoaXMubWlsbGlzZWNvbmRzKCksIDMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFNTU1MgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbCh0aGlzLm1pbGxpc2Vjb25kcygpLCAzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBaICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhID0gLXRoaXMuem9uZSgpLFxuICAgICAgICAgICAgICAgICAgICBiID0gXCIrXCI7XG4gICAgICAgICAgICAgICAgaWYgKGEgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGEgPSAtYTtcbiAgICAgICAgICAgICAgICAgICAgYiA9IFwiLVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYiArIGxlZnRaZXJvRmlsbCh0b0ludChhIC8gNjApLCAyKSArIFwiOlwiICsgbGVmdFplcm9GaWxsKHRvSW50KGEpICUgNjAsIDIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFpaICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSAtdGhpcy56b25lKCksXG4gICAgICAgICAgICAgICAgICAgIGIgPSBcIitcIjtcbiAgICAgICAgICAgICAgICBpZiAoYSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYSA9IC1hO1xuICAgICAgICAgICAgICAgICAgICBiID0gXCItXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBiICsgbGVmdFplcm9GaWxsKHRvSW50KGEgLyA2MCksIDIpICsgbGVmdFplcm9GaWxsKHRvSW50KGEpICUgNjAsIDIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHogOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuem9uZUFiYnIoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB6eiA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy56b25lTmFtZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFggICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5peCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFEgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVhcnRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGxpc3RzID0gWydtb250aHMnLCAnbW9udGhzU2hvcnQnLCAnd2Vla2RheXMnLCAnd2Vla2RheXNTaG9ydCcsICd3ZWVrZGF5c01pbiddO1xuXG4gICAgZnVuY3Rpb24gcGFkVG9rZW4oZnVuYywgY291bnQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICByZXR1cm4gbGVmdFplcm9GaWxsKGZ1bmMuY2FsbCh0aGlzLCBhKSwgY291bnQpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBvcmRpbmFsaXplVG9rZW4oZnVuYywgcGVyaW9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFuZygpLm9yZGluYWwoZnVuYy5jYWxsKHRoaXMsIGEpLCBwZXJpb2QpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHdoaWxlIChvcmRpbmFsaXplVG9rZW5zLmxlbmd0aCkge1xuICAgICAgICBpID0gb3JkaW5hbGl6ZVRva2Vucy5wb3AoKTtcbiAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbaSArICdvJ10gPSBvcmRpbmFsaXplVG9rZW4oZm9ybWF0VG9rZW5GdW5jdGlvbnNbaV0sIGkpO1xuICAgIH1cbiAgICB3aGlsZSAocGFkZGVkVG9rZW5zLmxlbmd0aCkge1xuICAgICAgICBpID0gcGFkZGVkVG9rZW5zLnBvcCgpO1xuICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1tpICsgaV0gPSBwYWRUb2tlbihmb3JtYXRUb2tlbkZ1bmN0aW9uc1tpXSwgMik7XG4gICAgfVxuICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zLkREREQgPSBwYWRUb2tlbihmb3JtYXRUb2tlbkZ1bmN0aW9ucy5EREQsIDMpO1xuXG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIENvbnN0cnVjdG9yc1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIGZ1bmN0aW9uIExhbmd1YWdlKCkge1xuXG4gICAgfVxuXG4gICAgLy8gTW9tZW50IHByb3RvdHlwZSBvYmplY3RcbiAgICBmdW5jdGlvbiBNb21lbnQoY29uZmlnKSB7XG4gICAgICAgIGNoZWNrT3ZlcmZsb3coY29uZmlnKTtcbiAgICAgICAgZXh0ZW5kKHRoaXMsIGNvbmZpZyk7XG4gICAgfVxuXG4gICAgLy8gRHVyYXRpb24gQ29uc3RydWN0b3JcbiAgICBmdW5jdGlvbiBEdXJhdGlvbihkdXJhdGlvbikge1xuICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoZHVyYXRpb24pLFxuICAgICAgICAgICAgeWVhcnMgPSBub3JtYWxpemVkSW5wdXQueWVhciB8fCAwLFxuICAgICAgICAgICAgbW9udGhzID0gbm9ybWFsaXplZElucHV0Lm1vbnRoIHx8IDAsXG4gICAgICAgICAgICB3ZWVrcyA9IG5vcm1hbGl6ZWRJbnB1dC53ZWVrIHx8IDAsXG4gICAgICAgICAgICBkYXlzID0gbm9ybWFsaXplZElucHV0LmRheSB8fCAwLFxuICAgICAgICAgICAgaG91cnMgPSBub3JtYWxpemVkSW5wdXQuaG91ciB8fCAwLFxuICAgICAgICAgICAgbWludXRlcyA9IG5vcm1hbGl6ZWRJbnB1dC5taW51dGUgfHwgMCxcbiAgICAgICAgICAgIHNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQuc2Vjb25kIHx8IDAsXG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQubWlsbGlzZWNvbmQgfHwgMDtcblxuICAgICAgICAvLyByZXByZXNlbnRhdGlvbiBmb3IgZGF0ZUFkZFJlbW92ZVxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPSArbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgIHNlY29uZHMgKiAxZTMgKyAvLyAxMDAwXG4gICAgICAgICAgICBtaW51dGVzICogNmU0ICsgLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICBob3VycyAqIDM2ZTU7IC8vIDEwMDAgKiA2MCAqIDYwXG4gICAgICAgIC8vIEJlY2F1c2Ugb2YgZGF0ZUFkZFJlbW92ZSB0cmVhdHMgMjQgaG91cnMgYXMgZGlmZmVyZW50IGZyb20gYVxuICAgICAgICAvLyBkYXkgd2hlbiB3b3JraW5nIGFyb3VuZCBEU1QsIHdlIG5lZWQgdG8gc3RvcmUgdGhlbSBzZXBhcmF0ZWx5XG4gICAgICAgIHRoaXMuX2RheXMgPSArZGF5cyArXG4gICAgICAgICAgICB3ZWVrcyAqIDc7XG4gICAgICAgIC8vIEl0IGlzIGltcG9zc2libGUgdHJhbnNsYXRlIG1vbnRocyBpbnRvIGRheXMgd2l0aG91dCBrbm93aW5nXG4gICAgICAgIC8vIHdoaWNoIG1vbnRocyB5b3UgYXJlIGFyZSB0YWxraW5nIGFib3V0LCBzbyB3ZSBoYXZlIHRvIHN0b3JlXG4gICAgICAgIC8vIGl0IHNlcGFyYXRlbHkuXG4gICAgICAgIHRoaXMuX21vbnRocyA9ICttb250aHMgK1xuICAgICAgICAgICAgeWVhcnMgKiAxMjtcblxuICAgICAgICB0aGlzLl9kYXRhID0ge307XG5cbiAgICAgICAgdGhpcy5fYnViYmxlKCk7XG4gICAgfVxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBIZWxwZXJzXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgICBmdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgICAgICBmb3IgKHZhciBpIGluIGIpIHtcbiAgICAgICAgICAgIGlmIChiLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICAgICAgYVtpXSA9IGJbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYi5oYXNPd25Qcm9wZXJ0eShcInRvU3RyaW5nXCIpKSB7XG4gICAgICAgICAgICBhLnRvU3RyaW5nID0gYi50b1N0cmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiLmhhc093blByb3BlcnR5KFwidmFsdWVPZlwiKSkge1xuICAgICAgICAgICAgYS52YWx1ZU9mID0gYi52YWx1ZU9mO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzUm91bmQobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gbGVmdCB6ZXJvIGZpbGwgYSBudW1iZXJcbiAgICAvLyBzZWUgaHR0cDovL2pzcGVyZi5jb20vbGVmdC16ZXJvLWZpbGxpbmcgZm9yIHBlcmZvcm1hbmNlIGNvbXBhcmlzb25cbiAgICBmdW5jdGlvbiBsZWZ0WmVyb0ZpbGwobnVtYmVyLCB0YXJnZXRMZW5ndGgsIGZvcmNlU2lnbikge1xuICAgICAgICB2YXIgb3V0cHV0ID0gTWF0aC5hYnMobnVtYmVyKSArICcnLFxuICAgICAgICAgICAgc2lnbiA9IG51bWJlciA+PSAwO1xuXG4gICAgICAgIHdoaWxlIChvdXRwdXQubGVuZ3RoIDwgdGFyZ2V0TGVuZ3RoKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSAnMCcgKyBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChzaWduID8gKGZvcmNlU2lnbiA/ICcrJyA6ICcnKSA6ICctJykgKyBvdXRwdXQ7XG4gICAgfVxuXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uIGZvciBfLmFkZFRpbWUgYW5kIF8uc3VidHJhY3RUaW1lXG4gICAgZnVuY3Rpb24gYWRkT3JTdWJ0cmFjdER1cmF0aW9uRnJvbU1vbWVudChtb20sIGR1cmF0aW9uLCBpc0FkZGluZywgaWdub3JlVXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgZGF5cyA9IGR1cmF0aW9uLl9kYXlzLFxuICAgICAgICAgICAgbW9udGhzID0gZHVyYXRpb24uX21vbnRocyxcbiAgICAgICAgICAgIG1pbnV0ZXMsXG4gICAgICAgICAgICBob3VycztcblxuICAgICAgICBpZiAobWlsbGlzZWNvbmRzKSB7XG4gICAgICAgICAgICBtb20uX2Quc2V0VGltZSgrbW9tLl9kICsgbWlsbGlzZWNvbmRzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0b3JlIHRoZSBtaW51dGVzIGFuZCBob3VycyBzbyB3ZSBjYW4gcmVzdG9yZSB0aGVtXG4gICAgICAgIGlmIChkYXlzIHx8IG1vbnRocykge1xuICAgICAgICAgICAgbWludXRlcyA9IG1vbS5taW51dGUoKTtcbiAgICAgICAgICAgIGhvdXJzID0gbW9tLmhvdXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF5cykge1xuICAgICAgICAgICAgbW9tLmRhdGUobW9tLmRhdGUoKSArIGRheXMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vbnRocykge1xuICAgICAgICAgICAgbW9tLm1vbnRoKG1vbS5tb250aCgpICsgbW9udGhzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaWxsaXNlY29uZHMgJiYgIWlnbm9yZVVwZGF0ZU9mZnNldCkge1xuICAgICAgICAgICAgbW9tZW50LnVwZGF0ZU9mZnNldChtb20pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlc3RvcmUgdGhlIG1pbnV0ZXMgYW5kIGhvdXJzIGFmdGVyIHBvc3NpYmx5IGNoYW5naW5nIGRzdFxuICAgICAgICBpZiAoZGF5cyB8fCBtb250aHMpIHtcbiAgICAgICAgICAgIG1vbS5taW51dGUobWludXRlcyk7XG4gICAgICAgICAgICBtb20uaG91cihob3Vycyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBpcyBhbiBhcnJheVxuICAgIGZ1bmN0aW9uIGlzQXJyYXkoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXRlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRGF0ZV0nIHx8XG4gICAgICAgICAgICAgICAgaW5wdXQgaW5zdGFuY2VvZiBEYXRlO1xuICAgIH1cblxuICAgIC8vIGNvbXBhcmUgdHdvIGFycmF5cywgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGlmZmVyZW5jZXNcbiAgICBmdW5jdGlvbiBjb21wYXJlQXJyYXlzKGFycmF5MSwgYXJyYXkyLCBkb250Q29udmVydCkge1xuICAgICAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJyYXkxLmxlbmd0aCwgYXJyYXkyLmxlbmd0aCksXG4gICAgICAgICAgICBsZW5ndGhEaWZmID0gTWF0aC5hYnMoYXJyYXkxLmxlbmd0aCAtIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgZGlmZnMgPSAwLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKGRvbnRDb252ZXJ0ICYmIGFycmF5MVtpXSAhPT0gYXJyYXkyW2ldKSB8fFxuICAgICAgICAgICAgICAgICghZG9udENvbnZlcnQgJiYgdG9JbnQoYXJyYXkxW2ldKSAhPT0gdG9JbnQoYXJyYXkyW2ldKSkpIHtcbiAgICAgICAgICAgICAgICBkaWZmcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWZmcyArIGxlbmd0aERpZmY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplVW5pdHModW5pdHMpIHtcbiAgICAgICAgaWYgKHVuaXRzKSB7XG4gICAgICAgICAgICB2YXIgbG93ZXJlZCA9IHVuaXRzLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvKC4pcyQvLCAnJDEnKTtcbiAgICAgICAgICAgIHVuaXRzID0gdW5pdEFsaWFzZXNbdW5pdHNdIHx8IGNhbWVsRnVuY3Rpb25zW2xvd2VyZWRdIHx8IGxvd2VyZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuaXRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU9iamVjdFVuaXRzKGlucHV0T2JqZWN0KSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSB7fSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wLFxuICAgICAgICAgICAgcHJvcDtcblxuICAgICAgICBmb3IgKHByb3AgaW4gaW5wdXRPYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dE9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wID0gbm9ybWFsaXplVW5pdHMocHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dFtub3JtYWxpemVkUHJvcF0gPSBpbnB1dE9iamVjdFtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZElucHV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VMaXN0KGZpZWxkKSB7XG4gICAgICAgIHZhciBjb3VudCwgc2V0dGVyO1xuXG4gICAgICAgIGlmIChmaWVsZC5pbmRleE9mKCd3ZWVrJykgPT09IDApIHtcbiAgICAgICAgICAgIGNvdW50ID0gNztcbiAgICAgICAgICAgIHNldHRlciA9ICdkYXknO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpZWxkLmluZGV4T2YoJ21vbnRoJykgPT09IDApIHtcbiAgICAgICAgICAgIGNvdW50ID0gMTI7XG4gICAgICAgICAgICBzZXR0ZXIgPSAnbW9udGgnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbW9tZW50W2ZpZWxkXSA9IGZ1bmN0aW9uIChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgaSwgZ2V0dGVyLFxuICAgICAgICAgICAgICAgIG1ldGhvZCA9IG1vbWVudC5mbi5fbGFuZ1tmaWVsZF0sXG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGZvcm1hdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdldHRlciA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG0gPSBtb21lbnQoKS51dGMoKS5zZXQoc2V0dGVyLCBpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kLmNhbGwobW9tZW50LmZuLl9sYW5nLCBtLCBmb3JtYXQgfHwgJycpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0dGVyKGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChnZXR0ZXIoaSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0ludChhcmd1bWVudEZvckNvZXJjaW9uKSB7XG4gICAgICAgIHZhciBjb2VyY2VkTnVtYmVyID0gK2FyZ3VtZW50Rm9yQ29lcmNpb24sXG4gICAgICAgICAgICB2YWx1ZSA9IDA7XG5cbiAgICAgICAgaWYgKGNvZXJjZWROdW1iZXIgIT09IDAgJiYgaXNGaW5pdGUoY29lcmNlZE51bWJlcikpIHtcbiAgICAgICAgICAgIGlmIChjb2VyY2VkTnVtYmVyID49IDApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGguZmxvb3IoY29lcmNlZE51bWJlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gTWF0aC5jZWlsKGNvZXJjZWROdW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCArIDEsIDApKS5nZXRVVENEYXRlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c0luWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDApIHx8IHllYXIgJSA0MDAgPT09IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tPdmVyZmxvdyhtKSB7XG4gICAgICAgIHZhciBvdmVyZmxvdztcbiAgICAgICAgaWYgKG0uX2EgJiYgbS5fcGYub3ZlcmZsb3cgPT09IC0yKSB7XG4gICAgICAgICAgICBvdmVyZmxvdyA9XG4gICAgICAgICAgICAgICAgbS5fYVtNT05USF0gPCAwIHx8IG0uX2FbTU9OVEhdID4gMTEgPyBNT05USCA6XG4gICAgICAgICAgICAgICAgbS5fYVtEQVRFXSA8IDEgfHwgbS5fYVtEQVRFXSA+IGRheXNJbk1vbnRoKG0uX2FbWUVBUl0sIG0uX2FbTU9OVEhdKSA/IERBVEUgOlxuICAgICAgICAgICAgICAgIG0uX2FbSE9VUl0gPCAwIHx8IG0uX2FbSE9VUl0gPiAyMyA/IEhPVVIgOlxuICAgICAgICAgICAgICAgIG0uX2FbTUlOVVRFXSA8IDAgfHwgbS5fYVtNSU5VVEVdID4gNTkgPyBNSU5VVEUgOlxuICAgICAgICAgICAgICAgIG0uX2FbU0VDT05EXSA8IDAgfHwgbS5fYVtTRUNPTkRdID4gNTkgPyBTRUNPTkQgOlxuICAgICAgICAgICAgICAgIG0uX2FbTUlMTElTRUNPTkRdIDwgMCB8fCBtLl9hW01JTExJU0VDT05EXSA+IDk5OSA/IE1JTExJU0VDT05EIDpcbiAgICAgICAgICAgICAgICAtMTtcblxuICAgICAgICAgICAgaWYgKG0uX3BmLl9vdmVyZmxvd0RheU9mWWVhciAmJiAob3ZlcmZsb3cgPCBZRUFSIHx8IG92ZXJmbG93ID4gREFURSkpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IERBVEU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG0uX3BmLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0aWFsaXplUGFyc2luZ0ZsYWdzKGNvbmZpZykge1xuICAgICAgICBjb25maWcuX3BmID0ge1xuICAgICAgICAgICAgZW1wdHkgOiBmYWxzZSxcbiAgICAgICAgICAgIHVudXNlZFRva2VucyA6IFtdLFxuICAgICAgICAgICAgdW51c2VkSW5wdXQgOiBbXSxcbiAgICAgICAgICAgIG92ZXJmbG93IDogLTIsXG4gICAgICAgICAgICBjaGFyc0xlZnRPdmVyIDogMCxcbiAgICAgICAgICAgIG51bGxJbnB1dCA6IGZhbHNlLFxuICAgICAgICAgICAgaW52YWxpZE1vbnRoIDogbnVsbCxcbiAgICAgICAgICAgIGludmFsaWRGb3JtYXQgOiBmYWxzZSxcbiAgICAgICAgICAgIHVzZXJJbnZhbGlkYXRlZCA6IGZhbHNlLFxuICAgICAgICAgICAgaXNvOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWQobSkge1xuICAgICAgICBpZiAobS5faXNWYWxpZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBtLl9pc1ZhbGlkID0gIWlzTmFOKG0uX2QuZ2V0VGltZSgpKSAmJlxuICAgICAgICAgICAgICAgIG0uX3BmLm92ZXJmbG93IDwgMCAmJlxuICAgICAgICAgICAgICAgICFtLl9wZi5lbXB0eSAmJlxuICAgICAgICAgICAgICAgICFtLl9wZi5pbnZhbGlkTW9udGggJiZcbiAgICAgICAgICAgICAgICAhbS5fcGYubnVsbElucHV0ICYmXG4gICAgICAgICAgICAgICAgIW0uX3BmLmludmFsaWRGb3JtYXQgJiZcbiAgICAgICAgICAgICAgICAhbS5fcGYudXNlckludmFsaWRhdGVkO1xuXG4gICAgICAgICAgICBpZiAobS5fc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgbS5faXNWYWxpZCA9IG0uX2lzVmFsaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgbS5fcGYuY2hhcnNMZWZ0T3ZlciA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBtLl9wZi51bnVzZWRUb2tlbnMubGVuZ3RoID09PSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUxhbmd1YWdlKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ID8ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJykgOiBrZXk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGEgbW9tZW50IGZyb20gaW5wdXQsIHRoYXQgaXMgbG9jYWwvdXRjL3pvbmUgZXF1aXZhbGVudCB0byBtb2RlbC5cbiAgICBmdW5jdGlvbiBtYWtlQXMoaW5wdXQsIG1vZGVsKSB7XG4gICAgICAgIHJldHVybiBtb2RlbC5faXNVVEMgPyBtb21lbnQoaW5wdXQpLnpvbmUobW9kZWwuX29mZnNldCB8fCAwKSA6XG4gICAgICAgICAgICBtb21lbnQoaW5wdXQpLmxvY2FsKCk7XG4gICAgfVxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBMYW5ndWFnZXNcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgIGV4dGVuZChMYW5ndWFnZS5wcm90b3R5cGUsIHtcblxuICAgICAgICBzZXQgOiBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICB2YXIgcHJvcCwgaTtcbiAgICAgICAgICAgIGZvciAoaSBpbiBjb25maWcpIHtcbiAgICAgICAgICAgICAgICBwcm9wID0gY29uZmlnW2ldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW2ldID0gcHJvcDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzWydfJyArIGldID0gcHJvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX21vbnRocyA6IFwiSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlclwiLnNwbGl0KFwiX1wiKSxcbiAgICAgICAgbW9udGhzIDogZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNbbS5tb250aCgpXTtcbiAgICAgICAgfSxcblxuICAgICAgICBfbW9udGhzU2hvcnQgOiBcIkphbl9GZWJfTWFyX0Fwcl9NYXlfSnVuX0p1bF9BdWdfU2VwX09jdF9Ob3ZfRGVjXCIuc3BsaXQoXCJfXCIpLFxuICAgICAgICBtb250aHNTaG9ydCA6IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRbbS5tb250aCgpXTtcbiAgICAgICAgfSxcblxuICAgICAgICBtb250aHNQYXJzZSA6IGZ1bmN0aW9uIChtb250aE5hbWUpIHtcbiAgICAgICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vbSA9IG1vbWVudC51dGMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKSArICd8XicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfd2Vla2RheXMgOiBcIlN1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5XCIuc3BsaXQoXCJfXCIpLFxuICAgICAgICB3ZWVrZGF5cyA6IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNbbS5kYXkoKV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3dlZWtkYXlzU2hvcnQgOiBcIlN1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdFwiLnNwbGl0KFwiX1wiKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXTtcbiAgICAgICAgfSxcblxuICAgICAgICBfd2Vla2RheXNNaW4gOiBcIlN1X01vX1R1X1dlX1RoX0ZyX1NhXCIuc3BsaXQoXCJfXCIpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5bbS5kYXkoKV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgd2Vla2RheXNQYXJzZSA6IGZ1bmN0aW9uICh3ZWVrZGF5TmFtZSkge1xuICAgICAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgICAgICBtb20gPSBtb21lbnQoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykgKyAnfF4nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2xvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiBcImg6bW0gQVwiLFxuICAgICAgICAgICAgTCA6IFwiTU0vREQvWVlZWVwiLFxuICAgICAgICAgICAgTEwgOiBcIk1NTU0gRCBZWVlZXCIsXG4gICAgICAgICAgICBMTEwgOiBcIk1NTU0gRCBZWVlZIExUXCIsXG4gICAgICAgICAgICBMTExMIDogXCJkZGRkLCBNTU1NIEQgWVlZWSBMVFwiXG4gICAgICAgIH0sXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV07XG4gICAgICAgICAgICBpZiAoIW91dHB1dCAmJiB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXkudG9VcHBlckNhc2UoKV0pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXkudG9VcHBlckNhc2UoKV0ucmVwbGFjZSgvTU1NTXxNTXxERHxkZGRkL2csIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbC5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldID0gb3V0cHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfSxcblxuICAgICAgICBpc1BNIDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICAvLyBJRTggUXVpcmtzIE1vZGUgJiBJRTcgU3RhbmRhcmRzIE1vZGUgZG8gbm90IGFsbG93IGFjY2Vzc2luZyBzdHJpbmdzIGxpa2UgYXJyYXlzXG4gICAgICAgICAgICAvLyBVc2luZyBjaGFyQXQgc2hvdWxkIGJlIG1vcmUgY29tcGF0aWJsZS5cbiAgICAgICAgICAgIHJldHVybiAoKGlucHV0ICsgJycpLnRvTG93ZXJDYXNlKCkuY2hhckF0KDApID09PSAncCcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9tZXJpZGllbVBhcnNlIDogL1thcF1cXC4/bT9cXC4/L2ksXG4gICAgICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XG4gICAgICAgICAgICBpZiAoaG91cnMgPiAxMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3BtJyA6ICdQTSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ2FtJyA6ICdBTSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2NhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdbVG9kYXkgYXRdIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW1RvbW9ycm93IGF0XSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFthdF0gTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdbTGFzdF0gZGRkZCBbYXRdIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDogZnVuY3Rpb24gKGtleSwgbW9tKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fY2FsZW5kYXJba2V5XTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb3V0cHV0ID09PSAnZnVuY3Rpb24nID8gb3V0cHV0LmFwcGx5KG1vbSkgOiBvdXRwdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3JlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6IFwiaW4gJXNcIixcbiAgICAgICAgICAgIHBhc3QgOiBcIiVzIGFnb1wiLFxuICAgICAgICAgICAgcyA6IFwiYSBmZXcgc2Vjb25kc1wiLFxuICAgICAgICAgICAgbSA6IFwiYSBtaW51dGVcIixcbiAgICAgICAgICAgIG1tIDogXCIlZCBtaW51dGVzXCIsXG4gICAgICAgICAgICBoIDogXCJhbiBob3VyXCIsXG4gICAgICAgICAgICBoaCA6IFwiJWQgaG91cnNcIixcbiAgICAgICAgICAgIGQgOiBcImEgZGF5XCIsXG4gICAgICAgICAgICBkZCA6IFwiJWQgZGF5c1wiLFxuICAgICAgICAgICAgTSA6IFwiYSBtb250aFwiLFxuICAgICAgICAgICAgTU0gOiBcIiVkIG1vbnRoc1wiLFxuICAgICAgICAgICAgeSA6IFwiYSB5ZWFyXCIsXG4gICAgICAgICAgICB5eSA6IFwiJWQgeWVhcnNcIlxuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiBmdW5jdGlvbiAobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW3N0cmluZ107XG4gICAgICAgICAgICByZXR1cm4gKHR5cGVvZiBvdXRwdXQgPT09ICdmdW5jdGlvbicpID9cbiAgICAgICAgICAgICAgICBvdXRwdXQobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSA6XG4gICAgICAgICAgICAgICAgb3V0cHV0LnJlcGxhY2UoLyVkL2ksIG51bWJlcik7XG4gICAgICAgIH0sXG4gICAgICAgIHBhc3RGdXR1cmUgOiBmdW5jdGlvbiAoZGlmZiwgb3V0cHV0KSB7XG4gICAgICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW2RpZmYgPiAwID8gJ2Z1dHVyZScgOiAncGFzdCddO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBmb3JtYXQgPT09ICdmdW5jdGlvbicgPyBmb3JtYXQob3V0cHV0KSA6IGZvcm1hdC5yZXBsYWNlKC8lcy9pLCBvdXRwdXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb3JkaW5hbC5yZXBsYWNlKFwiJWRcIiwgbnVtYmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgX29yZGluYWwgOiBcIiVkXCIsXG5cbiAgICAgICAgcHJlcGFyc2UgOiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBvc3Rmb3JtYXQgOiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICB9LFxuXG4gICAgICAgIHdlZWsgOiBmdW5jdGlvbiAobW9tKSB7XG4gICAgICAgICAgICByZXR1cm4gd2Vla09mWWVhcihtb20sIHRoaXMuX3dlZWsuZG93LCB0aGlzLl93ZWVrLmRveSkud2VlaztcbiAgICAgICAgfSxcblxuICAgICAgICBfd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNiAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9LFxuXG4gICAgICAgIF9pbnZhbGlkRGF0ZTogJ0ludmFsaWQgZGF0ZScsXG4gICAgICAgIGludmFsaWREYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW52YWxpZERhdGU7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIExvYWRzIGEgbGFuZ3VhZ2UgZGVmaW5pdGlvbiBpbnRvIHRoZSBgbGFuZ3VhZ2VzYCBjYWNoZS4gIFRoZSBmdW5jdGlvblxuICAgIC8vIHRha2VzIGEga2V5IGFuZCBvcHRpb25hbGx5IHZhbHVlcy4gIElmIG5vdCBpbiB0aGUgYnJvd3NlciBhbmQgbm8gdmFsdWVzXG4gICAgLy8gYXJlIHByb3ZpZGVkLCBpdCB3aWxsIGxvYWQgdGhlIGxhbmd1YWdlIGZpbGUgbW9kdWxlLiAgQXMgYSBjb252ZW5pZW5jZSxcbiAgICAvLyB0aGlzIGZ1bmN0aW9uIGFsc28gcmV0dXJucyB0aGUgbGFuZ3VhZ2UgdmFsdWVzLlxuICAgIGZ1bmN0aW9uIGxvYWRMYW5nKGtleSwgdmFsdWVzKSB7XG4gICAgICAgIHZhbHVlcy5hYmJyID0ga2V5O1xuICAgICAgICBpZiAoIWxhbmd1YWdlc1trZXldKSB7XG4gICAgICAgICAgICBsYW5ndWFnZXNba2V5XSA9IG5ldyBMYW5ndWFnZSgpO1xuICAgICAgICB9XG4gICAgICAgIGxhbmd1YWdlc1trZXldLnNldCh2YWx1ZXMpO1xuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VzW2tleV07XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGEgbGFuZ3VhZ2UgZnJvbSB0aGUgYGxhbmd1YWdlc2AgY2FjaGUuIE1vc3RseSB1c2VmdWwgaW4gdGVzdHMuXG4gICAgZnVuY3Rpb24gdW5sb2FkTGFuZyhrZXkpIHtcbiAgICAgICAgZGVsZXRlIGxhbmd1YWdlc1trZXldO1xuICAgIH1cblxuICAgIC8vIERldGVybWluZXMgd2hpY2ggbGFuZ3VhZ2UgZGVmaW5pdGlvbiB0byB1c2UgYW5kIHJldHVybnMgaXQuXG4gICAgLy9cbiAgICAvLyBXaXRoIG5vIHBhcmFtZXRlcnMsIGl0IHdpbGwgcmV0dXJuIHRoZSBnbG9iYWwgbGFuZ3VhZ2UuICBJZiB5b3VcbiAgICAvLyBwYXNzIGluIGEgbGFuZ3VhZ2Uga2V5LCBzdWNoIGFzICdlbicsIGl0IHdpbGwgcmV0dXJuIHRoZVxuICAgIC8vIGRlZmluaXRpb24gZm9yICdlbicsIHNvIGxvbmcgYXMgJ2VuJyBoYXMgYWxyZWFkeSBiZWVuIGxvYWRlZCB1c2luZ1xuICAgIC8vIG1vbWVudC5sYW5nLlxuICAgIGZ1bmN0aW9uIGdldExhbmdEZWZpbml0aW9uKGtleSkge1xuICAgICAgICB2YXIgaSA9IDAsIGosIGxhbmcsIG5leHQsIHNwbGl0LFxuICAgICAgICAgICAgZ2V0ID0gZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxhbmd1YWdlc1trXSAmJiBoYXNNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vbGFuZy8nICsgayk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbGFuZ3VhZ2VzW2tdO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmV0dXJuIG1vbWVudC5mbi5fbGFuZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNBcnJheShrZXkpKSB7XG4gICAgICAgICAgICAvL3Nob3J0LWNpcmN1aXQgZXZlcnl0aGluZyBlbHNlXG4gICAgICAgICAgICBsYW5nID0gZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAobGFuZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBsYW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5ID0gW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICAvL3BpY2sgdGhlIGxhbmd1YWdlIGZyb20gdGhlIGFycmF5XG4gICAgICAgIC8vdHJ5IFsnZW4tYXUnLCAnZW4tZ2InXSBhcyAnZW4tYXUnLCAnZW4tZ2InLCAnZW4nLCBhcyBpbiBtb3ZlIHRocm91Z2ggdGhlIGxpc3QgdHJ5aW5nIGVhY2hcbiAgICAgICAgLy9zdWJzdHJpbmcgZnJvbSBtb3N0IHNwZWNpZmljIHRvIGxlYXN0LCBidXQgbW92ZSB0byB0aGUgbmV4dCBhcnJheSBpdGVtIGlmIGl0J3MgYSBtb3JlIHNwZWNpZmljIHZhcmlhbnQgdGhhbiB0aGUgY3VycmVudCByb290XG4gICAgICAgIHdoaWxlIChpIDwga2V5Lmxlbmd0aCkge1xuICAgICAgICAgICAgc3BsaXQgPSBub3JtYWxpemVMYW5ndWFnZShrZXlbaV0pLnNwbGl0KCctJyk7XG4gICAgICAgICAgICBqID0gc3BsaXQubGVuZ3RoO1xuICAgICAgICAgICAgbmV4dCA9IG5vcm1hbGl6ZUxhbmd1YWdlKGtleVtpICsgMV0pO1xuICAgICAgICAgICAgbmV4dCA9IG5leHQgPyBuZXh0LnNwbGl0KCctJykgOiBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgbGFuZyA9IGdldChzcGxpdC5zbGljZSgwLCBqKS5qb2luKCctJykpO1xuICAgICAgICAgICAgICAgIGlmIChsYW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsYW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0Lmxlbmd0aCA+PSBqICYmIGNvbXBhcmVBcnJheXMoc3BsaXQsIG5leHQsIHRydWUpID49IGogLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdGhlIG5leHQgYXJyYXkgaXRlbSBpcyBiZXR0ZXIgdGhhbiBhIHNoYWxsb3dlciBzdWJzdHJpbmcgb2YgdGhpcyBvbmVcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9tZW50LmZuLl9sYW5nO1xuICAgIH1cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgRm9ybWF0dGluZ1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQubWF0Y2goL1xcW1tcXHNcXFNdLykpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9eXFxbfFxcXSQvZywgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1xcXFwvZywgXCJcIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBmb3JtYXQubWF0Y2goZm9ybWF0dGluZ1Rva2VucyksIGksIGxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXSkge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoYXJyYXlbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtb20pIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBcIlwiO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGFycmF5W2ldIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhcnJheVtpXS5jYWxsKG1vbSwgZm9ybWF0KSA6IGFycmF5W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBmb3JtYXQgZGF0ZSB1c2luZyBuYXRpdmUgZGF0ZSBvYmplY3RcbiAgICBmdW5jdGlvbiBmb3JtYXRNb21lbnQobSwgZm9ybWF0KSB7XG5cbiAgICAgICAgaWYgKCFtLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG0ubGFuZygpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBleHBhbmRGb3JtYXQoZm9ybWF0LCBtLmxhbmcoKSk7XG5cbiAgICAgICAgaWYgKCFmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSkge1xuICAgICAgICAgICAgZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gPSBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XShtKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBhbmRGb3JtYXQoZm9ybWF0LCBsYW5nKSB7XG4gICAgICAgIHZhciBpID0gNTtcblxuICAgICAgICBmdW5jdGlvbiByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBsYW5nLmxvbmdEYXRlRm9ybWF0KGlucHV0KSB8fCBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy50ZXN0KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKGxvY2FsRm9ybWF0dGluZ1Rva2VucywgcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKTtcbiAgICAgICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG5cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgUGFyc2luZ1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgLy8gZ2V0IHRoZSByZWdleCB0byBmaW5kIHRoZSBuZXh0IHRva2VuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpIHtcbiAgICAgICAgdmFyIGEsIHN0cmljdCA9IGNvbmZpZy5fc3RyaWN0O1xuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIGNhc2UgJ0REREQnOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5UaHJlZURpZ2l0cztcbiAgICAgICAgY2FzZSAnWVlZWSc6XG4gICAgICAgIGNhc2UgJ0dHR0cnOlxuICAgICAgICBjYXNlICdnZ2dnJzpcbiAgICAgICAgICAgIHJldHVybiBzdHJpY3QgPyBwYXJzZVRva2VuRm91ckRpZ2l0cyA6IHBhcnNlVG9rZW5PbmVUb0ZvdXJEaWdpdHM7XG4gICAgICAgIGNhc2UgJ1lZWVlZWSc6XG4gICAgICAgIGNhc2UgJ1lZWVlZJzpcbiAgICAgICAgY2FzZSAnR0dHR0cnOlxuICAgICAgICBjYXNlICdnZ2dnZyc6XG4gICAgICAgICAgICByZXR1cm4gc3RyaWN0ID8gcGFyc2VUb2tlblNpeERpZ2l0cyA6IHBhcnNlVG9rZW5PbmVUb1NpeERpZ2l0cztcbiAgICAgICAgY2FzZSAnUyc6XG4gICAgICAgICAgICBpZiAoc3RyaWN0KSB7IHJldHVybiBwYXJzZVRva2VuT25lRGlnaXQ7IH1cbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnU1MnOlxuICAgICAgICAgICAgaWYgKHN0cmljdCkgeyByZXR1cm4gcGFyc2VUb2tlblR3b0RpZ2l0czsgfVxuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdTU1MnOlxuICAgICAgICBjYXNlICdEREQnOlxuICAgICAgICAgICAgcmV0dXJuIHN0cmljdCA/IHBhcnNlVG9rZW5UaHJlZURpZ2l0cyA6IHBhcnNlVG9rZW5PbmVUb1RocmVlRGlnaXRzO1xuICAgICAgICBjYXNlICdNTU0nOlxuICAgICAgICBjYXNlICdNTU1NJzpcbiAgICAgICAgY2FzZSAnZGQnOlxuICAgICAgICBjYXNlICdkZGQnOlxuICAgICAgICBjYXNlICdkZGRkJzpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuV29yZDtcbiAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgcmV0dXJuIGdldExhbmdEZWZpbml0aW9uKGNvbmZpZy5fbCkuX21lcmlkaWVtUGFyc2U7XG4gICAgICAgIGNhc2UgJ1gnOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5UaW1lc3RhbXBNcztcbiAgICAgICAgY2FzZSAnWic6XG4gICAgICAgIGNhc2UgJ1paJzpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuVGltZXpvbmU7XG4gICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5UO1xuICAgICAgICBjYXNlICdTU1NTJzpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuRGlnaXRzO1xuICAgICAgICBjYXNlICdNTSc6XG4gICAgICAgIGNhc2UgJ0REJzpcbiAgICAgICAgY2FzZSAnWVknOlxuICAgICAgICBjYXNlICdHRyc6XG4gICAgICAgIGNhc2UgJ2dnJzpcbiAgICAgICAgY2FzZSAnSEgnOlxuICAgICAgICBjYXNlICdoaCc6XG4gICAgICAgIGNhc2UgJ21tJzpcbiAgICAgICAgY2FzZSAnc3MnOlxuICAgICAgICBjYXNlICd3dyc6XG4gICAgICAgIGNhc2UgJ1dXJzpcbiAgICAgICAgICAgIHJldHVybiBzdHJpY3QgPyBwYXJzZVRva2VuVHdvRGlnaXRzIDogcGFyc2VUb2tlbk9uZU9yVHdvRGlnaXRzO1xuICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgY2FzZSAnRCc6XG4gICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgIGNhc2UgJ20nOlxuICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgY2FzZSAndyc6XG4gICAgICAgIGNhc2UgJ1cnOlxuICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgICByZXR1cm4gc3RyaWN0ID8gcGFyc2VUb2tlbk9uZURpZ2l0IDogcGFyc2VUb2tlbk9uZU9yVHdvRGlnaXRzO1xuICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgIGEgPSBuZXcgUmVnRXhwKHJlZ2V4cEVzY2FwZSh1bmVzY2FwZUZvcm1hdCh0b2tlbi5yZXBsYWNlKCdcXFxcJywgJycpKSwgXCJpXCIpKTtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGltZXpvbmVNaW51dGVzRnJvbVN0cmluZyhzdHJpbmcpIHtcbiAgICAgICAgc3RyaW5nID0gc3RyaW5nIHx8IFwiXCI7XG4gICAgICAgIHZhciBwb3NzaWJsZVR6TWF0Y2hlcyA9IChzdHJpbmcubWF0Y2gocGFyc2VUb2tlblRpbWV6b25lKSB8fCBbXSksXG4gICAgICAgICAgICB0ekNodW5rID0gcG9zc2libGVUek1hdGNoZXNbcG9zc2libGVUek1hdGNoZXMubGVuZ3RoIC0gMV0gfHwgW10sXG4gICAgICAgICAgICBwYXJ0cyA9ICh0ekNodW5rICsgJycpLm1hdGNoKHBhcnNlVGltZXpvbmVDaHVua2VyKSB8fCBbJy0nLCAwLCAwXSxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSArKHBhcnRzWzFdICogNjApICsgdG9JbnQocGFydHNbMl0pO1xuXG4gICAgICAgIHJldHVybiBwYXJ0c1swXSA9PT0gJysnID8gLW1pbnV0ZXMgOiBtaW51dGVzO1xuICAgIH1cblxuICAgIC8vIGZ1bmN0aW9uIHRvIGNvbnZlcnQgc3RyaW5nIGlucHV0IHRvIGRhdGVcbiAgICBmdW5jdGlvbiBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgaW5wdXQsIGNvbmZpZykge1xuICAgICAgICB2YXIgYSwgZGF0ZVBhcnRBcnJheSA9IGNvbmZpZy5fYTtcblxuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIC8vIE1PTlRIXG4gICAgICAgIGNhc2UgJ00nIDogLy8gZmFsbCB0aHJvdWdoIHRvIE1NXG4gICAgICAgIGNhc2UgJ01NJyA6XG4gICAgICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRhdGVQYXJ0QXJyYXlbTU9OVEhdID0gdG9JbnQoaW5wdXQpIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdNTU0nIDogLy8gZmFsbCB0aHJvdWdoIHRvIE1NTU1cbiAgICAgICAgY2FzZSAnTU1NTScgOlxuICAgICAgICAgICAgYSA9IGdldExhbmdEZWZpbml0aW9uKGNvbmZpZy5fbCkubW9udGhzUGFyc2UoaW5wdXQpO1xuICAgICAgICAgICAgLy8gaWYgd2UgZGlkbid0IGZpbmQgYSBtb250aCBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWQuXG4gICAgICAgICAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGF0ZVBhcnRBcnJheVtNT05USF0gPSBhO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX3BmLmludmFsaWRNb250aCA9IGlucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIERBWSBPRiBNT05USFxuICAgICAgICBjYXNlICdEJyA6IC8vIGZhbGwgdGhyb3VnaCB0byBERFxuICAgICAgICBjYXNlICdERCcgOlxuICAgICAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkYXRlUGFydEFycmF5W0RBVEVdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIERBWSBPRiBZRUFSXG4gICAgICAgIGNhc2UgJ0RERCcgOiAvLyBmYWxsIHRocm91Z2ggdG8gRERERFxuICAgICAgICBjYXNlICdEREREJyA6XG4gICAgICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gWUVBUlxuICAgICAgICBjYXNlICdZWScgOlxuICAgICAgICAgICAgZGF0ZVBhcnRBcnJheVtZRUFSXSA9IHRvSW50KGlucHV0KSArICh0b0ludChpbnB1dCkgPiA2OCA/IDE5MDAgOiAyMDAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdZWVlZJyA6XG4gICAgICAgIGNhc2UgJ1lZWVlZJyA6XG4gICAgICAgIGNhc2UgJ1lZWVlZWScgOlxuICAgICAgICAgICAgZGF0ZVBhcnRBcnJheVtZRUFSXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBBTSAvIFBNXG4gICAgICAgIGNhc2UgJ2EnIDogLy8gZmFsbCB0aHJvdWdoIHRvIEFcbiAgICAgICAgY2FzZSAnQScgOlxuICAgICAgICAgICAgY29uZmlnLl9pc1BtID0gZ2V0TGFuZ0RlZmluaXRpb24oY29uZmlnLl9sKS5pc1BNKGlucHV0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyAyNCBIT1VSXG4gICAgICAgIGNhc2UgJ0gnIDogLy8gZmFsbCB0aHJvdWdoIHRvIGhoXG4gICAgICAgIGNhc2UgJ0hIJyA6IC8vIGZhbGwgdGhyb3VnaCB0byBoaFxuICAgICAgICBjYXNlICdoJyA6IC8vIGZhbGwgdGhyb3VnaCB0byBoaFxuICAgICAgICBjYXNlICdoaCcgOlxuICAgICAgICAgICAgZGF0ZVBhcnRBcnJheVtIT1VSXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBNSU5VVEVcbiAgICAgICAgY2FzZSAnbScgOiAvLyBmYWxsIHRocm91Z2ggdG8gbW1cbiAgICAgICAgY2FzZSAnbW0nIDpcbiAgICAgICAgICAgIGRhdGVQYXJ0QXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBTRUNPTkRcbiAgICAgICAgY2FzZSAncycgOiAvLyBmYWxsIHRocm91Z2ggdG8gc3NcbiAgICAgICAgY2FzZSAnc3MnIDpcbiAgICAgICAgICAgIGRhdGVQYXJ0QXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBNSUxMSVNFQ09ORFxuICAgICAgICBjYXNlICdTJyA6XG4gICAgICAgIGNhc2UgJ1NTJyA6XG4gICAgICAgIGNhc2UgJ1NTUycgOlxuICAgICAgICBjYXNlICdTU1NTJyA6XG4gICAgICAgICAgICBkYXRlUGFydEFycmF5W01JTExJU0VDT05EXSA9IHRvSW50KCgnMC4nICsgaW5wdXQpICogMTAwMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gVU5JWCBUSU1FU1RBTVAgV0lUSCBNU1xuICAgICAgICBjYXNlICdYJzpcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHBhcnNlRmxvYXQoaW5wdXQpICogMTAwMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gVElNRVpPTkVcbiAgICAgICAgY2FzZSAnWicgOiAvLyBmYWxsIHRocm91Z2ggdG8gWlpcbiAgICAgICAgY2FzZSAnWlonIDpcbiAgICAgICAgICAgIGNvbmZpZy5fdXNlVVRDID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fdHptID0gdGltZXpvbmVNaW51dGVzRnJvbVN0cmluZyhpbnB1dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndyc6XG4gICAgICAgIGNhc2UgJ3d3JzpcbiAgICAgICAgY2FzZSAnVyc6XG4gICAgICAgIGNhc2UgJ1dXJzpcbiAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgIGNhc2UgJ2RkJzpcbiAgICAgICAgY2FzZSAnZGRkJzpcbiAgICAgICAgY2FzZSAnZGRkZCc6XG4gICAgICAgIGNhc2UgJ2UnOlxuICAgICAgICBjYXNlICdFJzpcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW4uc3Vic3RyKDAsIDEpO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdnZyc6XG4gICAgICAgIGNhc2UgJ2dnZ2cnOlxuICAgICAgICBjYXNlICdHRyc6XG4gICAgICAgIGNhc2UgJ0dHR0cnOlxuICAgICAgICBjYXNlICdHR0dHRyc6XG4gICAgICAgICAgICB0b2tlbiA9IHRva2VuLnN1YnN0cigwLCAyKTtcbiAgICAgICAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5fdyA9IGNvbmZpZy5fdyB8fCB7fTtcbiAgICAgICAgICAgICAgICBjb25maWcuX3dbdG9rZW5dID0gaW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgYW4gYXJyYXkgdG8gYSBkYXRlLlxuICAgIC8vIHRoZSBhcnJheSBzaG91bGQgbWlycm9yIHRoZSBwYXJhbWV0ZXJzIGJlbG93XG4gICAgLy8gbm90ZTogYWxsIHZhbHVlcyBwYXN0IHRoZSB5ZWFyIGFyZSBvcHRpb25hbCBhbmQgd2lsbCBkZWZhdWx0IHRvIHRoZSBsb3dlc3QgcG9zc2libGUgdmFsdWUuXG4gICAgLy8gW3llYXIsIG1vbnRoLCBkYXkgLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdXG4gICAgZnVuY3Rpb24gZGF0ZUZyb21Db25maWcoY29uZmlnKSB7XG4gICAgICAgIHZhciBpLCBkYXRlLCBpbnB1dCA9IFtdLCBjdXJyZW50RGF0ZSxcbiAgICAgICAgICAgIHllYXJUb1VzZSwgZml4WWVhciwgdywgdGVtcCwgbGFuZywgd2Vla2RheSwgd2VlaztcblxuICAgICAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50RGF0ZSA9IGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKTtcblxuICAgICAgICAvL2NvbXB1dGUgZGF5IG9mIHRoZSB5ZWFyIGZyb20gd2Vla3MgYW5kIHdlZWtkYXlzXG4gICAgICAgIGlmIChjb25maWcuX3cgJiYgY29uZmlnLl9hW0RBVEVdID09IG51bGwgJiYgY29uZmlnLl9hW01PTlRIXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBmaXhZZWFyID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgIHZhciBpbnRfdmFsID0gcGFyc2VJbnQodmFsLCAxMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbCA/XG4gICAgICAgICAgICAgICAgICAodmFsLmxlbmd0aCA8IDMgPyAoaW50X3ZhbCA+IDY4ID8gMTkwMCArIGludF92YWwgOiAyMDAwICsgaW50X3ZhbCkgOiBpbnRfdmFsKSA6XG4gICAgICAgICAgICAgICAgICAoY29uZmlnLl9hW1lFQVJdID09IG51bGwgPyBtb21lbnQoKS53ZWVrWWVhcigpIDogY29uZmlnLl9hW1lFQVJdKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHcgPSBjb25maWcuX3c7XG4gICAgICAgICAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGVtcCA9IGRheU9mWWVhckZyb21XZWVrcyhmaXhZZWFyKHcuR0cpLCB3LlcgfHwgMSwgdy5FLCA0LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxhbmcgPSBnZXRMYW5nRGVmaW5pdGlvbihjb25maWcuX2wpO1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmQgIT0gbnVsbCA/ICBwYXJzZVdlZWtkYXkody5kLCBsYW5nKSA6XG4gICAgICAgICAgICAgICAgICAody5lICE9IG51bGwgPyAgcGFyc2VJbnQody5lLCAxMCkgKyBsYW5nLl93ZWVrLmRvdyA6IDApO1xuXG4gICAgICAgICAgICAgICAgd2VlayA9IHBhcnNlSW50KHcudywgMTApIHx8IDE7XG5cbiAgICAgICAgICAgICAgICAvL2lmIHdlJ3JlIHBhcnNpbmcgJ2QnLCB0aGVuIHRoZSBsb3cgZGF5IG51bWJlcnMgbWF5IGJlIG5leHQgd2Vla1xuICAgICAgICAgICAgICAgIGlmICh3LmQgIT0gbnVsbCAmJiB3ZWVrZGF5IDwgbGFuZy5fd2Vlay5kb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgd2VlaysrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRlbXAgPSBkYXlPZlllYXJGcm9tV2Vla3MoZml4WWVhcih3LmdnKSwgd2Vlaywgd2Vla2RheSwgbGFuZy5fd2Vlay5kb3ksIGxhbmcuX3dlZWsuZG93KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uZmlnLl9hW1lFQVJdID0gdGVtcC55ZWFyO1xuICAgICAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0ZW1wLmRheU9mWWVhcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vaWYgdGhlIGRheSBvZiB0aGUgeWVhciBpcyBzZXQsIGZpZ3VyZSBvdXQgd2hhdCBpdCBpc1xuICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIpIHtcbiAgICAgICAgICAgIHllYXJUb1VzZSA9IGNvbmZpZy5fYVtZRUFSXSA9PSBudWxsID8gY3VycmVudERhdGVbWUVBUl0gOiBjb25maWcuX2FbWUVBUl07XG5cbiAgICAgICAgICAgIGlmIChjb25maWcuX2RheU9mWWVhciA+IGRheXNJblllYXIoeWVhclRvVXNlKSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5fcGYuX292ZXJmbG93RGF5T2ZZZWFyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0ZSA9IG1ha2VVVENEYXRlKHllYXJUb1VzZSwgMCwgY29uZmlnLl9kYXlPZlllYXIpO1xuICAgICAgICAgICAgY29uZmlnLl9hW01PTlRIXSA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtEQVRFXSA9IGRhdGUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IGRhdGUuXG4gICAgICAgIC8vICogaWYgbm8geWVhciwgbW9udGgsIGRheSBvZiBtb250aCBhcmUgZ2l2ZW4sIGRlZmF1bHQgdG8gdG9kYXlcbiAgICAgICAgLy8gKiBpZiBkYXkgb2YgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgbW9udGggYW5kIHllYXJcbiAgICAgICAgLy8gKiBpZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBvbmx5IHllYXJcbiAgICAgICAgLy8gKiBpZiB5ZWFyIGlzIGdpdmVuLCBkb24ndCBkZWZhdWx0IGFueXRoaW5nXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAzICYmIGNvbmZpZy5fYVtpXSA9PSBudWxsOyArK2kpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gY3VycmVudERhdGVbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBaZXJvIG91dCB3aGF0ZXZlciB3YXMgbm90IGRlZmF1bHRlZCwgaW5jbHVkaW5nIHRpbWVcbiAgICAgICAgZm9yICg7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gKGNvbmZpZy5fYVtpXSA9PSBudWxsKSA/IChpID09PSAyID8gMSA6IDApIDogY29uZmlnLl9hW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRoZSBvZmZzZXRzIHRvIHRoZSB0aW1lIHRvIGJlIHBhcnNlZCBzbyB0aGF0IHdlIGNhbiBoYXZlIGEgY2xlYW4gYXJyYXkgZm9yIGNoZWNraW5nIGlzVmFsaWRcbiAgICAgICAgaW5wdXRbSE9VUl0gKz0gdG9JbnQoKGNvbmZpZy5fdHptIHx8IDApIC8gNjApO1xuICAgICAgICBpbnB1dFtNSU5VVEVdICs9IHRvSW50KChjb25maWcuX3R6bSB8fCAwKSAlIDYwKTtcblxuICAgICAgICBjb25maWcuX2QgPSAoY29uZmlnLl91c2VVVEMgPyBtYWtlVVRDRGF0ZSA6IG1ha2VEYXRlKS5hcHBseShudWxsLCBpbnB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF0ZUZyb21PYmplY3QoY29uZmlnKSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQ7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9ybWFsaXplZElucHV0ID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoY29uZmlnLl9pKTtcbiAgICAgICAgY29uZmlnLl9hID0gW1xuICAgICAgICAgICAgbm9ybWFsaXplZElucHV0LnllYXIsXG4gICAgICAgICAgICBub3JtYWxpemVkSW5wdXQubW9udGgsXG4gICAgICAgICAgICBub3JtYWxpemVkSW5wdXQuZGF5LFxuICAgICAgICAgICAgbm9ybWFsaXplZElucHV0LmhvdXIsXG4gICAgICAgICAgICBub3JtYWxpemVkSW5wdXQubWludXRlLFxuICAgICAgICAgICAgbm9ybWFsaXplZElucHV0LnNlY29uZCxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dC5taWxsaXNlY29uZFxuICAgICAgICBdO1xuXG4gICAgICAgIGRhdGVGcm9tQ29uZmlnKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3VycmVudERhdGVBcnJheShjb25maWcpIHtcbiAgICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGlmIChjb25maWcuX3VzZVVUQykge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBub3cuZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgICAgICAgICBub3cuZ2V0VVRDTW9udGgoKSxcbiAgICAgICAgICAgICAgICBub3cuZ2V0VVRDRGF0ZSgpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtub3cuZ2V0RnVsbFllYXIoKSwgbm93LmdldE1vbnRoKCksIG5vdy5nZXREYXRlKCldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgZm9ybWF0IHN0cmluZ1xuICAgIGZ1bmN0aW9uIG1ha2VEYXRlRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpIHtcblxuICAgICAgICBjb25maWcuX2EgPSBbXTtcbiAgICAgICAgY29uZmlnLl9wZi5lbXB0eSA9IHRydWU7XG5cbiAgICAgICAgLy8gVGhpcyBhcnJheSBpcyB1c2VkIHRvIG1ha2UgYSBEYXRlLCBlaXRoZXIgd2l0aCBgbmV3IERhdGVgIG9yIGBEYXRlLlVUQ2BcbiAgICAgICAgdmFyIGxhbmcgPSBnZXRMYW5nRGVmaW5pdGlvbihjb25maWcuX2wpLFxuICAgICAgICAgICAgc3RyaW5nID0gJycgKyBjb25maWcuX2ksXG4gICAgICAgICAgICBpLCBwYXJzZWRJbnB1dCwgdG9rZW5zLCB0b2tlbiwgc2tpcHBlZCxcbiAgICAgICAgICAgIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoID0gMDtcblxuICAgICAgICB0b2tlbnMgPSBleHBhbmRGb3JtYXQoY29uZmlnLl9mLCBsYW5nKS5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSB8fCBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIHBhcnNlZElucHV0ID0gKHN0cmluZy5tYXRjaChnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpIHx8IFtdKVswXTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIHNraXBwZWQgPSBzdHJpbmcuc3Vic3RyKDAsIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSk7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBwZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX3BmLnVudXNlZElucHV0LnB1c2goc2tpcHBlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZShzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkgKyBwYXJzZWRJbnB1dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggKz0gcGFyc2VkSW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZG9uJ3QgcGFyc2UgaWYgaXQncyBub3QgYSBrbm93biB0b2tlblxuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX3BmLmVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX3BmLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIHBhcnNlZElucHV0LCBjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLl9zdHJpY3QgJiYgIXBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9wZi51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgcmVtYWluaW5nIHVucGFyc2VkIGlucHV0IGxlbmd0aCB0byB0aGUgc3RyaW5nXG4gICAgICAgIGNvbmZpZy5fcGYuY2hhcnNMZWZ0T3ZlciA9IHN0cmluZ0xlbmd0aCAtIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGg7XG4gICAgICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uZmlnLl9wZi51bnVzZWRJbnB1dC5wdXNoKHN0cmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgYW0gcG1cbiAgICAgICAgaWYgKGNvbmZpZy5faXNQbSAmJiBjb25maWcuX2FbSE9VUl0gPCAxMikge1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdICs9IDEyO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGlzIDEyIGFtLCBjaGFuZ2UgaG91cnMgdG8gMFxuICAgICAgICBpZiAoY29uZmlnLl9pc1BtID09PSBmYWxzZSAmJiBjb25maWcuX2FbSE9VUl0gPT09IDEyKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0ZUZyb21Db25maWcoY29uZmlnKTtcbiAgICAgICAgY2hlY2tPdmVyZmxvdyhjb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuZXNjYXBlRm9ybWF0KHMpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZSgvXFxcXChcXFspfFxcXFwoXFxdKXxcXFsoW15cXF1cXFtdKilcXF18XFxcXCguKS9nLCBmdW5jdGlvbiAobWF0Y2hlZCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgICAgIHJldHVybiBwMSB8fCBwMiB8fCBwMyB8fCBwNDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQ29kZSBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzU2MTQ5My9pcy10aGVyZS1hLXJlZ2V4cC1lc2NhcGUtZnVuY3Rpb24taW4tamF2YXNjcmlwdFxuICAgIGZ1bmN0aW9uIHJlZ2V4cEVzY2FwZShzKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGFycmF5IG9mIGZvcm1hdCBzdHJpbmdzXG4gICAgZnVuY3Rpb24gbWFrZURhdGVGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIHZhciB0ZW1wQ29uZmlnLFxuICAgICAgICAgICAgYmVzdE1vbWVudCxcblxuICAgICAgICAgICAgc2NvcmVUb0JlYXQsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgY3VycmVudFNjb3JlO1xuXG4gICAgICAgIGlmIChjb25maWcuX2YubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb25maWcuX3BmLmludmFsaWRGb3JtYXQgPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb25maWcuX2YubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSA9IDA7XG4gICAgICAgICAgICB0ZW1wQ29uZmlnID0gZXh0ZW5kKHt9LCBjb25maWcpO1xuICAgICAgICAgICAgaW5pdGlhbGl6ZVBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKTtcbiAgICAgICAgICAgIHRlbXBDb25maWcuX2YgPSBjb25maWcuX2ZbaV07XG4gICAgICAgICAgICBtYWtlRGF0ZUZyb21TdHJpbmdBbmRGb3JtYXQodGVtcENvbmZpZyk7XG5cbiAgICAgICAgICAgIGlmICghaXNWYWxpZCh0ZW1wQ29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbnkgaW5wdXQgdGhhdCB3YXMgbm90IHBhcnNlZCBhZGQgYSBwZW5hbHR5IGZvciB0aGF0IGZvcm1hdFxuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IHRlbXBDb25maWcuX3BmLmNoYXJzTGVmdE92ZXI7XG5cbiAgICAgICAgICAgIC8vb3IgdG9rZW5zXG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gdGVtcENvbmZpZy5fcGYudW51c2VkVG9rZW5zLmxlbmd0aCAqIDEwO1xuXG4gICAgICAgICAgICB0ZW1wQ29uZmlnLl9wZi5zY29yZSA9IGN1cnJlbnRTY29yZTtcblxuICAgICAgICAgICAgaWYgKHNjb3JlVG9CZWF0ID09IG51bGwgfHwgY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQpIHtcbiAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9IGN1cnJlbnRTY29yZTtcbiAgICAgICAgICAgICAgICBiZXN0TW9tZW50ID0gdGVtcENvbmZpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dGVuZChjb25maWcsIGJlc3RNb21lbnQgfHwgdGVtcENvbmZpZyk7XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXRcbiAgICBmdW5jdGlvbiBtYWtlRGF0ZUZyb21TdHJpbmcoY29uZmlnKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgc3RyaW5nID0gY29uZmlnLl9pLFxuICAgICAgICAgICAgbWF0Y2ggPSBpc29SZWdleC5leGVjKHN0cmluZyk7XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25maWcuX3BmLmlzbyA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGkgPSA0OyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1hdGNoWzVdIHNob3VsZCBiZSBcIlRcIiBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9mID0gaXNvRGF0ZXNbaSAtIDFdICsgKG1hdGNoWzZdIHx8IFwiIFwiKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpc29UaW1lc1tpXVsxXS5leGVjKHN0cmluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9mICs9IGlzb1RpbWVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyaW5nLm1hdGNoKHBhcnNlVG9rZW5UaW1lem9uZSkpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2YgKz0gXCJaXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYWtlRGF0ZUZyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHN0cmluZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlRGF0ZUZyb21JbnB1dChjb25maWcpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pLFxuICAgICAgICAgICAgbWF0Y2hlZCA9IGFzcE5ldEpzb25SZWdleC5leGVjKGlucHV0KTtcblxuICAgICAgICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgrbWF0Y2hlZFsxXSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbWFrZURhdGVGcm9tU3RyaW5nKGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYSA9IGlucHV0LnNsaWNlKDApO1xuICAgICAgICAgICAgZGF0ZUZyb21Db25maWcoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgraW5wdXQpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZihpbnB1dCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBkYXRlRnJvbU9iamVjdChjb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZURhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpIHtcbiAgICAgICAgLy9jYW4ndCBqdXN0IGFwcGx5KCkgdG8gY3JlYXRlIGEgZGF0ZTpcbiAgICAgICAgLy9odHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE4MTM0OC9pbnN0YW50aWF0aW5nLWEtamF2YXNjcmlwdC1vYmplY3QtYnktY2FsbGluZy1wcm90b3R5cGUtY29uc3RydWN0b3ItYXBwbHlcbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh5LCBtLCBkLCBoLCBNLCBzLCBtcyk7XG5cbiAgICAgICAgLy90aGUgZGF0ZSBjb25zdHJ1Y3RvciBkb2Vzbid0IGFjY2VwdCB5ZWFycyA8IDE5NzBcbiAgICAgICAgaWYgKHkgPCAxOTcwKSB7XG4gICAgICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VVVENEYXRlKHkpIHtcbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICAgICAgaWYgKHkgPCAxOTcwKSB7XG4gICAgICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlV2Vla2RheShpbnB1dCwgbGFuZ3VhZ2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICghaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBwYXJzZUludChpbnB1dCwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBsYW5ndWFnZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgUmVsYXRpdmUgVGltZVxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uIGZvciBtb21lbnQuZm4uZnJvbSwgbW9tZW50LmZuLmZyb21Ob3csIGFuZCBtb21lbnQuZHVyYXRpb24uZm4uaHVtYW5pemVcbiAgICBmdW5jdGlvbiBzdWJzdGl0dXRlVGltZUFnbyhzdHJpbmcsIG51bWJlciwgd2l0aG91dFN1ZmZpeCwgaXNGdXR1cmUsIGxhbmcpIHtcbiAgICAgICAgcmV0dXJuIGxhbmcucmVsYXRpdmVUaW1lKG51bWJlciB8fCAxLCAhIXdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlVGltZShtaWxsaXNlY29uZHMsIHdpdGhvdXRTdWZmaXgsIGxhbmcpIHtcbiAgICAgICAgdmFyIHNlY29uZHMgPSByb3VuZChNYXRoLmFicyhtaWxsaXNlY29uZHMpIC8gMTAwMCksXG4gICAgICAgICAgICBtaW51dGVzID0gcm91bmQoc2Vjb25kcyAvIDYwKSxcbiAgICAgICAgICAgIGhvdXJzID0gcm91bmQobWludXRlcyAvIDYwKSxcbiAgICAgICAgICAgIGRheXMgPSByb3VuZChob3VycyAvIDI0KSxcbiAgICAgICAgICAgIHllYXJzID0gcm91bmQoZGF5cyAvIDM2NSksXG4gICAgICAgICAgICBhcmdzID0gc2Vjb25kcyA8IDQ1ICYmIFsncycsIHNlY29uZHNdIHx8XG4gICAgICAgICAgICAgICAgbWludXRlcyA9PT0gMSAmJiBbJ20nXSB8fFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPCA0NSAmJiBbJ21tJywgbWludXRlc10gfHxcbiAgICAgICAgICAgICAgICBob3VycyA9PT0gMSAmJiBbJ2gnXSB8fFxuICAgICAgICAgICAgICAgIGhvdXJzIDwgMjIgJiYgWydoaCcsIGhvdXJzXSB8fFxuICAgICAgICAgICAgICAgIGRheXMgPT09IDEgJiYgWydkJ10gfHxcbiAgICAgICAgICAgICAgICBkYXlzIDw9IDI1ICYmIFsnZGQnLCBkYXlzXSB8fFxuICAgICAgICAgICAgICAgIGRheXMgPD0gNDUgJiYgWydNJ10gfHxcbiAgICAgICAgICAgICAgICBkYXlzIDwgMzQ1ICYmIFsnTU0nLCByb3VuZChkYXlzIC8gMzApXSB8fFxuICAgICAgICAgICAgICAgIHllYXJzID09PSAxICYmIFsneSddIHx8IFsneXknLCB5ZWFyc107XG4gICAgICAgIGFyZ3NbMl0gPSB3aXRob3V0U3VmZml4O1xuICAgICAgICBhcmdzWzNdID0gbWlsbGlzZWNvbmRzID4gMDtcbiAgICAgICAgYXJnc1s0XSA9IGxhbmc7XG4gICAgICAgIHJldHVybiBzdWJzdGl0dXRlVGltZUFnby5hcHBseSh7fSwgYXJncyk7XG4gICAgfVxuXG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIFdlZWsgb2YgWWVhclxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgLy8gZmlyc3REYXlPZldlZWsgICAgICAgMCA9IHN1biwgNiA9IHNhdFxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgIHRoZSBkYXkgb2YgdGhlIHdlZWsgdGhhdCBzdGFydHMgdGhlIHdlZWtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAodXN1YWxseSBzdW5kYXkgb3IgbW9uZGF5KVxuICAgIC8vIGZpcnN0RGF5T2ZXZWVrT2ZZZWFyIDAgPSBzdW4sIDYgPSBzYXRcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICB0aGUgZmlyc3Qgd2VlayBpcyB0aGUgd2VlayB0aGF0IGNvbnRhaW5zIHRoZSBmaXJzdFxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgIG9mIHRoaXMgZGF5IG9mIHRoZSB3ZWVrXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgKGVnLiBJU08gd2Vla3MgdXNlIHRodXJzZGF5ICg0KSlcbiAgICBmdW5jdGlvbiB3ZWVrT2ZZZWFyKG1vbSwgZmlyc3REYXlPZldlZWssIGZpcnN0RGF5T2ZXZWVrT2ZZZWFyKSB7XG4gICAgICAgIHZhciBlbmQgPSBmaXJzdERheU9mV2Vla09mWWVhciAtIGZpcnN0RGF5T2ZXZWVrLFxuICAgICAgICAgICAgZGF5c1RvRGF5T2ZXZWVrID0gZmlyc3REYXlPZldlZWtPZlllYXIgLSBtb20uZGF5KCksXG4gICAgICAgICAgICBhZGp1c3RlZE1vbWVudDtcblxuXG4gICAgICAgIGlmIChkYXlzVG9EYXlPZldlZWsgPiBlbmQpIHtcbiAgICAgICAgICAgIGRheXNUb0RheU9mV2VlayAtPSA3O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRheXNUb0RheU9mV2VlayA8IGVuZCAtIDcpIHtcbiAgICAgICAgICAgIGRheXNUb0RheU9mV2VlayArPSA3O1xuICAgICAgICB9XG5cbiAgICAgICAgYWRqdXN0ZWRNb21lbnQgPSBtb21lbnQobW9tKS5hZGQoJ2QnLCBkYXlzVG9EYXlPZldlZWspO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2VlazogTWF0aC5jZWlsKGFkanVzdGVkTW9tZW50LmRheU9mWWVhcigpIC8gNyksXG4gICAgICAgICAgICB5ZWFyOiBhZGp1c3RlZE1vbWVudC55ZWFyKClcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvL2h0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZSNDYWxjdWxhdGluZ19hX2RhdGVfZ2l2ZW5fdGhlX3llYXIuMkNfd2Vla19udW1iZXJfYW5kX3dlZWtkYXlcbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla3MoeWVhciwgd2Vlaywgd2Vla2RheSwgZmlyc3REYXlPZldlZWtPZlllYXIsIGZpcnN0RGF5T2ZXZWVrKSB7XG4gICAgICAgIC8vIFRoZSBvbmx5IHNvbGlkIHdheSB0byBjcmVhdGUgYW4gaXNvIGRhdGUgZnJvbSB5ZWFyIGlzIHRvIHVzZVxuICAgICAgICAvLyBhIHN0cmluZyBmb3JtYXQgKERhdGUuVVRDIGhhbmRsZXMgb25seSB5ZWFycyA+IDE5MDApLiBEb24ndCBhc2sgd2h5XG4gICAgICAgIC8vIGl0IGRvZXNuJ3QgbmVlZCBaIGF0IHRoZSBlbmQuXG4gICAgICAgIHZhciBkID0gbmV3IERhdGUobGVmdFplcm9GaWxsKHllYXIsIDYsIHRydWUpICsgJy0wMS0wMScpLmdldFVUQ0RheSgpLFxuICAgICAgICAgICAgZGF5c1RvQWRkLCBkYXlPZlllYXI7XG5cbiAgICAgICAgd2Vla2RheSA9IHdlZWtkYXkgIT0gbnVsbCA/IHdlZWtkYXkgOiBmaXJzdERheU9mV2VlaztcbiAgICAgICAgZGF5c1RvQWRkID0gZmlyc3REYXlPZldlZWsgLSBkICsgKGQgPiBmaXJzdERheU9mV2Vla09mWWVhciA/IDcgOiAwKTtcbiAgICAgICAgZGF5T2ZZZWFyID0gNyAqICh3ZWVrIC0gMSkgKyAod2Vla2RheSAtIGZpcnN0RGF5T2ZXZWVrKSArIGRheXNUb0FkZCArIDE7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXI6IGRheU9mWWVhciA+IDAgPyB5ZWFyIDogeWVhciAtIDEsXG4gICAgICAgICAgICBkYXlPZlllYXI6IGRheU9mWWVhciA+IDAgPyAgZGF5T2ZZZWFyIDogZGF5c0luWWVhcih5ZWFyIC0gMSkgKyBkYXlPZlllYXJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIFRvcCBMZXZlbCBGdW5jdGlvbnNcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBmdW5jdGlvbiBtYWtlTW9tZW50KGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBmb3JtYXQgPSBjb25maWcuX2Y7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcuX3BmID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaW5pdGlhbGl6ZVBhcnNpbmdGbGFncyhjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9tZW50LmludmFsaWQoe251bGxJbnB1dDogdHJ1ZX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faSA9IGlucHV0ID0gZ2V0TGFuZ0RlZmluaXRpb24oKS5wcmVwYXJzZShpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9tZW50LmlzTW9tZW50KGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnID0gZXh0ZW5kKHt9LCBpbnB1dCk7XG5cbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCtpbnB1dC5fZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0KSB7XG4gICAgICAgICAgICBpZiAoaXNBcnJheShmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgbWFrZURhdGVGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFrZURhdGVGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYWtlRGF0ZUZyb21JbnB1dChjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQoY29uZmlnKTtcbiAgICB9XG5cbiAgICBtb21lbnQgPSBmdW5jdGlvbiAoaW5wdXQsIGZvcm1hdCwgbGFuZywgc3RyaWN0KSB7XG4gICAgICAgIGlmICh0eXBlb2YobGFuZykgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBzdHJpY3QgPSBsYW5nO1xuICAgICAgICAgICAgbGFuZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFrZU1vbWVudCh7XG4gICAgICAgICAgICBfaSA6IGlucHV0LFxuICAgICAgICAgICAgX2YgOiBmb3JtYXQsXG4gICAgICAgICAgICBfbCA6IGxhbmcsXG4gICAgICAgICAgICBfc3RyaWN0IDogc3RyaWN0LFxuICAgICAgICAgICAgX2lzVVRDIDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIGNyZWF0aW5nIHdpdGggdXRjXG4gICAgbW9tZW50LnV0YyA9IGZ1bmN0aW9uIChpbnB1dCwgZm9ybWF0LCBsYW5nLCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIG07XG5cbiAgICAgICAgaWYgKHR5cGVvZihsYW5nKSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHN0cmljdCA9IGxhbmc7XG4gICAgICAgICAgICBsYW5nID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIG0gPSBtYWtlTW9tZW50KHtcbiAgICAgICAgICAgIF91c2VVVEMgOiB0cnVlLFxuICAgICAgICAgICAgX2lzVVRDIDogdHJ1ZSxcbiAgICAgICAgICAgIF9sIDogbGFuZyxcbiAgICAgICAgICAgIF9pIDogaW5wdXQsXG4gICAgICAgICAgICBfZiA6IGZvcm1hdCxcbiAgICAgICAgICAgIF9zdHJpY3QgOiBzdHJpY3RcbiAgICAgICAgfSkudXRjKCk7XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfTtcblxuICAgIC8vIGNyZWF0aW5nIHdpdGggdW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpXG4gICAgbW9tZW50LnVuaXggPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG1vbWVudChpbnB1dCAqIDEwMDApO1xuICAgIH07XG5cbiAgICAvLyBkdXJhdGlvblxuICAgIG1vbWVudC5kdXJhdGlvbiA9IGZ1bmN0aW9uIChpbnB1dCwga2V5KSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGlucHV0LFxuICAgICAgICAgICAgLy8gbWF0Y2hpbmcgYWdhaW5zdCByZWdleHAgaXMgZXhwZW5zaXZlLCBkbyBpdCBvbiBkZW1hbmRcbiAgICAgICAgICAgIG1hdGNoID0gbnVsbCxcbiAgICAgICAgICAgIHNpZ24sXG4gICAgICAgICAgICByZXQsXG4gICAgICAgICAgICBwYXJzZUlzbztcblxuICAgICAgICBpZiAobW9tZW50LmlzRHVyYXRpb24oaW5wdXQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBtczogaW5wdXQuX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgICAgICBkOiBpbnB1dC5fZGF5cyxcbiAgICAgICAgICAgICAgICBNOiBpbnB1dC5fbW9udGhzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb25ba2V5XSA9IGlucHV0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbi5taWxsaXNlY29uZHMgPSBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGFzcE5ldFRpbWVTcGFuSnNvblJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gXCItXCIpID8gLTEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICBkOiB0b0ludChtYXRjaFtEQVRFXSkgKiBzaWduLFxuICAgICAgICAgICAgICAgIGg6IHRvSW50KG1hdGNoW0hPVVJdKSAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbTogdG9JbnQobWF0Y2hbTUlOVVRFXSkgKiBzaWduLFxuICAgICAgICAgICAgICAgIHM6IHRvSW50KG1hdGNoW1NFQ09ORF0pICogc2lnbixcbiAgICAgICAgICAgICAgICBtczogdG9JbnQobWF0Y2hbTUlMTElTRUNPTkRdKSAqIHNpZ25cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBpc29EdXJhdGlvblJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gXCItXCIpID8gLTEgOiAxO1xuICAgICAgICAgICAgcGFyc2VJc28gPSBmdW5jdGlvbiAoaW5wKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UnZCBub3JtYWxseSB1c2Ugfn5pbnAgZm9yIHRoaXMsIGJ1dCB1bmZvcnR1bmF0ZWx5IGl0IGFsc29cbiAgICAgICAgICAgICAgICAvLyBjb252ZXJ0cyBmbG9hdHMgdG8gaW50cy5cbiAgICAgICAgICAgICAgICAvLyBpbnAgbWF5IGJlIHVuZGVmaW5lZCwgc28gY2FyZWZ1bCBjYWxsaW5nIHJlcGxhY2Ugb24gaXQuXG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IGlucCAmJiBwYXJzZUZsb2F0KGlucC5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgICAgICAgICAgICAgLy8gYXBwbHkgc2lnbiB3aGlsZSB3ZSdyZSBhdCBpdFxuICAgICAgICAgICAgICAgIHJldHVybiAoaXNOYU4ocmVzKSA/IDAgOiByZXMpICogc2lnbjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB5OiBwYXJzZUlzbyhtYXRjaFsyXSksXG4gICAgICAgICAgICAgICAgTTogcGFyc2VJc28obWF0Y2hbM10pLFxuICAgICAgICAgICAgICAgIGQ6IHBhcnNlSXNvKG1hdGNoWzRdKSxcbiAgICAgICAgICAgICAgICBoOiBwYXJzZUlzbyhtYXRjaFs1XSksXG4gICAgICAgICAgICAgICAgbTogcGFyc2VJc28obWF0Y2hbNl0pLFxuICAgICAgICAgICAgICAgIHM6IHBhcnNlSXNvKG1hdGNoWzddKSxcbiAgICAgICAgICAgICAgICB3OiBwYXJzZUlzbyhtYXRjaFs4XSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXQgPSBuZXcgRHVyYXRpb24oZHVyYXRpb24pO1xuXG4gICAgICAgIGlmIChtb21lbnQuaXNEdXJhdGlvbihpbnB1dCkgJiYgaW5wdXQuaGFzT3duUHJvcGVydHkoJ19sYW5nJykpIHtcbiAgICAgICAgICAgIHJldC5fbGFuZyA9IGlucHV0Ll9sYW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgLy8gdmVyc2lvbiBudW1iZXJcbiAgICBtb21lbnQudmVyc2lvbiA9IFZFUlNJT047XG5cbiAgICAvLyBkZWZhdWx0IGZvcm1hdFxuICAgIG1vbWVudC5kZWZhdWx0Rm9ybWF0ID0gaXNvRm9ybWF0O1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciBhIG1vbWVudCBpcyBtdXRhdGVkLlxuICAgIC8vIEl0IGlzIGludGVuZGVkIHRvIGtlZXAgdGhlIG9mZnNldCBpbiBzeW5jIHdpdGggdGhlIHRpbWV6b25lLlxuICAgIG1vbWVudC51cGRhdGVPZmZzZXQgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBsb2FkIGxhbmd1YWdlcyBhbmQgdGhlbiBzZXQgdGhlIGdsb2JhbCBsYW5ndWFnZS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbiAgICAvLyBsYW5ndWFnZSBrZXkuXG4gICAgbW9tZW50LmxhbmcgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgdmFyIHI7XG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gbW9tZW50LmZuLl9sYW5nLl9hYmJyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICAgIGxvYWRMYW5nKG5vcm1hbGl6ZUxhbmd1YWdlKGtleSksIHZhbHVlcyk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWVzID09PSBudWxsKSB7XG4gICAgICAgICAgICB1bmxvYWRMYW5nKGtleSk7XG4gICAgICAgICAgICBrZXkgPSAnZW4nO1xuICAgICAgICB9IGVsc2UgaWYgKCFsYW5ndWFnZXNba2V5XSkge1xuICAgICAgICAgICAgZ2V0TGFuZ0RlZmluaXRpb24oa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByID0gbW9tZW50LmR1cmF0aW9uLmZuLl9sYW5nID0gbW9tZW50LmZuLl9sYW5nID0gZ2V0TGFuZ0RlZmluaXRpb24oa2V5KTtcbiAgICAgICAgcmV0dXJuIHIuX2FiYnI7XG4gICAgfTtcblxuICAgIC8vIHJldHVybnMgbGFuZ3VhZ2UgZGF0YVxuICAgIG1vbWVudC5sYW5nRGF0YSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGtleSAmJiBrZXkuX2xhbmcgJiYga2V5Ll9sYW5nLl9hYmJyKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkuX2xhbmcuX2FiYnI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldExhbmdEZWZpbml0aW9uKGtleSk7XG4gICAgfTtcblxuICAgIC8vIGNvbXBhcmUgbW9tZW50IG9iamVjdFxuICAgIG1vbWVudC5pc01vbWVudCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE1vbWVudDtcbiAgICB9O1xuXG4gICAgLy8gZm9yIHR5cGVjaGVja2luZyBEdXJhdGlvbiBvYmplY3RzXG4gICAgbW9tZW50LmlzRHVyYXRpb24gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBEdXJhdGlvbjtcbiAgICB9O1xuXG4gICAgZm9yIChpID0gbGlzdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgbWFrZUxpc3QobGlzdHNbaV0pO1xuICAgIH1cblxuICAgIG1vbWVudC5ub3JtYWxpemVVbml0cyA9IGZ1bmN0aW9uICh1bml0cykge1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgIH07XG5cbiAgICBtb21lbnQuaW52YWxpZCA9IGZ1bmN0aW9uIChmbGFncykge1xuICAgICAgICB2YXIgbSA9IG1vbWVudC51dGMoTmFOKTtcbiAgICAgICAgaWYgKGZsYWdzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGV4dGVuZChtLl9wZiwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbS5fcGYudXNlckludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH07XG5cbiAgICBtb21lbnQucGFyc2Vab25lID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBtb21lbnQoaW5wdXQpLnBhcnNlWm9uZSgpO1xuICAgIH07XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIE1vbWVudCBQcm90b3R5cGVcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgIGV4dGVuZChtb21lbnQuZm4gPSBNb21lbnQucHJvdG90eXBlLCB7XG5cbiAgICAgICAgY2xvbmUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9tZW50KHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHZhbHVlT2YgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gK3RoaXMuX2QgKyAoKHRoaXMuX29mZnNldCB8fCAwKSAqIDYwMDAwKTtcbiAgICAgICAgfSxcblxuICAgICAgICB1bml4IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoK3RoaXMgLyAxMDAwKTtcbiAgICAgICAgfSxcblxuICAgICAgICB0b1N0cmluZyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkubGFuZygnZW4nKS5mb3JtYXQoXCJkZGQgTU1NIEREIFlZWVkgSEg6bW06c3MgW0dNVF1aWlwiKTtcbiAgICAgICAgfSxcblxuICAgICAgICB0b0RhdGUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0ID8gbmV3IERhdGUoK3RoaXMpIDogdGhpcy5fZDtcbiAgICAgICAgfSxcblxuICAgICAgICB0b0lTT1N0cmluZyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtID0gbW9tZW50KHRoaXMpLnV0YygpO1xuICAgICAgICAgICAgaWYgKDAgPCBtLnllYXIoKSAmJiBtLnllYXIoKSA8PSA5OTk5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB0b0FycmF5IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBtLnllYXIoKSxcbiAgICAgICAgICAgICAgICBtLm1vbnRoKCksXG4gICAgICAgICAgICAgICAgbS5kYXRlKCksXG4gICAgICAgICAgICAgICAgbS5ob3VycygpLFxuICAgICAgICAgICAgICAgIG0ubWludXRlcygpLFxuICAgICAgICAgICAgICAgIG0uc2Vjb25kcygpLFxuICAgICAgICAgICAgICAgIG0ubWlsbGlzZWNvbmRzKClcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNWYWxpZCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1ZhbGlkKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzRFNUU2hpZnRlZCA6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgJiYgY29tcGFyZUFycmF5cyh0aGlzLl9hLCAodGhpcy5faXNVVEMgPyBtb21lbnQudXRjKHRoaXMuX2EpIDogbW9tZW50KHRoaXMuX2EpKS50b0FycmF5KCkpID4gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNpbmdGbGFncyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBleHRlbmQoe30sIHRoaXMuX3BmKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbnZhbGlkQXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wZi5vdmVyZmxvdztcbiAgICAgICAgfSxcblxuICAgICAgICB1dGMgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy56b25lKDApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGxvY2FsIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy56b25lKDApO1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZvcm1hdCA6IGZ1bmN0aW9uIChpbnB1dFN0cmluZykge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IGZvcm1hdE1vbWVudCh0aGlzLCBpbnB1dFN0cmluZyB8fCBtb21lbnQuZGVmYXVsdEZvcm1hdCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYW5nKCkucG9zdGZvcm1hdChvdXRwdXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZCA6IGZ1bmN0aW9uIChpbnB1dCwgdmFsKSB7XG4gICAgICAgICAgICB2YXIgZHVyO1xuICAgICAgICAgICAgLy8gc3dpdGNoIGFyZ3MgdG8gc3VwcG9ydCBhZGQoJ3MnLCAxKSBhbmQgYWRkKDEsICdzJylcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZHVyID0gbW9tZW50LmR1cmF0aW9uKCt2YWwsIGlucHV0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHVyID0gbW9tZW50LmR1cmF0aW9uKGlucHV0LCB2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkT3JTdWJ0cmFjdER1cmF0aW9uRnJvbU1vbWVudCh0aGlzLCBkdXIsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3VidHJhY3QgOiBmdW5jdGlvbiAoaW5wdXQsIHZhbCkge1xuICAgICAgICAgICAgdmFyIGR1cjtcbiAgICAgICAgICAgIC8vIHN3aXRjaCBhcmdzIHRvIHN1cHBvcnQgc3VidHJhY3QoJ3MnLCAxKSBhbmQgc3VidHJhY3QoMSwgJ3MnKVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBkdXIgPSBtb21lbnQuZHVyYXRpb24oK3ZhbCwgaW5wdXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkdXIgPSBtb21lbnQuZHVyYXRpb24oaW5wdXQsIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRPclN1YnRyYWN0RHVyYXRpb25Gcm9tTW9tZW50KHRoaXMsIGR1ciwgLTEpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlmZiA6IGZ1bmN0aW9uIChpbnB1dCwgdW5pdHMsIGFzRmxvYXQpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gbWFrZUFzKGlucHV0LCB0aGlzKSxcbiAgICAgICAgICAgICAgICB6b25lRGlmZiA9ICh0aGlzLnpvbmUoKSAtIHRoYXQuem9uZSgpKSAqIDZlNCxcbiAgICAgICAgICAgICAgICBkaWZmLCBvdXRwdXQ7XG5cbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgICAgICAgICBpZiAodW5pdHMgPT09ICd5ZWFyJyB8fCB1bml0cyA9PT0gJ21vbnRoJykge1xuICAgICAgICAgICAgICAgIC8vIGF2ZXJhZ2UgbnVtYmVyIG9mIGRheXMgaW4gdGhlIG1vbnRocyBpbiB0aGUgZ2l2ZW4gZGF0ZXNcbiAgICAgICAgICAgICAgICBkaWZmID0gKHRoaXMuZGF5c0luTW9udGgoKSArIHRoYXQuZGF5c0luTW9udGgoKSkgKiA0MzJlNTsgLy8gMjQgKiA2MCAqIDYwICogMTAwMCAvIDJcbiAgICAgICAgICAgICAgICAvLyBkaWZmZXJlbmNlIGluIG1vbnRoc1xuICAgICAgICAgICAgICAgIG91dHB1dCA9ICgodGhpcy55ZWFyKCkgLSB0aGF0LnllYXIoKSkgKiAxMikgKyAodGhpcy5tb250aCgpIC0gdGhhdC5tb250aCgpKTtcbiAgICAgICAgICAgICAgICAvLyBhZGp1c3QgYnkgdGFraW5nIGRpZmZlcmVuY2UgaW4gZGF5cywgYXZlcmFnZSBudW1iZXIgb2YgZGF5c1xuICAgICAgICAgICAgICAgIC8vIGFuZCBkc3QgaW4gdGhlIGdpdmVuIG1vbnRocy5cbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gKCh0aGlzIC0gbW9tZW50KHRoaXMpLnN0YXJ0T2YoJ21vbnRoJykpIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGF0IC0gbW9tZW50KHRoYXQpLnN0YXJ0T2YoJ21vbnRoJykpKSAvIGRpZmY7XG4gICAgICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2l0aCB6b25lcywgdG8gbmVnYXRlIGFsbCBkc3RcbiAgICAgICAgICAgICAgICBvdXRwdXQgLT0gKCh0aGlzLnpvbmUoKSAtIG1vbWVudCh0aGlzKS5zdGFydE9mKCdtb250aCcpLnpvbmUoKSkgLVxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoYXQuem9uZSgpIC0gbW9tZW50KHRoYXQpLnN0YXJ0T2YoJ21vbnRoJykuem9uZSgpKSkgKiA2ZTQgLyBkaWZmO1xuICAgICAgICAgICAgICAgIGlmICh1bml0cyA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCAvIDEyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlmZiA9ICh0aGlzIC0gdGhhdCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gdW5pdHMgPT09ICdzZWNvbmQnID8gZGlmZiAvIDFlMyA6IC8vIDEwMDBcbiAgICAgICAgICAgICAgICAgICAgdW5pdHMgPT09ICdtaW51dGUnID8gZGlmZiAvIDZlNCA6IC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ2hvdXInID8gZGlmZiAvIDM2ZTUgOiAvLyAxMDAwICogNjAgKiA2MFxuICAgICAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ2RheScgPyAoZGlmZiAtIHpvbmVEaWZmKSAvIDg2NGU1IDogLy8gMTAwMCAqIDYwICogNjAgKiAyNCwgbmVnYXRlIGRzdFxuICAgICAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ3dlZWsnID8gKGRpZmYgLSB6b25lRGlmZikgLyA2MDQ4ZTUgOiAvLyAxMDAwICogNjAgKiA2MCAqIDI0ICogNywgbmVnYXRlIGRzdFxuICAgICAgICAgICAgICAgICAgICBkaWZmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFzRmxvYXQgPyBvdXRwdXQgOiBhYnNSb3VuZChvdXRwdXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZyb20gOiBmdW5jdGlvbiAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICAgICAgcmV0dXJuIG1vbWVudC5kdXJhdGlvbih0aGlzLmRpZmYodGltZSkpLmxhbmcodGhpcy5sYW5nKCkuX2FiYnIpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICAgICAgfSxcblxuICAgICAgICBmcm9tTm93IDogZnVuY3Rpb24gKHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb20obW9tZW50KCksIHdpdGhvdXRTdWZmaXgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNhbGVuZGFyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAgICAgICAgIC8vIEdldHRpbmcgc3RhcnQtb2YtdG9kYXkgZGVwZW5kcyBvbiB3aGV0aGVyIHdlJ3JlIHpvbmUnZCBvciBub3QuXG4gICAgICAgICAgICB2YXIgc29kID0gbWFrZUFzKG1vbWVudCgpLCB0aGlzKS5zdGFydE9mKCdkYXknKSxcbiAgICAgICAgICAgICAgICBkaWZmID0gdGhpcy5kaWZmKHNvZCwgJ2RheXMnLCB0cnVlKSxcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBkaWZmIDwgLTYgPyAnc2FtZUVsc2UnIDpcbiAgICAgICAgICAgICAgICAgICAgZGlmZiA8IC0xID8gJ2xhc3RXZWVrJyA6XG4gICAgICAgICAgICAgICAgICAgIGRpZmYgPCAwID8gJ2xhc3REYXknIDpcbiAgICAgICAgICAgICAgICAgICAgZGlmZiA8IDEgPyAnc2FtZURheScgOlxuICAgICAgICAgICAgICAgICAgICBkaWZmIDwgMiA/ICduZXh0RGF5JyA6XG4gICAgICAgICAgICAgICAgICAgIGRpZmYgPCA3ID8gJ25leHRXZWVrJyA6ICdzYW1lRWxzZSc7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQodGhpcy5sYW5nKCkuY2FsZW5kYXIoZm9ybWF0LCB0aGlzKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNMZWFwWWVhciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHRoaXMueWVhcigpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc0RTVCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy56b25lKCkgPCB0aGlzLmNsb25lKCkubW9udGgoMCkuem9uZSgpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy56b25lKCkgPCB0aGlzLmNsb25lKCkubW9udGgoNSkuem9uZSgpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkYXkgOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciBkYXkgPSB0aGlzLl9pc1VUQyA/IHRoaXMuX2QuZ2V0VVRDRGF5KCkgOiB0aGlzLl9kLmdldERheSgpO1xuICAgICAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IHBhcnNlV2Vla2RheShpbnB1dCwgdGhpcy5sYW5nKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZCh7IGQgOiBpbnB1dCAtIGRheSB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtb250aCA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgdmFyIHV0YyA9IHRoaXMuX2lzVVRDID8gJ1VUQycgOiAnJyxcbiAgICAgICAgICAgICAgICBkYXlPZk1vbnRoO1xuXG4gICAgICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0ID0gdGhpcy5sYW5nKCkubW9udGhzUGFyc2UoaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkYXlPZk1vbnRoID0gdGhpcy5kYXRlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRlKDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RbJ3NldCcgKyB1dGMgKyAnTW9udGgnXShpbnB1dCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRlKE1hdGgubWluKGRheU9mTW9udGgsIHRoaXMuZGF5c0luTW9udGgoKSkpO1xuXG4gICAgICAgICAgICAgICAgbW9tZW50LnVwZGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RbJ2dldCcgKyB1dGMgKyAnTW9udGgnXSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHN0YXJ0T2Y6IGZ1bmN0aW9uICh1bml0cykge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgICAgICAvLyB0aGUgZm9sbG93aW5nIHN3aXRjaCBpbnRlbnRpb25hbGx5IG9taXRzIGJyZWFrIGtleXdvcmRzXG4gICAgICAgICAgICAvLyB0byB1dGlsaXplIGZhbGxpbmcgdGhyb3VnaCB0aGUgY2FzZXMuXG4gICAgICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKDApO1xuICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGUoMSk7XG4gICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICBjYXNlICdpc29XZWVrJzpcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICAgICAgdGhpcy5ob3VycygwKTtcbiAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICB0aGlzLm1pbnV0ZXMoMCk7XG4gICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICB0aGlzLnNlY29uZHMoMCk7XG4gICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICB0aGlzLm1pbGxpc2Vjb25kcygwKTtcbiAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHdlZWtzIGFyZSBhIHNwZWNpYWwgY2FzZVxuICAgICAgICAgICAgaWYgKHVuaXRzID09PSAnd2VlaycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndlZWtkYXkoMCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVuaXRzID09PSAnaXNvV2VlaycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzb1dlZWtkYXkoMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVuZE9mOiBmdW5jdGlvbiAodW5pdHMpIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRPZih1bml0cykuYWRkKCh1bml0cyA9PT0gJ2lzb1dlZWsnID8gJ3dlZWsnIDogdW5pdHMpLCAxKS5zdWJ0cmFjdCgnbXMnLCAxKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc0FmdGVyOiBmdW5jdGlvbiAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgICAgICB1bml0cyA9IHR5cGVvZiB1bml0cyAhPT0gJ3VuZGVmaW5lZCcgPyB1bml0cyA6ICdtaWxsaXNlY29uZCc7XG4gICAgICAgICAgICByZXR1cm4gK3RoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKSA+ICttb21lbnQoaW5wdXQpLnN0YXJ0T2YodW5pdHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzQmVmb3JlOiBmdW5jdGlvbiAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgICAgICB1bml0cyA9IHR5cGVvZiB1bml0cyAhPT0gJ3VuZGVmaW5lZCcgPyB1bml0cyA6ICdtaWxsaXNlY29uZCc7XG4gICAgICAgICAgICByZXR1cm4gK3RoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKSA8ICttb21lbnQoaW5wdXQpLnN0YXJ0T2YodW5pdHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzU2FtZTogZnVuY3Rpb24gKGlucHV0LCB1bml0cykge1xuICAgICAgICAgICAgdW5pdHMgPSB1bml0cyB8fCAnbXMnO1xuICAgICAgICAgICAgcmV0dXJuICt0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykgPT09ICttYWtlQXMoaW5wdXQsIHRoaXMpLnN0YXJ0T2YodW5pdHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1pbjogZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgICAgICBvdGhlciA9IG1vbWVudC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIG90aGVyIDwgdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgfSxcblxuICAgICAgICBtYXg6IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICAgICAgb3RoZXIgPSBtb21lbnQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBvdGhlciA+IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgem9uZSA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX29mZnNldCB8fCAwO1xuICAgICAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0ID0gdGltZXpvbmVNaW51dGVzRnJvbVN0cmluZyhpbnB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhpbnB1dCkgPCAxNikge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0ICogNjA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IGlucHV0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ICE9PSBpbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBhZGRPclN1YnRyYWN0RHVyYXRpb25Gcm9tTW9tZW50KHRoaXMsIG1vbWVudC5kdXJhdGlvbihvZmZzZXQgLSBpbnB1dCwgJ20nKSwgMSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyBvZmZzZXQgOiB0aGlzLl9kLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICB6b25lQWJiciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/IFwiVVRDXCIgOiBcIlwiO1xuICAgICAgICB9LFxuXG4gICAgICAgIHpvbmVOYW1lIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gXCJDb29yZGluYXRlZCBVbml2ZXJzYWwgVGltZVwiIDogXCJcIjtcbiAgICAgICAgfSxcblxuICAgICAgICBwYXJzZVpvbmUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdHptKSB7XG4gICAgICAgICAgICAgICAgdGhpcy56b25lKHRoaXMuX3R6bSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9pID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMuem9uZSh0aGlzLl9pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhc0FsaWduZWRIb3VyT2Zmc2V0IDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBtb21lbnQoaW5wdXQpLnpvbmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnpvbmUoKSAtIGlucHV0KSAlIDYwID09PSAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRheXNJbk1vbnRoIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRheXNJbk1vbnRoKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRheU9mWWVhciA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgdmFyIGRheU9mWWVhciA9IHJvdW5kKChtb21lbnQodGhpcykuc3RhcnRPZignZGF5JykgLSBtb21lbnQodGhpcykuc3RhcnRPZigneWVhcicpKSAvIDg2NGU1KSArIDE7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IGRheU9mWWVhciA6IHRoaXMuYWRkKFwiZFwiLCAoaW5wdXQgLSBkYXlPZlllYXIpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBxdWFydGVyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbCgodGhpcy5tb250aCgpICsgMS4wKSAvIDMuMCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgd2Vla1llYXIgOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciB5ZWFyID0gd2Vla09mWWVhcih0aGlzLCB0aGlzLmxhbmcoKS5fd2Vlay5kb3csIHRoaXMubGFuZygpLl93ZWVrLmRveSkueWVhcjtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8geWVhciA6IHRoaXMuYWRkKFwieVwiLCAoaW5wdXQgLSB5ZWFyKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNvV2Vla1llYXIgOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciB5ZWFyID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS55ZWFyO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB5ZWFyIDogdGhpcy5hZGQoXCJ5XCIsIChpbnB1dCAtIHllYXIpKTtcbiAgICAgICAgfSxcblxuICAgICAgICB3ZWVrIDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgd2VlayA9IHRoaXMubGFuZygpLndlZWsodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZChcImRcIiwgKGlucHV0IC0gd2VlaykgKiA3KTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc29XZWVrIDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgd2VlayA9IHdlZWtPZlllYXIodGhpcywgMSwgNCkud2VlaztcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKFwiZFwiLCAoaW5wdXQgLSB3ZWVrKSAqIDcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHdlZWtkYXkgOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciB3ZWVrZGF5ID0gKHRoaXMuZGF5KCkgKyA3IC0gdGhpcy5sYW5nKCkuX3dlZWsuZG93KSAlIDc7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWtkYXkgOiB0aGlzLmFkZChcImRcIiwgaW5wdXQgLSB3ZWVrZGF5KTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc29XZWVrZGF5IDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICAvLyBiZWhhdmVzIHRoZSBzYW1lIGFzIG1vbWVudCNkYXkgZXhjZXB0XG4gICAgICAgICAgICAvLyBhcyBhIGdldHRlciwgcmV0dXJucyA3IGluc3RlYWQgb2YgMCAoMS03IHJhbmdlIGluc3RlYWQgb2YgMC02KVxuICAgICAgICAgICAgLy8gYXMgYSBzZXR0ZXIsIHN1bmRheSBzaG91bGQgYmVsb25nIHRvIHRoZSBwcmV2aW91cyB3ZWVrLlxuICAgICAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB0aGlzLmRheSgpIHx8IDcgOiB0aGlzLmRheSh0aGlzLmRheSgpICUgNyA/IGlucHV0IDogaW5wdXQgLSA3KTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgOiBmdW5jdGlvbiAodW5pdHMpIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0IDogZnVuY3Rpb24gKHVuaXRzLCB2YWx1ZSkge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXNbdW5pdHNdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpc1t1bml0c10odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gSWYgcGFzc2VkIGEgbGFuZ3VhZ2Uga2V5LCBpdCB3aWxsIHNldCB0aGUgbGFuZ3VhZ2UgZm9yIHRoaXNcbiAgICAgICAgLy8gaW5zdGFuY2UuICBPdGhlcndpc2UsIGl0IHdpbGwgcmV0dXJuIHRoZSBsYW5ndWFnZSBjb25maWd1cmF0aW9uXG4gICAgICAgIC8vIHZhcmlhYmxlcyBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICAgICAgbGFuZyA6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYW5nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYW5nID0gZ2V0TGFuZ0RlZmluaXRpb24oa2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gaGVscGVyIGZvciBhZGRpbmcgc2hvcnRjdXRzXG4gICAgZnVuY3Rpb24gbWFrZUdldHRlckFuZFNldHRlcihuYW1lLCBrZXkpIHtcbiAgICAgICAgbW9tZW50LmZuW25hbWVdID0gbW9tZW50LmZuW25hbWUgKyAncyddID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgdXRjID0gdGhpcy5faXNVVEMgPyAnVVRDJyA6ICcnO1xuICAgICAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kWydzZXQnICsgdXRjICsga2V5XShpbnB1dCk7XG4gICAgICAgICAgICAgICAgbW9tZW50LnVwZGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RbJ2dldCcgKyB1dGMgKyBrZXldKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gbG9vcCB0aHJvdWdoIGFuZCBhZGQgc2hvcnRjdXRzIChNb250aCwgRGF0ZSwgSG91cnMsIE1pbnV0ZXMsIFNlY29uZHMsIE1pbGxpc2Vjb25kcylcbiAgICBmb3IgKGkgPSAwOyBpIDwgcHJveHlHZXR0ZXJzQW5kU2V0dGVycy5sZW5ndGg7IGkgKyspIHtcbiAgICAgICAgbWFrZUdldHRlckFuZFNldHRlcihwcm94eUdldHRlcnNBbmRTZXR0ZXJzW2ldLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvcyQvLCAnJyksIHByb3h5R2V0dGVyc0FuZFNldHRlcnNbaV0pO1xuICAgIH1cblxuICAgIC8vIGFkZCBzaG9ydGN1dCBmb3IgeWVhciAodXNlcyBkaWZmZXJlbnQgc3ludGF4IHRoYW4gdGhlIGdldHRlci9zZXR0ZXIgJ3llYXInID09ICdGdWxsWWVhcicpXG4gICAgbWFrZUdldHRlckFuZFNldHRlcigneWVhcicsICdGdWxsWWVhcicpO1xuXG4gICAgLy8gYWRkIHBsdXJhbCBtZXRob2RzXG4gICAgbW9tZW50LmZuLmRheXMgPSBtb21lbnQuZm4uZGF5O1xuICAgIG1vbWVudC5mbi5tb250aHMgPSBtb21lbnQuZm4ubW9udGg7XG4gICAgbW9tZW50LmZuLndlZWtzID0gbW9tZW50LmZuLndlZWs7XG4gICAgbW9tZW50LmZuLmlzb1dlZWtzID0gbW9tZW50LmZuLmlzb1dlZWs7XG5cbiAgICAvLyBhZGQgYWxpYXNlZCBmb3JtYXQgbWV0aG9kc1xuICAgIG1vbWVudC5mbi50b0pTT04gPSBtb21lbnQuZm4udG9JU09TdHJpbmc7XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIER1cmF0aW9uIFByb3RvdHlwZVxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgZXh0ZW5kKG1vbWVudC5kdXJhdGlvbi5mbiA9IER1cmF0aW9uLnByb3RvdHlwZSwge1xuXG4gICAgICAgIF9idWJibGUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzLFxuICAgICAgICAgICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyxcbiAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5fZGF0YSxcbiAgICAgICAgICAgICAgICBzZWNvbmRzLCBtaW51dGVzLCBob3VycywgeWVhcnM7XG5cbiAgICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBidWJibGVzIHVwIHZhbHVlcywgc2VlIHRoZSB0ZXN0cyBmb3JcbiAgICAgICAgICAgIC8vIGV4YW1wbGVzIG9mIHdoYXQgdGhhdCBtZWFucy5cbiAgICAgICAgICAgIGRhdGEubWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzICUgMTAwMDtcblxuICAgICAgICAgICAgc2Vjb25kcyA9IGFic1JvdW5kKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICAgICAgICAgICAgZGF0YS5zZWNvbmRzID0gc2Vjb25kcyAlIDYwO1xuXG4gICAgICAgICAgICBtaW51dGVzID0gYWJzUm91bmQoc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgICAgIGRhdGEubWludXRlcyA9IG1pbnV0ZXMgJSA2MDtcblxuICAgICAgICAgICAgaG91cnMgPSBhYnNSb3VuZChtaW51dGVzIC8gNjApO1xuICAgICAgICAgICAgZGF0YS5ob3VycyA9IGhvdXJzICUgMjQ7XG5cbiAgICAgICAgICAgIGRheXMgKz0gYWJzUm91bmQoaG91cnMgLyAyNCk7XG4gICAgICAgICAgICBkYXRhLmRheXMgPSBkYXlzICUgMzA7XG5cbiAgICAgICAgICAgIG1vbnRocyArPSBhYnNSb3VuZChkYXlzIC8gMzApO1xuICAgICAgICAgICAgZGF0YS5tb250aHMgPSBtb250aHMgJSAxMjtcblxuICAgICAgICAgICAgeWVhcnMgPSBhYnNSb3VuZChtb250aHMgLyAxMik7XG4gICAgICAgICAgICBkYXRhLnllYXJzID0geWVhcnM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgd2Vla3MgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gYWJzUm91bmQodGhpcy5kYXlzKCkgLyA3KTtcbiAgICAgICAgfSxcblxuICAgICAgICB2YWx1ZU9mIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21pbGxpc2Vjb25kcyArXG4gICAgICAgICAgICAgIHRoaXMuX2RheXMgKiA4NjRlNSArXG4gICAgICAgICAgICAgICh0aGlzLl9tb250aHMgJSAxMikgKiAyNTkyZTYgK1xuICAgICAgICAgICAgICB0b0ludCh0aGlzLl9tb250aHMgLyAxMikgKiAzMTUzNmU2O1xuICAgICAgICB9LFxuXG4gICAgICAgIGh1bWFuaXplIDogZnVuY3Rpb24gKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgICAgIHZhciBkaWZmZXJlbmNlID0gK3RoaXMsXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gcmVsYXRpdmVUaW1lKGRpZmZlcmVuY2UsICF3aXRoU3VmZml4LCB0aGlzLmxhbmcoKSk7XG5cbiAgICAgICAgICAgIGlmICh3aXRoU3VmZml4KSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gdGhpcy5sYW5nKCkucGFzdEZ1dHVyZShkaWZmZXJlbmNlLCBvdXRwdXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYW5nKCkucG9zdGZvcm1hdChvdXRwdXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZCA6IGZ1bmN0aW9uIChpbnB1dCwgdmFsKSB7XG4gICAgICAgICAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBhZGQoMSwgJ3MnKSBvciBhZGQobW9tZW50KVxuICAgICAgICAgICAgdmFyIGR1ciA9IG1vbWVudC5kdXJhdGlvbihpbnB1dCwgdmFsKTtcblxuICAgICAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzICs9IGR1ci5fbWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgdGhpcy5fZGF5cyArPSBkdXIuX2RheXM7XG4gICAgICAgICAgICB0aGlzLl9tb250aHMgKz0gZHVyLl9tb250aHM7XG5cbiAgICAgICAgICAgIHRoaXMuX2J1YmJsZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBzdWJ0cmFjdCA6IGZ1bmN0aW9uIChpbnB1dCwgdmFsKSB7XG4gICAgICAgICAgICB2YXIgZHVyID0gbW9tZW50LmR1cmF0aW9uKGlucHV0LCB2YWwpO1xuXG4gICAgICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgLT0gZHVyLl9taWxsaXNlY29uZHM7XG4gICAgICAgICAgICB0aGlzLl9kYXlzIC09IGR1ci5fZGF5cztcbiAgICAgICAgICAgIHRoaXMuX21vbnRocyAtPSBkdXIuX21vbnRocztcblxuICAgICAgICAgICAgdGhpcy5fYnViYmxlKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCA6IGZ1bmN0aW9uICh1bml0cykge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0cy50b0xvd2VyQ2FzZSgpICsgJ3MnXSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFzIDogZnVuY3Rpb24gKHVuaXRzKSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzWydhcycgKyB1bml0cy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHVuaXRzLnNsaWNlKDEpICsgJ3MnXSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGxhbmcgOiBtb21lbnQuZm4ubGFuZyxcblxuICAgICAgICB0b0lzb1N0cmluZyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9kb3JkaWxsZS9tb21lbnQtaXNvZHVyYXRpb24vYmxvYi9tYXN0ZXIvbW9tZW50Lmlzb2R1cmF0aW9uLmpzXG4gICAgICAgICAgICB2YXIgeWVhcnMgPSBNYXRoLmFicyh0aGlzLnllYXJzKCkpLFxuICAgICAgICAgICAgICAgIG1vbnRocyA9IE1hdGguYWJzKHRoaXMubW9udGhzKCkpLFxuICAgICAgICAgICAgICAgIGRheXMgPSBNYXRoLmFicyh0aGlzLmRheXMoKSksXG4gICAgICAgICAgICAgICAgaG91cnMgPSBNYXRoLmFicyh0aGlzLmhvdXJzKCkpLFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBNYXRoLmFicyh0aGlzLm1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgICAgc2Vjb25kcyA9IE1hdGguYWJzKHRoaXMuc2Vjb25kcygpICsgdGhpcy5taWxsaXNlY29uZHMoKSAvIDEwMDApO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuYXNTZWNvbmRzKCkpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBzYW1lIGFzIEMjJ3MgKE5vZGEpIGFuZCBweXRob24gKGlzb2RhdGUpLi4uXG4gICAgICAgICAgICAgICAgLy8gYnV0IG5vdCBvdGhlciBKUyAoZ29vZy5kYXRlKVxuICAgICAgICAgICAgICAgIHJldHVybiAnUDBEJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmFzU2Vjb25kcygpIDwgMCA/ICctJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgJ1AnICtcbiAgICAgICAgICAgICAgICAoeWVhcnMgPyB5ZWFycyArICdZJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgKG1vbnRocyA/IG1vbnRocyArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgKGRheXMgPyBkYXlzICsgJ0QnIDogJycpICtcbiAgICAgICAgICAgICAgICAoKGhvdXJzIHx8IG1pbnV0ZXMgfHwgc2Vjb25kcykgPyAnVCcgOiAnJykgK1xuICAgICAgICAgICAgICAgIChob3VycyA/IGhvdXJzICsgJ0gnIDogJycpICtcbiAgICAgICAgICAgICAgICAobWludXRlcyA/IG1pbnV0ZXMgKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgICAgIChzZWNvbmRzID8gc2Vjb25kcyArICdTJyA6ICcnKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbWFrZUR1cmF0aW9uR2V0dGVyKG5hbWUpIHtcbiAgICAgICAgbW9tZW50LmR1cmF0aW9uLmZuW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFbbmFtZV07XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUR1cmF0aW9uQXNHZXR0ZXIobmFtZSwgZmFjdG9yKSB7XG4gICAgICAgIG1vbWVudC5kdXJhdGlvbi5mblsnYXMnICsgbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gK3RoaXMgLyBmYWN0b3I7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZm9yIChpIGluIHVuaXRNaWxsaXNlY29uZEZhY3RvcnMpIHtcbiAgICAgICAgaWYgKHVuaXRNaWxsaXNlY29uZEZhY3RvcnMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIG1ha2VEdXJhdGlvbkFzR2V0dGVyKGksIHVuaXRNaWxsaXNlY29uZEZhY3RvcnNbaV0pO1xuICAgICAgICAgICAgbWFrZUR1cmF0aW9uR2V0dGVyKGkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtYWtlRHVyYXRpb25Bc0dldHRlcignV2Vla3MnLCA2MDQ4ZTUpO1xuICAgIG1vbWVudC5kdXJhdGlvbi5mbi5hc01vbnRocyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICgrdGhpcyAtIHRoaXMueWVhcnMoKSAqIDMxNTM2ZTYpIC8gMjU5MmU2ICsgdGhpcy55ZWFycygpICogMTI7XG4gICAgfTtcblxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBEZWZhdWx0IExhbmdcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgIC8vIFNldCBkZWZhdWx0IGxhbmd1YWdlLCBvdGhlciBsYW5ndWFnZXMgd2lsbCBpbmhlcml0IGZyb20gRW5nbGlzaC5cbiAgICBtb21lbnQubGFuZygnZW4nLCB7XG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0b0ludChudW1iZXIgJSAxMDAgLyAxMCkgPT09IDEpID8gJ3RoJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDIpID8gJ25kJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDMpID8gJ3JkJyA6ICd0aCc7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKiBFTUJFRF9MQU5HVUFHRVMgKi9cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgRXhwb3NpbmcgTW9tZW50XG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgZnVuY3Rpb24gbWFrZUdsb2JhbChkZXByZWNhdGUpIHtcbiAgICAgICAgdmFyIHdhcm5lZCA9IGZhbHNlLCBsb2NhbF9tb21lbnQgPSBtb21lbnQ7XG4gICAgICAgIC8qZ2xvYmFsIGVuZGVyOmZhbHNlICovXG4gICAgICAgIGlmICh0eXBlb2YgZW5kZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGVyZSwgYHRoaXNgIG1lYW5zIGB3aW5kb3dgIGluIHRoZSBicm93c2VyLCBvciBgZ2xvYmFsYCBvbiB0aGUgc2VydmVyXG4gICAgICAgIC8vIGFkZCBgbW9tZW50YCBhcyBhIGdsb2JhbCBvYmplY3QgdmlhIGEgc3RyaW5nIGlkZW50aWZpZXIsXG4gICAgICAgIC8vIGZvciBDbG9zdXJlIENvbXBpbGVyIFwiYWR2YW5jZWRcIiBtb2RlXG4gICAgICAgIGlmIChkZXByZWNhdGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5tb21lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF3YXJuZWQgJiYgY29uc29sZSAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQWNjZXNzaW5nIE1vbWVudCB0aHJvdWdoIHRoZSBnbG9iYWwgc2NvcGUgaXMgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGVwcmVjYXRlZCwgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhbiB1cGNvbWluZyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJyZWxlYXNlLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsX21vbWVudC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4dGVuZChnbG9iYWwubW9tZW50LCBsb2NhbF9tb21lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsWydtb21lbnQnXSA9IG1vbWVudDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbW1vbkpTIG1vZHVsZSBpcyBkZWZpbmVkXG4gICAgaWYgKGhhc01vZHVsZSkge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IG1vbWVudDtcbiAgICAgICAgbWFrZUdsb2JhbCh0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShcIm1vbWVudFwiLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgICAgICAgICBpZiAobW9kdWxlLmNvbmZpZyAmJiBtb2R1bGUuY29uZmlnKCkgJiYgbW9kdWxlLmNvbmZpZygpLm5vR2xvYmFsICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdXNlciBwcm92aWRlZCBub0dsb2JhbCwgaGUgaXMgYXdhcmUgb2YgZ2xvYmFsXG4gICAgICAgICAgICAgICAgbWFrZUdsb2JhbChtb2R1bGUuY29uZmlnKCkubm9HbG9iYWwgPT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtb21lbnQ7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG1ha2VHbG9iYWwoKTtcbiAgICB9XG59KS5jYWxsKHRoaXMpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEyIElnb3IgVmF5bmJlcmdcblxuVmVyc2lvbjogMy41LjIgVGltZXN0YW1wOiBTYXQgTm92ICAxIDE0OjQzOjM2IEVEVCAyMDE0XG5cblRoaXMgc29mdHdhcmUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiQXBhY2hlIExpY2Vuc2VcIikgb3IgdGhlIEdOVVxuR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIgKHRoZSBcIkdQTCBMaWNlbnNlXCIpLiBZb3UgbWF5IGNob29zZSBlaXRoZXIgbGljZW5zZSB0byBnb3Zlcm4geW91clxudXNlIG9mIHRoaXMgc29mdHdhcmUgb25seSB1cG9uIHRoZSBjb25kaXRpb24gdGhhdCB5b3UgYWNjZXB0IGFsbCBvZiB0aGUgdGVybXMgb2YgZWl0aGVyIHRoZSBBcGFjaGVcbkxpY2Vuc2Ugb3IgdGhlIEdQTCBMaWNlbnNlLlxuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIEFwYWNoZSBMaWNlbnNlIGFuZCB0aGUgR1BMIExpY2Vuc2UgYXQ6XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICBodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvZ3BsLTIuMC5odG1sXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlXG5BcGFjaGUgTGljZW5zZSBvciB0aGUgR1BMIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1JcbkNPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgQXBhY2hlIExpY2Vuc2UgYW5kIHRoZSBHUEwgTGljZW5zZSBmb3JcbnRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSBhbmQgdGhlIEdQTCBMaWNlbnNlLlxuKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIGlmKHR5cGVvZiAkLmZuLmVhY2gyID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgJC5leHRlbmQoJC5mbiwge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICogNC0xMCB0aW1lcyBmYXN0ZXIgLmVhY2ggcmVwbGFjZW1lbnRcbiAgICAgICAgICAgICogdXNlIGl0IGNhcmVmdWxseSwgYXMgaXQgb3ZlcnJpZGVzIGpRdWVyeSBjb250ZXh0IG9mIGVsZW1lbnQgb24gZWFjaCBpdGVyYXRpb25cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBlYWNoMiA6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgdmFyIGogPSAkKFswXSksIGkgPSAtMSwgbCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlIChcbiAgICAgICAgICAgICAgICAgICAgKytpIDwgbFxuICAgICAgICAgICAgICAgICAgICAmJiAoai5jb250ZXh0ID0galswXSA9IHRoaXNbaV0pXG4gICAgICAgICAgICAgICAgICAgICYmIGMuY2FsbChqWzBdLCBpLCBqKSAhPT0gZmFsc2UgLy9cInRoaXNcIj1ET00sIGk9aW5kZXgsIGo9alF1ZXJ5IG9iamVjdFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn0pKGpRdWVyeSk7XG5cbihmdW5jdGlvbiAoJCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgLypnbG9iYWwgZG9jdW1lbnQsIHdpbmRvdywgalF1ZXJ5LCBjb25zb2xlICovXG5cbiAgICBpZiAod2luZG93LlNlbGVjdDIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIEFic3RyYWN0U2VsZWN0MiwgU2luZ2xlU2VsZWN0MiwgTXVsdGlTZWxlY3QyLCBuZXh0VWlkLCBzaXplcixcbiAgICAgICAgbGFzdE1vdXNlUG9zaXRpb249e3g6MCx5OjB9LCAkZG9jdW1lbnQsIHNjcm9sbEJhckRpbWVuc2lvbnMsXG5cbiAgICBLRVkgPSB7XG4gICAgICAgIFRBQjogOSxcbiAgICAgICAgRU5URVI6IDEzLFxuICAgICAgICBFU0M6IDI3LFxuICAgICAgICBTUEFDRTogMzIsXG4gICAgICAgIExFRlQ6IDM3LFxuICAgICAgICBVUDogMzgsXG4gICAgICAgIFJJR0hUOiAzOSxcbiAgICAgICAgRE9XTjogNDAsXG4gICAgICAgIFNISUZUOiAxNixcbiAgICAgICAgQ1RSTDogMTcsXG4gICAgICAgIEFMVDogMTgsXG4gICAgICAgIFBBR0VfVVA6IDMzLFxuICAgICAgICBQQUdFX0RPV046IDM0LFxuICAgICAgICBIT01FOiAzNixcbiAgICAgICAgRU5EOiAzNSxcbiAgICAgICAgQkFDS1NQQUNFOiA4LFxuICAgICAgICBERUxFVEU6IDQ2LFxuICAgICAgICBpc0Fycm93OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgayA9IGsud2hpY2ggPyBrLndoaWNoIDogaztcbiAgICAgICAgICAgIHN3aXRjaCAoaykge1xuICAgICAgICAgICAgY2FzZSBLRVkuTEVGVDpcbiAgICAgICAgICAgIGNhc2UgS0VZLlJJR0hUOlxuICAgICAgICAgICAgY2FzZSBLRVkuVVA6XG4gICAgICAgICAgICBjYXNlIEtFWS5ET1dOOlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBpc0NvbnRyb2w6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgayA9IGUud2hpY2g7XG4gICAgICAgICAgICBzd2l0Y2ggKGspIHtcbiAgICAgICAgICAgIGNhc2UgS0VZLlNISUZUOlxuICAgICAgICAgICAgY2FzZSBLRVkuQ1RSTDpcbiAgICAgICAgICAgIGNhc2UgS0VZLkFMVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGUubWV0YUtleSkgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNGdW5jdGlvbktleTogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGsgPSBrLndoaWNoID8gay53aGljaCA6IGs7XG4gICAgICAgICAgICByZXR1cm4gayA+PSAxMTIgJiYgayA8PSAxMjM7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIE1FQVNVUkVfU0NST0xMQkFSX1RFTVBMQVRFID0gXCI8ZGl2IGNsYXNzPSdzZWxlY3QyLW1lYXN1cmUtc2Nyb2xsYmFyJz48L2Rpdj5cIixcblxuICAgIERJQUNSSVRJQ1MgPSB7XCJcXHUyNEI2XCI6XCJBXCIsXCJcXHVGRjIxXCI6XCJBXCIsXCJcXHUwMEMwXCI6XCJBXCIsXCJcXHUwMEMxXCI6XCJBXCIsXCJcXHUwMEMyXCI6XCJBXCIsXCJcXHUxRUE2XCI6XCJBXCIsXCJcXHUxRUE0XCI6XCJBXCIsXCJcXHUxRUFBXCI6XCJBXCIsXCJcXHUxRUE4XCI6XCJBXCIsXCJcXHUwMEMzXCI6XCJBXCIsXCJcXHUwMTAwXCI6XCJBXCIsXCJcXHUwMTAyXCI6XCJBXCIsXCJcXHUxRUIwXCI6XCJBXCIsXCJcXHUxRUFFXCI6XCJBXCIsXCJcXHUxRUI0XCI6XCJBXCIsXCJcXHUxRUIyXCI6XCJBXCIsXCJcXHUwMjI2XCI6XCJBXCIsXCJcXHUwMUUwXCI6XCJBXCIsXCJcXHUwMEM0XCI6XCJBXCIsXCJcXHUwMURFXCI6XCJBXCIsXCJcXHUxRUEyXCI6XCJBXCIsXCJcXHUwMEM1XCI6XCJBXCIsXCJcXHUwMUZBXCI6XCJBXCIsXCJcXHUwMUNEXCI6XCJBXCIsXCJcXHUwMjAwXCI6XCJBXCIsXCJcXHUwMjAyXCI6XCJBXCIsXCJcXHUxRUEwXCI6XCJBXCIsXCJcXHUxRUFDXCI6XCJBXCIsXCJcXHUxRUI2XCI6XCJBXCIsXCJcXHUxRTAwXCI6XCJBXCIsXCJcXHUwMTA0XCI6XCJBXCIsXCJcXHUwMjNBXCI6XCJBXCIsXCJcXHUyQzZGXCI6XCJBXCIsXCJcXHVBNzMyXCI6XCJBQVwiLFwiXFx1MDBDNlwiOlwiQUVcIixcIlxcdTAxRkNcIjpcIkFFXCIsXCJcXHUwMUUyXCI6XCJBRVwiLFwiXFx1QTczNFwiOlwiQU9cIixcIlxcdUE3MzZcIjpcIkFVXCIsXCJcXHVBNzM4XCI6XCJBVlwiLFwiXFx1QTczQVwiOlwiQVZcIixcIlxcdUE3M0NcIjpcIkFZXCIsXCJcXHUyNEI3XCI6XCJCXCIsXCJcXHVGRjIyXCI6XCJCXCIsXCJcXHUxRTAyXCI6XCJCXCIsXCJcXHUxRTA0XCI6XCJCXCIsXCJcXHUxRTA2XCI6XCJCXCIsXCJcXHUwMjQzXCI6XCJCXCIsXCJcXHUwMTgyXCI6XCJCXCIsXCJcXHUwMTgxXCI6XCJCXCIsXCJcXHUyNEI4XCI6XCJDXCIsXCJcXHVGRjIzXCI6XCJDXCIsXCJcXHUwMTA2XCI6XCJDXCIsXCJcXHUwMTA4XCI6XCJDXCIsXCJcXHUwMTBBXCI6XCJDXCIsXCJcXHUwMTBDXCI6XCJDXCIsXCJcXHUwMEM3XCI6XCJDXCIsXCJcXHUxRTA4XCI6XCJDXCIsXCJcXHUwMTg3XCI6XCJDXCIsXCJcXHUwMjNCXCI6XCJDXCIsXCJcXHVBNzNFXCI6XCJDXCIsXCJcXHUyNEI5XCI6XCJEXCIsXCJcXHVGRjI0XCI6XCJEXCIsXCJcXHUxRTBBXCI6XCJEXCIsXCJcXHUwMTBFXCI6XCJEXCIsXCJcXHUxRTBDXCI6XCJEXCIsXCJcXHUxRTEwXCI6XCJEXCIsXCJcXHUxRTEyXCI6XCJEXCIsXCJcXHUxRTBFXCI6XCJEXCIsXCJcXHUwMTEwXCI6XCJEXCIsXCJcXHUwMThCXCI6XCJEXCIsXCJcXHUwMThBXCI6XCJEXCIsXCJcXHUwMTg5XCI6XCJEXCIsXCJcXHVBNzc5XCI6XCJEXCIsXCJcXHUwMUYxXCI6XCJEWlwiLFwiXFx1MDFDNFwiOlwiRFpcIixcIlxcdTAxRjJcIjpcIkR6XCIsXCJcXHUwMUM1XCI6XCJEelwiLFwiXFx1MjRCQVwiOlwiRVwiLFwiXFx1RkYyNVwiOlwiRVwiLFwiXFx1MDBDOFwiOlwiRVwiLFwiXFx1MDBDOVwiOlwiRVwiLFwiXFx1MDBDQVwiOlwiRVwiLFwiXFx1MUVDMFwiOlwiRVwiLFwiXFx1MUVCRVwiOlwiRVwiLFwiXFx1MUVDNFwiOlwiRVwiLFwiXFx1MUVDMlwiOlwiRVwiLFwiXFx1MUVCQ1wiOlwiRVwiLFwiXFx1MDExMlwiOlwiRVwiLFwiXFx1MUUxNFwiOlwiRVwiLFwiXFx1MUUxNlwiOlwiRVwiLFwiXFx1MDExNFwiOlwiRVwiLFwiXFx1MDExNlwiOlwiRVwiLFwiXFx1MDBDQlwiOlwiRVwiLFwiXFx1MUVCQVwiOlwiRVwiLFwiXFx1MDExQVwiOlwiRVwiLFwiXFx1MDIwNFwiOlwiRVwiLFwiXFx1MDIwNlwiOlwiRVwiLFwiXFx1MUVCOFwiOlwiRVwiLFwiXFx1MUVDNlwiOlwiRVwiLFwiXFx1MDIyOFwiOlwiRVwiLFwiXFx1MUUxQ1wiOlwiRVwiLFwiXFx1MDExOFwiOlwiRVwiLFwiXFx1MUUxOFwiOlwiRVwiLFwiXFx1MUUxQVwiOlwiRVwiLFwiXFx1MDE5MFwiOlwiRVwiLFwiXFx1MDE4RVwiOlwiRVwiLFwiXFx1MjRCQlwiOlwiRlwiLFwiXFx1RkYyNlwiOlwiRlwiLFwiXFx1MUUxRVwiOlwiRlwiLFwiXFx1MDE5MVwiOlwiRlwiLFwiXFx1QTc3QlwiOlwiRlwiLFwiXFx1MjRCQ1wiOlwiR1wiLFwiXFx1RkYyN1wiOlwiR1wiLFwiXFx1MDFGNFwiOlwiR1wiLFwiXFx1MDExQ1wiOlwiR1wiLFwiXFx1MUUyMFwiOlwiR1wiLFwiXFx1MDExRVwiOlwiR1wiLFwiXFx1MDEyMFwiOlwiR1wiLFwiXFx1MDFFNlwiOlwiR1wiLFwiXFx1MDEyMlwiOlwiR1wiLFwiXFx1MDFFNFwiOlwiR1wiLFwiXFx1MDE5M1wiOlwiR1wiLFwiXFx1QTdBMFwiOlwiR1wiLFwiXFx1QTc3RFwiOlwiR1wiLFwiXFx1QTc3RVwiOlwiR1wiLFwiXFx1MjRCRFwiOlwiSFwiLFwiXFx1RkYyOFwiOlwiSFwiLFwiXFx1MDEyNFwiOlwiSFwiLFwiXFx1MUUyMlwiOlwiSFwiLFwiXFx1MUUyNlwiOlwiSFwiLFwiXFx1MDIxRVwiOlwiSFwiLFwiXFx1MUUyNFwiOlwiSFwiLFwiXFx1MUUyOFwiOlwiSFwiLFwiXFx1MUUyQVwiOlwiSFwiLFwiXFx1MDEyNlwiOlwiSFwiLFwiXFx1MkM2N1wiOlwiSFwiLFwiXFx1MkM3NVwiOlwiSFwiLFwiXFx1QTc4RFwiOlwiSFwiLFwiXFx1MjRCRVwiOlwiSVwiLFwiXFx1RkYyOVwiOlwiSVwiLFwiXFx1MDBDQ1wiOlwiSVwiLFwiXFx1MDBDRFwiOlwiSVwiLFwiXFx1MDBDRVwiOlwiSVwiLFwiXFx1MDEyOFwiOlwiSVwiLFwiXFx1MDEyQVwiOlwiSVwiLFwiXFx1MDEyQ1wiOlwiSVwiLFwiXFx1MDEzMFwiOlwiSVwiLFwiXFx1MDBDRlwiOlwiSVwiLFwiXFx1MUUyRVwiOlwiSVwiLFwiXFx1MUVDOFwiOlwiSVwiLFwiXFx1MDFDRlwiOlwiSVwiLFwiXFx1MDIwOFwiOlwiSVwiLFwiXFx1MDIwQVwiOlwiSVwiLFwiXFx1MUVDQVwiOlwiSVwiLFwiXFx1MDEyRVwiOlwiSVwiLFwiXFx1MUUyQ1wiOlwiSVwiLFwiXFx1MDE5N1wiOlwiSVwiLFwiXFx1MjRCRlwiOlwiSlwiLFwiXFx1RkYyQVwiOlwiSlwiLFwiXFx1MDEzNFwiOlwiSlwiLFwiXFx1MDI0OFwiOlwiSlwiLFwiXFx1MjRDMFwiOlwiS1wiLFwiXFx1RkYyQlwiOlwiS1wiLFwiXFx1MUUzMFwiOlwiS1wiLFwiXFx1MDFFOFwiOlwiS1wiLFwiXFx1MUUzMlwiOlwiS1wiLFwiXFx1MDEzNlwiOlwiS1wiLFwiXFx1MUUzNFwiOlwiS1wiLFwiXFx1MDE5OFwiOlwiS1wiLFwiXFx1MkM2OVwiOlwiS1wiLFwiXFx1QTc0MFwiOlwiS1wiLFwiXFx1QTc0MlwiOlwiS1wiLFwiXFx1QTc0NFwiOlwiS1wiLFwiXFx1QTdBMlwiOlwiS1wiLFwiXFx1MjRDMVwiOlwiTFwiLFwiXFx1RkYyQ1wiOlwiTFwiLFwiXFx1MDEzRlwiOlwiTFwiLFwiXFx1MDEzOVwiOlwiTFwiLFwiXFx1MDEzRFwiOlwiTFwiLFwiXFx1MUUzNlwiOlwiTFwiLFwiXFx1MUUzOFwiOlwiTFwiLFwiXFx1MDEzQlwiOlwiTFwiLFwiXFx1MUUzQ1wiOlwiTFwiLFwiXFx1MUUzQVwiOlwiTFwiLFwiXFx1MDE0MVwiOlwiTFwiLFwiXFx1MDIzRFwiOlwiTFwiLFwiXFx1MkM2MlwiOlwiTFwiLFwiXFx1MkM2MFwiOlwiTFwiLFwiXFx1QTc0OFwiOlwiTFwiLFwiXFx1QTc0NlwiOlwiTFwiLFwiXFx1QTc4MFwiOlwiTFwiLFwiXFx1MDFDN1wiOlwiTEpcIixcIlxcdTAxQzhcIjpcIkxqXCIsXCJcXHUyNEMyXCI6XCJNXCIsXCJcXHVGRjJEXCI6XCJNXCIsXCJcXHUxRTNFXCI6XCJNXCIsXCJcXHUxRTQwXCI6XCJNXCIsXCJcXHUxRTQyXCI6XCJNXCIsXCJcXHUyQzZFXCI6XCJNXCIsXCJcXHUwMTlDXCI6XCJNXCIsXCJcXHUyNEMzXCI6XCJOXCIsXCJcXHVGRjJFXCI6XCJOXCIsXCJcXHUwMUY4XCI6XCJOXCIsXCJcXHUwMTQzXCI6XCJOXCIsXCJcXHUwMEQxXCI6XCJOXCIsXCJcXHUxRTQ0XCI6XCJOXCIsXCJcXHUwMTQ3XCI6XCJOXCIsXCJcXHUxRTQ2XCI6XCJOXCIsXCJcXHUwMTQ1XCI6XCJOXCIsXCJcXHUxRTRBXCI6XCJOXCIsXCJcXHUxRTQ4XCI6XCJOXCIsXCJcXHUwMjIwXCI6XCJOXCIsXCJcXHUwMTlEXCI6XCJOXCIsXCJcXHVBNzkwXCI6XCJOXCIsXCJcXHVBN0E0XCI6XCJOXCIsXCJcXHUwMUNBXCI6XCJOSlwiLFwiXFx1MDFDQlwiOlwiTmpcIixcIlxcdTI0QzRcIjpcIk9cIixcIlxcdUZGMkZcIjpcIk9cIixcIlxcdTAwRDJcIjpcIk9cIixcIlxcdTAwRDNcIjpcIk9cIixcIlxcdTAwRDRcIjpcIk9cIixcIlxcdTFFRDJcIjpcIk9cIixcIlxcdTFFRDBcIjpcIk9cIixcIlxcdTFFRDZcIjpcIk9cIixcIlxcdTFFRDRcIjpcIk9cIixcIlxcdTAwRDVcIjpcIk9cIixcIlxcdTFFNENcIjpcIk9cIixcIlxcdTAyMkNcIjpcIk9cIixcIlxcdTFFNEVcIjpcIk9cIixcIlxcdTAxNENcIjpcIk9cIixcIlxcdTFFNTBcIjpcIk9cIixcIlxcdTFFNTJcIjpcIk9cIixcIlxcdTAxNEVcIjpcIk9cIixcIlxcdTAyMkVcIjpcIk9cIixcIlxcdTAyMzBcIjpcIk9cIixcIlxcdTAwRDZcIjpcIk9cIixcIlxcdTAyMkFcIjpcIk9cIixcIlxcdTFFQ0VcIjpcIk9cIixcIlxcdTAxNTBcIjpcIk9cIixcIlxcdTAxRDFcIjpcIk9cIixcIlxcdTAyMENcIjpcIk9cIixcIlxcdTAyMEVcIjpcIk9cIixcIlxcdTAxQTBcIjpcIk9cIixcIlxcdTFFRENcIjpcIk9cIixcIlxcdTFFREFcIjpcIk9cIixcIlxcdTFFRTBcIjpcIk9cIixcIlxcdTFFREVcIjpcIk9cIixcIlxcdTFFRTJcIjpcIk9cIixcIlxcdTFFQ0NcIjpcIk9cIixcIlxcdTFFRDhcIjpcIk9cIixcIlxcdTAxRUFcIjpcIk9cIixcIlxcdTAxRUNcIjpcIk9cIixcIlxcdTAwRDhcIjpcIk9cIixcIlxcdTAxRkVcIjpcIk9cIixcIlxcdTAxODZcIjpcIk9cIixcIlxcdTAxOUZcIjpcIk9cIixcIlxcdUE3NEFcIjpcIk9cIixcIlxcdUE3NENcIjpcIk9cIixcIlxcdTAxQTJcIjpcIk9JXCIsXCJcXHVBNzRFXCI6XCJPT1wiLFwiXFx1MDIyMlwiOlwiT1VcIixcIlxcdTI0QzVcIjpcIlBcIixcIlxcdUZGMzBcIjpcIlBcIixcIlxcdTFFNTRcIjpcIlBcIixcIlxcdTFFNTZcIjpcIlBcIixcIlxcdTAxQTRcIjpcIlBcIixcIlxcdTJDNjNcIjpcIlBcIixcIlxcdUE3NTBcIjpcIlBcIixcIlxcdUE3NTJcIjpcIlBcIixcIlxcdUE3NTRcIjpcIlBcIixcIlxcdTI0QzZcIjpcIlFcIixcIlxcdUZGMzFcIjpcIlFcIixcIlxcdUE3NTZcIjpcIlFcIixcIlxcdUE3NThcIjpcIlFcIixcIlxcdTAyNEFcIjpcIlFcIixcIlxcdTI0QzdcIjpcIlJcIixcIlxcdUZGMzJcIjpcIlJcIixcIlxcdTAxNTRcIjpcIlJcIixcIlxcdTFFNThcIjpcIlJcIixcIlxcdTAxNThcIjpcIlJcIixcIlxcdTAyMTBcIjpcIlJcIixcIlxcdTAyMTJcIjpcIlJcIixcIlxcdTFFNUFcIjpcIlJcIixcIlxcdTFFNUNcIjpcIlJcIixcIlxcdTAxNTZcIjpcIlJcIixcIlxcdTFFNUVcIjpcIlJcIixcIlxcdTAyNENcIjpcIlJcIixcIlxcdTJDNjRcIjpcIlJcIixcIlxcdUE3NUFcIjpcIlJcIixcIlxcdUE3QTZcIjpcIlJcIixcIlxcdUE3ODJcIjpcIlJcIixcIlxcdTI0QzhcIjpcIlNcIixcIlxcdUZGMzNcIjpcIlNcIixcIlxcdTFFOUVcIjpcIlNcIixcIlxcdTAxNUFcIjpcIlNcIixcIlxcdTFFNjRcIjpcIlNcIixcIlxcdTAxNUNcIjpcIlNcIixcIlxcdTFFNjBcIjpcIlNcIixcIlxcdTAxNjBcIjpcIlNcIixcIlxcdTFFNjZcIjpcIlNcIixcIlxcdTFFNjJcIjpcIlNcIixcIlxcdTFFNjhcIjpcIlNcIixcIlxcdTAyMThcIjpcIlNcIixcIlxcdTAxNUVcIjpcIlNcIixcIlxcdTJDN0VcIjpcIlNcIixcIlxcdUE3QThcIjpcIlNcIixcIlxcdUE3ODRcIjpcIlNcIixcIlxcdTI0QzlcIjpcIlRcIixcIlxcdUZGMzRcIjpcIlRcIixcIlxcdTFFNkFcIjpcIlRcIixcIlxcdTAxNjRcIjpcIlRcIixcIlxcdTFFNkNcIjpcIlRcIixcIlxcdTAyMUFcIjpcIlRcIixcIlxcdTAxNjJcIjpcIlRcIixcIlxcdTFFNzBcIjpcIlRcIixcIlxcdTFFNkVcIjpcIlRcIixcIlxcdTAxNjZcIjpcIlRcIixcIlxcdTAxQUNcIjpcIlRcIixcIlxcdTAxQUVcIjpcIlRcIixcIlxcdTAyM0VcIjpcIlRcIixcIlxcdUE3ODZcIjpcIlRcIixcIlxcdUE3MjhcIjpcIlRaXCIsXCJcXHUyNENBXCI6XCJVXCIsXCJcXHVGRjM1XCI6XCJVXCIsXCJcXHUwMEQ5XCI6XCJVXCIsXCJcXHUwMERBXCI6XCJVXCIsXCJcXHUwMERCXCI6XCJVXCIsXCJcXHUwMTY4XCI6XCJVXCIsXCJcXHUxRTc4XCI6XCJVXCIsXCJcXHUwMTZBXCI6XCJVXCIsXCJcXHUxRTdBXCI6XCJVXCIsXCJcXHUwMTZDXCI6XCJVXCIsXCJcXHUwMERDXCI6XCJVXCIsXCJcXHUwMURCXCI6XCJVXCIsXCJcXHUwMUQ3XCI6XCJVXCIsXCJcXHUwMUQ1XCI6XCJVXCIsXCJcXHUwMUQ5XCI6XCJVXCIsXCJcXHUxRUU2XCI6XCJVXCIsXCJcXHUwMTZFXCI6XCJVXCIsXCJcXHUwMTcwXCI6XCJVXCIsXCJcXHUwMUQzXCI6XCJVXCIsXCJcXHUwMjE0XCI6XCJVXCIsXCJcXHUwMjE2XCI6XCJVXCIsXCJcXHUwMUFGXCI6XCJVXCIsXCJcXHUxRUVBXCI6XCJVXCIsXCJcXHUxRUU4XCI6XCJVXCIsXCJcXHUxRUVFXCI6XCJVXCIsXCJcXHUxRUVDXCI6XCJVXCIsXCJcXHUxRUYwXCI6XCJVXCIsXCJcXHUxRUU0XCI6XCJVXCIsXCJcXHUxRTcyXCI6XCJVXCIsXCJcXHUwMTcyXCI6XCJVXCIsXCJcXHUxRTc2XCI6XCJVXCIsXCJcXHUxRTc0XCI6XCJVXCIsXCJcXHUwMjQ0XCI6XCJVXCIsXCJcXHUyNENCXCI6XCJWXCIsXCJcXHVGRjM2XCI6XCJWXCIsXCJcXHUxRTdDXCI6XCJWXCIsXCJcXHUxRTdFXCI6XCJWXCIsXCJcXHUwMUIyXCI6XCJWXCIsXCJcXHVBNzVFXCI6XCJWXCIsXCJcXHUwMjQ1XCI6XCJWXCIsXCJcXHVBNzYwXCI6XCJWWVwiLFwiXFx1MjRDQ1wiOlwiV1wiLFwiXFx1RkYzN1wiOlwiV1wiLFwiXFx1MUU4MFwiOlwiV1wiLFwiXFx1MUU4MlwiOlwiV1wiLFwiXFx1MDE3NFwiOlwiV1wiLFwiXFx1MUU4NlwiOlwiV1wiLFwiXFx1MUU4NFwiOlwiV1wiLFwiXFx1MUU4OFwiOlwiV1wiLFwiXFx1MkM3MlwiOlwiV1wiLFwiXFx1MjRDRFwiOlwiWFwiLFwiXFx1RkYzOFwiOlwiWFwiLFwiXFx1MUU4QVwiOlwiWFwiLFwiXFx1MUU4Q1wiOlwiWFwiLFwiXFx1MjRDRVwiOlwiWVwiLFwiXFx1RkYzOVwiOlwiWVwiLFwiXFx1MUVGMlwiOlwiWVwiLFwiXFx1MDBERFwiOlwiWVwiLFwiXFx1MDE3NlwiOlwiWVwiLFwiXFx1MUVGOFwiOlwiWVwiLFwiXFx1MDIzMlwiOlwiWVwiLFwiXFx1MUU4RVwiOlwiWVwiLFwiXFx1MDE3OFwiOlwiWVwiLFwiXFx1MUVGNlwiOlwiWVwiLFwiXFx1MUVGNFwiOlwiWVwiLFwiXFx1MDFCM1wiOlwiWVwiLFwiXFx1MDI0RVwiOlwiWVwiLFwiXFx1MUVGRVwiOlwiWVwiLFwiXFx1MjRDRlwiOlwiWlwiLFwiXFx1RkYzQVwiOlwiWlwiLFwiXFx1MDE3OVwiOlwiWlwiLFwiXFx1MUU5MFwiOlwiWlwiLFwiXFx1MDE3QlwiOlwiWlwiLFwiXFx1MDE3RFwiOlwiWlwiLFwiXFx1MUU5MlwiOlwiWlwiLFwiXFx1MUU5NFwiOlwiWlwiLFwiXFx1MDFCNVwiOlwiWlwiLFwiXFx1MDIyNFwiOlwiWlwiLFwiXFx1MkM3RlwiOlwiWlwiLFwiXFx1MkM2QlwiOlwiWlwiLFwiXFx1QTc2MlwiOlwiWlwiLFwiXFx1MjREMFwiOlwiYVwiLFwiXFx1RkY0MVwiOlwiYVwiLFwiXFx1MUU5QVwiOlwiYVwiLFwiXFx1MDBFMFwiOlwiYVwiLFwiXFx1MDBFMVwiOlwiYVwiLFwiXFx1MDBFMlwiOlwiYVwiLFwiXFx1MUVBN1wiOlwiYVwiLFwiXFx1MUVBNVwiOlwiYVwiLFwiXFx1MUVBQlwiOlwiYVwiLFwiXFx1MUVBOVwiOlwiYVwiLFwiXFx1MDBFM1wiOlwiYVwiLFwiXFx1MDEwMVwiOlwiYVwiLFwiXFx1MDEwM1wiOlwiYVwiLFwiXFx1MUVCMVwiOlwiYVwiLFwiXFx1MUVBRlwiOlwiYVwiLFwiXFx1MUVCNVwiOlwiYVwiLFwiXFx1MUVCM1wiOlwiYVwiLFwiXFx1MDIyN1wiOlwiYVwiLFwiXFx1MDFFMVwiOlwiYVwiLFwiXFx1MDBFNFwiOlwiYVwiLFwiXFx1MDFERlwiOlwiYVwiLFwiXFx1MUVBM1wiOlwiYVwiLFwiXFx1MDBFNVwiOlwiYVwiLFwiXFx1MDFGQlwiOlwiYVwiLFwiXFx1MDFDRVwiOlwiYVwiLFwiXFx1MDIwMVwiOlwiYVwiLFwiXFx1MDIwM1wiOlwiYVwiLFwiXFx1MUVBMVwiOlwiYVwiLFwiXFx1MUVBRFwiOlwiYVwiLFwiXFx1MUVCN1wiOlwiYVwiLFwiXFx1MUUwMVwiOlwiYVwiLFwiXFx1MDEwNVwiOlwiYVwiLFwiXFx1MkM2NVwiOlwiYVwiLFwiXFx1MDI1MFwiOlwiYVwiLFwiXFx1QTczM1wiOlwiYWFcIixcIlxcdTAwRTZcIjpcImFlXCIsXCJcXHUwMUZEXCI6XCJhZVwiLFwiXFx1MDFFM1wiOlwiYWVcIixcIlxcdUE3MzVcIjpcImFvXCIsXCJcXHVBNzM3XCI6XCJhdVwiLFwiXFx1QTczOVwiOlwiYXZcIixcIlxcdUE3M0JcIjpcImF2XCIsXCJcXHVBNzNEXCI6XCJheVwiLFwiXFx1MjREMVwiOlwiYlwiLFwiXFx1RkY0MlwiOlwiYlwiLFwiXFx1MUUwM1wiOlwiYlwiLFwiXFx1MUUwNVwiOlwiYlwiLFwiXFx1MUUwN1wiOlwiYlwiLFwiXFx1MDE4MFwiOlwiYlwiLFwiXFx1MDE4M1wiOlwiYlwiLFwiXFx1MDI1M1wiOlwiYlwiLFwiXFx1MjREMlwiOlwiY1wiLFwiXFx1RkY0M1wiOlwiY1wiLFwiXFx1MDEwN1wiOlwiY1wiLFwiXFx1MDEwOVwiOlwiY1wiLFwiXFx1MDEwQlwiOlwiY1wiLFwiXFx1MDEwRFwiOlwiY1wiLFwiXFx1MDBFN1wiOlwiY1wiLFwiXFx1MUUwOVwiOlwiY1wiLFwiXFx1MDE4OFwiOlwiY1wiLFwiXFx1MDIzQ1wiOlwiY1wiLFwiXFx1QTczRlwiOlwiY1wiLFwiXFx1MjE4NFwiOlwiY1wiLFwiXFx1MjREM1wiOlwiZFwiLFwiXFx1RkY0NFwiOlwiZFwiLFwiXFx1MUUwQlwiOlwiZFwiLFwiXFx1MDEwRlwiOlwiZFwiLFwiXFx1MUUwRFwiOlwiZFwiLFwiXFx1MUUxMVwiOlwiZFwiLFwiXFx1MUUxM1wiOlwiZFwiLFwiXFx1MUUwRlwiOlwiZFwiLFwiXFx1MDExMVwiOlwiZFwiLFwiXFx1MDE4Q1wiOlwiZFwiLFwiXFx1MDI1NlwiOlwiZFwiLFwiXFx1MDI1N1wiOlwiZFwiLFwiXFx1QTc3QVwiOlwiZFwiLFwiXFx1MDFGM1wiOlwiZHpcIixcIlxcdTAxQzZcIjpcImR6XCIsXCJcXHUyNEQ0XCI6XCJlXCIsXCJcXHVGRjQ1XCI6XCJlXCIsXCJcXHUwMEU4XCI6XCJlXCIsXCJcXHUwMEU5XCI6XCJlXCIsXCJcXHUwMEVBXCI6XCJlXCIsXCJcXHUxRUMxXCI6XCJlXCIsXCJcXHUxRUJGXCI6XCJlXCIsXCJcXHUxRUM1XCI6XCJlXCIsXCJcXHUxRUMzXCI6XCJlXCIsXCJcXHUxRUJEXCI6XCJlXCIsXCJcXHUwMTEzXCI6XCJlXCIsXCJcXHUxRTE1XCI6XCJlXCIsXCJcXHUxRTE3XCI6XCJlXCIsXCJcXHUwMTE1XCI6XCJlXCIsXCJcXHUwMTE3XCI6XCJlXCIsXCJcXHUwMEVCXCI6XCJlXCIsXCJcXHUxRUJCXCI6XCJlXCIsXCJcXHUwMTFCXCI6XCJlXCIsXCJcXHUwMjA1XCI6XCJlXCIsXCJcXHUwMjA3XCI6XCJlXCIsXCJcXHUxRUI5XCI6XCJlXCIsXCJcXHUxRUM3XCI6XCJlXCIsXCJcXHUwMjI5XCI6XCJlXCIsXCJcXHUxRTFEXCI6XCJlXCIsXCJcXHUwMTE5XCI6XCJlXCIsXCJcXHUxRTE5XCI6XCJlXCIsXCJcXHUxRTFCXCI6XCJlXCIsXCJcXHUwMjQ3XCI6XCJlXCIsXCJcXHUwMjVCXCI6XCJlXCIsXCJcXHUwMUREXCI6XCJlXCIsXCJcXHUyNEQ1XCI6XCJmXCIsXCJcXHVGRjQ2XCI6XCJmXCIsXCJcXHUxRTFGXCI6XCJmXCIsXCJcXHUwMTkyXCI6XCJmXCIsXCJcXHVBNzdDXCI6XCJmXCIsXCJcXHUyNEQ2XCI6XCJnXCIsXCJcXHVGRjQ3XCI6XCJnXCIsXCJcXHUwMUY1XCI6XCJnXCIsXCJcXHUwMTFEXCI6XCJnXCIsXCJcXHUxRTIxXCI6XCJnXCIsXCJcXHUwMTFGXCI6XCJnXCIsXCJcXHUwMTIxXCI6XCJnXCIsXCJcXHUwMUU3XCI6XCJnXCIsXCJcXHUwMTIzXCI6XCJnXCIsXCJcXHUwMUU1XCI6XCJnXCIsXCJcXHUwMjYwXCI6XCJnXCIsXCJcXHVBN0ExXCI6XCJnXCIsXCJcXHUxRDc5XCI6XCJnXCIsXCJcXHVBNzdGXCI6XCJnXCIsXCJcXHUyNEQ3XCI6XCJoXCIsXCJcXHVGRjQ4XCI6XCJoXCIsXCJcXHUwMTI1XCI6XCJoXCIsXCJcXHUxRTIzXCI6XCJoXCIsXCJcXHUxRTI3XCI6XCJoXCIsXCJcXHUwMjFGXCI6XCJoXCIsXCJcXHUxRTI1XCI6XCJoXCIsXCJcXHUxRTI5XCI6XCJoXCIsXCJcXHUxRTJCXCI6XCJoXCIsXCJcXHUxRTk2XCI6XCJoXCIsXCJcXHUwMTI3XCI6XCJoXCIsXCJcXHUyQzY4XCI6XCJoXCIsXCJcXHUyQzc2XCI6XCJoXCIsXCJcXHUwMjY1XCI6XCJoXCIsXCJcXHUwMTk1XCI6XCJodlwiLFwiXFx1MjREOFwiOlwiaVwiLFwiXFx1RkY0OVwiOlwiaVwiLFwiXFx1MDBFQ1wiOlwiaVwiLFwiXFx1MDBFRFwiOlwiaVwiLFwiXFx1MDBFRVwiOlwiaVwiLFwiXFx1MDEyOVwiOlwiaVwiLFwiXFx1MDEyQlwiOlwiaVwiLFwiXFx1MDEyRFwiOlwiaVwiLFwiXFx1MDBFRlwiOlwiaVwiLFwiXFx1MUUyRlwiOlwiaVwiLFwiXFx1MUVDOVwiOlwiaVwiLFwiXFx1MDFEMFwiOlwiaVwiLFwiXFx1MDIwOVwiOlwiaVwiLFwiXFx1MDIwQlwiOlwiaVwiLFwiXFx1MUVDQlwiOlwiaVwiLFwiXFx1MDEyRlwiOlwiaVwiLFwiXFx1MUUyRFwiOlwiaVwiLFwiXFx1MDI2OFwiOlwiaVwiLFwiXFx1MDEzMVwiOlwiaVwiLFwiXFx1MjREOVwiOlwialwiLFwiXFx1RkY0QVwiOlwialwiLFwiXFx1MDEzNVwiOlwialwiLFwiXFx1MDFGMFwiOlwialwiLFwiXFx1MDI0OVwiOlwialwiLFwiXFx1MjREQVwiOlwia1wiLFwiXFx1RkY0QlwiOlwia1wiLFwiXFx1MUUzMVwiOlwia1wiLFwiXFx1MDFFOVwiOlwia1wiLFwiXFx1MUUzM1wiOlwia1wiLFwiXFx1MDEzN1wiOlwia1wiLFwiXFx1MUUzNVwiOlwia1wiLFwiXFx1MDE5OVwiOlwia1wiLFwiXFx1MkM2QVwiOlwia1wiLFwiXFx1QTc0MVwiOlwia1wiLFwiXFx1QTc0M1wiOlwia1wiLFwiXFx1QTc0NVwiOlwia1wiLFwiXFx1QTdBM1wiOlwia1wiLFwiXFx1MjREQlwiOlwibFwiLFwiXFx1RkY0Q1wiOlwibFwiLFwiXFx1MDE0MFwiOlwibFwiLFwiXFx1MDEzQVwiOlwibFwiLFwiXFx1MDEzRVwiOlwibFwiLFwiXFx1MUUzN1wiOlwibFwiLFwiXFx1MUUzOVwiOlwibFwiLFwiXFx1MDEzQ1wiOlwibFwiLFwiXFx1MUUzRFwiOlwibFwiLFwiXFx1MUUzQlwiOlwibFwiLFwiXFx1MDE3RlwiOlwibFwiLFwiXFx1MDE0MlwiOlwibFwiLFwiXFx1MDE5QVwiOlwibFwiLFwiXFx1MDI2QlwiOlwibFwiLFwiXFx1MkM2MVwiOlwibFwiLFwiXFx1QTc0OVwiOlwibFwiLFwiXFx1QTc4MVwiOlwibFwiLFwiXFx1QTc0N1wiOlwibFwiLFwiXFx1MDFDOVwiOlwibGpcIixcIlxcdTI0RENcIjpcIm1cIixcIlxcdUZGNERcIjpcIm1cIixcIlxcdTFFM0ZcIjpcIm1cIixcIlxcdTFFNDFcIjpcIm1cIixcIlxcdTFFNDNcIjpcIm1cIixcIlxcdTAyNzFcIjpcIm1cIixcIlxcdTAyNkZcIjpcIm1cIixcIlxcdTI0RERcIjpcIm5cIixcIlxcdUZGNEVcIjpcIm5cIixcIlxcdTAxRjlcIjpcIm5cIixcIlxcdTAxNDRcIjpcIm5cIixcIlxcdTAwRjFcIjpcIm5cIixcIlxcdTFFNDVcIjpcIm5cIixcIlxcdTAxNDhcIjpcIm5cIixcIlxcdTFFNDdcIjpcIm5cIixcIlxcdTAxNDZcIjpcIm5cIixcIlxcdTFFNEJcIjpcIm5cIixcIlxcdTFFNDlcIjpcIm5cIixcIlxcdTAxOUVcIjpcIm5cIixcIlxcdTAyNzJcIjpcIm5cIixcIlxcdTAxNDlcIjpcIm5cIixcIlxcdUE3OTFcIjpcIm5cIixcIlxcdUE3QTVcIjpcIm5cIixcIlxcdTAxQ0NcIjpcIm5qXCIsXCJcXHUyNERFXCI6XCJvXCIsXCJcXHVGRjRGXCI6XCJvXCIsXCJcXHUwMEYyXCI6XCJvXCIsXCJcXHUwMEYzXCI6XCJvXCIsXCJcXHUwMEY0XCI6XCJvXCIsXCJcXHUxRUQzXCI6XCJvXCIsXCJcXHUxRUQxXCI6XCJvXCIsXCJcXHUxRUQ3XCI6XCJvXCIsXCJcXHUxRUQ1XCI6XCJvXCIsXCJcXHUwMEY1XCI6XCJvXCIsXCJcXHUxRTREXCI6XCJvXCIsXCJcXHUwMjJEXCI6XCJvXCIsXCJcXHUxRTRGXCI6XCJvXCIsXCJcXHUwMTREXCI6XCJvXCIsXCJcXHUxRTUxXCI6XCJvXCIsXCJcXHUxRTUzXCI6XCJvXCIsXCJcXHUwMTRGXCI6XCJvXCIsXCJcXHUwMjJGXCI6XCJvXCIsXCJcXHUwMjMxXCI6XCJvXCIsXCJcXHUwMEY2XCI6XCJvXCIsXCJcXHUwMjJCXCI6XCJvXCIsXCJcXHUxRUNGXCI6XCJvXCIsXCJcXHUwMTUxXCI6XCJvXCIsXCJcXHUwMUQyXCI6XCJvXCIsXCJcXHUwMjBEXCI6XCJvXCIsXCJcXHUwMjBGXCI6XCJvXCIsXCJcXHUwMUExXCI6XCJvXCIsXCJcXHUxRUREXCI6XCJvXCIsXCJcXHUxRURCXCI6XCJvXCIsXCJcXHUxRUUxXCI6XCJvXCIsXCJcXHUxRURGXCI6XCJvXCIsXCJcXHUxRUUzXCI6XCJvXCIsXCJcXHUxRUNEXCI6XCJvXCIsXCJcXHUxRUQ5XCI6XCJvXCIsXCJcXHUwMUVCXCI6XCJvXCIsXCJcXHUwMUVEXCI6XCJvXCIsXCJcXHUwMEY4XCI6XCJvXCIsXCJcXHUwMUZGXCI6XCJvXCIsXCJcXHUwMjU0XCI6XCJvXCIsXCJcXHVBNzRCXCI6XCJvXCIsXCJcXHVBNzREXCI6XCJvXCIsXCJcXHUwMjc1XCI6XCJvXCIsXCJcXHUwMUEzXCI6XCJvaVwiLFwiXFx1MDIyM1wiOlwib3VcIixcIlxcdUE3NEZcIjpcIm9vXCIsXCJcXHUyNERGXCI6XCJwXCIsXCJcXHVGRjUwXCI6XCJwXCIsXCJcXHUxRTU1XCI6XCJwXCIsXCJcXHUxRTU3XCI6XCJwXCIsXCJcXHUwMUE1XCI6XCJwXCIsXCJcXHUxRDdEXCI6XCJwXCIsXCJcXHVBNzUxXCI6XCJwXCIsXCJcXHVBNzUzXCI6XCJwXCIsXCJcXHVBNzU1XCI6XCJwXCIsXCJcXHUyNEUwXCI6XCJxXCIsXCJcXHVGRjUxXCI6XCJxXCIsXCJcXHUwMjRCXCI6XCJxXCIsXCJcXHVBNzU3XCI6XCJxXCIsXCJcXHVBNzU5XCI6XCJxXCIsXCJcXHUyNEUxXCI6XCJyXCIsXCJcXHVGRjUyXCI6XCJyXCIsXCJcXHUwMTU1XCI6XCJyXCIsXCJcXHUxRTU5XCI6XCJyXCIsXCJcXHUwMTU5XCI6XCJyXCIsXCJcXHUwMjExXCI6XCJyXCIsXCJcXHUwMjEzXCI6XCJyXCIsXCJcXHUxRTVCXCI6XCJyXCIsXCJcXHUxRTVEXCI6XCJyXCIsXCJcXHUwMTU3XCI6XCJyXCIsXCJcXHUxRTVGXCI6XCJyXCIsXCJcXHUwMjREXCI6XCJyXCIsXCJcXHUwMjdEXCI6XCJyXCIsXCJcXHVBNzVCXCI6XCJyXCIsXCJcXHVBN0E3XCI6XCJyXCIsXCJcXHVBNzgzXCI6XCJyXCIsXCJcXHUyNEUyXCI6XCJzXCIsXCJcXHVGRjUzXCI6XCJzXCIsXCJcXHUwMERGXCI6XCJzXCIsXCJcXHUwMTVCXCI6XCJzXCIsXCJcXHUxRTY1XCI6XCJzXCIsXCJcXHUwMTVEXCI6XCJzXCIsXCJcXHUxRTYxXCI6XCJzXCIsXCJcXHUwMTYxXCI6XCJzXCIsXCJcXHUxRTY3XCI6XCJzXCIsXCJcXHUxRTYzXCI6XCJzXCIsXCJcXHUxRTY5XCI6XCJzXCIsXCJcXHUwMjE5XCI6XCJzXCIsXCJcXHUwMTVGXCI6XCJzXCIsXCJcXHUwMjNGXCI6XCJzXCIsXCJcXHVBN0E5XCI6XCJzXCIsXCJcXHVBNzg1XCI6XCJzXCIsXCJcXHUxRTlCXCI6XCJzXCIsXCJcXHUyNEUzXCI6XCJ0XCIsXCJcXHVGRjU0XCI6XCJ0XCIsXCJcXHUxRTZCXCI6XCJ0XCIsXCJcXHUxRTk3XCI6XCJ0XCIsXCJcXHUwMTY1XCI6XCJ0XCIsXCJcXHUxRTZEXCI6XCJ0XCIsXCJcXHUwMjFCXCI6XCJ0XCIsXCJcXHUwMTYzXCI6XCJ0XCIsXCJcXHUxRTcxXCI6XCJ0XCIsXCJcXHUxRTZGXCI6XCJ0XCIsXCJcXHUwMTY3XCI6XCJ0XCIsXCJcXHUwMUFEXCI6XCJ0XCIsXCJcXHUwMjg4XCI6XCJ0XCIsXCJcXHUyQzY2XCI6XCJ0XCIsXCJcXHVBNzg3XCI6XCJ0XCIsXCJcXHVBNzI5XCI6XCJ0elwiLFwiXFx1MjRFNFwiOlwidVwiLFwiXFx1RkY1NVwiOlwidVwiLFwiXFx1MDBGOVwiOlwidVwiLFwiXFx1MDBGQVwiOlwidVwiLFwiXFx1MDBGQlwiOlwidVwiLFwiXFx1MDE2OVwiOlwidVwiLFwiXFx1MUU3OVwiOlwidVwiLFwiXFx1MDE2QlwiOlwidVwiLFwiXFx1MUU3QlwiOlwidVwiLFwiXFx1MDE2RFwiOlwidVwiLFwiXFx1MDBGQ1wiOlwidVwiLFwiXFx1MDFEQ1wiOlwidVwiLFwiXFx1MDFEOFwiOlwidVwiLFwiXFx1MDFENlwiOlwidVwiLFwiXFx1MDFEQVwiOlwidVwiLFwiXFx1MUVFN1wiOlwidVwiLFwiXFx1MDE2RlwiOlwidVwiLFwiXFx1MDE3MVwiOlwidVwiLFwiXFx1MDFENFwiOlwidVwiLFwiXFx1MDIxNVwiOlwidVwiLFwiXFx1MDIxN1wiOlwidVwiLFwiXFx1MDFCMFwiOlwidVwiLFwiXFx1MUVFQlwiOlwidVwiLFwiXFx1MUVFOVwiOlwidVwiLFwiXFx1MUVFRlwiOlwidVwiLFwiXFx1MUVFRFwiOlwidVwiLFwiXFx1MUVGMVwiOlwidVwiLFwiXFx1MUVFNVwiOlwidVwiLFwiXFx1MUU3M1wiOlwidVwiLFwiXFx1MDE3M1wiOlwidVwiLFwiXFx1MUU3N1wiOlwidVwiLFwiXFx1MUU3NVwiOlwidVwiLFwiXFx1MDI4OVwiOlwidVwiLFwiXFx1MjRFNVwiOlwidlwiLFwiXFx1RkY1NlwiOlwidlwiLFwiXFx1MUU3RFwiOlwidlwiLFwiXFx1MUU3RlwiOlwidlwiLFwiXFx1MDI4QlwiOlwidlwiLFwiXFx1QTc1RlwiOlwidlwiLFwiXFx1MDI4Q1wiOlwidlwiLFwiXFx1QTc2MVwiOlwidnlcIixcIlxcdTI0RTZcIjpcIndcIixcIlxcdUZGNTdcIjpcIndcIixcIlxcdTFFODFcIjpcIndcIixcIlxcdTFFODNcIjpcIndcIixcIlxcdTAxNzVcIjpcIndcIixcIlxcdTFFODdcIjpcIndcIixcIlxcdTFFODVcIjpcIndcIixcIlxcdTFFOThcIjpcIndcIixcIlxcdTFFODlcIjpcIndcIixcIlxcdTJDNzNcIjpcIndcIixcIlxcdTI0RTdcIjpcInhcIixcIlxcdUZGNThcIjpcInhcIixcIlxcdTFFOEJcIjpcInhcIixcIlxcdTFFOERcIjpcInhcIixcIlxcdTI0RThcIjpcInlcIixcIlxcdUZGNTlcIjpcInlcIixcIlxcdTFFRjNcIjpcInlcIixcIlxcdTAwRkRcIjpcInlcIixcIlxcdTAxNzdcIjpcInlcIixcIlxcdTFFRjlcIjpcInlcIixcIlxcdTAyMzNcIjpcInlcIixcIlxcdTFFOEZcIjpcInlcIixcIlxcdTAwRkZcIjpcInlcIixcIlxcdTFFRjdcIjpcInlcIixcIlxcdTFFOTlcIjpcInlcIixcIlxcdTFFRjVcIjpcInlcIixcIlxcdTAxQjRcIjpcInlcIixcIlxcdTAyNEZcIjpcInlcIixcIlxcdTFFRkZcIjpcInlcIixcIlxcdTI0RTlcIjpcInpcIixcIlxcdUZGNUFcIjpcInpcIixcIlxcdTAxN0FcIjpcInpcIixcIlxcdTFFOTFcIjpcInpcIixcIlxcdTAxN0NcIjpcInpcIixcIlxcdTAxN0VcIjpcInpcIixcIlxcdTFFOTNcIjpcInpcIixcIlxcdTFFOTVcIjpcInpcIixcIlxcdTAxQjZcIjpcInpcIixcIlxcdTAyMjVcIjpcInpcIixcIlxcdTAyNDBcIjpcInpcIixcIlxcdTJDNkNcIjpcInpcIixcIlxcdUE3NjNcIjpcInpcIixcIlxcdTAzODZcIjpcIlxcdTAzOTFcIixcIlxcdTAzODhcIjpcIlxcdTAzOTVcIixcIlxcdTAzODlcIjpcIlxcdTAzOTdcIixcIlxcdTAzOEFcIjpcIlxcdTAzOTlcIixcIlxcdTAzQUFcIjpcIlxcdTAzOTlcIixcIlxcdTAzOENcIjpcIlxcdTAzOUZcIixcIlxcdTAzOEVcIjpcIlxcdTAzQTVcIixcIlxcdTAzQUJcIjpcIlxcdTAzQTVcIixcIlxcdTAzOEZcIjpcIlxcdTAzQTlcIixcIlxcdTAzQUNcIjpcIlxcdTAzQjFcIixcIlxcdTAzQURcIjpcIlxcdTAzQjVcIixcIlxcdTAzQUVcIjpcIlxcdTAzQjdcIixcIlxcdTAzQUZcIjpcIlxcdTAzQjlcIixcIlxcdTAzQ0FcIjpcIlxcdTAzQjlcIixcIlxcdTAzOTBcIjpcIlxcdTAzQjlcIixcIlxcdTAzQ0NcIjpcIlxcdTAzQkZcIixcIlxcdTAzQ0RcIjpcIlxcdTAzQzVcIixcIlxcdTAzQ0JcIjpcIlxcdTAzQzVcIixcIlxcdTAzQjBcIjpcIlxcdTAzQzVcIixcIlxcdTAzQzlcIjpcIlxcdTAzQzlcIixcIlxcdTAzQzJcIjpcIlxcdTAzQzNcIn07XG5cbiAgICAkZG9jdW1lbnQgPSAkKGRvY3VtZW50KTtcblxuICAgIG5leHRVaWQ9KGZ1bmN0aW9uKCkgeyB2YXIgY291bnRlcj0xOyByZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiBjb3VudGVyKys7IH07IH0oKSk7XG5cblxuICAgIGZ1bmN0aW9uIHJlaW5zZXJ0RWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIHZhciBwbGFjZWhvbGRlciA9ICQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpKTtcblxuICAgICAgICBlbGVtZW50LmJlZm9yZShwbGFjZWhvbGRlcik7XG4gICAgICAgIHBsYWNlaG9sZGVyLmJlZm9yZShlbGVtZW50KTtcbiAgICAgICAgcGxhY2Vob2xkZXIucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RyaXBEaWFjcml0aWNzKHN0cikge1xuICAgICAgICAvLyBVc2VkICd1bmkgcmFuZ2UgKyBuYW1lZCBmdW5jdGlvbicgZnJvbSBodHRwOi8vanNwZXJmLmNvbS9kaWFjcml0aWNzLzE4XG4gICAgICAgIGZ1bmN0aW9uIG1hdGNoKGEpIHtcbiAgICAgICAgICAgIHJldHVybiBESUFDUklUSUNTW2FdIHx8IGE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1teXFx1MDAwMC1cXHUwMDdFXS9nLCBtYXRjaCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5kZXhPZih2YWx1ZSwgYXJyYXkpIHtcbiAgICAgICAgdmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICBmb3IgKDsgaSA8IGw7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgaWYgKGVxdWFsKHZhbHVlLCBhcnJheVtpXSkpIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZWFzdXJlU2Nyb2xsYmFyICgpIHtcbiAgICAgICAgdmFyICR0ZW1wbGF0ZSA9ICQoIE1FQVNVUkVfU0NST0xMQkFSX1RFTVBMQVRFICk7XG4gICAgICAgICR0ZW1wbGF0ZS5hcHBlbmRUbyhkb2N1bWVudC5ib2R5KTtcblxuICAgICAgICB2YXIgZGltID0ge1xuICAgICAgICAgICAgd2lkdGg6ICR0ZW1wbGF0ZS53aWR0aCgpIC0gJHRlbXBsYXRlWzBdLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiAkdGVtcGxhdGUuaGVpZ2h0KCkgLSAkdGVtcGxhdGVbMF0uY2xpZW50SGVpZ2h0XG4gICAgICAgIH07XG4gICAgICAgICR0ZW1wbGF0ZS5yZW1vdmUoKTtcblxuICAgICAgICByZXR1cm4gZGltO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXBhcmVzIGVxdWFsaXR5IG9mIGEgYW5kIGJcbiAgICAgKiBAcGFyYW0gYVxuICAgICAqIEBwYXJhbSBiXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWwoYSwgYikge1xuICAgICAgICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChhID09PSB1bmRlZmluZWQgfHwgYiA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChhID09PSBudWxsIHx8IGIgPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciAnYScgb3IgJ2InIGlzIGEgc3RyaW5nIChwcmltaXRpdmUgb3Igb2JqZWN0KS5cbiAgICAgICAgLy8gVGhlIGNvbmNhdGVuYXRpb24gb2YgYW4gZW1wdHkgc3RyaW5nICgrJycpIGNvbnZlcnRzIGl0cyBhcmd1bWVudCB0byBhIHN0cmluZydzIHByaW1pdGl2ZS5cbiAgICAgICAgaWYgKGEuY29uc3RydWN0b3IgPT09IFN0cmluZykgcmV0dXJuIGErJycgPT09IGIrJyc7IC8vIGErJycgLSBpbiBjYXNlICdhJyBpcyBhIFN0cmluZyBvYmplY3RcbiAgICAgICAgaWYgKGIuY29uc3RydWN0b3IgPT09IFN0cmluZykgcmV0dXJuIGIrJycgPT09IGErJyc7IC8vIGIrJycgLSBpbiBjYXNlICdiJyBpcyBhIFN0cmluZyBvYmplY3RcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNwbGl0cyB0aGUgc3RyaW5nIGludG8gYW4gYXJyYXkgb2YgdmFsdWVzLCB0cmFuc2Zvcm1pbmcgZWFjaCB2YWx1ZS4gQW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWQgZm9yIG51bGxzIG9yIGVtcHR5XG4gICAgICogc3RyaW5nc1xuICAgICAqIEBwYXJhbSBzdHJpbmdcbiAgICAgKiBAcGFyYW0gc2VwYXJhdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3BsaXRWYWwoc3RyaW5nLCBzZXBhcmF0b3IsIHRyYW5zZm9ybSkge1xuICAgICAgICB2YXIgdmFsLCBpLCBsO1xuICAgICAgICBpZiAoc3RyaW5nID09PSBudWxsIHx8IHN0cmluZy5sZW5ndGggPCAxKSByZXR1cm4gW107XG4gICAgICAgIHZhbCA9IHN0cmluZy5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gdmFsLmxlbmd0aDsgaSA8IGw7IGkgPSBpICsgMSkgdmFsW2ldID0gdHJhbnNmb3JtKHZhbFtpXSk7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2lkZUJvcmRlclBhZGRpbmcoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudC5vdXRlcldpZHRoKGZhbHNlKSAtIGVsZW1lbnQud2lkdGgoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsS2V5VXBDaGFuZ2VFdmVudChlbGVtZW50KSB7XG4gICAgICAgIHZhciBrZXk9XCJrZXl1cC1jaGFuZ2UtdmFsdWVcIjtcbiAgICAgICAgZWxlbWVudC5vbihcImtleWRvd25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCQuZGF0YShlbGVtZW50LCBrZXkpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAkLmRhdGEoZWxlbWVudCwga2V5LCBlbGVtZW50LnZhbCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGVsZW1lbnQub24oXCJrZXl1cFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmFsPSAkLmRhdGEoZWxlbWVudCwga2V5KTtcbiAgICAgICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCAmJiBlbGVtZW50LnZhbCgpICE9PSB2YWwpIHtcbiAgICAgICAgICAgICAgICAkLnJlbW92ZURhdGEoZWxlbWVudCwga2V5KTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnRyaWdnZXIoXCJrZXl1cC1jaGFuZ2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogZmlsdGVycyBtb3VzZSBldmVudHMgc28gYW4gZXZlbnQgaXMgZmlyZWQgb25seSBpZiB0aGUgbW91c2UgbW92ZWQuXG4gICAgICpcbiAgICAgKiBmaWx0ZXJzIG91dCBtb3VzZSBldmVudHMgdGhhdCBvY2N1ciB3aGVuIG1vdXNlIGlzIHN0YXRpb25hcnkgYnV0XG4gICAgICogdGhlIGVsZW1lbnRzIHVuZGVyIHRoZSBwb2ludGVyIGFyZSBzY3JvbGxlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnN0YWxsRmlsdGVyZWRNb3VzZU1vdmUoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50Lm9uKFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgbGFzdHBvcyA9IGxhc3RNb3VzZVBvc2l0aW9uO1xuICAgICAgICAgICAgaWYgKGxhc3Rwb3MgPT09IHVuZGVmaW5lZCB8fCBsYXN0cG9zLnggIT09IGUucGFnZVggfHwgbGFzdHBvcy55ICE9PSBlLnBhZ2VZKSB7XG4gICAgICAgICAgICAgICAgJChlLnRhcmdldCkudHJpZ2dlcihcIm1vdXNlbW92ZS1maWx0ZXJlZFwiLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVib3VuY2VzIGEgZnVuY3Rpb24uIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNhbGxzIHRoZSBvcmlnaW5hbCBmbiBmdW5jdGlvbiBvbmx5IGlmIG5vIGludm9jYXRpb25zIGhhdmUgYmVlbiBtYWRlXG4gICAgICogd2l0aGluIHRoZSBsYXN0IHF1aWV0TWlsbGlzIG1pbGxpc2Vjb25kcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBxdWlldE1pbGxpcyBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIGludm9raW5nIGZuXG4gICAgICogQHBhcmFtIGZuIGZ1bmN0aW9uIHRvIGJlIGRlYm91bmNlZFxuICAgICAqIEBwYXJhbSBjdHggb2JqZWN0IHRvIGJlIHVzZWQgYXMgdGhpcyByZWZlcmVuY2Ugd2l0aGluIGZuXG4gICAgICogQHJldHVybiBkZWJvdW5jZWQgdmVyc2lvbiBvZiBmblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlYm91bmNlKHF1aWV0TWlsbGlzLCBmbiwgY3R4KSB7XG4gICAgICAgIGN0eCA9IGN0eCB8fCB1bmRlZmluZWQ7XG4gICAgICAgIHZhciB0aW1lb3V0O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGZuLmFwcGx5KGN0eCwgYXJncyk7XG4gICAgICAgICAgICB9LCBxdWlldE1pbGxpcyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbERlYm91bmNlZFNjcm9sbCh0aHJlc2hvbGQsIGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIG5vdGlmeSA9IGRlYm91bmNlKHRocmVzaG9sZCwgZnVuY3Rpb24gKGUpIHsgZWxlbWVudC50cmlnZ2VyKFwic2Nyb2xsLWRlYm91bmNlZFwiLCBlKTt9KTtcbiAgICAgICAgZWxlbWVudC5vbihcInNjcm9sbFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGluZGV4T2YoZS50YXJnZXQsIGVsZW1lbnQuZ2V0KCkpID49IDApIG5vdGlmeShlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9jdXMoJGVsKSB7XG4gICAgICAgIGlmICgkZWxbMF0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHJldHVybjtcblxuICAgICAgICAvKiBzZXQgdGhlIGZvY3VzIGluIGEgMCB0aW1lb3V0IC0gdGhhdCB3YXkgdGhlIGZvY3VzIGlzIHNldCBhZnRlciB0aGUgcHJvY2Vzc2luZ1xuICAgICAgICAgICAgb2YgdGhlIGN1cnJlbnQgZXZlbnQgaGFzIGZpbmlzaGVkIC0gd2hpY2ggc2VlbXMgbGlrZSB0aGUgb25seSByZWxpYWJsZSB3YXlcbiAgICAgICAgICAgIHRvIHNldCBmb2N1cyAqL1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBlbD0kZWxbMF0sIHBvcz0kZWwudmFsKCkubGVuZ3RoLCByYW5nZTtcblxuICAgICAgICAgICAgJGVsLmZvY3VzKCk7XG5cbiAgICAgICAgICAgIC8qIG1ha2Ugc3VyZSBlbCByZWNlaXZlZCBmb2N1cyBzbyB3ZSBkbyBub3QgZXJyb3Igb3V0IHdoZW4gdHJ5aW5nIHRvIG1hbmlwdWxhdGUgdGhlIGNhcmV0LlxuICAgICAgICAgICAgICAgIHNvbWV0aW1lcyBtb2RhbHMgb3Igb3RoZXJzIGxpc3RlbmVycyBtYXkgc3RlYWwgaXQgYWZ0ZXIgaXRzIHNldCAqL1xuICAgICAgICAgICAgdmFyIGlzVmlzaWJsZSA9IChlbC5vZmZzZXRXaWR0aCA+IDAgfHwgZWwub2Zmc2V0SGVpZ2h0ID4gMCk7XG4gICAgICAgICAgICBpZiAoaXNWaXNpYmxlICYmIGVsID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG5cbiAgICAgICAgICAgICAgICAvKiBhZnRlciB0aGUgZm9jdXMgaXMgc2V0IG1vdmUgdGhlIGNhcmV0IHRvIHRoZSBlbmQsIG5lY2Vzc2FyeSB3aGVuIHdlIHZhbCgpXG4gICAgICAgICAgICAgICAgICAgIGp1c3QgYmVmb3JlIHNldHRpbmcgZm9jdXMgKi9cbiAgICAgICAgICAgICAgICBpZihlbC5zZXRTZWxlY3Rpb25SYW5nZSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnNldFNlbGVjdGlvblJhbmdlKHBvcywgcG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZWwuY3JlYXRlVGV4dFJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gZWwuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDdXJzb3JJbmZvKGVsKSB7XG4gICAgICAgIGVsID0gJChlbClbMF07XG4gICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICAgICAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gZWwpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IGVsLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgICAgbGVuZ3RoID0gZWwuc2VsZWN0aW9uRW5kIC0gb2Zmc2V0O1xuICAgICAgICB9IGVsc2UgaWYgKCdzZWxlY3Rpb24nIGluIGRvY3VtZW50KSB7XG4gICAgICAgICAgICBlbC5mb2N1cygpO1xuICAgICAgICAgICAgdmFyIHNlbCA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgbGVuZ3RoID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCkudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBzZWwubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCAtZWwudmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgIG9mZnNldCA9IHNlbC50ZXh0Lmxlbmd0aCAtIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBvZmZzZXQ6IG9mZnNldCwgbGVuZ3RoOiBsZW5ndGggfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBraWxsRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGtpbGxFdmVudEltbWVkaWF0ZWx5KGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lYXN1cmVUZXh0V2lkdGgoZSkge1xuICAgICAgICBpZiAoIXNpemVyKXtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGVbMF0uY3VycmVudFN0eWxlIHx8IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVbMF0sIG51bGwpO1xuICAgICAgICAgICAgc2l6ZXIgPSAkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpLmNzcyh7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgICAgICBsZWZ0OiBcIi0xMDAwMHB4XCIsXG4gICAgICAgICAgICAgICAgdG9wOiBcIi0xMDAwMHB4XCIsXG4gICAgICAgICAgICAgICAgZGlzcGxheTogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IHN0eWxlLmZvbnRTaXplLFxuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6IHN0eWxlLmZvbnRGYW1pbHksXG4gICAgICAgICAgICAgICAgZm9udFN0eWxlOiBzdHlsZS5mb250U3R5bGUsXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogc3R5bGUuZm9udFdlaWdodCxcbiAgICAgICAgICAgICAgICBsZXR0ZXJTcGFjaW5nOiBzdHlsZS5sZXR0ZXJTcGFjaW5nLFxuICAgICAgICAgICAgICAgIHRleHRUcmFuc2Zvcm06IHN0eWxlLnRleHRUcmFuc2Zvcm0sXG4gICAgICAgICAgICAgICAgd2hpdGVTcGFjZTogXCJub3dyYXBcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzaXplci5hdHRyKFwiY2xhc3NcIixcInNlbGVjdDItc2l6ZXJcIik7XG4gICAgICAgICAgICAkKGRvY3VtZW50LmJvZHkpLmFwcGVuZChzaXplcik7XG4gICAgICAgIH1cbiAgICAgICAgc2l6ZXIudGV4dChlLnZhbCgpKTtcbiAgICAgICAgcmV0dXJuIHNpemVyLndpZHRoKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3luY0Nzc0NsYXNzZXMoZGVzdCwgc3JjLCBhZGFwdGVyKSB7XG4gICAgICAgIHZhciBjbGFzc2VzLCByZXBsYWNlbWVudHMgPSBbXSwgYWRhcHRlZDtcblxuICAgICAgICBjbGFzc2VzID0gJC50cmltKGRlc3QuYXR0cihcImNsYXNzXCIpKTtcblxuICAgICAgICBpZiAoY2xhc3Nlcykge1xuICAgICAgICAgICAgY2xhc3NlcyA9ICcnICsgY2xhc3NlczsgLy8gZm9yIElFIHdoaWNoIHJldHVybnMgb2JqZWN0XG5cbiAgICAgICAgICAgICQoY2xhc3Nlcy5zcGxpdCgvXFxzKy8pKS5lYWNoMihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmRleE9mKFwic2VsZWN0Mi1cIikgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnRzLnB1c2godGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjbGFzc2VzID0gJC50cmltKHNyYy5hdHRyKFwiY2xhc3NcIikpO1xuXG4gICAgICAgIGlmIChjbGFzc2VzKSB7XG4gICAgICAgICAgICBjbGFzc2VzID0gJycgKyBjbGFzc2VzOyAvLyBmb3IgSUUgd2hpY2ggcmV0dXJucyBvYmplY3RcblxuICAgICAgICAgICAgJChjbGFzc2VzLnNwbGl0KC9cXHMrLykpLmVhY2gyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZGV4T2YoXCJzZWxlY3QyLVwiKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBhZGFwdGVkID0gYWRhcHRlcih0aGlzKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoYWRhcHRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnRzLnB1c2goYWRhcHRlZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlc3QuYXR0cihcImNsYXNzXCIsIHJlcGxhY2VtZW50cy5qb2luKFwiIFwiKSk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBtYXJrTWF0Y2godGV4dCwgdGVybSwgbWFya3VwLCBlc2NhcGVNYXJrdXApIHtcbiAgICAgICAgdmFyIG1hdGNoPXN0cmlwRGlhY3JpdGljcyh0ZXh0LnRvVXBwZXJDYXNlKCkpLmluZGV4T2Yoc3RyaXBEaWFjcml0aWNzKHRlcm0udG9VcHBlckNhc2UoKSkpLFxuICAgICAgICAgICAgdGw9dGVybS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKG1hdGNoPDApIHtcbiAgICAgICAgICAgIG1hcmt1cC5wdXNoKGVzY2FwZU1hcmt1cCh0ZXh0KSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBtYXJrdXAucHVzaChlc2NhcGVNYXJrdXAodGV4dC5zdWJzdHJpbmcoMCwgbWF0Y2gpKSk7XG4gICAgICAgIG1hcmt1cC5wdXNoKFwiPHNwYW4gY2xhc3M9J3NlbGVjdDItbWF0Y2gnPlwiKTtcbiAgICAgICAgbWFya3VwLnB1c2goZXNjYXBlTWFya3VwKHRleHQuc3Vic3RyaW5nKG1hdGNoLCBtYXRjaCArIHRsKSkpO1xuICAgICAgICBtYXJrdXAucHVzaChcIjwvc3Bhbj5cIik7XG4gICAgICAgIG1hcmt1cC5wdXNoKGVzY2FwZU1hcmt1cCh0ZXh0LnN1YnN0cmluZyhtYXRjaCArIHRsLCB0ZXh0Lmxlbmd0aCkpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0RXNjYXBlTWFya3VwKG1hcmt1cCkge1xuICAgICAgICB2YXIgcmVwbGFjZV9tYXAgPSB7XG4gICAgICAgICAgICAnXFxcXCc6ICcmIzkyOycsXG4gICAgICAgICAgICAnJic6ICcmYW1wOycsXG4gICAgICAgICAgICAnPCc6ICcmbHQ7JyxcbiAgICAgICAgICAgICc+JzogJyZndDsnLFxuICAgICAgICAgICAgJ1wiJzogJyZxdW90OycsXG4gICAgICAgICAgICBcIidcIjogJyYjMzk7JyxcbiAgICAgICAgICAgIFwiL1wiOiAnJiM0NzsnXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIFN0cmluZyhtYXJrdXApLnJlcGxhY2UoL1smPD5cIidcXC9cXFxcXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlX21hcFttYXRjaF07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGFuIGFqYXgtYmFzZWQgcXVlcnkgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIG9iamVjdCBjb250YWluaW5nIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLnBhcmFtcyBwYXJhbWV0ZXIgbWFwIGZvciB0aGUgdHJhbnNwb3J0IGFqYXggY2FsbCwgY2FuIGNvbnRhaW4gc3VjaCBvcHRpb25zIGFzIGNhY2hlLCBqc29ucENhbGxiYWNrLCBldGMuIHNlZSAkLmFqYXhcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50cmFuc3BvcnQgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIHVzZWQgdG8gZXhlY3V0ZSB0aGUgYWpheCByZXF1ZXN0LiBtdXN0IGJlIGNvbXBhdGlibGUgd2l0aCBwYXJhbWV0ZXJzIHN1cHBvcnRlZCBieSAkLmFqYXhcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy51cmwgdXJsIGZvciB0aGUgZGF0YVxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRhdGEgYSBmdW5jdGlvbihzZWFyY2hUZXJtLCBwYWdlTnVtYmVyLCBjb250ZXh0KSB0aGF0IHNob3VsZCByZXR1cm4gYW4gb2JqZWN0IGNvbnRhaW5pbmcgcXVlcnkgc3RyaW5nIHBhcmFtZXRlcnMgZm9yIHRoZSBhYm92ZSB1cmwuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZGF0YVR5cGUgcmVxdWVzdCBkYXRhIHR5cGU6IGFqYXgsIGpzb25wLCBvdGhlciBkYXRhdHlwZXMgc3VwcG9ydGVkIGJ5IGpRdWVyeSdzICQuYWpheCBmdW5jdGlvbiBvciB0aGUgdHJhbnNwb3J0IGZ1bmN0aW9uIGlmIHNwZWNpZmllZFxuICAgICAqIEBwYXJhbSBvcHRpb25zLnF1aWV0TWlsbGlzIChvcHRpb25hbCkgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIG1ha2luZyB0aGUgYWpheFJlcXVlc3QsIGhlbHBzIGRlYm91bmNlIHRoZSBhamF4IGZ1bmN0aW9uIGlmIGludm9rZWQgdG9vIG9mdGVuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucmVzdWx0cyBhIGZ1bmN0aW9uKHJlbW90ZURhdGEsIHBhZ2VOdW1iZXIsIHF1ZXJ5KSB0aGF0IGNvbnZlcnRzIGRhdGEgcmV0dXJuZWQgZm9ybSB0aGUgcmVtb3RlIHJlcXVlc3QgdG8gdGhlIGZvcm1hdCBleHBlY3RlZCBieSBTZWxlY3QyLlxuICAgICAqICAgICAgVGhlIGV4cGVjdGVkIGZvcm1hdCBpcyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIGtleXM6XG4gICAgICogICAgICByZXN1bHRzIGFycmF5IG9mIG9iamVjdHMgdGhhdCB3aWxsIGJlIHVzZWQgYXMgY2hvaWNlc1xuICAgICAqICAgICAgbW9yZSAob3B0aW9uYWwpIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZXJlIGFyZSBtb3JlIHJlc3VsdHMgYXZhaWxhYmxlXG4gICAgICogICAgICBFeGFtcGxlOiB7cmVzdWx0czpbe2lkOjEsIHRleHQ6J1JlZCd9LHtpZDoyLCB0ZXh0OidCbHVlJ31dLCBtb3JlOnRydWV9XG4gICAgICovXG4gICAgZnVuY3Rpb24gYWpheChvcHRpb25zKSB7XG4gICAgICAgIHZhciB0aW1lb3V0LCAvLyBjdXJyZW50IHNjaGVkdWxlZCBidXQgbm90IHlldCBleGVjdXRlZCByZXF1ZXN0XG4gICAgICAgICAgICBoYW5kbGVyID0gbnVsbCxcbiAgICAgICAgICAgIHF1aWV0TWlsbGlzID0gb3B0aW9ucy5xdWlldE1pbGxpcyB8fCAxMDAsXG4gICAgICAgICAgICBhamF4VXJsID0gb3B0aW9ucy51cmwsXG4gICAgICAgICAgICBzZWxmID0gdGhpcztcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IG9wdGlvbnMuZGF0YSwgLy8gYWpheCBkYXRhIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgIHVybCA9IGFqYXhVcmwsIC8vIGFqYXggdXJsIHN0cmluZyBvciBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQgPSBvcHRpb25zLnRyYW5zcG9ydCB8fCAkLmZuLnNlbGVjdDIuYWpheERlZmF1bHRzLnRyYW5zcG9ydCxcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVwcmVjYXRlZCAtIHRvIGJlIHJlbW92ZWQgaW4gNC4wICAtIHVzZSBwYXJhbXMgaW5zdGVhZFxuICAgICAgICAgICAgICAgICAgICBkZXByZWNhdGVkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogb3B0aW9ucy50eXBlIHx8ICdHRVQnLCAvLyBzZXQgdHlwZSBvZiByZXF1ZXN0IChHRVQgb3IgUE9TVClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlOiBvcHRpb25zLmNhY2hlIHx8IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAganNvbnBDYWxsYmFjazogb3B0aW9ucy5qc29ucENhbGxiYWNrfHx1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogb3B0aW9ucy5kYXRhVHlwZXx8XCJqc29uXCJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gJC5leHRlbmQoe30sICQuZm4uc2VsZWN0Mi5hamF4RGVmYXVsdHMucGFyYW1zLCBkZXByZWNhdGVkKTtcblxuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhID8gZGF0YS5jYWxsKHNlbGYsIHF1ZXJ5LnRlcm0sIHF1ZXJ5LnBhZ2UsIHF1ZXJ5LmNvbnRleHQpIDogbnVsbDtcbiAgICAgICAgICAgICAgICB1cmwgPSAodHlwZW9mIHVybCA9PT0gJ2Z1bmN0aW9uJykgPyB1cmwuY2FsbChzZWxmLCBxdWVyeS50ZXJtLCBxdWVyeS5wYWdlLCBxdWVyeS5jb250ZXh0KSA6IHVybDtcblxuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyICYmIHR5cGVvZiBoYW5kbGVyLmFib3J0ID09PSBcImZ1bmN0aW9uXCIpIHsgaGFuZGxlci5hYm9ydCgpOyB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCQuaXNGdW5jdGlvbihvcHRpb25zLnBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQuZXh0ZW5kKHBhcmFtcywgb3B0aW9ucy5wYXJhbXMuY2FsbChzZWxmKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkLmV4dGVuZChwYXJhbXMsIG9wdGlvbnMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICQuZXh0ZW5kKHBhcmFtcywge1xuICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGU6IG9wdGlvbnMuZGF0YVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIC0gcmVwbGFjZSBxdWVyeS5wYWdlIHdpdGggcXVlcnkgc28gdXNlcnMgaGF2ZSBhY2Nlc3MgdG8gdGVybSwgcGFnZSwgZXRjLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkZWQgcXVlcnkgYXMgdGhpcmQgcGFyYW10ZXIgdG8ga2VlcCBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBvcHRpb25zLnJlc3VsdHMoZGF0YSwgcXVlcnkucGFnZSwgcXVlcnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkuY2FsbGJhY2socmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbihqcVhIUiwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzRXJyb3I6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganFYSFI6IGpxWEhSLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRTdGF0dXM6IHRleHRTdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JUaHJvd246IGVycm9yVGhyb3duXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5jYWxsYmFjayhyZXN1bHRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSB0cmFuc3BvcnQuY2FsbChzZWxmLCBwYXJhbXMpO1xuICAgICAgICAgICAgfSwgcXVpZXRNaWxsaXMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGEgcXVlcnkgZnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIGEgbG9jYWwgYXJyYXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIG9iamVjdCBjb250YWluaW5nIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVycy4gVGhlIG9wdGlvbnMgcGFyYW1ldGVyIGNhbiBlaXRoZXIgYmUgYW4gYXJyYXkgb3IgYW5cbiAgICAgKiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgYXJyYXkgZm9ybSBpcyB1c2VkIGl0IGlzIGFzc3VtZWQgdGhhdCBpdCBjb250YWlucyBvYmplY3RzIHdpdGggJ2lkJyBhbmQgJ3RleHQnIGtleXMuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgb2JqZWN0IGZvcm0gaXMgdXNlZCBpdCBpcyBhc3N1bWVkIHRoYXQgaXQgY29udGFpbnMgJ2RhdGEnIGFuZCAndGV4dCcga2V5cy4gVGhlICdkYXRhJyBrZXkgc2hvdWxkIGNvbnRhaW5cbiAgICAgKiBhbiBhcnJheSBvZiBvYmplY3RzIHRoYXQgd2lsbCBiZSB1c2VkIGFzIGNob2ljZXMuIFRoZXNlIG9iamVjdHMgbXVzdCBjb250YWluIGF0IGxlYXN0IGFuICdpZCcga2V5LiBUaGUgJ3RleHQnXG4gICAgICoga2V5IGNhbiBlaXRoZXIgYmUgYSBTdHJpbmcgaW4gd2hpY2ggY2FzZSBpdCBpcyBleHBlY3RlZCB0aGF0IGVhY2ggZWxlbWVudCBpbiB0aGUgJ2RhdGEnIGFycmF5IGhhcyBhIGtleSB3aXRoIHRoZVxuICAgICAqIHZhbHVlIG9mICd0ZXh0JyB3aGljaCB3aWxsIGJlIHVzZWQgdG8gbWF0Y2ggY2hvaWNlcy4gQWx0ZXJuYXRpdmVseSwgdGV4dCBjYW4gYmUgYSBmdW5jdGlvbihpdGVtKSB0aGF0IGNhbiBleHRyYWN0XG4gICAgICogdGhlIHRleHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9jYWwob3B0aW9ucykge1xuICAgICAgICB2YXIgZGF0YSA9IG9wdGlvbnMsIC8vIGRhdGEgZWxlbWVudHNcbiAgICAgICAgICAgIGRhdGFUZXh0LFxuICAgICAgICAgICAgdG1wLFxuICAgICAgICAgICAgdGV4dCA9IGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBcIlwiK2l0ZW0udGV4dDsgfTsgLy8gZnVuY3Rpb24gdXNlZCB0byByZXRyaWV2ZSB0aGUgdGV4dCBwb3J0aW9uIG9mIGEgZGF0YSBpdGVtIHRoYXQgaXMgbWF0Y2hlZCBhZ2FpbnN0IHRoZSBzZWFyY2hcblxuICAgICAgICAgaWYgKCQuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgdG1wID0gZGF0YTtcbiAgICAgICAgICAgIGRhdGEgPSB7IHJlc3VsdHM6IHRtcCB9O1xuICAgICAgICB9XG5cbiAgICAgICAgIGlmICgkLmlzRnVuY3Rpb24oZGF0YSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0bXAgPSBkYXRhO1xuICAgICAgICAgICAgZGF0YSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdG1wOyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRhdGFJdGVtID0gZGF0YSgpO1xuICAgICAgICBpZiAoZGF0YUl0ZW0udGV4dCkge1xuICAgICAgICAgICAgdGV4dCA9IGRhdGFJdGVtLnRleHQ7XG4gICAgICAgICAgICAvLyBpZiB0ZXh0IGlzIG5vdCBhIGZ1bmN0aW9uIHdlIGFzc3VtZSBpdCB0byBiZSBhIGtleSBuYW1lXG4gICAgICAgICAgICBpZiAoISQuaXNGdW5jdGlvbih0ZXh0KSkge1xuICAgICAgICAgICAgICAgIGRhdGFUZXh0ID0gZGF0YUl0ZW0udGV4dDsgLy8gd2UgbmVlZCB0byBzdG9yZSB0aGlzIGluIGEgc2VwYXJhdGUgdmFyaWFibGUgYmVjYXVzZSBpbiB0aGUgbmV4dCBzdGVwIGRhdGEgZ2V0cyByZXNldCBhbmQgZGF0YS50ZXh0IGlzIG5vIGxvbmdlciBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW1bZGF0YVRleHRdOyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChxdWVyeSkge1xuICAgICAgICAgICAgdmFyIHQgPSBxdWVyeS50ZXJtLCBmaWx0ZXJlZCA9IHsgcmVzdWx0czogW10gfSwgcHJvY2VzcztcbiAgICAgICAgICAgIGlmICh0ID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgcXVlcnkuY2FsbGJhY2soZGF0YSgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByb2Nlc3MgPSBmdW5jdGlvbihkYXR1bSwgY29sbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBncm91cCwgYXR0cjtcbiAgICAgICAgICAgICAgICBkYXR1bSA9IGRhdHVtWzBdO1xuICAgICAgICAgICAgICAgIGlmIChkYXR1bS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICBncm91cCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGF0dHIgaW4gZGF0dW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXR1bS5oYXNPd25Qcm9wZXJ0eShhdHRyKSkgZ3JvdXBbYXR0cl09ZGF0dW1bYXR0cl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuY2hpbGRyZW49W107XG4gICAgICAgICAgICAgICAgICAgICQoZGF0dW0uY2hpbGRyZW4pLmVhY2gyKGZ1bmN0aW9uKGksIGNoaWxkRGF0dW0pIHsgcHJvY2VzcyhjaGlsZERhdHVtLCBncm91cC5jaGlsZHJlbik7IH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXAuY2hpbGRyZW4ubGVuZ3RoIHx8IHF1ZXJ5Lm1hdGNoZXIodCwgdGV4dChncm91cCksIGRhdHVtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbi5wdXNoKGdyb3VwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxdWVyeS5tYXRjaGVyKHQsIHRleHQoZGF0dW0pLCBkYXR1bSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24ucHVzaChkYXR1bSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAkKGRhdGEoKS5yZXN1bHRzKS5lYWNoMihmdW5jdGlvbihpLCBkYXR1bSkgeyBwcm9jZXNzKGRhdHVtLCBmaWx0ZXJlZC5yZXN1bHRzKTsgfSk7XG4gICAgICAgICAgICBxdWVyeS5jYWxsYmFjayhmaWx0ZXJlZCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gVE9ETyBqYXZhZG9jXG4gICAgZnVuY3Rpb24gdGFncyhkYXRhKSB7XG4gICAgICAgIHZhciBpc0Z1bmMgPSAkLmlzRnVuY3Rpb24oZGF0YSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgICAgIHZhciB0ID0gcXVlcnkudGVybSwgZmlsdGVyZWQgPSB7cmVzdWx0czogW119O1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGlzRnVuYyA/IGRhdGEocXVlcnkpIDogZGF0YTtcbiAgICAgICAgICAgIGlmICgkLmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICQocmVzdWx0KS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzT2JqZWN0ID0gdGhpcy50ZXh0ICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gaXNPYmplY3QgPyB0aGlzLnRleHQgOiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBpZiAodCA9PT0gXCJcIiB8fCBxdWVyeS5tYXRjaGVyKHQsIHRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZC5yZXN1bHRzLnB1c2goaXNPYmplY3QgPyB0aGlzIDoge2lkOiB0aGlzLCB0ZXh0OiB0aGlzfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBxdWVyeS5jYWxsYmFjayhmaWx0ZXJlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBmb3JtYXR0ZXIgZnVuY3Rpb24gc2hvdWxkIGJlIHVzZWQuXG4gICAgICpcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgaXQgaXMgbm90IGEgZnVuY3Rpb24uIFJldHVybnMgdHJ1ZSBpZiBpdCBzaG91bGQgYmUgdXNlZCxcbiAgICAgKiBmYWxzZSBpZiBubyBmb3JtYXR0aW5nIHNob3VsZCBiZSBwZXJmb3JtZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm9ybWF0dGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hlY2tGb3JtYXR0ZXIoZm9ybWF0dGVyLCBmb3JtYXR0ZXJOYW1lKSB7XG4gICAgICAgIGlmICgkLmlzRnVuY3Rpb24oZm9ybWF0dGVyKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICghZm9ybWF0dGVyKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2YoZm9ybWF0dGVyKSA9PT0gJ3N0cmluZycpIHJldHVybiB0cnVlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZm9ybWF0dGVyTmFtZSArXCIgbXVzdCBiZSBhIHN0cmluZywgZnVuY3Rpb24sIG9yIGZhbHN5IHZhbHVlXCIpO1xuICAgIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGdpdmVuIHZhbHVlXG4gICAqIElmIGdpdmVuIGEgZnVuY3Rpb24sIHJldHVybnMgaXRzIG91dHB1dFxuICAgKlxuICAgKiBAcGFyYW0gdmFsIHN0cmluZ3xmdW5jdGlvblxuICAgKiBAcGFyYW0gY29udGV4dCB2YWx1ZSBvZiBcInRoaXNcIiB0byBiZSBwYXNzZWQgdG8gZnVuY3Rpb25cbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICAgIGZ1bmN0aW9uIGV2YWx1YXRlKHZhbCwgY29udGV4dCkge1xuICAgICAgICBpZiAoJC5pc0Z1bmN0aW9uKHZhbCkpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICAgICAgICAgIHJldHVybiB2YWwuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb3VudFJlc3VsdHMocmVzdWx0cykge1xuICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAkLmVhY2gocmVzdWx0cywgZnVuY3Rpb24oaSwgaXRlbSkge1xuICAgICAgICAgICAgaWYgKGl0ZW0uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBjb3VudCArPSBjb3VudFJlc3VsdHMoaXRlbS5jaGlsZHJlbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCB0b2tlbml6ZXIuIFRoaXMgZnVuY3Rpb24gdXNlcyBicmVha3MgdGhlIGlucHV0IG9uIHN1YnN0cmluZyBtYXRjaCBvZiBhbnkgc3RyaW5nIGZyb20gdGhlXG4gICAgICogb3B0cy50b2tlblNlcGFyYXRvcnMgYXJyYXkgYW5kIHVzZXMgb3B0cy5jcmVhdGVTZWFyY2hDaG9pY2UgdG8gY3JlYXRlIHRoZSBjaG9pY2Ugb2JqZWN0LiBCb3RoIG9mIHRob3NlXG4gICAgICogdHdvIG9wdGlvbnMgaGF2ZSB0byBiZSBkZWZpbmVkIGluIG9yZGVyIGZvciB0aGUgdG9rZW5pemVyIHRvIHdvcmsuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgdGV4dCB1c2VyIGhhcyB0eXBlZCBzbyBmYXIgb3IgcGFzdGVkIGludG8gdGhlIHNlYXJjaCBmaWVsZFxuICAgICAqIEBwYXJhbSBzZWxlY3Rpb24gY3VycmVudGx5IHNlbGVjdGVkIGNob2ljZXNcbiAgICAgKiBAcGFyYW0gc2VsZWN0Q2FsbGJhY2sgZnVuY3Rpb24oY2hvaWNlKSBjYWxsYmFjayB0aG8gYWRkIHRoZSBjaG9pY2UgdG8gc2VsZWN0aW9uXG4gICAgICogQHBhcmFtIG9wdHMgc2VsZWN0MidzIG9wdHNcbiAgICAgKiBAcmV0dXJuIHVuZGVmaW5lZC9udWxsIHRvIGxlYXZlIHRoZSBjdXJyZW50IGlucHV0IHVuY2hhbmdlZCwgb3IgYSBzdHJpbmcgdG8gY2hhbmdlIHRoZSBpbnB1dCB0byB0aGUgcmV0dXJuZWQgdmFsdWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWZhdWx0VG9rZW5pemVyKGlucHV0LCBzZWxlY3Rpb24sIHNlbGVjdENhbGxiYWNrLCBvcHRzKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbCA9IGlucHV0LCAvLyBzdG9yZSB0aGUgb3JpZ2luYWwgc28gd2UgY2FuIGNvbXBhcmUgYW5kIGtub3cgaWYgd2UgbmVlZCB0byB0ZWxsIHRoZSBzZWFyY2ggdG8gdXBkYXRlIGl0cyB0ZXh0XG4gICAgICAgICAgICBkdXBlID0gZmFsc2UsIC8vIGNoZWNrIGZvciB3aGV0aGVyIGEgdG9rZW4gd2UgZXh0cmFjdGVkIHJlcHJlc2VudHMgYSBkdXBsaWNhdGUgc2VsZWN0ZWQgY2hvaWNlXG4gICAgICAgICAgICB0b2tlbiwgLy8gdG9rZW5cbiAgICAgICAgICAgIGluZGV4LCAvLyBwb3NpdGlvbiBhdCB3aGljaCB0aGUgc2VwYXJhdG9yIHdhcyBmb3VuZFxuICAgICAgICAgICAgaSwgbCwgLy8gbG9vcGluZyB2YXJpYWJsZXNcbiAgICAgICAgICAgIHNlcGFyYXRvcjsgLy8gdGhlIG1hdGNoZWQgc2VwYXJhdG9yXG5cbiAgICAgICAgaWYgKCFvcHRzLmNyZWF0ZVNlYXJjaENob2ljZSB8fCAhb3B0cy50b2tlblNlcGFyYXRvcnMgfHwgb3B0cy50b2tlblNlcGFyYXRvcnMubGVuZ3RoIDwgMSkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaW5kZXggPSAtMTtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IG9wdHMudG9rZW5TZXBhcmF0b3JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHNlcGFyYXRvciA9IG9wdHMudG9rZW5TZXBhcmF0b3JzW2ldO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaW5wdXQuaW5kZXhPZihzZXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkgYnJlYWs7IC8vIGRpZCBub3QgZmluZCBhbnkgdG9rZW4gc2VwYXJhdG9yIGluIHRoZSBpbnB1dCBzdHJpbmcsIGJhaWxcblxuICAgICAgICAgICAgdG9rZW4gPSBpbnB1dC5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5zdWJzdHJpbmcoaW5kZXggKyBzZXBhcmF0b3IubGVuZ3RoKTtcblxuICAgICAgICAgICAgaWYgKHRva2VuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IG9wdHMuY3JlYXRlU2VhcmNoQ2hvaWNlLmNhbGwodGhpcywgdG9rZW4sIHNlbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSB1bmRlZmluZWQgJiYgdG9rZW4gIT09IG51bGwgJiYgb3B0cy5pZCh0b2tlbikgIT09IHVuZGVmaW5lZCAmJiBvcHRzLmlkKHRva2VuKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBkdXBlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBzZWxlY3Rpb24ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXF1YWwob3B0cy5pZCh0b2tlbiksIG9wdHMuaWQoc2VsZWN0aW9uW2ldKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXBlID0gdHJ1ZTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWR1cGUpIHNlbGVjdENhbGxiYWNrKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3JpZ2luYWwhPT1pbnB1dCkgcmV0dXJuIGlucHV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFudXBKUXVlcnlFbGVtZW50cygpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICQuZWFjaChhcmd1bWVudHMsIGZ1bmN0aW9uIChpLCBlbGVtZW50KSB7XG4gICAgICAgICAgICBzZWxmW2VsZW1lbnRdLnJlbW92ZSgpO1xuICAgICAgICAgICAgc2VsZltlbGVtZW50XSA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY2xhc3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdXBlckNsYXNzXG4gICAgICogQHBhcmFtIG1ldGhvZHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbGF6eihTdXBlckNsYXNzLCBtZXRob2RzKSB7XG4gICAgICAgIHZhciBjb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBuZXcgU3VwZXJDbGFzcztcbiAgICAgICAgY29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY29uc3RydWN0b3I7XG4gICAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZS5wYXJlbnQgPSBTdXBlckNsYXNzLnByb3RvdHlwZTtcbiAgICAgICAgY29uc3RydWN0b3IucHJvdG90eXBlID0gJC5leHRlbmQoY29uc3RydWN0b3IucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yO1xuICAgIH1cblxuICAgIEFic3RyYWN0U2VsZWN0MiA9IGNsYXp6KE9iamVjdCwge1xuXG4gICAgICAgIC8vIGFic3RyYWN0XG4gICAgICAgIGJpbmQ6IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZ1bmMuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gYWJzdHJhY3RcbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRzLCBzZWFyY2gsIHJlc3VsdHNTZWxlY3RvciA9IFwiLnNlbGVjdDItcmVzdWx0c1wiO1xuXG4gICAgICAgICAgICAvLyBwcmVwYXJlIG9wdGlvbnNcbiAgICAgICAgICAgIHRoaXMub3B0cyA9IG9wdHMgPSB0aGlzLnByZXBhcmVPcHRzKG9wdHMpO1xuXG4gICAgICAgICAgICB0aGlzLmlkPW9wdHMuaWQ7XG5cbiAgICAgICAgICAgIC8vIGRlc3Ryb3kgaWYgY2FsbGVkIG9uIGFuIGV4aXN0aW5nIGNvbXBvbmVudFxuICAgICAgICAgICAgaWYgKG9wdHMuZWxlbWVudC5kYXRhKFwic2VsZWN0MlwiKSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgb3B0cy5lbGVtZW50LmRhdGEoXCJzZWxlY3QyXCIpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5lbGVtZW50LmRhdGEoXCJzZWxlY3QyXCIpLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzLmNyZWF0ZUNvbnRhaW5lcigpO1xuXG4gICAgICAgICAgICB0aGlzLmxpdmVSZWdpb24gPSAkKCcuc2VsZWN0Mi1oaWRkZW4tYWNjZXNzaWJsZScpO1xuICAgICAgICAgICAgaWYgKHRoaXMubGl2ZVJlZ2lvbi5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGl2ZVJlZ2lvbiA9ICQoXCI8c3Bhbj5cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9sZTogXCJzdGF0dXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYXJpYS1saXZlXCI6IFwicG9saXRlXCJcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFwic2VsZWN0Mi1oaWRkZW4tYWNjZXNzaWJsZVwiKVxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kVG8oZG9jdW1lbnQuYm9keSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVySWQ9XCJzMmlkX1wiKyhvcHRzLmVsZW1lbnQuYXR0cihcImlkXCIpIHx8IFwiYXV0b2dlblwiK25leHRVaWQoKSk7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lckV2ZW50TmFtZT0gdGhpcy5jb250YWluZXJJZFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oWy5dKS9nLCAnXycpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoLyhbOyYsXFwtXFwuXFwrXFwqXFx+JzpcIlxcIVxcXiMkJUBcXFtcXF1cXChcXCk9PlxcfF0pL2csICdcXFxcJDEnKTtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmF0dHIoXCJpZFwiLCB0aGlzLmNvbnRhaW5lcklkKTtcblxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYXR0cihcInRpdGxlXCIsIG9wdHMuZWxlbWVudC5hdHRyKFwidGl0bGVcIikpO1xuXG4gICAgICAgICAgICB0aGlzLmJvZHkgPSAkKGRvY3VtZW50LmJvZHkpO1xuXG4gICAgICAgICAgICBzeW5jQ3NzQ2xhc3Nlcyh0aGlzLmNvbnRhaW5lciwgdGhpcy5vcHRzLmVsZW1lbnQsIHRoaXMub3B0cy5hZGFwdENvbnRhaW5lckNzc0NsYXNzKTtcblxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYXR0cihcInN0eWxlXCIsIG9wdHMuZWxlbWVudC5hdHRyKFwic3R5bGVcIikpO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuY3NzKGV2YWx1YXRlKG9wdHMuY29udGFpbmVyQ3NzLCB0aGlzLm9wdHMuZWxlbWVudCkpO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2xhc3MoZXZhbHVhdGUob3B0cy5jb250YWluZXJDc3NDbGFzcywgdGhpcy5vcHRzLmVsZW1lbnQpKTtcblxuICAgICAgICAgICAgdGhpcy5lbGVtZW50VGFiSW5kZXggPSB0aGlzLm9wdHMuZWxlbWVudC5hdHRyKFwidGFiaW5kZXhcIik7XG5cbiAgICAgICAgICAgIC8vIHN3YXAgY29udGFpbmVyIGZvciB0aGUgZWxlbWVudFxuICAgICAgICAgICAgdGhpcy5vcHRzLmVsZW1lbnRcbiAgICAgICAgICAgICAgICAuZGF0YShcInNlbGVjdDJcIiwgdGhpcylcbiAgICAgICAgICAgICAgICAuYXR0cihcInRhYmluZGV4XCIsIFwiLTFcIilcbiAgICAgICAgICAgICAgICAuYmVmb3JlKHRoaXMuY29udGFpbmVyKVxuICAgICAgICAgICAgICAgIC5vbihcImNsaWNrLnNlbGVjdDJcIiwga2lsbEV2ZW50KTsgLy8gZG8gbm90IGxlYWsgY2xpY2sgZXZlbnRzXG5cbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmRhdGEoXCJzZWxlY3QyXCIsIHRoaXMpO1xuXG4gICAgICAgICAgICB0aGlzLmRyb3Bkb3duID0gdGhpcy5jb250YWluZXIuZmluZChcIi5zZWxlY3QyLWRyb3BcIik7XG5cbiAgICAgICAgICAgIHN5bmNDc3NDbGFzc2VzKHRoaXMuZHJvcGRvd24sIHRoaXMub3B0cy5lbGVtZW50LCB0aGlzLm9wdHMuYWRhcHREcm9wZG93bkNzc0NsYXNzKTtcblxuICAgICAgICAgICAgdGhpcy5kcm9wZG93bi5hZGRDbGFzcyhldmFsdWF0ZShvcHRzLmRyb3Bkb3duQ3NzQ2xhc3MsIHRoaXMub3B0cy5lbGVtZW50KSk7XG4gICAgICAgICAgICB0aGlzLmRyb3Bkb3duLmRhdGEoXCJzZWxlY3QyXCIsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5kcm9wZG93bi5vbihcImNsaWNrXCIsIGtpbGxFdmVudCk7XG5cbiAgICAgICAgICAgIHRoaXMucmVzdWx0cyA9IHJlc3VsdHMgPSB0aGlzLmNvbnRhaW5lci5maW5kKHJlc3VsdHNTZWxlY3Rvcik7XG4gICAgICAgICAgICB0aGlzLnNlYXJjaCA9IHNlYXJjaCA9IHRoaXMuY29udGFpbmVyLmZpbmQoXCJpbnB1dC5zZWxlY3QyLWlucHV0XCIpO1xuXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5Q291bnQgPSAwO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRzUGFnZSA9IDA7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBjb250YWluZXJcbiAgICAgICAgICAgIHRoaXMuaW5pdENvbnRhaW5lcigpO1xuXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5vbihcImNsaWNrXCIsIGtpbGxFdmVudCk7XG5cbiAgICAgICAgICAgIGluc3RhbGxGaWx0ZXJlZE1vdXNlTW92ZSh0aGlzLnJlc3VsdHMpO1xuXG4gICAgICAgICAgICB0aGlzLmRyb3Bkb3duLm9uKFwibW91c2Vtb3ZlLWZpbHRlcmVkXCIsIHJlc3VsdHNTZWxlY3RvciwgdGhpcy5iaW5kKHRoaXMuaGlnaGxpZ2h0VW5kZXJFdmVudCkpO1xuICAgICAgICAgICAgdGhpcy5kcm9wZG93bi5vbihcInRvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kXCIsIHJlc3VsdHNTZWxlY3RvciwgdGhpcy5iaW5kKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RvdWNoRXZlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0VW5kZXJFdmVudChldmVudCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB0aGlzLmRyb3Bkb3duLm9uKFwidG91Y2htb3ZlXCIsIHJlc3VsdHNTZWxlY3RvciwgdGhpcy5iaW5kKHRoaXMudG91Y2hNb3ZlZCkpO1xuICAgICAgICAgICAgdGhpcy5kcm9wZG93bi5vbihcInRvdWNoc3RhcnQgdG91Y2hlbmRcIiwgcmVzdWx0c1NlbGVjdG9yLCB0aGlzLmJpbmQodGhpcy5jbGVhclRvdWNoTW92ZWQpKTtcblxuICAgICAgICAgICAgLy8gV2FpdGluZyBmb3IgYSBjbGljayBldmVudCBvbiB0b3VjaCBkZXZpY2VzIHRvIHNlbGVjdCBvcHRpb24gYW5kIGhpZGUgZHJvcGRvd25cbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBjbGljayB3aWxsIGJlIHRyaWdnZXJlZCBvbiBhbiB1bmRlcmx5aW5nIGVsZW1lbnRcbiAgICAgICAgICAgIHRoaXMuZHJvcGRvd24ub24oJ2NsaWNrJywgdGhpcy5iaW5kKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl90b3VjaEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RvdWNoRXZlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RIaWdobGlnaHRlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgaW5zdGFsbERlYm91bmNlZFNjcm9sbCg4MCwgdGhpcy5yZXN1bHRzKTtcbiAgICAgICAgICAgIHRoaXMuZHJvcGRvd24ub24oXCJzY3JvbGwtZGVib3VuY2VkXCIsIHJlc3VsdHNTZWxlY3RvciwgdGhpcy5iaW5kKHRoaXMubG9hZE1vcmVJZk5lZWRlZCkpO1xuXG4gICAgICAgICAgICAvLyBkbyBub3QgcHJvcGFnYXRlIGNoYW5nZSBldmVudCBmcm9tIHRoZSBzZWFyY2ggZmllbGQgb3V0IG9mIHRoZSBjb21wb25lbnRcbiAgICAgICAgICAgICQodGhpcy5jb250YWluZXIpLm9uKFwiY2hhbmdlXCIsIFwiLnNlbGVjdDItaW5wdXRcIiwgZnVuY3Rpb24oZSkge2Uuc3RvcFByb3BhZ2F0aW9uKCk7fSk7XG4gICAgICAgICAgICAkKHRoaXMuZHJvcGRvd24pLm9uKFwiY2hhbmdlXCIsIFwiLnNlbGVjdDItaW5wdXRcIiwgZnVuY3Rpb24oZSkge2Uuc3RvcFByb3BhZ2F0aW9uKCk7fSk7XG5cbiAgICAgICAgICAgIC8vIGlmIGpxdWVyeS5tb3VzZXdoZWVsIHBsdWdpbiBpcyBpbnN0YWxsZWQgd2UgY2FuIHByZXZlbnQgb3V0LW9mLWJvdW5kcyBzY3JvbGxpbmcgb2YgcmVzdWx0cyB2aWEgbW91c2V3aGVlbFxuICAgICAgICAgICAgaWYgKCQuZm4ubW91c2V3aGVlbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMubW91c2V3aGVlbChmdW5jdGlvbiAoZSwgZGVsdGEsIGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b3AgPSByZXN1bHRzLnNjcm9sbFRvcCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVsdGFZID4gMCAmJiB0b3AgLSBkZWx0YVkgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5zY3JvbGxUb3AoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBraWxsRXZlbnQoZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVsdGFZIDwgMCAmJiByZXN1bHRzLmdldCgwKS5zY3JvbGxIZWlnaHQgLSByZXN1bHRzLnNjcm9sbFRvcCgpICsgZGVsdGFZIDw9IHJlc3VsdHMuaGVpZ2h0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMuc2Nyb2xsVG9wKHJlc3VsdHMuZ2V0KDApLnNjcm9sbEhlaWdodCAtIHJlc3VsdHMuaGVpZ2h0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAga2lsbEV2ZW50KGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGluc3RhbGxLZXlVcENoYW5nZUV2ZW50KHNlYXJjaCk7XG4gICAgICAgICAgICBzZWFyY2gub24oXCJrZXl1cC1jaGFuZ2UgaW5wdXQgcGFzdGVcIiwgdGhpcy5iaW5kKHRoaXMudXBkYXRlUmVzdWx0cykpO1xuICAgICAgICAgICAgc2VhcmNoLm9uKFwiZm9jdXNcIiwgZnVuY3Rpb24gKCkgeyBzZWFyY2guYWRkQ2xhc3MoXCJzZWxlY3QyLWZvY3VzZWRcIik7IH0pO1xuICAgICAgICAgICAgc2VhcmNoLm9uKFwiYmx1clwiLCBmdW5jdGlvbiAoKSB7IHNlYXJjaC5yZW1vdmVDbGFzcyhcInNlbGVjdDItZm9jdXNlZFwiKTt9KTtcblxuICAgICAgICAgICAgdGhpcy5kcm9wZG93bi5vbihcIm1vdXNldXBcIiwgcmVzdWx0c1NlbGVjdG9yLCB0aGlzLmJpbmQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoJChlLnRhcmdldCkuY2xvc2VzdChcIi5zZWxlY3QyLXJlc3VsdC1zZWxlY3RhYmxlXCIpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRVbmRlckV2ZW50KGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdEhpZ2hsaWdodGVkKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgLy8gdHJhcCBhbGwgbW91c2UgZXZlbnRzIGZyb20gbGVhdmluZyB0aGUgZHJvcGRvd24uIHNvbWV0aW1lcyB0aGVyZSBtYXkgYmUgYSBtb2RhbCB0aGF0IGlzIGxpc3RlbmluZ1xuICAgICAgICAgICAgLy8gZm9yIG1vdXNlIGV2ZW50cyBvdXRzaWRlIG9mIGl0c2VsZiBzbyBpdCBjYW4gY2xvc2UgaXRzZWxmLiBzaW5jZSB0aGUgZHJvcGRvd24gaXMgbm93IG91dHNpZGUgdGhlIHNlbGVjdDInc1xuICAgICAgICAgICAgLy8gZG9tIGl0IHdpbGwgdHJpZ2dlciB0aGUgcG9wdXAgY2xvc2UsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnRcbiAgICAgICAgICAgIC8vIGZvY3VzaW4gY2FuIGNhdXNlIGZvY3VzIHdhcnMgYmV0d2VlbiBtb2RhbHMgYW5kIHNlbGVjdDIgc2luY2UgdGhlIGRyb3Bkb3duIGlzIG91dHNpZGUgdGhlIG1vZGFsLlxuICAgICAgICAgICAgdGhpcy5kcm9wZG93bi5vbihcImNsaWNrIG1vdXNldXAgbW91c2Vkb3duIHRvdWNoc3RhcnQgdG91Y2hlbmQgZm9jdXNpblwiLCBmdW5jdGlvbiAoZSkgeyBlLnN0b3BQcm9wYWdhdGlvbigpOyB9KTtcblxuICAgICAgICAgICAgdGhpcy5uZXh0U2VhcmNoVGVybSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgaWYgKCQuaXNGdW5jdGlvbih0aGlzLm9wdHMuaW5pdFNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXplIHNlbGVjdGlvbiBiYXNlZCBvbiB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgc291cmNlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRTZWxlY3Rpb24oKTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSB1c2VyIGhhcyBwcm92aWRlZCBhIGZ1bmN0aW9uIHRoYXQgY2FuIHNldCBzZWxlY3Rpb24gYmFzZWQgb24gdGhlIHZhbHVlIG9mIHRoZSBzb3VyY2UgZWxlbWVudFxuICAgICAgICAgICAgICAgIC8vIHdlIG1vbml0b3IgdGhlIGNoYW5nZSBldmVudCBvbiB0aGUgZWxlbWVudCBhbmQgdHJpZ2dlciBpdCwgYWxsb3dpbmcgZm9yIHR3byB3YXkgc3luY2hyb25pemF0aW9uXG4gICAgICAgICAgICAgICAgdGhpcy5tb25pdG9yU291cmNlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHRzLm1heGltdW1JbnB1dExlbmd0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoLmF0dHIoXCJtYXhsZW5ndGhcIiwgb3B0cy5tYXhpbXVtSW5wdXRMZW5ndGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGlzYWJsZWQgPSBvcHRzLmVsZW1lbnQucHJvcChcImRpc2FibGVkXCIpO1xuICAgICAgICAgICAgaWYgKGRpc2FibGVkID09PSB1bmRlZmluZWQpIGRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZSghZGlzYWJsZWQpO1xuXG4gICAgICAgICAgICB2YXIgcmVhZG9ubHkgPSBvcHRzLmVsZW1lbnQucHJvcChcInJlYWRvbmx5XCIpO1xuICAgICAgICAgICAgaWYgKHJlYWRvbmx5ID09PSB1bmRlZmluZWQpIHJlYWRvbmx5ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnJlYWRvbmx5KHJlYWRvbmx5KTtcblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHNpemUgb2Ygc2Nyb2xsYmFyXG4gICAgICAgICAgICBzY3JvbGxCYXJEaW1lbnNpb25zID0gc2Nyb2xsQmFyRGltZW5zaW9ucyB8fCBtZWFzdXJlU2Nyb2xsYmFyKCk7XG5cbiAgICAgICAgICAgIHRoaXMuYXV0b2ZvY3VzID0gb3B0cy5lbGVtZW50LnByb3AoXCJhdXRvZm9jdXNcIik7XG4gICAgICAgICAgICBvcHRzLmVsZW1lbnQucHJvcChcImF1dG9mb2N1c1wiLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5hdXRvZm9jdXMpIHRoaXMuZm9jdXMoKTtcblxuICAgICAgICAgICAgdGhpcy5zZWFyY2guYXR0cihcInBsYWNlaG9sZGVyXCIsIG9wdHMuc2VhcmNoSW5wdXRQbGFjZWhvbGRlcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gYWJzdHJhY3RcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQ9dGhpcy5vcHRzLmVsZW1lbnQsIHNlbGVjdDIgPSBlbGVtZW50LmRhdGEoXCJzZWxlY3QyXCIpLCBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5sZW5ndGggJiYgZWxlbWVudFswXS5kZXRhY2hFdmVudCAmJiBzZWxmLl9zeW5jKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX3N5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGV0YWNoRXZlbnQoXCJvbnByb3BlcnR5Y2hhbmdlXCIsIHNlbGYuX3N5bmMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wZXJ0eU9ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnR5T2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc3luYyA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3QyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3QyLmNvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBzZWxlY3QyLmxpdmVSZWdpb24ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgc2VsZWN0Mi5kcm9wZG93bi5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIC5zaG93KClcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZURhdGEoXCJzZWxlY3QyXCIpXG4gICAgICAgICAgICAgICAgICAgIC5vZmYoXCIuc2VsZWN0MlwiKVxuICAgICAgICAgICAgICAgICAgICAucHJvcChcImF1dG9mb2N1c1wiLCB0aGlzLmF1dG9mb2N1cyB8fCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZWxlbWVudFRhYkluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0cih7dGFiaW5kZXg6IHRoaXMuZWxlbWVudFRhYkluZGV4fSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyKFwidGFiaW5kZXhcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsZW1lbnQuc2hvdygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjbGVhbnVwSlF1ZXJ5RWxlbWVudHMuY2FsbCh0aGlzLFxuICAgICAgICAgICAgICAgIFwiY29udGFpbmVyXCIsXG4gICAgICAgICAgICAgICAgXCJsaXZlUmVnaW9uXCIsXG4gICAgICAgICAgICAgICAgXCJkcm9wZG93blwiLFxuICAgICAgICAgICAgICAgIFwicmVzdWx0c1wiLFxuICAgICAgICAgICAgICAgIFwic2VhcmNoXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gYWJzdHJhY3RcbiAgICAgICAgb3B0aW9uVG9EYXRhOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5pcyhcIm9wdGlvblwiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOmVsZW1lbnQucHJvcChcInZhbHVlXCIpLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OmVsZW1lbnQudGV4dCgpLFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LmdldCgpLFxuICAgICAgICAgICAgICAgICAgICBjc3M6IGVsZW1lbnQuYXR0cihcImNsYXNzXCIpLFxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDogZWxlbWVudC5wcm9wKFwiZGlzYWJsZWRcIiksXG4gICAgICAgICAgICAgICAgICAgIGxvY2tlZDogZXF1YWwoZWxlbWVudC5hdHRyKFwibG9ja2VkXCIpLCBcImxvY2tlZFwiKSB8fCBlcXVhbChlbGVtZW50LmRhdGEoXCJsb2NrZWRcIiksIHRydWUpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5pcyhcIm9wdGdyb3VwXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDplbGVtZW50LmF0dHIoXCJsYWJlbFwiKSxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46W10sXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQuZ2V0KCksXG4gICAgICAgICAgICAgICAgICAgIGNzczogZWxlbWVudC5hdHRyKFwiY2xhc3NcIilcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGFic3RyYWN0XG4gICAgICAgIHByZXBhcmVPcHRzOiBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQsIHNlbGVjdCwgaWRLZXksIGFqYXhVcmwsIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICBlbGVtZW50ID0gb3B0cy5lbGVtZW50O1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5nZXQoMCkudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInNlbGVjdFwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3QgPSBzZWxlY3QgPSBvcHRzLmVsZW1lbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3QpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGVzZSBvcHRpb25zIGFyZSBub3QgYWxsb3dlZCB3aGVuIGF0dGFjaGVkIHRvIGEgc2VsZWN0IGJlY2F1c2UgdGhleSBhcmUgcGlja2VkIHVwIG9mZiB0aGUgZWxlbWVudCBpdHNlbGZcbiAgICAgICAgICAgICAgICAkLmVhY2goW1wiaWRcIiwgXCJtdWx0aXBsZVwiLCBcImFqYXhcIiwgXCJxdWVyeVwiLCBcImNyZWF0ZVNlYXJjaENob2ljZVwiLCBcImluaXRTZWxlY3Rpb25cIiwgXCJkYXRhXCIsIFwidGFnc1wiXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcyBpbiBvcHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPcHRpb24gJ1wiICsgdGhpcyArIFwiJyBpcyBub3QgYWxsb3dlZCBmb3IgU2VsZWN0MiB3aGVuIGF0dGFjaGVkIHRvIGEgPHNlbGVjdD4gZWxlbWVudC5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3B0cyA9ICQuZXh0ZW5kKHt9LCB7XG4gICAgICAgICAgICAgICAgcG9wdWxhdGVSZXN1bHRzOiBmdW5jdGlvbihjb250YWluZXIsIHJlc3VsdHMsIHF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3B1bGF0ZSwgaWQ9dGhpcy5vcHRzLmlkLCBsaXZlUmVnaW9uPXRoaXMubGl2ZVJlZ2lvbjtcblxuICAgICAgICAgICAgICAgICAgICBwb3B1bGF0ZT1mdW5jdGlvbihyZXN1bHRzLCBjb250YWluZXIsIGRlcHRoKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpLCBsLCByZXN1bHQsIHNlbGVjdGFibGUsIGRpc2FibGVkLCBjb21wb3VuZCwgbm9kZSwgbGFiZWwsIGlubmVyQ29udGFpbmVyLCBmb3JtYXR0ZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBvcHRzLnNvcnRSZXN1bHRzKHJlc3VsdHMsIGNvbnRhaW5lciwgcXVlcnkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb2xsZWN0IHRoZSBjcmVhdGVkIG5vZGVzIGZvciBidWxrIGFwcGVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gcmVzdWx0cy5sZW5ndGg7IGkgPCBsOyBpID0gaSArIDEpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdD1yZXN1bHRzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQgPSAocmVzdWx0LmRpc2FibGVkID09PSB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RhYmxlID0gKCFkaXNhYmxlZCkgJiYgKGlkKHJlc3VsdCkgIT09IHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb3VuZD1yZXN1bHQuY2hpbGRyZW4gJiYgcmVzdWx0LmNoaWxkcmVuLmxlbmd0aCA+IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlPSQoXCI8bGk+PC9saT5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hZGRDbGFzcyhcInNlbGVjdDItcmVzdWx0cy1kZXB0LVwiK2RlcHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmFkZENsYXNzKFwic2VsZWN0Mi1yZXN1bHRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hZGRDbGFzcyhzZWxlY3RhYmxlID8gXCJzZWxlY3QyLXJlc3VsdC1zZWxlY3RhYmxlXCIgOiBcInNlbGVjdDItcmVzdWx0LXVuc2VsZWN0YWJsZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzYWJsZWQpIHsgbm9kZS5hZGRDbGFzcyhcInNlbGVjdDItZGlzYWJsZWRcIik7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG91bmQpIHsgbm9kZS5hZGRDbGFzcyhcInNlbGVjdDItcmVzdWx0LXdpdGgtY2hpbGRyZW5cIik7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmFkZENsYXNzKHNlbGYub3B0cy5mb3JtYXRSZXN1bHRDc3NDbGFzcyhyZXN1bHQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmF0dHIoXCJyb2xlXCIsIFwicHJlc2VudGF0aW9uXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9JChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbC5hZGRDbGFzcyhcInNlbGVjdDItcmVzdWx0LWxhYmVsXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsLmF0dHIoXCJpZFwiLCBcInNlbGVjdDItcmVzdWx0LWxhYmVsLVwiICsgbmV4dFVpZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbC5hdHRyKFwicm9sZVwiLCBcIm9wdGlvblwiKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZD1vcHRzLmZvcm1hdFJlc3VsdChyZXN1bHQsIGxhYmVsLCBxdWVyeSwgc2VsZi5vcHRzLmVzY2FwZU1hcmt1cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvcm1hdHRlZCE9PXVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbC5odG1sKGZvcm1hdHRlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYXBwZW5kKGxhYmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wb3VuZCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyQ29udGFpbmVyPSQoXCI8dWw+PC91bD5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyQ29udGFpbmVyLmFkZENsYXNzKFwic2VsZWN0Mi1yZXN1bHQtc3ViXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3B1bGF0ZShyZXN1bHQuY2hpbGRyZW4sIGlubmVyQ29udGFpbmVyLCBkZXB0aCsxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hcHBlbmQoaW5uZXJDb250YWluZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZGF0YShcInNlbGVjdDItZGF0YVwiLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobm9kZVswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1bGsgYXBwZW5kIHRoZSBjcmVhdGVkIG5vZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kKG5vZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpdmVSZWdpb24udGV4dChvcHRzLmZvcm1hdE1hdGNoZXMocmVzdWx0cy5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBwb3B1bGF0ZShyZXN1bHRzLCBjb250YWluZXIsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sICQuZm4uc2VsZWN0Mi5kZWZhdWx0cywgb3B0cyk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Yob3B0cy5pZCkgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGlkS2V5ID0gb3B0cy5pZDtcbiAgICAgICAgICAgICAgICBvcHRzLmlkID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGVbaWRLZXldOyB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoJC5pc0FycmF5KG9wdHMuZWxlbWVudC5kYXRhKFwic2VsZWN0MlRhZ3NcIikpKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwidGFnc1wiIGluIG9wdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJ0YWdzIHNwZWNpZmllZCBhcyBib3RoIGFuIGF0dHJpYnV0ZSAnZGF0YS1zZWxlY3QyLXRhZ3MnIGFuZCBpbiBvcHRpb25zIG9mIFNlbGVjdDIgXCIgKyBvcHRzLmVsZW1lbnQuYXR0cihcImlkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRzLnRhZ3M9b3B0cy5lbGVtZW50LmRhdGEoXCJzZWxlY3QyVGFnc1wiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlbGVjdCkge1xuICAgICAgICAgICAgICAgIG9wdHMucXVlcnkgPSB0aGlzLmJpbmQoZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0geyByZXN1bHRzOiBbXSwgbW9yZTogZmFsc2UgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlcm0gPSBxdWVyeS50ZXJtLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4sIHBsYWNlaG9sZGVyT3B0aW9uLCBwcm9jZXNzO1xuXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3M9ZnVuY3Rpb24oZWxlbWVudCwgY29sbGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuaXMoXCJvcHRpb25cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocXVlcnkubWF0Y2hlcih0ZXJtLCBlbGVtZW50LnRleHQoKSwgZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbi5wdXNoKHNlbGYub3B0aW9uVG9EYXRhKGVsZW1lbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuaXMoXCJvcHRncm91cFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwPXNlbGYub3B0aW9uVG9EYXRhKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuY2hpbGRyZW4oKS5lYWNoMihmdW5jdGlvbihpLCBlbG0pIHsgcHJvY2VzcyhlbG0sIGdyb3VwLmNoaWxkcmVuKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwLmNoaWxkcmVuLmxlbmd0aD4wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24ucHVzaChncm91cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuPWVsZW1lbnQuY2hpbGRyZW4oKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgdGhlIHBsYWNlaG9sZGVyIG9wdGlvbiBpZiB0aGVyZSBpcyBvbmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0UGxhY2Vob2xkZXIoKSAhPT0gdW5kZWZpbmVkICYmIGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyT3B0aW9uID0gdGhpcy5nZXRQbGFjZWhvbGRlck9wdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBsYWNlaG9sZGVyT3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW49Y2hpbGRyZW4ubm90KHBsYWNlaG9sZGVyT3B0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLmVhY2gyKGZ1bmN0aW9uKGksIGVsbSkgeyBwcm9jZXNzKGVsbSwgZGF0YS5yZXN1bHRzKTsgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcXVlcnkuY2FsbGJhY2soZGF0YSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBuZWVkZWQgYmVjYXVzZSBpbnNpZGUgdmFsKCkgd2UgY29uc3RydWN0IGNob2ljZXMgZnJvbSBvcHRpb25zIGFuZCB0aGVpciBpZCBpcyBoYXJkY29kZWRcbiAgICAgICAgICAgICAgICBvcHRzLmlkPWZ1bmN0aW9uKGUpIHsgcmV0dXJuIGUuaWQ7IH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghKFwicXVlcnlcIiBpbiBvcHRzKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChcImFqYXhcIiBpbiBvcHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhamF4VXJsID0gb3B0cy5lbGVtZW50LmRhdGEoXCJhamF4LXVybFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhamF4VXJsICYmIGFqYXhVcmwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMuYWpheC51cmwgPSBhamF4VXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0cy5xdWVyeSA9IGFqYXguY2FsbChvcHRzLmVsZW1lbnQsIG9wdHMuYWpheCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXCJkYXRhXCIgaW4gb3B0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0cy5xdWVyeSA9IGxvY2FsKG9wdHMuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXCJ0YWdzXCIgaW4gb3B0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0cy5xdWVyeSA9IHRhZ3Mob3B0cy50YWdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLmNyZWF0ZVNlYXJjaENob2ljZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cy5jcmVhdGVTZWFyY2hDaG9pY2UgPSBmdW5jdGlvbiAodGVybSkgeyByZXR1cm4ge2lkOiAkLnRyaW0odGVybSksIHRleHQ6ICQudHJpbSh0ZXJtKX07IH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0cy5pbml0U2VsZWN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRzLmluaXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChzcGxpdFZhbChlbGVtZW50LnZhbCgpLCBvcHRzLnNlcGFyYXRvciwgb3B0cy50cmFuc2Zvcm1WYWwpKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmogPSB7IGlkOiB0aGlzLCB0ZXh0OiB0aGlzIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFncyA9IG9wdHMudGFncztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkLmlzRnVuY3Rpb24odGFncykpIHRhZ3M9dGFncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCh0YWdzKS5lYWNoKGZ1bmN0aW9uKCkgeyBpZiAoZXF1YWwodGhpcy5pZCwgb2JqLmlkKSkgeyBvYmogPSB0aGlzOyByZXR1cm4gZmFsc2U7IH0gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2gob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Yob3B0cy5xdWVyeSkgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRocm93IFwicXVlcnkgZnVuY3Rpb24gbm90IGRlZmluZWQgZm9yIFNlbGVjdDIgXCIgKyBvcHRzLmVsZW1lbnQuYXR0cihcImlkXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3B0cy5jcmVhdGVTZWFyY2hDaG9pY2VQb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgICAgICBvcHRzLmNyZWF0ZVNlYXJjaENob2ljZVBvc2l0aW9uID0gZnVuY3Rpb24obGlzdCwgaXRlbSkgeyBsaXN0LnVuc2hpZnQoaXRlbSk7IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRzLmNyZWF0ZVNlYXJjaENob2ljZVBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgICAgICAgICAgIG9wdHMuY3JlYXRlU2VhcmNoQ2hvaWNlUG9zaXRpb24gPSBmdW5jdGlvbihsaXN0LCBpdGVtKSB7IGxpc3QucHVzaChpdGVtKTsgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZihvcHRzLmNyZWF0ZVNlYXJjaENob2ljZVBvc2l0aW9uKSAhPT0gXCJmdW5jdGlvblwiKSAge1xuICAgICAgICAgICAgICAgIHRocm93IFwiaW52YWxpZCBjcmVhdGVTZWFyY2hDaG9pY2VQb3NpdGlvbiBvcHRpb24gbXVzdCBiZSAndG9wJywgJ2JvdHRvbScgb3IgYSBjdXN0b20gZnVuY3Rpb25cIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9wdHM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vbml0b3IgdGhlIG9yaWdpbmFsIGVsZW1lbnQgZm9yIGNoYW5nZXMgYW5kIHVwZGF0ZSBzZWxlY3QyIGFjY29yZGluZ2x5XG4gICAgICAgICAqL1xuICAgICAgICAvLyBhYnN0cmFjdFxuICAgICAgICBtb25pdG9yU291cmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzLm9wdHMuZWxlbWVudCwgb2JzZXJ2ZXIsIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICBlbC5vbihcImNoYW5nZS5zZWxlY3QyXCIsIHRoaXMuYmluZChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuZWxlbWVudC5kYXRhKFwic2VsZWN0Mi1jaGFuZ2UtdHJpZ2dlcmVkXCIpICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgdGhpcy5fc3luYyA9IHRoaXMuYmluZChmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBzeW5jIGVuYWJsZWQgc3RhdGVcbiAgICAgICAgICAgICAgICB2YXIgZGlzYWJsZWQgPSBlbC5wcm9wKFwiZGlzYWJsZWRcIik7XG4gICAgICAgICAgICAgICAgaWYgKGRpc2FibGVkID09PSB1bmRlZmluZWQpIGRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmFibGUoIWRpc2FibGVkKTtcblxuICAgICAgICAgICAgICAgIHZhciByZWFkb25seSA9IGVsLnByb3AoXCJyZWFkb25seVwiKTtcbiAgICAgICAgICAgICAgICBpZiAocmVhZG9ubHkgPT09IHVuZGVmaW5lZCkgcmVhZG9ubHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWRvbmx5KHJlYWRvbmx5KTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICBzeW5jQ3NzQ2xhc3Nlcyh0aGlzLmNvbnRhaW5lciwgdGhpcy5vcHRzLmVsZW1lbnQsIHRoaXMub3B0cy5hZGFwdENvbnRhaW5lckNzc0NsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2xhc3MoZXZhbHVhdGUodGhpcy5vcHRzLmNvbnRhaW5lckNzc0NsYXNzLCB0aGlzLm9wdHMuZWxlbWVudCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRyb3Bkb3duKSB7XG4gICAgICAgICAgICAgICAgICAgIHN5bmNDc3NDbGFzc2VzKHRoaXMuZHJvcGRvd24sIHRoaXMub3B0cy5lbGVtZW50LCB0aGlzLm9wdHMuYWRhcHREcm9wZG93bkNzc0NsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wZG93bi5hZGRDbGFzcyhldmFsdWF0ZSh0aGlzLm9wdHMuZHJvcGRvd25Dc3NDbGFzcywgdGhpcy5vcHRzLmVsZW1lbnQpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBJRTgtMTAgKElFOS8xMCB3b24ndCBmaXJlIHByb3BlcnR5Q2hhbmdlIHZpYSBhdHRhY2hFdmVudExpc3RlbmVyKVxuICAgICAgICAgICAgaWYgKGVsLmxlbmd0aCAmJiBlbFswXS5hdHRhY2hFdmVudCkge1xuICAgICAgICAgICAgICAgIGVsLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvbnByb3BlcnR5Y2hhbmdlXCIsIHNlbGYuX3N5bmMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzYWZhcmksIGNocm9tZSwgZmlyZWZveCwgSUUxMVxuICAgICAgICAgICAgb2JzZXJ2ZXIgPSB3aW5kb3cuTXV0YXRpb25PYnNlcnZlciB8fCB3aW5kb3cuV2ViS2l0TXV0YXRpb25PYnNlcnZlcnx8IHdpbmRvdy5Nb3pNdXRhdGlvbk9ic2VydmVyO1xuICAgICAgICAgICAgaWYgKG9ic2VydmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9wZXJ0eU9ic2VydmVyKSB7IGRlbGV0ZSB0aGlzLnByb3BlcnR5T2JzZXJ2ZXI7IHRoaXMucHJvcGVydHlPYnNlcnZlciA9IG51bGw7IH1cbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnR5T2JzZXJ2ZXIgPSBuZXcgb2JzZXJ2ZXIoZnVuY3Rpb24gKG11dGF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAkLmVhY2gobXV0YXRpb25zLCBzZWxmLl9zeW5jKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnR5T2JzZXJ2ZXIub2JzZXJ2ZShlbC5nZXQoMCksIHsgYXR0cmlidXRlczp0cnVlLCBzdWJ0cmVlOmZhbHNlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGFic3RyYWN0XG4gICAgICAgIHRyaWdnZXJTZWxlY3Q6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBldnQgPSAkLkV2ZW50KFwic2VsZWN0Mi1zZWxlY3RpbmdcIiwgeyB2YWw6IHRoaXMuaWQoZGF0YSksIG9iamVjdDogZGF0YSwgY2hvaWNlOiBkYXRhIH0pO1xuICAgICAgICAgICAgdGhpcy5vcHRzLmVsZW1lbnQudHJpZ2dlcihldnQpO1xuICAgICAgICAgICAgcmV0dXJuICFldnQuaXNEZWZhdWx0UHJldmVudGVkKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyaWdnZXJzIHRoZSBjaGFuZ2UgZXZlbnQgb24gdGhlIHNvdXJjZSBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICAvLyBhYnN0cmFjdFxuICAgICAgICB0cmlnZ2VyQ2hhbmdlOiBmdW5jdGlvbiAoZGV0YWlscykge1xuXG4gICAgICAgICAgICBkZXRhaWxzID0gZGV0YWlscyB8fCB7fTtcbiAgICAgICAgICAgIGRldGFpbHM9ICQuZXh0ZW5kKHt9LCBkZXRhaWxzLCB7IHR5cGU6IFwiY2hhbmdlXCIsIHZhbDogdGhpcy52YWwoKSB9KTtcbiAgICAgICAgICAgIC8vIHByZXZlbnRzIHJlY3Vyc2l2ZSB0cmlnZ2VyaW5nXG4gICAgICAgICAgICB0aGlzLm9wdHMuZWxlbWVudC5kYXRhKFwic2VsZWN0Mi1jaGFuZ2UtdHJpZ2dlcmVkXCIsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5vcHRzLmVsZW1lbnQudHJpZ2dlcihkZXRhaWxzKTtcbiAgICAgICAgICAgIHRoaXMub3B0cy5lbGVtZW50LmRhdGEoXCJzZWxlY3QyLWNoYW5nZS10cmlnZ2VyZWRcIiwgZmFsc2UpO1xuXG4gICAgICAgICAgICAvLyBzb21lIHZhbGlkYXRpb24gZnJhbWV3b3JrcyBpZ25vcmUgdGhlIGNoYW5nZSBldmVudCBhbmQgbGlzdGVuIGluc3RlYWQgdG8ga2V5dXAsIGNsaWNrIGZvciBzZWxlY3RzXG4gICAgICAgICAgICAvLyBzbyBoZXJlIHdlIHRyaWdnZXIgdGhlIGNsaWNrIGV2ZW50IG1hbnVhbGx5XG4gICAgICAgICAgICB0aGlzLm9wdHMuZWxlbWVudC5jbGljaygpO1xuXG4gICAgICAgICAgICAvLyBWYWxpZGF0aW9uRW5naW5lIGlnbm9yZXMgdGhlIGNoYW5nZSBldmVudCBhbmQgbGlzdGVucyBpbnN0ZWFkIHRvIGJsdXJcbiAgICAgICAgICAgIC8vIHNvIGhlcmUgd2UgdHJpZ2dlciB0aGUgYmx1ciBldmVudCBtYW51YWxseSBpZiBzbyBkZXNpcmVkXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLmJsdXJPbkNoYW5nZSlcbiAgICAgICAgICAgICAgICB0aGlzLm9wdHMuZWxlbWVudC5ibHVyKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy9hYnN0cmFjdFxuICAgICAgICBpc0ludGVyZmFjZUVuYWJsZWQ6IGZ1bmN0aW9uKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5hYmxlZEludGVyZmFjZSA9PT0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBhYnN0cmFjdFxuICAgICAgICBlbmFibGVJbnRlcmZhY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGVuYWJsZWQgPSB0aGlzLl9lbmFibGVkICYmICF0aGlzLl9yZWFkb25seSxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZCA9ICFlbmFibGVkO1xuXG4gICAgICAgICAgICBpZiAoZW5hYmxlZCA9PT0gdGhpcy5lbmFibGVkSW50ZXJmYWNlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnRvZ2dsZUNsYXNzKFwic2VsZWN0Mi1jb250YWluZXItZGlzYWJsZWRcIiwgZGlzYWJsZWQpO1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5lbmFibGVkSW50ZXJmYWNlID0gZW5hYmxlZDtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gYWJzdHJhY3RcbiAgICAgICAgZW5hYmxlOiBmdW5jdGlvbihlbmFibGVkKSB7XG4gICAgICAgICAgICBpZiAoZW5hYmxlZCA9PT0gdW5kZWZpbmVkKSBlbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9lbmFibGVkID09PSBlbmFibGVkKSByZXR1cm47XG4gICAgICAgICAgICB0aGlzLl9lbmFibGVkID0gZW5hYmxlZDtcblxuICAgICAgICAgICAgdGhpcy5vcHRzLmVsZW1lbnQucHJvcChcImRpc2FibGVkXCIsICFlbmFibGVkKTtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlSW50ZXJmYWNlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gYWJzdHJhY3RcbiAgICAgICAgZGlzYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZShmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gYWJzdHJhY3RcbiAgICAgICAgcmVhZG9ubHk6IGZ1bmN0aW9uKGVuYWJsZWQpIHtcbiAgICAgICAgICAgIGlmIChlbmFibGVkID09PSB1bmRlZmluZWQpIGVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZWFkb25seSA9PT0gZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5fcmVhZG9ubHkgPSBlbmFibGVkO1xuXG4gICAgICAgICAgICB0aGlzLm9wdHMuZWxlbWVudC5wcm9wKFwicmVhZG9ubHlcIiwgZW5hYmxlZCk7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZUludGVyZmFjZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGFic3RyYWN0XG4gICAgICAgIG9wZW5lZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmNvbnRhaW5lcikgPyB0aGlzLmNvbnRhaW5lci5oYXNDbGFzcyhcInNlbGVjdDItZHJvcGRvd24tb3BlblwiKSA6IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGFic3RyYWN0XG4gICAgICAgIHBvc2l0aW9uRHJvcGRvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyICRkcm9wZG93biA9IHRoaXMuZHJvcGRvd24sXG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gdGhpcy5jb250YWluZXIsXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gY29udGFpbmVyLm9mZnNldCgpLFxuICAgICAgICAgICAgICAgIGhlaWdodCA9IGNvbnRhaW5lci5vdXRlckhlaWdodChmYWxzZSksXG4gICAgICAgICAgICAgICAgd2lkdGggPSBjb250YWluZXIub3V0ZXJXaWR0aChmYWxzZSksXG4gICAgICAgICAgICAgICAgZHJvcEhlaWdodCA9ICRkcm9wZG93bi5vdXRlckhlaWdodChmYWxzZSksXG4gICAgICAgICAgICAgICAgJHdpbmRvdyA9ICQod2luZG93KSxcbiAgICAgICAgICAgICAgICB3aW5kb3dXaWR0aCA9ICR3aW5kb3cud2lkdGgoKSxcbiAgICAgICAgICAgICAgICB3aW5kb3dIZWlnaHQgPSAkd2luZG93LmhlaWdodCgpLFxuICAgICAgICAgICAgICAgIHZpZXdQb3J0UmlnaHQgPSAkd2luZG93LnNjcm9sbExlZnQoKSArIHdpbmRvd1dpZHRoLFxuICAgICAgICAgICAgICAgIHZpZXdwb3J0Qm90dG9tID0gJHdpbmRvdy5zY3JvbGxUb3AoKSArIHdpbmRvd0hlaWdodCxcbiAgICAgICAgICAgICAgICBkcm9wVG9wID0gb2Zmc2V0LnRvcCArIGhlaWdodCxcbiAgICAgICAgICAgICAgICBkcm9wTGVmdCA9IG9mZnNldC5sZWZ0LFxuICAgICAgICAgICAgICAgIGVub3VnaFJvb21CZWxvdyA9IGRyb3BUb3AgKyBkcm9wSGVpZ2h0IDw9IHZpZXdwb3J0Qm90dG9tLFxuICAgICAgICAgICAgICAgIGVub3VnaFJvb21BYm92ZSA9IChvZmZzZXQudG9wIC0gZHJvcEhlaWdodCkgPj0gJHdpbmRvdy5zY3JvbGxUb3AoKSxcbiAgICAgICAgICAgICAgICBkcm9wV2lkdGggPSAkZHJvcGRvd24ub3V0ZXJXaWR0aChmYWxzZSksXG4gICAgICAgICAgICAgICAgZW5vdWdoUm9vbU9uUmlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRyb3BMZWZ0ICsgZHJvcFdpZHRoIDw9IHZpZXdQb3J0UmlnaHQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbm91Z2hSb29tT25MZWZ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXQubGVmdCArIHZpZXdQb3J0UmlnaHQgKyBjb250YWluZXIub3V0ZXJXaWR0aChmYWxzZSkgID4gZHJvcFdpZHRoO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYWJvdmVOb3cgPSAkZHJvcGRvd24uaGFzQ2xhc3MoXCJzZWxlY3QyLWRyb3AtYWJvdmVcIiksXG4gICAgICAgICAgICAgICAgYm9keU9mZnNldCxcbiAgICAgICAgICAgICAgICBhYm92ZSxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEaXJlY3Rpb24sXG4gICAgICAgICAgICAgICAgY3NzLFxuICAgICAgICAgICAgICAgIHJlc3VsdHNMaXN0Tm9kZTtcblxuICAgICAgICAgICAgLy8gYWx3YXlzIHByZWZlciB0aGUgY3VycmVudCBhYm92ZS9iZWxvdyBhbGlnbm1lbnQsIHVubGVzcyB0aGVyZSBpcyBub3QgZW5vdWdoIHJvb21cbiAgICAgICAgICAgIGlmIChhYm92ZU5vdykge1xuICAgICAgICAgICAgICAgIGFib3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWVub3VnaFJvb21BYm92ZSAmJiBlbm91Z2hSb29tQmVsb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRGlyZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYWJvdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFib3ZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKCFlbm91Z2hSb29tQmVsb3cgJiYgZW5vdWdoUm9vbUFib3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZURpcmVjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGFib3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vaWYgd2UgYXJlIGNoYW5naW5nIGRpcmVjdGlvbiB3ZSBuZWVkIHRvIGdldCBwb3NpdGlvbnMgd2hlbiBkcm9wZG93biBpcyBoaWRkZW47XG4gICAgICAgICAgICBpZiAoY2hhbmdlRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgJGRyb3Bkb3duLmhpZGUoKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLmNvbnRhaW5lci5vZmZzZXQoKTtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLmNvbnRhaW5lci5vdXRlckhlaWdodChmYWxzZSk7XG4gICAgICAgICAgICAgICAgd2lkdGggPSB0aGlzLmNvbnRhaW5lci5vdXRlcldpZHRoKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBkcm9wSGVpZ2h0ID0gJGRyb3Bkb3duLm91dGVySGVpZ2h0KGZhbHNlKTtcbiAgICAgICAgICAgICAgICB2aWV3UG9ydFJpZ2h0ID0gJHdpbmRvdy5zY3JvbGxMZWZ0KCkgKyB3aW5kb3dXaWR0aDtcbiAgICAgICAgICAgICAgICB2aWV3cG9ydEJvdHRvbSA9ICR3aW5kb3cuc2Nyb2xsVG9wKCkgKyB3aW5kb3dIZWlnaHQ7XG4gICAgICAgICAgICAgICAgZHJvcFRvcCA9IG9mZnNldC50b3AgKyBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgZHJvcExlZnQgPSBvZmZzZXQubGVmdDtcbiAgICAgICAgICAgICAgICBkcm9wV2lkdGggPSAkZHJvcGRvd24ub3V0ZXJXaWR0aChmYWxzZSk7XG4gICAgICAgICAgICAgICAgJGRyb3Bkb3duLnNob3coKTtcblxuICAgICAgICAgICAgICAgIC8vIGZpeCBzbyB0aGUgY3Vyc29yIGRvZXMgbm90IG1vdmUgdG8gdGhlIGxlZnQgd2l0aGluIHRoZSBzZWFyY2gtdGV4dGJveCBpbiBJRVxuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXNTZWFyY2goKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5kcm9wZG93bkF1dG9XaWR0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHNMaXN0Tm9kZSA9ICQoJy5zZWxlY3QyLXJlc3VsdHMnLCAkZHJvcGRvd24pWzBdO1xuICAgICAgICAgICAgICAgICRkcm9wZG93bi5hZGRDbGFzcygnc2VsZWN0Mi1kcm9wLWF1dG8td2lkdGgnKTtcbiAgICAgICAgICAgICAgICAkZHJvcGRvd24uY3NzKCd3aWR0aCcsICcnKTtcbiAgICAgICAgICAgICAgICAvLyBBZGQgc2Nyb2xsYmFyIHdpZHRoIHRvIGRyb3Bkb3duIGlmIHZlcnRpY2FsIHNjcm9sbGJhciBpcyBwcmVzZW50XG4gICAgICAgICAgICAgICAgZHJvcFdpZHRoID0gJGRyb3Bkb3duLm91dGVyV2lkdGgoZmFsc2UpICsgKHJlc3VsdHNMaXN0Tm9kZS5zY3JvbGxIZWlnaHQgPT09IHJlc3VsdHNMaXN0Tm9kZS5jbGllbnRIZWlnaHQgPyAwIDogc2Nyb2xsQmFyRGltZW5zaW9ucy53aWR0aCk7XG4gICAgICAgICAgICAgICAgZHJvcFdpZHRoID4gd2lkdGggPyB3aWR0aCA9IGRyb3BXaWR0aCA6IGRyb3BXaWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgIGRyb3BIZWlnaHQgPSAkZHJvcGRvd24ub3V0ZXJIZWlnaHQoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlQ2xhc3MoJ3NlbGVjdDItZHJvcC1hdXRvLXdpZHRoJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJiZWxvdy8gZHJvcHRvcDpcIiwgZHJvcFRvcCwgXCJkcm9wSGVpZ2h0XCIsIGRyb3BIZWlnaHQsIFwic3VtXCIsIChkcm9wVG9wK2Ryb3BIZWlnaHQpK1wiIHZpZXdwb3J0IGJvdHRvbVwiLCB2aWV3cG9ydEJvdHRvbSwgXCJlbm91Z2g/XCIsIGVub3VnaFJvb21CZWxvdyk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiYWJvdmUvIG9mZnNldC50b3BcIiwgb2Zmc2V0LnRvcCwgXCJkcm9wSGVpZ2h0XCIsIGRyb3BIZWlnaHQsIFwidG9wXCIsIChvZmZzZXQudG9wLWRyb3BIZWlnaHQpLCBcInNjcm9sbFRvcFwiLCB0aGlzLmJvZHkuc2Nyb2xsVG9wKCksIFwiZW5vdWdoP1wiLCBlbm91Z2hSb29tQWJvdmUpO1xuXG4gICAgICAgICAgICAvLyBmaXggcG9zaXRpb25pbmcgd2hlbiBib2R5IGhhcyBhbiBvZmZzZXQgYW5kIGlzIG5vdCBwb3NpdGlvbjogc3RhdGljXG4gICAgICAgICAgICBpZiAodGhpcy5ib2R5LmNzcygncG9zaXRpb24nKSAhPT0gJ3N0YXRpYycpIHtcbiAgICAgICAgICAgICAgICBib2R5T2Zmc2V0ID0gdGhpcy5ib2R5Lm9mZnNldCgpO1xuICAgICAgICAgICAgICAgIGRyb3BUb3AgLT0gYm9keU9mZnNldC50b3A7XG4gICAgICAgICAgICAgICAgZHJvcExlZnQgLT0gYm9keU9mZnNldC5sZWZ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWVub3VnaFJvb21PblJpZ2h0KCkgJiYgZW5vdWdoUm9vbU9uTGVmdCgpKSB7XG4gICAgICAgICAgICAgICAgZHJvcExlZnQgPSBvZmZzZXQubGVmdCArIHRoaXMuY29udGFpbmVyLm91dGVyV2lkdGgoZmFsc2UpIC0gZHJvcFdpZHRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjc3MgPSAge1xuICAgICAgICAgICAgICAgIGxlZnQ6IGRyb3BMZWZ0LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGFib3ZlKSB7XG4gICAgICAgICAgICAgICAgY3NzLnRvcCA9IG9mZnNldC50b3AgLSBkcm9wSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGNzcy5ib3R0b20gPSAnYXV0byc7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2xhc3MoXCJzZWxlY3QyLWRyb3AtYWJvdmVcIik7XG4gICAgICAgICAgICAgICAgJGRyb3Bkb3duLmFkZENsYXNzKFwic2VsZWN0Mi1kcm9wLWFib3ZlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3NzLnRvcCA9IGRyb3BUb3A7XG4gICAgICAgICAgICAgICAgY3NzLmJvdHRvbSA9ICdhdXRvJztcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDbGFzcyhcInNlbGVjdDItZHJvcC1hYm92ZVwiKTtcbiAgICAgICAgICAgICAgICAkZHJvcGRvd24ucmVtb3ZlQ2xhc3MoXCJzZWxlY3QyLWRyb3AtYWJvdmVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjc3MgPSAkLmV4dGVuZChjc3MsIGV2YWx1YXRlKHRoaXMub3B0cy5kcm9wZG93bkNzcywgdGhpcy5vcHRzLmVsZW1lbnQpKTtcblxuICAgICAgICAgICAgJGRyb3Bkb3duLmNzcyhjc3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGFic3RyYWN0XG4gICAgICAgIHNob3VsZE9wZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGV2ZW50O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vcGVuZWQoKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fZW5hYmxlZCA9PT0gZmFsc2UgfHwgdGhpcy5fcmVhZG9ubHkgPT09IHRydWUpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgZXZlbnQgPSAkLkV2ZW50KFwic2VsZWN0Mi1vcGVuaW5nXCIpO1xuICAgICAgICAgICAgdGhpcy5vcHRzLmVsZW1lbnQudHJpZ2dlcihldmVudCk7XG4gICAgICAgICAgICByZXR1cm4gIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGFic3RyYWN0XG4gICAgICAgIGNsZWFyRHJvcGRvd25BbGlnbm1lbnRQcmVmZXJlbmNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGNsZWFyIHRoZSBjbGFzc2VzIHVzZWQgdG8gZmlndXJlIG91dCB0aGUgcHJlZmVyZW5jZSBvZiB3aGVyZSB0aGUgZHJvcGRvd24gc2hvdWxkIGJlIG9wZW5lZFxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlQ2xhc3MoXCJzZWxlY3QyLWRyb3AtYWJvdmVcIik7XG4gICAgICAgICAgICB0aGlzLmRyb3Bkb3duLnJlbW92ZUNsYXNzKFwic2VsZWN0Mi1kcm9wLWFib3ZlXCIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcGVucyB0aGUgZHJvcGRvd25cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciBvciBub3QgZHJvcGRvd24gd2FzIG9wZW5lZC4gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZmFsc2UgaWYsIGZvciBleGFtcGxlLFxuICAgICAgICAgKiB0aGUgZHJvcGRvd24gaXMgYWxyZWFkeSBvcGVuLCBvciBpZiB0aGUgJ29wZW4nIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSBlbGVtZW50IGNhbGxlZCBwcmV2ZW50RGVmYXVsdCgpLlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gYWJzdHJhY3RcbiAgICAgICAgb3BlbjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuc2hvdWxkT3BlbigpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHRoaXMub3BlbmluZygpO1xuXG4gICAgICAgICAgICAvLyBPbmx5IGJpbmQgdGhlIGRvY3VtZW50IG1vdXNlbW92ZSB3aGVuIHRoZSBkcm9wZG93biBpcyB2aXNpYmxlXG4gICAgICAgICAgICAkZG9jdW1lbnQub24oXCJtb3VzZW1vdmUuc2VsZWN0MkV2ZW50XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgbGFzdE1vdXNlUG9zaXRpb24ueCA9IGUucGFnZVg7XG4gICAgICAgICAgICAgICAgbGFzdE1vdXNlUG9zaXRpb24ueSA9IGUucGFnZVk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBlcmZvcm1zIHRoZSBvcGVuaW5nIG9mIHRoZSBkcm9wZG93blxuICAgICAgICAgKi9cbiAgICAgICAgLy8gYWJzdHJhY3RcbiAgICAgICAgb3BlbmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2lkID0gdGhpcy5jb250YWluZXJFdmVudE5hbWUsXG4gICAgICAgICAgICAgICAgc2Nyb2xsID0gXCJzY3JvbGwuXCIgKyBjaWQsXG4gICAgICAgICAgICAgICAgcmVzaXplID0gXCJyZXNpemUuXCIrY2lkLFxuICAgICAgICAgICAgICAgIG9yaWVudCA9IFwib3JpZW50YXRpb25jaGFuZ2UuXCIrY2lkLFxuICAgICAgICAgICAgICAgIG1hc2s7XG5cbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENsYXNzKFwic2VsZWN0Mi1kcm9wZG93bi1vcGVuXCIpLmFkZENsYXNzKFwic2VsZWN0Mi1jb250YWluZXItYWN0aXZlXCIpO1xuXG4gICAgICAgICAgICB0aGlzLmNsZWFyRHJvcGRvd25BbGlnbm1lbnRQcmVmZXJlbmNlKCk7XG5cbiAgICAgICAgICAgIGlmKHRoaXMuZHJvcGRvd25bMF0gIT09IHRoaXMuYm9keS5jaGlsZHJlbigpLmxhc3QoKVswXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJvcGRvd24uZGV0YWNoKCkuYXBwZW5kVG8odGhpcy5ib2R5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY3JlYXRlIHRoZSBkcm9wZG93biBtYXNrIGlmIGRvZXNuJ3QgYWxyZWFkeSBleGlzdFxuICAgICAgICAgICAgbWFzayA9ICQoXCIjc2VsZWN0Mi1kcm9wLW1hc2tcIik7XG4gICAgICAgICAgICBpZiAobWFzay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBtYXNrID0gJChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICAgICAgICAgICAgICBtYXNrLmF0dHIoXCJpZFwiLFwic2VsZWN0Mi1kcm9wLW1hc2tcIikuYXR0cihcImNsYXNzXCIsXCJzZWxlY3QyLWRyb3AtbWFza1wiKTtcbiAgICAgICAgICAgICAgICBtYXNrLmhpZGUoKTtcbiAgICAgICAgICAgICAgICBtYXNrLmFwcGVuZFRvKHRoaXMuYm9keSk7XG4gICAgICAgICAgICAgICAgbWFzay5vbihcIm1vdXNlZG93biB0b3VjaHN0YXJ0IGNsaWNrXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgSUUgZnJvbSBnZW5lcmF0aW5nIGEgY2xpY2sgZXZlbnQgb24gdGhlIGJvZHlcbiAgICAgICAgICAgICAgICAgICAgcmVpbnNlcnRFbGVtZW50KG1hc2spO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkcm9wZG93biA9ICQoXCIjc2VsZWN0Mi1kcm9wXCIpLCBzZWxmO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZHJvcGRvd24ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZj1kcm9wZG93bi5kYXRhKFwic2VsZWN0MlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLm9wdHMuc2VsZWN0T25CbHVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RIaWdobGlnaHRlZCh7bm9Gb2N1czogdHJ1ZX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBlbnN1cmUgdGhlIG1hc2sgaXMgYWx3YXlzIHJpZ2h0IGJlZm9yZSB0aGUgZHJvcGRvd25cbiAgICAgICAgICAgIGlmICh0aGlzLmRyb3Bkb3duLnByZXYoKVswXSAhPT0gbWFza1swXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJvcGRvd24uYmVmb3JlKG1hc2spO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBtb3ZlIHRoZSBnbG9iYWwgaWQgdG8gdGhlIGNvcnJlY3QgZHJvcGRvd25cbiAgICAgICAgICAgICQoXCIjc2VsZWN0Mi1kcm9wXCIpLnJlbW92ZUF0dHIoXCJpZFwiKTtcbiAgICAgICAgICAgIHRoaXMuZHJvcGRvd24uYXR0cihcImlkXCIsIFwic2VsZWN0Mi1kcm9wXCIpO1xuXG4gICAgICAgICAgICAvLyBzaG93IHRoZSBlbGVtZW50c1xuICAgICAgICAgICAgbWFzay5zaG93KCk7XG5cbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25Ecm9wZG93bigpO1xuICAgICAgICAgICAgdGhpcy5kcm9wZG93bi5zaG93KCk7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uRHJvcGRvd24oKTtcblxuICAgICAgICAgICAgdGhpcy5kcm9wZG93bi5hZGRDbGFzcyhcInNlbGVjdDItZHJvcC1hY3RpdmVcIik7XG5cbiAgICAgICAgICAgIC8vIGF0dGFjaCBsaXN0ZW5lcnMgdG8gZXZlbnRzIHRoYXQgY2FuIGNoYW5nZSB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbnRhaW5lciBhbmQgdGh1cyByZXF1aXJlXG4gICAgICAgICAgICAvLyB0aGUgcG9zaXRpb24gb2YgdGhlIGRyb3Bkb3duIHRvIGJlIHVwZGF0ZWQgYXMgd2VsbCBzbyBpdCBkb2VzIG5vdCBjb21lIHVuZ2x1ZWQgZnJvbSB0aGUgY29udGFpbmVyXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5wYXJlbnRzKCkuYWRkKHdpbmRvdykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5vbihyZXNpemUrXCIgXCIrc2Nyb2xsK1wiIFwiK29yaWVudCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQub3BlbmVkKCkpIHRoYXQucG9zaXRpb25Ecm9wZG93bigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGFic3RyYWN0XG4gICAgICAgIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMub3BlbmVkKCkpIHJldHVybjtcblxuICAgICAgICAgICAgdmFyIGNpZCA9IHRoaXMuY29udGFpbmVyRXZlbnROYW1lLFxuICAgICAgICAgICAgICAgIHNjcm9sbCA9IFwic2Nyb2xsLlwiICsgY2lkLFxuICAgICAgICAgICAgICAgIHJlc2l6ZSA9IFwicmVzaXplLlwiK2NpZCxcbiAgICAgICAgICAgICAgICBvcmllbnQgPSBcIm9yaWVudGF0aW9uY2hhbmdlLlwiK2NpZDtcblxuICAgICAgICAgICAgLy8gdW5iaW5kIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIucGFyZW50cygpLmFkZCh3aW5kb3cpLmVhY2goZnVuY3Rpb24gKCkgeyAkKHRoaXMpLm9mZihzY3JvbGwpLm9mZihyZXNpemUpLm9mZihvcmllbnQpOyB9KTtcblxuICAgICAgICAgICAgdGhpcy5jbGVhckRyb3Bkb3duQWxpZ25tZW50UHJlZmVyZW5jZSgpO1xuXG4gICAgICAgICAgICAkKFwiI3NlbGVjdDItZHJvcC1tYXNrXCIpLmhpZGUoKTtcbiAgICAgICAgICAgIHRoaXMuZHJvcGRvd24ucmVtb3ZlQXR0cihcImlkXCIpOyAvLyBvbmx5IHRoZSBhY3RpdmUgZHJvcGRvd24gaGFzIHRoZSBzZWxlY3QyLWRyb3AgaWRcbiAgICAgICAgICAgIHRoaXMuZHJvcGRvd24uaGlkZSgpO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlQ2xhc3MoXCJzZWxlY3QyLWRyb3Bkb3duLW9wZW5cIikucmVtb3ZlQ2xhc3MoXCJzZWxlY3QyLWNvbnRhaW5lci1hY3RpdmVcIik7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdHMuZW1wdHkoKTtcblxuICAgICAgICAgICAgLy8gTm93IHRoYXQgdGhlIGRyb3Bkb3duIGlzIGNsb3NlZCwgdW5iaW5kIHRoZSBnbG9iYWwgZG9jdW1lbnQgbW91c2Vtb3ZlIGV2ZW50XG4gICAgICAgICAgICAkZG9jdW1lbnQub2ZmKFwibW91c2Vtb3ZlLnNlbGVjdDJFdmVudFwiKTtcblxuICAgICAgICAgICAgdGhpcy5jbGVhclNlYXJjaCgpO1xuICAgICAgICAgICAgdGhpcy5zZWFyY2gucmVtb3ZlQ2xhc3MoXCJzZWxlY3QyLWFjdGl2ZVwiKTtcbiAgICAgICAgICAgIHRoaXMub3B0cy5lbGVtZW50LnRyaWdnZXIoJC5FdmVudChcInNlbGVjdDItY2xvc2VcIikpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcGVucyBjb250cm9sLCBzZXRzIGlucHV0IHZhbHVlLCBhbmQgdXBkYXRlcyByZXN1bHRzLlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gYWJzdHJhY3RcbiAgICAgICAgZXh0ZXJuYWxTZWFyY2g6IGZ1bmN0aW9uICh0ZXJtKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoLnZhbCh0ZXJtKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUmVzdWx0cyhmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gYWJzdHJhY3RcbiAgICAgICAgY2xlYXJTZWFyY2g6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8vYWJzdHJhY3RcbiAgICAgICAgZ2V0TWF4aW11bVNlbGVjdGlvblNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGV2YWx1YXRlKHRoaXMub3B0cy5tYXhpbXVtU2VsZWN0aW9uU2l6ZSwgdGhpcy5vcHRzLmVsZW1lbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGFic3RyYWN0XG4gICAgICAgIGVuc3VyZUhpZ2hsaWdodFZpc2libGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gdGhpcy5yZXN1bHRzLCBjaGlsZHJlbiwgaW5kZXgsIGNoaWxkLCBoYiwgcmIsIHksIG1vcmUsIHRvcE9mZnNldDtcblxuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmhpZ2hsaWdodCgpO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggPCAwKSByZXR1cm47XG5cbiAgICAgICAgICAgIGlmIChpbmRleCA9PSAwKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZmlyc3QgZWxlbWVudCBpcyBoaWdobGlnaHRlZCBzY3JvbGwgYWxsIHRoZSB3YXkgdG8gdGhlIHRvcCxcbiAgICAgICAgICAgICAgICAvLyB0aGF0IHdheSBhbnkgdW5zZWxlY3RhYmxlIGhlYWRlcnMgYWJvdmUgaXQgd2lsbCBhbHNvIGJlIHNjcm9sbGVkXG4gICAgICAgICAgICAgICAgLy8gaW50byB2aWV3XG5cbiAgICAgICAgICAgICAgICByZXN1bHRzLnNjcm9sbFRvcCgwKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy5maW5kSGlnaGxpZ2h0YWJsZUNob2ljZXMoKS5maW5kKCcuc2VsZWN0Mi1yZXN1bHQtbGFiZWwnKTtcblxuICAgICAgICAgICAgY2hpbGQgPSAkKGNoaWxkcmVuW2luZGV4XSk7XG5cbiAgICAgICAgICAgIHRvcE9mZnNldCA9IChjaGlsZC5vZmZzZXQoKSB8fCB7fSkudG9wIHx8IDA7XG5cbiAgICAgICAgICAgIGhiID0gdG9wT2Zmc2V0ICsgY2hpbGQub3V0ZXJIZWlnaHQodHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgdGhlIGxhc3QgY2hpbGQgbGV0cyBhbHNvIG1ha2Ugc3VyZSBzZWxlY3QyLW1vcmUtcmVzdWx0cyBpcyB2aXNpYmxlXG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IGNoaWxkcmVuLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBtb3JlID0gcmVzdWx0cy5maW5kKFwibGkuc2VsZWN0Mi1tb3JlLXJlc3VsdHNcIik7XG4gICAgICAgICAgICAgICAgaWYgKG1vcmUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBoYiA9IG1vcmUub2Zmc2V0KCkudG9wICsgbW9yZS5vdXRlckhlaWdodCh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJiID0gcmVzdWx0cy5vZmZzZXQoKS50b3AgKyByZXN1bHRzLm91dGVySGVpZ2h0KGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChoYiA+IHJiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5zY3JvbGxUb3AocmVzdWx0cy5zY3JvbGxUb3AoKSArIChoYiAtIHJiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5ID0gdG9wT2Zmc2V0IC0gcmVzdWx0cy5vZmZzZXQoKS50b3A7XG5cbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgdG9wIG9mIHRoZSBlbGVtZW50IGlzIHZpc2libGVcbiAgICAgICAgICAgIGlmICh5IDwgMCAmJiBjaGlsZC5jc3MoJ2Rpc3BsYXknKSAhPSAnbm9uZScgKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5zY3JvbGxUb3AocmVzdWx0cy5zY3JvbGxUb3AoKSArIHkpOyAvLyB5IGlzIG5lZ2F0aXZlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gYWJzdHJhY3RcbiAgICAgICAgZmluZEhpZ2hsaWdodGFibGVDaG9pY2VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdHMuZmluZChcIi5zZWxlY3QyLXJlc3VsdC1zZWxlY3RhYmxlOm5vdCguc2VsZWN0Mi1kaXNhYmxlZCk6bm90KC5zZWxlY3QyLXNlbGVjdGVkKVwiKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBhYnN0cmFjdFxuICAgICAgICBtb3ZlSGlnaGxpZ2h0OiBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgIHZhciBjaG9pY2VzID0gdGhpcy5maW5kSGlnaGxpZ2h0YWJsZUNob2ljZXMoKSxcbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuaGlnaGxpZ2h0KCk7XG5cbiAgICAgICAgICAgIHdoaWxlIChpbmRleCA+IC0xICYmIGluZGV4IDwgY2hvaWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpbmRleCArPSBkZWx0YTtcbiAgICAgICAgICAgICAgICB2YXIgY2hvaWNlID0gJChjaG9pY2VzW2luZGV4XSk7XG4gICAgICAgICAgICAgICAgaWYgKGNob2ljZS5oYXNDbGFzcyhcInNlbGVjdDItcmVzdWx0LXNlbGVjdGFibGVcIikgJiYgIWNob2ljZS5oYXNDbGFzcyhcInNlbGVjdDItZGlzYWJsZWRcIikgJiYgIWNob2ljZS5oYXNDbGFzcyhcInNlbGVjdDItc2VsZWN0ZWRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHQoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gYWJzdHJhY3RcbiAgICAgICAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBjaG9pY2VzID0gdGhpcy5maW5kSGlnaGxpZ2h0YWJsZUNob2ljZXMoKSxcbiAgICAgICAgICAgICAgICBjaG9pY2UsXG4gICAgICAgICAgICAgICAgZGF0YTtcblxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXhPZihjaG9pY2VzLmZpbHRlcihcIi5zZWxlY3QyLWhpZ2hsaWdodGVkXCIpWzBdLCBjaG9pY2VzLmdldCgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGluZGV4ID49IGNob2ljZXMubGVuZ3RoKSBpbmRleCA9IGNob2ljZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmIChpbmRleCA8IDApIGluZGV4ID0gMDtcblxuICAgICAgICAgICAgdGhpcy5yZW1vdmVIaWdobGlnaHQoKTtcblxuICAgICAgICAgICAgY2hvaWNlID0gJChjaG9pY2VzW2luZGV4XSk7XG4gICAgICAgICAgICBjaG9pY2UuYWRkQ2xhc3MoXCJzZWxlY3QyLWhpZ2hsaWdodGVkXCIpO1xuXG4gICAgICAgICAgICAvLyBlbnN1cmUgYXNzaXN0aXZlIHRlY2hub2xvZ3kgY2FuIGRldGVybWluZSB0aGUgYWN0aXZlIGNob2ljZVxuICAgICAgICAgICAgdGhpcy5zZWFyY2guYXR0cihcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiLCBjaG9pY2UuZmluZChcIi5zZWxlY3QyLXJlc3VsdC1sYWJlbFwiKS5hdHRyKFwiaWRcIikpO1xuXG4gICAgICAgICAgICB0aGlzLmVuc3VyZUhpZ2hsaWdodFZpc2libGUoKTtcblxuICAgICAgICAgICAgdGhpcy5saXZlUmVnaW9uLnRleHQoY2hvaWNlLnRleHQoKSk7XG5cbiAgICAgICAgICAgIGRhdGEgPSBjaG9pY2UuZGF0YShcInNlbGVjdDItZGF0YVwiKTtcbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRzLmVsZW1lbnQudHJpZ2dlcih7IHR5cGU6IFwic2VsZWN0Mi1oaWdobGlnaHRcIiwgdmFsOiB0aGlzLmlkKGRhdGEpLCBjaG9pY2U6IGRhdGEgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlSGlnaGxpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0cy5maW5kKFwiLnNlbGVjdDItaGlnaGxpZ2h0ZWRcIikucmVtb3ZlQ2xhc3MoXCJzZWxlY3QyLWhpZ2hsaWdodGVkXCIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRvdWNoTW92ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fdG91Y2hNb3ZlZCA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXJUb3VjaE1vdmVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLl90b3VjaE1vdmVkID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gYWJzdHJhY3RcbiAgICAgICAgY291bnRTZWxlY3RhYmxlUmVzdWx0czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5kSGlnaGxpZ2h0YWJsZUNob2ljZXMoKS5sZW5ndGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gYWJzdHJhY3RcbiAgICAgICAgaGlnaGxpZ2h0VW5kZXJFdmVudDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZWwgPSAkKGV2ZW50LnRhcmdldCkuY2xvc2VzdChcIi5zZWxlY3QyLXJlc3VsdC1zZWxlY3RhYmxlXCIpO1xuICAgICAgICAgICAgaWYgKGVsLmxlbmd0aCA+IDAgJiYgIWVsLmlzKFwiLnNlbGVjdDItaGlnaGxpZ2h0ZWRcIikpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hvaWNlcyA9IHRoaXMuZmluZEhpZ2hsaWdodGFibGVDaG9pY2VzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHQoY2hvaWNlcy5pbmRleChlbCkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlbC5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBvdmVyIGFuIHVuc2VsZWN0YWJsZSBpdGVtIHJlbW92ZSBhbGwgaGlnaGxpZ2h0c1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlSGlnaGxpZ2h0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gYWJzdHJhY3RcbiAgICAgICAgbG9hZE1vcmVJZk5lZWRlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB0aGlzLnJlc3VsdHMsXG4gICAgICAgICAgICAgICAgbW9yZSA9IHJlc3VsdHMuZmluZChcImxpLnNlbGVjdDItbW9yZS1yZXN1bHRzXCIpLFxuICAgICAgICAgICAgICAgIGJlbG93LCAvLyBwaXhlbHMgdGhlIGVsZW1lbnQgaXMgYmVsb3cgdGhlIHNjcm9sbCBmb2xkLCBiZWxvdz09MCBpcyB3aGVuIHRoZSBlbGVtZW50IGlzIHN0YXJ0aW5nIHRvIGJlIHZpc2libGVcbiAgICAgICAgICAgICAgICBwYWdlID0gdGhpcy5yZXN1bHRzUGFnZSArIDEsXG4gICAgICAgICAgICAgICAgc2VsZj10aGlzLFxuICAgICAgICAgICAgICAgIHRlcm09dGhpcy5zZWFyY2gudmFsKCksXG4gICAgICAgICAgICAgICAgY29udGV4dD10aGlzLmNvbnRleHQ7XG5cbiAgICAgICAgICAgIGlmIChtb3JlLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgICAgICAgYmVsb3cgPSBtb3JlLm9mZnNldCgpLnRvcCAtIHJlc3VsdHMub2Zmc2V0KCkudG9wIC0gcmVzdWx0cy5oZWlnaHQoKTtcblxuICAgICAgICAgICAgaWYgKGJlbG93IDw9IHRoaXMub3B0cy5sb2FkTW9yZVBhZGRpbmcpIHtcbiAgICAgICAgICAgICAgICBtb3JlLmFkZENsYXNzKFwic2VsZWN0Mi1hY3RpdmVcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRzLnF1ZXJ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMub3B0cy5lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVybTogdGVybSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2U6IHBhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcjogdGhpcy5vcHRzLm1hdGNoZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogdGhpcy5iaW5kKGZ1bmN0aW9uIChkYXRhKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIGEgcmVzcG9uc2UgaWYgdGhlIHNlbGVjdDIgaGFzIGJlZW4gY2xvc2VkIGJlZm9yZSBpdCB3YXMgcmVjZWl2ZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxmLm9wZW5lZCgpKSByZXR1cm47XG5cblxuICAgICAgICAgICAgICAgICAgICBzZWxmLm9wdHMucG9wdWxhdGVSZXN1bHRzLmNhbGwodGhpcywgcmVzdWx0cywgZGF0YS5yZXN1bHRzLCB7dGVybTogdGVybSwgcGFnZTogcGFnZSwgY29udGV4dDpjb250ZXh0fSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucG9zdHByb2Nlc3NSZXN1bHRzKGRhdGEsIGZhbHNlLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEubW9yZT09PXRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vcmUuZGV0YWNoKCkuYXBwZW5kVG8ocmVzdWx0cykuaHRtbChzZWxmLm9wdHMuZXNjYXBlTWFya3VwKGV2YWx1YXRlKHNlbGYub3B0cy5mb3JtYXRMb2FkTW9yZSwgc2VsZi5vcHRzLmVsZW1lbnQsIHBhZ2UrMSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBzZWxmLmxvYWRNb3JlSWZOZWVkZWQoKTsgfSwgMTApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9yZS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWxmLnBvc2l0aW9uRHJvcGRvd24oKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZXN1bHRzUGFnZSA9IHBhZ2U7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29udGV4dCA9IGRhdGEuY29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRzLmVsZW1lbnQudHJpZ2dlcih7IHR5cGU6IFwic2VsZWN0Mi1sb2FkZWRcIiwgaXRlbXM6IGRhdGEgfSk7XG4gICAgICAgICAgICAgICAgfSl9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmYXVsdCB0b2tlbml6ZXIgZnVuY3Rpb24gd2hpY2ggZG9lcyBub3RoaW5nXG4gICAgICAgICAqL1xuICAgICAgICB0b2tlbml6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGluaXRpYWwgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgY2FsbCB0byB0aGlzIG1ldGhvZCByaWdodCBhZnRlciB0aGUgZHJvcGRvd24gaGFzIGJlZW4gb3BlbmVkXG4gICAgICAgICAqL1xuICAgICAgICAvLyBhYnN0cmFjdFxuICAgICAgICB1cGRhdGVSZXN1bHRzOiBmdW5jdGlvbiAoaW5pdGlhbCkge1xuICAgICAgICAgICAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoLFxuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSB0aGlzLnJlc3VsdHMsXG4gICAgICAgICAgICAgICAgb3B0cyA9IHRoaXMub3B0cyxcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIHRlcm0gPSBzZWFyY2gudmFsKCksXG4gICAgICAgICAgICAgICAgbGFzdFRlcm0gPSAkLmRhdGEodGhpcy5jb250YWluZXIsIFwic2VsZWN0Mi1sYXN0LXRlcm1cIiksXG4gICAgICAgICAgICAgICAgLy8gc2VxdWVuY2UgbnVtYmVyIHVzZWQgdG8gZHJvcCBvdXQtb2Ytb3JkZXIgcmVzcG9uc2VzXG4gICAgICAgICAgICAgICAgcXVlcnlOdW1iZXI7XG5cbiAgICAgICAgICAgIC8vIHByZXZlbnQgZHVwbGljYXRlIHF1ZXJpZXMgYWdhaW5zdCB0aGUgc2FtZSB0ZXJtXG4gICAgICAgICAgICBpZiAoaW5pdGlhbCAhPT0gdHJ1ZSAmJiBsYXN0VGVybSAmJiBlcXVhbCh0ZXJtLCBsYXN0VGVybSkpIHJldHVybjtcblxuICAgICAgICAgICAgJC5kYXRhKHRoaXMuY29udGFpbmVyLCBcInNlbGVjdDItbGFzdC10ZXJtXCIsIHRlcm0pO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGUgc2VhcmNoIGlzIGN1cnJlbnRseSBoaWRkZW4gd2UgZG8gbm90IGFsdGVyIHRoZSByZXN1bHRzXG4gICAgICAgICAgICBpZiAoaW5pdGlhbCAhPT0gdHJ1ZSAmJiAodGhpcy5zaG93U2VhcmNoSW5wdXQgPT09IGZhbHNlIHx8ICF0aGlzLm9wZW5lZCgpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gcG9zdFJlbmRlcigpIHtcbiAgICAgICAgICAgICAgICBzZWFyY2gucmVtb3ZlQ2xhc3MoXCJzZWxlY3QyLWFjdGl2ZVwiKTtcbiAgICAgICAgICAgICAgICBzZWxmLnBvc2l0aW9uRHJvcGRvd24oKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0cy5maW5kKCcuc2VsZWN0Mi1uby1yZXN1bHRzLC5zZWxlY3QyLXNlbGVjdGlvbi1saW1pdCwuc2VsZWN0Mi1zZWFyY2hpbmcnKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5saXZlUmVnaW9uLnRleHQocmVzdWx0cy50ZXh0KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5saXZlUmVnaW9uLnRleHQoc2VsZi5vcHRzLmZvcm1hdE1hdGNoZXMocmVzdWx0cy5maW5kKCcuc2VsZWN0Mi1yZXN1bHQtc2VsZWN0YWJsZTpub3QoXCIuc2VsZWN0Mi1zZWxlY3RlZFwiKScpLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gcmVuZGVyKGh0bWwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLmh0bWwoaHRtbCk7XG4gICAgICAgICAgICAgICAgcG9zdFJlbmRlcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBxdWVyeU51bWJlciA9ICsrdGhpcy5xdWVyeUNvdW50O1xuXG4gICAgICAgICAgICB2YXIgbWF4U2VsU2l6ZSA9IHRoaXMuZ2V0TWF4aW11bVNlbGVjdGlvblNpemUoKTtcbiAgICAgICAgICAgIGlmIChtYXhTZWxTaXplID49MSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGEoKTtcbiAgICAgICAgICAgICAgICBpZiAoJC5pc0FycmF5KGRhdGEpICYmIGRhdGEubGVuZ3RoID49IG1heFNlbFNpemUgJiYgY2hlY2tGb3JtYXR0ZXIob3B0cy5mb3JtYXRTZWxlY3Rpb25Ub29CaWcsIFwiZm9ybWF0U2VsZWN0aW9uVG9vQmlnXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcihcIjxsaSBjbGFzcz0nc2VsZWN0Mi1zZWxlY3Rpb24tbGltaXQnPlwiICsgZXZhbHVhdGUob3B0cy5mb3JtYXRTZWxlY3Rpb25Ub29CaWcsIG9wdHMuZWxlbWVudCwgbWF4U2VsU2l6ZSkgKyBcIjwvbGk+XCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VhcmNoLnZhbCgpLmxlbmd0aCA8IG9wdHMubWluaW11bUlucHV0TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrRm9ybWF0dGVyKG9wdHMuZm9ybWF0SW5wdXRUb29TaG9ydCwgXCJmb3JtYXRJbnB1dFRvb1Nob3J0XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcihcIjxsaSBjbGFzcz0nc2VsZWN0Mi1uby1yZXN1bHRzJz5cIiArIGV2YWx1YXRlKG9wdHMuZm9ybWF0SW5wdXRUb29TaG9ydCwgb3B0cy5lbGVtZW50LCBzZWFyY2gudmFsKCksIG9wdHMubWluaW11bUlucHV0TGVuZ3RoKSArIFwiPC9saT5cIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyKFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbCAmJiB0aGlzLnNob3dTZWFyY2gpIHRoaXMuc2hvd1NlYXJjaCh0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHRzLm1heGltdW1JbnB1dExlbmd0aCAmJiBzZWFyY2gudmFsKCkubGVuZ3RoID4gb3B0cy5tYXhpbXVtSW5wdXRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tGb3JtYXR0ZXIob3B0cy5mb3JtYXRJbnB1dFRvb0xvbmcsIFwiZm9ybWF0SW5wdXRUb29Mb25nXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcihcIjxsaSBjbGFzcz0nc2VsZWN0Mi1uby1yZXN1bHRzJz5cIiArIGV2YWx1YXRlKG9wdHMuZm9ybWF0SW5wdXRUb29Mb25nLCBvcHRzLmVsZW1lbnQsIHNlYXJjaC52YWwoKSwgb3B0cy5tYXhpbXVtSW5wdXRMZW5ndGgpICsgXCI8L2xpPlwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXIoXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdHMuZm9ybWF0U2VhcmNoaW5nICYmIHRoaXMuZmluZEhpZ2hsaWdodGFibGVDaG9pY2VzKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyKFwiPGxpIGNsYXNzPSdzZWxlY3QyLXNlYXJjaGluZyc+XCIgKyBldmFsdWF0ZShvcHRzLmZvcm1hdFNlYXJjaGluZywgb3B0cy5lbGVtZW50KSArIFwiPC9saT5cIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlYXJjaC5hZGRDbGFzcyhcInNlbGVjdDItYWN0aXZlXCIpO1xuXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUhpZ2hsaWdodCgpO1xuXG4gICAgICAgICAgICAvLyBnaXZlIHRoZSB0b2tlbml6ZXIgYSBjaGFuY2UgdG8gcHJlLXByb2Nlc3MgdGhlIGlucHV0XG4gICAgICAgICAgICBpbnB1dCA9IHRoaXMudG9rZW5pemUoKTtcbiAgICAgICAgICAgIGlmIChpbnB1dCAhPSB1bmRlZmluZWQgJiYgaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNlYXJjaC52YWwoaW5wdXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnJlc3VsdHNQYWdlID0gMTtcblxuICAgICAgICAgICAgb3B0cy5xdWVyeSh7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogb3B0cy5lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB0ZXJtOiBzZWFyY2gudmFsKCksXG4gICAgICAgICAgICAgICAgICAgIHBhZ2U6IHRoaXMucmVzdWx0c1BhZ2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXI6IG9wdHMubWF0Y2hlcixcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IHRoaXMuYmluZChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBkZWY7IC8vIGRlZmF1bHQgY2hvaWNlXG5cbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgb2xkIHJlc3BvbnNlc1xuICAgICAgICAgICAgICAgIGlmIChxdWVyeU51bWJlciAhPSB0aGlzLnF1ZXJ5Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgYSByZXNwb25zZSBpZiB0aGUgc2VsZWN0MiBoYXMgYmVlbiBjbG9zZWQgYmVmb3JlIGl0IHdhcyByZWNlaXZlZFxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5vcGVuZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaC5yZW1vdmVDbGFzcyhcInNlbGVjdDItYWN0aXZlXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIGFqYXggZXJyb3JcbiAgICAgICAgICAgICAgICBpZihkYXRhLmhhc0Vycm9yICE9PSB1bmRlZmluZWQgJiYgY2hlY2tGb3JtYXR0ZXIob3B0cy5mb3JtYXRBamF4RXJyb3IsIFwiZm9ybWF0QWpheEVycm9yXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcihcIjxsaSBjbGFzcz0nc2VsZWN0Mi1hamF4LWVycm9yJz5cIiArIGV2YWx1YXRlKG9wdHMuZm9ybWF0QWpheEVycm9yLCBvcHRzLmVsZW1lbnQsIGRhdGEuanFYSFIsIGRhdGEudGV4dFN0YXR1cywgZGF0YS5lcnJvclRocm93bikgKyBcIjwvbGk+XCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gc2F2ZSBjb250ZXh0LCBpZiBhbnlcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQgPSAoZGF0YS5jb250ZXh0PT09dW5kZWZpbmVkKSA/IG51bGwgOiBkYXRhLmNvbnRleHQ7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgZGVmYXVsdCBjaG9pY2UgYW5kIHByZXBlbmQgaXQgdG8gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRzLmNyZWF0ZVNlYXJjaENob2ljZSAmJiBzZWFyY2gudmFsKCkgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmID0gdGhpcy5vcHRzLmNyZWF0ZVNlYXJjaENob2ljZS5jYWxsKHNlbGYsIHNlYXJjaC52YWwoKSwgZGF0YS5yZXN1bHRzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZiAhPT0gdW5kZWZpbmVkICYmIGRlZiAhPT0gbnVsbCAmJiBzZWxmLmlkKGRlZikgIT09IHVuZGVmaW5lZCAmJiBzZWxmLmlkKGRlZikgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkKGRhdGEucmVzdWx0cykuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVxdWFsKHNlbGYuaWQodGhpcyksIHNlbGYuaWQoZGVmKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRzLmNyZWF0ZVNlYXJjaENob2ljZVBvc2l0aW9uKGRhdGEucmVzdWx0cywgZGVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChkYXRhLnJlc3VsdHMubGVuZ3RoID09PSAwICYmIGNoZWNrRm9ybWF0dGVyKG9wdHMuZm9ybWF0Tm9NYXRjaGVzLCBcImZvcm1hdE5vTWF0Y2hlc1wiKSkge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXIoXCI8bGkgY2xhc3M9J3NlbGVjdDItbm8tcmVzdWx0cyc+XCIgKyBldmFsdWF0ZShvcHRzLmZvcm1hdE5vTWF0Y2hlcywgb3B0cy5lbGVtZW50LCBzZWFyY2gudmFsKCkpICsgXCI8L2xpPlwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc3VsdHMuZW1wdHkoKTtcbiAgICAgICAgICAgICAgICBzZWxmLm9wdHMucG9wdWxhdGVSZXN1bHRzLmNhbGwodGhpcywgcmVzdWx0cywgZGF0YS5yZXN1bHRzLCB7dGVybTogc2VhcmNoLnZhbCgpLCBwYWdlOiB0aGlzLnJlc3VsdHNQYWdlLCBjb250ZXh0Om51bGx9KTtcblxuICAgICAgICAgICAgICAgIGlmIChkYXRhLm1vcmUgPT09IHRydWUgJiYgY2hlY2tGb3JtYXR0ZXIob3B0cy5mb3JtYXRMb2FkTW9yZSwgXCJmb3JtYXRMb2FkTW9yZVwiKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLmFwcGVuZChcIjxsaSBjbGFzcz0nc2VsZWN0Mi1tb3JlLXJlc3VsdHMnPlwiICsgb3B0cy5lc2NhcGVNYXJrdXAoZXZhbHVhdGUob3B0cy5mb3JtYXRMb2FkTW9yZSwgb3B0cy5lbGVtZW50LCB0aGlzLnJlc3VsdHNQYWdlKSkgKyBcIjwvbGk+XCIpO1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHsgc2VsZi5sb2FkTW9yZUlmTmVlZGVkKCk7IH0sIDEwKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnBvc3Rwcm9jZXNzUmVzdWx0cyhkYXRhLCBpbml0aWFsKTtcblxuICAgICAgICAgICAgICAgIHBvc3RSZW5kZXIoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMub3B0cy5lbGVtZW50LnRyaWdnZXIoeyB0eXBlOiBcInNlbGVjdDItbG9hZGVkXCIsIGl0ZW1zOiBkYXRhIH0pO1xuICAgICAgICAgICAgfSl9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBhYnN0cmFjdFxuICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBhYnN0cmFjdFxuICAgICAgICBibHVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBpZiBzZWxlY3RPbkJsdXIgPT0gdHJ1ZSwgc2VsZWN0IHRoZSBjdXJyZW50bHkgaGlnaGxpZ2h0ZWQgb3B0aW9uXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLnNlbGVjdE9uQmx1cilcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdEhpZ2hsaWdodGVkKHtub0ZvY3VzOiB0cnVlfSk7XG5cbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUNsYXNzKFwic2VsZWN0Mi1jb250YWluZXItYWN0aXZlXCIpO1xuICAgICAgICAgICAgLy8gc3lub255bW91cyB0byAuaXMoJzpmb2N1cycpLCB3aGljaCBpcyBhdmFpbGFibGUgaW4ganF1ZXJ5ID49IDEuNlxuICAgICAgICAgICAgaWYgKHRoaXMuc2VhcmNoWzBdID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7IHRoaXMuc2VhcmNoLmJsdXIoKTsgfVxuICAgICAgICAgICAgdGhpcy5jbGVhclNlYXJjaCgpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uZmluZChcIi5zZWxlY3QyLXNlYXJjaC1jaG9pY2UtZm9jdXNcIikucmVtb3ZlQ2xhc3MoXCJzZWxlY3QyLXNlYXJjaC1jaG9pY2UtZm9jdXNcIik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gYWJzdHJhY3RcbiAgICAgICAgZm9jdXNTZWFyY2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvY3VzKHRoaXMuc2VhcmNoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBhYnN0cmFjdFxuICAgICAgICBzZWxlY3RIaWdobGlnaHRlZDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl90b3VjaE1vdmVkKSB7XG4gICAgICAgICAgICAgIHRoaXMuY2xlYXJUb3VjaE1vdmVkKCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbmRleD10aGlzLmhpZ2hsaWdodCgpLFxuICAgICAgICAgICAgICAgIGhpZ2hsaWdodGVkPXRoaXMucmVzdWx0cy5maW5kKFwiLnNlbGVjdDItaGlnaGxpZ2h0ZWRcIiksXG4gICAgICAgICAgICAgICAgZGF0YSA9IGhpZ2hsaWdodGVkLmNsb3Nlc3QoJy5zZWxlY3QyLXJlc3VsdCcpLmRhdGEoXCJzZWxlY3QyLWRhdGFcIik7XG5cbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHQoaW5kZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMub25TZWxlY3QoZGF0YSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ub0ZvY3VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGFic3RyYWN0XG4gICAgICAgIGdldFBsYWNlaG9sZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGxhY2Vob2xkZXJPcHRpb247XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRzLmVsZW1lbnQuYXR0cihcInBsYWNlaG9sZGVyXCIpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRzLmVsZW1lbnQuYXR0cihcImRhdGEtcGxhY2Vob2xkZXJcIikgfHwgLy8ganF1ZXJ5IDEuNCBjb21wYXRcbiAgICAgICAgICAgICAgICB0aGlzLm9wdHMuZWxlbWVudC5kYXRhKFwicGxhY2Vob2xkZXJcIikgfHxcbiAgICAgICAgICAgICAgICB0aGlzLm9wdHMucGxhY2Vob2xkZXIgfHxcbiAgICAgICAgICAgICAgICAoKHBsYWNlaG9sZGVyT3B0aW9uID0gdGhpcy5nZXRQbGFjZWhvbGRlck9wdGlvbigpKSAhPT0gdW5kZWZpbmVkID8gcGxhY2Vob2xkZXJPcHRpb24udGV4dCgpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBhYnN0cmFjdFxuICAgICAgICBnZXRQbGFjZWhvbGRlck9wdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RPcHRpb24gPSB0aGlzLnNlbGVjdC5jaGlsZHJlbignb3B0aW9uJykuZmlyc3QoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRzLnBsYWNlaG9sZGVyT3B0aW9uICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vRGV0ZXJtaW5lIHRoZSBwbGFjZWhvbGRlciBvcHRpb24gYmFzZWQgb24gdGhlIHNwZWNpZmllZCBwbGFjZWhvbGRlck9wdGlvbiBzZXR0aW5nXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5vcHRzLnBsYWNlaG9sZGVyT3B0aW9uID09PSBcImZpcnN0XCIgJiYgZmlyc3RPcHRpb24pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIHRoaXMub3B0cy5wbGFjZWhvbGRlck9wdGlvbiA9PT0gXCJmdW5jdGlvblwiICYmIHRoaXMub3B0cy5wbGFjZWhvbGRlck9wdGlvbih0aGlzLnNlbGVjdCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoJC50cmltKGZpcnN0T3B0aW9uLnRleHQoKSkgPT09IFwiXCIgJiYgZmlyc3RPcHRpb24udmFsKCkgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9ObyBleHBsaWNpdCBwbGFjZWhvbGRlciBvcHRpb24gc3BlY2lmaWVkLCB1c2UgdGhlIGZpcnN0IGlmIGl0J3MgYmxhbmtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0T3B0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBkZXNpcmVkIHdpZHRoIGZvciB0aGUgY29udGFpbmVyIGVsZW1lbnQuICBUaGlzIGlzXG4gICAgICAgICAqIGRlcml2ZWQgZmlyc3QgZnJvbSBvcHRpb24gYHdpZHRoYCBwYXNzZWQgdG8gc2VsZWN0MiwgdGhlblxuICAgICAgICAgKiB0aGUgaW5saW5lICdzdHlsZScgb24gdGhlIG9yaWdpbmFsIGVsZW1lbnQsIGFuZCBmaW5hbGx5XG4gICAgICAgICAqIGZhbGxzIGJhY2sgdG8gdGhlIGpRdWVyeSBjYWxjdWxhdGVkIGVsZW1lbnQgd2lkdGguXG4gICAgICAgICAqL1xuICAgICAgICAvLyBhYnN0cmFjdFxuICAgICAgICBpbml0Q29udGFpbmVyV2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlc29sdmVDb250YWluZXJXaWR0aCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGUsIGF0dHJzLCBtYXRjaGVzLCBpLCBsLCBhdHRyO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0cy53aWR0aCA9PT0gXCJvZmZcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0cy53aWR0aCA9PT0gXCJlbGVtZW50XCIpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRzLmVsZW1lbnQub3V0ZXJXaWR0aChmYWxzZSkgPT09IDAgPyAnYXV0bycgOiB0aGlzLm9wdHMuZWxlbWVudC5vdXRlcldpZHRoKGZhbHNlKSArICdweCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdHMud2lkdGggPT09IFwiY29weVwiIHx8IHRoaXMub3B0cy53aWR0aCA9PT0gXCJyZXNvbHZlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgaXMgaW5saW5lIHN0eWxlIG9uIHRoZSBlbGVtZW50IHRoYXQgY29udGFpbnMgd2lkdGhcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUgPSB0aGlzLm9wdHMuZWxlbWVudC5hdHRyKCdzdHlsZScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnMgPSBzdHlsZS5zcGxpdCgnOycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIgPSBhdHRyc1tpXS5yZXBsYWNlKC9cXHMvZywgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXMgPSBhdHRyLm1hdGNoKC9ed2lkdGg6KChbLStdPyhbMC05XSpcXC4pP1swLTldKykocHh8ZW18ZXh8JXxpbnxjbXxtbXxwdHxwYykpL2kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzICE9PSBudWxsICYmIG1hdGNoZXMubGVuZ3RoID49IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVzWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0cy53aWR0aCA9PT0gXCJyZXNvbHZlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5leHQgY2hlY2sgaWYgY3NzKCd3aWR0aCcpIGNhbiByZXNvbHZlIGEgd2lkdGggdGhhdCBpcyBwZXJjZW50IGJhc2VkLCB0aGlzIGlzIHNvbWV0aW1lcyBwb3NzaWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBhdHRhY2hlZCB0byBpbnB1dCB0eXBlPWhpZGRlbiBvciBlbGVtZW50cyBoaWRkZW4gdmlhIGNzc1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUgPSB0aGlzLm9wdHMuZWxlbWVudC5jc3MoJ3dpZHRoJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGUuaW5kZXhPZihcIiVcIikgPiAwKSByZXR1cm4gc3R5bGU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpbmFsbHksIGZhbGxiYWNrIG9uIHRoZSBjYWxjdWxhdGVkIHdpZHRoIG9mIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMub3B0cy5lbGVtZW50Lm91dGVyV2lkdGgoZmFsc2UpID09PSAwID8gJ2F1dG8nIDogdGhpcy5vcHRzLmVsZW1lbnQub3V0ZXJXaWR0aChmYWxzZSkgKyAncHgnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoJC5pc0Z1bmN0aW9uKHRoaXMub3B0cy53aWR0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0cy53aWR0aCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdHMud2lkdGg7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgd2lkdGggPSByZXNvbHZlQ29udGFpbmVyV2lkdGguY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGlmICh3aWR0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmNzcyhcIndpZHRoXCIsIHdpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgU2luZ2xlU2VsZWN0MiA9IGNsYXp6KEFic3RyYWN0U2VsZWN0Miwge1xuXG4gICAgICAgIC8vIHNpbmdsZVxuXG4gICAgICAgIGNyZWF0ZUNvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9ICQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSkuYXR0cih7XG4gICAgICAgICAgICAgICAgXCJjbGFzc1wiOiBcInNlbGVjdDItY29udGFpbmVyXCJcbiAgICAgICAgICAgIH0pLmh0bWwoW1xuICAgICAgICAgICAgICAgIFwiPGEgaHJlZj0namF2YXNjcmlwdDp2b2lkKDApJyBjbGFzcz0nc2VsZWN0Mi1jaG9pY2UnIHRhYmluZGV4PSctMSc+XCIsXG4gICAgICAgICAgICAgICAgXCIgICA8c3BhbiBjbGFzcz0nc2VsZWN0Mi1jaG9zZW4nPiYjMTYwOzwvc3Bhbj48YWJiciBjbGFzcz0nc2VsZWN0Mi1zZWFyY2gtY2hvaWNlLWNsb3NlJz48L2FiYnI+XCIsXG4gICAgICAgICAgICAgICAgXCIgICA8c3BhbiBjbGFzcz0nc2VsZWN0Mi1hcnJvdycgcm9sZT0ncHJlc2VudGF0aW9uJz48YiByb2xlPSdwcmVzZW50YXRpb24nPjwvYj48L3NwYW4+XCIsXG4gICAgICAgICAgICAgICAgXCI8L2E+XCIsXG4gICAgICAgICAgICAgICAgXCI8bGFiZWwgZm9yPScnIGNsYXNzPSdzZWxlY3QyLW9mZnNjcmVlbic+PC9sYWJlbD5cIixcbiAgICAgICAgICAgICAgICBcIjxpbnB1dCBjbGFzcz0nc2VsZWN0Mi1mb2N1c3NlciBzZWxlY3QyLW9mZnNjcmVlbicgdHlwZT0ndGV4dCcgYXJpYS1oYXNwb3B1cD0ndHJ1ZScgcm9sZT0nYnV0dG9uJyAvPlwiLFxuICAgICAgICAgICAgICAgIFwiPGRpdiBjbGFzcz0nc2VsZWN0Mi1kcm9wIHNlbGVjdDItZGlzcGxheS1ub25lJz5cIixcbiAgICAgICAgICAgICAgICBcIiAgIDxkaXYgY2xhc3M9J3NlbGVjdDItc2VhcmNoJz5cIixcbiAgICAgICAgICAgICAgICBcIiAgICAgICA8bGFiZWwgZm9yPScnIGNsYXNzPSdzZWxlY3QyLW9mZnNjcmVlbic+PC9sYWJlbD5cIixcbiAgICAgICAgICAgICAgICBcIiAgICAgICA8aW5wdXQgdHlwZT0ndGV4dCcgYXV0b2NvbXBsZXRlPSdvZmYnIGF1dG9jb3JyZWN0PSdvZmYnIGF1dG9jYXBpdGFsaXplPSdvZmYnIHNwZWxsY2hlY2s9J2ZhbHNlJyBjbGFzcz0nc2VsZWN0Mi1pbnB1dCcgcm9sZT0nY29tYm9ib3gnIGFyaWEtZXhwYW5kZWQ9J3RydWUnXCIsXG4gICAgICAgICAgICAgICAgXCIgICAgICAgYXJpYS1hdXRvY29tcGxldGU9J2xpc3QnIC8+XCIsXG4gICAgICAgICAgICAgICAgXCIgICA8L2Rpdj5cIixcbiAgICAgICAgICAgICAgICBcIiAgIDx1bCBjbGFzcz0nc2VsZWN0Mi1yZXN1bHRzJyByb2xlPSdsaXN0Ym94Jz5cIixcbiAgICAgICAgICAgICAgICBcIiAgIDwvdWw+XCIsXG4gICAgICAgICAgICAgICAgXCI8L2Rpdj5cIl0uam9pbihcIlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHNpbmdsZVxuICAgICAgICBlbmFibGVJbnRlcmZhY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50LmVuYWJsZUludGVyZmFjZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c3Nlci5wcm9wKFwiZGlzYWJsZWRcIiwgIXRoaXMuaXNJbnRlcmZhY2VFbmFibGVkKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHNpbmdsZVxuICAgICAgICBvcGVuaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZWwsIHJhbmdlLCBsZW47XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMubWluaW11bVJlc3VsdHNGb3JTZWFyY2ggPj0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvd1NlYXJjaCh0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5wYXJlbnQub3BlbmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zaG93U2VhcmNoSW5wdXQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgLy8gSUUgYXBwZW5kcyBmb2N1c3Nlci52YWwoKSBhdCB0aGUgZW5kIG9mIGZpZWxkIDovIHNvIHdlIG1hbnVhbGx5IGluc2VydCBpdCBhdCB0aGUgYmVnaW5uaW5nIHVzaW5nIGEgcmFuZ2VcbiAgICAgICAgICAgICAgICAvLyBhbGwgb3RoZXIgYnJvd3NlcnMgaGFuZGxlIHRoaXMganVzdCBmaW5lXG5cbiAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaC52YWwodGhpcy5mb2N1c3Nlci52YWwoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLnNob3VsZEZvY3VzSW5wdXQodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIC8vIG1vdmUgdGhlIGN1cnNvciB0byB0aGUgZW5kIGFmdGVyIGZvY3Vzc2luZywgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgYXQgdGhlIGJlZ2lubmluZyBhbmRcbiAgICAgICAgICAgICAgICAvLyBuZXcgdGV4dCB3aWxsIGFwcGVhciAqYmVmb3JlKiBmb2N1c3Nlci52YWwoKVxuICAgICAgICAgICAgICAgIGVsID0gdGhpcy5zZWFyY2guZ2V0KDApO1xuICAgICAgICAgICAgICAgIGlmIChlbC5jcmVhdGVUZXh0UmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBlbC5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UuY29sbGFwc2UoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZWxlY3QoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVsLnNldFNlbGVjdGlvblJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IHRoaXMuc2VhcmNoLnZhbCgpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZWwuc2V0U2VsZWN0aW9uUmFuZ2UobGVuLCBsZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZXMgc2VhcmNoJ3MgdmFsdWUgd2l0aCBuZXh0U2VhcmNoVGVybSAoaWYgZGVmaW5lZCBieSB1c2VyKVxuICAgICAgICAgICAgLy8gaWdub3JlIG5leHRTZWFyY2hUZXJtIGlmIHRoZSBkcm9wZG93biBpcyBvcGVuZWQgYnkgdGhlIHVzZXIgcHJlc3NpbmcgYSBsZXR0ZXJcbiAgICAgICAgICAgIGlmKHRoaXMuc2VhcmNoLnZhbCgpID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5uZXh0U2VhcmNoVGVybSAhPSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaC52YWwodGhpcy5uZXh0U2VhcmNoVGVybSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoLnNlbGVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5mb2N1c3Nlci5wcm9wKFwiZGlzYWJsZWRcIiwgdHJ1ZSkudmFsKFwiXCIpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVSZXN1bHRzKHRydWUpO1xuICAgICAgICAgICAgdGhpcy5vcHRzLmVsZW1lbnQudHJpZ2dlcigkLkV2ZW50KFwic2VsZWN0Mi1vcGVuXCIpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBzaW5nbGVcbiAgICAgICAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5vcGVuZWQoKSkgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2xvc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgdGhpcy5mb2N1c3Nlci5wcm9wKFwiZGlzYWJsZWRcIiwgZmFsc2UpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLnNob3VsZEZvY3VzSW5wdXQodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvY3Vzc2VyLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gc2luZ2xlXG4gICAgICAgIGZvY3VzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcGVuZWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c3Nlci5wcm9wKFwiZGlzYWJsZWRcIiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuc2hvdWxkRm9jdXNJbnB1dCh0aGlzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvY3Vzc2VyLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHNpbmdsZVxuICAgICAgICBpc0ZvY3VzZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lci5oYXNDbGFzcyhcInNlbGVjdDItY29udGFpbmVyLWFjdGl2ZVwiKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBzaW5nbGVcbiAgICAgICAgY2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5jYW5jZWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNzZXIucHJvcChcImRpc2FibGVkXCIsIGZhbHNlKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5zaG91bGRGb2N1c0lucHV0KHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c3Nlci5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHNpbmdsZVxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICQoXCJsYWJlbFtmb3I9J1wiICsgdGhpcy5mb2N1c3Nlci5hdHRyKCdpZCcpICsgXCInXVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdmb3InLCB0aGlzLm9wdHMuZWxlbWVudC5hdHRyKFwiaWRcIikpO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuZGVzdHJveS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBjbGVhbnVwSlF1ZXJ5RWxlbWVudHMuY2FsbCh0aGlzLFxuICAgICAgICAgICAgICAgIFwic2VsZWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgXCJmb2N1c3NlclwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHNpbmdsZVxuICAgICAgICBpbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gdGhpcy5jb250YWluZXIsXG4gICAgICAgICAgICAgICAgZHJvcGRvd24gPSB0aGlzLmRyb3Bkb3duLFxuICAgICAgICAgICAgICAgIGlkU3VmZml4ID0gbmV4dFVpZCgpLFxuICAgICAgICAgICAgICAgIGVsZW1lbnRMYWJlbDtcblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5taW5pbXVtUmVzdWx0c0ZvclNlYXJjaCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dTZWFyY2goZmFsc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dTZWFyY2godHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gc2VsZWN0aW9uID0gY29udGFpbmVyLmZpbmQoXCIuc2VsZWN0Mi1jaG9pY2VcIik7XG5cbiAgICAgICAgICAgIHRoaXMuZm9jdXNzZXIgPSBjb250YWluZXIuZmluZChcIi5zZWxlY3QyLWZvY3Vzc2VyXCIpO1xuXG4gICAgICAgICAgICAvLyBhZGQgYXJpYSBhc3NvY2lhdGlvbnNcbiAgICAgICAgICAgIHNlbGVjdGlvbi5maW5kKFwiLnNlbGVjdDItY2hvc2VuXCIpLmF0dHIoXCJpZFwiLCBcInNlbGVjdDItY2hvc2VuLVwiK2lkU3VmZml4KTtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNzZXIuYXR0cihcImFyaWEtbGFiZWxsZWRieVwiLCBcInNlbGVjdDItY2hvc2VuLVwiK2lkU3VmZml4KTtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0cy5hdHRyKFwiaWRcIiwgXCJzZWxlY3QyLXJlc3VsdHMtXCIraWRTdWZmaXgpO1xuICAgICAgICAgICAgdGhpcy5zZWFyY2guYXR0cihcImFyaWEtb3duc1wiLCBcInNlbGVjdDItcmVzdWx0cy1cIitpZFN1ZmZpeCk7XG5cbiAgICAgICAgICAgIC8vIHJld3JpdGUgbGFiZWxzIGZyb20gb3JpZ2luYWwgZWxlbWVudCB0byBmb2N1c3NlclxuICAgICAgICAgICAgdGhpcy5mb2N1c3Nlci5hdHRyKFwiaWRcIiwgXCJzMmlkX2F1dG9nZW5cIitpZFN1ZmZpeCk7XG5cbiAgICAgICAgICAgIGVsZW1lbnRMYWJlbCA9ICQoXCJsYWJlbFtmb3I9J1wiICsgdGhpcy5vcHRzLmVsZW1lbnQuYXR0cihcImlkXCIpICsgXCInXVwiKTtcbiAgICAgICAgICAgIHRoaXMub3B0cy5lbGVtZW50LmZvY3VzKHRoaXMuYmluZChmdW5jdGlvbiAoKSB7IHRoaXMuZm9jdXMoKTsgfSkpO1xuXG4gICAgICAgICAgICB0aGlzLmZvY3Vzc2VyLnByZXYoKVxuICAgICAgICAgICAgICAgIC50ZXh0KGVsZW1lbnRMYWJlbC50ZXh0KCkpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZvcicsIHRoaXMuZm9jdXNzZXIuYXR0cignaWQnKSk7XG5cbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgb3JpZ2luYWwgZWxlbWVudCByZXRhaW5zIGFuIGFjY2Vzc2libGUgbmFtZVxuICAgICAgICAgICAgdmFyIG9yaWdpbmFsVGl0bGUgPSB0aGlzLm9wdHMuZWxlbWVudC5hdHRyKFwidGl0bGVcIik7XG4gICAgICAgICAgICB0aGlzLm9wdHMuZWxlbWVudC5hdHRyKFwidGl0bGVcIiwgKG9yaWdpbmFsVGl0bGUgfHwgZWxlbWVudExhYmVsLnRleHQoKSkpO1xuXG4gICAgICAgICAgICB0aGlzLmZvY3Vzc2VyLmF0dHIoXCJ0YWJpbmRleFwiLCB0aGlzLmVsZW1lbnRUYWJJbmRleCk7XG5cbiAgICAgICAgICAgIC8vIHdyaXRlIGxhYmVsIGZvciBzZWFyY2ggZmllbGQgdXNpbmcgdGhlIGxhYmVsIGZyb20gdGhlIGZvY3Vzc2VyIGVsZW1lbnRcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoLmF0dHIoXCJpZFwiLCB0aGlzLmZvY3Vzc2VyLmF0dHIoJ2lkJykgKyAnX3NlYXJjaCcpO1xuXG4gICAgICAgICAgICB0aGlzLnNlYXJjaC5wcmV2KClcbiAgICAgICAgICAgICAgICAudGV4dCgkKFwibGFiZWxbZm9yPSdcIiArIHRoaXMuZm9jdXNzZXIuYXR0cignaWQnKSArIFwiJ11cIikudGV4dCgpKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdmb3InLCB0aGlzLnNlYXJjaC5hdHRyKCdpZCcpKTtcblxuICAgICAgICAgICAgdGhpcy5zZWFyY2gub24oXCJrZXlkb3duXCIsIHRoaXMuYmluZChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0ludGVyZmFjZUVuYWJsZWQoKSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgLy8gZmlsdGVyIDIyOSBrZXlDb2RlcyAoaW5wdXQgbWV0aG9kIGVkaXRvciBpcyBwcm9jZXNzaW5nIGtleSBpbnB1dClcbiAgICAgICAgICAgICAgICBpZiAoMjI5ID09IGUua2V5Q29kZSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgaWYgKGUud2hpY2ggPT09IEtFWS5QQUdFX1VQIHx8IGUud2hpY2ggPT09IEtFWS5QQUdFX0RPV04pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJldmVudCB0aGUgcGFnZSBmcm9tIHNjcm9sbGluZ1xuICAgICAgICAgICAgICAgICAgICBraWxsRXZlbnQoZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGUud2hpY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBLRVkuVVA6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgS0VZLkRPV046XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVIaWdobGlnaHQoKGUud2hpY2ggPT09IEtFWS5VUCkgPyAtMSA6IDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAga2lsbEV2ZW50KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEtFWS5FTlRFUjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0SGlnaGxpZ2h0ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbGxFdmVudChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBLRVkuVEFCOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RIaWdobGlnaHRlZCh7bm9Gb2N1czogdHJ1ZX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEtFWS5FU0M6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbGxFdmVudChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIHRoaXMuc2VhcmNoLm9uKFwiYmx1clwiLCB0aGlzLmJpbmQoZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIC8vIGEgd29ya2Fyb3VuZCBmb3IgY2hyb21lIHRvIGtlZXAgdGhlIHNlYXJjaCBmaWVsZCBmb2N1c3NlZCB3aGVuIHRoZSBzY3JvbGwgYmFyIGlzIHVzZWQgdG8gc2Nyb2xsIHRoZSBkcm9wZG93bi5cbiAgICAgICAgICAgICAgICAvLyB3aXRob3V0IHRoaXMgdGhlIHNlYXJjaCBmaWVsZCBsb3NlcyBmb2N1cyB3aGljaCBpcyBhbm5veWluZ1xuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0aGlzLmJvZHkuZ2V0KDApKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KHRoaXMuYmluZChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wZW5lZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWFyY2guZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSksIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgdGhpcy5mb2N1c3Nlci5vbihcImtleWRvd25cIiwgdGhpcy5iaW5kKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzSW50ZXJmYWNlRW5hYmxlZCgpKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBpZiAoZS53aGljaCA9PT0gS0VZLlRBQiB8fCBLRVkuaXNDb250cm9sKGUpIHx8IEtFWS5pc0Z1bmN0aW9uS2V5KGUpIHx8IGUud2hpY2ggPT09IEtFWS5FU0MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdHMub3Blbk9uRW50ZXIgPT09IGZhbHNlICYmIGUud2hpY2ggPT09IEtFWS5FTlRFUikge1xuICAgICAgICAgICAgICAgICAgICBraWxsRXZlbnQoZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZS53aGljaCA9PSBLRVkuRE9XTiB8fCBlLndoaWNoID09IEtFWS5VUFxuICAgICAgICAgICAgICAgICAgICB8fCAoZS53aGljaCA9PSBLRVkuRU5URVIgJiYgdGhpcy5vcHRzLm9wZW5PbkVudGVyKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmFsdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5zaGlmdEtleSB8fCBlLm1ldGFLZXkpIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgICAgICAgICAgICAgICAga2lsbEV2ZW50KGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGUud2hpY2ggPT0gS0VZLkRFTEVURSB8fCBlLndoaWNoID09IEtFWS5CQUNLU1BBQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5hbGxvd0NsZWFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAga2lsbEV2ZW50KGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuXG5cbiAgICAgICAgICAgIGluc3RhbGxLZXlVcENoYW5nZUV2ZW50KHRoaXMuZm9jdXNzZXIpO1xuICAgICAgICAgICAgdGhpcy5mb2N1c3Nlci5vbihcImtleXVwLWNoYW5nZSBpbnB1dFwiLCB0aGlzLmJpbmQoZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdHMubWluaW11bVJlc3VsdHNGb3JTZWFyY2ggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcGVuZWQoKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIHNlbGVjdGlvbi5vbihcIm1vdXNlZG93biB0b3VjaHN0YXJ0XCIsIFwiYWJiclwiLCB0aGlzLmJpbmQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNJbnRlcmZhY2VFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICBraWxsRXZlbnRJbW1lZGlhdGVseShlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIHNlbGVjdGlvbi5vbihcIm1vdXNlZG93biB0b3VjaHN0YXJ0XCIsIHRoaXMuYmluZChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgSUUgZnJvbSBnZW5lcmF0aW5nIGEgY2xpY2sgZXZlbnQgb24gdGhlIGJvZHlcbiAgICAgICAgICAgICAgICByZWluc2VydEVsZW1lbnQoc2VsZWN0aW9uKTtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250YWluZXIuaGFzQ2xhc3MoXCJzZWxlY3QyLWNvbnRhaW5lci1hY3RpdmVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRzLmVsZW1lbnQudHJpZ2dlcigkLkV2ZW50KFwic2VsZWN0Mi1mb2N1c1wiKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3BlbmVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0ludGVyZmFjZUVuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBraWxsRXZlbnQoZSk7XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIGRyb3Bkb3duLm9uKFwibW91c2Vkb3duIHRvdWNoc3RhcnRcIiwgdGhpcy5iaW5kKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuc2hvdWxkRm9jdXNJbnB1dCh0aGlzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgc2VsZWN0aW9uLm9uKFwiZm9jdXNcIiwgdGhpcy5iaW5kKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBraWxsRXZlbnQoZSk7XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIHRoaXMuZm9jdXNzZXIub24oXCJmb2N1c1wiLCB0aGlzLmJpbmQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGFpbmVyLmhhc0NsYXNzKFwic2VsZWN0Mi1jb250YWluZXItYWN0aXZlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0cy5lbGVtZW50LnRyaWdnZXIoJC5FdmVudChcInNlbGVjdDItZm9jdXNcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRDbGFzcyhcInNlbGVjdDItY29udGFpbmVyLWFjdGl2ZVwiKTtcbiAgICAgICAgICAgIH0pKS5vbihcImJsdXJcIiwgdGhpcy5iaW5kKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5vcGVuZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDbGFzcyhcInNlbGVjdDItY29udGFpbmVyLWFjdGl2ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRzLmVsZW1lbnQudHJpZ2dlcigkLkV2ZW50KFwic2VsZWN0Mi1ibHVyXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB0aGlzLnNlYXJjaC5vbihcImZvY3VzXCIsIHRoaXMuYmluZChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250YWluZXIuaGFzQ2xhc3MoXCJzZWxlY3QyLWNvbnRhaW5lci1hY3RpdmVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRzLmVsZW1lbnQudHJpZ2dlcigkLkV2ZW50KFwic2VsZWN0Mi1mb2N1c1wiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENsYXNzKFwic2VsZWN0Mi1jb250YWluZXItYWN0aXZlXCIpO1xuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICB0aGlzLmluaXRDb250YWluZXJXaWR0aCgpO1xuICAgICAgICAgICAgdGhpcy5vcHRzLmVsZW1lbnQuaGlkZSgpO1xuICAgICAgICAgICAgdGhpcy5zZXRQbGFjZWhvbGRlcigpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gc2luZ2xlXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbih0cmlnZ2VyQ2hhbmdlKSB7XG4gICAgICAgICAgICB2YXIgZGF0YT10aGlzLnNlbGVjdGlvbi5kYXRhKFwic2VsZWN0Mi1kYXRhXCIpO1xuICAgICAgICAgICAgaWYgKGRhdGEpIHsgLy8gZ3VhcmQgYWdhaW5zdCBxdWV1ZWQgcXVpY2sgY29uc2VjdXRpdmUgY2xpY2tzXG4gICAgICAgICAgICAgICAgdmFyIGV2dCA9ICQuRXZlbnQoXCJzZWxlY3QyLWNsZWFyaW5nXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMub3B0cy5lbGVtZW50LnRyaWdnZXIoZXZ0KTtcbiAgICAgICAgICAgICAgICBpZiAoZXZ0LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHBsYWNlaG9sZGVyT3B0aW9uID0gdGhpcy5nZXRQbGFjZWhvbGRlck9wdGlvbigpO1xuICAgICAgICAgICAgICAgIHRoaXMub3B0cy5lbGVtZW50LnZhbChwbGFjZWhvbGRlck9wdGlvbiA/IHBsYWNlaG9sZGVyT3B0aW9uLnZhbCgpIDogXCJcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uZmluZChcIi5zZWxlY3QyLWNob3NlblwiKS5lbXB0eSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnJlbW92ZURhdGEoXCJzZWxlY3QyLWRhdGFcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQbGFjZWhvbGRlcigpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRyaWdnZXJDaGFuZ2UgIT09IGZhbHNlKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRzLmVsZW1lbnQudHJpZ2dlcih7IHR5cGU6IFwic2VsZWN0Mi1yZW1vdmVkXCIsIHZhbDogdGhpcy5pZChkYXRhKSwgY2hvaWNlOiBkYXRhIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJDaGFuZ2Uoe3JlbW92ZWQ6ZGF0YX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyBzZWxlY3Rpb24gYmFzZWQgb24gc291cmNlIGVsZW1lbnQncyB2YWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gc2luZ2xlXG4gICAgICAgIGluaXRTZWxlY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZDtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUGxhY2Vob2xkZXJPcHRpb25TZWxlY3RlZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTZWxlY3Rpb24obnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UGxhY2Vob2xkZXIoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMub3B0cy5pbml0U2VsZWN0aW9uLmNhbGwobnVsbCwgdGhpcy5vcHRzLmVsZW1lbnQsIGZ1bmN0aW9uKHNlbGVjdGVkKXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkICE9PSB1bmRlZmluZWQgJiYgc2VsZWN0ZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlU2VsZWN0aW9uKHNlbGVjdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0UGxhY2Vob2xkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubmV4dFNlYXJjaFRlcm0gPSBzZWxmLm9wdHMubmV4dFNlYXJjaFRlcm0oc2VsZWN0ZWQsIHNlbGYuc2VhcmNoLnZhbCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGlzUGxhY2Vob2xkZXJPcHRpb25TZWxlY3RlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcGxhY2Vob2xkZXJPcHRpb247XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRQbGFjZWhvbGRlcigpID09PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZTsgLy8gbm8gcGxhY2Vob2xkZXIgc3BlY2lmaWVkIHNvIG5vIG9wdGlvbiBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgICAgICAgICAgcmV0dXJuICgocGxhY2Vob2xkZXJPcHRpb24gPSB0aGlzLmdldFBsYWNlaG9sZGVyT3B0aW9uKCkpICE9PSB1bmRlZmluZWQgJiYgcGxhY2Vob2xkZXJPcHRpb24ucHJvcChcInNlbGVjdGVkXCIpKVxuICAgICAgICAgICAgICAgIHx8ICh0aGlzLm9wdHMuZWxlbWVudC52YWwoKSA9PT0gXCJcIilcbiAgICAgICAgICAgICAgICB8fCAodGhpcy5vcHRzLmVsZW1lbnQudmFsKCkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB8fCAodGhpcy5vcHRzLmVsZW1lbnQudmFsKCkgPT09IG51bGwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHNpbmdsZVxuICAgICAgICBwcmVwYXJlT3B0czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9wdHMgPSB0aGlzLnBhcmVudC5wcmVwYXJlT3B0cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICAgICAgICAgIHNlbGY9dGhpcztcblxuICAgICAgICAgICAgaWYgKG9wdHMuZWxlbWVudC5nZXQoMCkudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInNlbGVjdFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5zdGFsbCB0aGUgc2VsZWN0aW9uIGluaXRpYWxpemVyXG4gICAgICAgICAgICAgICAgb3B0cy5pbml0U2VsZWN0aW9uID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IGVsZW1lbnQuZmluZChcIm9wdGlvblwiKS5maWx0ZXIoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnNlbGVjdGVkICYmICF0aGlzLmRpc2FibGVkIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBhIHNpbmdsZSBzZWxlY3QgYm94IGFsd2F5cyBoYXMgYSB2YWx1ZSwgbm8gbmVlZCB0byBudWxsIGNoZWNrICdzZWxlY3RlZCdcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soc2VsZi5vcHRpb25Ub0RhdGEoc2VsZWN0ZWQpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcImRhdGFcIiBpbiBvcHRzKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5zdGFsbCBkZWZhdWx0IGluaXRTZWxlY3Rpb24gd2hlbiBhcHBsaWVkIHRvIGhpZGRlbiBpbnB1dCBhbmQgZGF0YSBpcyBsb2NhbFxuICAgICAgICAgICAgICAgIG9wdHMuaW5pdFNlbGVjdGlvbiA9IG9wdHMuaW5pdFNlbGVjdGlvbiB8fCBmdW5jdGlvbiAoZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gZWxlbWVudC52YWwoKTtcbiAgICAgICAgICAgICAgICAgICAgLy9zZWFyY2ggaW4gZGF0YSBieSBpZCwgc3RvcmluZyB0aGUgYWN0dWFsIG1hdGNoaW5nIGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5xdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyOiBmdW5jdGlvbih0ZXJtLCB0ZXh0LCBlbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzX21hdGNoID0gZXF1YWwoaWQsIG9wdHMuaWQoZWwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNfbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzX21hdGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiAhJC5pc0Z1bmN0aW9uKGNhbGxiYWNrKSA/ICQubm9vcCA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9wdHM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gc2luZ2xlXG4gICAgICAgIGdldFBsYWNlaG9sZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGlmIGEgcGxhY2Vob2xkZXIgaXMgc3BlY2lmaWVkIG9uIGEgc2luZ2xlIHNlbGVjdCB3aXRob3V0IGEgdmFsaWQgcGxhY2Vob2xkZXIgb3B0aW9uIGlnbm9yZSBpdFxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0UGxhY2Vob2xkZXJPcHRpb24oKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0UGxhY2Vob2xkZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBzaW5nbGVcbiAgICAgICAgc2V0UGxhY2Vob2xkZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwbGFjZWhvbGRlciA9IHRoaXMuZ2V0UGxhY2Vob2xkZXIoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaXNQbGFjZWhvbGRlck9wdGlvblNlbGVjdGVkKCkgJiYgcGxhY2Vob2xkZXIgIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGEgcGxhY2Vob2xkZXIgb3B0aW9uIGlmIGF0dGFjaGVkIHRvIGEgc2VsZWN0XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ICYmIHRoaXMuZ2V0UGxhY2Vob2xkZXJPcHRpb24oKSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5maW5kKFwiLnNlbGVjdDItY2hvc2VuXCIpLmh0bWwodGhpcy5vcHRzLmVzY2FwZU1hcmt1cChwbGFjZWhvbGRlcikpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uYWRkQ2xhc3MoXCJzZWxlY3QyLWRlZmF1bHRcIik7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDbGFzcyhcInNlbGVjdDItYWxsb3djbGVhclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBzaW5nbGVcbiAgICAgICAgcG9zdHByb2Nlc3NSZXN1bHRzOiBmdW5jdGlvbiAoZGF0YSwgaW5pdGlhbCwgbm9IaWdobGlnaHRVcGRhdGUpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IDAsIHNlbGYgPSB0aGlzLCBzaG93U2VhcmNoSW5wdXQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBmaW5kIHRoZSBzZWxlY3RlZCBlbGVtZW50IGluIHRoZSByZXN1bHQgbGlzdFxuXG4gICAgICAgICAgICB0aGlzLmZpbmRIaWdobGlnaHRhYmxlQ2hvaWNlcygpLmVhY2gyKGZ1bmN0aW9uIChpLCBlbG0pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXF1YWwoc2VsZi5pZChlbG0uZGF0YShcInNlbGVjdDItZGF0YVwiKSksIHNlbGYub3B0cy5lbGVtZW50LnZhbCgpKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gYW5kIGhpZ2hsaWdodCBpdFxuICAgICAgICAgICAgaWYgKG5vSGlnaGxpZ2h0VXBkYXRlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmIChpbml0aWFsID09PSB0cnVlICYmIHNlbGVjdGVkID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHQoc2VsZWN0ZWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0KDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaGlkZSB0aGUgc2VhcmNoIGJveCBpZiB0aGlzIGlzIHRoZSBmaXJzdCB3ZSBnb3QgdGhlIHJlc3VsdHMgYW5kIHRoZXJlIGFyZSBlbm91Z2ggb2YgdGhlbSBmb3Igc2VhcmNoXG5cbiAgICAgICAgICAgIGlmIChpbml0aWFsID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pbiA9IHRoaXMub3B0cy5taW5pbXVtUmVzdWx0c0ZvclNlYXJjaDtcbiAgICAgICAgICAgICAgICBpZiAobWluID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93U2VhcmNoKGNvdW50UmVzdWx0cyhkYXRhLnJlc3VsdHMpID49IG1pbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHNpbmdsZVxuICAgICAgICBzaG93U2VhcmNoOiBmdW5jdGlvbihzaG93U2VhcmNoSW5wdXQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNob3dTZWFyY2hJbnB1dCA9PT0gc2hvd1NlYXJjaElucHV0KSByZXR1cm47XG5cbiAgICAgICAgICAgIHRoaXMuc2hvd1NlYXJjaElucHV0ID0gc2hvd1NlYXJjaElucHV0O1xuXG4gICAgICAgICAgICB0aGlzLmRyb3Bkb3duLmZpbmQoXCIuc2VsZWN0Mi1zZWFyY2hcIikudG9nZ2xlQ2xhc3MoXCJzZWxlY3QyLXNlYXJjaC1oaWRkZW5cIiwgIXNob3dTZWFyY2hJbnB1dCk7XG4gICAgICAgICAgICB0aGlzLmRyb3Bkb3duLmZpbmQoXCIuc2VsZWN0Mi1zZWFyY2hcIikudG9nZ2xlQ2xhc3MoXCJzZWxlY3QyLW9mZnNjcmVlblwiLCAhc2hvd1NlYXJjaElucHV0KTtcbiAgICAgICAgICAgIC8vYWRkIFwic2VsZWN0Mi13aXRoLXNlYXJjaGJveFwiIHRvIHRoZSBjb250YWluZXIgaWYgc2VhcmNoIGJveCBpcyBzaG93blxuICAgICAgICAgICAgJCh0aGlzLmRyb3Bkb3duLCB0aGlzLmNvbnRhaW5lcikudG9nZ2xlQ2xhc3MoXCJzZWxlY3QyLXdpdGgtc2VhcmNoYm94XCIsIHNob3dTZWFyY2hJbnB1dCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gc2luZ2xlXG4gICAgICAgIG9uU2VsZWN0OiBmdW5jdGlvbiAoZGF0YSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMudHJpZ2dlclNlbGVjdChkYXRhKSkgeyByZXR1cm47IH1cblxuICAgICAgICAgICAgdmFyIG9sZCA9IHRoaXMub3B0cy5lbGVtZW50LnZhbCgpLFxuICAgICAgICAgICAgICAgIG9sZERhdGEgPSB0aGlzLmRhdGEoKTtcblxuICAgICAgICAgICAgdGhpcy5vcHRzLmVsZW1lbnQudmFsKHRoaXMuaWQoZGF0YSkpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTZWxlY3Rpb24oZGF0YSk7XG5cbiAgICAgICAgICAgIHRoaXMub3B0cy5lbGVtZW50LnRyaWdnZXIoeyB0eXBlOiBcInNlbGVjdDItc2VsZWN0ZWRcIiwgdmFsOiB0aGlzLmlkKGRhdGEpLCBjaG9pY2U6IGRhdGEgfSk7XG5cbiAgICAgICAgICAgIHRoaXMubmV4dFNlYXJjaFRlcm0gPSB0aGlzLm9wdHMubmV4dFNlYXJjaFRlcm0oZGF0YSwgdGhpcy5zZWFyY2gudmFsKCkpO1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuXG4gICAgICAgICAgICBpZiAoKCFvcHRpb25zIHx8ICFvcHRpb25zLm5vRm9jdXMpICYmIHRoaXMub3B0cy5zaG91bGRGb2N1c0lucHV0KHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c3Nlci5mb2N1cygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWVxdWFsKG9sZCwgdGhpcy5pZChkYXRhKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJDaGFuZ2UoeyBhZGRlZDogZGF0YSwgcmVtb3ZlZDogb2xkRGF0YSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBzaW5nbGVcbiAgICAgICAgdXBkYXRlU2VsZWN0aW9uOiBmdW5jdGlvbiAoZGF0YSkge1xuXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyPXRoaXMuc2VsZWN0aW9uLmZpbmQoXCIuc2VsZWN0Mi1jaG9zZW5cIiksIGZvcm1hdHRlZCwgY3NzQ2xhc3M7XG5cbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLmRhdGEoXCJzZWxlY3QyLWRhdGFcIiwgZGF0YSk7XG5cbiAgICAgICAgICAgIGNvbnRhaW5lci5lbXB0eSgpO1xuICAgICAgICAgICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWQ9dGhpcy5vcHRzLmZvcm1hdFNlbGVjdGlvbihkYXRhLCBjb250YWluZXIsIHRoaXMub3B0cy5lc2NhcGVNYXJrdXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdHRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZChmb3JtYXR0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3NzQ2xhc3M9dGhpcy5vcHRzLmZvcm1hdFNlbGVjdGlvbkNzc0NsYXNzKGRhdGEsIGNvbnRhaW5lcik7XG4gICAgICAgICAgICBpZiAoY3NzQ2xhc3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hZGRDbGFzcyhjc3NDbGFzcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnJlbW92ZUNsYXNzKFwic2VsZWN0Mi1kZWZhdWx0XCIpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLmFsbG93Q2xlYXIgJiYgdGhpcy5nZXRQbGFjZWhvbGRlcigpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRDbGFzcyhcInNlbGVjdDItYWxsb3djbGVhclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBzaW5nbGVcbiAgICAgICAgdmFsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmFsLFxuICAgICAgICAgICAgICAgIHRyaWdnZXJDaGFuZ2UgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBkYXRhID0gbnVsbCxcbiAgICAgICAgICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgICAgICBvbGREYXRhID0gdGhpcy5kYXRhKCk7XG5cbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0cy5lbGVtZW50LnZhbCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWwgPSBhcmd1bWVudHNbMF07XG5cbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHRyaWdnZXJDaGFuZ2UgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0XG4gICAgICAgICAgICAgICAgICAgIC52YWwodmFsKVxuICAgICAgICAgICAgICAgICAgICAuZmluZChcIm9wdGlvblwiKS5maWx0ZXIoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnNlbGVjdGVkIH0pLmVhY2gyKGZ1bmN0aW9uIChpLCBlbG0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBzZWxmLm9wdGlvblRvRGF0YShlbG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbihkYXRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFBsYWNlaG9sZGVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRyaWdnZXJDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyQ2hhbmdlKHthZGRlZDogZGF0YSwgcmVtb3ZlZDpvbGREYXRhfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB2YWwgaXMgYW4gaWQuICF2YWwgaXMgdHJ1ZSBmb3IgW3VuZGVmaW5lZCxudWxsLCcnLDBdIC0gMCBpcyBsZWdhbFxuICAgICAgICAgICAgICAgIGlmICghdmFsICYmIHZhbCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyKHRyaWdnZXJDaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuaW5pdFNlbGVjdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBjYWxsIHZhbCgpIGlmIGluaXRTZWxlY3Rpb24oKSBpcyBub3QgZGVmaW5lZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRzLmVsZW1lbnQudmFsKHZhbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRzLmluaXRTZWxlY3Rpb24odGhpcy5vcHRzLmVsZW1lbnQsIGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm9wdHMuZWxlbWVudC52YWwoIWRhdGEgPyBcIlwiIDogc2VsZi5pZChkYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlU2VsZWN0aW9uKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNldFBsYWNlaG9sZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnRyaWdnZXJDaGFuZ2Uoe2FkZGVkOiBkYXRhLCByZW1vdmVkOm9sZERhdGF9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHNpbmdsZVxuICAgICAgICBjbGVhclNlYXJjaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zZWFyY2gudmFsKFwiXCIpO1xuICAgICAgICAgICAgdGhpcy5mb2N1c3Nlci52YWwoXCJcIik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gc2luZ2xlXG4gICAgICAgIGRhdGE6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSxcbiAgICAgICAgICAgICAgICB0cmlnZ2VyQ2hhbmdlID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuc2VsZWN0aW9uLmRhdGEoXCJzZWxlY3QyLWRhdGFcIik7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgPT0gdW5kZWZpbmVkKSBkYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJDaGFuZ2UgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhcih0cmlnZ2VyQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5kYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0cy5lbGVtZW50LnZhbCghdmFsdWUgPyBcIlwiIDogdGhpcy5pZCh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJDaGFuZ2Uoe2FkZGVkOiB2YWx1ZSwgcmVtb3ZlZDpkYXRhfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIE11bHRpU2VsZWN0MiA9IGNsYXp6KEFic3RyYWN0U2VsZWN0Miwge1xuXG4gICAgICAgIC8vIG11bHRpXG4gICAgICAgIGNyZWF0ZUNvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9ICQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSkuYXR0cih7XG4gICAgICAgICAgICAgICAgXCJjbGFzc1wiOiBcInNlbGVjdDItY29udGFpbmVyIHNlbGVjdDItY29udGFpbmVyLW11bHRpXCJcbiAgICAgICAgICAgIH0pLmh0bWwoW1xuICAgICAgICAgICAgICAgIFwiPHVsIGNsYXNzPSdzZWxlY3QyLWNob2ljZXMnPlwiLFxuICAgICAgICAgICAgICAgIFwiICA8bGkgY2xhc3M9J3NlbGVjdDItc2VhcmNoLWZpZWxkJz5cIixcbiAgICAgICAgICAgICAgICBcIiAgICA8bGFiZWwgZm9yPScnIGNsYXNzPSdzZWxlY3QyLW9mZnNjcmVlbic+PC9sYWJlbD5cIixcbiAgICAgICAgICAgICAgICBcIiAgICA8aW5wdXQgdHlwZT0ndGV4dCcgYXV0b2NvbXBsZXRlPSdvZmYnIGF1dG9jb3JyZWN0PSdvZmYnIGF1dG9jYXBpdGFsaXplPSdvZmYnIHNwZWxsY2hlY2s9J2ZhbHNlJyBjbGFzcz0nc2VsZWN0Mi1pbnB1dCc+XCIsXG4gICAgICAgICAgICAgICAgXCIgIDwvbGk+XCIsXG4gICAgICAgICAgICAgICAgXCI8L3VsPlwiLFxuICAgICAgICAgICAgICAgIFwiPGRpdiBjbGFzcz0nc2VsZWN0Mi1kcm9wIHNlbGVjdDItZHJvcC1tdWx0aSBzZWxlY3QyLWRpc3BsYXktbm9uZSc+XCIsXG4gICAgICAgICAgICAgICAgXCIgICA8dWwgY2xhc3M9J3NlbGVjdDItcmVzdWx0cyc+XCIsXG4gICAgICAgICAgICAgICAgXCIgICA8L3VsPlwiLFxuICAgICAgICAgICAgICAgIFwiPC9kaXY+XCJdLmpvaW4oXCJcIikpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBtdWx0aVxuICAgICAgICBwcmVwYXJlT3B0czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9wdHMgPSB0aGlzLnBhcmVudC5wcmVwYXJlT3B0cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICAgICAgICAgIHNlbGY9dGhpcztcblxuICAgICAgICAgICAgLy8gVE9ETyB2YWxpZGF0ZSBwbGFjZWhvbGRlciBpcyBhIHN0cmluZyBpZiBzcGVjaWZpZWRcbiAgICAgICAgICAgIGlmIChvcHRzLmVsZW1lbnQuZ2V0KDApLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJzZWxlY3RcIikge1xuICAgICAgICAgICAgICAgIC8vIGluc3RhbGwgdGhlIHNlbGVjdGlvbiBpbml0aWFsaXplclxuICAgICAgICAgICAgICAgIG9wdHMuaW5pdFNlbGVjdGlvbiA9IGZ1bmN0aW9uIChlbGVtZW50LCBjYWxsYmFjaykge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5maW5kKFwib3B0aW9uXCIpLmZpbHRlcihmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc2VsZWN0ZWQgJiYgIXRoaXMuZGlzYWJsZWQgfSkuZWFjaDIoZnVuY3Rpb24gKGksIGVsbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5wdXNoKHNlbGYub3B0aW9uVG9EYXRhKGVsbSkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXCJkYXRhXCIgaW4gb3B0cykge1xuICAgICAgICAgICAgICAgIC8vIGluc3RhbGwgZGVmYXVsdCBpbml0U2VsZWN0aW9uIHdoZW4gYXBwbGllZCB0byBoaWRkZW4gaW5wdXQgYW5kIGRhdGEgaXMgbG9jYWxcbiAgICAgICAgICAgICAgICBvcHRzLmluaXRTZWxlY3Rpb24gPSBvcHRzLmluaXRTZWxlY3Rpb24gfHwgZnVuY3Rpb24gKGVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZHMgPSBzcGxpdFZhbChlbGVtZW50LnZhbCgpLCBvcHRzLnNlcGFyYXRvciwgb3B0cy50cmFuc2Zvcm1WYWwpO1xuICAgICAgICAgICAgICAgICAgICAvL3NlYXJjaCBpbiBkYXRhIGJ5IGFycmF5IG9mIGlkcywgc3RvcmluZyBtYXRjaGluZyBpdGVtcyBpbiBhIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5xdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyOiBmdW5jdGlvbih0ZXJtLCB0ZXh0LCBlbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzX21hdGNoID0gJC5ncmVwKGlkcywgZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVxdWFsKGlkLCBvcHRzLmlkKGVsKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc19tYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2goZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNfbWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6ICEkLmlzRnVuY3Rpb24oY2FsbGJhY2spID8gJC5ub29wIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVvcmRlciBtYXRjaGVzIGJhc2VkIG9uIHRoZSBvcmRlciB0aGV5IGFwcGVhciBpbiB0aGUgaWRzIGFycmF5IGJlY2F1c2UgcmlnaHQgbm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhleSBhcmUgaW4gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgYXBwZWFyIGluIGRhdGEgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JkZXJlZCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IGlkc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXRjaGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBtYXRjaGVzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVxdWFsKGlkLCBvcHRzLmlkKG1hdGNoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmRlcmVkLnB1c2gobWF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXMuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG9yZGVyZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3B0cztcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBtdWx0aVxuICAgICAgICBzZWxlY3RDaG9pY2U6IGZ1bmN0aW9uIChjaG9pY2UpIHtcblxuICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gdGhpcy5jb250YWluZXIuZmluZChcIi5zZWxlY3QyLXNlYXJjaC1jaG9pY2UtZm9jdXNcIik7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQubGVuZ3RoICYmIGNob2ljZSAmJiBjaG9pY2VbMF0gPT0gc2VsZWN0ZWRbMF0pIHtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0cy5lbGVtZW50LnRyaWdnZXIoXCJjaG9pY2UtZGVzZWxlY3RlZFwiLCBzZWxlY3RlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGVjdGVkLnJlbW92ZUNsYXNzKFwic2VsZWN0Mi1zZWFyY2gtY2hvaWNlLWZvY3VzXCIpO1xuICAgICAgICAgICAgICAgIGlmIChjaG9pY2UgJiYgY2hvaWNlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNob2ljZS5hZGRDbGFzcyhcInNlbGVjdDItc2VhcmNoLWNob2ljZS1mb2N1c1wiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRzLmVsZW1lbnQudHJpZ2dlcihcImNob2ljZS1zZWxlY3RlZFwiLCBjaG9pY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBtdWx0aVxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICQoXCJsYWJlbFtmb3I9J1wiICsgdGhpcy5zZWFyY2guYXR0cignaWQnKSArIFwiJ11cIilcbiAgICAgICAgICAgICAgICAuYXR0cignZm9yJywgdGhpcy5vcHRzLmVsZW1lbnQuYXR0cihcImlkXCIpKTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmRlc3Ryb3kuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgY2xlYW51cEpRdWVyeUVsZW1lbnRzLmNhbGwodGhpcyxcbiAgICAgICAgICAgICAgICBcInNlYXJjaENvbnRhaW5lclwiLFxuICAgICAgICAgICAgICAgIFwic2VsZWN0aW9uXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gbXVsdGlcbiAgICAgICAgaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBcIi5zZWxlY3QyLWNob2ljZXNcIiwgc2VsZWN0aW9uO1xuXG4gICAgICAgICAgICB0aGlzLnNlYXJjaENvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyLmZpbmQoXCIuc2VsZWN0Mi1zZWFyY2gtZmllbGRcIik7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHNlbGVjdGlvbiA9IHRoaXMuY29udGFpbmVyLmZpbmQoc2VsZWN0b3IpO1xuXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24ub24oXCJjbGlja1wiLCBcIi5zZWxlY3QyLWNvbnRhaW5lcjpub3QoLnNlbGVjdDItY29udGFpbmVyLWRpc2FibGVkKSAuc2VsZWN0Mi1zZWFyY2gtY2hvaWNlOm5vdCguc2VsZWN0Mi1sb2NrZWQpXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2VhcmNoWzBdLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2VsZWN0Q2hvaWNlKCQodGhpcykpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHJld3JpdGUgbGFiZWxzIGZyb20gb3JpZ2luYWwgZWxlbWVudCB0byBmb2N1c3NlclxuICAgICAgICAgICAgdGhpcy5zZWFyY2guYXR0cihcImlkXCIsIFwiczJpZF9hdXRvZ2VuXCIrbmV4dFVpZCgpKTtcblxuICAgICAgICAgICAgdGhpcy5zZWFyY2gucHJldigpXG4gICAgICAgICAgICAgICAgLnRleHQoJChcImxhYmVsW2Zvcj0nXCIgKyB0aGlzLm9wdHMuZWxlbWVudC5hdHRyKFwiaWRcIikgKyBcIiddXCIpLnRleHQoKSlcbiAgICAgICAgICAgICAgICAuYXR0cignZm9yJywgdGhpcy5zZWFyY2guYXR0cignaWQnKSk7XG4gICAgICAgICAgICB0aGlzLm9wdHMuZWxlbWVudC5mb2N1cyh0aGlzLmJpbmQoZnVuY3Rpb24gKCkgeyB0aGlzLmZvY3VzKCk7IH0pKTtcblxuICAgICAgICAgICAgdGhpcy5zZWFyY2gub24oXCJpbnB1dCBwYXN0ZVwiLCB0aGlzLmJpbmQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VhcmNoLmF0dHIoJ3BsYWNlaG9sZGVyJykgJiYgdGhpcy5zZWFyY2gudmFsKCkubGVuZ3RoID09IDApIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNJbnRlcmZhY2VFbmFibGVkKCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3BlbmVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICB0aGlzLnNlYXJjaC5hdHRyKFwidGFiaW5kZXhcIiwgdGhpcy5lbGVtZW50VGFiSW5kZXgpO1xuXG4gICAgICAgICAgICB0aGlzLmtleWRvd25zID0gMDtcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoLm9uKFwia2V5ZG93blwiLCB0aGlzLmJpbmQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNJbnRlcmZhY2VFbmFibGVkKCkpIHJldHVybjtcblxuICAgICAgICAgICAgICAgICsrdGhpcy5rZXlkb3ducztcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSBzZWxlY3Rpb24uZmluZChcIi5zZWxlY3QyLXNlYXJjaC1jaG9pY2UtZm9jdXNcIik7XG4gICAgICAgICAgICAgICAgdmFyIHByZXYgPSBzZWxlY3RlZC5wcmV2KFwiLnNlbGVjdDItc2VhcmNoLWNob2ljZTpub3QoLnNlbGVjdDItbG9ja2VkKVwiKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IHNlbGVjdGVkLm5leHQoXCIuc2VsZWN0Mi1zZWFyY2gtY2hvaWNlOm5vdCguc2VsZWN0Mi1sb2NrZWQpXCIpO1xuICAgICAgICAgICAgICAgIHZhciBwb3MgPSBnZXRDdXJzb3JJbmZvKHRoaXMuc2VhcmNoKTtcblxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZC5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgKGUud2hpY2ggPT0gS0VZLkxFRlQgfHwgZS53aGljaCA9PSBLRVkuUklHSFQgfHwgZS53aGljaCA9PSBLRVkuQkFDS1NQQUNFIHx8IGUud2hpY2ggPT0gS0VZLkRFTEVURSB8fCBlLndoaWNoID09IEtFWS5FTlRFUikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkQ2hvaWNlID0gc2VsZWN0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLndoaWNoID09IEtFWS5MRUZUICYmIHByZXYubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZENob2ljZSA9IHByZXY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZS53aGljaCA9PSBLRVkuUklHSFQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkQ2hvaWNlID0gbmV4dC5sZW5ndGggPyBuZXh0IDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlLndoaWNoID09PSBLRVkuQkFDS1NQQUNFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy51bnNlbGVjdChzZWxlY3RlZC5maXJzdCgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoLndpZHRoKDEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZENob2ljZSA9IHByZXYubGVuZ3RoID8gcHJldiA6IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZS53aGljaCA9PSBLRVkuREVMRVRFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy51bnNlbGVjdChzZWxlY3RlZC5maXJzdCgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoLndpZHRoKDEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZENob2ljZSA9IG5leHQubGVuZ3RoID8gbmV4dCA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZS53aGljaCA9PSBLRVkuRU5URVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkQ2hvaWNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0Q2hvaWNlKHNlbGVjdGVkQ2hvaWNlKTtcbiAgICAgICAgICAgICAgICAgICAga2lsbEV2ZW50KGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdGVkQ2hvaWNlIHx8ICFzZWxlY3RlZENob2ljZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCgoZS53aGljaCA9PT0gS0VZLkJBQ0tTUEFDRSAmJiB0aGlzLmtleWRvd25zID09IDEpXG4gICAgICAgICAgICAgICAgICAgIHx8IGUud2hpY2ggPT0gS0VZLkxFRlQpICYmIChwb3Mub2Zmc2V0ID09IDAgJiYgIXBvcy5sZW5ndGgpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RDaG9pY2Uoc2VsZWN0aW9uLmZpbmQoXCIuc2VsZWN0Mi1zZWFyY2gtY2hvaWNlOm5vdCguc2VsZWN0Mi1sb2NrZWQpXCIpLmxhc3QoKSk7XG4gICAgICAgICAgICAgICAgICAgIGtpbGxFdmVudChlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0Q2hvaWNlKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wZW5lZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZS53aGljaCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEtFWS5VUDpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBLRVkuRE9XTjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZUhpZ2hsaWdodCgoZS53aGljaCA9PT0gS0VZLlVQKSA/IC0xIDogMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBraWxsRXZlbnQoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgS0VZLkVOVEVSOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RIaWdobGlnaHRlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAga2lsbEV2ZW50KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEtFWS5UQUI6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdEhpZ2hsaWdodGVkKHtub0ZvY3VzOnRydWV9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBLRVkuRVNDOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5jZWwoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBraWxsRXZlbnQoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZS53aGljaCA9PT0gS0VZLlRBQiB8fCBLRVkuaXNDb250cm9sKGUpIHx8IEtFWS5pc0Z1bmN0aW9uS2V5KGUpXG4gICAgICAgICAgICAgICAgIHx8IGUud2hpY2ggPT09IEtFWS5CQUNLU1BBQ0UgfHwgZS53aGljaCA9PT0gS0VZLkVTQykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGUud2hpY2ggPT09IEtFWS5FTlRFUikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRzLm9wZW5PbkVudGVyID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLnNoaWZ0S2V5IHx8IGUubWV0YUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZS53aGljaCA9PT0gS0VZLlBBR0VfVVAgfHwgZS53aGljaCA9PT0gS0VZLlBBR0VfRE9XTikge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcmV2ZW50IHRoZSBwYWdlIGZyb20gc2Nyb2xsaW5nXG4gICAgICAgICAgICAgICAgICAgIGtpbGxFdmVudChlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZS53aGljaCA9PT0gS0VZLkVOVEVSKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgZm9ybSBmcm9tIGJlaW5nIHN1Ym1pdHRlZFxuICAgICAgICAgICAgICAgICAgICBraWxsRXZlbnQoZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIHRoaXMuc2VhcmNoLm9uKFwia2V5dXBcIiwgdGhpcy5iaW5kKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlkb3ducyA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemVTZWFyY2goKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB0aGlzLnNlYXJjaC5vbihcImJsdXJcIiwgdGhpcy5iaW5kKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDbGFzcyhcInNlbGVjdDItY29udGFpbmVyLWFjdGl2ZVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaC5yZW1vdmVDbGFzcyhcInNlbGVjdDItZm9jdXNlZFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdENob2ljZShudWxsKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3BlbmVkKCkpIHRoaXMuY2xlYXJTZWFyY2goKTtcbiAgICAgICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIHRoaXMub3B0cy5lbGVtZW50LnRyaWdnZXIoJC5FdmVudChcInNlbGVjdDItYmx1clwiKSk7XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLm9uKFwiY2xpY2tcIiwgc2VsZWN0b3IsIHRoaXMuYmluZChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0ludGVyZmFjZUVuYWJsZWQoKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICgkKGUudGFyZ2V0KS5jbG9zZXN0KFwiLnNlbGVjdDItc2VhcmNoLWNob2ljZVwiKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNsaWNrZWQgaW5zaWRlIGEgc2VsZWN0MiBzZWFyY2ggY2hvaWNlLCBkbyBub3Qgb3BlblxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0Q2hvaWNlKG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJQbGFjZWhvbGRlcigpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250YWluZXIuaGFzQ2xhc3MoXCJzZWxlY3QyLWNvbnRhaW5lci1hY3RpdmVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRzLmVsZW1lbnQudHJpZ2dlcigkLkV2ZW50KFwic2VsZWN0Mi1mb2N1c1wiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXNTZWFyY2goKTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLm9uKFwiZm9jdXNcIiwgc2VsZWN0b3IsIHRoaXMuYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzSW50ZXJmYWNlRW5hYmxlZCgpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRhaW5lci5oYXNDbGFzcyhcInNlbGVjdDItY29udGFpbmVyLWFjdGl2ZVwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdHMuZWxlbWVudC50cmlnZ2VyKCQuRXZlbnQoXCJzZWxlY3QyLWZvY3VzXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2xhc3MoXCJzZWxlY3QyLWNvbnRhaW5lci1hY3RpdmVcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5kcm9wZG93bi5hZGRDbGFzcyhcInNlbGVjdDItZHJvcC1hY3RpdmVcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclBsYWNlaG9sZGVyKCk7XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIHRoaXMuaW5pdENvbnRhaW5lcldpZHRoKCk7XG4gICAgICAgICAgICB0aGlzLm9wdHMuZWxlbWVudC5oaWRlKCk7XG5cbiAgICAgICAgICAgIC8vIHNldCB0aGUgcGxhY2Vob2xkZXIgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICB0aGlzLmNsZWFyU2VhcmNoKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gbXVsdGlcbiAgICAgICAgZW5hYmxlSW50ZXJmYWNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudC5lbmFibGVJbnRlcmZhY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoLnByb3AoXCJkaXNhYmxlZFwiLCAhdGhpcy5pc0ludGVyZmFjZUVuYWJsZWQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gbXVsdGlcbiAgICAgICAgaW5pdFNlbGVjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLmVsZW1lbnQudmFsKCkgPT09IFwiXCIgJiYgdGhpcy5vcHRzLmVsZW1lbnQudGV4dCgpID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTZWxlY3Rpb24oW10pO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAvLyBzZXQgdGhlIHBsYWNlaG9sZGVyIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJTZWFyY2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdCB8fCB0aGlzLm9wdHMuZWxlbWVudC52YWwoKSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLm9wdHMuaW5pdFNlbGVjdGlvbi5jYWxsKG51bGwsIHRoaXMub3B0cy5lbGVtZW50LCBmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCAmJiBkYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZVNlbGVjdGlvbihkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldCB0aGUgcGxhY2Vob2xkZXIgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNsZWFyU2VhcmNoKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBtdWx0aVxuICAgICAgICBjbGVhclNlYXJjaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gdGhpcy5nZXRQbGFjZWhvbGRlcigpLFxuICAgICAgICAgICAgICAgIG1heFdpZHRoID0gdGhpcy5nZXRNYXhTZWFyY2hXaWR0aCgpO1xuXG4gICAgICAgICAgICBpZiAocGxhY2Vob2xkZXIgIT09IHVuZGVmaW5lZCAgJiYgdGhpcy5nZXRWYWwoKS5sZW5ndGggPT09IDAgJiYgdGhpcy5zZWFyY2guaGFzQ2xhc3MoXCJzZWxlY3QyLWZvY3VzZWRcIikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWFyY2gudmFsKHBsYWNlaG9sZGVyKS5hZGRDbGFzcyhcInNlbGVjdDItZGVmYXVsdFwiKTtcbiAgICAgICAgICAgICAgICAvLyBzdHJldGNoIHRoZSBzZWFyY2ggYm94IHRvIGZ1bGwgd2lkdGggb2YgdGhlIGNvbnRhaW5lciBzbyBhcyBtdWNoIG9mIHRoZSBwbGFjZWhvbGRlciBpcyB2aXNpYmxlIGFzIHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgLy8gd2UgY291bGQgY2FsbCB0aGlzLnJlc2l6ZVNlYXJjaCgpLCBidXQgd2UgZG8gbm90IGJlY2F1c2UgdGhhdCByZXF1aXJlcyBhIHNpemVyIGFuZCB3ZSBkbyBub3Qgd2FudCB0byBjcmVhdGUgb25lIHNvIGVhcmx5IGJlY2F1c2Ugb2YgYSBmaXJlZm94IGJ1Zywgc2VlICM5NDRcbiAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaC53aWR0aChtYXhXaWR0aCA+IDAgPyBtYXhXaWR0aCA6IHRoaXMuY29udGFpbmVyLmNzcyhcIndpZHRoXCIpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWFyY2gudmFsKFwiXCIpLndpZHRoKDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBtdWx0aVxuICAgICAgICBjbGVhclBsYWNlaG9sZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZWFyY2guaGFzQ2xhc3MoXCJzZWxlY3QyLWRlZmF1bHRcIikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaC52YWwoXCJcIikucmVtb3ZlQ2xhc3MoXCJzZWxlY3QyLWRlZmF1bHRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gbXVsdGlcbiAgICAgICAgb3BlbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5jbGVhclBsYWNlaG9sZGVyKCk7IC8vIHNob3VsZCBiZSBkb25lIGJlZm9yZSBzdXBlciBzbyBwbGFjZWhvbGRlciBpcyBub3QgdXNlZCB0byBzZWFyY2hcbiAgICAgICAgICAgIHRoaXMucmVzaXplU2VhcmNoKCk7XG5cbiAgICAgICAgICAgIHRoaXMucGFyZW50Lm9wZW5pbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgdGhpcy5mb2N1c1NlYXJjaCgpO1xuXG4gICAgICAgICAgICAvLyBpbml0aWFsaXplcyBzZWFyY2gncyB2YWx1ZSB3aXRoIG5leHRTZWFyY2hUZXJtIChpZiBkZWZpbmVkIGJ5IHVzZXIpXG4gICAgICAgICAgICAvLyBpZ25vcmUgbmV4dFNlYXJjaFRlcm0gaWYgdGhlIGRyb3Bkb3duIGlzIG9wZW5lZCBieSB0aGUgdXNlciBwcmVzc2luZyBhIGxldHRlclxuICAgICAgICAgICAgaWYodGhpcy5zZWFyY2gudmFsKCkgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLm5leHRTZWFyY2hUZXJtICE9IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoLnZhbCh0aGlzLm5leHRTZWFyY2hUZXJtKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWFyY2guc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVJlc3VsdHModHJ1ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLnNob3VsZEZvY3VzSW5wdXQodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaC5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vcHRzLmVsZW1lbnQudHJpZ2dlcigkLkV2ZW50KFwic2VsZWN0Mi1vcGVuXCIpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBtdWx0aVxuICAgICAgICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLm9wZW5lZCgpKSByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5jbG9zZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIG11bHRpXG4gICAgICAgIGZvY3VzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnNlYXJjaC5mb2N1cygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIG11bHRpXG4gICAgICAgIGlzRm9jdXNlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoLmhhc0NsYXNzKFwic2VsZWN0Mi1mb2N1c2VkXCIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIG11bHRpXG4gICAgICAgIHVwZGF0ZVNlbGVjdGlvbjogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBpZHMgPSBbXSwgZmlsdGVyZWQgPSBbXSwgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgZHVwbGljYXRlc1xuICAgICAgICAgICAgJChkYXRhKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXhPZihzZWxmLmlkKHRoaXMpLCBpZHMpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBpZHMucHVzaChzZWxmLmlkKHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWQucHVzaCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRhdGEgPSBmaWx0ZXJlZDtcblxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uZmluZChcIi5zZWxlY3QyLXNlYXJjaC1jaG9pY2VcIikucmVtb3ZlKCk7XG4gICAgICAgICAgICAkKGRhdGEpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuYWRkU2VsZWN0ZWRDaG9pY2UodGhpcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGYucG9zdHByb2Nlc3NSZXN1bHRzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gbXVsdGlcbiAgICAgICAgdG9rZW5pemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5zZWFyY2gudmFsKCk7XG4gICAgICAgICAgICBpbnB1dCA9IHRoaXMub3B0cy50b2tlbml6ZXIuY2FsbCh0aGlzLCBpbnB1dCwgdGhpcy5kYXRhKCksIHRoaXMuYmluZCh0aGlzLm9uU2VsZWN0KSwgdGhpcy5vcHRzKTtcbiAgICAgICAgICAgIGlmIChpbnB1dCAhPSBudWxsICYmIGlucHV0ICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoLnZhbChpbnB1dCk7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gbXVsdGlcbiAgICAgICAgb25TZWxlY3Q6IGZ1bmN0aW9uIChkYXRhLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy50cmlnZ2VyU2VsZWN0KGRhdGEpIHx8IGRhdGEudGV4dCA9PT0gXCJcIikgeyByZXR1cm47IH1cblxuICAgICAgICAgICAgdGhpcy5hZGRTZWxlY3RlZENob2ljZShkYXRhKTtcblxuICAgICAgICAgICAgdGhpcy5vcHRzLmVsZW1lbnQudHJpZ2dlcih7IHR5cGU6IFwic2VsZWN0ZWRcIiwgdmFsOiB0aGlzLmlkKGRhdGEpLCBjaG9pY2U6IGRhdGEgfSk7XG5cbiAgICAgICAgICAgIC8vIGtlZXAgdHJhY2sgb2YgdGhlIHNlYXJjaCdzIHZhbHVlIGJlZm9yZSBpdCBnZXRzIGNsZWFyZWRcbiAgICAgICAgICAgIHRoaXMubmV4dFNlYXJjaFRlcm0gPSB0aGlzLm9wdHMubmV4dFNlYXJjaFRlcm0oZGF0YSwgdGhpcy5zZWFyY2gudmFsKCkpO1xuXG4gICAgICAgICAgICB0aGlzLmNsZWFyU2VhcmNoKCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVJlc3VsdHMoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0IHx8ICF0aGlzLm9wdHMuY2xvc2VPblNlbGVjdCkgdGhpcy5wb3N0cHJvY2Vzc1Jlc3VsdHMoZGF0YSwgZmFsc2UsIHRoaXMub3B0cy5jbG9zZU9uU2VsZWN0PT09dHJ1ZSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuY2xvc2VPblNlbGVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaC53aWR0aCgxMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvdW50U2VsZWN0YWJsZVJlc3VsdHMoKT4wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoLndpZHRoKDEwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNpemVTZWFyY2goKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0TWF4aW11bVNlbGVjdGlvblNpemUoKSA+IDAgJiYgdGhpcy52YWwoKS5sZW5ndGggPj0gdGhpcy5nZXRNYXhpbXVtU2VsZWN0aW9uU2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSByZWFjaGVkIG1heCBzZWxlY3Rpb24gc2l6ZSByZXBhaW50IHRoZSByZXN1bHRzIHNvIGNob2ljZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFyZSByZXBsYWNlZCB3aXRoIHRoZSBtYXggc2VsZWN0aW9uIHJlYWNoZWQgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVSZXN1bHRzKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZXMgc2VhcmNoJ3MgdmFsdWUgd2l0aCBuZXh0U2VhcmNoVGVybSBhbmQgdXBkYXRlIHNlYXJjaCByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMubmV4dFNlYXJjaFRlcm0gIT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaC52YWwodGhpcy5uZXh0U2VhcmNoVGVybSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVSZXN1bHRzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWFyY2guc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbkRyb3Bkb3duKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm90aGluZyBsZWZ0IHRvIHNlbGVjdCBjbG9zZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoLndpZHRoKDEwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNpbmNlIGl0cyBub3QgcG9zc2libGUgdG8gc2VsZWN0IGFuIGVsZW1lbnQgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG4gICAgICAgICAgICAvLyBhZGRlZCB3ZSBkbyBub3QgbmVlZCB0byBjaGVjayBpZiB0aGlzIGlzIGEgbmV3IGVsZW1lbnQgYmVmb3JlIGZpcmluZyBjaGFuZ2VcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckNoYW5nZSh7IGFkZGVkOiBkYXRhIH0pO1xuXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMubm9Gb2N1cylcbiAgICAgICAgICAgICAgICB0aGlzLmZvY3VzU2VhcmNoKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gbXVsdGlcbiAgICAgICAgY2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLmZvY3VzU2VhcmNoKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkU2VsZWN0ZWRDaG9pY2U6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgZW5hYmxlQ2hvaWNlID0gIWRhdGEubG9ja2VkLFxuICAgICAgICAgICAgICAgIGVuYWJsZWRJdGVtID0gJChcbiAgICAgICAgICAgICAgICAgICAgXCI8bGkgY2xhc3M9J3NlbGVjdDItc2VhcmNoLWNob2ljZSc+XCIgK1xuICAgICAgICAgICAgICAgICAgICBcIiAgICA8ZGl2PjwvZGl2PlwiICtcbiAgICAgICAgICAgICAgICAgICAgXCIgICAgPGEgaHJlZj0nIycgY2xhc3M9J3NlbGVjdDItc2VhcmNoLWNob2ljZS1jbG9zZScgdGFiaW5kZXg9Jy0xJz48L2E+XCIgK1xuICAgICAgICAgICAgICAgICAgICBcIjwvbGk+XCIpLFxuICAgICAgICAgICAgICAgIGRpc2FibGVkSXRlbSA9ICQoXG4gICAgICAgICAgICAgICAgICAgIFwiPGxpIGNsYXNzPSdzZWxlY3QyLXNlYXJjaC1jaG9pY2Ugc2VsZWN0Mi1sb2NrZWQnPlwiICtcbiAgICAgICAgICAgICAgICAgICAgXCI8ZGl2PjwvZGl2PlwiICtcbiAgICAgICAgICAgICAgICAgICAgXCI8L2xpPlwiKTtcbiAgICAgICAgICAgIHZhciBjaG9pY2UgPSBlbmFibGVDaG9pY2UgPyBlbmFibGVkSXRlbSA6IGRpc2FibGVkSXRlbSxcbiAgICAgICAgICAgICAgICBpZCA9IHRoaXMuaWQoZGF0YSksXG4gICAgICAgICAgICAgICAgdmFsID0gdGhpcy5nZXRWYWwoKSxcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWQsXG4gICAgICAgICAgICAgICAgY3NzQ2xhc3M7XG5cbiAgICAgICAgICAgIGZvcm1hdHRlZD10aGlzLm9wdHMuZm9ybWF0U2VsZWN0aW9uKGRhdGEsIGNob2ljZS5maW5kKFwiZGl2XCIpLCB0aGlzLm9wdHMuZXNjYXBlTWFya3VwKTtcbiAgICAgICAgICAgIGlmIChmb3JtYXR0ZWQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY2hvaWNlLmZpbmQoXCJkaXZcIikucmVwbGFjZVdpdGgoJChcIjxkaXY+PC9kaXY+XCIpLmh0bWwoZm9ybWF0dGVkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjc3NDbGFzcz10aGlzLm9wdHMuZm9ybWF0U2VsZWN0aW9uQ3NzQ2xhc3MoZGF0YSwgY2hvaWNlLmZpbmQoXCJkaXZcIikpO1xuICAgICAgICAgICAgaWYgKGNzc0NsYXNzICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNob2ljZS5hZGRDbGFzcyhjc3NDbGFzcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGVuYWJsZUNob2ljZSl7XG4gICAgICAgICAgICAgIGNob2ljZS5maW5kKFwiLnNlbGVjdDItc2VhcmNoLWNob2ljZS1jbG9zZVwiKVxuICAgICAgICAgICAgICAgICAgLm9uKFwibW91c2Vkb3duXCIsIGtpbGxFdmVudClcbiAgICAgICAgICAgICAgICAgIC5vbihcImNsaWNrIGRibGNsaWNrXCIsIHRoaXMuYmluZChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzSW50ZXJmYWNlRW5hYmxlZCgpKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgIHRoaXMudW5zZWxlY3QoJChlLnRhcmdldCkpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uZmluZChcIi5zZWxlY3QyLXNlYXJjaC1jaG9pY2UtZm9jdXNcIikucmVtb3ZlQ2xhc3MoXCJzZWxlY3QyLXNlYXJjaC1jaG9pY2UtZm9jdXNcIik7XG4gICAgICAgICAgICAgICAgICBraWxsRXZlbnQoZSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICB0aGlzLmZvY3VzU2VhcmNoKCk7XG4gICAgICAgICAgICAgIH0pKS5vbihcImZvY3VzXCIsIHRoaXMuYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNJbnRlcmZhY2VFbmFibGVkKCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENsYXNzKFwic2VsZWN0Mi1jb250YWluZXItYWN0aXZlXCIpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wZG93bi5hZGRDbGFzcyhcInNlbGVjdDItZHJvcC1hY3RpdmVcIik7XG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hvaWNlLmRhdGEoXCJzZWxlY3QyLWRhdGFcIiwgZGF0YSk7XG4gICAgICAgICAgICBjaG9pY2UuaW5zZXJ0QmVmb3JlKHRoaXMuc2VhcmNoQ29udGFpbmVyKTtcblxuICAgICAgICAgICAgdmFsLnB1c2goaWQpO1xuICAgICAgICAgICAgdGhpcy5zZXRWYWwodmFsKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBtdWx0aVxuICAgICAgICB1bnNlbGVjdDogZnVuY3Rpb24gKHNlbGVjdGVkKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gdGhpcy5nZXRWYWwoKSxcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIGluZGV4O1xuICAgICAgICAgICAgc2VsZWN0ZWQgPSBzZWxlY3RlZC5jbG9zZXN0KFwiLnNlbGVjdDItc2VhcmNoLWNob2ljZVwiKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IFwiSW52YWxpZCBhcmd1bWVudDogXCIgKyBzZWxlY3RlZCArIFwiLiBNdXN0IGJlIC5zZWxlY3QyLXNlYXJjaC1jaG9pY2VcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0YSA9IHNlbGVjdGVkLmRhdGEoXCJzZWxlY3QyLWRhdGFcIik7XG5cbiAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgYSByYWNlIGNvbmRpdGlvbiB3aGVuIHRoZSAneCcgaXMgY2xpY2tlZCByZWFsbHkgZmFzdCByZXBlYXRlZGx5IHRoZSBldmVudCBjYW4gYmUgcXVldWVkXG4gICAgICAgICAgICAgICAgLy8gYW5kIGludm9rZWQgb24gYW4gZWxlbWVudCBhbHJlYWR5IHJlbW92ZWRcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBldnQgPSAkLkV2ZW50KFwic2VsZWN0Mi1yZW1vdmluZ1wiKTtcbiAgICAgICAgICAgIGV2dC52YWwgPSB0aGlzLmlkKGRhdGEpO1xuICAgICAgICAgICAgZXZ0LmNob2ljZSA9IGRhdGE7XG4gICAgICAgICAgICB0aGlzLm9wdHMuZWxlbWVudC50cmlnZ2VyKGV2dCk7XG5cbiAgICAgICAgICAgIGlmIChldnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdoaWxlKChpbmRleCA9IGluZGV4T2YodGhpcy5pZChkYXRhKSwgdmFsKSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHZhbC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsKHZhbCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0KSB0aGlzLnBvc3Rwcm9jZXNzUmVzdWx0cygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxlY3RlZC5yZW1vdmUoKTtcblxuICAgICAgICAgICAgdGhpcy5vcHRzLmVsZW1lbnQudHJpZ2dlcih7IHR5cGU6IFwic2VsZWN0Mi1yZW1vdmVkXCIsIHZhbDogdGhpcy5pZChkYXRhKSwgY2hvaWNlOiBkYXRhIH0pO1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyQ2hhbmdlKHsgcmVtb3ZlZDogZGF0YSB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gbXVsdGlcbiAgICAgICAgcG9zdHByb2Nlc3NSZXN1bHRzOiBmdW5jdGlvbiAoZGF0YSwgaW5pdGlhbCwgbm9IaWdobGlnaHRVcGRhdGUpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLmdldFZhbCgpLFxuICAgICAgICAgICAgICAgIGNob2ljZXMgPSB0aGlzLnJlc3VsdHMuZmluZChcIi5zZWxlY3QyLXJlc3VsdFwiKSxcbiAgICAgICAgICAgICAgICBjb21wb3VuZCA9IHRoaXMucmVzdWx0cy5maW5kKFwiLnNlbGVjdDItcmVzdWx0LXdpdGgtY2hpbGRyZW5cIiksXG4gICAgICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIGNob2ljZXMuZWFjaDIoZnVuY3Rpb24gKGksIGNob2ljZSkge1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IHNlbGYuaWQoY2hvaWNlLmRhdGEoXCJzZWxlY3QyLWRhdGFcIikpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleE9mKGlkLCB2YWwpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hvaWNlLmFkZENsYXNzKFwic2VsZWN0Mi1zZWxlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFyayBhbGwgY2hpbGRyZW4gb2YgdGhlIHNlbGVjdGVkIHBhcmVudCBhcyBzZWxlY3RlZFxuICAgICAgICAgICAgICAgICAgICBjaG9pY2UuZmluZChcIi5zZWxlY3QyLXJlc3VsdC1zZWxlY3RhYmxlXCIpLmFkZENsYXNzKFwic2VsZWN0Mi1zZWxlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29tcG91bmQuZWFjaDIoZnVuY3Rpb24oaSwgY2hvaWNlKSB7XG4gICAgICAgICAgICAgICAgLy8gaGlkZSBhbiBvcHRncm91cCBpZiBpdCBkb2Vzbid0IGhhdmUgYW55IHNlbGVjdGFibGUgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICBpZiAoIWNob2ljZS5pcygnLnNlbGVjdDItcmVzdWx0LXNlbGVjdGFibGUnKVxuICAgICAgICAgICAgICAgICAgICAmJiBjaG9pY2UuZmluZChcIi5zZWxlY3QyLXJlc3VsdC1zZWxlY3RhYmxlOm5vdCguc2VsZWN0Mi1zZWxlY3RlZClcIikubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNob2ljZS5hZGRDbGFzcyhcInNlbGVjdDItc2VsZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmhpZ2hsaWdodCgpID09IC0xICYmIG5vSGlnaGxpZ2h0VXBkYXRlICE9PSBmYWxzZSAmJiB0aGlzLm9wdHMuY2xvc2VPblNlbGVjdCA9PT0gdHJ1ZSl7XG4gICAgICAgICAgICAgICAgc2VsZi5oaWdobGlnaHQoMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vSWYgYWxsIHJlc3VsdHMgYXJlIGNob3NlbiByZW5kZXIgZm9ybWF0Tm9NYXRjaGVzXG4gICAgICAgICAgICBpZighdGhpcy5vcHRzLmNyZWF0ZVNlYXJjaENob2ljZSAmJiAhY2hvaWNlcy5maWx0ZXIoJy5zZWxlY3QyLXJlc3VsdDpub3QoLnNlbGVjdDItc2VsZWN0ZWQpJykubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICAgICAgaWYoIWRhdGEgfHwgZGF0YSAmJiAhZGF0YS5tb3JlICYmIHRoaXMucmVzdWx0cy5maW5kKFwiLnNlbGVjdDItbm8tcmVzdWx0c1wiKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrRm9ybWF0dGVyKHNlbGYub3B0cy5mb3JtYXROb01hdGNoZXMsIFwiZm9ybWF0Tm9NYXRjaGVzXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdHMuYXBwZW5kKFwiPGxpIGNsYXNzPSdzZWxlY3QyLW5vLXJlc3VsdHMnPlwiICsgZXZhbHVhdGUoc2VsZi5vcHRzLmZvcm1hdE5vTWF0Y2hlcywgc2VsZi5vcHRzLmVsZW1lbnQsIHNlbGYuc2VhcmNoLnZhbCgpKSArIFwiPC9saT5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBtdWx0aVxuICAgICAgICBnZXRNYXhTZWFyY2hXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24ud2lkdGgoKSAtIGdldFNpZGVCb3JkZXJQYWRkaW5nKHRoaXMuc2VhcmNoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBtdWx0aVxuICAgICAgICByZXNpemVTZWFyY2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtaW5pbXVtV2lkdGgsIGxlZnQsIG1heFdpZHRoLCBjb250YWluZXJMZWZ0LCBzZWFyY2hXaWR0aCxcbiAgICAgICAgICAgICAgICBzaWRlQm9yZGVyUGFkZGluZyA9IGdldFNpZGVCb3JkZXJQYWRkaW5nKHRoaXMuc2VhcmNoKTtcblxuICAgICAgICAgICAgbWluaW11bVdpZHRoID0gbWVhc3VyZVRleHRXaWR0aCh0aGlzLnNlYXJjaCkgKyAxMDtcblxuICAgICAgICAgICAgbGVmdCA9IHRoaXMuc2VhcmNoLm9mZnNldCgpLmxlZnQ7XG5cbiAgICAgICAgICAgIG1heFdpZHRoID0gdGhpcy5zZWxlY3Rpb24ud2lkdGgoKTtcbiAgICAgICAgICAgIGNvbnRhaW5lckxlZnQgPSB0aGlzLnNlbGVjdGlvbi5vZmZzZXQoKS5sZWZ0O1xuXG4gICAgICAgICAgICBzZWFyY2hXaWR0aCA9IG1heFdpZHRoIC0gKGxlZnQgLSBjb250YWluZXJMZWZ0KSAtIHNpZGVCb3JkZXJQYWRkaW5nO1xuXG4gICAgICAgICAgICBpZiAoc2VhcmNoV2lkdGggPCBtaW5pbXVtV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBzZWFyY2hXaWR0aCA9IG1heFdpZHRoIC0gc2lkZUJvcmRlclBhZGRpbmc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWFyY2hXaWR0aCA8IDQwKSB7XG4gICAgICAgICAgICAgICAgc2VhcmNoV2lkdGggPSBtYXhXaWR0aCAtIHNpZGVCb3JkZXJQYWRkaW5nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VhcmNoV2lkdGggPD0gMCkge1xuICAgICAgICAgICAgICBzZWFyY2hXaWR0aCA9IG1pbmltdW1XaWR0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zZWFyY2gud2lkdGgoTWF0aC5mbG9vcihzZWFyY2hXaWR0aCkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIG11bHRpXG4gICAgICAgIGdldFZhbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHZhbDtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdCkge1xuICAgICAgICAgICAgICAgIHZhbCA9IHRoaXMuc2VsZWN0LnZhbCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWwgPT09IG51bGwgPyBbXSA6IHZhbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsID0gdGhpcy5vcHRzLmVsZW1lbnQudmFsKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwbGl0VmFsKHZhbCwgdGhpcy5vcHRzLnNlcGFyYXRvciwgdGhpcy5vcHRzLnRyYW5zZm9ybVZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gbXVsdGlcbiAgICAgICAgc2V0VmFsOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB2YXIgdW5pcXVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3QudmFsKHZhbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVuaXF1ZSA9IFtdO1xuICAgICAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgZHVwbGljYXRlc1xuICAgICAgICAgICAgICAgICQodmFsKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4T2YodGhpcywgdW5pcXVlKSA8IDApIHVuaXF1ZS5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMub3B0cy5lbGVtZW50LnZhbCh1bmlxdWUubGVuZ3RoID09PSAwID8gXCJcIiA6IHVuaXF1ZS5qb2luKHRoaXMub3B0cy5zZXBhcmF0b3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBtdWx0aVxuICAgICAgICBidWlsZENoYW5nZURldGFpbHM6IGZ1bmN0aW9uIChvbGQsIGN1cnJlbnQpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gY3VycmVudC5zbGljZSgwKSxcbiAgICAgICAgICAgICAgICBvbGQgPSBvbGQuc2xpY2UoMCk7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSBpbnRlcnNlY3Rpb24gZnJvbSBlYWNoIGFycmF5XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1cnJlbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9sZC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXF1YWwodGhpcy5vcHRzLmlkKGN1cnJlbnRbaV0pLCB0aGlzLm9wdHMuaWQob2xkW2pdKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoaT4wKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvbGQuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge2FkZGVkOiBjdXJyZW50LCByZW1vdmVkOiBvbGR9O1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgLy8gbXVsdGlcbiAgICAgICAgdmFsOiBmdW5jdGlvbiAodmFsLCB0cmlnZ2VyQ2hhbmdlKSB7XG4gICAgICAgICAgICB2YXIgb2xkRGF0YSwgc2VsZj10aGlzO1xuXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFZhbCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvbGREYXRhPXRoaXMuZGF0YSgpO1xuICAgICAgICAgICAgaWYgKCFvbGREYXRhLmxlbmd0aCkgb2xkRGF0YT1bXTtcblxuICAgICAgICAgICAgLy8gdmFsIGlzIGFuIGlkLiAhdmFsIGlzIHRydWUgZm9yIFt1bmRlZmluZWQsbnVsbCwnJywwXSAtIDAgaXMgbGVnYWxcbiAgICAgICAgICAgIGlmICghdmFsICYmIHZhbCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0cy5lbGVtZW50LnZhbChcIlwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbihbXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclNlYXJjaCgpO1xuICAgICAgICAgICAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckNoYW5nZSh7YWRkZWQ6IHRoaXMuZGF0YSgpLCByZW1vdmVkOiBvbGREYXRhfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdmFsIGlzIGEgbGlzdCBvZiBpZHNcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsKHZhbCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0cy5pbml0U2VsZWN0aW9uKHRoaXMuc2VsZWN0LCB0aGlzLmJpbmQodGhpcy51cGRhdGVTZWxlY3Rpb24pKTtcbiAgICAgICAgICAgICAgICBpZiAodHJpZ2dlckNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJDaGFuZ2UodGhpcy5idWlsZENoYW5nZURldGFpbHMob2xkRGF0YSwgdGhpcy5kYXRhKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuaW5pdFNlbGVjdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInZhbCgpIGNhbm5vdCBiZSBjYWxsZWQgaWYgaW5pdFNlbGVjdGlvbigpIGlzIG5vdCBkZWZpbmVkXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMub3B0cy5pbml0U2VsZWN0aW9uKHRoaXMub3B0cy5lbGVtZW50LCBmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkcz0kLm1hcChkYXRhLCBzZWxmLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXRWYWwoaWRzKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi51cGRhdGVTZWxlY3Rpb24oZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2xlYXJTZWFyY2goKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyaWdnZXJDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlckNoYW5nZShzZWxmLmJ1aWxkQ2hhbmdlRGV0YWlscyhvbGREYXRhLCBzZWxmLmRhdGEoKSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsZWFyU2VhcmNoKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gbXVsdGlcbiAgICAgICAgb25Tb3J0U3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU29ydGluZyBvZiBlbGVtZW50cyBpcyBub3Qgc3VwcG9ydGVkIHdoZW4gYXR0YWNoZWQgdG8gPHNlbGVjdD4uIEF0dGFjaCB0byA8aW5wdXQgdHlwZT0naGlkZGVuJy8+IGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjb2xsYXBzZSBzZWFyY2ggZmllbGQgaW50byAwIHdpZHRoIHNvIGl0cyBjb250YWluZXIgY2FuIGJlIGNvbGxhcHNlZCBhcyB3ZWxsXG4gICAgICAgICAgICB0aGlzLnNlYXJjaC53aWR0aCgwKTtcbiAgICAgICAgICAgIC8vIGhpZGUgdGhlIGNvbnRhaW5lclxuICAgICAgICAgICAgdGhpcy5zZWFyY2hDb250YWluZXIuaGlkZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIG11bHRpXG4gICAgICAgIG9uU29ydEVuZDpmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgdmFyIHZhbD1bXSwgc2VsZj10aGlzO1xuXG4gICAgICAgICAgICAvLyBzaG93IHNlYXJjaCBhbmQgbW92ZSBpdCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0XG4gICAgICAgICAgICB0aGlzLnNlYXJjaENvbnRhaW5lci5zaG93KCk7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIHNlYXJjaCBjb250YWluZXIgaXMgdGhlIGxhc3QgaXRlbSBpbiB0aGUgbGlzdFxuICAgICAgICAgICAgdGhpcy5zZWFyY2hDb250YWluZXIuYXBwZW5kVG8odGhpcy5zZWFyY2hDb250YWluZXIucGFyZW50KCkpO1xuICAgICAgICAgICAgLy8gc2luY2Ugd2UgY29sbGFwc2VkIHRoZSB3aWR0aCBpbiBkcmFnU3RhcnRlZCwgd2UgcmVzaXplIGl0IGhlcmVcbiAgICAgICAgICAgIHRoaXMucmVzaXplU2VhcmNoKCk7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBzZWxlY3Rpb25cbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLmZpbmQoXCIuc2VsZWN0Mi1zZWFyY2gtY2hvaWNlXCIpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFsLnB1c2goc2VsZi5vcHRzLmlkKCQodGhpcykuZGF0YShcInNlbGVjdDItZGF0YVwiKSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnNldFZhbCh2YWwpO1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyQ2hhbmdlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gbXVsdGlcbiAgICAgICAgZGF0YTogZnVuY3Rpb24odmFsdWVzLCB0cmlnZ2VyQ2hhbmdlKSB7XG4gICAgICAgICAgICB2YXIgc2VsZj10aGlzLCBpZHMsIG9sZDtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgLmNoaWxkcmVuKFwiLnNlbGVjdDItc2VhcmNoLWNob2ljZVwiKVxuICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbigpIHsgcmV0dXJuICQodGhpcykuZGF0YShcInNlbGVjdDItZGF0YVwiKTsgfSlcbiAgICAgICAgICAgICAgICAgICAgIC5nZXQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb2xkID0gdGhpcy5kYXRhKCk7XG4gICAgICAgICAgICAgICAgaWYgKCF2YWx1ZXMpIHsgdmFsdWVzID0gW107IH1cbiAgICAgICAgICAgICAgICBpZHMgPSAkLm1hcCh2YWx1ZXMsIGZ1bmN0aW9uKGUpIHsgcmV0dXJuIHNlbGYub3B0cy5pZChlKTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWYWwoaWRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbih2YWx1ZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJTZWFyY2goKTtcbiAgICAgICAgICAgICAgICBpZiAodHJpZ2dlckNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJDaGFuZ2UodGhpcy5idWlsZENoYW5nZURldGFpbHMob2xkLCB0aGlzLmRhdGEoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgJC5mbi5zZWxlY3QyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSxcbiAgICAgICAgICAgIG9wdHMsXG4gICAgICAgICAgICBzZWxlY3QyLFxuICAgICAgICAgICAgbWV0aG9kLCB2YWx1ZSwgbXVsdGlwbGUsXG4gICAgICAgICAgICBhbGxvd2VkTWV0aG9kcyA9IFtcInZhbFwiLCBcImRlc3Ryb3lcIiwgXCJvcGVuZWRcIiwgXCJvcGVuXCIsIFwiY2xvc2VcIiwgXCJmb2N1c1wiLCBcImlzRm9jdXNlZFwiLCBcImNvbnRhaW5lclwiLCBcImRyb3Bkb3duXCIsIFwib25Tb3J0U3RhcnRcIiwgXCJvblNvcnRFbmRcIiwgXCJlbmFibGVcIiwgXCJkaXNhYmxlXCIsIFwicmVhZG9ubHlcIiwgXCJwb3NpdGlvbkRyb3Bkb3duXCIsIFwiZGF0YVwiLCBcInNlYXJjaFwiXSxcbiAgICAgICAgICAgIHZhbHVlTWV0aG9kcyA9IFtcIm9wZW5lZFwiLCBcImlzRm9jdXNlZFwiLCBcImNvbnRhaW5lclwiLCBcImRyb3Bkb3duXCJdLFxuICAgICAgICAgICAgcHJvcGVydHlNZXRob2RzID0gW1widmFsXCIsIFwiZGF0YVwiXSxcbiAgICAgICAgICAgIG1ldGhvZHNNYXAgPSB7IHNlYXJjaDogXCJleHRlcm5hbFNlYXJjaFwiIH07XG5cbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCB8fCB0eXBlb2YoYXJnc1swXSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBvcHRzID0gYXJncy5sZW5ndGggPT09IDAgPyB7fSA6ICQuZXh0ZW5kKHt9LCBhcmdzWzBdKTtcbiAgICAgICAgICAgICAgICBvcHRzLmVsZW1lbnQgPSAkKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdHMuZWxlbWVudC5nZXQoMCkudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInNlbGVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpcGxlID0gb3B0cy5lbGVtZW50LnByb3AoXCJtdWx0aXBsZVwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZSA9IG9wdHMubXVsdGlwbGUgfHwgZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcInRhZ3NcIiBpbiBvcHRzKSB7b3B0cy5tdWx0aXBsZSA9IG11bHRpcGxlID0gdHJ1ZTt9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2VsZWN0MiA9IG11bHRpcGxlID8gbmV3IHdpbmRvdy5TZWxlY3QyW1wiY2xhc3NcIl0ubXVsdGkoKSA6IG5ldyB3aW5kb3cuU2VsZWN0MltcImNsYXNzXCJdLnNpbmdsZSgpO1xuICAgICAgICAgICAgICAgIHNlbGVjdDIuaW5pdChvcHRzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKGFyZ3NbMF0pID09PSBcInN0cmluZ1wiKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXhPZihhcmdzWzBdLCBhbGxvd2VkTWV0aG9kcykgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IFwiVW5rbm93biBtZXRob2Q6IFwiICsgYXJnc1swXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBzZWxlY3QyID0gJCh0aGlzKS5kYXRhKFwic2VsZWN0MlwiKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0MiA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBtZXRob2Q9YXJnc1swXTtcblxuICAgICAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwiY29udGFpbmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzZWxlY3QyLmNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJkcm9wZG93blwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gc2VsZWN0Mi5kcm9wZG93bjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kc01hcFttZXRob2RdKSBtZXRob2QgPSBtZXRob2RzTWFwW21ldGhvZF07XG5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzZWxlY3QyW21ldGhvZF0uYXBwbHkoc2VsZWN0MiwgYXJncy5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmRleE9mKGFyZ3NbMF0sIHZhbHVlTWV0aG9kcykgPj0gMFxuICAgICAgICAgICAgICAgICAgICB8fCAoaW5kZXhPZihhcmdzWzBdLCBwcm9wZXJ0eU1ldGhvZHMpID49IDAgJiYgYXJncy5sZW5ndGggPT0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBhYm9ydCB0aGUgaXRlcmF0aW9uLCByZWFkeSB0byByZXR1cm4gZmlyc3QgbWF0Y2hlZCB2YWx1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIGFyZ3VtZW50cyB0byBzZWxlY3QyIHBsdWdpbjogXCIgKyBhcmdzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IHRoaXMgOiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgLy8gcGx1Z2luIGRlZmF1bHRzLCBhY2Nlc3NpYmxlIHRvIHVzZXJzXG4gICAgJC5mbi5zZWxlY3QyLmRlZmF1bHRzID0ge1xuICAgICAgICB3aWR0aDogXCJjb3B5XCIsXG4gICAgICAgIGxvYWRNb3JlUGFkZGluZzogMCxcbiAgICAgICAgY2xvc2VPblNlbGVjdDogdHJ1ZSxcbiAgICAgICAgb3Blbk9uRW50ZXI6IHRydWUsXG4gICAgICAgIGNvbnRhaW5lckNzczoge30sXG4gICAgICAgIGRyb3Bkb3duQ3NzOiB7fSxcbiAgICAgICAgY29udGFpbmVyQ3NzQ2xhc3M6IFwiXCIsXG4gICAgICAgIGRyb3Bkb3duQ3NzQ2xhc3M6IFwiXCIsXG4gICAgICAgIGZvcm1hdFJlc3VsdDogZnVuY3Rpb24ocmVzdWx0LCBjb250YWluZXIsIHF1ZXJ5LCBlc2NhcGVNYXJrdXApIHtcbiAgICAgICAgICAgIHZhciBtYXJrdXA9W107XG4gICAgICAgICAgICBtYXJrTWF0Y2godGhpcy50ZXh0KHJlc3VsdCksIHF1ZXJ5LnRlcm0sIG1hcmt1cCwgZXNjYXBlTWFya3VwKTtcbiAgICAgICAgICAgIHJldHVybiBtYXJrdXAuam9pbihcIlwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNmb3JtVmFsOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiAkLnRyaW0odmFsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0U2VsZWN0aW9uOiBmdW5jdGlvbiAoZGF0YSwgY29udGFpbmVyLCBlc2NhcGVNYXJrdXApIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhID8gZXNjYXBlTWFya3VwKHRoaXMudGV4dChkYXRhKSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNvcnRSZXN1bHRzOiBmdW5jdGlvbiAocmVzdWx0cywgY29udGFpbmVyLCBxdWVyeSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0sXG4gICAgICAgIGZvcm1hdFJlc3VsdENzc0NsYXNzOiBmdW5jdGlvbihkYXRhKSB7cmV0dXJuIGRhdGEuY3NzO30sXG4gICAgICAgIGZvcm1hdFNlbGVjdGlvbkNzc0NsYXNzOiBmdW5jdGlvbihkYXRhLCBjb250YWluZXIpIHtyZXR1cm4gdW5kZWZpbmVkO30sXG4gICAgICAgIG1pbmltdW1SZXN1bHRzRm9yU2VhcmNoOiAwLFxuICAgICAgICBtaW5pbXVtSW5wdXRMZW5ndGg6IDAsXG4gICAgICAgIG1heGltdW1JbnB1dExlbmd0aDogbnVsbCxcbiAgICAgICAgbWF4aW11bVNlbGVjdGlvblNpemU6IDAsXG4gICAgICAgIGlkOiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZSA9PSB1bmRlZmluZWQgPyBudWxsIDogZS5pZDsgfSxcbiAgICAgICAgdGV4dDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBpZiAoZSAmJiB0aGlzLmRhdGEgJiYgdGhpcy5kYXRhLnRleHQpIHtcbiAgICAgICAgICAgIGlmICgkLmlzRnVuY3Rpb24odGhpcy5kYXRhLnRleHQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEudGV4dChlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBlW3RoaXMuZGF0YS50ZXh0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGUudGV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1hdGNoZXI6IGZ1bmN0aW9uKHRlcm0sIHRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpcERpYWNyaXRpY3MoJycrdGV4dCkudG9VcHBlckNhc2UoKS5pbmRleE9mKHN0cmlwRGlhY3JpdGljcygnJyt0ZXJtKS50b1VwcGVyQ2FzZSgpKSA+PSAwO1xuICAgICAgICB9LFxuICAgICAgICBzZXBhcmF0b3I6IFwiLFwiLFxuICAgICAgICB0b2tlblNlcGFyYXRvcnM6IFtdLFxuICAgICAgICB0b2tlbml6ZXI6IGRlZmF1bHRUb2tlbml6ZXIsXG4gICAgICAgIGVzY2FwZU1hcmt1cDogZGVmYXVsdEVzY2FwZU1hcmt1cCxcbiAgICAgICAgYmx1ck9uQ2hhbmdlOiBmYWxzZSxcbiAgICAgICAgc2VsZWN0T25CbHVyOiBmYWxzZSxcbiAgICAgICAgYWRhcHRDb250YWluZXJDc3NDbGFzczogZnVuY3Rpb24oYykgeyByZXR1cm4gYzsgfSxcbiAgICAgICAgYWRhcHREcm9wZG93bkNzc0NsYXNzOiBmdW5jdGlvbihjKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICBuZXh0U2VhcmNoVGVybTogZnVuY3Rpb24oc2VsZWN0ZWRPYmplY3QsIGN1cnJlbnRTZWFyY2hUZXJtKSB7IHJldHVybiB1bmRlZmluZWQ7IH0sXG4gICAgICAgIHNlYXJjaElucHV0UGxhY2Vob2xkZXI6ICcnLFxuICAgICAgICBjcmVhdGVTZWFyY2hDaG9pY2VQb3NpdGlvbjogJ3RvcCcsXG4gICAgICAgIHNob3VsZEZvY3VzSW5wdXQ6IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byBkZXRlY3QgdG91Y2ggZGV2aWNlc1xuICAgICAgICAgICAgdmFyIHN1cHBvcnRzVG91Y2hFdmVudHMgPSAoKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChuYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50cyA+IDApKTtcblxuICAgICAgICAgICAgLy8gT25seSBkZXZpY2VzIHdoaWNoIHN1cHBvcnQgdG91Y2ggZXZlbnRzIHNob3VsZCBiZSBzcGVjaWFsIGNhc2VkXG4gICAgICAgICAgICBpZiAoIXN1cHBvcnRzVG91Y2hFdmVudHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTmV2ZXIgZm9jdXMgdGhlIGlucHV0IGlmIHNlYXJjaCBpcyBkaXNhYmxlZFxuICAgICAgICAgICAgaWYgKGluc3RhbmNlLm9wdHMubWluaW11bVJlc3VsdHNGb3JTZWFyY2ggPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAkLmZuLnNlbGVjdDIubG9jYWxlcyA9IFtdO1xuXG4gICAgJC5mbi5zZWxlY3QyLmxvY2FsZXNbJ2VuJ10gPSB7XG4gICAgICAgICBmb3JtYXRNYXRjaGVzOiBmdW5jdGlvbiAobWF0Y2hlcykgeyBpZiAobWF0Y2hlcyA9PT0gMSkgeyByZXR1cm4gXCJPbmUgcmVzdWx0IGlzIGF2YWlsYWJsZSwgcHJlc3MgZW50ZXIgdG8gc2VsZWN0IGl0LlwiOyB9IHJldHVybiBtYXRjaGVzICsgXCIgcmVzdWx0cyBhcmUgYXZhaWxhYmxlLCB1c2UgdXAgYW5kIGRvd24gYXJyb3cga2V5cyB0byBuYXZpZ2F0ZS5cIjsgfSxcbiAgICAgICAgIGZvcm1hdE5vTWF0Y2hlczogZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJObyBtYXRjaGVzIGZvdW5kXCI7IH0sXG4gICAgICAgICBmb3JtYXRBamF4RXJyb3I6IGZ1bmN0aW9uIChqcVhIUiwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pIHsgcmV0dXJuIFwiTG9hZGluZyBmYWlsZWRcIjsgfSxcbiAgICAgICAgIGZvcm1hdElucHV0VG9vU2hvcnQ6IGZ1bmN0aW9uIChpbnB1dCwgbWluKSB7IHZhciBuID0gbWluIC0gaW5wdXQubGVuZ3RoOyByZXR1cm4gXCJQbGVhc2UgZW50ZXIgXCIgKyBuICsgXCIgb3IgbW9yZSBjaGFyYWN0ZXJcIiArIChuID09IDEgPyBcIlwiIDogXCJzXCIpOyB9LFxuICAgICAgICAgZm9ybWF0SW5wdXRUb29Mb25nOiBmdW5jdGlvbiAoaW5wdXQsIG1heCkgeyB2YXIgbiA9IGlucHV0Lmxlbmd0aCAtIG1heDsgcmV0dXJuIFwiUGxlYXNlIGRlbGV0ZSBcIiArIG4gKyBcIiBjaGFyYWN0ZXJcIiArIChuID09IDEgPyBcIlwiIDogXCJzXCIpOyB9LFxuICAgICAgICAgZm9ybWF0U2VsZWN0aW9uVG9vQmlnOiBmdW5jdGlvbiAobGltaXQpIHsgcmV0dXJuIFwiWW91IGNhbiBvbmx5IHNlbGVjdCBcIiArIGxpbWl0ICsgXCIgaXRlbVwiICsgKGxpbWl0ID09IDEgPyBcIlwiIDogXCJzXCIpOyB9LFxuICAgICAgICAgZm9ybWF0TG9hZE1vcmU6IGZ1bmN0aW9uIChwYWdlTnVtYmVyKSB7IHJldHVybiBcIkxvYWRpbmcgbW9yZSByZXN1bHRz4oCmXCI7IH0sXG4gICAgICAgICBmb3JtYXRTZWFyY2hpbmc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiU2VhcmNoaW5n4oCmXCI7IH1cbiAgICB9O1xuXG4gICAgJC5leHRlbmQoJC5mbi5zZWxlY3QyLmRlZmF1bHRzLCAkLmZuLnNlbGVjdDIubG9jYWxlc1snZW4nXSk7XG5cbiAgICAkLmZuLnNlbGVjdDIuYWpheERlZmF1bHRzID0ge1xuICAgICAgICB0cmFuc3BvcnQ6ICQuYWpheCxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxuICAgICAgICAgICAgY2FjaGU6IGZhbHNlLFxuICAgICAgICAgICAgZGF0YVR5cGU6IFwianNvblwiXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gZXhwb3J0c1xuICAgIHdpbmRvdy5TZWxlY3QyID0ge1xuICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgYWpheDogYWpheCxcbiAgICAgICAgICAgIGxvY2FsOiBsb2NhbCxcbiAgICAgICAgICAgIHRhZ3M6IHRhZ3NcbiAgICAgICAgfSwgdXRpbDoge1xuICAgICAgICAgICAgZGVib3VuY2U6IGRlYm91bmNlLFxuICAgICAgICAgICAgbWFya01hdGNoOiBtYXJrTWF0Y2gsXG4gICAgICAgICAgICBlc2NhcGVNYXJrdXA6IGRlZmF1bHRFc2NhcGVNYXJrdXAsXG4gICAgICAgICAgICBzdHJpcERpYWNyaXRpY3M6IHN0cmlwRGlhY3JpdGljc1xuICAgICAgICB9LCBcImNsYXNzXCI6IHtcbiAgICAgICAgICAgIFwiYWJzdHJhY3RcIjogQWJzdHJhY3RTZWxlY3QyLFxuICAgICAgICAgICAgXCJzaW5nbGVcIjogU2luZ2xlU2VsZWN0MixcbiAgICAgICAgICAgIFwibXVsdGlcIjogTXVsdGlTZWxlY3QyXG4gICAgICAgIH1cbiAgICB9O1xuXG59KGpRdWVyeSkpO1xuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKlxuanF1ZXJ5LXRpbWVwaWNrZXIgdjEuMi4xNVxuaHR0cDovL2pvbnRob3JudG9uLmdpdGh1Yi5jb20vanF1ZXJ5LXRpbWVwaWNrZXIvXG5cbnJlcXVpcmVzIGpRdWVyeSAxLjcrXG4qKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG5cdFx0ZGVmaW5lKFsnanF1ZXJ5J10sIGZhY3RvcnkpO1xuXHR9IGVsc2Uge1xuXHRcdC8vIEJyb3dzZXIgZ2xvYmFsc1xuXHRcdGZhY3RvcnkoalF1ZXJ5KTtcblx0fVxufShmdW5jdGlvbiAoJCkge1xuXHR2YXIgX2Jhc2VEYXRlID0gX2dlbmVyYXRlQmFzZURhdGUoKTtcblx0dmFyIF9PTkVfREFZID0gODY0MDA7XG5cdHZhciBfZGVmYXVsdHMgPVx0e1xuXHRcdGNsYXNzTmFtZTogbnVsbCxcblx0XHRtaW5UaW1lOiBudWxsLFxuXHRcdG1heFRpbWU6IG51bGwsXG5cdFx0ZHVyYXRpb25UaW1lOiBudWxsLFxuXHRcdHN0ZXA6IDMwLFxuXHRcdHNob3dEdXJhdGlvbjogZmFsc2UsXG5cdFx0dGltZUZvcm1hdDogJ2c6aWEnLFxuXHRcdHNjcm9sbERlZmF1bHROb3c6IGZhbHNlLFxuXHRcdHNjcm9sbERlZmF1bHRUaW1lOiBmYWxzZSxcblx0XHRzZWxlY3RPbkJsdXI6IGZhbHNlLFxuXHRcdGRpc2FibGVUb3VjaEtleWJvYXJkOiBmYWxzZSxcblx0XHRmb3JjZVJvdW5kVGltZTogZmFsc2UsXG5cdFx0YXBwZW5kVG86ICdib2R5Jyxcblx0XHRkaXNhYmxlVGltZVJhbmdlczogW10sXG5cdFx0Y2xvc2VPbldpbmRvd1Njcm9sbDogZmFsc2UsXG5cdFx0ZGlzYWJsZVRleHRJbnB1dDogZmFsc2UsXG5cdFx0dHlwZWFoZWFkSGlnaGxpZ2h0OiB0cnVlXG5cdH07XG5cdHZhciBfbGFuZyA9IHtcblx0XHRkZWNpbWFsOiAnLicsXG5cdFx0bWluczogJ21pbnMnLFxuXHRcdGhyOiAnaHInLFxuXHRcdGhyczogJ2hycydcblx0fTtcblxuXHR2YXIgbWV0aG9kcyA9XG5cdHtcblx0XHRpbml0OiBmdW5jdGlvbihvcHRpb25zKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgc2VsZiA9ICQodGhpcyk7XG5cblx0XHRcdFx0Ly8gY29udmVydCBkcm9wZG93bnMgdG8gdGV4dCBpbnB1dFxuXHRcdFx0XHRpZiAoc2VsZlswXS50YWdOYW1lID09ICdTRUxFQ1QnKSB7XG5cdFx0XHRcdFx0dmFyIGF0dHJzID0geyAndHlwZSc6ICd0ZXh0JywgJ3ZhbHVlJzogc2VsZi52YWwoKSB9O1xuXHRcdFx0XHRcdHZhciByYXdfYXR0cnMgPSBzZWxmWzBdLmF0dHJpYnV0ZXM7XG5cblx0XHRcdFx0XHRmb3IgKHZhciBpPTA7IGkgPCByYXdfYXR0cnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGF0dHJzW3Jhd19hdHRyc1tpXS5ub2RlTmFtZV0gPSByYXdfYXR0cnNbaV0ubm9kZVZhbHVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciBpbnB1dCA9ICQoJzxpbnB1dCAvPicsIGF0dHJzKTtcblx0XHRcdFx0XHRzZWxmLnJlcGxhY2VXaXRoKGlucHV0KTtcblx0XHRcdFx0XHRzZWxmID0gaW5wdXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgc2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwgX2RlZmF1bHRzKTtcblxuXHRcdFx0XHRpZiAob3B0aW9ucykge1xuXHRcdFx0XHRcdHNldHRpbmdzID0gJC5leHRlbmQoc2V0dGluZ3MsIG9wdGlvbnMpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHNldHRpbmdzLmxhbmcpIHtcblx0XHRcdFx0XHRfbGFuZyA9ICQuZXh0ZW5kKF9sYW5nLCBzZXR0aW5ncy5sYW5nKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNldHRpbmdzID0gX3BhcnNlU2V0dGluZ3Moc2V0dGluZ3MpO1xuXG5cdFx0XHRcdHNlbGYuZGF0YSgndGltZXBpY2tlci1zZXR0aW5ncycsIHNldHRpbmdzKTtcblx0XHRcdFx0c2VsZi5wcm9wKCdhdXRvY29tcGxldGUnLCAnb2ZmJyk7XG5cdFx0XHRcdHNlbGYub24oJ2NsaWNrLnRpbWVwaWNrZXIgZm9jdXMudGltZXBpY2tlcicsIG1ldGhvZHMuc2hvdyk7XG5cdFx0XHRcdHNlbGYub24oJ2NoYW5nZS50aW1lcGlja2VyJywgX2Zvcm1hdFZhbHVlKTtcblx0XHRcdFx0c2VsZi5vbigna2V5ZG93bi50aW1lcGlja2VyJywgX2tleWRvd25oYW5kbGVyKTtcblx0XHRcdFx0c2VsZi5vbigna2V5dXAudGltZXBpY2tlcicsIF9rZXl1cGhhbmRsZXIpO1xuXHRcdFx0XHRzZWxmLmFkZENsYXNzKCd1aS10aW1lcGlja2VyLWlucHV0Jyk7XG5cblx0XHRcdFx0X2Zvcm1hdFZhbHVlLmNhbGwoc2VsZi5nZXQoMCkpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdHNob3c6IGZ1bmN0aW9uKGUpXG5cdFx0e1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHR2YXIgc2VsZiA9ICQodGhpcyk7XG5cdFx0XHR2YXIgc2V0dGluZ3MgPSBzZWxmLmRhdGEoJ3RpbWVwaWNrZXItc2V0dGluZ3MnKTtcblxuXHRcdFx0aWYgKF9oaWRlS2V5Ym9hcmQoc2VsZikpIHtcblx0XHRcdFx0Ly8gYmxvY2sgdGhlIGtleWJvYXJkIG9uIG1vYmlsZSBkZXZpY2VzXG5cdFx0XHRcdHNlbGYuYmx1cigpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbGlzdCA9IHNlbGYuZGF0YSgndGltZXBpY2tlci1saXN0Jyk7XG5cblx0XHRcdC8vIGNoZWNrIGlmIGlucHV0IGlzIHJlYWRvbmx5XG5cdFx0XHRpZiAoc2VsZi5wcm9wKCdyZWFkb25seScpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gY2hlY2sgaWYgbGlzdCBuZWVkcyB0byBiZSByZW5kZXJlZFxuXHRcdFx0aWYgKCFsaXN0IHx8IGxpc3QubGVuZ3RoID09PSAwIHx8IHR5cGVvZiBzZXR0aW5ncy5kdXJhdGlvblRpbWUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0X3JlbmRlcihzZWxmKTtcblx0XHRcdFx0bGlzdCA9IHNlbGYuZGF0YSgndGltZXBpY2tlci1saXN0Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChsaXN0LmlzKCc6dmlzaWJsZScpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gbWFrZSBzdXJlIG90aGVyIHBpY2tlcnMgYXJlIGhpZGRlblxuXHRcdFx0bWV0aG9kcy5oaWRlKCk7XG5cblx0XHRcdGxpc3Quc2hvdygpO1xuXG5cdFx0XHRpZiAoKHNlbGYub2Zmc2V0KCkudG9wICsgc2VsZi5vdXRlckhlaWdodCh0cnVlKSArIGxpc3Qub3V0ZXJIZWlnaHQoKSkgPiAkKHdpbmRvdykuaGVpZ2h0KCkgKyAkKHdpbmRvdykuc2Nyb2xsVG9wKCkpIHtcblx0XHRcdFx0Ly8gcG9zaXRpb24gdGhlIGRyb3Bkb3duIG9uIHRvcFxuXHRcdFx0XHRsaXN0Lm9mZnNldCh7XG5cdFx0XHRcdFx0J2xlZnQnOiBzZWxmLm9mZnNldCgpLmxlZnQgKyBwYXJzZUludChsaXN0LmNzcygnbWFyZ2luTGVmdCcpLnJlcGxhY2UoJ3B4JywgJycpLCAxMCksXG5cdFx0XHRcdFx0J3RvcCc6IHNlbGYub2Zmc2V0KCkudG9wIC0gbGlzdC5vdXRlckhlaWdodCgpICsgcGFyc2VJbnQobGlzdC5jc3MoJ21hcmdpblRvcCcpLnJlcGxhY2UoJ3B4JywgJycpLCAxMClcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBwdXQgaXQgdW5kZXIgdGhlIGlucHV0XG5cdFx0XHRcdGxpc3Qub2Zmc2V0KHtcblx0XHRcdFx0XHQnbGVmdCc6c2VsZi5vZmZzZXQoKS5sZWZ0ICsgcGFyc2VJbnQobGlzdC5jc3MoJ21hcmdpbkxlZnQnKS5yZXBsYWNlKCdweCcsICcnKSwgMTApLFxuXHRcdFx0XHRcdCd0b3AnOiBzZWxmLm9mZnNldCgpLnRvcCArIHNlbGYub3V0ZXJIZWlnaHQoKSArIHBhcnNlSW50KGxpc3QuY3NzKCdtYXJnaW5Ub3AnKS5yZXBsYWNlKCdweCcsICcnKSwgMTApXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwb3NpdGlvbiBzY3JvbGxpbmdcblx0XHRcdHZhciBzZWxlY3RlZCA9IGxpc3QuZmluZCgnLnVpLXRpbWVwaWNrZXItc2VsZWN0ZWQnKTtcblxuXHRcdFx0aWYgKCFzZWxlY3RlZC5sZW5ndGgpIHtcblx0XHRcdFx0aWYgKF9nZXRUaW1lVmFsdWUoc2VsZikpIHtcblx0XHRcdFx0XHRzZWxlY3RlZCA9IF9maW5kUm93KHNlbGYsIGxpc3QsIF90aW1lMmludChfZ2V0VGltZVZhbHVlKHNlbGYpKSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoc2V0dGluZ3Muc2Nyb2xsRGVmYXVsdE5vdykge1xuXHRcdFx0XHRcdHNlbGVjdGVkID0gX2ZpbmRSb3coc2VsZiwgbGlzdCwgX3RpbWUyaW50KG5ldyBEYXRlKCkpKTtcblx0XHRcdFx0fSBlbHNlIGlmIChzZXR0aW5ncy5zY3JvbGxEZWZhdWx0VGltZSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRzZWxlY3RlZCA9IF9maW5kUm93KHNlbGYsIGxpc3QsIF90aW1lMmludChzZXR0aW5ncy5zY3JvbGxEZWZhdWx0VGltZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChzZWxlY3RlZCAmJiBzZWxlY3RlZC5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIHRvcE9mZnNldCA9IGxpc3Quc2Nyb2xsVG9wKCkgKyBzZWxlY3RlZC5wb3NpdGlvbigpLnRvcCAtIHNlbGVjdGVkLm91dGVySGVpZ2h0KCk7XG5cdFx0XHRcdGxpc3Quc2Nyb2xsVG9wKHRvcE9mZnNldCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsaXN0LnNjcm9sbFRvcCgwKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYXR0YWNoIGNsb3NlIGhhbmRsZXJzXG5cdFx0XHQkKCdib2R5Jykub24oJ3RvdWNoc3RhcnQudWktdGltZXBpY2tlciBtb3VzZWRvd24udWktdGltZXBpY2tlcicsIF9jbG9zZUhhbmRsZXIpO1xuXHRcdFx0aWYgKHNldHRpbmdzLmNsb3NlT25XaW5kb3dTY3JvbGwpIHtcblx0XHRcdFx0JCh3aW5kb3cpLm9uKCdzY3JvbGwudWktdGltZXBpY2tlcicsIF9jbG9zZUhhbmRsZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxmLnRyaWdnZXIoJ3Nob3dUaW1lcGlja2VyJyk7XG5cdFx0fSxcblxuXHRcdGhpZGU6IGZ1bmN0aW9uKGUpXG5cdFx0e1xuXHRcdFx0JCgnLnVpLXRpbWVwaWNrZXItd3JhcHBlcjp2aXNpYmxlJykuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGxpc3QgPSAkKHRoaXMpO1xuXHRcdFx0XHR2YXIgc2VsZiA9IGxpc3QuZGF0YSgndGltZXBpY2tlci1pbnB1dCcpO1xuXHRcdFx0XHR2YXIgc2V0dGluZ3MgPSBzZWxmLmRhdGEoJ3RpbWVwaWNrZXItc2V0dGluZ3MnKTtcblxuXHRcdFx0XHRpZiAoc2V0dGluZ3MgJiYgc2V0dGluZ3Muc2VsZWN0T25CbHVyKSB7XG5cdFx0XHRcdFx0X3NlbGVjdFZhbHVlKHNlbGYpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGlzdC5oaWRlKCk7XG5cdFx0XHRcdHNlbGYudHJpZ2dlcignaGlkZVRpbWVwaWNrZXInKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRvcHRpb246IGZ1bmN0aW9uKGtleSwgdmFsdWUpXG5cdFx0e1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0dmFyIHNldHRpbmdzID0gc2VsZi5kYXRhKCd0aW1lcGlja2VyLXNldHRpbmdzJyk7XG5cdFx0XHR2YXIgbGlzdCA9IHNlbGYuZGF0YSgndGltZXBpY2tlci1saXN0Jyk7XG5cblx0XHRcdGlmICh0eXBlb2Yga2V5ID09ICdvYmplY3QnKSB7XG5cdFx0XHRcdHNldHRpbmdzID0gJC5leHRlbmQoc2V0dGluZ3MsIGtleSk7XG5cblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIGtleSA9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUgIT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0c2V0dGluZ3Nba2V5XSA9IHZhbHVlO1xuXG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0cmV0dXJuIHNldHRpbmdzW2tleV07XG5cdFx0XHR9XG5cblx0XHRcdHNldHRpbmdzID0gX3BhcnNlU2V0dGluZ3Moc2V0dGluZ3MpO1xuXG5cdFx0XHRzZWxmLmRhdGEoJ3RpbWVwaWNrZXItc2V0dGluZ3MnLCBzZXR0aW5ncyk7XG5cblx0XHRcdGlmIChsaXN0KSB7XG5cdFx0XHRcdGxpc3QucmVtb3ZlKCk7XG5cdFx0XHRcdHNlbGYuZGF0YSgndGltZXBpY2tlci1saXN0JywgZmFsc2UpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2VsZjtcblx0XHR9LFxuXG5cdFx0Z2V0U2Vjb25kc0Zyb21NaWRuaWdodDogZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdHJldHVybiBfdGltZTJpbnQoX2dldFRpbWVWYWx1ZSh0aGlzKSk7XG5cdFx0fSxcblxuXHRcdGdldFRpbWU6IGZ1bmN0aW9uKHJlbGF0aXZlX2RhdGUpXG5cdFx0e1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0XHR2YXIgdGltZV9zdHJpbmcgPSBfZ2V0VGltZVZhbHVlKHNlbGYpO1xuXHRcdFx0aWYgKCF0aW1lX3N0cmluZykge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFyZWxhdGl2ZV9kYXRlKSB7XG5cdFx0XHRcdHJlbGF0aXZlX2RhdGUgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZWxhdGl2ZV9kYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuXHRcdFx0cmV0dXJuIG5ldyBEYXRlKHJlbGF0aXZlX2RhdGUudmFsdWVPZigpICsgKF90aW1lMmludCh0aW1lX3N0cmluZykqMTAwMCkpO1xuXHRcdH0sXG5cblx0XHRzZXRUaW1lOiBmdW5jdGlvbih2YWx1ZSlcblx0XHR7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHR2YXIgcHJldHR5VGltZSA9IF9pbnQydGltZShfdGltZTJpbnQodmFsdWUpLCBzZWxmLmRhdGEoJ3RpbWVwaWNrZXItc2V0dGluZ3MnKS50aW1lRm9ybWF0KTtcblxuXHRcdFx0X3NldFRpbWVWYWx1ZShzZWxmLCBwcmV0dHlUaW1lKTtcblx0XHRcdGlmIChzZWxmLmRhdGEoJ3RpbWVwaWNrZXItbGlzdCcpKSB7XG5cdFx0XHRcdF9zZXRTZWxlY3RlZChzZWxmLCBzZWxmLmRhdGEoJ3RpbWVwaWNrZXItbGlzdCcpKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0cmVtb3ZlOiBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0XHQvLyBjaGVjayBpZiB0aGlzIGVsZW1lbnQgaXMgYSB0aW1lcGlja2VyXG5cdFx0XHRpZiAoIXNlbGYuaGFzQ2xhc3MoJ3VpLXRpbWVwaWNrZXItaW5wdXQnKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHNlbGYucmVtb3ZlQXR0cignYXV0b2NvbXBsZXRlJywgJ29mZicpO1xuXHRcdFx0c2VsZi5yZW1vdmVDbGFzcygndWktdGltZXBpY2tlci1pbnB1dCcpO1xuXHRcdFx0c2VsZi5yZW1vdmVEYXRhKCd0aW1lcGlja2VyLXNldHRpbmdzJyk7XG5cdFx0XHRzZWxmLm9mZignLnRpbWVwaWNrZXInKTtcblxuXHRcdFx0Ly8gdGltZXBpY2tlci1saXN0IHdvbid0IGJlIHByZXNlbnQgdW5sZXNzIHRoZSB1c2VyIGhhcyBpbnRlcmFjdGVkIHdpdGggdGhpcyB0aW1lcGlja2VyXG5cdFx0XHRpZiAoc2VsZi5kYXRhKCd0aW1lcGlja2VyLWxpc3QnKSkge1xuXHRcdFx0XHRzZWxmLmRhdGEoJ3RpbWVwaWNrZXItbGlzdCcpLnJlbW92ZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxmLnJlbW92ZURhdGEoJ3RpbWVwaWNrZXItbGlzdCcpO1xuXHRcdH1cblx0fTtcblxuXHQvLyBwcml2YXRlIG1ldGhvZHNcblxuXHRmdW5jdGlvbiBfcGFyc2VTZXR0aW5ncyhzZXR0aW5ncylcblx0e1xuXHRcdGlmIChzZXR0aW5ncy5taW5UaW1lKSB7XG5cdFx0XHRzZXR0aW5ncy5taW5UaW1lID0gX3RpbWUyaW50KHNldHRpbmdzLm1pblRpbWUpO1xuXHRcdH1cblxuXHRcdGlmIChzZXR0aW5ncy5tYXhUaW1lKSB7XG5cdFx0XHRzZXR0aW5ncy5tYXhUaW1lID0gX3RpbWUyaW50KHNldHRpbmdzLm1heFRpbWUpO1xuXHRcdH1cblxuXHRcdGlmIChzZXR0aW5ncy5kdXJhdGlvblRpbWUgJiYgdHlwZW9mIHNldHRpbmdzLmR1cmF0aW9uVGltZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0c2V0dGluZ3MuZHVyYXRpb25UaW1lID0gX3RpbWUyaW50KHNldHRpbmdzLmR1cmF0aW9uVGltZSk7XG5cdFx0fVxuXG5cdFx0aWYgKHNldHRpbmdzLmRpc2FibGVUaW1lUmFuZ2VzLmxlbmd0aCA+IDApIHtcblx0XHRcdC8vIGNvbnZlcnQgc3RyaW5nIHRpbWVzIHRvIGludGVnZXJzXG5cdFx0XHRmb3IgKHZhciBpIGluIHNldHRpbmdzLmRpc2FibGVUaW1lUmFuZ2VzKSB7XG5cdFx0XHRcdHNldHRpbmdzLmRpc2FibGVUaW1lUmFuZ2VzW2ldID0gW1xuXHRcdFx0XHRcdF90aW1lMmludChzZXR0aW5ncy5kaXNhYmxlVGltZVJhbmdlc1tpXVswXSksXG5cdFx0XHRcdFx0X3RpbWUyaW50KHNldHRpbmdzLmRpc2FibGVUaW1lUmFuZ2VzW2ldWzFdKVxuXHRcdFx0XHRdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBzb3J0IGJ5IHN0YXJ0aW5nIHRpbWVcblx0XHRcdHNldHRpbmdzLmRpc2FibGVUaW1lUmFuZ2VzID0gc2V0dGluZ3MuZGlzYWJsZVRpbWVSYW5nZXMuc29ydChmdW5jdGlvbihhLCBiKXtcblx0XHRcdFx0cmV0dXJuIGFbMF0gLSBiWzBdO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIG1lcmdlIGFueSBvdmVybGFwcGluZyByYW5nZXNcblx0XHRcdGZvciAodmFyIGkgPSBzZXR0aW5ncy5kaXNhYmxlVGltZVJhbmdlcy5sZW5ndGgtMTsgaSA+IDA7IGktLSkge1xuXHRcdFx0XHRpZiAoc2V0dGluZ3MuZGlzYWJsZVRpbWVSYW5nZXNbaV1bMF0gPD0gc2V0dGluZ3MuZGlzYWJsZVRpbWVSYW5nZXNbaS0xXVsxXSkge1xuXHRcdFx0XHRcdHNldHRpbmdzLmRpc2FibGVUaW1lUmFuZ2VzW2ktMV0gPSBbXG5cdFx0XHRcdFx0XHRNYXRoLm1pbihzZXR0aW5ncy5kaXNhYmxlVGltZVJhbmdlc1tpXVswXSwgc2V0dGluZ3MuZGlzYWJsZVRpbWVSYW5nZXNbaS0xXVswXSksXG5cdFx0XHRcdFx0XHRNYXRoLm1heChzZXR0aW5ncy5kaXNhYmxlVGltZVJhbmdlc1tpXVsxXSwgc2V0dGluZ3MuZGlzYWJsZVRpbWVSYW5nZXNbaS0xXVsxXSlcblx0XHRcdFx0XHRdO1xuXHRcdFx0XHRcdHNldHRpbmdzLmRpc2FibGVUaW1lUmFuZ2VzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBzZXR0aW5ncztcblx0fVxuXG5cdGZ1bmN0aW9uIF9yZW5kZXIoc2VsZilcblx0e1xuXHRcdHZhciBzZXR0aW5ncyA9IHNlbGYuZGF0YSgndGltZXBpY2tlci1zZXR0aW5ncycpO1xuXHRcdHZhciBsaXN0ID0gc2VsZi5kYXRhKCd0aW1lcGlja2VyLWxpc3QnKTtcblxuXHRcdGlmIChsaXN0ICYmIGxpc3QubGVuZ3RoKSB7XG5cdFx0XHRsaXN0LnJlbW92ZSgpO1xuXHRcdFx0c2VsZi5kYXRhKCd0aW1lcGlja2VyLWxpc3QnLCBmYWxzZSk7XG5cdFx0fVxuXG5cdFx0bGlzdCA9ICQoJzx1bCAvPicsIHsgJ2NsYXNzJzogJ3VpLXRpbWVwaWNrZXItbGlzdCcgfSk7XG5cblx0XHR2YXIgd3JhcHBlZF9saXN0ID0gJCgnPGRpdiAvPicsIHsgJ2NsYXNzJzogJ3VpLXRpbWVwaWNrZXItd3JhcHBlcicsICd0YWJpbmRleCc6IC0xIH0pO1xuXHRcdHdyYXBwZWRfbGlzdC5jc3MoeydkaXNwbGF5Jzonbm9uZScsICdwb3NpdGlvbic6ICdhYnNvbHV0ZScgfSkuYXBwZW5kKGxpc3QpO1xuXG5cblx0XHRpZiAoc2V0dGluZ3MuY2xhc3NOYW1lKSB7XG5cdFx0XHR3cmFwcGVkX2xpc3QuYWRkQ2xhc3Moc2V0dGluZ3MuY2xhc3NOYW1lKTtcblx0XHR9XG5cblx0XHRpZiAoKHNldHRpbmdzLm1pblRpbWUgIT09IG51bGwgfHwgc2V0dGluZ3MuZHVyYXRpb25UaW1lICE9PSBudWxsKSAmJiBzZXR0aW5ncy5zaG93RHVyYXRpb24pIHtcblx0XHRcdHdyYXBwZWRfbGlzdC5hZGRDbGFzcygndWktdGltZXBpY2tlci13aXRoLWR1cmF0aW9uJyk7XG5cdFx0fVxuXG5cdFx0dmFyIGR1clN0YXJ0ID0gc2V0dGluZ3MubWluVGltZTtcblx0XHRpZiAodHlwZW9mIHNldHRpbmdzLmR1cmF0aW9uVGltZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0ZHVyU3RhcnQgPSBfdGltZTJpbnQoc2V0dGluZ3MuZHVyYXRpb25UaW1lKCkpO1xuXHRcdH0gZWxzZSBpZiAoc2V0dGluZ3MuZHVyYXRpb25UaW1lICE9PSBudWxsKSB7XG5cdFx0XHRkdXJTdGFydCA9IHNldHRpbmdzLmR1cmF0aW9uVGltZTtcblx0XHR9XG5cdFx0dmFyIHN0YXJ0ID0gKHNldHRpbmdzLm1pblRpbWUgIT09IG51bGwpID8gc2V0dGluZ3MubWluVGltZSA6IDA7XG5cdFx0dmFyIGVuZCA9IChzZXR0aW5ncy5tYXhUaW1lICE9PSBudWxsKSA/IHNldHRpbmdzLm1heFRpbWUgOiAoc3RhcnQgKyBfT05FX0RBWSAtIDEpO1xuXG5cdFx0aWYgKGVuZCA8PSBzdGFydCkge1xuXHRcdFx0Ly8gbWFrZSBzdXJlIHRoZSBlbmQgdGltZSBpcyBncmVhdGVyIHRoYW4gc3RhcnQgdGltZSwgb3RoZXJ3aXNlIHRoZXJlIHdpbGwgYmUgbm8gbGlzdCB0byBzaG93XG5cdFx0XHRlbmQgKz0gX09ORV9EQVk7XG5cdFx0fVxuXG5cdFx0aWYgKGVuZCA9PT0gX09ORV9EQVktMSAmJiBzZXR0aW5ncy50aW1lRm9ybWF0LmluZGV4T2YoJ0gnKSAhPT0gLTEpIHtcblx0XHRcdC8vIHNob3cgYSAyNDowMCBvcHRpb24gd2hlbiB1c2luZyBtaWxpdGFyeSB0aW1lXG5cdFx0XHRlbmQgPSBfT05FX0RBWTtcblx0XHR9XG5cblx0XHR2YXIgZHIgPSBzZXR0aW5ncy5kaXNhYmxlVGltZVJhbmdlcztcblx0XHR2YXIgZHJDdXIgPSAwO1xuXHRcdHZhciBkckxlbiA9IGRyLmxlbmd0aDtcblxuXHRcdGZvciAodmFyIGk9c3RhcnQ7IGkgPD0gZW5kOyBpICs9IHNldHRpbmdzLnN0ZXAqNjApIHtcblx0XHRcdHZhciB0aW1lSW50ID0gaTtcblxuXHRcdFx0dmFyIHJvdyA9ICQoJzxsaSAvPicpO1xuXHRcdFx0cm93LmRhdGEoJ3RpbWUnLCAodGltZUludCA8PSA4NjQwMCA/IHRpbWVJbnQgOiB0aW1lSW50ICUgODY0MDApKTtcblx0XHRcdHJvdy50ZXh0KF9pbnQydGltZSh0aW1lSW50LCBzZXR0aW5ncy50aW1lRm9ybWF0KSk7XG5cblx0XHRcdGlmICgoc2V0dGluZ3MubWluVGltZSAhPT0gbnVsbCB8fCBzZXR0aW5ncy5kdXJhdGlvblRpbWUgIT09IG51bGwpICYmIHNldHRpbmdzLnNob3dEdXJhdGlvbikge1xuXHRcdFx0XHR2YXIgZHVyYXRpb24gPSAkKCc8c3BhbiAvPicpO1xuXHRcdFx0XHRkdXJhdGlvbi5hZGRDbGFzcygndWktdGltZXBpY2tlci1kdXJhdGlvbicpO1xuXHRcdFx0XHRkdXJhdGlvbi50ZXh0KCcgKCcrX2ludDJkdXJhdGlvbihpIC0gZHVyU3RhcnQpKycpJyk7XG5cdFx0XHRcdHJvdy5hcHBlbmQoZHVyYXRpb24pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZHJDdXIgPCBkckxlbikge1xuXHRcdFx0XHRpZiAodGltZUludCA+PSBkcltkckN1cl1bMV0pIHtcblx0XHRcdFx0XHRkckN1ciArPSAxO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGRyW2RyQ3VyXSAmJiB0aW1lSW50ID49IGRyW2RyQ3VyXVswXSAmJiB0aW1lSW50IDwgZHJbZHJDdXJdWzFdKSB7XG5cdFx0XHRcdFx0cm93LmFkZENsYXNzKCd1aS10aW1lcGlja2VyLWRpc2FibGVkJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0bGlzdC5hcHBlbmQocm93KTtcblx0XHR9XG5cblx0XHR3cmFwcGVkX2xpc3QuZGF0YSgndGltZXBpY2tlci1pbnB1dCcsIHNlbGYpO1xuXHRcdHNlbGYuZGF0YSgndGltZXBpY2tlci1saXN0Jywgd3JhcHBlZF9saXN0KTtcblxuXHRcdHZhciBhcHBlbmRUbyA9IHNldHRpbmdzLmFwcGVuZFRvO1xuXHRcdGlmICh0eXBlb2YgYXBwZW5kVG8gPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRhcHBlbmRUbyA9ICQoYXBwZW5kVG8pO1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIGFwcGVuZFRvID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRhcHBlbmRUbyA9IGFwcGVuZFRvKHNlbGYpO1xuXHRcdH1cblx0XHRhcHBlbmRUby5hcHBlbmQod3JhcHBlZF9saXN0KTtcblx0XHRfc2V0U2VsZWN0ZWQoc2VsZiwgbGlzdCk7XG5cblx0XHRsaXN0Lm9uKCdjbGljaycsICdsaScsIGZ1bmN0aW9uKGUpIHtcblxuXHRcdFx0Ly8gaGFjazogdGVtcG9yYXJpbHkgZGlzYWJsZSB0aGUgZm9jdXMgaGFuZGxlclxuXHRcdFx0Ly8gdG8gZGVhbCB3aXRoIHRoZSBmYWN0IHRoYXQgSUUgZmlyZXMgJ2ZvY3VzJ1xuXHRcdFx0Ly8gZXZlbnRzIGFzeW5jaHJvbm91c2x5XG5cdFx0XHRzZWxmLm9mZignZm9jdXMudGltZXBpY2tlcicpO1xuXHRcdFx0c2VsZi5vbignZm9jdXMudGltZXBpY2tlci1pZS1oYWNrJywgZnVuY3Rpb24oKXtcblx0XHRcdFx0c2VsZi5vZmYoJ2ZvY3VzLnRpbWVwaWNrZXItaWUtaGFjaycpO1xuXHRcdFx0XHRzZWxmLm9uKCdmb2N1cy50aW1lcGlja2VyJywgbWV0aG9kcy5zaG93KTtcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAoIV9oaWRlS2V5Ym9hcmQoc2VsZikpIHtcblx0XHRcdFx0c2VsZlswXS5mb2N1cygpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBtYWtlIHN1cmUgb25seSB0aGUgY2xpY2tlZCByb3cgaXMgc2VsZWN0ZWRcblx0XHRcdGxpc3QuZmluZCgnbGknKS5yZW1vdmVDbGFzcygndWktdGltZXBpY2tlci1zZWxlY3RlZCcpO1xuXHRcdFx0JCh0aGlzKS5hZGRDbGFzcygndWktdGltZXBpY2tlci1zZWxlY3RlZCcpO1xuXG5cdFx0XHRpZiAoX3NlbGVjdFZhbHVlKHNlbGYpKSB7XG5cdFx0XHRcdHNlbGYudHJpZ2dlcignaGlkZVRpbWVwaWNrZXInKTtcblx0XHRcdFx0d3JhcHBlZF9saXN0LmhpZGUoKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIF9nZW5lcmF0ZUJhc2VEYXRlKClcblx0e1xuXHRcdHJldHVybiBuZXcgRGF0ZSgxOTcwLCAxLCAxLCAwLCAwLCAwKTtcblx0fVxuXG5cdC8vIGV2ZW50IGhhbmRsZXIgdG8gZGVjaWRlIHdoZXRoZXIgdG8gY2xvc2UgdGltZXBpY2tlclxuXHRmdW5jdGlvbiBfY2xvc2VIYW5kbGVyKGUpXG5cdHtcblx0XHR2YXIgdGFyZ2V0ID0gJChlLnRhcmdldCk7XG5cdFx0dmFyIGlucHV0ID0gdGFyZ2V0LmNsb3Nlc3QoJy51aS10aW1lcGlja2VyLWlucHV0Jyk7XG5cdFx0aWYgKGlucHV0Lmxlbmd0aCA9PT0gMCAmJiB0YXJnZXQuY2xvc2VzdCgnLnVpLXRpbWVwaWNrZXItd3JhcHBlcicpLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0bWV0aG9kcy5oaWRlKCk7XG5cdFx0XHQkKCdib2R5JykudW5iaW5kKCcudWktdGltZXBpY2tlcicpO1xuXHRcdFx0JCh3aW5kb3cpLnVuYmluZCgnLnVpLXRpbWVwaWNrZXInKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBfaGlkZUtleWJvYXJkKHNlbGYpXG5cdHtcblx0XHR2YXIgc2V0dGluZ3MgPSBzZWxmLmRhdGEoJ3RpbWVwaWNrZXItc2V0dGluZ3MnKTtcblx0XHRyZXR1cm4gKCh3aW5kb3cubmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMgfHwgJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQpICYmIHNldHRpbmdzLmRpc2FibGVUb3VjaEtleWJvYXJkKTtcblx0fVxuXG5cdGZ1bmN0aW9uIF9maW5kUm93KHNlbGYsIGxpc3QsIHZhbHVlKVxuXHR7XG5cdFx0aWYgKCF2YWx1ZSAmJiB2YWx1ZSAhPT0gMCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHZhciBzZXR0aW5ncyA9IHNlbGYuZGF0YSgndGltZXBpY2tlci1zZXR0aW5ncycpO1xuXHRcdHZhciBvdXQgPSBmYWxzZTtcblx0XHR2YXIgaGFsZlN0ZXAgPSBzZXR0aW5ncy5zdGVwKjMwO1xuXG5cdFx0Ly8gbG9vcCB0aHJvdWdoIHRoZSBtZW51IGl0ZW1zXG5cdFx0bGlzdC5maW5kKCdsaScpLmVhY2goZnVuY3Rpb24oaSwgb2JqKSB7XG5cdFx0XHR2YXIgak9iaiA9ICQob2JqKTtcblxuXHRcdFx0dmFyIG9mZnNldCA9IGpPYmouZGF0YSgndGltZScpIC0gdmFsdWU7XG5cblx0XHRcdC8vIGNoZWNrIGlmIHRoZSB2YWx1ZSBpcyBsZXNzIHRoYW4gaGFsZiBhIHN0ZXAgZnJvbSBlYWNoIHJvd1xuXHRcdFx0aWYgKE1hdGguYWJzKG9mZnNldCkgPCBoYWxmU3RlcCB8fCBvZmZzZXQgPT0gaGFsZlN0ZXApIHtcblx0XHRcdFx0b3V0ID0gak9iajtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIG91dDtcblx0fVxuXG5cdGZ1bmN0aW9uIF9zZXRTZWxlY3RlZChzZWxmLCBsaXN0KVxuXHR7XG5cdFx0bGlzdC5maW5kKCdsaScpLnJlbW92ZUNsYXNzKCd1aS10aW1lcGlja2VyLXNlbGVjdGVkJyk7XG5cblx0XHR2YXIgdGltZVZhbHVlID0gX3RpbWUyaW50KF9nZXRUaW1lVmFsdWUoc2VsZikpO1xuXHRcdGlmICh0aW1lVmFsdWUgPT09IG51bGwpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgc2VsZWN0ZWQgPSBfZmluZFJvdyhzZWxmLCBsaXN0LCB0aW1lVmFsdWUpO1xuXHRcdGlmIChzZWxlY3RlZCkge1xuXG5cdFx0XHR2YXIgdG9wRGVsdGEgPSBzZWxlY3RlZC5vZmZzZXQoKS50b3AgLSBsaXN0Lm9mZnNldCgpLnRvcDtcblxuXHRcdFx0aWYgKHRvcERlbHRhICsgc2VsZWN0ZWQub3V0ZXJIZWlnaHQoKSA+IGxpc3Qub3V0ZXJIZWlnaHQoKSB8fCB0b3BEZWx0YSA8IDApIHtcblx0XHRcdFx0bGlzdC5zY3JvbGxUb3AobGlzdC5zY3JvbGxUb3AoKSArIHNlbGVjdGVkLnBvc2l0aW9uKCkudG9wIC0gc2VsZWN0ZWQub3V0ZXJIZWlnaHQoKSk7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGVjdGVkLmFkZENsYXNzKCd1aS10aW1lcGlja2VyLXNlbGVjdGVkJyk7XG5cdFx0fVxuXHR9XG5cblxuXHRmdW5jdGlvbiBfZm9ybWF0VmFsdWUoKVxuXHR7XG5cdFx0aWYgKHRoaXMudmFsdWUgPT09ICcnKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHNlbGYgPSAkKHRoaXMpO1xuXHRcdHZhciBsaXN0ID0gc2VsZi5kYXRhKCd0aW1lcGlja2VyLWxpc3QnKTtcblxuXHRcdGlmIChsaXN0ICYmIGxpc3QuaXMoJzp2aXNpYmxlJykpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgc2Vjb25kcyA9IF90aW1lMmludCh0aGlzLnZhbHVlKTtcblxuXHRcdGlmIChzZWNvbmRzID09PSBudWxsKSB7XG5cdFx0XHRzZWxmLnRyaWdnZXIoJ3RpbWVGb3JtYXRFcnJvcicpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBzZXR0aW5ncyA9IHNlbGYuZGF0YSgndGltZXBpY2tlci1zZXR0aW5ncycpO1xuXHRcdHZhciByYW5nZUVycm9yID0gZmFsc2U7XG5cdFx0Ly8gY2hlY2sgdGhhdCB0aGUgdGltZSBpbiB3aXRoaW4gYm91bmRzXG5cdFx0aWYgKHNldHRpbmdzLm1pblRpbWUgIT09IG51bGwgJiYgc2Vjb25kcyA8IHNldHRpbmdzLm1pblRpbWUpIHtcblx0XHRcdHJhbmdlRXJyb3IgPSB0cnVlO1xuXHRcdH0gZWxzZSBpZiAoc2V0dGluZ3MubWF4VGltZSAhPT0gbnVsbCAmJiBzZWNvbmRzID4gc2V0dGluZ3MubWF4VGltZSkge1xuXHRcdFx0cmFuZ2VFcnJvciA9IHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gY2hlY2sgdGhhdCB0aW1lIGlzbid0IHdpdGhpbiBkaXNhYmxlZCB0aW1lIHJhbmdlc1xuXHRcdCQuZWFjaChzZXR0aW5ncy5kaXNhYmxlVGltZVJhbmdlcywgZnVuY3Rpb24oKXtcblx0XHRcdGlmIChzZWNvbmRzID49IHRoaXNbMF0gJiYgc2Vjb25kcyA8IHRoaXNbMV0pIHtcblx0XHRcdFx0cmFuZ2VFcnJvciA9IHRydWU7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGlmIChzZXR0aW5ncy5mb3JjZVJvdW5kVGltZSkge1xuXHRcdFx0dmFyIG9mZnNldCA9IHNlY29uZHMgJSAoc2V0dGluZ3Muc3RlcCo2MCk7IC8vIHN0ZXAgaXMgaW4gbWludXRlc1xuXG5cdFx0XHRpZiAob2Zmc2V0ID49IHNldHRpbmdzLnN0ZXAqMzApIHtcblx0XHRcdFx0Ly8gaWYgb2Zmc2V0IGlzIGxhcmdlciB0aGFuIGEgaGFsZiBzdGVwLCByb3VuZCB1cFxuXHRcdFx0XHRzZWNvbmRzICs9IChzZXR0aW5ncy5zdGVwKjYwKSAtIG9mZnNldDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHJvdW5kIGRvd25cblx0XHRcdFx0c2Vjb25kcyAtPSBvZmZzZXQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIHByZXR0eVRpbWUgPSBfaW50MnRpbWUoc2Vjb25kcywgc2V0dGluZ3MudGltZUZvcm1hdCk7XG5cblx0XHRpZiAocmFuZ2VFcnJvcikge1xuXHRcdFx0aWYgKF9zZXRUaW1lVmFsdWUoc2VsZiwgcHJldHR5VGltZSwgJ2Vycm9yJykpIHtcblx0XHRcdFx0c2VsZi50cmlnZ2VyKCd0aW1lUmFuZ2VFcnJvcicpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRfc2V0VGltZVZhbHVlKHNlbGYsIHByZXR0eVRpbWUpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIF9nZXRUaW1lVmFsdWUoc2VsZilcblx0e1xuXHRcdGlmIChzZWxmLmlzKCdpbnB1dCcpKSB7XG5cdFx0XHRyZXR1cm4gc2VsZi52YWwoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gdXNlIHRoZSBlbGVtZW50J3MgZGF0YSBhdHRyaWJ1dGVzIHRvIHN0b3JlIHZhbHVlc1xuXHRcdFx0cmV0dXJuIHNlbGYuZGF0YSgndWktdGltZXBpY2tlci12YWx1ZScpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIF9zZXRUaW1lVmFsdWUoc2VsZiwgdmFsdWUsIHNvdXJjZSlcblx0e1xuXHRcdGlmIChzZWxmLmlzKCdpbnB1dCcpKSB7XG5cdFx0XHRzZWxmLnZhbCh2YWx1ZSk7XG5cdFx0fVxuXG5cdFx0aWYgKHNlbGYuZGF0YSgndWktdGltZXBpY2tlci12YWx1ZScpICE9IHZhbHVlKSB7XG5cdFx0XHRzZWxmLmRhdGEoJ3VpLXRpbWVwaWNrZXItdmFsdWUnLCB2YWx1ZSk7XG5cdFx0XHRpZiAoc291cmNlID09ICdzZWxlY3QnKSB7XG5cdFx0XHRcdHNlbGYudHJpZ2dlcignc2VsZWN0VGltZScpLnRyaWdnZXIoJ2NoYW5nZVRpbWUnKS50cmlnZ2VyKCdjaGFuZ2UnKTtcblx0XHRcdH0gZWxzZSBpZiAoc291cmNlICE9ICdlcnJvcicpIHtcblx0XHRcdFx0c2VsZi50cmlnZ2VyKCdjaGFuZ2VUaW1lJyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzZWxmLnRyaWdnZXIoJ3NlbGVjdFRpbWUnKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHQvKlxuXHQqICBLZXlib2FyZCBuYXZpZ2F0aW9uIHZpYSBhcnJvdyBrZXlzXG5cdCovXG5cdGZ1bmN0aW9uIF9rZXlkb3duaGFuZGxlcihlKVxuXHR7XG5cdFx0dmFyIHNlbGYgPSAkKHRoaXMpO1xuXHRcdHZhciBsaXN0ID0gc2VsZi5kYXRhKCd0aW1lcGlja2VyLWxpc3QnKTtcblxuXHRcdGlmICghbGlzdCB8fCAhbGlzdC5pcygnOnZpc2libGUnKSkge1xuXHRcdFx0aWYgKGUua2V5Q29kZSA9PSA0MCkge1xuXHRcdFx0XHRpZiAoIV9oaWRlS2V5Ym9hcmQoc2VsZikpIHtcblx0XHRcdFx0XHRzZWxmLmZvY3VzKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBfc2NyZWVuSW5wdXQoZSwgc2VsZik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c3dpdGNoIChlLmtleUNvZGUpIHtcblxuXHRcdFx0Y2FzZSAxMzogLy8gcmV0dXJuXG5cdFx0XHRcdGlmIChfc2VsZWN0VmFsdWUoc2VsZikpIHtcblx0XHRcdFx0XHRtZXRob2RzLmhpZGUuYXBwbHkodGhpcyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0Y2FzZSAzODogLy8gdXBcblx0XHRcdFx0dmFyIHNlbGVjdGVkID0gbGlzdC5maW5kKCcudWktdGltZXBpY2tlci1zZWxlY3RlZCcpO1xuXG5cdFx0XHRcdGlmICghc2VsZWN0ZWQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0bGlzdC5maW5kKCdsaScpLmVhY2goZnVuY3Rpb24oaSwgb2JqKSB7XG5cdFx0XHRcdFx0XHRpZiAoJChvYmopLnBvc2l0aW9uKCkudG9wID4gMCkge1xuXHRcdFx0XHRcdFx0XHRzZWxlY3RlZCA9ICQob2JqKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHNlbGVjdGVkLmFkZENsYXNzKCd1aS10aW1lcGlja2VyLXNlbGVjdGVkJyk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICghc2VsZWN0ZWQuaXMoJzpmaXJzdC1jaGlsZCcpKSB7XG5cdFx0XHRcdFx0c2VsZWN0ZWQucmVtb3ZlQ2xhc3MoJ3VpLXRpbWVwaWNrZXItc2VsZWN0ZWQnKTtcblx0XHRcdFx0XHRzZWxlY3RlZC5wcmV2KCkuYWRkQ2xhc3MoJ3VpLXRpbWVwaWNrZXItc2VsZWN0ZWQnKTtcblxuXHRcdFx0XHRcdGlmIChzZWxlY3RlZC5wcmV2KCkucG9zaXRpb24oKS50b3AgPCBzZWxlY3RlZC5vdXRlckhlaWdodCgpKSB7XG5cdFx0XHRcdFx0XHRsaXN0LnNjcm9sbFRvcChsaXN0LnNjcm9sbFRvcCgpIC0gc2VsZWN0ZWQub3V0ZXJIZWlnaHQoKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRjYXNlIDQwOiAvLyBkb3duXG5cdFx0XHRcdHNlbGVjdGVkID0gbGlzdC5maW5kKCcudWktdGltZXBpY2tlci1zZWxlY3RlZCcpO1xuXG5cdFx0XHRcdGlmIChzZWxlY3RlZC5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRsaXN0LmZpbmQoJ2xpJykuZWFjaChmdW5jdGlvbihpLCBvYmopIHtcblx0XHRcdFx0XHRcdGlmICgkKG9iaikucG9zaXRpb24oKS50b3AgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdHNlbGVjdGVkID0gJChvYmopO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRzZWxlY3RlZC5hZGRDbGFzcygndWktdGltZXBpY2tlci1zZWxlY3RlZCcpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCFzZWxlY3RlZC5pcygnOmxhc3QtY2hpbGQnKSkge1xuXHRcdFx0XHRcdHNlbGVjdGVkLnJlbW92ZUNsYXNzKCd1aS10aW1lcGlja2VyLXNlbGVjdGVkJyk7XG5cdFx0XHRcdFx0c2VsZWN0ZWQubmV4dCgpLmFkZENsYXNzKCd1aS10aW1lcGlja2VyLXNlbGVjdGVkJyk7XG5cblx0XHRcdFx0XHRpZiAoc2VsZWN0ZWQubmV4dCgpLnBvc2l0aW9uKCkudG9wICsgMipzZWxlY3RlZC5vdXRlckhlaWdodCgpID4gbGlzdC5vdXRlckhlaWdodCgpKSB7XG5cdFx0XHRcdFx0XHRsaXN0LnNjcm9sbFRvcChsaXN0LnNjcm9sbFRvcCgpICsgc2VsZWN0ZWQub3V0ZXJIZWlnaHQoKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRjYXNlIDI3OiAvLyBlc2NhcGVcblx0XHRcdFx0bGlzdC5maW5kKCdsaScpLnJlbW92ZUNsYXNzKCd1aS10aW1lcGlja2VyLXNlbGVjdGVkJyk7XG5cdFx0XHRcdG1ldGhvZHMuaGlkZSgpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSA5OiAvL3RhYlxuXHRcdFx0XHRtZXRob2RzLmhpZGUoKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBfc2NyZWVuSW5wdXQoZSwgc2VsZik7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gX3NjcmVlbklucHV0KGUsIHNlbGYpXG5cdHtcblx0XHRyZXR1cm4gIXNlbGYuZGF0YSgndGltZXBpY2tlci1zZXR0aW5ncycpLmRpc2FibGVUZXh0SW5wdXQgfHwgZS5jdHJsS2V5IHx8IGUuYWx0S2V5IHx8IGUubWV0YUtleSB8fCAoZS5rZXlDb2RlICE9IDIgJiYgZS5rZXlDb2RlICE9IDggJiYgZS5rZXlDb2RlIDwgNDYpO1xuXHR9XG5cblx0Lypcblx0Klx0VGltZSB0eXBlYWhlYWRcblx0Ki9cblx0ZnVuY3Rpb24gX2tleXVwaGFuZGxlcihlKVxuXHR7XG5cdFx0dmFyIHNlbGYgPSAkKHRoaXMpO1xuXHRcdHZhciBsaXN0ID0gc2VsZi5kYXRhKCd0aW1lcGlja2VyLWxpc3QnKTtcblxuXHRcdGlmICghbGlzdCB8fCAhbGlzdC5pcygnOnZpc2libGUnKSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCFzZWxmLmRhdGEoJ3RpbWVwaWNrZXItc2V0dGluZ3MnKS50eXBlYWhlYWRIaWdobGlnaHQpIHtcblx0XHRcdGxpc3QuZmluZCgnbGknKS5yZW1vdmVDbGFzcygndWktdGltZXBpY2tlci1zZWxlY3RlZCcpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0c3dpdGNoIChlLmtleUNvZGUpIHtcblxuXHRcdFx0Y2FzZSA5NjogLy8gbnVtcGFkIG51bWVyYWxzXG5cdFx0XHRjYXNlIDk3OlxuXHRcdFx0Y2FzZSA5ODpcblx0XHRcdGNhc2UgOTk6XG5cdFx0XHRjYXNlIDEwMDpcblx0XHRcdGNhc2UgMTAxOlxuXHRcdFx0Y2FzZSAxMDI6XG5cdFx0XHRjYXNlIDEwMzpcblx0XHRcdGNhc2UgMTA0OlxuXHRcdFx0Y2FzZSAxMDU6XG5cdFx0XHRjYXNlIDQ4OiAvLyBudW1lcmFsc1xuXHRcdFx0Y2FzZSA0OTpcblx0XHRcdGNhc2UgNTA6XG5cdFx0XHRjYXNlIDUxOlxuXHRcdFx0Y2FzZSA1Mjpcblx0XHRcdGNhc2UgNTM6XG5cdFx0XHRjYXNlIDU0OlxuXHRcdFx0Y2FzZSA1NTpcblx0XHRcdGNhc2UgNTY6XG5cdFx0XHRjYXNlIDU3OlxuXHRcdFx0Y2FzZSA2NTogLy8gYVxuXHRcdFx0Y2FzZSA3NzogLy8gbVxuXHRcdFx0Y2FzZSA4MDogLy8gcFxuXHRcdFx0Y2FzZSAxODY6IC8vIGNvbG9uXG5cdFx0XHRjYXNlIDg6IC8vIGJhY2tzcGFjZVxuXHRcdFx0Y2FzZSA0NjogLy8gZGVsZXRlXG5cdFx0XHRcdF9zZXRTZWxlY3RlZChzZWxmLCBsaXN0KTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdC8vIGxpc3QuZmluZCgnbGknKS5yZW1vdmVDbGFzcygndWktdGltZXBpY2tlci1zZWxlY3RlZCcpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gX3NlbGVjdFZhbHVlKHNlbGYpXG5cdHtcblx0XHR2YXIgc2V0dGluZ3MgPSBzZWxmLmRhdGEoJ3RpbWVwaWNrZXItc2V0dGluZ3MnKTtcblx0XHR2YXIgbGlzdCA9IHNlbGYuZGF0YSgndGltZXBpY2tlci1saXN0Jyk7XG5cdFx0dmFyIHRpbWVWYWx1ZSA9IG51bGw7XG5cblx0XHR2YXIgY3Vyc29yID0gbGlzdC5maW5kKCcudWktdGltZXBpY2tlci1zZWxlY3RlZCcpO1xuXG5cdFx0aWYgKGN1cnNvci5oYXNDbGFzcygndWktdGltZXBpY2tlci1kaXNhYmxlZCcpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKGN1cnNvci5sZW5ndGgpIHtcblx0XHRcdC8vIHNlbGVjdGVkIHZhbHVlIGZvdW5kXG5cdFx0XHR0aW1lVmFsdWUgPSBjdXJzb3IuZGF0YSgndGltZScpO1xuXG5cdFx0fSBlbHNlIGlmIChfZ2V0VGltZVZhbHVlKHNlbGYpKSB7XG5cblx0XHRcdC8vIG5vIHNlbGVjdGVkIHZhbHVlOyBmYWxsIGJhY2sgb24gaW5wdXQgdmFsdWVcblx0XHRcdHRpbWVWYWx1ZSA9IF90aW1lMmludChfZ2V0VGltZVZhbHVlKHNlbGYpKTtcblxuXHRcdFx0X3NldFNlbGVjdGVkKHNlbGYsIGxpc3QpO1xuXHRcdH1cblxuXHRcdGlmICh0aW1lVmFsdWUgIT09IG51bGwpIHtcblx0XHRcdHZhciB0aW1lU3RyaW5nID0gX2ludDJ0aW1lKHRpbWVWYWx1ZSwgc2V0dGluZ3MudGltZUZvcm1hdCk7XG5cdFx0XHRfc2V0VGltZVZhbHVlKHNlbGYsIHRpbWVTdHJpbmcsICdzZWxlY3QnKTtcblx0XHR9XG5cblx0XHQvL3NlbGYudHJpZ2dlcignY2hhbmdlJykudHJpZ2dlcignc2VsZWN0VGltZScpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gX2ludDJkdXJhdGlvbihzZWNvbmRzKVxuXHR7XG5cdFx0dmFyIG1pbnV0ZXMgPSBNYXRoLnJvdW5kKHNlY29uZHMvNjApO1xuXHRcdHZhciBkdXJhdGlvbjtcblxuXHRcdGlmIChNYXRoLmFicyhtaW51dGVzKSA8IDYwKSB7XG5cdFx0XHRkdXJhdGlvbiA9IFttaW51dGVzLCBfbGFuZy5taW5zXTtcblx0XHR9IGVsc2UgaWYgKG1pbnV0ZXMgPT0gNjApIHtcblx0XHRcdGR1cmF0aW9uID0gWycxJywgX2xhbmcuaHJdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgaG91cnMgPSAobWludXRlcy82MCkudG9GaXhlZCgxKTtcblx0XHRcdGlmIChfbGFuZy5kZWNpbWFsICE9ICcuJykgaG91cnMgPSBob3Vycy5yZXBsYWNlKCcuJywgX2xhbmcuZGVjaW1hbCk7XG5cdFx0XHRkdXJhdGlvbiA9IFtob3VycywgX2xhbmcuaHJzXTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZHVyYXRpb24uam9pbignICcpO1xuXHR9XG5cblx0ZnVuY3Rpb24gX2ludDJ0aW1lKHNlY29uZHMsIGZvcm1hdClcblx0e1xuXHRcdGlmIChzZWNvbmRzID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHRpbWUgPSBuZXcgRGF0ZShfYmFzZURhdGUudmFsdWVPZigpICsgKHNlY29uZHMqMTAwMCkpO1xuXHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHR2YXIgaG91ciwgY29kZTtcblxuXHRcdGZvciAodmFyIGk9MDsgaTxmb3JtYXQubGVuZ3RoOyBpKyspIHtcblxuXHRcdFx0Y29kZSA9IGZvcm1hdC5jaGFyQXQoaSk7XG5cdFx0XHRzd2l0Y2ggKGNvZGUpIHtcblxuXHRcdFx0XHRjYXNlICdhJzpcblx0XHRcdFx0XHRvdXRwdXQgKz0gKHRpbWUuZ2V0SG91cnMoKSA+IDExKSA/ICdwbScgOiAnYW0nO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0EnOlxuXHRcdFx0XHRcdG91dHB1dCArPSAodGltZS5nZXRIb3VycygpID4gMTEpID8gJ1BNJyA6ICdBTSc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnZyc6XG5cdFx0XHRcdFx0aG91ciA9IHRpbWUuZ2V0SG91cnMoKSAlIDEyO1xuXHRcdFx0XHRcdG91dHB1dCArPSAoaG91ciA9PT0gMCkgPyAnMTInIDogaG91cjtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdHJzpcblx0XHRcdFx0XHRvdXRwdXQgKz0gdGltZS5nZXRIb3VycygpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2gnOlxuXHRcdFx0XHRcdGhvdXIgPSB0aW1lLmdldEhvdXJzKCkgJSAxMjtcblxuXHRcdFx0XHRcdGlmIChob3VyICE9PSAwICYmIGhvdXIgPCAxMCkge1xuXHRcdFx0XHRcdFx0aG91ciA9ICcwJytob3VyO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dCArPSAoaG91ciA9PT0gMCkgPyAnMTInIDogaG91cjtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdIJzpcblx0XHRcdFx0XHRob3VyID0gdGltZS5nZXRIb3VycygpO1xuXHRcdFx0XHRcdGlmIChzZWNvbmRzID09PSBfT05FX0RBWSkgaG91ciA9IDI0O1xuXHRcdFx0XHRcdG91dHB1dCArPSAoaG91ciA+IDkpID8gaG91ciA6ICcwJytob3VyO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2knOlxuXHRcdFx0XHRcdHZhciBtaW51dGVzID0gdGltZS5nZXRNaW51dGVzKCk7XG5cdFx0XHRcdFx0b3V0cHV0ICs9IChtaW51dGVzID4gOSkgPyBtaW51dGVzIDogJzAnK21pbnV0ZXM7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAncyc6XG5cdFx0XHRcdFx0c2Vjb25kcyA9IHRpbWUuZ2V0U2Vjb25kcygpO1xuXHRcdFx0XHRcdG91dHB1dCArPSAoc2Vjb25kcyA+IDkpID8gc2Vjb25kcyA6ICcwJytzZWNvbmRzO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0b3V0cHV0ICs9IGNvZGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdGZ1bmN0aW9uIF90aW1lMmludCh0aW1lU3RyaW5nKVxuXHR7XG5cdFx0aWYgKHRpbWVTdHJpbmcgPT09ICcnKSByZXR1cm4gbnVsbDtcblx0XHRpZiAoIXRpbWVTdHJpbmcgfHwgdGltZVN0cmluZyswID09IHRpbWVTdHJpbmcpIHJldHVybiB0aW1lU3RyaW5nO1xuXG5cdFx0aWYgKHR5cGVvZih0aW1lU3RyaW5nKSA9PSAnb2JqZWN0Jykge1xuXHRcdFx0dGltZVN0cmluZyA9IHRpbWVTdHJpbmcuZ2V0SG91cnMoKSsnOicrX3BhZDIodGltZVN0cmluZy5nZXRNaW51dGVzKCkpKyc6JytfcGFkMih0aW1lU3RyaW5nLmdldFNlY29uZHMoKSk7XG5cdFx0fVxuXG5cdFx0dGltZVN0cmluZyA9IHRpbWVTdHJpbmcudG9Mb3dlckNhc2UoKTtcblxuXHRcdHZhciBkID0gbmV3IERhdGUoMCk7XG5cdFx0dmFyIHRpbWU7XG5cblx0XHQvLyB0cnkgdG8gcGFyc2UgdGltZSBpbnB1dFxuXHRcdGlmICh0aW1lU3RyaW5nLmluZGV4T2YoXCI6XCIpID09PSAtMSkge1xuXHRcdFx0Ly8gbm8gY29sb24gcHJlc2VudFxuXHRcdFx0dGltZSA9IHRpbWVTdHJpbmcubWF0Y2goL14oWzAtOV0pOj8oWzAtNV1bMC05XSk/Oj8oWzAtNV1bMC05XSk/XFxzKihbcGFdPyltPyQvKTtcblxuXHRcdFx0aWYgKCF0aW1lKSB7XG5cdFx0XHRcdHRpbWUgPSB0aW1lU3RyaW5nLm1hdGNoKC9eKFswLTJdWzAtOV0pOj8oWzAtNV1bMC05XSk/Oj8oWzAtNV1bMC05XSk/XFxzKihbcGFdPyltPyQvKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGltZSA9IHRpbWVTdHJpbmcubWF0Y2goL14oXFxkezEsMn0pKD86OihbMC01XVswLTldKSk/KD86OihbMC01XVswLTldKSk/XFxzKihbcGFdPyltPyQvKTtcblx0XHR9XG5cblx0XHRpZiAoIXRpbWUpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHZhciBob3VyID0gcGFyc2VJbnQodGltZVsxXSoxLCAxMCk7XG5cdFx0dmFyIGhvdXJzO1xuXG5cdFx0aWYgKHRpbWVbNF0pIHtcblx0XHRcdGlmIChob3VyID09IDEyKSB7XG5cdFx0XHRcdGhvdXJzID0gKHRpbWVbNF0gPT0gJ3AnKSA/IDEyIDogMDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhvdXJzID0gKGhvdXIgKyAodGltZVs0XSA9PSAncCcgPyAxMiA6IDApKTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRob3VycyA9IGhvdXI7XG5cdFx0fVxuXG5cdFx0dmFyIG1pbnV0ZXMgPSAoIHRpbWVbMl0qMSB8fCAwICk7XG5cdFx0dmFyIHNlY29uZHMgPSAoIHRpbWVbM10qMSB8fCAwICk7XG5cdFx0cmV0dXJuIGhvdXJzKjM2MDAgKyBtaW51dGVzKjYwICsgc2Vjb25kcztcblx0fVxuXG5cdGZ1bmN0aW9uIF9wYWQyKG4pIHtcblx0XHRyZXR1cm4gKFwiMFwiICsgbikuc2xpY2UoLTIpO1xuXHR9XG5cblx0Ly8gUGx1Z2luIGVudHJ5XG5cdCQuZm4udGltZXBpY2tlciA9IGZ1bmN0aW9uKG1ldGhvZClcblx0e1xuXHRcdGlmKG1ldGhvZHNbbWV0aG9kXSkgeyByZXR1cm4gbWV0aG9kc1ttZXRob2RdLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpOyB9XG5cdFx0ZWxzZSBpZih0eXBlb2YgbWV0aG9kID09PSBcIm9iamVjdFwiIHx8ICFtZXRob2QpIHsgcmV0dXJuIG1ldGhvZHMuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cdFx0ZWxzZSB7ICQuZXJyb3IoXCJNZXRob2QgXCIrIG1ldGhvZCArIFwiIGRvZXMgbm90IGV4aXN0IG9uIGpRdWVyeS50aW1lcGlja2VyXCIpOyB9XG5cdH07XG59KSk7XG4iLCIvLyAgICAgVW5kZXJzY29yZS5qcyAxLjguMlxuLy8gICAgIGh0dHA6Ly91bmRlcnNjb3JlanMub3JnXG4vLyAgICAgKGMpIDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuLy8gICAgIFVuZGVyc2NvcmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbihmdW5jdGlvbigpIHtcblxuICAvLyBCYXNlbGluZSBzZXR1cFxuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEVzdGFibGlzaCB0aGUgcm9vdCBvYmplY3QsIGB3aW5kb3dgIGluIHRoZSBicm93c2VyLCBvciBgZXhwb3J0c2Agb24gdGhlIHNlcnZlci5cbiAgdmFyIHJvb3QgPSB0aGlzO1xuXG4gIC8vIFNhdmUgdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBgX2AgdmFyaWFibGUuXG4gIHZhciBwcmV2aW91c1VuZGVyc2NvcmUgPSByb290Ll87XG5cbiAgLy8gU2F2ZSBieXRlcyBpbiB0aGUgbWluaWZpZWQgKGJ1dCBub3QgZ3ppcHBlZCkgdmVyc2lvbjpcbiAgdmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsIE9ialByb3RvID0gT2JqZWN0LnByb3RvdHlwZSwgRnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4gIC8vIENyZWF0ZSBxdWljayByZWZlcmVuY2UgdmFyaWFibGVzIGZvciBzcGVlZCBhY2Nlc3MgdG8gY29yZSBwcm90b3R5cGVzLlxuICB2YXJcbiAgICBwdXNoICAgICAgICAgICAgID0gQXJyYXlQcm90by5wdXNoLFxuICAgIHNsaWNlICAgICAgICAgICAgPSBBcnJheVByb3RvLnNsaWNlLFxuICAgIHRvU3RyaW5nICAgICAgICAgPSBPYmpQcm90by50b1N0cmluZyxcbiAgICBoYXNPd25Qcm9wZXJ0eSAgID0gT2JqUHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgLy8gQWxsICoqRUNNQVNjcmlwdCA1KiogbmF0aXZlIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9ucyB0aGF0IHdlIGhvcGUgdG8gdXNlXG4gIC8vIGFyZSBkZWNsYXJlZCBoZXJlLlxuICB2YXJcbiAgICBuYXRpdmVJc0FycmF5ICAgICAgPSBBcnJheS5pc0FycmF5LFxuICAgIG5hdGl2ZUtleXMgICAgICAgICA9IE9iamVjdC5rZXlzLFxuICAgIG5hdGl2ZUJpbmQgICAgICAgICA9IEZ1bmNQcm90by5iaW5kLFxuICAgIG5hdGl2ZUNyZWF0ZSAgICAgICA9IE9iamVjdC5jcmVhdGU7XG5cbiAgLy8gTmFrZWQgZnVuY3Rpb24gcmVmZXJlbmNlIGZvciBzdXJyb2dhdGUtcHJvdG90eXBlLXN3YXBwaW5nLlxuICB2YXIgQ3RvciA9IGZ1bmN0aW9uKCl7fTtcblxuICAvLyBDcmVhdGUgYSBzYWZlIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yIHVzZSBiZWxvdy5cbiAgdmFyIF8gPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgXykgcmV0dXJuIG9iajtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgXykpIHJldHVybiBuZXcgXyhvYmopO1xuICAgIHRoaXMuX3dyYXBwZWQgPSBvYmo7XG4gIH07XG5cbiAgLy8gRXhwb3J0IHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgKipOb2RlLmpzKiosIHdpdGhcbiAgLy8gYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgZm9yIHRoZSBvbGQgYHJlcXVpcmUoKWAgQVBJLiBJZiB3ZSdyZSBpblxuICAvLyB0aGUgYnJvd3NlciwgYWRkIGBfYCBhcyBhIGdsb2JhbCBvYmplY3QuXG4gIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IF87XG4gICAgfVxuICAgIGV4cG9ydHMuXyA9IF87XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5fID0gXztcbiAgfVxuXG4gIC8vIEN1cnJlbnQgdmVyc2lvbi5cbiAgXy5WRVJTSU9OID0gJzEuOC4yJztcblxuICAvLyBJbnRlcm5hbCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gZWZmaWNpZW50IChmb3IgY3VycmVudCBlbmdpbmVzKSB2ZXJzaW9uXG4gIC8vIG9mIHRoZSBwYXNzZWQtaW4gY2FsbGJhY2ssIHRvIGJlIHJlcGVhdGVkbHkgYXBwbGllZCBpbiBvdGhlciBVbmRlcnNjb3JlXG4gIC8vIGZ1bmN0aW9ucy5cbiAgdmFyIG9wdGltaXplQ2IgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHJldHVybiBmdW5jO1xuICAgIHN3aXRjaCAoYXJnQ291bnQgPT0gbnVsbCA/IDMgOiBhcmdDb3VudCkge1xuICAgICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSk7XG4gICAgICB9O1xuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUsIG90aGVyKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCBhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBBIG1vc3RseS1pbnRlcm5hbCBmdW5jdGlvbiB0byBnZW5lcmF0ZSBjYWxsYmFja3MgdGhhdCBjYW4gYmUgYXBwbGllZFxuICAvLyB0byBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uLCByZXR1cm5pbmcgdGhlIGRlc2lyZWQgcmVzdWx0IOKAlCBlaXRoZXJcbiAgLy8gaWRlbnRpdHksIGFuIGFyYml0cmFyeSBjYWxsYmFjaywgYSBwcm9wZXJ0eSBtYXRjaGVyLCBvciBhIHByb3BlcnR5IGFjY2Vzc29yLlxuICB2YXIgY2IgPSBmdW5jdGlvbih2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIF8uaWRlbnRpdHk7XG4gICAgaWYgKF8uaXNGdW5jdGlvbih2YWx1ZSkpIHJldHVybiBvcHRpbWl6ZUNiKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCk7XG4gICAgaWYgKF8uaXNPYmplY3QodmFsdWUpKSByZXR1cm4gXy5tYXRjaGVyKHZhbHVlKTtcbiAgICByZXR1cm4gXy5wcm9wZXJ0eSh2YWx1ZSk7XG4gIH07XG4gIF8uaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwgY29udGV4dCkge1xuICAgIHJldHVybiBjYih2YWx1ZSwgY29udGV4dCwgSW5maW5pdHkpO1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhc3NpZ25lciBmdW5jdGlvbnMuXG4gIHZhciBjcmVhdGVBc3NpZ25lciA9IGZ1bmN0aW9uKGtleXNGdW5jLCB1bmRlZmluZWRPbmx5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoIDwgMiB8fCBvYmogPT0gbnVsbCkgcmV0dXJuIG9iajtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF0sXG4gICAgICAgICAgICBrZXlzID0ga2V5c0Z1bmMoc291cmNlKSxcbiAgICAgICAgICAgIGwgPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoIXVuZGVmaW5lZE9ubHkgfHwgb2JqW2tleV0gPT09IHZvaWQgMCkgb2JqW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIG5ldyBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIGFub3RoZXIuXG4gIHZhciBiYXNlQ3JlYXRlID0gZnVuY3Rpb24ocHJvdG90eXBlKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KHByb3RvdHlwZSkpIHJldHVybiB7fTtcbiAgICBpZiAobmF0aXZlQ3JlYXRlKSByZXR1cm4gbmF0aXZlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgQ3Rvci5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBDdG9yO1xuICAgIEN0b3IucHJvdG90eXBlID0gbnVsbDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIEhlbHBlciBmb3IgY29sbGVjdGlvbiBtZXRob2RzIHRvIGRldGVybWluZSB3aGV0aGVyIGEgY29sbGVjdGlvblxuICAvLyBzaG91bGQgYmUgaXRlcmF0ZWQgYXMgYW4gYXJyYXkgb3IgYXMgYW4gb2JqZWN0XG4gIC8vIFJlbGF0ZWQ6IGh0dHA6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvbGVuZ3RoXG4gIHZhciBNQVhfQVJSQVlfSU5ERVggPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuICB2YXIgaXNBcnJheUxpa2UgPSBmdW5jdGlvbihjb2xsZWN0aW9uKSB7XG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24gJiYgY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgcmV0dXJuIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgbGVuZ3RoID49IDAgJiYgbGVuZ3RoIDw9IE1BWF9BUlJBWV9JTkRFWDtcbiAgfTtcblxuICAvLyBDb2xsZWN0aW9uIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFRoZSBjb3JuZXJzdG9uZSwgYW4gYGVhY2hgIGltcGxlbWVudGF0aW9uLCBha2EgYGZvckVhY2hgLlxuICAvLyBIYW5kbGVzIHJhdyBvYmplY3RzIGluIGFkZGl0aW9uIHRvIGFycmF5LWxpa2VzLiBUcmVhdHMgYWxsXG4gIC8vIHNwYXJzZSBhcnJheS1saWtlcyBhcyBpZiB0aGV5IHdlcmUgZGVuc2UuXG4gIF8uZWFjaCA9IF8uZm9yRWFjaCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBpLCBsZW5ndGg7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRlZShvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtrZXlzW2ldXSwga2V5c1tpXSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudC5cbiAgXy5tYXAgPSBfLmNvbGxlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdHMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICByZXN1bHRzW2luZGV4XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgcmVkdWNpbmcgZnVuY3Rpb24gaXRlcmF0aW5nIGxlZnQgb3IgcmlnaHQuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJlZHVjZShkaXIpIHtcbiAgICAvLyBPcHRpbWl6ZWQgaXRlcmF0b3IgZnVuY3Rpb24gYXMgdXNpbmcgYXJndW1lbnRzLmxlbmd0aFxuICAgIC8vIGluIHRoZSBtYWluIGZ1bmN0aW9uIHdpbGwgZGVvcHRpbWl6ZSB0aGUsIHNlZSAjMTk5MS5cbiAgICBmdW5jdGlvbiBpdGVyYXRvcihvYmosIGl0ZXJhdGVlLCBtZW1vLCBrZXlzLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICAgIG1lbW8gPSBpdGVyYXRlZShtZW1vLCBvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgbWVtbywgY29udGV4dCkge1xuICAgICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCA0KTtcbiAgICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgICAgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICAvLyBEZXRlcm1pbmUgdGhlIGluaXRpYWwgdmFsdWUgaWYgbm9uZSBpcyBwcm92aWRlZC5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgICBtZW1vID0gb2JqW2tleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4XTtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdG9yKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGtleXMsIGluZGV4LCBsZW5ndGgpO1xuICAgIH07XG4gIH1cblxuICAvLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsXG4gIC8vIG9yIGBmb2xkbGAuXG4gIF8ucmVkdWNlID0gXy5mb2xkbCA9IF8uaW5qZWN0ID0gY3JlYXRlUmVkdWNlKDEpO1xuXG4gIC8vIFRoZSByaWdodC1hc3NvY2lhdGl2ZSB2ZXJzaW9uIG9mIHJlZHVjZSwgYWxzbyBrbm93biBhcyBgZm9sZHJgLlxuICBfLnJlZHVjZVJpZ2h0ID0gXy5mb2xkciA9IGNyZWF0ZVJlZHVjZSgtMSk7XG5cbiAgLy8gUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB3aGljaCBwYXNzZXMgYSB0cnV0aCB0ZXN0LiBBbGlhc2VkIGFzIGBkZXRlY3RgLlxuICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIGtleTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAga2V5ID0gXy5maW5kSW5kZXgob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBfLmZpbmRLZXkob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAoa2V5ICE9PSB2b2lkIDAgJiYga2V5ICE9PSAtMSkgcmV0dXJuIG9ialtrZXldO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYHNlbGVjdGAuXG4gIF8uZmlsdGVyID0gXy5zZWxlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBmb3Igd2hpY2ggYSB0cnV0aCB0ZXN0IGZhaWxzLlxuICBfLnJlamVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5uZWdhdGUoY2IocHJlZGljYXRlKSksIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIERldGVybWluZSB3aGV0aGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgbWF0Y2ggYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbGxgLlxuICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmICghcHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgYW55YC5cbiAgXy5zb21lID0gXy5hbnkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiB0aGUgYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5zIGEgZ2l2ZW4gdmFsdWUgKHVzaW5nIGA9PT1gKS5cbiAgLy8gQWxpYXNlZCBhcyBgaW5jbHVkZXNgIGFuZCBgaW5jbHVkZWAuXG4gIF8uY29udGFpbnMgPSBfLmluY2x1ZGVzID0gXy5pbmNsdWRlID0gZnVuY3Rpb24ob2JqLCB0YXJnZXQsIGZyb21JbmRleCkge1xuICAgIGlmICghaXNBcnJheUxpa2Uob2JqKSkgb2JqID0gXy52YWx1ZXMob2JqKTtcbiAgICByZXR1cm4gXy5pbmRleE9mKG9iaiwgdGFyZ2V0LCB0eXBlb2YgZnJvbUluZGV4ID09ICdudW1iZXInICYmIGZyb21JbmRleCkgPj0gMDtcbiAgfTtcblxuICAvLyBJbnZva2UgYSBtZXRob2QgKHdpdGggYXJndW1lbnRzKSBvbiBldmVyeSBpdGVtIGluIGEgY29sbGVjdGlvbi5cbiAgXy5pbnZva2UgPSBmdW5jdGlvbihvYmosIG1ldGhvZCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBpc0Z1bmMgPSBfLmlzRnVuY3Rpb24obWV0aG9kKTtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0Z1bmMgPyBtZXRob2QgOiB2YWx1ZVttZXRob2RdO1xuICAgICAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IGZ1bmMgOiBmdW5jLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBtYXBgOiBmZXRjaGluZyBhIHByb3BlcnR5LlxuICBfLnBsdWNrID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBfLnByb3BlcnR5KGtleSkpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbHRlcmA6IHNlbGVjdGluZyBvbmx5IG9iamVjdHNcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy53aGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaW5kYDogZ2V0dGluZyB0aGUgZmlyc3Qgb2JqZWN0XG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8uZmluZFdoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbmQob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1heGltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWF4ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSAtSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IC1JbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsICYmIG9iaiAhPSBudWxsKSB7XG4gICAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSA+IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgaWYgKGNvbXB1dGVkID4gbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSAtSW5maW5pdHkgJiYgcmVzdWx0ID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtaW5pbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1pbiA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IEluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgJiYgb2JqICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlIDwgcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPCBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IEluZmluaXR5ICYmIHJlc3VsdCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gU2h1ZmZsZSBhIGNvbGxlY3Rpb24sIHVzaW5nIHRoZSBtb2Rlcm4gdmVyc2lvbiBvZiB0aGVcbiAgLy8gW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlcuKAk1lhdGVzX3NodWZmbGUpLlxuICBfLnNodWZmbGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgc2V0ID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IHNldC5sZW5ndGg7XG4gICAgdmFyIHNodWZmbGVkID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIHJhbmQ7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByYW5kID0gXy5yYW5kb20oMCwgaW5kZXgpO1xuICAgICAgaWYgKHJhbmQgIT09IGluZGV4KSBzaHVmZmxlZFtpbmRleF0gPSBzaHVmZmxlZFtyYW5kXTtcbiAgICAgIHNodWZmbGVkW3JhbmRdID0gc2V0W2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHNodWZmbGVkO1xuICB9O1xuXG4gIC8vIFNhbXBsZSAqKm4qKiByYW5kb20gdmFsdWVzIGZyb20gYSBjb2xsZWN0aW9uLlxuICAvLyBJZiAqKm4qKiBpcyBub3Qgc3BlY2lmaWVkLCByZXR1cm5zIGEgc2luZ2xlIHJhbmRvbSBlbGVtZW50LlxuICAvLyBUaGUgaW50ZXJuYWwgYGd1YXJkYCBhcmd1bWVudCBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBtYXBgLlxuICBfLnNhbXBsZSA9IGZ1bmN0aW9uKG9iaiwgbiwgZ3VhcmQpIHtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSB7XG4gICAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgICByZXR1cm4gb2JqW18ucmFuZG9tKG9iai5sZW5ndGggLSAxKV07XG4gICAgfVxuICAgIHJldHVybiBfLnNodWZmbGUob2JqKS5zbGljZSgwLCBNYXRoLm1heCgwLCBuKSk7XG4gIH07XG5cbiAgLy8gU29ydCB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uIHByb2R1Y2VkIGJ5IGFuIGl0ZXJhdGVlLlxuICBfLnNvcnRCeSA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICByZXR1cm4gXy5wbHVjayhfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIGNyaXRlcmlhOiBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpXG4gICAgICB9O1xuICAgIH0pLnNvcnQoZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYTtcbiAgICAgIHZhciBiID0gcmlnaHQuY3JpdGVyaWE7XG4gICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICBpZiAoYSA+IGIgfHwgYSA9PT0gdm9pZCAwKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgPCBiIHx8IGIgPT09IHZvaWQgMCkgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlZnQuaW5kZXggLSByaWdodC5pbmRleDtcbiAgICB9KSwgJ3ZhbHVlJyk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdXNlZCBmb3IgYWdncmVnYXRlIFwiZ3JvdXAgYnlcIiBvcGVyYXRpb25zLlxuICB2YXIgZ3JvdXAgPSBmdW5jdGlvbihiZWhhdmlvcikge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgICB2YXIga2V5ID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBvYmopO1xuICAgICAgICBiZWhhdmlvcihyZXN1bHQsIHZhbHVlLCBrZXkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gR3JvdXBzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24uIFBhc3MgZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZVxuICAvLyB0byBncm91cCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNyaXRlcmlvbi5cbiAgXy5ncm91cEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7IGVsc2UgcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xuICB9KTtcblxuICAvLyBJbmRleGVzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24sIHNpbWlsYXIgdG8gYGdyb3VwQnlgLCBidXQgZm9yXG4gIC8vIHdoZW4geW91IGtub3cgdGhhdCB5b3VyIGluZGV4IHZhbHVlcyB3aWxsIGJlIHVuaXF1ZS5cbiAgXy5pbmRleEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgLy8gQ291bnRzIGluc3RhbmNlcyBvZiBhbiBvYmplY3QgdGhhdCBncm91cCBieSBhIGNlcnRhaW4gY3JpdGVyaW9uLiBQYXNzXG4gIC8vIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGUgdG8gY291bnQgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAvLyBjcml0ZXJpb24uXG4gIF8uY291bnRCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIGlmIChfLmhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldKys7IGVsc2UgcmVzdWx0W2tleV0gPSAxO1xuICB9KTtcblxuICAvLyBTYWZlbHkgY3JlYXRlIGEgcmVhbCwgbGl2ZSBhcnJheSBmcm9tIGFueXRoaW5nIGl0ZXJhYmxlLlxuICBfLnRvQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIFtdO1xuICAgIGlmIChfLmlzQXJyYXkob2JqKSkgcmV0dXJuIHNsaWNlLmNhbGwob2JqKTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkgcmV0dXJuIF8ubWFwKG9iaiwgXy5pZGVudGl0eSk7XG4gICAgcmV0dXJuIF8udmFsdWVzKG9iaik7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYW4gb2JqZWN0LlxuICBfLnNpemUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiAwO1xuICAgIHJldHVybiBpc0FycmF5TGlrZShvYmopID8gb2JqLmxlbmd0aCA6IF8ua2V5cyhvYmopLmxlbmd0aDtcbiAgfTtcblxuICAvLyBTcGxpdCBhIGNvbGxlY3Rpb24gaW50byB0d28gYXJyYXlzOiBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIHNhdGlzZnkgdGhlIGdpdmVuXG4gIC8vIHByZWRpY2F0ZSwgYW5kIG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgZG8gbm90IHNhdGlzZnkgdGhlIHByZWRpY2F0ZS5cbiAgXy5wYXJ0aXRpb24gPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIHBhc3MgPSBbXSwgZmFpbCA9IFtdO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikge1xuICAgICAgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBvYmopID8gcGFzcyA6IGZhaWwpLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBbcGFzcywgZmFpbF07XG4gIH07XG5cbiAgLy8gQXJyYXkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBBbGlhc2VkIGFzIGBoZWFkYCBhbmQgYHRha2VgLiBUaGUgKipndWFyZCoqIGNoZWNrXG4gIC8vIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5maXJzdCA9IF8uaGVhZCA9IF8udGFrZSA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVswXTtcbiAgICByZXR1cm4gXy5pbml0aWFsKGFycmF5LCBhcnJheS5sZW5ndGggLSBuKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5IG9mIHRoZSBhcnJheS4gRXNwZWNpYWxseSB1c2VmdWwgb25cbiAgLy8gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gYWxsIHRoZSB2YWx1ZXMgaW5cbiAgLy8gdGhlIGFycmF5LCBleGNsdWRpbmcgdGhlIGxhc3QgTi5cbiAgXy5pbml0aWFsID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIChuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbikpKTtcbiAgfTtcblxuICAvLyBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgbGFzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ubGFzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gXy5yZXN0KGFycmF5LCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSBuKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgZmlyc3QgZW50cnkgb2YgdGhlIGFycmF5LiBBbGlhc2VkIGFzIGB0YWlsYCBhbmQgYGRyb3BgLlxuICAvLyBFc3BlY2lhbGx5IHVzZWZ1bCBvbiB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyBhbiAqKm4qKiB3aWxsIHJldHVyblxuICAvLyB0aGUgcmVzdCBOIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ucmVzdCA9IF8udGFpbCA9IF8uZHJvcCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCBuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbik7XG4gIH07XG5cbiAgLy8gVHJpbSBvdXQgYWxsIGZhbHN5IHZhbHVlcyBmcm9tIGFuIGFycmF5LlxuICBfLmNvbXBhY3QgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgXy5pZGVudGl0eSk7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgYSByZWN1cnNpdmUgYGZsYXR0ZW5gIGZ1bmN0aW9uLlxuICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uKGlucHV0LCBzaGFsbG93LCBzdHJpY3QsIHN0YXJ0SW5kZXgpIHtcbiAgICB2YXIgb3V0cHV0ID0gW10sIGlkeCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggfHwgMCwgbGVuZ3RoID0gaW5wdXQgJiYgaW5wdXQubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGlucHV0W2ldO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJiAoXy5pc0FycmF5KHZhbHVlKSB8fCBfLmlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgICAgLy9mbGF0dGVuIGN1cnJlbnQgbGV2ZWwgb2YgYXJyYXkgb3IgYXJndW1lbnRzIG9iamVjdFxuICAgICAgICBpZiAoIXNoYWxsb3cpIHZhbHVlID0gZmxhdHRlbih2YWx1ZSwgc2hhbGxvdywgc3RyaWN0KTtcbiAgICAgICAgdmFyIGogPSAwLCBsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIG91dHB1dC5sZW5ndGggKz0gbGVuO1xuICAgICAgICB3aGlsZSAoaiA8IGxlbikge1xuICAgICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZVtqKytdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFzdHJpY3QpIHtcbiAgICAgICAgb3V0cHV0W2lkeCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xuXG4gIC8vIEZsYXR0ZW4gb3V0IGFuIGFycmF5LCBlaXRoZXIgcmVjdXJzaXZlbHkgKGJ5IGRlZmF1bHQpLCBvciBqdXN0IG9uZSBsZXZlbC5cbiAgXy5mbGF0dGVuID0gZnVuY3Rpb24oYXJyYXksIHNoYWxsb3cpIHtcbiAgICByZXR1cm4gZmxhdHRlbihhcnJheSwgc2hhbGxvdywgZmFsc2UpO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHZlcnNpb24gb2YgdGhlIGFycmF5IHRoYXQgZG9lcyBub3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIHZhbHVlKHMpLlxuICBfLndpdGhvdXQgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmRpZmZlcmVuY2UoYXJyYXksIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgdGhlIGFycmF5LiBJZiB0aGUgYXJyYXkgaGFzIGFscmVhZHlcbiAgLy8gYmVlbiBzb3J0ZWQsIHlvdSBoYXZlIHRoZSBvcHRpb24gb2YgdXNpbmcgYSBmYXN0ZXIgYWxnb3JpdGhtLlxuICAvLyBBbGlhc2VkIGFzIGB1bmlxdWVgLlxuICBfLnVuaXEgPSBfLnVuaXF1ZSA9IGZ1bmN0aW9uKGFycmF5LCBpc1NvcnRlZCwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIFtdO1xuICAgIGlmICghXy5pc0Jvb2xlYW4oaXNTb3J0ZWQpKSB7XG4gICAgICBjb250ZXh0ID0gaXRlcmF0ZWU7XG4gICAgICBpdGVyYXRlZSA9IGlzU29ydGVkO1xuICAgICAgaXNTb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGl0ZXJhdGVlICE9IG51bGwpIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgc2VlbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaV0sXG4gICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlLCBpLCBhcnJheSkgOiB2YWx1ZTtcbiAgICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgICBpZiAoIWkgfHwgc2VlbiAhPT0gY29tcHV0ZWQpIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgc2VlbiA9IGNvbXB1dGVkO1xuICAgICAgfSBlbHNlIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoc2VlbiwgY29tcHV0ZWQpKSB7XG4gICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIV8uY29udGFpbnMocmVzdWx0LCB2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZlxuICAvLyB0aGUgcGFzc2VkLWluIGFycmF5cy5cbiAgXy51bmlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnVuaXEoZmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUpKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlXG4gIC8vIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8uaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIFtdO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IGFycmF5W2ldO1xuICAgICAgaWYgKF8uY29udGFpbnMocmVzdWx0LCBpdGVtKSkgY29udGludWU7XG4gICAgICBmb3IgKHZhciBqID0gMTsgaiA8IGFyZ3NMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoYXJndW1lbnRzW2pdLCBpdGVtKSkgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoaiA9PT0gYXJnc0xlbmd0aCkgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gVGFrZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIG9uZSBhcnJheSBhbmQgYSBudW1iZXIgb2Ygb3RoZXIgYXJyYXlzLlxuICAvLyBPbmx5IHRoZSBlbGVtZW50cyBwcmVzZW50IGluIGp1c3QgdGhlIGZpcnN0IGFycmF5IHdpbGwgcmVtYWluLlxuICBfLmRpZmZlcmVuY2UgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciByZXN0ID0gZmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUsIDEpO1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgZnVuY3Rpb24odmFsdWUpe1xuICAgICAgcmV0dXJuICFfLmNvbnRhaW5zKHJlc3QsIHZhbHVlKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBaaXAgdG9nZXRoZXIgbXVsdGlwbGUgbGlzdHMgaW50byBhIHNpbmdsZSBhcnJheSAtLSBlbGVtZW50cyB0aGF0IHNoYXJlXG4gIC8vIGFuIGluZGV4IGdvIHRvZ2V0aGVyLlxuICBfLnppcCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnVuemlwKGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gQ29tcGxlbWVudCBvZiBfLnppcC4gVW56aXAgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgYW5kIGdyb3Vwc1xuICAvLyBlYWNoIGFycmF5J3MgZWxlbWVudHMgb24gc2hhcmVkIGluZGljZXNcbiAgXy51bnppcCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ICYmIF8ubWF4KGFycmF5LCAnbGVuZ3RoJykubGVuZ3RoIHx8IDA7XG4gICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gXy5wbHVjayhhcnJheSwgaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENvbnZlcnRzIGxpc3RzIGludG8gb2JqZWN0cy4gUGFzcyBlaXRoZXIgYSBzaW5nbGUgYXJyYXkgb2YgYFtrZXksIHZhbHVlXWBcbiAgLy8gcGFpcnMsIG9yIHR3byBwYXJhbGxlbCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoIC0tIG9uZSBvZiBrZXlzLCBhbmQgb25lIG9mXG4gIC8vIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgXy5vYmplY3QgPSBmdW5jdGlvbihsaXN0LCB2YWx1ZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGxpc3QgJiYgbGlzdC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICByZXN1bHRbbGlzdFtpXV0gPSB2YWx1ZXNbaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbbGlzdFtpXVswXV0gPSBsaXN0W2ldWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW4gaXRlbSBpbiBhbiBhcnJheSxcbiAgLy8gb3IgLTEgaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS5cbiAgLy8gSWYgdGhlIGFycmF5IGlzIGxhcmdlIGFuZCBhbHJlYWR5IGluIHNvcnQgb3JkZXIsIHBhc3MgYHRydWVgXG4gIC8vIGZvciAqKmlzU29ydGVkKiogdG8gdXNlIGJpbmFyeSBzZWFyY2guXG4gIF8uaW5kZXhPZiA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBpc1NvcnRlZCkge1xuICAgIHZhciBpID0gMCwgbGVuZ3RoID0gYXJyYXkgJiYgYXJyYXkubGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgaXNTb3J0ZWQgPT0gJ251bWJlcicpIHtcbiAgICAgIGkgPSBpc1NvcnRlZCA8IDAgPyBNYXRoLm1heCgwLCBsZW5ndGggKyBpc1NvcnRlZCkgOiBpc1NvcnRlZDtcbiAgICB9IGVsc2UgaWYgKGlzU29ydGVkICYmIGxlbmd0aCkge1xuICAgICAgaSA9IF8uc29ydGVkSW5kZXgoYXJyYXksIGl0ZW0pO1xuICAgICAgcmV0dXJuIGFycmF5W2ldID09PSBpdGVtID8gaSA6IC0xO1xuICAgIH1cbiAgICBpZiAoaXRlbSAhPT0gaXRlbSkge1xuICAgICAgcmV0dXJuIF8uZmluZEluZGV4KHNsaWNlLmNhbGwoYXJyYXksIGkpLCBfLmlzTmFOKTtcbiAgICB9XG4gICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykgaWYgKGFycmF5W2ldID09PSBpdGVtKSByZXR1cm4gaTtcbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgXy5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBmcm9tKSB7XG4gICAgdmFyIGlkeCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICBpZiAodHlwZW9mIGZyb20gPT0gJ251bWJlcicpIHtcbiAgICAgIGlkeCA9IGZyb20gPCAwID8gaWR4ICsgZnJvbSArIDEgOiBNYXRoLm1pbihpZHgsIGZyb20gKyAxKTtcbiAgICB9XG4gICAgaWYgKGl0ZW0gIT09IGl0ZW0pIHtcbiAgICAgIHJldHVybiBfLmZpbmRMYXN0SW5kZXgoc2xpY2UuY2FsbChhcnJheSwgMCwgaWR4KSwgXy5pc05hTik7XG4gICAgfVxuICAgIHdoaWxlICgtLWlkeCA+PSAwKSBpZiAoYXJyYXlbaWR4XSA9PT0gaXRlbSkgcmV0dXJuIGlkeDtcbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgLy8gR2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgZmluZEluZGV4IGFuZCBmaW5kTGFzdEluZGV4IGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBjcmVhdGVJbmRleEZpbmRlcihkaXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSAhPSBudWxsICYmIGFycmF5Lmxlbmd0aDtcbiAgICAgIHZhciBpbmRleCA9IGRpciA+IDAgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgIGZvciAoOyBpbmRleCA+PSAwICYmIGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSBkaXIpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgaW5kZXggb24gYW4gYXJyYXktbGlrZSB0aGF0IHBhc3NlcyBhIHByZWRpY2F0ZSB0ZXN0XG4gIF8uZmluZEluZGV4ID0gY3JlYXRlSW5kZXhGaW5kZXIoMSk7XG5cbiAgXy5maW5kTGFzdEluZGV4ID0gY3JlYXRlSW5kZXhGaW5kZXIoLTEpO1xuXG4gIC8vIFVzZSBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gdG8gZmlndXJlIG91dCB0aGUgc21hbGxlc3QgaW5kZXggYXQgd2hpY2hcbiAgLy8gYW4gb2JqZWN0IHNob3VsZCBiZSBpbnNlcnRlZCBzbyBhcyB0byBtYWludGFpbiBvcmRlci4gVXNlcyBiaW5hcnkgc2VhcmNoLlxuICBfLnNvcnRlZEluZGV4ID0gZnVuY3Rpb24oYXJyYXksIG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICB2YXIgdmFsdWUgPSBpdGVyYXRlZShvYmopO1xuICAgIHZhciBsb3cgPSAwLCBoaWdoID0gYXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICB2YXIgbWlkID0gTWF0aC5mbG9vcigobG93ICsgaGlnaCkgLyAyKTtcbiAgICAgIGlmIChpdGVyYXRlZShhcnJheVttaWRdKSA8IHZhbHVlKSBsb3cgPSBtaWQgKyAxOyBlbHNlIGhpZ2ggPSBtaWQ7XG4gICAgfVxuICAgIHJldHVybiBsb3c7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYW4gaW50ZWdlciBBcnJheSBjb250YWluaW5nIGFuIGFyaXRobWV0aWMgcHJvZ3Jlc3Npb24uIEEgcG9ydCBvZlxuICAvLyB0aGUgbmF0aXZlIFB5dGhvbiBgcmFuZ2UoKWAgZnVuY3Rpb24uIFNlZVxuICAvLyBbdGhlIFB5dGhvbiBkb2N1bWVudGF0aW9uXShodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvZnVuY3Rpb25zLmh0bWwjcmFuZ2UpLlxuICBfLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICBzdG9wID0gc3RhcnQgfHwgMDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgc3RlcCA9IHN0ZXAgfHwgMTtcblxuICAgIHZhciBsZW5ndGggPSBNYXRoLm1heChNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSwgMCk7XG4gICAgdmFyIHJhbmdlID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyssIHN0YXJ0ICs9IHN0ZXApIHtcbiAgICAgIHJhbmdlW2lkeF0gPSBzdGFydDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG5cbiAgLy8gRnVuY3Rpb24gKGFoZW0pIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gZXhlY3V0ZSBhIGZ1bmN0aW9uIGFzIGEgY29uc3RydWN0b3JcbiAgLy8gb3IgYSBub3JtYWwgZnVuY3Rpb24gd2l0aCB0aGUgcHJvdmlkZWQgYXJndW1lbnRzXG4gIHZhciBleGVjdXRlQm91bmQgPSBmdW5jdGlvbihzb3VyY2VGdW5jLCBib3VuZEZ1bmMsIGNvbnRleHQsIGNhbGxpbmdDb250ZXh0LCBhcmdzKSB7XG4gICAgaWYgKCEoY2FsbGluZ0NvbnRleHQgaW5zdGFuY2VvZiBib3VuZEZ1bmMpKSByZXR1cm4gc291cmNlRnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB2YXIgc2VsZiA9IGJhc2VDcmVhdGUoc291cmNlRnVuYy5wcm90b3R5cGUpO1xuICAgIHZhciByZXN1bHQgPSBzb3VyY2VGdW5jLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIGlmIChfLmlzT2JqZWN0KHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgZnVuY3Rpb24gYm91bmQgdG8gYSBnaXZlbiBvYmplY3QgKGFzc2lnbmluZyBgdGhpc2AsIGFuZCBhcmd1bWVudHMsXG4gIC8vIG9wdGlvbmFsbHkpLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgRnVuY3Rpb24uYmluZGAgaWZcbiAgLy8gYXZhaWxhYmxlLlxuICBfLmJpbmQgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0KSB7XG4gICAgaWYgKG5hdGl2ZUJpbmQgJiYgZnVuYy5iaW5kID09PSBuYXRpdmVCaW5kKSByZXR1cm4gbmF0aXZlQmluZC5hcHBseShmdW5jLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIGlmICghXy5pc0Z1bmN0aW9uKGZ1bmMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdCaW5kIG11c3QgYmUgY2FsbGVkIG9uIGEgZnVuY3Rpb24nKTtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIGNvbnRleHQsIHRoaXMsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9O1xuXG4gIC8vIFBhcnRpYWxseSBhcHBseSBhIGZ1bmN0aW9uIGJ5IGNyZWF0aW5nIGEgdmVyc2lvbiB0aGF0IGhhcyBoYWQgc29tZSBvZiBpdHNcbiAgLy8gYXJndW1lbnRzIHByZS1maWxsZWQsIHdpdGhvdXQgY2hhbmdpbmcgaXRzIGR5bmFtaWMgYHRoaXNgIGNvbnRleHQuIF8gYWN0c1xuICAvLyBhcyBhIHBsYWNlaG9sZGVyLCBhbGxvd2luZyBhbnkgY29tYmluYXRpb24gb2YgYXJndW1lbnRzIHRvIGJlIHByZS1maWxsZWQuXG4gIF8ucGFydGlhbCA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICB2YXIgYm91bmRBcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHZhciBib3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvc2l0aW9uID0gMCwgbGVuZ3RoID0gYm91bmRBcmdzLmxlbmd0aDtcbiAgICAgIHZhciBhcmdzID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJnc1tpXSA9IGJvdW5kQXJnc1tpXSA9PT0gXyA/IGFyZ3VtZW50c1twb3NpdGlvbisrXSA6IGJvdW5kQXJnc1tpXTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChwb3NpdGlvbiA8IGFyZ3VtZW50cy5sZW5ndGgpIGFyZ3MucHVzaChhcmd1bWVudHNbcG9zaXRpb24rK10pO1xuICAgICAgcmV0dXJuIGV4ZWN1dGVCb3VuZChmdW5jLCBib3VuZCwgdGhpcywgdGhpcywgYXJncyk7XG4gICAgfTtcbiAgICByZXR1cm4gYm91bmQ7XG4gIH07XG5cbiAgLy8gQmluZCBhIG51bWJlciBvZiBhbiBvYmplY3QncyBtZXRob2RzIHRvIHRoYXQgb2JqZWN0LiBSZW1haW5pbmcgYXJndW1lbnRzXG4gIC8vIGFyZSB0aGUgbWV0aG9kIG5hbWVzIHRvIGJlIGJvdW5kLiBVc2VmdWwgZm9yIGVuc3VyaW5nIHRoYXQgYWxsIGNhbGxiYWNrc1xuICAvLyBkZWZpbmVkIG9uIGFuIG9iamVjdCBiZWxvbmcgdG8gaXQuXG4gIF8uYmluZEFsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLCBrZXk7XG4gICAgaWYgKGxlbmd0aCA8PSAxKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBbGwgbXVzdCBiZSBwYXNzZWQgZnVuY3Rpb24gbmFtZXMnKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIG9ialtrZXldID0gXy5iaW5kKG9ialtrZXldLCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIE1lbW9pemUgYW4gZXhwZW5zaXZlIGZ1bmN0aW9uIGJ5IHN0b3JpbmcgaXRzIHJlc3VsdHMuXG4gIF8ubWVtb2l6ZSA9IGZ1bmN0aW9uKGZ1bmMsIGhhc2hlcikge1xuICAgIHZhciBtZW1vaXplID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgY2FjaGUgPSBtZW1vaXplLmNhY2hlO1xuICAgICAgdmFyIGFkZHJlc3MgPSAnJyArIChoYXNoZXIgPyBoYXNoZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGtleSk7XG4gICAgICBpZiAoIV8uaGFzKGNhY2hlLCBhZGRyZXNzKSkgY2FjaGVbYWRkcmVzc10gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gY2FjaGVbYWRkcmVzc107XG4gICAgfTtcbiAgICBtZW1vaXplLmNhY2hlID0ge307XG4gICAgcmV0dXJuIG1lbW9pemU7XG4gIH07XG5cbiAgLy8gRGVsYXlzIGEgZnVuY3Rpb24gZm9yIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCBhbmQgdGhlbiBjYWxsc1xuICAvLyBpdCB3aXRoIHRoZSBhcmd1bWVudHMgc3VwcGxpZWQuXG4gIF8uZGVsYXkgPSBmdW5jdGlvbihmdW5jLCB3YWl0KSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0sIHdhaXQpO1xuICB9O1xuXG4gIC8vIERlZmVycyBhIGZ1bmN0aW9uLCBzY2hlZHVsaW5nIGl0IHRvIHJ1biBhZnRlciB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhc1xuICAvLyBjbGVhcmVkLlxuICBfLmRlZmVyID0gXy5wYXJ0aWFsKF8uZGVsYXksIF8sIDEpO1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIG9ubHkgYmUgdHJpZ2dlcmVkIGF0IG1vc3Qgb25jZVxuICAvLyBkdXJpbmcgYSBnaXZlbiB3aW5kb3cgb2YgdGltZS4gTm9ybWFsbHksIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gd2lsbCBydW5cbiAgLy8gYXMgbXVjaCBhcyBpdCBjYW4sIHdpdGhvdXQgZXZlciBnb2luZyBtb3JlIHRoYW4gb25jZSBwZXIgYHdhaXRgIGR1cmF0aW9uO1xuICAvLyBidXQgaWYgeW91J2QgbGlrZSB0byBkaXNhYmxlIHRoZSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSwgcGFzc1xuICAvLyBge2xlYWRpbmc6IGZhbHNlfWAuIFRvIGRpc2FibGUgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlLCBkaXR0by5cbiAgXy50aHJvdHRsZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgY29udGV4dCwgYXJncywgcmVzdWx0O1xuICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXMgPSAwO1xuICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IF8ubm93KCk7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub3cgPSBfLm5vdygpO1xuICAgICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSBwcmV2aW91cyA9IG5vdztcbiAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxuICAvLyBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXG4gIC8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuICAvLyBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLlxuICBfLmRlYm91bmNlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGFzdCA9IF8ubm93KCkgLSB0aW1lc3RhbXA7XG5cbiAgICAgIGlmIChsYXN0IDwgd2FpdCAmJiBsYXN0ID49IDApIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdGltZXN0YW1wID0gXy5ub3coKTtcbiAgICAgIHZhciBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xuICAgICAgaWYgKCF0aW1lb3V0KSB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICBpZiAoY2FsbE5vdykge1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBmdW5jdGlvbiBwYXNzZWQgYXMgYW4gYXJndW1lbnQgdG8gdGhlIHNlY29uZCxcbiAgLy8gYWxsb3dpbmcgeW91IHRvIGFkanVzdCBhcmd1bWVudHMsIHJ1biBjb2RlIGJlZm9yZSBhbmQgYWZ0ZXIsIGFuZFxuICAvLyBjb25kaXRpb25hbGx5IGV4ZWN1dGUgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxuICBfLndyYXAgPSBmdW5jdGlvbihmdW5jLCB3cmFwcGVyKSB7XG4gICAgcmV0dXJuIF8ucGFydGlhbCh3cmFwcGVyLCBmdW5jKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgbmVnYXRlZCB2ZXJzaW9uIG9mIHRoZSBwYXNzZWQtaW4gcHJlZGljYXRlLlxuICBfLm5lZ2F0ZSA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgYSBsaXN0IG9mIGZ1bmN0aW9ucywgZWFjaFxuICAvLyBjb25zdW1pbmcgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gdGhhdCBmb2xsb3dzLlxuICBfLmNvbXBvc2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgc3RhcnQgPSBhcmdzLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGkgPSBzdGFydDtcbiAgICAgIHZhciByZXN1bHQgPSBhcmdzW3N0YXJ0XS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgd2hpbGUgKGktLSkgcmVzdWx0ID0gYXJnc1tpXS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIG9uIGFuZCBhZnRlciB0aGUgTnRoIGNhbGwuXG4gIF8uYWZ0ZXIgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzIDwgMSkge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIHVwIHRvIChidXQgbm90IGluY2x1ZGluZykgdGhlIE50aCBjYWxsLlxuICBfLmJlZm9yZSA9IGZ1bmN0aW9uKHRpbWVzLCBmdW5jKSB7XG4gICAgdmFyIG1lbW87XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tdGltZXMgPiAwKSB7XG4gICAgICAgIG1lbW8gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICBpZiAodGltZXMgPD0gMSkgZnVuYyA9IG51bGw7XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYXQgbW9zdCBvbmUgdGltZSwgbm8gbWF0dGVyIGhvd1xuICAvLyBvZnRlbiB5b3UgY2FsbCBpdC4gVXNlZnVsIGZvciBsYXp5IGluaXRpYWxpemF0aW9uLlxuICBfLm9uY2UgPSBfLnBhcnRpYWwoXy5iZWZvcmUsIDIpO1xuXG4gIC8vIE9iamVjdCBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEtleXMgaW4gSUUgPCA5IHRoYXQgd29uJ3QgYmUgaXRlcmF0ZWQgYnkgYGZvciBrZXkgaW4gLi4uYCBhbmQgdGh1cyBtaXNzZWQuXG4gIHZhciBoYXNFbnVtQnVnID0gIXt0b1N0cmluZzogbnVsbH0ucHJvcGVydHlJc0VudW1lcmFibGUoJ3RvU3RyaW5nJyk7XG4gIHZhciBub25FbnVtZXJhYmxlUHJvcHMgPSBbJ3ZhbHVlT2YnLCAnaXNQcm90b3R5cGVPZicsICd0b1N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJ2hhc093blByb3BlcnR5JywgJ3RvTG9jYWxlU3RyaW5nJ107XG5cbiAgZnVuY3Rpb24gY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpIHtcbiAgICB2YXIgbm9uRW51bUlkeCA9IG5vbkVudW1lcmFibGVQcm9wcy5sZW5ndGg7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gb2JqLmNvbnN0cnVjdG9yO1xuICAgIHZhciBwcm90byA9IChfLmlzRnVuY3Rpb24oY29uc3RydWN0b3IpICYmIGNvbnN0cnVjdG9yLnByb3RvdHlwZSkgfHwgT2JqUHJvdG87XG5cbiAgICAvLyBDb25zdHJ1Y3RvciBpcyBhIHNwZWNpYWwgY2FzZS5cbiAgICB2YXIgcHJvcCA9ICdjb25zdHJ1Y3Rvcic7XG4gICAgaWYgKF8uaGFzKG9iaiwgcHJvcCkgJiYgIV8uY29udGFpbnMoa2V5cywgcHJvcCkpIGtleXMucHVzaChwcm9wKTtcblxuICAgIHdoaWxlIChub25FbnVtSWR4LS0pIHtcbiAgICAgIHByb3AgPSBub25FbnVtZXJhYmxlUHJvcHNbbm9uRW51bUlkeF07XG4gICAgICBpZiAocHJvcCBpbiBvYmogJiYgb2JqW3Byb3BdICE9PSBwcm90b1twcm9wXSAmJiAhXy5jb250YWlucyhrZXlzLCBwcm9wKSkge1xuICAgICAgICBrZXlzLnB1c2gocHJvcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0cmlldmUgdGhlIG5hbWVzIG9mIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzLlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgT2JqZWN0LmtleXNgXG4gIF8ua2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgaWYgKG5hdGl2ZUtleXMpIHJldHVybiBuYXRpdmVLZXlzKG9iaik7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSBhbGwgdGhlIHByb3BlcnR5IG5hbWVzIG9mIGFuIG9iamVjdC5cbiAgXy5hbGxLZXlzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBbXTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICAgIC8vIEFoZW0sIElFIDwgOS5cbiAgICBpZiAoaGFzRW51bUJ1ZykgY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpO1xuICAgIHJldHVybiBrZXlzO1xuICB9O1xuXG4gIC8vIFJldHJpZXZlIHRoZSB2YWx1ZXMgb2YgYW4gb2JqZWN0J3MgcHJvcGVydGllcy5cbiAgXy52YWx1ZXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgdmFsdWVzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZXNbaV0gPSBvYmpba2V5c1tpXV07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0ZWUgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBvYmplY3RcbiAgLy8gSW4gY29udHJhc3QgdG8gXy5tYXAgaXQgcmV0dXJucyBhbiBvYmplY3RcbiAgXy5tYXBPYmplY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAgXy5rZXlzKG9iaiksXG4gICAgICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0cyA9IHt9LFxuICAgICAgICAgIGN1cnJlbnRLZXk7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGN1cnJlbnRLZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgICAgcmVzdWx0c1tjdXJyZW50S2V5XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIENvbnZlcnQgYW4gb2JqZWN0IGludG8gYSBsaXN0IG9mIGBba2V5LCB2YWx1ZV1gIHBhaXJzLlxuICBfLnBhaXJzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHBhaXJzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBwYWlyc1tpXSA9IFtrZXlzW2ldLCBvYmpba2V5c1tpXV1dO1xuICAgIH1cbiAgICByZXR1cm4gcGFpcnM7XG4gIH07XG5cbiAgLy8gSW52ZXJ0IHRoZSBrZXlzIGFuZCB2YWx1ZXMgb2YgYW4gb2JqZWN0LiBUaGUgdmFsdWVzIG11c3QgYmUgc2VyaWFsaXphYmxlLlxuICBfLmludmVydCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbb2JqW2tleXNbaV1dXSA9IGtleXNbaV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgc29ydGVkIGxpc3Qgb2YgdGhlIGZ1bmN0aW9uIG5hbWVzIGF2YWlsYWJsZSBvbiB0aGUgb2JqZWN0LlxuICAvLyBBbGlhc2VkIGFzIGBtZXRob2RzYFxuICBfLmZ1bmN0aW9ucyA9IF8ubWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24ob2JqW2tleV0pKSBuYW1lcy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcy5zb3J0KCk7XG4gIH07XG5cbiAgLy8gRXh0ZW5kIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBwcm9wZXJ0aWVzIGluIHBhc3NlZC1pbiBvYmplY3QocykuXG4gIF8uZXh0ZW5kID0gY3JlYXRlQXNzaWduZXIoXy5hbGxLZXlzKTtcblxuICAvLyBBc3NpZ25zIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBvd24gcHJvcGVydGllcyBpbiB0aGUgcGFzc2VkLWluIG9iamVjdChzKVxuICAvLyAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnbilcbiAgXy5leHRlbmRPd24gPSBfLmFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKF8ua2V5cyk7XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3Qga2V5IG9uIGFuIG9iamVjdCB0aGF0IHBhc3NlcyBhIHByZWRpY2F0ZSB0ZXN0XG4gIF8uZmluZEtleSA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopLCBrZXk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAocHJlZGljYXRlKG9ialtrZXldLCBrZXksIG9iaikpIHJldHVybiBrZXk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCBvbmx5IGNvbnRhaW5pbmcgdGhlIHdoaXRlbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ucGljayA9IGZ1bmN0aW9uKG9iamVjdCwgb2l0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9LCBvYmogPSBvYmplY3QsIGl0ZXJhdGVlLCBrZXlzO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKG9pdGVyYXRlZSkpIHtcbiAgICAgIGtleXMgPSBfLmFsbEtleXMob2JqKTtcbiAgICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihvaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gZmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSk7XG4gICAgICBpdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikgeyByZXR1cm4ga2V5IGluIG9iajsgfTtcbiAgICAgIG9iaiA9IE9iamVjdChvYmopO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgIGlmIChpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmopKSByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgd2l0aG91dCB0aGUgYmxhY2tsaXN0ZWQgcHJvcGVydGllcy5cbiAgXy5vbWl0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGlmIChfLmlzRnVuY3Rpb24oaXRlcmF0ZWUpKSB7XG4gICAgICBpdGVyYXRlZSA9IF8ubmVnYXRlKGl0ZXJhdGVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBfLm1hcChmbGF0dGVuKGFyZ3VtZW50cywgZmFsc2UsIGZhbHNlLCAxKSwgU3RyaW5nKTtcbiAgICAgIGl0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICByZXR1cm4gIV8uY29udGFpbnMoa2V5cywga2V5KTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfLnBpY2sob2JqLCBpdGVyYXRlZSwgY29udGV4dCk7XG4gIH07XG5cbiAgLy8gRmlsbCBpbiBhIGdpdmVuIG9iamVjdCB3aXRoIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgXy5kZWZhdWx0cyA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cywgdHJ1ZSk7XG5cbiAgLy8gQ3JlYXRlIGEgKHNoYWxsb3ctY2xvbmVkKSBkdXBsaWNhdGUgb2YgYW4gb2JqZWN0LlxuICBfLmNsb25lID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gICAgcmV0dXJuIF8uaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBfLmV4dGVuZCh7fSwgb2JqKTtcbiAgfTtcblxuICAvLyBJbnZva2VzIGludGVyY2VwdG9yIHdpdGggdGhlIG9iaiwgYW5kIHRoZW4gcmV0dXJucyBvYmouXG4gIC8vIFRoZSBwcmltYXJ5IHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluLCBpblxuICAvLyBvcmRlciB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluIHRoZSBjaGFpbi5cbiAgXy50YXAgPSBmdW5jdGlvbihvYmosIGludGVyY2VwdG9yKSB7XG4gICAgaW50ZXJjZXB0b3Iob2JqKTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybnMgd2hldGhlciBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gc2V0IG9mIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLmlzTWF0Y2ggPSBmdW5jdGlvbihvYmplY3QsIGF0dHJzKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMoYXR0cnMpLCBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHJldHVybiAhbGVuZ3RoO1xuICAgIHZhciBvYmogPSBPYmplY3Qob2JqZWN0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChhdHRyc1trZXldICE9PSBvYmpba2V5XSB8fCAhKGtleSBpbiBvYmopKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG5cbiAgLy8gSW50ZXJuYWwgcmVjdXJzaXZlIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIGBpc0VxdWFsYC5cbiAgdmFyIGVxID0gZnVuY3Rpb24oYSwgYiwgYVN0YWNrLCBiU3RhY2spIHtcbiAgICAvLyBJZGVudGljYWwgb2JqZWN0cyBhcmUgZXF1YWwuIGAwID09PSAtMGAsIGJ1dCB0aGV5IGFyZW4ndCBpZGVudGljYWwuXG4gICAgLy8gU2VlIHRoZSBbSGFybW9ueSBgZWdhbGAgcHJvcG9zYWxdKGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6ZWdhbCkuXG4gICAgaWYgKGEgPT09IGIpIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09PSAxIC8gYjtcbiAgICAvLyBBIHN0cmljdCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGBudWxsID09IHVuZGVmaW5lZGAuXG4gICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBhID09PSBiO1xuICAgIC8vIFVud3JhcCBhbnkgd3JhcHBlZCBvYmplY3RzLlxuICAgIGlmIChhIGluc3RhbmNlb2YgXykgYSA9IGEuX3dyYXBwZWQ7XG4gICAgaWYgKGIgaW5zdGFuY2VvZiBfKSBiID0gYi5fd3JhcHBlZDtcbiAgICAvLyBDb21wYXJlIGBbW0NsYXNzXV1gIG5hbWVzLlxuICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpO1xuICAgIGlmIChjbGFzc05hbWUgIT09IHRvU3RyaW5nLmNhbGwoYikpIHJldHVybiBmYWxzZTtcbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgLy8gU3RyaW5ncywgbnVtYmVycywgcmVndWxhciBleHByZXNzaW9ucywgZGF0ZXMsIGFuZCBib29sZWFucyBhcmUgY29tcGFyZWQgYnkgdmFsdWUuXG4gICAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOlxuICAgICAgLy8gUmVnRXhwcyBhcmUgY29lcmNlZCB0byBzdHJpbmdzIGZvciBjb21wYXJpc29uIChOb3RlOiAnJyArIC9hL2kgPT09ICcvYS9pJylcbiAgICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gYG5ldyBTdHJpbmcoXCI1XCIpYC5cbiAgICAgICAgcmV0dXJuICcnICsgYSA9PT0gJycgKyBiO1xuICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcbiAgICAgICAgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS5cbiAgICAgICAgLy8gT2JqZWN0KE5hTikgaXMgZXF1aXZhbGVudCB0byBOYU5cbiAgICAgICAgaWYgKCthICE9PSArYSkgcmV0dXJuICtiICE9PSArYjtcbiAgICAgICAgLy8gQW4gYGVnYWxgIGNvbXBhcmlzb24gaXMgcGVyZm9ybWVkIGZvciBvdGhlciBudW1lcmljIHZhbHVlcy5cbiAgICAgICAgcmV0dXJuICthID09PSAwID8gMSAvICthID09PSAxIC8gYiA6ICthID09PSArYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOlxuICAgICAgY2FzZSAnW29iamVjdCBCb29sZWFuXSc6XG4gICAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtZXJpYyBwcmltaXRpdmUgdmFsdWVzLiBEYXRlcyBhcmUgY29tcGFyZWQgYnkgdGhlaXJcbiAgICAgICAgLy8gbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zLiBOb3RlIHRoYXQgaW52YWxpZCBkYXRlcyB3aXRoIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9uc1xuICAgICAgICAvLyBvZiBgTmFOYCBhcmUgbm90IGVxdWl2YWxlbnQuXG4gICAgICAgIHJldHVybiArYSA9PT0gK2I7XG4gICAgfVxuXG4gICAgdmFyIGFyZUFycmF5cyA9IGNsYXNzTmFtZSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICBpZiAoIWFyZUFycmF5cykge1xuICAgICAgaWYgKHR5cGVvZiBhICE9ICdvYmplY3QnIHx8IHR5cGVvZiBiICE9ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIC8vIE9iamVjdHMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1aXZhbGVudCwgYnV0IGBPYmplY3RgcyBvciBgQXJyYXlgc1xuICAgICAgLy8gZnJvbSBkaWZmZXJlbnQgZnJhbWVzIGFyZS5cbiAgICAgIHZhciBhQ3RvciA9IGEuY29uc3RydWN0b3IsIGJDdG9yID0gYi5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmIChhQ3RvciAhPT0gYkN0b3IgJiYgIShfLmlzRnVuY3Rpb24oYUN0b3IpICYmIGFDdG9yIGluc3RhbmNlb2YgYUN0b3IgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmlzRnVuY3Rpb24oYkN0b3IpICYmIGJDdG9yIGluc3RhbmNlb2YgYkN0b3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICYmICgnY29uc3RydWN0b3InIGluIGEgJiYgJ2NvbnN0cnVjdG9yJyBpbiBiKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEFzc3VtZSBlcXVhbGl0eSBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWNcbiAgICAvLyBzdHJ1Y3R1cmVzIGlzIGFkYXB0ZWQgZnJvbSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLCBhYnN0cmFjdCBvcGVyYXRpb24gYEpPYC5cbiAgICBcbiAgICAvLyBJbml0aWFsaXppbmcgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgLy8gSXQncyBkb25lIGhlcmUgc2luY2Ugd2Ugb25seSBuZWVkIHRoZW0gZm9yIG9iamVjdHMgYW5kIGFycmF5cyBjb21wYXJpc29uLlxuICAgIGFTdGFjayA9IGFTdGFjayB8fCBbXTtcbiAgICBiU3RhY2sgPSBiU3RhY2sgfHwgW107XG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PT0gYSkgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09PSBiO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucHVzaChhKTtcbiAgICBiU3RhY2sucHVzaChiKTtcblxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgIGlmIChhcmVBcnJheXMpIHtcbiAgICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoIWVxKGFbbGVuZ3RoXSwgYltsZW5ndGhdLCBhU3RhY2ssIGJTdGFjaykpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhhKSwga2V5O1xuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcyBiZWZvcmUgY29tcGFyaW5nIGRlZXAgZXF1YWxpdHkuXG4gICAgICBpZiAoXy5rZXlzKGIpLmxlbmd0aCAhPT0gbGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyXG4gICAgICAgIGtleSA9IGtleXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKCEoXy5oYXMoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgYVN0YWNrLCBiU3RhY2spKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IG9iamVjdCBmcm9tIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucG9wKCk7XG4gICAgYlN0YWNrLnBvcCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIFBlcmZvcm0gYSBkZWVwIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGVxdWFsLlxuICBfLmlzRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGVxKGEsIGIpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gYXJyYXksIHN0cmluZywgb3Igb2JqZWN0IGVtcHR5P1xuICAvLyBBbiBcImVtcHR5XCIgb2JqZWN0IGhhcyBubyBlbnVtZXJhYmxlIG93bi1wcm9wZXJ0aWVzLlxuICBfLmlzRW1wdHkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopICYmIChfLmlzQXJyYXkob2JqKSB8fCBfLmlzU3RyaW5nKG9iaikgfHwgXy5pc0FyZ3VtZW50cyhvYmopKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gICAgcmV0dXJuIF8ua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgRE9NIGVsZW1lbnQ/XG4gIF8uaXNFbGVtZW50ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYW4gYXJyYXk/XG4gIC8vIERlbGVnYXRlcyB0byBFQ01BNSdzIG5hdGl2ZSBBcnJheS5pc0FycmF5XG4gIF8uaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIGFuIG9iamVjdD9cbiAgXy5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcbiAgfTtcblxuICAvLyBBZGQgc29tZSBpc1R5cGUgbWV0aG9kczogaXNBcmd1bWVudHMsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlciwgaXNEYXRlLCBpc1JlZ0V4cCwgaXNFcnJvci5cbiAgXy5lYWNoKFsnQXJndW1lbnRzJywgJ0Z1bmN0aW9uJywgJ1N0cmluZycsICdOdW1iZXInLCAnRGF0ZScsICdSZWdFeHAnLCAnRXJyb3InXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIF9bJ2lzJyArIG5hbWVdID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCAnICsgbmFtZSArICddJztcbiAgICB9O1xuICB9KTtcblxuICAvLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFIDwgOSksIHdoZXJlXG4gIC8vIHRoZXJlIGlzbid0IGFueSBpbnNwZWN0YWJsZSBcIkFyZ3VtZW50c1wiIHR5cGUuXG4gIGlmICghXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpKSB7XG4gICAgXy5pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIF8uaGFzKG9iaiwgJ2NhbGxlZScpO1xuICAgIH07XG4gIH1cblxuICAvLyBPcHRpbWl6ZSBgaXNGdW5jdGlvbmAgaWYgYXBwcm9wcmlhdGUuIFdvcmsgYXJvdW5kIHNvbWUgdHlwZW9mIGJ1Z3MgaW4gb2xkIHY4LFxuICAvLyBJRSAxMSAoIzE2MjEpLCBhbmQgaW4gU2FmYXJpIDggKCMxOTI5KS5cbiAgaWYgKHR5cGVvZiAvLi8gIT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgSW50OEFycmF5ICE9ICdvYmplY3QnKSB7XG4gICAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nIHx8IGZhbHNlO1xuICAgIH07XG4gIH1cblxuICAvLyBJcyBhIGdpdmVuIG9iamVjdCBhIGZpbml0ZSBudW1iZXI/XG4gIF8uaXNGaW5pdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gaXNGaW5pdGUob2JqKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChvYmopKTtcbiAgfTtcblxuICAvLyBJcyB0aGUgZ2l2ZW4gdmFsdWUgYE5hTmA/IChOYU4gaXMgdGhlIG9ubHkgbnVtYmVyIHdoaWNoIGRvZXMgbm90IGVxdWFsIGl0c2VsZikuXG4gIF8uaXNOYU4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gXy5pc051bWJlcihvYmopICYmIG9iaiAhPT0gK29iajtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cbiAgXy5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBCb29sZWFuXSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBlcXVhbCB0byBudWxsP1xuICBfLmlzTnVsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSB1bmRlZmluZWQ/XG4gIF8uaXNVbmRlZmluZWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XG4gIH07XG5cbiAgLy8gU2hvcnRjdXQgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBwcm9wZXJ0eSBkaXJlY3RseVxuICAvLyBvbiBpdHNlbGYgKGluIG90aGVyIHdvcmRzLCBub3Qgb24gYSBwcm90b3R5cGUpLlxuICBfLmhhcyA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUnVuIFVuZGVyc2NvcmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0c1xuICAvLyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJvb3QuXyA9IHByZXZpb3VzVW5kZXJzY29yZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBLZWVwIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBhcm91bmQgZm9yIGRlZmF1bHQgaXRlcmF0ZWVzLlxuICBfLmlkZW50aXR5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLy8gUHJlZGljYXRlLWdlbmVyYXRpbmcgZnVuY3Rpb25zLiBPZnRlbiB1c2VmdWwgb3V0c2lkZSBvZiBVbmRlcnNjb3JlLlxuICBfLmNvbnN0YW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfTtcblxuICBfLm5vb3AgPSBmdW5jdGlvbigpe307XG5cbiAgXy5wcm9wZXJ0eSA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT0gbnVsbCA/IHZvaWQgMCA6IG9ialtrZXldO1xuICAgIH07XG4gIH07XG5cbiAgLy8gR2VuZXJhdGVzIGEgZnVuY3Rpb24gZm9yIGEgZ2l2ZW4gb2JqZWN0IHRoYXQgcmV0dXJucyBhIGdpdmVuIHByb3BlcnR5LlxuICBfLnByb3BlcnR5T2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09IG51bGwgPyBmdW5jdGlvbigpe30gOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBwcmVkaWNhdGUgZm9yIGNoZWNraW5nIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZiBcbiAgLy8gYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ubWF0Y2hlciA9IF8ubWF0Y2hlcyA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgYXR0cnMgPSBfLmV4dGVuZE93bih7fSwgYXR0cnMpO1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBfLmlzTWF0Y2gob2JqLCBhdHRycyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cbiAgXy50aW1lcyA9IGZ1bmN0aW9uKG4sIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIGFjY3VtID0gQXJyYXkoTWF0aC5tYXgoMCwgbikpO1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIGFjY3VtW2ldID0gaXRlcmF0ZWUoaSk7XG4gICAgcmV0dXJuIGFjY3VtO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gbWluIGFuZCBtYXggKGluY2x1c2l2ZSkuXG4gIF8ucmFuZG9tID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgIG1heCA9IG1pbjtcbiAgICAgIG1pbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBtaW4gKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICB9O1xuXG4gIC8vIEEgKHBvc3NpYmx5IGZhc3Rlcikgd2F5IHRvIGdldCB0aGUgY3VycmVudCB0aW1lc3RhbXAgYXMgYW4gaW50ZWdlci5cbiAgXy5ub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH07XG5cbiAgIC8vIExpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXG4gIHZhciBlc2NhcGVNYXAgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiN4Mjc7JyxcbiAgICAnYCc6ICcmI3g2MDsnXG4gIH07XG4gIHZhciB1bmVzY2FwZU1hcCA9IF8uaW52ZXJ0KGVzY2FwZU1hcCk7XG5cbiAgLy8gRnVuY3Rpb25zIGZvciBlc2NhcGluZyBhbmQgdW5lc2NhcGluZyBzdHJpbmdzIHRvL2Zyb20gSFRNTCBpbnRlcnBvbGF0aW9uLlxuICB2YXIgY3JlYXRlRXNjYXBlciA9IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciBlc2NhcGVyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgIHJldHVybiBtYXBbbWF0Y2hdO1xuICAgIH07XG4gICAgLy8gUmVnZXhlcyBmb3IgaWRlbnRpZnlpbmcgYSBrZXkgdGhhdCBuZWVkcyB0byBiZSBlc2NhcGVkXG4gICAgdmFyIHNvdXJjZSA9ICcoPzonICsgXy5rZXlzKG1hcCkuam9pbignfCcpICsgJyknO1xuICAgIHZhciB0ZXN0UmVnZXhwID0gUmVnRXhwKHNvdXJjZSk7XG4gICAgdmFyIHJlcGxhY2VSZWdleHAgPSBSZWdFeHAoc291cmNlLCAnZycpO1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHN0cmluZyA9PSBudWxsID8gJycgOiAnJyArIHN0cmluZztcbiAgICAgIHJldHVybiB0ZXN0UmVnZXhwLnRlc3Qoc3RyaW5nKSA/IHN0cmluZy5yZXBsYWNlKHJlcGxhY2VSZWdleHAsIGVzY2FwZXIpIDogc3RyaW5nO1xuICAgIH07XG4gIH07XG4gIF8uZXNjYXBlID0gY3JlYXRlRXNjYXBlcihlc2NhcGVNYXApO1xuICBfLnVuZXNjYXBlID0gY3JlYXRlRXNjYXBlcih1bmVzY2FwZU1hcCk7XG5cbiAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBgcHJvcGVydHlgIGlzIGEgZnVuY3Rpb24gdGhlbiBpbnZva2UgaXQgd2l0aCB0aGVcbiAgLy8gYG9iamVjdGAgYXMgY29udGV4dDsgb3RoZXJ3aXNlLCByZXR1cm4gaXQuXG4gIF8ucmVzdWx0ID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgZmFsbGJhY2spIHtcbiAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlID0gZmFsbGJhY2s7XG4gICAgfVxuICAgIHJldHVybiBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgaW50ZWdlciBpZCAodW5pcXVlIHdpdGhpbiB0aGUgZW50aXJlIGNsaWVudCBzZXNzaW9uKS5cbiAgLy8gVXNlZnVsIGZvciB0ZW1wb3JhcnkgRE9NIGlkcy5cbiAgdmFyIGlkQ291bnRlciA9IDA7XG4gIF8udW5pcXVlSWQgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICB2YXIgaWQgPSArK2lkQ291bnRlciArICcnO1xuICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xuICB9O1xuXG4gIC8vIEJ5IGRlZmF1bHQsIFVuZGVyc2NvcmUgdXNlcyBFUkItc3R5bGUgdGVtcGxhdGUgZGVsaW1pdGVycywgY2hhbmdlIHRoZVxuICAvLyBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICBldmFsdWF0ZSAgICA6IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgaW50ZXJwb2xhdGUgOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcbiAgICBlc2NhcGUgICAgICA6IC88JS0oW1xcc1xcU10rPyklPi9nXG4gIH07XG5cbiAgLy8gV2hlbiBjdXN0b21pemluZyBgdGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxuICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzXG4gIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxuICB2YXIgbm9NYXRjaCA9IC8oLileLztcblxuICAvLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuICAvLyBzdHJpbmcgbGl0ZXJhbC5cbiAgdmFyIGVzY2FwZXMgPSB7XG4gICAgXCInXCI6ICAgICAgXCInXCIsXG4gICAgJ1xcXFwnOiAgICAgJ1xcXFwnLFxuICAgICdcXHInOiAgICAgJ3InLFxuICAgICdcXG4nOiAgICAgJ24nLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICB2YXIgZXNjYXBlciA9IC9cXFxcfCd8XFxyfFxcbnxcXHUyMDI4fFxcdTIwMjkvZztcblxuICB2YXIgZXNjYXBlQ2hhciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdO1xuICB9O1xuXG4gIC8vIEphdmFTY3JpcHQgbWljcm8tdGVtcGxhdGluZywgc2ltaWxhciB0byBKb2huIFJlc2lnJ3MgaW1wbGVtZW50YXRpb24uXG4gIC8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcbiAgLy8gYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gIC8vIE5COiBgb2xkU2V0dGluZ3NgIG9ubHkgZXhpc3RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHRleHQsIHNldHRpbmdzLCBvbGRTZXR0aW5ncykge1xuICAgIGlmICghc2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MpIHNldHRpbmdzID0gb2xkU2V0dGluZ3M7XG4gICAgc2V0dGluZ3MgPSBfLmRlZmF1bHRzKHt9LCBzZXR0aW5ncywgXy50ZW1wbGF0ZVNldHRpbmdzKTtcblxuICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxuICAgIHZhciBtYXRjaGVyID0gUmVnRXhwKFtcbiAgICAgIChzZXR0aW5ncy5lc2NhcGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcbiAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XG5cbiAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCI7XG4gICAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUsIGludGVycG9sYXRlLCBldmFsdWF0ZSwgb2Zmc2V0KSB7XG4gICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKGVzY2FwZXIsIGVzY2FwZUNoYXIpO1xuICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBlc2NhcGUgKyBcIikpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBpbnRlcnBvbGF0ZSArIFwiKSk9PW51bGw/Jyc6X190KStcXG4nXCI7XG4gICAgICB9IGVsc2UgaWYgKGV2YWx1YXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZSArIFwiXFxuX19wKz0nXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkb2JlIFZNcyBuZWVkIHRoZSBtYXRjaCByZXR1cm5lZCB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IG9mZmVzdC5cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcbiAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cbiAgICBpZiAoIXNldHRpbmdzLnZhcmlhYmxlKSBzb3VyY2UgPSAnd2l0aChvYmp8fHt9KXtcXG4nICsgc291cmNlICsgJ31cXG4nO1xuXG4gICAgc291cmNlID0gXCJ2YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4sXCIgK1xuICAgICAgXCJwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xcblwiICtcbiAgICAgIHNvdXJjZSArICdyZXR1cm4gX19wO1xcbic7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIHJlbmRlciA9IG5ldyBGdW5jdGlvbihzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJywgJ18nLCBzb3VyY2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSwgXyk7XG4gICAgfTtcblxuICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cbiAgICB2YXIgYXJndW1lbnQgPSBzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJztcbiAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIGFyZ3VtZW50ICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfTtcblxuICAvLyBBZGQgYSBcImNoYWluXCIgZnVuY3Rpb24uIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5jaGFpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpbnN0YW5jZSA9IF8ob2JqKTtcbiAgICBpbnN0YW5jZS5fY2hhaW4gPSB0cnVlO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICAvLyBPT1BcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG4gIC8vIElmIFVuZGVyc2NvcmUgaXMgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIGl0IHJldHVybnMgYSB3cmFwcGVkIG9iamVjdCB0aGF0XG4gIC8vIGNhbiBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgdGhlXG4gIC8vIHVuZGVyc2NvcmUgZnVuY3Rpb25zLiBXcmFwcGVkIG9iamVjdHMgbWF5IGJlIGNoYWluZWQuXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnRpbnVlIGNoYWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzLlxuICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24oaW5zdGFuY2UsIG9iaikge1xuICAgIHJldHVybiBpbnN0YW5jZS5fY2hhaW4gPyBfKG9iaikuY2hhaW4oKSA6IG9iajtcbiAgfTtcblxuICAvLyBBZGQgeW91ciBvd24gY3VzdG9tIGZ1bmN0aW9ucyB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubWl4aW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICBfLmVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBfW25hbWVdID0gb2JqW25hbWVdO1xuICAgICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fd3JhcHBlZF07XG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLCBmdW5jLmFwcGx5KF8sIGFyZ3MpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQWRkIGFsbCBvZiB0aGUgVW5kZXJzY29yZSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICBfLm1peGluKF8pO1xuXG4gIC8vIEFkZCBhbGwgbXV0YXRvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIF8uZWFjaChbJ3BvcCcsICdwdXNoJywgJ3JldmVyc2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl93cmFwcGVkO1xuICAgICAgbWV0aG9kLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICAgIGlmICgobmFtZSA9PT0gJ3NoaWZ0JyB8fCBuYW1lID09PSAnc3BsaWNlJykgJiYgb2JqLmxlbmd0aCA9PT0gMCkgZGVsZXRlIG9ialswXTtcbiAgICAgIHJldHVybiByZXN1bHQodGhpcywgb2JqKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cbiAgXy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBQcm92aWRlIHVud3JhcHBpbmcgcHJveHkgZm9yIHNvbWUgbWV0aG9kcyB1c2VkIGluIGVuZ2luZSBvcGVyYXRpb25zXG4gIC8vIHN1Y2ggYXMgYXJpdGhtZXRpYyBhbmQgSlNPTiBzdHJpbmdpZmljYXRpb24uXG4gIF8ucHJvdG90eXBlLnZhbHVlT2YgPSBfLnByb3RvdHlwZS50b0pTT04gPSBfLnByb3RvdHlwZS52YWx1ZTtcbiAgXG4gIF8ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICcnICsgdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBBTUQgcmVnaXN0cmF0aW9uIGhhcHBlbnMgYXQgdGhlIGVuZCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIEFNRCBsb2FkZXJzXG4gIC8vIHRoYXQgbWF5IG5vdCBlbmZvcmNlIG5leHQtdHVybiBzZW1hbnRpY3Mgb24gbW9kdWxlcy4gRXZlbiB0aG91Z2ggZ2VuZXJhbFxuICAvLyBwcmFjdGljZSBmb3IgQU1EIHJlZ2lzdHJhdGlvbiBpcyB0byBiZSBhbm9ueW1vdXMsIHVuZGVyc2NvcmUgcmVnaXN0ZXJzXG4gIC8vIGFzIGEgbmFtZWQgbW9kdWxlIGJlY2F1c2UsIGxpa2UgalF1ZXJ5LCBpdCBpcyBhIGJhc2UgbGlicmFyeSB0aGF0IGlzXG4gIC8vIHBvcHVsYXIgZW5vdWdoIHRvIGJlIGJ1bmRsZWQgaW4gYSB0aGlyZCBwYXJ0eSBsaWIsIGJ1dCBub3QgYmUgcGFydCBvZlxuICAvLyBhbiBBTUQgbG9hZCByZXF1ZXN0LiBUaG9zZSBjYXNlcyBjb3VsZCBnZW5lcmF0ZSBhbiBlcnJvciB3aGVuIGFuXG4gIC8vIGFub255bW91cyBkZWZpbmUoKSBpcyBjYWxsZWQgb3V0c2lkZSBvZiBhIGxvYWRlciByZXF1ZXN0LlxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKCd1bmRlcnNjb3JlJywgW10sIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF87XG4gICAgfSk7XG4gIH1cbn0uY2FsbCh0aGlzKSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGpRdWVyeTtcbiJdfQ==
